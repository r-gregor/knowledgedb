filename: nas-installing-debian-on-usb-stick-for-terramaster-nas-20260121.txt
https://lovergine.com/installing-debian-on-a-usb-stick-for-a-terramaster-nas.html

Installing Debian on a USB stick for a Terramaster NAS
October 15, 2025

   I recently bought a basic NAS for home use. The NAS is a nice Terramaster F2-425, which is a very
   basic RAID1-only NAS with a decent CPU and 2.5Gb network. Terramaster allows users to either use its
   custom Linux-based TOS or install any other operating system supported by the x86_64-based platform.
   Note that this model does not mount any NVME unit for the OS, as for the F2-424.

   Common choices include TrueNas, Proxmox, or any other Linux-based distribution. My choice has been a
   plain Debian stable distribution because I do not have special requirements and prefer a lightweight
   CLI-only solution over a dashboard. The F2-425 does not have NVME cards, only regular HDDs/SSDs.
   However, when installing an independent OS, as in my case, you can immediately use an external USB
   stick for the system, and dedicate HDDs to data. The unit even has a tiny (264MB) internal USB stick
   for installing TOS, but I simply used a decent 16GB SanDisk thumb drive. The clear advantage is the
   possibility of having the base system and data perfectly separated, and multiple copies of the stick
   for safety.

   Of course, the installation of such a system can be done without using the Debian installer at all,
   so I'm describing here how to perform such an installation for my future reference and for other
   geeks. Of course, you need a running Linux system with debootstrap installed. The process involves
   partitioning the stick in GPT mode, installing the base system and EFI, and configuring the system to
   finalize a bootable system with the necessary software to connect the NAS to the network, including
   OpenSSH.

   Note that the 2.5 Gb Ethernet is a RealTek, so a firmware blob (firmware-realtek package on Trixie)
   is required to properly work with that. Alternatively, another of the USB ports could also be used to
   add a wireless connection. The OS stick could be simply mounted on the internal port, but it requires
   opening the chassis for that and using a tiny stick.

   At power-on, the internal TOS dongle automagically boots up, so connecting an HDMI display and a
   keyboard is required to change the setup to boot the Debian EFI image on the stick. On F2-425, press
   the <F12> key to access the AMI setup and change boot priorities. There are always slight differences
   among AMI BIOS setups, so it is required to find the right key to access settings and change boot
   options.

   Let's consider /dev/sde as the name of the USB stick device on the host where it will be prepared. A
   GPT partition can be created via GNU parted, as follows:

$> parted /dev/sde              # to create EFI and root primary partition
$> partprobe --summary /dev/sde
$> sfdisk -l /dev/sde
$> mkfs.vfat -F 32 /dev/sde1
$> mkswap /dev/sde2
$> mkfs.ext4 /dev/sde3

   Once done, installing the base system is immediate.
$> mount /dev/sde3 /mnt
$> mount /dev/sde1 /mnt/boot/efi
$> debootstrap trixie /mnt

$> mount -o bind /dev /mnt/dev
$> mount -t devpts devpts /mnt/dev/pts
$> mount -t proc proc /mnt/proc
$> mount -t sysfs sysfs /sys /mnt/sys
$> mount -t tmpfs run /mnt/run

$> cp /etc/apt/sources.d/debian.sources /mnt/etc/apt/sources.d/.
$> cp /etc/resolv.conf /mnt/etc/.

$> echo "nas" > /mnt/etc/hostname
$> sed -i -e 's/localhost$/localhost\n127.0.0.1\tnas/' /mnt/etc/hosts

$> rootfs=$(blkid /dev/sde | grep TYPE=\"ext4\"|awk '{print $2}'|cut -d\" -f2)
$> vfat=$(blkid /dev/sde|grep TYPE=\"vfat\"|awk '{print $2}'|cut -d\" -f2)
$> swap=$(blkid /dev/sde|grep TYPE=\"swap\"|awk '{print $2}'|cut -d\" -f2)

$> cat >/mnt/etc/fstab <<EOF
$> UUID=$rootfs / ext4 noatime,errors=remount-ro 0 1
$> UUID=$vfat /boot/efi vfat noatime,umask=0077 0 1
$> UUID=$swap none swap sw 0 0
$> EOF

$> chroot /mnt
$> apt update
$> apt upgrade -y
$> apt install grub-efi-amd64 linux-image-amd64 ssh \
        firmware-misc-nonfree \
        firmware-realtek xfsprogs rsync pmount \
        gddrescue screen util-linux-extra bash-completion \
        mdadm  parted smartmontools htop ntp unattended-upgrades sudo
$> useradd -m -G sudo -s /bin/bash -C 'Your Name' your_username
$> passwd your_username
$> adduser your_username plugdev
$> apt install tzdata locales
$> dpkg-reconfigure locales
$> grub-install --target=x86_64-efi --force-extra-removable /dev/sde
$> update-initramfs -u
$> apt clean
$> exit # leave the chroot
$> umount /mnt/run
$> umount /mnt/sys/firmware/efi/efivars
$> umount /mnt/sys
$> umount /mnt/proc
$> umount /mnt/dev/pts
$> umount /mnt/dev

   Note that required HDDs can be easily installed later. I manually configured the two disks with GNU
   parted for a GPT Linux RAID partition. After booting with the stick, a simple install of the md array
   support suffices. Typically, the USB stick runs as /dev/sdd

$> sudo mdadm --create /dev/md0 --level=1 --raid-devices=2 /dev/sda1 /dev/sdb1
$> mkfs.xfs /dev/md0
$> mkdir /data
$> data=$(blkid /dev/md0|grep TYPE=\"xfs\"|awk '{print $2}'|cut -d\" -f2)
$> echo "UUID=$data /data xfs defaults 1 1" >>/etc/fstab

   In order to allow shutting down by pressing the power button, it is required to configure
   systemd-logind as follows.

$> sed -i -e 's/^#HandlePowerKey=poweroff'/HandlePowerKey=poweroff/ \
       -e 's/^#HandlePowerKeyLongPress=ignore/HandlePowerKeyLongPress=ignore/ \
    /etc/systemd/logind.conf

$> systemctl restart systemd-logind.service

   It could also be a good idea to stop the periodic auto-scan on the RAID volume for big disks, which
   can take ages to run.

$> sed -i -e 's/^AUTOCHECK=true/AUTOCHECK=false/' /etc/default/mdadm
$> systemctl restart mdmonitor.service

   The network configuration depends definitively on the type of connection used and the home network
   setup. In my case, the NAS uses a static IPv4 address, so it can be configured through ifupdown, and
   it is only necessary to correctly write the /etc/network/interfaces for the enp1s0 Realtek 2.5Gb
   Ethernet interface. Not that it requires a non-free firmware blob to run.

   After the initial syncing, a series of software to better manage the NAS can be installed, but that
   is optional and can be the subject of a different post. For sure, for better convenience, a copy of
   the USB stick with the complete configuration is a good idea, to allow a fast recovery in case of
   failures.


---
https://lovergine.com/a-terramaster-nas-with-debian-take-two.html

A Terramaster NAS with Debian, take two.
January 19, 2026

   After experimenting at home, the very first professional-grade NAS from Terramaster arrived at work,
   too, with 12 HDD bays and possibly a pair of M2s. NVME cards. In this case, I again installed a plain
   Debian distribution, but HDD monitoring required some configuration adjustments to run smartd
   properly.

   A decent approach to data safety is to run regularly scheduled short and long SMART tests on all
   disks to detect potential damage. Running such tests on all disks at once isn't ideal, so I set up a
   script to create a staggered configuration and test multiple groups of disks at different times. Note
   that it is mandatory to read the devices at each reboot because their names and order can change.

   Of course, the same principle (short/long test at regular intervals along the week) should be applied
   for a simpler configuration, as in the case of my home NAS with a pair of RAID1 devices.

   What follows is a simple script to create a staggered smartd.conf at boot time:

<code>
#!/bin/bash
#
# Save this as /usr/local/bin/create-smartd-conf.sh
#
# Dynamically generate smartd.conf with staggered SMART test scheduling
# at boot time based on discovered ATA devices

# HERE IS A LIST OF DIRECTIVES FOR THIS CONFIGURATION FILE.
# PLEASE SEE THE smartd.conf MAN PAGE FOR DETAILS
#
#   -d TYPE Set the device type: ata, scsi[+TYPE], nvme[,NSID],
#           sat[,auto][,N][+TYPE], usbcypress[,X], usbjmicron[,p][,x][,N],
#           usbprolific, usbsunplus, sntasmedia, sntjmicron[,NSID], sntrealtek,
#           ... (platform specific)
#   -T TYPE Set the tolerance to one of: normal, permissive
#   -o VAL  Enable/disable automatic offline tests (on/off)
#   -S VAL  Enable/disable attribute autosave (on/off)
#   -n MODE No check if: never, sleep[,N][,q], standby[,N][,q], idle[,N][,q]
#   -H      Monitor SMART Health Status, report if failed
#   -s REG  Do Self-Test at time(s) given by regular expression REG
#   -l TYPE Monitor SMART log or self-test status:
#           error, selftest, xerror, offlinests[,ns], selfteststs[,ns]
#   -l scterc,R,W  Set SCT Error Recovery Control
#   -e      Change device setting: aam,[N|off], apm,[N|off], dsn,[on|off],
#           lookahead,[on|off], security-freeze, standby,[N|off], wcache,[on|off]
#   -f      Monitor 'Usage' Attributes, report failures
#   -m ADD  Send email warning to address ADD
#   -M TYPE Modify email warning behavior (see man page)
#   -p      Report changes in 'Prefailure' Attributes
#   -u      Report changes in 'Usage' Attributes
#   -t      Equivalent to -p and -u Directives
#   -r ID   Also report Raw values of Attribute ID with -p, -u or -t
#   -R ID   Track changes in Attribute ID Raw value with -p, -u or -t
#   -i ID   Ignore Attribute ID for -f Directive
#   -I ID   Ignore Attribute ID for -p, -u or -t Directive
#   -C ID[+] Monitor [increases of] Current Pending Sectors in Attribute ID
#   -U ID[+] Monitor [increases of] Offline Uncorrectable Sectors in Attribute ID
#   -W D,I,C Monitor Temperature D)ifference, I)nformal limit, C)ritical limit
#   -v N,ST Modifies labeling of Attribute N (see man page)
#   -P TYPE Drive-specific presets: use, ignore, show, showall
#   -a      Default: -H -f -t -l error -l selftest -l selfteststs -C 197 -U 198
#   -F TYPE Use firmware bug workaround:
#           none, nologdir, samsung, samsung2, samsung3, xerrorlba
#   -c i=N  Set interval between disk checks to N seconds
#    #      Comment: text after a hash sign is ignored
#    \      Line continuation character
# Attribute ID is a decimal integer 1 <= ID <= 255
# except for -C and -U, where ID = 0 turns them off.

set -euo pipefail

# Test schedule configuration
BASE_SCHEDULE="L/../../6"  # Long test on Saturdays
TEST_HOURS=(01 03 05 07)   # 4 time slots: 1am, 3am, 5am, 7am

DEVICES_PER_GROUP=3

main() {
	# Get array of device names (e.g., sda, sdb, sdc)
	mapfile -t devices < <(ls -l /dev/disk/by-id/ | grep ata | awk '{print $11}' | grep sd | cut -d/ -f3 | \
	sort -u)

	if [[ ${#devices[@]} -eq 0 ]]; then
		exit 1
	fi

	# Start building config file
	cat << EOF
# smartd.conf - Auto-generated at boot
# Generated: $(date '+%Y-%m-%d %H:%M:%S')
#
# Staggered SMART test scheduling to avoid concurrent disk load
# Long tests run on Saturdays at different times per group
#
EOF

	# Process devices into groups
	local group=0
	local count_in_group=0

	for i in "${!devices[@]}"; do
		local dev="${devices[$i]}"
		local hour="${TEST_HOURS[$group]}"

		# Add group header at start of each group
		if [[ $count_in_group -eq 0 ]]; then
			echo ""
			echo "# Group $((group + 1)) - Tests at ${hour}:00 on Saturdays"
		fi

		# Add device entry
		# echo "/dev/${dev} -a -o on -S on -s (${BASE_SCHEDULE}/${hour}) -m root"
		echo "/dev/${dev} -a -o on -S on -s (L/../../6/${hour}) -s (S/../.././$(((hour + 12) % 24))) -m root"

		# Move to next group when current group is full
		count_in_group=$((count_in_group + 1))
		if [[ $count_in_group -ge $DEVICES_PER_GROUP ]]; then
			count_in_group=0
			group=$(((group + 1) % ${#TEST_HOURS[@]}))
		fi
	done
}

main "$@"
</code>

   To run such a script at boot, add a unit file to the systemd configuration.
$> sudo systemctl edit --full /etc/systemd/system/regenerate-smartd-conf.service
$> sudo systemctl enable regenerate-smartd-conf.service

   Where the unit service is the following:

[Unit]
Description=Generate smartd.conf with staggered SMART test scheduling
# Wait for all local filesystems and udev device detection
After=local-fs.target systemd-udev-settle.service
Before=smartd.service
Wants=systemd-udev-settle.service
DefaultDependencies=no

[Service]
Type=oneshot
# Only generate the config file, don't touch smartd here
ExecStart=/bin/bash -c '/usr/local/bin/create-smartd-config.sh > /etc/smartd.conf'
StandardOutput=journal
StandardError=journal
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target


---

