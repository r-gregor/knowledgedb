filename: functions-vs-methods-multif-20251204.txt
https://www.codecademy.com/article/method-vs-function-difference

Function vs Method: Everything You Need to Know

   The main difference between a function and a method: Functions are standalone blocks of code that can
   be called independently, while methods are functions that belong to objects or classes. Both perform
   tasks, but the methods are tied to the data they operate on.

   This guide explains the key differences between functions and methods in programming with
   practical examples.

Method vs function: The key differences
   The key difference between methods and functions lies in where they live and how they're called. This
   table summarizes the key differences between a function and a method:

   ------------------------------------------------------------------------------------------------
   Feature            Function                  Method
   ------------------------------------------------------------------------------------------------
   Where it lives     On its own                Inside a data structure (like an object or a class)
   How it's called    Just its name             Object name + dot operator + method name
   Binding to data    No                        Yes, it operates on the data it's part of
   Used for           General-purpose actions   Object-specific behaviors
   Container needed   No                        Yes
   ------------------------------------------------------------------------------------------------

   So, a key takeaway is that:
     * Functions live on their own and can be called directly
     * Methods live inside objects and are called through the object

   Now let's explore each concept in detail.

What is a function in programming?
   Think of a function like a coffee machine. You press a button, it takes your input (coffee type),
   runs a set of steps (grinds beans, brews water), and gives you a nice hot cup of coffee. Just like
   that, in programming, a function takes input, does some work, and returns output.

   It's a reusable block of code that helps avoid repeating code. You define it once and use it as many
   times as you want with different inputs if needed. Let's implement this function in JavaScript:

function makeCoffee(type) {
	console.log("Here is your " + type + " coffee!");
}
makeCoffee("Espresso");
makeCoffee("Latte");

   The output generated by this code will be:

   Here is your Espresso coffee!
   Here is your Latte coffee!

   In this code, we:
     * Defined a function using the function keyword, and the name of this function is makeCoffee. It
       takes one input: type, also called parameter.
     * We print a message inside the function using console.log(). The message changes depending on the
       type of coffee you pass.
     * We call the function twice: once with "Espresso" and once with "Latte". These values are termed
       as arguments

   The key advantages of a function are that it saves time, reduces repetition, and makes code easier to
   manage. Functions, when tied to an object, become methods. So, let's understand them in detail.

What is a method in programming?
   A method is just a function that lives inside an object. It does everything a function does, but it's
   tied to the object it belongs to.

   Imagine you have a friend named Alex, and Alex can speak.
     * "Speak" is something Alex knows how to do, it's a method.
     * You can't call speak() on its own, you have to say Alex.speak() because it belongs to Alex.

   Let's implement this method in JavaScript:

const person = {
	speak: function() {
		console.log("Hello, I can talk!");
	}
};
person.speak();

   This code will produce the following output:

   Hello, I can talk!

   In this code:
     * We created an object called person.
     * Inside it, we defined a method called speak.
     * That method prints a message.
     * To run it, we call it person.speak() because the method belongs to the person object.

   Now that you know what functions and methods are, and how they differ, you have the foundation to use
   them confidently in your programs.

Conclusion
   The fundamental difference between method and function comes down to context and ownership. Functions
   are independent blocks of code that can be called directly and work with any data you pass to them.
   Methods, on the other hand, are functions tied to objects and operate on the specific data within
   those objects.

   Understanding this method vs function distinction is crucial whether you're working with APIs,
   building object-oriented applications, or just writing clean, organized code. Remember: if it's
   called on its own, it's a function. If it's called through an object using dot notation, it's a
   method


---
https://stillat.com/blog/2014/07/19/procedure-vs-function-vs-method-vs

Procedure vs. Function vs. Method vs. ?
July 19, 2014

   The field of programming and computer science is awash in technical terms with definitions for those
   terms that are only slightly different from each other. A good example of terms like this are
   procedure, function, method and the anonymous function.

   With the exception of the anonymous function all of these terms are, for the most part, used
   interchangeably. However, they do have slightly different definitions and ultimately mean different
   things.

   Before we get into what makes each term different, we should talk about what each of these things are
   actually doing, even if they do in a different way. Each of the above terms in programming is
   essentially a programming fragment, or a piece of a program that exists on its own. Let's look at
   this example:

#include <stdio.h>

int main() {
	float base = 10;;
	float height = 20;;
	float area = ((base * height) / 2););
	printf( "The area of the triangle is %.2f\n", area );
}

   The above piece of code is a simple C function that calculates the area of a triangle and returns the
   following output:

   The area of the triangle is 100.00

   As it sits, the above code is fairly manageable. But what happens when we need to calculate the area
   of many triangles? We could do something like this:

#include <stdio.h>

int main() {
	// Triangle one.
	float base = 10;;
	float height = 20;;
	float area = ((base * height) / 2););

	// Triangle two.
	float base2 = 5;;
	float height2 = 120;;
	float area2 = ((base2 * height2) / 2););

	// ...potentially many other triangles...
	printf( "The area of the triangle is %.2f\n", area );
	printf( "The area of the triangle2 is %.2f\n", area2 );
}

   In all honesty, even that is slightly manageable. Let's say you work for a company that just
   calculates the areas of triangles. And you need to do it a lot in your program for some reason - the
   boss is addicted to triangles? Anyways, if you continued to calculate the area of a bunch of
   triangles like this, your team members will most likely hurt you. This is why we use functions - a
   kind of compiler/interpreter copy and paste trick:

#include <stdio.h>

float triangleArea(float base, float height) {
	// Calculate the area of a triangle and return it.
	return ((base * height) / 2););
}

int main() {
	printf( "The area of the triangle is %.2f\n", triangleArea(10, 20) );, 20) );) );
	printf( "The area of the triangle2 is %.2f\n", triangleArea(5, 120) );, 120) );) );
}

   The above code is significantly shorter, and it accomplishes the same exact thing. Most importantly -
   your co-workers probably won't hurt you! And if you ever need to change how the area of a triangle is
   calculated (maybe Heron of ALexandria had it wrong?) you can do it one spot and not have to worry
   about if you updated every possible place that you are calculating the area of a triangle! Win!

   Now, this example is using the area of triangles. A fairly trivial thing. The exact function doesn't
   matter; its the fact that we can use functions and function-like things to make code more
   maintainable and easier to read.

   Now, on to the rant!

Functions
   Let's start with functions, because that will flow better with the previous examples. When we wrote
   our triangleArea function, that really was a function. Functions return a value to whatever code that
   called it. In our above example, some code in the main() function calls our triangleArea function and
   gets handed back some floating point result.

   Summary: Function's return values.

Procedures
   Procedures are sort of like functions, in the fact that they are sort of a language copy and paste
   feature. The defining difference is that a procedure does not return a value. You can thing of it
   kind of like this: a function determines how something is done, and a procedure determines when
   something is done (since we are not returning a value).

   Let's look at this example in C:

   #include <stdio.h>

void sayHello() {
	printf("Hello\n");
}

int main() {
	sayHello();
}

   It is fairly simple. We just wrote a procedure that says Hello and then terminates. Nothing to major
   here, and we even define it like a function! Confusing!

   Summary: Procedures are like functions, but do not return a value, or alternatively, functions are
   procedures that define some process and return a value. Not a whole lof difference these days,
   really.

Methods
   Now we are on methods. And what an a mess we are about to get in. The term method falls out of
   object-oriented programming, of which we won't go into depth here. For now, an object is a collection
   of things that are related, or a program within a program, or a function on steroids.

   Let's look at this C++ code sample:

#include <iostream>
using namespace std;

class Triangle {
	float base, height;

	public:
	void setBase setBase(float);
	void setHeight setHeight(float);

	float area area() {
		return ((base * height) / 2);
	}

};

void Triangle::setBase Triangle::setBase(float b) {
	base = b;
}

void Triangle::setHeight Triangle::setHeight(float h) {
	height = h;
}

int main main() {

	Triangle tria;
	tria.setBase(10);
	tria.setHeight(20);

	cout << "Area of triangle: " << tria.area();
	return 0;
}

   Wow, that's a lengthy bit of code! What we are doing with it though is creating a class called
   Triangle. The triangle class appears to have three functions: setBase(float b), setHeight(float h)
   and area(). But wait! We are talking about a class here.

   Looking at this part of the code we can notice a few things:

int main main() {
	Triangle tria;
	tria.setBase(10);
	tria.setHeight(20);

	cout << "Area of triangle: " << tria.area();
	return 0;
}

   First thing, we are working with the Triangle class, which we are storing with the variable name
   tria. We call the setBase(float b), setHeight(float h) and area() on the variable tria. These are
   method calls. When we are concerned with object-oriented programming, methods are functions and
   procedures inside classes.

   Summary: Methods are functions and procedures that belong to classes and instances of those classes.

Anonymous Functions
   Again, we might be in a world of hurt here. Anonymous functions are a kind of different breed of
   functions. Let's look at an example in JavaScript (ECMAScript for you technical type):

(function() {
	console.log('Hello, world!');
})();

   The above code runs in the context of the web browser (so we can use the console features, and what
   not. But it doesn't have to). When this code is ran, it will write "Hello, world!" to the console.
   But we didn't explicitly call a function here. This a function without a name, an anonymous function.

   We could have written it like this if we wanted to do it without an anonymous function:

function helloWorld() {
	console.log('Hello, world!');
}

helloWorld();

   Both code samples accomplish the same exact thing. In the first one we don't define a name for the
   function, and we don't explicitly call it. In the second, we gave it a name helloWorld() and we had
   to explicitly call the function to get it to print Hello, world! to the console.

   Summary: Anonymous functions are simply functions or procedures that do not have a name.

Conclusion
   If you have stuck around this long, congratulations! Someone out there still as a lengthy attention
   span! As a reward, you now know the very subtle differences between functions, procedures, methods
   and anonymous functions. What you do with your new knowledge is up to you, but I wouldn't make a
   point of correcting everyone that happens to use them interchangeably - after all, the differences
   are small.

   The only exception to correcting people I would have to say is if they are writing a compiler,
   interpreter or crafting a programming language. If someone is doing those things then they really
   should know the difference, no matter how academic it may seem.


---
https://softwareengineering.stackexchange.com/questions/20909/method-vs-function-vs-procedure

Method vs Function vs Procedure

   Simple question, but I often hear these three terms defined with such ferocity, but which have been
   known to me to mean different things over the years.

   What are the "correct" definitions of "Procedures", "Methods", "Function", "Subroutines", etc?

***
   I'm going with a different answer here: practically speaking, there's really no difference, with the
   slight exception that "method" usually refers to a subroutine associated with an object in OO
   languages.

   The terms "procedure, function, subroutine, subprogram, and method" all really mean the same thing: a
   callable sub-program within a larger program. But it's difficult to come up with a definition that
   captures all variant usages of these terms, because they are not used consistently across programming
   languages or paradigms.

   You might say a function returns a value. Well, the following C function doesn't return a value:
void f() { return; }

   ... but I doubt you'd find anyone who would call it a procedure.

   Sure, in Pascal, procedures don't return values and functions return values, but that's merely a
   reflection of how Pascal was designed. In Fortran, a function returns a value, and a subroutine
   returns multiple values. Yet none of this really allows us to come up with a "universal" definition
   for these terms.

   In fact, the term "procedural programming" refers to a whole class of languages, including C, Fortran
   and Pascal, only one of which actually uses the term "procedure" to mean anything.

   So none of this is really consistent. The only exception is probably "method", which seems to be used
   almost entirely with OO languages, referring to a function that is associated with an object.
   Although, even this is not always consistent. C++, for example, usually uses the term "member
   function" rather than method, (even though the term "method" has crept into the C++ vernacular among
   programmers.)

   The point is, none of this is really consistent. It simply reflects the terminology employed by
   whatever languages are en vogue at the time.

***
   A function returns a value, but a procedure does not.

   A method is similar to a function, but is [DEL: internal to :DEL] part of a class. The term method is
   used almost exclusively in object-oriented programming.

***
   A function is something that takes a bunch of inputs and returns one or more values. If the returned
   values are entirely determined by the inputs, and the function doesn't have any side effects
   (logging, perhaps, or causing state changes outside itself), then it's called a pure function.

   A procedure is a function that doesn't return a value. In particular, this means that a procedure can
   only cause side effects. (That might include mutating an input parameter!)

   A method is a function that closes over a set of variables, that is, a closure. It takes zero or more
   input parameters, has access to this set of variables, and returns zero or more values. In OO
   languages these methods are attached to objects or classes.

   In most mainstream OO languages, those closed-over variables are called the member fields, or
   instance variables, of an object. A method can be a pure function, an impure function or a procedure.

   The latter definition leads to the object = struct + closures correspondence.

***
   Bruce has a good answer. I would add, semantically:
     * A procedure should "do something" to the arguments or cause some other side effect (e.g. printf)
     * A function should (a) answer a question about the arguments, or (b) compute a new value based on
       the arguments
     * A function method should answer a question about the state of the object
     * A procedure method should change the state of the object

***
   good detailed answers above; the short story is that they'll all flavors of subroutines; what is
   meant by each term will vary according to the programming language context

   in general, functions return a value, but they don't have to

   methods are a generic OOP terms at present

   in SQL, stored procedures have outputs but typically only return an error code, while user-defined
   functions must return a value (which may be a result-set)

   again, the precise difference between these terms depends on who you're talking to!


---
https://medium.com/predict/javascript-functions-vs-methods-and-other-helpful-tips-e58a621b1d27

JavaScript Functions vs Methods (and other helpful tips)
Mar 27, 2017

If you're coming to JavaScript after learning another backend language, you may get confused with some of the
JavaScript terminology - I was. While knowing every single term in the JavaScript vocabulary won't necessarily
improve your code, not knowing them may lead to awkward situations. Because of that, I've created this cheat
sheet to help you (and me) better understand some of the nuances when it comes to functions in JavaScript:

Functions vs. Methods
So what's the different between the two?

Methods have a "receiver" while functions do not.

This is not unique to JavaScript but it's still good to learn and remember. My background is in Ruby and I
rarely ever heard the term "function". It's all about those methods (besides procs and lambdas). I never
really understood the difference until I started learning JavaScript.

Also, this definition may not technically be true in JavaScript - and I'll show you why - but it's probably
the easiest way to think of it. If you are unaware of what a "receiver" is, look at the code snippet below:

someObject.someMethod()

In this context, the someObject is the receiver, while the someMethod is the method. Compare that with a
function invocation:

someFunction(arg)

Notice how there is no receiver. In JavaScript, functions are invoked without a receiver using the parens
syntax (). The receiver is what separates a function from a method.

Technicalities
While it may look like a function is invoked without a receiver in JavaScript, there's a gray area to that.
Whenever a function is declared on the global scope it becomes a property of the global object. In the
browser, the global object is the window:

function helloWorld() {
	console.log('hello world');
}
helloWorld();          // Logs 'hello world'
window.helloWorld();   // Also logs 'hello world'

As you can see in the last line, the window is the receiver of helloWorld which would make helloWorld a method
and not a function by my own definition. However, in JavaScript, it's still considered a function.

Another thing to note is you can easily turn a method into a function and vice-versa.

var object = {
	method: function() {
		console.log("Am I still a method?");
	}
};
object.method();             // method call
var func = object.method;
func();                      // now it is a function invocation

Function Declaration vs Function Expression

What's the difference?
If the line begins with the word "function" it's a declaration. Otherwise, it's an expression.

Here are some examples:

// This is a function declaration
function hello() {
	console.log('Hello World');
}

// This is a function expression
var hello = function() {
	console.log('Hello World');
};

// This is also a function expression.
(function() {
	console.log('Hello World');
})();

Notice in the last expression that the line started with ( and not function.

Implicit vs Explicit Function Context

What's the difference?
Explicit context is when the context is explicitly defined and passed in. Implicit context is when the context
is left off and the runtime interprets it.

And if you don't know what I mean by "context," I'm referring to whatever this equals when a function is
executed.

This might be harder to understand, so look at the code below for reference:

function context() {
	console.log('the context is ' + this);
}
var someObject = {};

context.call(someObject);
// Logs: 'the context is [object Object]'
// This is explicit context. The context is explicitly defined.

context();
// Logs: 'the context is [object Window]'
// This is implicit context. The context is not defined.

In the explicit context execution, we directly told the context function to use the someObject context.
Therefore, this was assigned to someObject, which is why it logged out the context is [object Object].

However, in the implicit execution, no context was given. And since functions are properties of the global
object, this will equal the global object. That's why it logged out the context is [object Window].

First-Class Functions vs Higher-Order Functions

What's the difference?
First class functions are treated like objects. Higher order functions either accept a function as an
argument, return a function, or both.

When I say first class functions are treated like objects, I mean that they have states and behaviors, and
they can be passed as arguments in functions and returned from functions - among other things. In this way,
higher order functions essentially use first order functions and are first order functions themselves.

Examples:

// Higher Order Function
function higher(callback) {  // first order function being passed in
	callback();
	return callback;           // first order function being returned.
}

var callback = higher(function() {
	console.log('Hello World');
});
// Logs: 'Hello World'

callback();
// Also logs: 'Hello World'

While first order functions and higher level functions are not necessarily related, it's hard to imagine a
programming language supporting one and not the other.

While this is by no means the entire list of things to know about JavaScript functions, I hope you can use it
as a handy reference guide. At the least it can be a nice beginner's reference for anyone just starting out in
JavaScript or anyone transferring from another backend language.

JavaScript has its quirks and flaws, but it's here to stay. All we can do is learn to love it. Happy
programming!



---
https://dev.to/msabir/method-vs-function-in-javascript-1emk

Method vs Function in Javascript

In Javascript every function is an object (A).
An Object is collection of {key:value} pair.

As per MDN:
	A method is a function which is a property of an object. There are two kind of methods: Instance Methods
	which are built-in tasks performed by an object instance, or Static Methods which are tasks that are
	called directly on an object constructor.

Values can be

*-> Primative: * Primative implies to data type such as number, string,boolean or can be another pair of
                 object.

-> Function: Since its property of an object, so function is called as Method .

So, does it means that every function is a method but every method is not a function ? No

-> If a function is within the lexical environment / environment of an object, then that function is termed as
   method, we can invoke that by OurObject.OurMethod() (B)

var OurObject = {
	name : "John snow",
	OurMethod: function someFun(paramA, paramB) {
		// some code..
	}

-> A pure function is, a function which have no object associated with it.

function func(param1, ...args) {
	// some code...
}

As per Point A, we are saying every function is an object in Javascript, so, a function within within a
function will be termed as method of that function.

From the book ** JavaScript Patterns by Stoyan Stefanov** covers your questions in detail. Here's a quote from
the book on this subject:

So it could happen that a function A, being an object, has properties and methods, one of which happens to
be another function B. Then B can accept a function C as an argument and, when executed, can return
another function D.

Lastly, I would like to give very basic example. Everyone knows that arrays have different methods.

EXACTLY, different METHODS not FUNCTIONS. Like push(), pop(),slice(),splice()`.

Why they are methods?
They are methods because this functions are an part of an object, so as per point B, There environment is
object, so they are termed as METHODS.

Cheers!!


---
https://stackoverflow.com/questions/8108688/in-python-when-should-i-use-a-function-instead-of-a-method

In Python, when should I use a function instead of a method?

   The Zen of Python states that there should only be one way to do things- yet frequently I run into
   the problem of deciding when to use a function versus when to use a method.

   Let's take a trivial example- a ChessBoard object. Let's say we need some way to get all the legal
   King moves available on the board. Do we write ChessBoard.get_king_moves() or
   get_king_moves(chess_board)?

   Here are some related questions I looked at:
     * [https://stackoverflow.com/q/2657627/577199]Why does python use 'magic methods'?
     * [https://stackoverflow.com/q/237128/577199]Is there a reason Python strings don't have a string length
       method?

   The answers I got were largely inconclusive:
Why does Python use methods for some functionality (e.g. list.index()) but functions for other (e.g.
len(list))?

     The major reason is history. Functions were used for those operations that were generic for a
     group of types and which were intended to work even for objects that didn't have methods at all
     (e.g. tuples). It is also convenient to have a function that can readily be applied to an
     amorphous collection of objects when you use the functional features of Python (map(), apply() et
     al).

     In fact, implementing len(), max(), min() as a built-in function is actually less code than
     implementing them as methods for each type. One can quibble about individual cases but it's a part
     of Python, and it's too late to make such fundamental changes now. The functions have to remain to
     avoid massive code breakage.

   While interesting, the above doesn't really say much as to what strategy to adopt.

     This is one of the reasons - with custom methods, developers would be free to choose a different
     method name, like getLength(), length(), getlength() or whatsoever. Python enforces strict naming
     so that the common function len() can be used.

   Slightly more interesting. My take is that functions are in a sense, the Pythonic version of
   interfaces.

   Lastly, [https://mail.python.org/pipermail/python-3000/2006-November/004643.html]from Guido himself:

     Talking about the Abilities/Interfaces made me think about some of our "rogue" special method
     names. In the Language Reference, it says, "A class can implement certain operations that are
     invoked by special syntax (such as arithmetic operations or subscripting and slicing) by defining
     methods with special names." But there are all these methods with special names like __len__ or
     __unicode__ which seem to be provided for the benefit of built-in functions, rather than for
     support of syntax. Presumably in an interface-based Python, these methods would turn into
     regularly-named methods on an ABC, so that __len__ would become

class container:
	...
	def len(self):
		raise NotImplemented

     Though, thinking about it some more, I don't see why all syntactic operations wouldn't just invoke
     the appropriate normally-named method on a specific ABC. "<", for instance, would presumably
     invoke "object.lessthan" (or perhaps "comparable.lessthan"). So another benefit would be the
     ability to wean Python away from this mangled-name oddness, which seems to me an HCI improvement.

     Hm. I'm not sure I agree (figure that :-).

     There are two bits of "Python rationale" that I'd like to explain first.

     First of all, I chose len(x) over x.len() for HCI reasons (def __len__() came much later). There
     are two intertwined reasons actually, both HCI:

     (a) For some operations, prefix notation just reads better than postfix -- prefix (and infix!)
     operations have a long tradition in mathematics which likes notations where the visuals help the
     mathematician thinking about a problem. Compare the easy with which we rewrite a formula like
     x*(a+b) into x*a + x*b to the clumsiness of doing the same thing using a raw OO notation.

     (b) When I read code that says len(x) I know that it is asking for the length of something. This
     tells me two things: the result is an integer, and the argument is some kind of container. To the
     contrary, when I read x.len(), I have to already know that x is some kind of container
     implementing an interface or inheriting from a class that has a standard len(). Witness the
     confusion we occasionally have when a class that is not implementing a mapping has a get() or
     keys() method, or something that isn't a file has a write() method.

     Saying the same thing in another way, I see 'len' as a built-in operation. I'd hate to lose that.
     I can't say for sure whether you meant that or not, but 'def len(self): ...' certainly sounds like
     you want to demote it to an ordinary method. I'm strongly -1 on that.

     The second bit of Python rationale I promised to explain is the reason why I chose special methods
     to look __special__ and not merely special. I was anticipating lots of operations that classes
     might want to override, some standard (e.g. __add__ or __getitem__), some not so standard (e.g.
     pickle's __reduce__ for a long time had no support in C code at all). I didn't want these special
     operations to use ordinary method names, because then pre-existing classes, or classes written by
     users without an encyclopedic memory for all the special methods, would be liable to accidentally
     define operations they didn't mean to implement, with possibly disastrous consequences. Ivan
     Krstić explained this more concise in his message, which arrived after I'd written all this up.

     --Guido van Rossum (home page: http://www.python.org/~guido/)

   My understanding of this is that in certain cases, prefix notation just makes more sense (ie,
   Duck.quack makes more sense than quack(Duck) from a linguistic standpoint.) and again, the functions
   allow for "interfaces".

   In such a case, my guess would be to implement get_king_moves based solely on Guido's first point.
   But that still leaves a lot of open questions regarding say, implementing a stack and queue class
   with similar push and pop methods- should they be functions or methods? (here I would guess
   functions, because I really want to signal a push-pop interface)

   TLDR: Can someone explain what the strategy for deciding when to use functions vs. methods should be?

***
   My general rule is this - is the operation performed on the object or by the object?

   if it is done by the object, it should be a member operation. If it could apply to other things too,
   or is done by something else to the object then it should be a function (or perhaps a member of
   something else).

   When introducing programming, it is traditional (albeit implementation incorrect) to describe objects
   in terms of real-world objects such as cars. You mention a duck, so let's go with that.

class duck:
	def __init__(self):pass
	def eat(self, o): pass
	def crap(self) : pass
	def die(self)
	...

   In the context of the "objects are real things" analogy, it is "correct" to add a class method for
   anything which the object can do. So say I want to kill off a duck, do I add a .kill() to the duck?
   No... as far as I know animals do not commit suicide. Therefore if I want to kill a duck I should do
   this:

def kill(o):
	if isinstance(o, duck):
		o.die()
	elif isinstance(o, dog):
		print "WHY????"
		o.die()
	elif isinstance(o, nyancat):
		raise Exception("NYAN "*9001)
	else:
	   print "can't kill it."

   Moving away from this analogy, why do we use methods and classes? Because we want to contain data and
   hopefully structure our code in a manner such that it will be reusable and extensible in the future.
   This brings us to the notion of encapsulation which is so dear to OO design.

   The encapsulation principal is really what this comes down to: as a designer you should hide
   everything about the implementation and class internals which it is not absolutely necessarily for
   any user or other developer to access. Because we deal with instances of classes, this reduces to
   "what operations are crucial on this instance". If an operation is not instance specific, then it
   should not be a member function.

   TL;DR: what @Bryan said. If it operates on an instance and needs to access data which is internal to
   the class instance, it should be a member function.

***
Use a class when you want to:
1) Isolate calling code from implementation details -- taking advantage of abstraction and encapsulation.
2) When you want to be substitutable for other objects -- taking advantage of polymorphism.
3) When you want to reuse code for similar objects -- taking advantage of inheritance.

Use a function for calls that make sense across many different object types -- for example, the builtin len
and repr functions apply to many kinds of objects.

That being said, the choice sometimes comes down to a matter of taste. Think in terms of what is most
convenient and readable for typical calls. For example, which would be better (x.sin()**2 + y.cos()**2).sqrt()
or sqrt(sin(x)**2 + cos(y)**2)?

***
I usually think of an object like a person.

Attributes are the person's name, height, shoe size, etc.

Methods and functions are operations that the person can perform.

If the operation could be done by just any ol' person, without requiring anything unique to this one specific
person (and without changing anything on this one specific person), then it's a function and should be written
as such.

If an operation is acting upon the person (e.g. eating, walking, ...) or requires something unique to this
person to get involved (like dancing, writing a book, ...), then it should be a method.

Of course, it is not always trivial to translate this into the specific object you're working with, but I find
it is a good way to think of it.

***
Generally I use classes to implement a logical set of capabilities for some thing, so that in the rest of my
program I can reason about the thing, not having to worry about all the little concerns that make up its
implementation.

Anything that's part of that core abstraction of "what you can do with a thing" should usually be a method.
This generally includes everything that can alter a thing, as the internal data state is usually considered
private and not part of the logical idea of "what you can do with a thing".

When you come to higher level operations, especially if they involve multiple things, I find they are usually
most naturally expressed as functions, if they can be built out of the public abstraction of a thing without
needing special access to the internals (unless they're methods of some other object). This has the big
advantage that when I decide to completely rewrite the internals of how my thing works (without changing the
interface), I just have a small core set of methods to rewrite, and then all the external functions written in
terms of those methods will Just Work. I find that insisting that all operations to do with class X are
methods on class X leads to over-complicated classes.

It depends on the code I'm writing though. For some programs I model them as a collection of objects whose
interactions give rise to the behavior of the program; here most important functionality is closely coupled to
a single object, and so is implemented in methods, with a scattering of utility functions. For other programs
the most important stuff is a set of functions that manipulate data, and classes are in use only to implement
the natural "duck types" that are manipulated by the functions.


---
https://dev.to/sharoztanveer/functions-vs-classes-when-to-use-which-and-why-48d6

Functions vs Classes: When to Use Which and Why?

One of the developers' most important decisions when writing code is whether to use functions or classes.
Choosing the wrong approach can lead to unnecessarily complex, difficult-to-maintain code, potentially
introducing bugs. While this might not result in catastrophic outcomes like sparking global conflict or
creating black holes, it could hinder your development process. So, let's dive into how to decide when to use
functions or classes to make your code cleaner, more maintainable, and less prone to errors.

Functions vs Classes: A Brief Overview
Before diving into the "when" and "why," let's clarify what functions and classes do.

Functions take input, process that input, and return a result. You can then pass that result to other
functions, allowing for a data flow-driven architecture. In functional programming languages like Haskell,
functions can be passed to and returned by other functions, making them flexible and action-oriented.
Classes, on the other hand, focus on structuring information. They encapsulate variables (data) into
objects, often forming hierarchies where objects can inherit properties from other objects. The methods in
these classes modify the state of these objects, making object-oriented programming (OOP) state-centric.

When to Use Functions
Functions shine when your code is more action-focused. For example, if you're processing data in a sequential
manner where the structure of the data isn't as critical as what you're doing with it, functions are usually
the better choice.

Imagine you're writing a script to process and analyze data from a weather dataset. The dataset contains
information like temperature, humidity, wind speed, and precipitation over a period of time, and your goal is
to identify trends, such as average temperatures over each season or the days with the highest precipitation.

In this case, organizing your code into functions would be the most straightforward and efficient approach.
You might have functions to load the dataset, calculate seasonal averages, and identify weather extremes. Each
function can handle a specific task: one for reading the CSV file, another for analyzing seasonal trends, and
one for outputting the results in a clean format.

Using classes in this context would probably add unnecessary complexity. The primary tasks are clear and don't
involve the kind of state management or complex relationships between data that would justify an
object-oriented approach. Each function is independent, modular, and focused on a specific job, which makes
the code easier to maintain and update if you need to tweak how the data is processed.

Moreover, testing is simpler when you use functions. Functions that don't modify the global state can be
tested in isolation, making it easier to verify the correctness of each component. This leads to more
reliable, testable code without the overhead of additional abstractions.

When to Use Classes
Classes, on the other hand, excel in scenarios where the code is more state-focused. This is especially true
when you need to model real-world objects or concepts. For example, a banking application that manages
multiple bank accounts would benefit from a class-based approach.

A BankAccount class could maintain an initial balance, and a transaction history, and provide methods for
deposits, withdrawals, and balance checks. Each instance of the BankAccount class would represent a separate
account with its state, making the use of OOP logical and efficient.

In such cases, trying to use functions instead of classes would make the code more cumbersome because the
concept of a "bank account" naturally involves a state - it's not just a sequence of actions. By structuring
your program with classes, you can more easily manage the state, encapsulate related behaviors, and reduce the
complexity that would arise from trying to pass state through functions.

Real-World Examples
Consider you're building a system to manage a library. You need to model books, members, and loans. Each of
these has distinct attributes and behaviors: books have titles and authors, members have names and membership
IDs, and loans have due dates and statuses. This is a great case for using object-oriented programming (OOP),
as classes can represent these entities with properties and methods to handle actions like checking out books
or renewing loans. OOP makes the system more intuitive and scalable as it reflects real-world relationships
between the objects.

On the other hand, not all problems require OOP. Imagine you're tasked with processing book return data to
calculate overdue fines. If the goal is simply to take a list of return dates, compare them to due dates, and
calculate the fines, functions might be a more suitable choice. Here, you don't need to create full classes
for books or members because you're just working with dates and numbers in a step-by-step process. Functions
would keep the code simple, reducing overhead, and allowing you to focus on the core task of processing
fines rather than managing the state of multiple objects.

Combining Functions and Classes
One of Python's strengths is the ability to seamlessly integrate functions and classes, allowing you to
leverage both as needed. For instance, you could create a class to represent a shopping cart, encapsulating
the properties of items and their quantities. At the same time, you could employ functions to handle specific
tasks, such as calculating the total price of items or applying discounts. This flexibility enables you to
choose the best approach for each task, whether it involves using a class, a function, or a combination of
both to achieve an efficient and organized solution.

Conclusion
Use functions when your code is action-driven and you're focusing on the flow of data.
Use classes when you're working with state and need to model real-world objects or concepts.

Ultimately, there's no one-size-fits-all solution. The best approach depends on the problem at hand. Don't
hesitate to experiment with different methods and combinations. Understanding when and why to use functions
versus classes will help you write cleaner, more maintainable code.

[Disclosure: This article is a collaborative effort, combining my own ideas with the assistance of ChatGPT
for enhanced articulation.]


---

