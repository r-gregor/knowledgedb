filename: wikipedia-base64-20251217.txt
[NEW: 20251217] https://en.wikipedia.org/wiki/Base64

Base64

Encoding for a sequence of byte values using 64 printable characters

Base64 is a binary-to-text encoding that uses 64 printable characters to represent each 6-bit segment of a
sequence of byte values. As for all binary-to-text encodings, Base64 encoding enables transmitting binary
data on a communication channel that only supports text.

When comparing the original data to the resulting encoded data, Base64 encoding increases the size by 33%
plus about 4% additional if inserting line breaks for typical line length.

The earliest uses of this encoding were for dial-up communication between systems running the same operating
system – for example, uuencode for UNIX and BinHex for the TRS-80 (later adapted for the Macintosh) – and
could therefore make more assumptions about what characters were safe to use. For instance, uuencode uses
uppercase letters, digits, and many punctuation characters, but no lowercase.

Applications
Notable applications of Base64:

Web pages
    Encoding as Base64 is prevalent on the World Wide Web where is it often used to embed binary data
    such as a digital image in text such as HTML and CSS.

E-mail attachment
    Base64 is widely used for sending e-mail attachments, because SMTP – in its original form – was designed
    to transport 7-bit ASCII characters only. Encoding an attachment as Base64 before sending, and then
    decoding when received, assures older SMTP servers correctly transmit messages with attached binary
    information.

Embed binary data in a text file
    For example, to include the data of an image in a script to avoid depending on external files.

Embed binary data in XML
    To embed binary data in an XML file, using a syntax similar to <data encoding="base64">...</data> e.g.
    favicons in Firefox's exported bookmarks.html.

Embed PDF file
    To embed a PDF file in an HTML page.

Embedded elements
    Although not part of the official specification for the SVG format, some viewers can interpret Base64
    when used for embedded elements, such as raster images inside SVG files.

Prevent delimiter collision
    To transmit and store text that might otherwise cause delimiter collision.

LDAP Data Interchange Format
    To encode character strings in LDAP Data Interchange Format files.

Data URI scheme
    The data URI scheme can use Base64 to represent file contents. For instance, background images and fonts
    can be specified in a CSS stylesheet file as data: URIs, instead of being supplied in separate files.

Leverage clipboard
    To store/transmit relatively small amounts of binary data via a computer's text clipboard functionality,
    especially in cases where the information doesn't warrant being permanently saved or when information
    must be quickly sent between a wide variety of different, potentially incompatible programs. An example
    is the representation of the public keys of cryptocurrency recipients as Base64 encoded text strings,
    which can be easily copied and pasted into users' wallet software.

Support human verification
    Binary data that must be quickly verified by humans as a safety mechanism, such as file checksums or key
    fingerprints, is often represented in Base64 for easy checking, sometimes with additional formatting,
    such as separating each group of four characters in the representation of a PGP key fingerprint with a
    space.

QR code encoding
    A QR code, which contains binary data, is sometimes stored as Base64 since it is more likely that a QR
    code reader accurately decodes text than binary data. Also, some devices more readily save text from a QR
    code than potentially malicious binary data.

Alphabet
The set of characters used to represent the values for each base-64 digit (value from 0 to 63) differs
slightly between the variations of Base64. The general strategy is to use printable characters that are
common to most character encodings. This tends to result in data remaining unchanged as it moves through
information systems, such as email, that were traditionally not 8-bit clean. Typically, an encoding uses
A–Z, a–z, and 0–9 for the first 62 values. Many variants use + and / for the last two.

Per RFC 4648 §4, the following table lists the characters used for each numeric value. To indicate padding, =
is used.

Base64 alphabet
value char  value char  value char  value char
0     A     16    Q     32    g     48    w
1     B     17    R     33    h     49    x
2     C     18    S     34    i     50    y
3     D     19    T     35    j     51    z
4     E     20    U     36    k     52    0
5     F     21    V     37    l     53    1
6     G     22    W     38    m     54    2
7     H     23    X     39    n     55    3
8     I     24    Y     40    o     56    4
9     J     25    Z     41    p     57    5
10    K     26    a     42    q     58    6
11    L     27    b     43    r     59    7
12    M     28    c     44    s     60    8
13    N     29    d     45    t     61    9
14    O     30    e     46    u     62    +
15    P     31    f     47    v     63    /

Note that Base64URL encoding replaces '+' with '-' and '/' with '_' to make the encoded string HTTP-safe and
avoid the need for escaping.

Examples
To simplify explanation, the example below uses ASCII text for input even though this is not a typical use.
More commonly, input is binary data, such as an image, and the result then represents binary data in a
printable text format.

For the input data:
Many hands make light work.

The typical Base64 represented is:
TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcmsu

Encoding when no padding needed
Each input sequence of 6 bits (which can encode 2^6 = 64 values) is mapped to a Base64 alphabet letter.
Therefore, Base64 encoding results in four characters for each three input bytes. Assuming the input is ASCII
or similar, the byte-data for the first three characters 'M', 'a', 'n' are values 77, 97, and 110 which in
8-bit binary representation are 01001101, 01100001, and 01101110. Joining these representations and splitting
into 6-bit groups gives:

010011 010110 000101 101110

Which encodes the string TWFu (per ASCII or similar).

The following table shows how input is encoded. For example, the letter 'M' has the value 77 (per ASCII and
similar). The first 6 bits of the value is 010011 or 19 decimal which maps to Base64 letter 'T' which has a
value 84 (per ASCII and similar).

Encoding 'M', 'a', 'n' as Base64
----------------------------------------------------------------------------
 input  |  letter (ASCII)  |M              |a              |n
        |------------------|---------------|---------------|----------------
(ASCII) |      8-bit       |77             |97             |110
        |  decimal value   |               |               |
---------------------------|------------------------------------------------
           bits            |0 1 0 0 1 1|0 1 0 1 1 0|0 0 0 1 0 1|1 0 1 1 1 0
---------------------------|-----------|-----------|-----------|------------
        |      6-bit       |19         |22         |5          |46
encoded |  decimal value   |           |           |           |
        |------------------|-----------|-----------|-----------|------------
(Base64)|      letter      |T          |W          |F          |u
        |(Base64 alphabet) |           |           |           |
        |------------------|-----------|-----------|-----------|------------
        |       byte       |84         |87         |70         |117
----------------------------------------------------------------------------

Encoding with one padding character
If the input consists of a number of bytes that is 2 more than a multiple of 3 (e.g. 'M', 'a'), then the last
2 bytes (16 bits) are encoded in 3 Base64 digits (18 bits). The two least significant bits of the last
content-bearing 6-bit block are treated as zero for encoding and discarded for decoding (along with the
trailing = padding character).

----------------------------------------------------------------------------
 input  |  letter (ASCII)  |M              |a              |
        |------------------|---------------|---------------|
(ASCII) |      8-bit       |77             |97             |
        |  decimal value   |               |               |
---------------------------|---------------|---------------|----------------
           bits            |0 1 0 0 1 1|0 1|0 1 1 0|0 0 0 1|0 0|  |  |  |  |          
---------------------------|-----------|-----------|-----------|------------
        |      6-bit       |19         |22         |4          |Padding
encoded |  decimal value   |           |           |           |
        |------------------|-----------|-----------|-----------|------------
(Base64)|      letter      |T          |W          |E          |=
        |(Base64 alphabet) |           |           |           |
        |------------------|-----------|-----------|-----------|------------
        |       byte       |84         |87         |69         |61
----------------------------------------------------------------------------

Encoding with two padding characters
If the input consists of a number of bytes that is 1 more than a multiple of 3 (e.g. 'M'), then the last 8
bits are represented in 2 Base64 digits (12 bits). The four least significant bits of the last
content-bearing 6-bit block are treated as zero for encoding and discarded for decoding (along with the
trailing two = padding characters):

----------------------------------------------------------------------------
 input  |  letter (ASCII)  |M              |
        |------------------|---------------|
(ASCII) |      8-bit       |77             |
        |  decimal value   |               |
---------------------------|---------------|--------------------------------
           bits            |0 1 0 0 1 1|0 1|0 0 0 0|  |  |  |  |  |  |  |  |
---------------------------|-----------|-----------|-----------|------------
        |      6-bit       |19         |16         |Padding    |Padding
encoded |  decimal value   |           |           |           |
        |------------------|-----------|-----------|-----------|------------
(Base64)|      letter      |T          |Q          |=          |=
        |(Base64 alphabet) |           |           |           |
        |------------------|-----------|-----------|-----------|------------
        |       byte       |84         |81         |61         |61
----------------------------------------------------------------------------

Decoding with padding
When decoding, each sequence of four encoded characters is converted to three output bytes, but with a single
padding character the final 4 characters decode to only two bytes, or with two padding characters, the final
4 characters decode to a single byte. For example:

---------------------------------------
Encoded       Padding Length  Decoded
---------------------------------------
bGlnaHQgdw==  ==      1       light w
bGlnaHQgd28=  =       2       light wo
bGlnaHQgd29y  None    3       light wor
---------------------------------------

Another way to interpret the padding character is to consider it as an instruction to discard 2 trailing bits
from the bit string each time a = is encountered. For example, when bGlnaHQgdw== is decoded, we convert each
character (except the trailing occurrences of =) into their corresponding 6-bit representation, and then
discard 2 trailing bits for the first = and another 2 trailing bits for the other =. In this instance, we
would get 6 bits from the d, and another 6 bits from the w for a bit string of length 12, but since we remove
2 bits for each = (for a total of 4 bits), the dw== ends up producing 8 bits (1 byte) when decoded.

Decoding without padding
Use of the padding character in encoded text is not essential for decoding. The number of missing bytes can
be inferred from the length of the encoded text. In some variants, the padding character is mandatory, while
for others it is not used. Notably, when concatenating Base64 encoded strings, then use of padding characters
is required.

Without padding, after decoding each sequence of 4 encoded characters, there may be 2 or 3 encoded characters
left over. A single remaining encoded character is not possible because a single Base64 character only
contains 6 bits, and 8 bits are required to create a byte. The first character contributes 6 bits, and the
second character contributes its first 2 bits. The following table demonstrates decoding encoded strings that
have 2, 3 or no left-over characters.

-------------------------------------------------------------
Encoded        Length           Decoded        Decoded length
               of last group                   of last group
-------------------------------------------------------------
bGlnaHQgdw     2                light w        1
bGlnaHQgd28    3                light wo       2
bGlnaHQgd29y   4                light wor      3
-------------------------------------------------------------

Decoding without padding is not performed consistently among decoders^[clarification needed]. In addition,
allowing padless decoding by definition allows multiple strings to decode into the same set of bytes^[
clarification needed], which can be a security risk.

Variants
Variations of Base64 differ in the alphabet used and structural aspects like maximum line length. The most
commonly used alphabet is that described by RFC 4648 and most variations only differ in the last two letters
used. The following table describes more commonly used encodings that are specified by an RFC.

-----------------------------------------------------------------------------------------------------------
               Encoding                |Specification |     Alphabet  |             Lines
                                       |              |---------------|-----------------------------------
                                       |              |62nd|63rd|pad  |Separators|Length  |Checksum
---------------------------------------|--------------|----|----|-----|----------|--------|----------------
              Base 64 Encoding         |RFC 4648 §4   |+   |/   |=    |No        |        |No
Base 64 Encoding with URL and Filename |RFC 4648 §5   |-   |_   |=    |No        |        |No
             Safe Alphabet             |optional      |    |    |     |          |        |
                  for MIME             |RFC 2045      |+   |/   |=    |Yes       |76      |No
   for Privacy-Enhanced Mail           |RFC 1421      |+   |/   |=    |Yes       |64      |Yes, in PEM
               (deprecated)            |CRC           |    |    |     |          |        |
                 for UTF-7             |RFC 2152      |+   |/   |     |No        |        |No
           for IMAP mailbox names      |RFC 3501      |+   |,   |     |No        |        |No
  Textual Encodings of PKIX, PKCS,     |RFC 7468      |+   |/   |=    |Yes       |64      |No
           and CMS Structures          |              |    |    |     |          |        |
          ASCII armor for OpenPGP      |RFC 9580      |+   |/   |=    |Yes       |76      |Yes, (CRC24)
-----------------------------------------------------------------------------------------------------------

RFC 4648
RFC 4648 describes a various encodings including Base64, and it discusses the use of line feeds in encoded
data, the use of padding in encoded data, the use of non-alphabet characters in encoded data, use of
different encoding alphabets, and canonical encodings. The variant that it calls Base 64 Encoding and base64
is intended for general-use.

The RFC also specifies a second Base64 encoding that is calls Base 64 Encoding with URL and Filename Safe
Alphabet that is intended for representing relatively long identifying information. For example, a database
persistence framework for Java objects might use Base64 encoding to encode a relatively large unique id
(generally 128-bit UUIDs) as a string for use as an HTTP parameter in an HTTP form or an HTTP GET URL. Also,
many applications need to encode binary data in a way that is convenient for inclusion in a URL, including in
hidden web form fields, and Base64 is a convenient encoding to render them in a compact way.

Using standard Base64 in a URL requires encoding the +, / and = characters as special percent-encoded
hexadecimal sequences (+ becomes %2B, / becomes %2F and = becomes %3D), which makes the string longer and
harder to read. Using a different alphabet allows for encoding as Base64 without requiring this extra markup.
Typically, + and / are replaced by - and _, respectively, so that using URL encoders/decoders is no longer
necessary and has no effect on the length of the encoded value, leaving the same encoded form intact for use
in relational databases, web forms, and object identifiers in general. A popular site to make use of such is
YouTube. Some variants allow or require omitting the padding = signs to avoid them being confused with
field separators, or require that any such padding be percent-encoded. Some libraries ^[which?] encode = as
., potentially exposing applications to relative path attacks when a folder name is encoded from user data.

RFC 3548

that attempts to unify the RFC 1421 and RFC 2045 specifications of Base64 encodings, alternative-alphabet
encodings, and the Base32 (which is seldom used) and Base16 encodings. RFC 4648 obsoletes RFC 3548.

Unless an encoder is written to a specification that refers to RFC 3548 and specifically requires otherwise^[
clarification needed], RFC 3548 forbids an encoder from generating messages containing characters outside the
encoding alphabet or without padding, and it also declares that a decoder must reject data that contain
characters other than the encoding alphabet.

MIME
The MIME (Multipurpose Internet Mail Extensions) specification lists Base64 as one of two binary-to-text
encoding schemes (the other being quoted-printable). MIME's Base64 encoding is based on that of the RFC 
1421 version of PEM: it uses the same 64-character alphabet and encoding mechanism as PEM and uses the =
symbol for output padding in the same way, as described at RFC 2045.

MIME does not specify a fixed length for Base64-encoded lines, but it does specify a maximum line length of
76 characters. Additionally, it specifies that any character outside the standard set of 64 encoding
characters (for example CRLF sequences), must be ignored by a compliant decoder, although most
implementations use a CR/LF newline pair to delimit encoded lines.

Thus, the actual length of MIME-compliant Base64-encoded binary data is usually about 137% of the original
data length (4⁄3×78⁄76), though for very short messages the overhead can be much higher due to the overhead
of the headers. Very roughly, the final size of Base64-encoded binary data is equal to 1.37 times the
original data size + 814 bytes (for headers). The size of the decoded data can be approximated with this
formula:

bytes = (string_length(encoded_string) − 814) / 1.37

Privacy-enhanced mail
The first known standardized use of the encoding now called MIME Base64 was in the Privacy-Enhanced Mail
(PEM) protocol, proposed by RFC 989 in 1987. PEM defines a "printable encoding" scheme that uses Base64
encoding to transform an arbitrary sequence of bytes to a format that can be expressed in short lines of
6-bit characters, as required by transfer protocols such as SMTP.

The current version of PEM (specified in RFC 1421) uses a 64-character alphabet consisting of upper- and
lower-case Roman letters (A–Z, a–z), the numerals (0–9), and the + and / symbols. The = symbol is also used
as a padding suffix. The original specification, RFC 989, additionally used the * symbol to delimit
encoded but unencrypted data within the output stream.

To convert data to PEM printable encoding, the first byte is placed in the most significant eight bits of a
24-bit buffer, the next in the middle eight, and the third in the least significant eight bits. If there are
fewer than three bytes left to encode (or in total), the remaining buffer bits will be zero. The buffer is
then used, six bits at a time, most significant first, as indices into the string:
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", and the indicated character is output.

The process is repeated on the remaining data until fewer than four bytes remain. If three bytes remain, they
are processed normally. If fewer than three bytes (24 bits) are remaining to encode, the input data is
right-padded with zero bits to form an integral multiple of six bits.

After encoding the non-padded data, if two bytes of the 24-bit buffer are padded-zeros, two = characters are
appended to the output; if one byte of the 24-bit buffer is filled with padded-zeros, one = character is
appended. This signals the decoder that the zero bits added due to padding should be excluded from the
reconstructed data. This also guarantees that the encoded output length is a multiple of 4 bytes.

PEM requires that all encoded lines consist of exactly 64 printable characters, with the exception of the
last line, which may contain fewer printable characters. Lines are delimited by whitespace characters
according to local (platform-specific) conventions.

UTF-7
UTF-7, described first in RFC 1642, which was later superseded by RFC 2152, introduced a system called
modified Base64. This data encoding scheme is used to encode UTF-16 as ASCII characters for use in 7-bit
transports such as SMTP. It is a variant of the Base64 encoding used in MIME.

The "Modified Base64" alphabet consists of the MIME Base64 alphabet, but does not use the "=" padding
character. UTF-7 is intended for use in mail headers (defined in RFC 2047), and the "=" character is reserved
in that context as the escape character for "quoted-printable" encoding. Modified Base64 simply omits the
padding and ends immediately after the last Base64 digit containing useful bits leaving up to three unused
bits in the last Base64 digit.

OpenPGP
Further information: Pretty Good Privacy § OpenPGP

OpenPGP, described in RFC 9580, specifies "ASCII armor", which is identical to the "Base64" encoding
described by MIME, with the addition of an optional 24-bit CRC. The checksum is calculated on the input data
before encoding; the checksum is then encoded with the same Base64 algorithm and, prefixed by the "=" symbol
as the separator, appended to the encoded output data.

Javascript (DOM Web API)
The atob() and btoa() JavaScript methods, defined in the HTML5 draft specification, provide Base64
encoding and decoding functionality to web pages. The btoa() method outputs padding characters, but these are
optional in the input of the atob() method.
Example: Encoding of the beginning of a GIF file: btoa("GIF89a") ↦ "R0lGODlh".

With atypical alphabet order
Several variants use alphabets similar to the common variants, but in a different order.

Unix password
    Unix stores password hashes computed with crypt in the /etc/passwd file using an encoding called B64.
    crypt's alphabet puts the punctuation . and / before the alphanumeric characters. crypt uses the alphabet
    "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" without padding. An advantage over RFC
    4648 is that sorting encoded ASCII data results in the same order as sorting the plain ASCII data.

GEDCOM
    The GEDCOM 5.5 standard for genealogical data interchange encodes multimedia files in its text-line
    hierarchical file format. GEDCOM uses the same alphabet as crypt, which is "./
    0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".

bcrypt
    bcrypt hashes are designed to be used in the same way as traditional crypt(3) hashes, but bcrypt's
    alphabet is in a different order than crypt's. bcrypt uses the alphabet "./
    ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".

Xxencoding
    Xxencoding uses a mostly-alphanumeric character set similar to crypt, but using + and - rather than . and
    /. Xxencoding uses the alphabet "+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".

6PACK
    Used with some terminal node controllers, uses an alphabet from 0x00 to 0x3f.

Bash
    Bash supports numeric literals in Base64. Bash uses the alphabet 
    "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@_".

With atypical alphabet
Some variants use a Base64 alphabet that is significantly different from the alphabets used in the most
common Base64 variants (like RFC 4648).

Uuencoding
    The Uuencoding alphabet includes no lowercase characters, instead using ASCII codes 32 (" " (space))
    through 95 ("_"), consecutively. Uuencoding uses the alphabet " !"#$%&'()*+,-./0123456789:;<=>?
    @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_". Avoiding all lower-case letters was helpful, because many older
    printers only printed uppercase. Using consecutive ASCII characters saved computing power, because it was
    only necessary to add 32, without requiring a lookup table. Its use of most punctuation characters and
    the space character may limit its usefulness in some applications, such as those that use these
    characters as syntax.^[citation needed]

BinHex
    BinHex 4 (HQX), which was used within the classic Mac OS, excludes some visually confusable characters
    like '7', 'O', 'g' and 'o'. Its alphabet includes additional punctuation characters. It uses the alphabet
    "!"#$%&'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr".

UTF-8
    A UTF-8 environment can use non-synchronized continuation bytes as base64: 0b10xxxxxx. See UTF-8#
    Self-synchronization.


---
[OLD] https://en.wikipedia.org/wiki/Base64

Base64

   From Wikipedia, the free encyclopedia

   Base64 is a group of similar binary-to-text encoding schemes that represent binary data in an
   ASCII string format by translating it into a radix-64 representation. The term Base64
   originates from a specific MIME content transfer encoding.

   Each base64 digit represents exactly 6 bits of data.

Design
   The particular set of 64 characters chosen to represent the 64 place-values for the base varies
   between implementations. The general strategy is to choose 64 characters that are both members of a
   subset common to most encodings, and also printable. This combination leaves the data unlikely to
   be modified in transit through information systems, such as email, that were traditionally not
   8-bit clean. For example, MIME's Base64 implementation uses A–Z, a–z, and 0–9 for the
   first 62 values. Other variations share this property but differ in the symbols chosen for the last
   two values; an example is UTF-7.

   The earliest instances of this type of encoding were created for dialup communication between systems
   running the same OS - e.g., uuencode for UNIX, BinHex for the TRS-80 (later adapted for the Macintosh) -
   and could therefore make more assumptions about what characters were safe to use. For instance, uuencode
   uses uppercase letters, digits, and many punctuation characters, but no lowercase.

Examples
   A quote from Thomas Hobbes' Leviathan (be aware of spaces between lines):
Man is distinguished, not only by his reason, but by this singular passion from
other animals, which is a lust of the mind, that by a perseverance of delight
in the continued and indefatigable generation of knowledge, exceeds the short
vehemence of any carnal pleasure.

   is represented as a byte sequence of 8-bit-padded ASCII characters encoded in MIME's Base64
   scheme as follows:
TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz
IHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2Yg
dGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGlu
dWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRo
ZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=

   In the above quote, the encoded value of Man is TWFu. Encoded in ASCII, the characters M, a, and n
   are stored as the bytes 77, 97, and 110, which are the 8-bit binary values 01001101, 01100001, and
   01101110. These three values are joined together into a 24-bit string, producing
   010011010110000101101110. Groups of 6 bits (6 bits have a maximum of 2^6 = 64 different binary
   values) are converted into individual numbers from left to right (in this case, there are four
   numbers in a 24-bit string), which are then converted into their corresponding Base64 character
   values.
   source ASCII (if <128) M                a                n
       source octets      77 (0x4d)        97 (0x61)        110 (0x6e)
        Bit pattern       0 1 0 0 1 1 0 1  0 1 1 0 0 0 0 1  0 1 1 0 1 1 1 0
           Index          19          22           5            46
       Base64-encoded     T           W            F            u
       encoded octets     84 (0x54)   87 (0x57)    70 (0x46)    117 (0x75)

   As this example illustrates, Base64 encoding converts three octets into four encoded characters.

   The Base64 index table:
   Value Char   Value Char   Value Char   Value Char
   0     A      16    Q      32    g      48    w
   1     B      17    R      33    h      49    x
   2     C      18    S      34    i      50    y
   3     D      19    T      35    j      51    z
   4     E      20    U      36    k      52    0
   5     F      21    V      37    l      53    1
   6     G      22    W      38    m      54    2
   7     H      23    X      39    n      55    3
   8     I      24    Y      40    o      56    4
   9     J      25    Z      41    p      57    5
   10    K      26    a      42    q      58    6
   11    L      27    b      43    r      59    7
   12    M      28    c      44    s      60    8
   13    N      29    d      45    t      61    9
   14    O      30    e      46    u      62    +
   15    P      31    f      47    v      63    /

   When the number of bytes to encode is not divisible by three (that is, if there are only one or two
   bytes of input for the last 24-bit block), then the following action is performed:

   Add extra bytes with value zero so there are three bytes, and perform the conversion to base64.

   If there is only one significant input byte (e.g., 'M'), all 8 bits will be captured in the first two
   base64 digits (12 bits).
    Text content  M
       ASCII      77 (0x4d)        0 (0x00)        0 (0x00)
    Bit pattern   0 1 0 0 1 1 0 1  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
       Index      19          16           0           0
   Base64-encoded T           Q            =           =

   If there are two significant input bytes (e.g., 'Ma'), all 16 bits will be captured in the first
   three base64 digits (18 bits). '=' characters might be added to make the last block contain four
   base64 characters.
    Text content  M                a
       ASCII      77 (0x4d)        97 (0x61)        0 (0x00)
    Bit pattern   0 1 0 0 1 1 0 1  0 1 1 0 0 0 0 1  0 0 0 0 0 0 0 0
       Index      19          22           4            0
   Base64-encoded T           W            E            =

   As illustrated in the first table above, when the last input group contains only one octet, the four
   least significant bits of the last content-bearing 6-bit block will turn out to be zero:
    Bit pattern   0 1 0 0 0 0
       Index      16
   Base64-encoded Q

   And when the last input group contains two octets, the two least significant bits of the last
   content-bearing 6-bit block will turn out to be zero:
    Bit pattern   0 0 0 1 0 0
       Index      4
   Base64-encoded E

Output padding
   The final '==' sequence indicates that the last group contained only one byte, and '=' indicates that
   it contained two bytes. The example below illustrates how truncating the input of the above quote
   changes the output padding:

   ---------------------------------------------------------------------------------
   Length   Input                  Length    Output                          Padding
   ---------------------------------------------------------------------------------
   20       any carnal pleasure.   28        YW55IGNhcm5hbCBwbGVhc3VyZS4=    1
   19       any carnal pleasure    28        YW55IGNhcm5hbCBwbGVhc3VyZQ==    2
   18       any carnal pleasur     24        YW55IGNhcm5hbCBwbGVhc3Vy        0
   17       any carnal pleasu      24        YW55IGNhcm5hbCBwbGVhc3U=        1
   16       any carnal pleas       24        YW55IGNhcm5hbCBwbGVhcw==        2
   ---------------------------------------------------------------------------------

   The same characters will be encoded differently depending on their position within the three-octet
   group which is encoded to produce the four characters. For example:

   --------------------------
   Input        Output
   --------------------------
   pleasure.    cGxlYXN1cmUu
   leasure.     bGVhc3VyZS4=
   easure.      ZWFzdXJlLg==
   asure.       YXN1cmUu
   sure.        c3VyZS4=
   --------------------------

   The ratio of output bytes to input bytes is 4:3 (33% overhead). Specifically, given an input of n
   bytes, the output will be
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle displaystyle="true" scriptlevel="0">
   <mn>4</mn> <mo fence="false" stretchy="false">⌈</mo> <mi>n</mi> <mrow class="MJX-TeXAtom-ORD">
   <mo>/</mo> </mrow> <mn>3</mn> <mo fence="false" stretchy="false">⌉</mo> </mstyle> </mrow> <annotation
   encoding="application/x-tex">{\displaystyle 4\lceil n/3\rceil }</annotation> </semantics> :MATH]
   4 \lceil n/3 \rceil bytes long, including padding characters.

   In theory, the padding character is not needed for decoding, since the number of missing bytes can be
   calculated from the number of Base64 digits. In some implementations, the padding character is
   mandatory, while for others it is not used. One case in which padding characters are required is
   concatenating multiple Base64 encoded files.

   Decoding Base64 with padding
   When decoding Base64 text, four characters are typically converted back to three bytes. The only
   exceptions are when padding characters exist. A single '=' indicates that the four characters will
   decode to only two bytes, while '==' indicates that the four characters will decode to only a single
   byte. For example:

   ----------------------------------------------------------------------
   Encoded                      Paddin     Length      Decoded
   ----------------------------------------------------------------------
   YW55IGNhcm5hbCBwbGVhcw==     two '='s   1           any carnal pleas
   YW55IGNhcm5hbCBwbGVhc3U=     one '='    2           any carnal pleasu
   YW55IGNhcm5hbCBwbGVhc3Vy     no '='s    3           any carnal pleasur
   ----------------------------------------------------------------------

   Decoding Base64 without padding
   Without padding, after normal decoding of four characters to three bytes over and over again, less
   than four encoded characters may remain. In this situation only two or three characters shall remain.
   A single remaining encoded character is not possible (because a single base 64 character only
   contains 6 bits, and 8 bits are required to create a byte, so a minimum of 2 base 64 characters are
   required : the first character contributes 6 bits, and the second character contributes its first 2
   bits) . For example:

   ------------------------------------------------------------------
   Length    Encoded                     Length    Decoded
   ------------------------------------------------------------------
   2         YW55IGNhcm5hbCBwbGVhcw      1         any carnal pleas
   3         YW55IGNhcm5hbCBwbGVhc3U     2         any carnal pleasu
   4         YW55IGNhcm5hbCBwbGVhc3Vy    3         any carnal pleasur
   ------------------------------------------------------------------

Sample Implementation in Java
   This implementation is designed to illustrate the mechanics of Base64 encoding and decoding, not
   necessarily for memory or time efficiency.

   Please note that Java 8 has introduced java.util.Base64.

private static final String CODES = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

private static byte[] base64Decode(String input) {
	if (input.length() % 4 == 0)    {
		byte decoded[] = new byte[((input.length() * 3) / 4) - (input.indexOf('=') > 0 ? (input.length() - \
		input.indexOf('=')) : 0)];

		char[] inChars = input.toCharArray();
		int j = 0;
		int b[] = new int[4];
		for (int i = 0; i < inChars.length; i += 4) {
			// This could be made faster (but more complicated) by precomputing these index locations.
			b[0] = CODES.indexOf(inChars[i]);
			b[1] = CODES.indexOf(inChars[i + 1]);
			b[2] = CODES.indexOf(inChars[i + 2]);
			b[3] = CODES.indexOf(inChars[i + 3]);
			decoded[j++] = (byte) ((b[0] << 2) | (b[1] >> 4));
			if (b[2] < 64)      {
				decoded[j++] = (byte) ((b[1] << 4) | (b[2] >> 2));
				if (b[3] < 64)  {
					decoded[j++] = (byte) ((b[2] << 6) | b[3]);
				}
			}
		}
		return decoded;
	} else {
		throw new IllegalArgumentException("Invalid base64 input");
	}
}

private static String base64Encode(byte[] in) {
	StringBuilder out = new StringBuilder((in.length * 4) / 3);
	int b;
	for (int i = 0; i < in.length; i += 3) {
		b = (in[i] & 0xFC) >> 2;
		out.append(CODES.charAt(b));
		b = (in[i] & 0x03) << 4;
		if (i + 1 < in.length) {
			b |= (in[i + 1] & 0xF0) >> 4;
			out.append(CODES.charAt(b));
			b = (in[i + 1] & 0x0F) << 2;
			if (i + 2 < in.length) {
				b |= (in[i + 2] & 0xC0) >> 6;
				out.append(CODES.charAt(b));
				b = in[i + 2] & 0x3F;
				out.append(CODES.charAt(b));
			} else {
				out.append(CODES.charAt(b));
				out.append('=');
			}
		} else {
			out.append(CODES.charAt(b));
			out.append("==");
		}
	}

	return out.toString();
}

C encoder efficiency considerations
   As an example of a small naive program stub to improve time performance (but not space), consider
   these quasi C code base64 functions, Byte3toChar4(), to do the basic intrinsic encoding.

char base64set[]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                 "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                 "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                 "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" ;

// repeating the base64 characters in the index array avoids the  077 &  operations
char* Byte3toChar4(unsigned char ra[3]){
static char ar[4] = { base64set[       ra[0] >> 2                           ] ,
                      base64set[       ra[0] << 4 | ra[1] >> 4              ] ,
                      base64set[                    ra[1] << 2 | ra[2] >> 6 ] ,
                      base64set[                                 ra[2]      ] };
return (char *)ar;}

// replaces the traditional rudimentary approach, though it only uses base64set[0..63]
char* Byte3toChar4(unsigned char ra[3]){
static char ar[4] = { base64set[       ra[0] >> 2                           ] ,
                      base64set[ 077 & ra[0] << 4 | ra[1] >> 4              ] ,
                      base64set[ 077 &              ra[1] << 2 | ra[2] >> 6 ] ,
                      base64set[ 077 &                           ra[2]      ] };
return (char *)ar;}

   Both functions take advantage of array indexing operations ( {,,,} and base64set[] and ra[] ) which
   are often more efficient in machine hardware architectures than programmed result concatenation
   calculations. Judicious use of the capability in C to do coercive casting (such as char[3] and
   char[4] with uint32_t), and using operations that are type consistent, can provide more dramatic
   enhanced performance.

   Arguably, the algorithm's efficiency of exposé for human comprehension rivals machine performance
   concerns.

   The semiotics of the algorithm's coding is a direct reflection of the paradigm used to manipulate
   and position the base64 encoded bits. In particular, the distinct symmetry of the octal "077 &" bit
   selector repetition and its elimination in the time efficient version is made visually acute. As a
   case in point, any corruption or typographical error becomes trivial to identify.

   This paradigm is an artifact of the 1970's and was used very effectively for such problems. The
   rendering of this algorithm in C emphasizes its historic and archaic origins.

   The veracity of the above can be confirmed with an obtuse and perverse space consuming scURIple. (A
   scURIple is a URI program script using a scheme such as
   data:text/html,<html><script>...</script></html>. These are known as scriptlets or bookmarklets when
   javascript: is used as the scheme or protocol.)
javascript:

ra64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" ;
ra64+=ra64;  ra64+=ra64;  ra64+=ra64; ra64+=ra64;  ra64+=ra64;  ra64+=ra64;
function encode3as4of64(ra){
	return [
		ra64 [ ra.charCodeAt(0) >> 2                                                 ],
		ra64 [ ra.charCodeAt(0) << 4 | ra.charCodeAt(1) >> 4                         ],
		ra64 [                         ra.charCodeAt(1) << 2 | ra.charCodeAt(2) >> 6 ],
		ra64 [                                                 ra.charCodeAt(2)      ] ] };
"Empirically confirm 'TWFu' encodes 'Man': " + encode3as4of64("Man").join("") ;

   A few other encodings to consider:
encode3as4of64("\000\000\000").join("") +"\n"+
encode3as4of64("\x00\x00\x00").join("") +"\n"+

encode3as4of64("\377\377\377").join("") +"\n"+
encode3as4of64("\xff\xff\xff").join("") +"\n"+

encode3as4of64("\252\252\252").join("") +"\n"+
encode3as4of64("\xaa\xaa\xaa").join("") +"\n"+

encode3as4of64("\x55\x55\x55").join("") +"\n"+
encode3as4of64("UUU")         .join("") +"\n"

Implementations and history ...


---

