filename: entity-component-system-multif-20251205.txt
https://www.simplilearn.com/entity-component-system-introductory-guide-article

Entity Component System: An Introductory Guide
Nov 16, 2025

   Video games are a serious business. Ask anyone who plays or designs them! A lot goes into creating
   these games, including various utilities, architecture, and coding. That's why today we are covering
   Entity Component Systems. Some writers insert hyphens between each word, but we won't be doing that,
   although we will often refer to the term by its commonly used acronym of ECS.

   This article introduces you to the Entity Component System, including what it is, its pros and cons,
   examples, how to create ECS hierarchies, and much more.

   Let's begin our guide with some definitions.

What Is an Entity Component System?
   The Entity Component System is an architectural pattern often used in video game development. It
   facilitates code reusability by separating the data from the behavior. In addition, ECS obeys the
   "composition over inheritance principle," providing improved flexibility and helping developers
   identify entities in a game's scene where all the objects are classified as entities.

   Frameworks often enable Entity Component Systems, and the term "ECS" is frequently used to illustrate
   a specific design pattern implementation.

   An ECS consists of the following elements:
     * It has unique identifiers known as entities.
     * It contains plain datatypes without behavior, known as components.
     * It has systems, defined as functions that are matched with entities that have a particular set of
       components.
     * Entities may contain zero or more components.
     * Entities can dynamically change components.

   So, an ECS is an architecture that focuses on data and separates data/components, identity/entities,
   and behavior/systems. These characteristics make it a natural fit for video game design.

   Now, let's break down the term into separate parts and identify them better.

What Is Defined as an Entity?
   An entity represents one "thing" in a video game, a distinct object representing an actor in a
   simulated space, typically expressed as a unique integer value. For example, if you're playing
   Skyrim, all the tangible, visible "things" in the game's universe are entities. They contain no
   actual data or behaviors.

What's the Definition of a Component?
   Components are datatypes consisting of a unique behavior assigned to an entity. They are reusable
   modules that programmers attach to the entities, providing behavior, functionality, and appearance,
   forming an entity.

   For example, a sword and sorcery game programmer could build a magic sword entity by gathering these
   components:
     * A material component, such as "shininess," influences the sword's appearance
     * A weight component measures "pounds" to determine the sword's overall weight
     * A damage component that influences how practical of a weapon the sword is

What Is Considered the System?
   Systems iterate components to perform low-level functions like performing physics calculations or
   rendering graphics. Systems provide global scope, services, and management for component classes.
   It's basically the logic that operates on the components.

   For example, a camera system manages every entity with a camera component, controlling which camera
   is active.

What's a Composition?
   Compositions allow developers to attach more components to add additional functionalities, behavior,
   or appearance.

The Advantages of ECS
   Here's why Entity Component Systems are a benefit to programmers:
     * Programmers can use ECS to create shorter, less complicated code
     * It offers a clean design that employs decoupling, encapsulation, modularization, and reusability
       methods
     * It lets programmers mix reusable parts, providing better flexibility when defining objects
     * It features very flexible emergent behavior
     * It offers an architecture for both 3D and VR development, allowing you to build the latter
       application in terms of complexity
     * It allows non-techies to script by behavior
     * It's an easy choice for unit testing and mocking
     * You can switch components with mocked components at run-time
     * It helps you to add or bolster new features
     * It's a friendly method for multi-threading and parallel processing
     * It helps programmers separate data from the functions that can act on it.

The Disadvantages of Using ECS
   Of course, every tool has its downside. Here's are things about ECS that aren't as great:
     * ECS is not very well known. Most people haven't even heard of it. That can pose problems for
       collaboration.
     * It's not as concretely defined as other patterns, like Model-View-Controller (MVC).
     * It's challenging to apply correctly, and it's easy to misuse. As a result, programmers need to
       think more about how to design good components.
     * ECS requires programmers to write many small systems which can potentially be used in vast
       numbers of entities. This method results in a risk of writing very inefficient code.

Entity Component System Example
   This illustration, provided by Docs.unity3d, shows an example of ECS architecture and how the
   parts all work together.

          [Entity A]     [Entity B]             [Entity C]
              |              |                      |
      +-------|--------------|-------+     +--------|-------+      +-----------------+
      |       |              |       |     |        |       |      | +-------------+ |
      | [Translation ][Translation ]========>[Translation ]=========>|             | |
      | [Rotation    ][Rotation    ]========>[Rotation    ]=========>| L2W = T * R | |
      | [LocalToWorld][LocalToWorld]<========[LocalToWorld]<=========|             | |
      | [Renderer    ][Renderer    ] |     |                |      | +-------------+ |
      |          Components          |     |  Components    |      |      System     |
      +------------------------------+     +----------------+      +-----------------+

Data flow in ECS
   We can break down the ECS data flow into the following steps:
     * System: The system listens to outside events and publishes updates to the components.
     * Component: The components listen to system events, then update their state.
     * Entity: The entity gains behavior through the changes in component states.

   So, a gamer presses the "right arrow" key while adventuring in a fantasy world. The player input
   system detects the gamer's key press and updates the motion component. The motion system activates
   and "sees" that the entity's motion is to the right, so it applies the Physics force accordingly.
   Then, the render system takes over and reads the entity's current position, drawing it according to
   its new spatial definition.

Why Is ECS Used?
   We've already touched upon the advantages of ECS, but there are four reasons why game developers like
   using it:
     * First, it can support many game objects
     * Second, its code is more reusable
     * Third, it allows a more dynamic coding style
     * Fourth, it lets developers extend/add new features

How Is ECS Different From OOP?
   Some people consider ECS an alternative to Object Oriented Programming, otherwise known as OOP.
   Although the two share some overlapping similarities, there are four key differences between them:
     * OOP encourages data encapsulation while ECS promotes exposed plain old data (POD) objects
     * OOP considers inheritance a first-class citizen, while ECS considers composition a first class
     * OOP colocates data with behavior, but ECS separates the data from behavior
     * OOP Object instances are single static, and entities may dynamically change multiple components

How Is ECS Different From Entity-Component Frameworks?
   Although they share two-thirds of the same name, ECS and Entity-Component Frameworks aren't the same.
   EC frameworks, like the ones usually found in game engines, are like ECS in that they allow entity
   creation and component composition.

   But in EC, components are classes that have both data and behavior. Also, behavior is executed
   directly on the component. Here's what a simple EC framework looks like, courtesy of GitHub:

class IComponent {
	public:
		virtual void update() = 0;
};

class Entity {
	vector<IComponent*> components;

	public:
		void addComponent(IComponent *component);
		void removeComponent(IComponent *component);
		void updateComponents();
};

Is ECS a Lower Level of Abstraction?
   Not really. Although several ECS designs may leverage low-level machine optimizations, an ECS's
   written code doesn't have to be lower or higher than other approaches.

Does ECS Require Writing More Code?
   The answer really depends on the ECS framework and what kind of engine you're using. When you
   integrate an ECS framework with an engine, you can get pretty compact and concise code that's
   sometimes shorter than the non-ECS alternatives.

   But when your ECS isn't integrated with an engine, you will need additional glue-code to make a
   bridge between the native engine types and the ECS. This procedure can cause an application to write
   more code.

   In the final analysis, though, any time spent writing ECS code is typically offset by the time
   savings you get from having a more maintainable codebase.

Is ECS Fast?
   As a rule, yes, although it depends on what's being measured and the ECS implementation itself
   because different implementations result in different tradeoffs. So, for example, an operation that's
   slow in one framework could be extremely fast in another.

   In terms of speed, ECS implementations are typically good at dynamically changing components at
   run-time and linearly querying and iterating entity sets. On the other hand, ECS implementations fall
   short in speed when executing queries or operations that need highly specialized data structures
   like spatial structures and binary trees.

   But you can get the most out of your ECS if you familiarize yourself with the implementation's
   tradeoffs and leverage its design.

Is ECS Code More Reusable?
   Yes, because an ECS's behaviors are matched with a set of components, not tightly coupled with a
   class like in OOP. Since behaviors aren't tied to one class, they can be used across different
   classes of entities.

   Furthermore, programmers can introduce new systems at any stage of development. The systems will get
   automatically matched with any new or existing entities that contain the right components.

Is ECS Good for Multi-threading?
   Usually, yes, because the separation of data and behavior means it's easier to identify individual
   systems, their dependencies, and how the developer should schedule them.

Can ECS Be Used Outside of Gaming?
   Yes, it can and has been used in non-gaming projects.

How Do You Create a Hierarchy in ECS?
   Here's an approach you can use to create a hierarchy in an Entity Component System, coding courtesy
   of[https://github.com/SanderMertens/ecs-faq#why-is-ecs-used] Github.

// Store the parent entity on child entities
struct Parent {
	entity parent;
};

// Store all children of a parent in a component with a vector
struct Children {
	vector<entity> children;
};

// Store children in linked list
struct ChildList {
	entity first_child; // First child of entity
	entity prev_sibling; // Previous sibling
	entity next_sibling; // Next sibling
};

How Do You Store Spatial Data in ECS?
   Spatial data structures use layouts that don't match up well with the typical ECS layout. However,
   you can create a query that iterates the relevant entries, storing them in spatial structures at
   either the start or end of each frame.

Summarize and Review
   Here are the salient takeaways:
     * Entity-Component-Systems (ECS) is an architectural pattern
     * An entity is a distinct object representing an actor in a simulated space
     * A component is defined as a singular behavior that's ascribed to an entity
     * A system iterates many components so they can perform low-level functions like pathfinding,
       rendering graphics, or performing physics calculations
     * A composition is an element to which programmers can attach more components, adding behaviors,
       additional appearance, or functionality
     * You can use an ECS pattern to create shorter, less complicated code
     * ECS isn't as concretely defined as other patterns like MVC


---
https://austinmorlan.com/posts/entity_component_system/

A Simple Entity Component System (ECS) [C++]
Jun 25, 2019

   Ever since first hearing about Entity Component Systems and their implications in game development,
   I've wanted to build one for my own usage and knowledge. There are a few examples that people have
   built and posted online, and there are a few full-fledged ones that can be used to build
   real games.

   I liked different aspects of each of them that I studied, but I wanted to build my own and put my own
   spin on the problem, incorporating different elements from different examples. This is the result.

   It is, admittedly and by design, simple. It's intended as a jumping off point for the curious.

   In the two years since I wrote this, I've received many comments/emails about it, and it gets a lot
   of daily hits. I fear that people read it and take it as gospel when I never intended to be seen as
   an authority on the subject; I just wanted to write about something that I found interesting.
   Since then my feelings on a few things have changed so I'd like to talk about them here briefly.

   1) I don't like "Modern" C++ or really C++ in general.
   I use some C++ features here that I would never use today as I've gone back to trying to write simple
   code. I will either use C++ with a limited feature set (operator overloading, function overloading,
   that's about it), or I will just use straight up C. I like the simplicity of C and I find that when I
   use C++ I spend far too much brainpower on thinking about the language and not enough time thinking
   of the actual problem I'm trying to solve.

   2) I'm not an expert on ECSes.
   I wrote this because I heard about the idea of an ECS and thought they were cool but often explained
   poorly or overly complicated, so I wanted to explain my understanding in a way that made sense to me.
   I've not done anything else with ECSes since.
   I hope you still find this useful but take it for what it is.

What is an ECS?
   Traditionally in game development, you would follow an inheritance approach to problems. A Goblin
   inherits from a Monster which inherits from an Actor. A Shopkeeper inherits from a Human which also
   inherits from an Actor. The Actor class contains a function called Render() which knows how to render
   an Actor, so for every Goblin you can call Goblin.Render() and for every Shopkeeper you can call
   Shoperkeeper.Render().

   There are two main problems with this approach. The first is the problem of flexibility. If you
   decide that you want to visit a town of friendly goblins in the game, and you have Goblin
   Shopkeepers, your inheritance tree gets messed up. You have all of the shopkeeping functionality in
   the Shopkeeper class (selling, bartering, whatever), but your Goblin Shopkeeper can't inherit from
   Shopkeeper because that would make the Goblin Shopkeeper a Human. Without a doubt, inheritance has
   its place in software development, but in gameplay programming it can cause problems.

   The second problem is a misuse of the cache. In games, you commonly iterate over a set of objects
   multiple times per second, running methods on them every frame. For example, your physics system
   might iterate over all objects that are subject to physics and call Object.Integrate(dt), updating
   their position, velocity, and acceleration. So traditionally you'd have your big object that contains
   all of its state, including those needed for physics, and you'd call the integrate function on every
   object that needs to be updated. In each object's Integrate() method, you access the object's
   position, velocity, and acceleration member variables. When you access position, it's pulled into a
   cache line along with nearby member variables. Some of those nearby member variables will be useful
   (velocity and the acceleration), while others will not be. This is a huge waste of the cache and in
   an age where the performance bottleneck is the time it takes for data to get from main memory to the
   CPU's memory, it's a big deal.

   The tides have been shifting into component-based design to solve the first problem. Looking at
   Unity, for example, all of the game objects are component-based. You start with a blank object that
   has only the default required Transform component, and you add more components to give the object
   functionality. But that hasn't solved the second problem.

   The second problem is solved by keeping all of the data that will be iterated upon regularly packed
   tightly into memory so that an entire cache line's worth of data can be loaded at once, and when the
   next item is iterated upon, its data is already in the cache. This is solved by defining components
   as Plain Old Data (POD), essentially a simple struct with only the relevant data included. To
   continue the physics example, you might have Transform with position, Rigidody with velocity and
   acceleration, and Gravity with the gravitational constant g.

   The physics system would then iterate over all "objects" that "contain" these three components,
   pulling in only the data it cares about into the cache.

   Unity is moving in this direction with the introduction of its own ECS implementation, as well as its
   Jobs system and the Burst compiler. In fact, watching a talk by Mike Acton (Principal Programmer at
   Unity leading ECS development) is what got me interested in this stuff in the first place.

   In reality, the traditional concept of the "object" is gone. Instead we have an Entity which is
   simply an ID. It doesn't "contain" anything. Instead the ID is used as an index into an array of
   components. An array is contiguous in memory which lends itself well to being the data structure of
   choice. So the physics system might have a list of all entities that have a Transform, RigidBody, and
   Gravity component, and use the entity's ID as an index into the Transform array, into the RigidBody
   array, and into the Gravity array.

   So conceptually it's all pretty simple. An Entity is an ID. A Component is a struct of data. A System
   is the logic that operates on the components. The meat of this post will be on how to implement those
   three elements in a way that is simple, easy to understand, and easy to use.

   I set out to design mine with the following goals:
     * Relatively simple and understandable
     * Modern C++
     * Minimal amount of if conditions (to avoid branch mispredictions)
     * Minimal virtual inheritance (to avoid virtual function lookup and branch mispredictions)

The Entity

   As promised, an Entity is very simple:

// A simple type alias
using Entity = std::uint32_t;

// Used to define the size of arrays later on
const Entity MAX_ENTITIES = 5000;

   You could of course choose for an Entity to be of any size, and same with MAX_ENTITIES.

The Component
   A component is almost as simple as an entity. It's just a struct with a small chunk of functionally
   related data. As an example, Transform might look like this:

struct Transform {
	Vec3 position;
	Quat rotation;
	Vec3 scale;
}

   Each component type (Transform, RigidBody, etc) also has a unique ID given to it (for reasons
   explained later).

// A simple type alias
using ComponentType = std::uint8_t;

// Used to define the size of arrays later on
const ComponentType MAX_COMPONENTS = 32;

   Again, you could choose any size for ComponentType and MAX_COMPONENTS.

The Signature
   Since an entity is simply an ID, we need a way to track which components an entity "has", and we also
   need a way to track which components a system cares about.

   I chose the very simple approach of using a std::bitset (modern C++ equivalent of a bitfield), called
   a Signature. Each component type has a unique ID (starting from 0), which is used to represent a bit
   in the signature.

   As an example, if Transform has type 0, RigidBody has type 1, and Gravity has type 2, an entity that
   "has" those three components would have a signature of 0b111 (bits 0, 1, and 2 are set).

   A system would also register its interest in certain components as another signature. Then it's a
   simple bitwise comparison to ensure that an entity's signature contains the system's signature (an
   entity might have more components than a system requires, which is fine, as long as it has all of the
   components a system requires).

// A simple type alias
using Signature = std::bitset<MAX_COMPONENTS>;

The Entity Manager
   The Entity Manager is in charge of distributing entity IDs and keeping record of which IDs are in use
   and which are not.

   I chose to use a simple std::queue, where on startup the queue is initialized to contain every valid
   entity ID up to MAX_ENTITIES. When an entity is created it takes an ID from the front of the queue,
   and when an entity is destroyed it puts the destroyed ID at the back of the queue.

class EntityManager {
	public:
		EntityManager() {
			// Initialize the queue with all possible entity IDs
			for (Entity entity = 0; entity < MAX_ENTITIES; ++entity) {
				mAvailableEntities.push(entity);
			}
		}

		Entity CreateEntity() {
			assert(mLivingEntityCount < MAX_ENTITIES && "Too many entities in existence.");

			// Take an ID from the front of the queue
			Entity id = mAvailableEntities.front();
			mAvailableEntities.pop();
			++mLivingEntityCount;

			return id;
		}

		void DestroyEntity(Entity entity) {
			assert(entity < MAX_ENTITIES && "Entity out of range.");

			// Invalidate the destroyed entity's signature
			mSignatures[entity].reset();

			// Put the destroyed ID at the back of the queue
			mAvailableEntities.push(entity);
			--mLivingEntityCount;
		}

		void SetSignature(Entity entity, Signature signature) {
			assert(entity < MAX_ENTITIES && "Entity out of range.");

			// Put this entity's signature into the array
			mSignatures[entity] = signature;
		}

		Signature GetSignature(Entity entity) {
			assert(entity < MAX_ENTITIES && "Entity out of range.");

			// Get this entity's signature from the array
			return mSignatures[entity];
		}

	private:
		// Queue of unused entity IDs
		std::queue<Entity> mAvailableEntities{};

		// Array of signatures where the index corresponds to the entity ID
		std::array<Signature, MAX_ENTITIES> mSignatures{};

		// Total living entities - used to keep limits on how many exist
		uint32_t mLivingEntityCount{};
};

The Component Array
   We need to create a data structure that is essentially a simple array, but is always a packed array,
   meaning it has no holes. If an entity is just an index into an array of components, then it's simple
   to grab the relevant component for an entity, but what happens when an entity is destroyed? That
   index into the array is no longer valid.

   Remember that the entire point of the ECS is to keep the data packed in memory, meaning that you
   should be able to iterate over all of the indices in the array without needing any sort of
   "if(valid)" checks. When an entity is destroyed, the component data it "had" still exists in the
   arrays. If a system were to then try to iterate over the array, it would encounter stale data with no
   entity attached. For this reason we need to keep the array packed with valid data at all times.

   I chose to solve this problem by keeping a mapping from entity IDs to array indices. When accessing
   the array, you use the entity ID to look up the actual array index. Then, when an entity is
   destroyed, you take the last valid element in the array and move it into the deleted entity's spot
   and update the map so that the entity ID now points to the correct position. There is also a map from
   the array index to an entity ID so that, when moving the last array element, you know which entity
   was using that index and can update its map.

   Before showing the code, let me demonstrate the process visually because try as I might to make the
   code understandable, it's still clearer in picture form.

   Let's assume that MAX_ENTITIES is set to 5. The array starts out empty, there is nothing in the maps,
   and the size is 0.

Start
------
Array: []

Entity->Index: []

Index->Entity: []

Size: 0

   We then add a component with value A to Entity 0.

   Entity 0 maps to Index 0, and Index 0 maps to Entity 0.

Add A to Entity 0
------
Array: [A]

Entity->Index:
[0:0] Entity 0's data (A) is at Index 0

Index->Entity:
[0:0] Index 0 holds Entity 0's data (A)

Size: 1

   We then add a component with value B to Entity 1.

   Entity 1 maps to Index 1, and Index 1 maps to Entity 1.

Add B to Entity 1
------
Array: [A, B]

Entity->Index:
[0:0] Entity 0's data (A) is at Index 0
[1:1] Entity 1's data (B) is at Index 1

Index->Entity:
[0:0] Index 0 holds Entity 0's data (A)
[1:1] Index 1 holds Entity 1's data (B)

Size: 2

   We then add a component with value C to Entity 2.

   Entity 2 maps to Index 2, and Index 2 maps to Entity 2.

Add C to Entity 2
------
Array: [A, B, C]

Entity->Index:
[0:0] Entity 0's data (A) is at Index 0
[1:1] Entity 1's data (B) is at Index 1
[2:2] Entity 2's data (C) is at Index 2

Index->Entity:
[0:0] Index 0 holds Entity 0's data (A)
[1:1] Index 1 holds Entity 1's data (B)
[2:2] Index 2 holds Entity 2's data (C)

Size: 3

   We then add a component with value D to Entity 3.

   Entity 3 maps to Index 3, and Index 3 maps to Entity 3.

Add D to Entity 3
------
Array: [A, B, C, D]

Entity->Index:
[0:0] Entity 0's data (A) is at Index 0
[1:1] Entity 1's data (B) is at Index 1
[2:2] Entity 2's data (C) is at Index 2
[3:3] Entity 3's data (D) is at Index 3

Index->Entity:
[0:0] Index 0 holds Entity 0's data (A)
[1:1] Index 1 holds Entity 1's data (B)
[2:2] Index 2 holds Entity 2's data (C)
[3:3] Index 3 holds Entity 3's data (D)

Size: 4

   So far so good. Everything is packed into memory. But then we delete the value B from Entity 1. To
   keep it packed, we move the last element D into the spot occupied by B, and update the maps.

   Entity 3 maps to Index 1, and Index 1 maps to Entity 3.

Delete B (which was at Index 1 and was the data of Entity 1)
------
Array: [A, D, C]

Entity->Index:
[0:0] Entity 0's data (A) is at Index 0
[3:1] Entity 3's data (D) is at Index 1
[2:2] Entity 2's data (C) is at Index 2

Index->Entity:
[0:0] Index 0 holds Entity 0's data (A)
[1:3] Index 1 holds Entity 3's data (D)
[2:2] Index 2 holds Entity 2's data (C)

Size: 3

   We then delete the value D from Entity 3, moving the last element C into the spot occupied by D.

   Entity 2 maps to Index 1, and Index 1 maps to Entity 2.

Delete D (which was at Index 1 and was the data of Entity 3)
------
Array: [A, C]

Entity->Index:
[0:0] Entity 0's data (A) is at Index 0
[2:1] Entity 2's data (C) is at Index 1

Index->Entity:
[0:0] Index 0 holds Entity 0's data (A)
[1:2] Index 1 holds Entity 2's data (C)

Size: 2

   Finally we add value E to Entity 4.

   Entity 4 maps to Index 2, and Index 2 maps to Entity 4.

Add E to Entity 4
------
Array: [A, C, E]

Entity->Index:
[0:0] Entity 0's data (A) is at Index 0
[2:1] Entity 2's data (C) is at Index 1
[4:2] Entity 4's data (E) is at index 2

Index->Entity:
[0:0] Index 0 holds Entity 0's data (A)
[1:2] Index 1 holds Entity 2's data (C)
[2:4] Index 2 holds Entity 4's data (E)

Size: 3

   Voila, components removed and added while maintaining density.

// The one instance of virtual inheritance in the entire implementation.
// An interface is needed so that the ComponentManager (seen later)
// can tell a generic ComponentArray that an entity has been destroyed
// and that it needs to update its array mappings.
class IComponentArray {
	public:
		virtual ~IComponentArray() = default;
		virtual void EntityDestroyed(Entity entity) = 0;
};


template<typename T>
class ComponentArray : public IComponentArray {
	public:
		void InsertData(Entity entity, T component) {
			assert(mEntityToIndexMap.find(entity) == mEntityToIndexMap.end() && \
			"Component added to same entity more than once.");

			// Put new entry at end and update the maps
			size_t newIndex = mSize;
			mEntityToIndexMap[entity] = newIndex;
			mIndexToEntityMap[newIndex] = entity;
			mComponentArray[newIndex] = component;
			++mSize;
		}

		void RemoveData(Entity entity) {
			assert(mEntityToIndexMap.find(entity) != mEntityToIndexMap.end() && \
			"Removing non-existent component.");

			// Copy element at end into deleted element's place to maintain density
			size_t indexOfRemovedEntity = mEntityToIndexMap[entity];
			size_t indexOfLastElement = mSize - 1;
			mComponentArray[indexOfRemovedEntity] = mComponentArray[indexOfLastElement];

			// Update map to point to moved spot
			Entity entityOfLastElement = mIndexToEntityMap[indexOfLastElement];
			mEntityToIndexMap[entityOfLastElement] = indexOfRemovedEntity;
			mIndexToEntityMap[indexOfRemovedEntity] = entityOfLastElement;

			mEntityToIndexMap.erase(entity);
			mIndexToEntityMap.erase(indexOfLastElement);

			--mSize;
		}

		T& GetData(Entity entity) {
			assert(mEntityToIndexMap.find(entity) != mEntityToIndexMap.end() && \
			"Retrieving non-existent component.");

			// Return a reference to the entity's component
			return mComponentArray[mEntityToIndexMap[entity]];
		}

		void EntityDestroyed(Entity entity) override {
			if (mEntityToIndexMap.find(entity) != mEntityToIndexMap.end()) {
				// Remove the entity's component if it existed
				RemoveData(entity);
			}
		}

	private:
		// The packed array of components (of generic type T),
		// set to a specified maximum amount, matching the maximum number
		// of entities allowed to exist simultaneously, so that each entity
		// has a unique spot.
		std::array<T, MAX_ENTITIES> mComponentArray;

		// Map from an entity ID to an array index.
		std::unordered_map<Entity, size_t> mEntityToIndexMap;

		// Map from an array index to an entity ID.
		std::unordered_map<size_t, Entity> mIndexToEntityMap;

		// Total size of valid entries in the array.
		size_t mSize;
};

   The unordered_map does have a performance penalty because when you want to get the ID of a component
   to grab it from the contiguous array, you have to request it from the unordered_map which is not
   contiguous. An alternative would be to use arrays instead.

   But the unordered_maps have the nice property of supporting find(), insert(), and delete(), which
   allow for asserting validity without "if(valid)" checks and it's a bit clearer then setting array
   elements to some "INVALID" value.

   The virtual inheritance of IComponentArray is unfortunate but, as far as I can tell, unavoidable. As
   seen later, we'll have a list of every ComponentArray (one per component type), and we need to notify
   all of them when an entity is destroyed so that it can remove the entity's data if it exists. The
   only way to keep a list of multiple templated types is to keep a list of their common interface so
   that we can call EntityDestroyed() on all of them.

   Another method is to use events, so that every ComponentArray can subscribe to an Entity Destroyed
   event and then respond accordingly. This was my original approach but I decided to keep
   ComponentArrays relatively stupid.

   Yet another method would be to use some fancy template magic and reflection, but I wanted to keep it
   as simple as possibe for my own sanity. The cost of calling the virtual function EntityDestroyed()
   should be minimal because it isn't something that happens every single frame.

The Component Manager
   Now we can implement the Component Manager, which is in charge of talking to all of the different
   ComponentArrays when a component needs to be added or removed.

   As mentioned earlier, we need to have a unique ID for every type of component so that it can have a
   bit in a signature. To accomplish that without pain, I have the Component Manager have a
   ComponentType variable that increments by one with every component type that is registered. I've seen
   implementations that don't require any sort of RegisterComponent functionality, but I've found it to
   be the simplest method. The downside is that any time you add a new type of component to your game
   and want to use it, you will first need to call RegisterComponent.

   C++ offers a convenient function that will return a pointer to a const char array representation of a
   type T. That pointer (which is just an integer) can be used as a unique key into a map of
   ComponentTypes.

   That same key is also used as a unique key into a map of IComponentArray pointers, so there is one
   ComponentArray instantiation per ComponentType.

class ComponentManager {
	public:
		template<typename T>
			void RegisterComponent() {
				const char* typeName = typeid(T).name();

				assert(mComponentTypes.find(typeName) == mComponentTypes.end() && \
				"Registering component type more than once.");

				// Add this component type to the component type map
				mComponentTypes.insert({typeName, mNextComponentType});

				// Create a ComponentArray pointer and add it to the component arrays map
				mComponentArrays.insert({typeName, std::make_shared<ComponentArray<T>>()});

				// Increment the value so that the next component registered will be different
				++mNextComponentType;
			}

		template<typename T>
			ComponentType GetComponentType() {
				const char* typeName = typeid(T).name();

				assert(mComponentTypes.find(typeName) != mComponentTypes.end() && \
				"Component not registered before use.");

				// Return this component's type - used for creating signatures
				return mComponentTypes[typeName];
			}

		template<typename T>
			void AddComponent(Entity entity, T component) {
				// Add a component to the array for an entity
				GetComponentArray<T>()->InsertData(entity, component);
			}

		template<typename T>
			void RemoveComponent(Entity entity) {
				// Remove a component from the array for an entity
				GetComponentArray<T>()->RemoveData(entity);
			}

		template<typename T>
			T& GetComponent(Entity entity) {
				// Get a reference to a component from the array for an entity
				return GetComponentArray<T>()->GetData(entity);
			}

		void EntityDestroyed(Entity entity) {
			// Notify each component array that an entity has been destroyed
			// If it has a component for that entity, it will remove it
			for (auto const& pair : mComponentArrays) {
				auto const& component = pair.second;

				component->EntityDestroyed(entity);
			}
		}

	private:
		// Map from type string pointer to a component type
		std::unordered_map<const char*, ComponentType> mComponentTypes{};

		// Map from type string pointer to a component array
		std::unordered_map<const char*, std::shared_ptr<IComponentArray>> mComponentArrays{};

		// The component type to be assigned to the next registered component - starting at 0
		ComponentType mNextComponentType{};

		// Convenience function to get the statically casted pointer to the ComponentArray of type T.
		template<typename T>
			std::shared_ptr<ComponentArray<T>> GetComponentArray() {
				const char* typeName = typeid(T).name();

				assert(mComponentTypes.find(typeName) != mComponentTypes.end() && \
				"Component not registered before use.");

				return std::static_pointer_cast<ComponentArray<T>>(mComponentArrays[typeName]);
			}
};

The System
   A system is any functionality that iterates upon a list of entities with a certain signature of
   components.

   Every system needs a list of entities, and we want some logic outside of the system (in the form of a
   manager to maintain that list), so I use a System base class that has only a std::set of entities.

   I chose a std::set rather than a std::list for a few reasons.

   First, each entity is unique, and a set is defined as having every element be unique, so it maps well
   logically.

   Second, each entity is an integer which makes for easy compares when inserting/removing from the set.
   Removing a specific entity from a list is O(n) because you have to start at the beginning and
   possibly go to the end, while removing from a set is O(log n) because it's a binary tree. However,
   inserting into a list is only O(1) while inserting into a set is O(log n) as well.

   Third, it makes the code easier to understand and read. With a list, you have to use std::find to
   check if an entity is in the list, but with std::set you can just call insert() and erase() directly
   without any checks. If trying to insert when it's already in, it does nothing. If trying to erase
   when it doesn't exist, it does nothing.

   Fourth, I tested using a list and using a set, and a set was faster.

class System {
	public:
		std::set<Entity> mEntities;
};

   Each system can then inherit from this class which allows the System Manager (see next section) to
   keep a list of pointers to systems. Inheritance, but not virtual.

   A system could then do something like this:

for (auto const& entity : mEntities) {
	auto& rigidBody = GetComponent<RigidBody>(entity);
	auto& transform = GetComponent<Transform>(entity);
	auto const& gravity = GetComponent<Gravity>(entity);

	transform.position += rigidBody.velocity * dt;

	rigidBody.velocity += gravity.force * dt;
}

   A RigidBody, a Transform, and a Gravity will be pulled into the cache for this entity as well as for
   all of the entities near it in the component array, which are likely to be needed with the next
   entity in the list of entities.

The System Manager
   The System Manager is in charge of maintaining a record of registered systems and their signatures.
   When a system is registered, it's added to a map with the same typeid(T).name() trick used for the
   components. That same key is used for a map of system pointers as well.

   As with components, this approach requires a call to RegisterSystem() for every additional system
   type added to the game.

   Each system needs to have a signature set for it so that the manager can add appropriate entities to
   each systems's list of entities. When an entity's signature has changed (due to components being
   added or removed), then the system's list of entities that it's tracking needs to be updated.

   If an entity that the system is tracking is destroyed, then it also needs to update its list.

class SystemManager {
	public:
		template<typename T>
			std::shared_ptr<T> RegisterSystem() {
				const char* typeName = typeid(T).name();

				assert(mSystems.find(typeName) == mSystems.end() && "Registering system more than once.");

				// Create a pointer to the system and return it so it can be used externally
				auto system = std::make_shared<T>();
				mSystems.insert({typeName, system});
				return system;
			}

		template<typename T>
			void SetSignature(Signature signature) {
				const char* typeName = typeid(T).name();

				assert(mSystems.find(typeName) != mSystems.end() && "System used before registered.");

				// Set the signature for this system
				mSignatures.insert({typeName, signature});
			}

		void EntityDestroyed(Entity entity) {
			// Erase a destroyed entity from all system lists
			// mEntities is a set so no check needed
			for (auto const& pair : mSystems) {
				auto const& system = pair.second;

				system->mEntities.erase(entity);
			}
		}

		void EntitySignatureChanged(Entity entity, Signature entitySignature) {
			// Notify each system that an entity's signature changed
			for (auto const& pair : mSystems) {
				auto const& type = pair.first;
				auto const& system = pair.second;
				auto const& systemSignature = mSignatures[type];

				// Entity signature matches system signature - insert into set
				if ((entitySignature & systemSignature) == systemSignature) {
					system->mEntities.insert(entity);
				}
				// Entity signature does not match system signature - erase from set
				else {
					system->mEntities.erase(entity);
				}
			}
		}

	private:
		// Map from system type string pointer to a signature
		std::unordered_map<const char*, Signature> mSignatures{};

		// Map from system type string pointer to a system pointer
		std::unordered_map<const char*, std::shared_ptr<System>> mSystems{};
};

The Coordinator
   We now have quite a lot of functionality built up. We have entities which are managed by an Entity
   Manager. We have components which are managed by a Component Manager. And we have systems which are
   managed by a System Manager. These three managers also need to talk to each other.

   There are a few ways of accomplishing that, such as having them all be globals, or using an event
   system, but I opted to instead bundle them into a single class called Coordinator (alternative name
   suggestions welcome) that acts as a mediator. This allows us to have a single instance of the
   coordinator (as a global or whatever you want), and we can use it to interface with all of the
   managers. It also makes usage easier because you can replace this:

Entity player = entityManager.CreateEntity();
componentManager.AddComponent<Transform>(player);
RenderSystem renderSystem = systemManager.RegisterSystem<RenderSystem>();

   With this:

Entity player = coordinator.CreateEntity();
coordinator.AddComponent<Transform>(player);
RenderSystem renderSystem = coordinator.RegisterSystem<RenderSystem>();

   The coordinator has pointers to each manager and does some meta-managing between them.

class Coordinator {
	public:
		void Init() {
			// Create pointers to each manager
			mComponentManager = std::make_unique<ComponentManager>();
			mEntityManager = std::make_unique<EntityManager>();
			mSystemManager = std::make_unique<SystemManager>();
		}


		// Entity methods
		Entity CreateEntity() {
			return mEntityManager->CreateEntity();
		}

		void DestroyEntity(Entity entity) {
			mEntityManager->DestroyEntity(entity);

			mComponentManager->EntityDestroyed(entity);

			mSystemManager->EntityDestroyed(entity);
		}

		// Component methods
		template<typename T>
			void RegisterComponent() {
				mComponentManager->RegisterComponent<T>();
			}

		template<typename T>
			void AddComponent(Entity entity, T component) {
				mComponentManager->AddComponent<T>(entity, component);

				auto signature = mEntityManager->GetSignature(entity);
				signature.set(mComponentManager->GetComponentType<T>(), true);
				mEntityManager->SetSignature(entity, signature);

				mSystemManager->EntitySignatureChanged(entity, signature);
			}

		template<typename T>
			void RemoveComponent(Entity entity) {
				mComponentManager->RemoveComponent<T>(entity);

				auto signature = mEntityManager->GetSignature(entity);
				signature.set(mComponentManager->GetComponentType<T>(), false);
				mEntityManager->SetSignature(entity, signature);

				mSystemManager->EntitySignatureChanged(entity, signature);
			}

		template<typename T>
			T& GetComponent(Entity entity) {
				return mComponentManager->GetComponent<T>(entity);
			}

		template<typename T>
			ComponentType GetComponentType() {
				return mComponentManager->GetComponentType<T>();
			}


		// System methods
		template<typename T>
			std::shared_ptr<T> RegisterSystem() {
				return mSystemManager->RegisterSystem<T>();
			}

		template<typename T>
			void SetSystemSignature(Signature signature) {
				mSystemManager->SetSignature<T>(signature);
			}

	private:
		std::unique_ptr<ComponentManager> mComponentManager;
		std::unique_ptr<EntityManager> mEntityManager;
		std::unique_ptr<SystemManager> mSystemManager;
};

   I've seen implementations that create an entity class that acts as a wrapper to an ID with methods
   that call into the EntityManager and ComponentManager directly (e.g., entity.RemoveComponent()),
   which makes for more intuitive usage, but I found it to cause the code to be more complicated and
   hard to understand. I tried to do it that way multiple times but each time came upon recursive header
   issues. In the end I opted for the cleaner but less intuitive Coordinator.

Demo
   Now let's see how all of this might be used in a demo that instantiates 10,000 cubes and then has
   them fall under the influence of gravity. We'll ignore the rendering and the math classes because
   that isn't what this post is about, but keep in mind there is also a rendering system and a Vec3
   class.

   We have the following components:

struct Gravity {
	Vec3 force;
};

struct RigidBody {
	Vec3 velocity;
	Vec3 acceleration;
};

struct Transform {
	Vec3 position;
	Vec3 rotation;
	Vec3 scale;
};

   A system for rudimentary physics integration:

extern Coordinator gCoordinator;

void PhysicsSystem::Update(float dt) {
	for (auto const& entity : mEntities) {
		auto& rigidBody = gCoordinator.GetComponent<RigidBody>(entity);
		auto& transform = gCoordinator.GetComponent<Transform>(entity);
		auto const& gravity = gCoordinator.GetComponent<Gravity>(entity);

		transform.position += rigidBody.velocity * dt;

		rigidBody.velocity += gravity.force * dt;
	}
}

   Then the main loop:

Coordinator gCoordinator;

int main() {
	gCoordinator.Init();

	gCoordinator.RegisterComponent<Gravity>();
	gCoordinator.RegisterComponent<RigidBody>();
	gCoordinator.RegisterComponent<Transform>();

	auto physicsSystem = gCoordinator.RegisterSystem<PhysicsSystem>();

	Signature signature;
	signature.set(gCoordinator.GetComponentType<Gravity>());
	signature.set(gCoordinator.GetComponentType<RigidBody>());
	signature.set(gCoordinator.GetComponentType<Transform>());
	gCoordinator.SetSystemSignature<PhysicsSystem>(signature);

	std::vector<Entity> entities(MAX_ENTITIES);

	std::default_random_engine generator;
	std::uniform_real_distribution<float> randPosition(-100.0f, 100.0f);
	std::uniform_real_distribution<float> randRotation(0.0f, 3.0f);
	std::uniform_real_distribution<float> randScale(3.0f, 5.0f);
	std::uniform_real_distribution<float> randGravity(-10.0f, -1.0f);

	float scale = randScale(generator);

	for (auto& entity : entities) {
		entity = gCoordinator.CreateEntity();

		gCoordinator.AddComponent(
				entity,
				Gravity{Vec3(0.0f, randGravity(generator), 0.0f)});

		gCoordinator.AddComponent(
				entity,
				RigidBody{
				.velocity = Vec3(0.0f, 0.0f, 0.0f),
				.acceleration = Vec3(0.0f, 0.0f, 0.0f)
				});

		gCoordinator.AddComponent(
				entity,
				Transform{
				.position = Vec3(randPosition(generator), randPosition(generator), randPositio
						n(generator)),
				.rotation = Vec3(randRotation(generator), randRotation(generator), randRotatio
						n(generator)),
				.scale = Vec3(scale, scale, scale)
				});
	}

	float dt = 0.0f;

	while (!quit) {
		auto startTime = std::chrono::high_resolution_clock::now();

		physicsSystem->Update(dt);

		auto stopTime = std::chrono::high_resolution_clock::now();

		dt = std::chrono::duration<float, std::chrono::seconds::period>(stopTime - startTime).count();
	}
}

   Here is the result:

   Here is the output from Valgrind's cachegrind tool if you're curious:

==15445== I   refs:      3,632,270,619
==15445== I1  misses:       87,147,982
==15445== LLi misses:           26,599
==15445== I1  miss rate:          2.40%
==15445== LLi miss rate:          0.00%
==15445==
==15445== D   refs:      1,583,125,924  (1,045,689,190 rd   + 537,436,734 wr)
==15445== D1  misses:       11,968,989  (    7,776,523 rd   +   4,192,466 wr)
==15445== LLd misses:          505,598  (      270,649 rd   +     234,949 wr)
==15445== D1  miss rate:           0.8% (          0.7%     +         0.8%  )
==15445== LLd miss rate:           0.0% (          0.0%     +         0.0%  )
==15445==
==15445== LL refs:          99,116,971  (   94,924,505 rd   +   4,192,466 wr)
==15445== LL misses:           532,197  (      297,248 rd   +     234,949 wr)
==15445== LL miss rate:            0.0% (          0.0%     +         0.0%  )

   This is a very simple example of course, but it's still fun.

   Circling back to the beginning about components also making complex behavior easier, we could easily
   flip our demo by not adding a RigidBody or a Gravity to the cubes, and instead adding them to the
   camera.

   That is the camera falling down while the cubes remain still.

Conclusion
   If you were skeptical about the idea of an ECS, I hope I've convinced you it has its merits. And if
   you were confused about how to implement one (like I was for a long time), I hope I've helped you
   find a way.

Source Code
   You can find all of the source code [https://code.austinmorlan.com/austin/2019-ecs]here.
   All of the ECS-related source code exists only in headers for two reasons. First, there are a lot of
   templates which must be in headers anyway. Second, it may possibly increase the odds that the
   compiler will inline.


---
https://prdeving.wordpress.com/2018/06/27/videogames-programming-ecs-system-in-plain-c/

Videogames programming: ECS system in plain C

   ECS stands for Entity - Component - System, it's a paradigm introduced in the industry more than a
   decade ago but even today it's still being one of the most used options while designing games.

   When building a game your code goes messy really fast, even faster if you haven't defined everything
   clearly beforehand, games have interdependencies, connections, interactions and states that makes
   them really hard and tricky to design, and, when they grow they tend to be a messy hank of code and
   classes, here's where ECS comes to the rescue.

   The concept of ECS is pretty simple, it assumes that every single "entity"  in the game (npcs,
   player, items, etc) is formed by common models or behaviours,  so, if an NPC has a "movement"
   behaviour that takes the target location from an AI mechanism, the player has the same behivour but
   it's target location is taken from the user input.
   assuming that this hypothesis is right (and it's right, almost), if you had enough pieces for storing
   the data (components) and enough mechanisms to execute actions based on the data of each entity
   (systems) you could build every single entity needed for your game.

How does it work?
   The main idea is simple, of course, there are thousands of variations and each of them is used and
   has it's own pros and cons, but the root is the same: You have an entity that stores components, then
   you have components that stores data, then you have some systems that runs entity by entity executing
   tasks depending on the component that entity have. Let's see some pseudocode:

obj Component_position {
	x, y
}

obj Entity {
	list Components[Component_position]
}

fn System_movement (Entity){
	if (Entity have Component_position) {
		Entity -> Components -> Component_position -> x ++
	}
}

fn System_draw (Entity){
	if (Entity have Component_position) {
		DrawRect(Entity -> Component_position)
	}
}

define Entity;
gameloop(
	System_movement(Entity)
	System_draw (Entity)
)

Now in C99
   Well, first of all, this system is based in a proof of concept implementation that i wrote to check
   if an ECS could fit in my current project, a PSP rpg ("mount and blade"-like) game, so i had to have
   in mind some preconditions.
     * The PSP has 32Mb RAM
     * The PSP has 333MHz CPU
     * I want my game to manage ~200 different items

   I don't care too much about CPU tho, indeed my main objective is to fit all the data models of my
   entities in just 1Mb of ram. Also, my implementation had to have near to 0 boilerplate. Let's see.

   First, the Components. I want my components to act as partial models for the entities, the Entity
   model will be built with components, components won't have any logic or other components by
   themselves.

typedef struct {
	float x;
	float y;
} ComponentPosition;

typedef struct {
	int color;
	int size;
} ComponentDraw;

   Once we have the components we need a list, in C++ we might want to use a vector<> and, of course i
   could have used an array, but i instead used a data structure that holds pointers to all possible
   components, why?

   This is a really bad idea, if the components list grows bigger it will be unmantainable, but i don't
   want boilerplate.

   Other issue with this design is that the CPU cache is almost not used, i'm storing an object that
   stores pointers, and those objects (Component structure) are stored inside the Entities, no cache no
   party.

   Serious ECS systems uses an UID correlation where the Entity is refered from the components that are
   in an array, this is pretty similar to data oriented design, it's leveraged by CPU cache, is easier
   to mantain and doesn't waste that much memory.

typedef struct {
	ComponentPosition *componentPosition;
	ComponentDraw *componentDraw;
} Components;

   Now the Entity itself, as i said before, the entity is just the data model for the element it
   represents in the game, in this case, that model is built by the components.

typedef struct {
	unsigned int uuid;
	Components components;
} Entity;

   Components has to be added to the entity so the model can be built, this is done programatically. As
   stated before, the component container have pointers so we need to "malloc" the components, is this a
   good idea? well, as long as the component container exists, this is the less memory-intensive way to
   do it.

void addComponentPosition(Entity *entity, int x, int y) {
	entity -> components.componentPosition = malloc(sizeof(ComponentPosition));
	entity -> components.componentPosition -> x = x;
	entity -> components.componentPosition -> y = y;
}

void addComponentDraw(Entity *entity, int color, int size) {
	entity -> components.componentDraw = malloc(sizeof(ComponentDraw));
	entity -> components.componentDraw -> color = color;
	entity -> components.componentDraw -> size = size;
}

   And of course, we need  a way to free the memory.

void freeEntity(Entity *entity) {
	if (entity -> components.componentPosition) free(entity -> components.componentPosition);
	if (entity -> components.componentDraw) free(entity -> components.componentDraw);
}

   Now we can define our entity. Entity definitions are like recipes.

Entity npc;
addComponentPosition(&npc, 0, 0);
addComponentDraw(&npc, 0xFF00FF, 20);

   Then the systems, in my case i wanted them to be as granular as possible, even if it's not good for
   my CPU performance, i wanted to be able to test the architecture as a hybrid solution, so i wanted
   tiny specialized systems. As we are replicating the example above we will need two systems, one to
   update the position and the other to draw the entity.

   I want my game state to have as little logic as possible, so the systems have to be able to run on
   every single entity, even if that entity doesn't have the needed data.

int updatePositionSystem(Entity *entity) {
	if (!entity -> Components.componentPosition) return 1;
	entity -> Components.componentPosition -> x++;
}

int DrawSystem(Entity *entity) {
	if (!entity -> Components.componentPosition || ! entity -> Components.componentDraw) return 1;

	drawRectangle(
		entity -> Components.componentPosition -> x,
		entity -> Components.componentPosition -> y,
		entity -> Components.componentDraw -> size,
		entity -> Components.componentDraw -> color
	);
}

   Then those systems are called in the game loop, if there are more entities, the systems are called
   inside the entities loop, so each system is called once for each entity. In a real-world example we
   would see some systems running in threads and iterating the components at it's own, in my case,
   systems are used inside the loop for simplicity.

   Cool, right? This is just an approach, it's not even the best approach, it's not even a good one but
   i think it helps to clarify what a ECS is and how it works.

Conclusion
   Is ECS the final perfect answer for all our game-development problems?
   The answer is simple, NO. ECS is just an architecture, and, as always, it's good for some projects
   and bad for others. As you can see, it might be good when you are building something big, with tons
   of different entities that have to interact with each other or with the game world, but the
   boilerplate of a proper ECS system makes it unsuitable for little projects.

   On the other hand, even with large code bases, once the ECS is implemented and stable the development
   is much more fluid and easy, entity definition is just a recipe as you can notice in the examples, so
   you can build new ones in a couple lines. It also helps with projects where live changes are key, do
   you want to change the controllable character? just delete the UserInputComponent from the character
   and add it to other entity.


---
https://aframe.io/docs/1.7.0/introduction/entity-component-system.html

Entity-Component-System

   A-Frame is a three.js framework with an entity-component-system (ECS) architecture. ECS
   architecture is a common and desirable pattern in 3D and game development that follows the
   composition over inheritance and hierarchy principle.

   The benefits of ECS include:
    1. Greater flexibility when defining objects by mixing and matching reusable parts.
    2. Eliminates the problems of long inheritance chains with complex interwoven functionality.
    3. Promotes clean design via decoupling, encapsulation, modularization, reusability.
    4. Most scalable way to build a VR application in terms of complexity.
    5. Proven architecture for 3D and VR development.
    6. Allows for extending new features (possibly sharing them as community components).

   On the 2D Web, we lay out elements that have fixed behavior in a hierarchy. 3D and VR is different;
   there are infinite types of possible objects that have unbounded behavior. ECS provides a manageable
   pattern to construct types of objects.

   Below are great introductory materials to ECS architecture. We recommend skimming through them to get
   a better grasp of the benefits. ECS is well-suited for VR development, and A-Frame is based entirely
   around this paradigm:
     * Entity-component-system on Wikipedia
     * What is an Entity System? by Adam Martin
     * Decoupling Patterns - Component on Game Programming Patterns
     * Evolve Your Hierarchy by Mick West

   A well-known game engine implementing ECS is Unity. Although there are pain points in cross-entity
   communication, we'll see how A-Frame, the DOM, and declarative HTML really make ECS shine.

Concept
   ECS Minecraft
   A basic definition of ECS involves:
     * Entities are container objects into which components can be attached. Entities are the base
       of all objects in the scene. Without components, entities neither do nor render anything, similar
       to empty <div>s.
     * Components are reusable modules or data containers that can be attached to entities to
       provide appearance, behavior, and/or functionality. Components are like plug-and-play for
       objects. All logic is implemented through components, and we define different types of objects by
       mixing, matching, and configuring components. Like alchemy!
     * Systems provide global scope, management, and services for classes of components. Systems
       are often optional, but we can use them to separate logic and data; systems handle the logic,
       components act as data containers.

Examples
   Some abstract examples of different types of entities built from composing together different
   components:
     * Box = Position + Geometry + Material
     * Light Bulb = Position + Light + Geometry + Material + Shadow
     * Sign = Position + Geometry + Material + Text
     * VR Controller = Position + Rotation + Input + Model + Grab + Gestures
     * Ball = Position + Velocity + Physics + Geometry + Material
     * Player = Position + Camera + Input + Avatar + Identity

   As another abstract example, imagine we want to build a car entity by assembling components:
     * We can attach a material component that has properties such as "color" or "shininess" that
       affects the appearance of the car.
     * We can attach an engine component that has properties such as "horsepower" or "weight" that
       affects the functionality of the car.
     * We can attach a tire component that has properties such as "number of tires" or "steering angle"
       that affects the behavior of the car.

   So we can create different types of cars by varying the properties of the material, engine, and tire
   component. The material, engine, and tire components don't have to know about each other and can even
   be used in isolation for other cases. We could mix and match them to create even different types of
   vehicles:
     * To create a boat entity: remove the tire component.
     * To create a motorcycle entity: change tire component's number of tires to 2, configure the engine
       component to be smaller.
     * To create an airplane entity: attach wing and jet components.

   Contrast this to traditional inheritance where if we want to extend an object, we would have to
   create a large class that tries to handle everything or an inheritance chain.

ECS in A-Frame
   A-Frame has APIs that represents each piece of ECS:
     * Entities are represented by the <a-entity> element and prototype.
     * Components are represented by HTML attributes on <a-entity>'s. Underneath, components are objects
       containing a schema, lifecycle handlers, and methods. Components are registered via the
       AFRAME.registerComponent (name, definition) API.
     * Systems are represented by <a-scene>'s HTML attributes. System are similar to components in
       definition. Systems are registered via the AFRAME.registerSystem (name, definition) API.

Syntax
   We create <a-entity> and attach components as HTML attributes. Most components have multiple
   properties that are represented by a syntax similar to HTMLElement.style CSS. This syntax takes
   the form with a colon (:) separating property names from property values, and a semicolon (;)
   separating different property declarations:

   <a-entity ${componentName}="${propertyName1}: ${propertyValue1}; ${propertyName2}:
   ${propertyValue2}">

   For example, we have <a-entity> and attach the geometry, material, light, and
   position components with various properties and property values:
<a-entity geometry="primitive: sphere; radius: 1.5"
          light="type: point; color: white; intensity: 2"
          material="color: white; shader: flat; src: glow.jpg"
          position="0 0 -5"></a-entity>

Composition
   From there, we could attach more components to add additional appearance, behavior, or functionality
   (e.g., physics). Or we could update the component values to configure the entity (either
   declaratively or through .setAttribute).

   Composing an Entity
   A common type of entity to compose from multiple components are the player's hands in VR. The
   player's hands can have many components: appearance, gestures, behaviors, interactivity with other
   objects.

   We plug in components into a hand entity to provide it behavior as if we were attaching superpowers
   or augmentations for VR! Each of the components below have no knowledge of each other, but can be
   combined to define a complex entity:
<a-entity
  tracked-controls  <!-- Hook into the Gamepad API for pose. -->
  vive-controls  <!-- Vive button mappings. -->
  meta-touch-controls  <!-- Oculus button mappings. -->
  hand-controls  <!-- Appearance (model), gestures, and events. -->
  laser-controls <!-- Laser to interact with menus and UI. -->
  sphere-collider  <!-- Listen when hand is in contact with an object. -->
  grab  <!-- Provide ability to grab objects. -->
  throw <!-- Provide ability to throw objects. -->
  event-set="_event: grabstart; visible: false"  <!-- Hide hand when grabbing object. -->
  event-set="_event: grabend; visible: true"  <!-- Show hand when no longer grabbing object. -->
>

Declarative DOM-Based ECS
   A-Frame takes ECS to another level by making it declarative and based on the DOM. Traditionally,
   ECS-based engines would create entities, attach components, update components, remove components all
   through code. But A-Frame has HTML and the DOM which makes ECS ergonomic and resolves many of its
   weaknesses. Below are abilities that the DOM provides for ECS:
    1. Referencing Other Entities with Query Selectors: The DOM provides a powerful query selector
       system which lets us query the scene graph and select an entity or entities that match a
       condition. We can get references to entities by IDs, classes, or data attributes. Because A-Frame
       is based on HTML, we can use query selectors out of the box. document.querySelector('#player').
    2. Decoupled Cross-Entity Communication with Events: The DOM provides the ability to listen to and
       emit events. This provides a publish-subscribe communication system between entities. Components
       don't have to know about each other, they can just emit an event (which could bubble up), and
       other components can listen to those events without calling each other. ball.emit('collided').
    3. APIs for Lifecycle Management with DOM APIs: The DOM provides APIs to update HTML elements and
       the tree including .setAttribute, .removeAttribute, .createElement, and .removeChild. These can
       be used as is just like in normal web development.
    4. Entity-Filtering with Attribute Selectors: The DOM provides attribute selectors which allows us
       to query for an entity or entities that have or don't have certain HTML attributes. This means we
       can ask for entities that have or don't have a certain set of components.
       document.querySelector('[enemy]:not([alive])').
    5. Declarativeness: Lastly, the DOM provides HTML. A-Frame bridges between ECS and HTML making an
       already clean pattern declarative, readable, and copy-and-pasteable.

Extensibility
   A-Frame components can do anything. Developers are given permissionless innovation to create
   components to extend any feature. Components have full access to JavaScript, three.js, and Web APIs
   (e.g., WebRTC, Speech Recognition).

   We will later go over in detail how to write an A-Frame component. As a preview, the structure
   of a basic component may look like:

AFRAME.registerComponent('foo', {
	schema: {
		bar: {type: 'number'},
		baz: {type: 'string'}
	},
	init: function () {
		// Do something when component first attached.
	},
	update: function () {
		// Do something when component's data is updated.
	},
	remove: function () {
		// Do something when the component or its entity is detached.
	},
	tick: function (time, timeDelta) {
		// Do something on every scene tick or frame.
	}
});

   Declarative ECS grants us the ability to write a JavaScript module and abstract it through HTML. Once
   the component is registered, we can declaratively plug this module of code into an entity via an HTML
   attribute. This code-to-HTML abstraction makes ECS powerful and easy to reason. foo is the name of
   the component we just registered, and the data contains bar and baz properties:
<a-entity foo="bar: 5; baz: bazValue"></a-entity>

Component-Based Development
   For building VR applications, we recommend placing all application code within components (and
   systems). An ideal A-Frame codebase consists purely of modular, encapsulated, and decoupled
   components. These components can be unit tested in isolation or alongside other components.

   When an application is created solely with components, all parts of its codebase become reusable!
   Components can be shared for other developers to use or we can reuse them in our other projects. Or
   the components can be forked and modified to adapt to other use cases.

   A simple ECS codebase might be structured like:
index.html
	components/
		ball.js
		collidable.js
		grabbable.js
		enemy.js
		scoreboard.js
		throwable.js

Higher-Order Components
   Components can set other components on the entity, making them a higher-order or higher-level
   component in abstraction.

   For example, the cursor component sets and builds on top of the raycaster component. Or the
   hand-controls component sets and builds on top of the vive-controls component and
   meta-touch-controls component which in turn build on top of the tracked-controls component.

Community Component Ecosystem
   Components can be shared into the A-Frame ecosystem for the community to use. The wonderful thing
   about A-Frame's ECS is extensibility. An experienced developer can develop a physics system or
   graphics shader components, and an novice developer can take those components and use them in their
   scene from HTML just by dropping in a <script> tag. We can use powerful published components without
   having to touch JavaScript.

Where to Find Components
   There are hundreds of components out in the wild. We try our best to make them discoverable. If you
   develop a component, please submit it through these channels to share!

npm
   Most A-Frame components are published on npm as well as GitHub. We can use npm's search to
   search for packages tagged with aframe-component. This is a great place to look for a more complete
   list of components.

   For a list of components with the A-Frame version that the component was last tested with, check out
   the community-maintained Component Directory on the A-Frame Wiki.

GitHub Projects
   Many A-Frame applications are developed purely from components, and many of those A-Frame
   applications are open source on GitHub. Their codebases will contain components that we can use
   directly, refer to, or copy from. Projects to look at include:
     * BeatSaver Viewer
     * Super Says
     * A-Painter
     * A-Blast

A-Frame Blog
   The A-Frame Blog archives include details of components as they were released or updated, and can be
   a good place to find links to components.

A-Frame Wiki
   The A-Frame Wiki is a useful community-driven initiative that collects information and tips
   about available A-Frame components. Everyone is encouraged to participate. It's very easy to add and
   edit information.

Using a Community Component
   Once we find a component that we want to use, we can include the component as a <script> tag and use
   it from HTML.

   For example, let's use the particle system component:

Using unpkg
   First, we have to grab a CDN link to the component JS file. The documentation of the component will
   usually have a CDN link or usage information. But a way to get the most up-to-date CDN link is to use
   unpkg.com.

   unpkg is a CDN that automatically hosts everything that is published to npm. unpkg can resolve
   semantic versioning and provide us the version of the component we want. A URL takes the form of:
https://unpkg.com/<npm package name>@<version>/<path to file>

   If we want the latest version, we can exclude the version:
https://unpkg.com/<npm package name>/<path to file>

   Rather than typing in the path to the built component JS file, we can exclude path to file to be able
   to browse the directories of the component package. The JS file will usually be in a folder called
   dist/ or build/ and end with .min.js.

   For the particle system component, we head to:
https://unpkg.com/aframe-particle-system-component/

   Note the ending slash (/). Find the file we need, right click, and hit Copy Link to Address to copy
   the CDN link into our clipboard.

   unpkg

Including the Component JS File
   Then head to our HTML. Under the <head>, after the A-Frame JS <script> tag, and before <a-scene>, we
   will include our JS file with a <script> tag.

   For the particle system component, the CDN link we found earlier (at time of writing) was:
https://unpkg.com/@c-frame/[email protected]/dist/aframe-particle-system-component.min.js

   Now we can include it into our HTML:
<html>
  <head>
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
    <script src="https://unpkg.com/@c-frame/aframe-particle-system-component@1.2.x/dist/aframe-particle-system-component.min.js"></script>
  </head>
  <body>
    <a-scene>
    </a-scene>
  </body>
</html>

Using the Component

   Follow the documentation of the component on how to use it in implementation. But generally, the
   usage involves attaching the component to an entity and configuring it. For the particle system
   component:

   Now we can include it into our HTML:
<html>
  <head>
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
    <script src="https://unpkg.com/@c-frame//dist/aframe-particle-system-component.min.j
s"></script>
  </head>
  <body>
    <a-scene>
      <a-entity particle-system="preset: snow" position="0 0 -10"></a-entity>
    </a-scene>
  </body>
</html>

Using jsdelivr for CDN

   JSDELIVR is an alternative CDN to unpkg. One benefit of JSDELIVR is that it can download files
   from GitHub as well as NPM.

   You can convert unpkg URLs to JSDELIVR URLs using this link: https://www.jsdelivr.com/unpkg

   You can convert GitHub URLs to JSDELIVR URLs using this link: https://www.jsdelivr.com/github

Example

   Community Components Example
   Below is a complete example of using various community components from the Registry and using the
   JSDELIVR CDN. This example can also be viewed in the A-Frame Examples.
<html>
  <head>
    <title>Community Components Example</title>
    <meta name="description" content="Community Components Example">
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
    <script src="https://unpkg.com/@c-frame/aframe-simple-sun-sky@^1.2.2/dist/aframe-particle-system-component.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-simple-sun-sky@^1.2.2/simple-sun-sky.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frameaframe-particle-system-component@1.2.x/dist/aframe-extras.min.js"></scrip
t>
  </head>
  <body>
    <a-scene>
      <a-entity id="rain" particle-system="preset: rain; color: #24CAFF; particleCount: 5000"></a-entity>
      <a-entity id="sphere" geometry="primitive: sphere"
                material="color: #EFEFEF; shader: flat"
                position="0 0.15 -5"
                light="type: point; intensity: 5"
                animation="property: position; easing: easeInOutQuad; dir: alternate; dur: 1000; to: 0 -0.10 -5; loop: true"></a-entity>
      <a-entity id="ocean" ocean="density: 20; width: 50; depth: 50; speed: 4"
                material="color: #9CE3F9; opacity: 0.75; metalness: 0; roughness: 1"
                rotation="-90 0 0"></a-entity>
      <a-simple-sun-sky sun-position="1 0.4 0"></a-simple-sun-sky>
      <a-entity id="light" light="type: ambient; color: #888"></a-entity>
    </a-scene>
  </body>
</html>

   The A-Frame project and content on this site are licensed under the MIT License.


---
https://www.richardlord.net/blog/ecs/what-is-an-entity-framework.html

What is an Entity Component System architecture for game development?
19 January 2012

   Last week I released Ash, an entity component system framework for Actionscript game development,
   and a number of people have asked me the question "What is an entity component system framework?".
   This is my rather long answer.

   Entity systems are growing in popularity, with well-known examples like Unity, and lesser known
   frameworks like Actionscript frameworks Ember2, Xember and my own Ash. There's a very
   good reason for this; they simplify game architecture, encourage clean separation of responsibilities
   in your code, and are fun to use.

   In this post I will walk you through how an entity based architecture evolves from the old fashioned
   game loop. This may take a while. The examples will be in Actionscript because that happens to be
   what I'm using at the moment, but the architecture applies to all programming language.

   Note that the naming of things within this post is based on
     * How they were named as I discovered these archtectures over the past twenty years of my game
       development life
     * How they are usually named in modern entity component system architectures

   This is different, for example, to how they are named in Unity, which is an entity architecture but
   is not an entity component system architecture.

   This is based on a presentation I gave at try{harder} in 2011.

The examples
   Throughout this post, I'll be using a simple Asteroids game as an example. I like to use
   Asteroids as an example because it involves simplified versions of many of the systems required in
   larger games - rendering, physics, ai, user control of a character, non-player characters.

The game loop
   To understand why we use entity systems, you really need to understand the old-fashioned game
   loop. A game loop for Asteroids might look something like this

function update( time:Number ):void {
	game.update( time );
	spaceship.updateInputs( time );
	for each( var flyingSaucer:FlyingSaucer in flyingSaucers ) {
		flyingSaucer.updateAI( time );
	}
	spaceship.update( time );
	for each( var flyingSaucer:FlyingSaucer in flyingSaucers ) {
		flyingSaucer.update( time );
	}
	for each( var asteroid:Asteroid in asteroids ) {
		asteroid.update( time );
	}
	for each( var bullet:Bullet in bullets ) {
		bullet.update( time );
	}
	collisionManager.update( time );
	spaceship.render();
	for each( var flyingSaucer:FlyingSaucer in flyingSaucers ) {
		flyingSaucer.render();
	}
	for each( var asteroid:Asteroid in asteroids ) {
		asteroid.render();
	}
	for each( var bullet:Bullet in bullets ) {
		bullet.render();
	}
}

   This game loop is called on a regular interval, usually every 60th of a second or every 30th of a
   second, to update the game. The order of operations in the loop is important as we update various
   game objects, check for collisions between them, and then draw them all. Every frame.

   This is a very simple game loop. It's simple because
    1. The game is simple
    2. The game has only one state

   In the past, I have worked on console games where the game loop, a single function, was over 3,000
   lines of code. It wasn't pretty, and it wasn't clever. That's the way games were built and we had to
   live with it.

   Entity system architecture derives from an attempt to resolve the problems with the game loop. It
   addresses the game loop as the core of the game, and pre-supposes that simplifying the game loop is
   more important than anything else in modern game architecture. More important than separation of the
   view from the controller, for example.

Processes
   The first step in this evolution is to think about objects called processes. These are objects that
   can be initialised, updated on a regular basis, and destroyed. The interface for a process looks
   something like this.

interface IProcess {
	function start():Boolean;
	function update( time:Number ):void;
	function end():void;
}

   We can simplify our game loop if we break it into a number of processes to handle, for example,
   rendering, movement, collision resolution. To manage those processes we create a process manager.

class ProcessManager {
	private var processes:PrioritisedList;

	public function addProcess( process:IProcess, priority:int ):Boolean {
		if( process.start() ) {
			processes.add( process, priority );
			return true;
		}
		return false;
	}

	public function update( time:Number ):void {
		for each( var process:IProcess in processes ) {
			process.update( time );
		}
	}

	public function removeProcess( process:IProcess ):void {
		process.end();
		processes.remove( process );
	}
}

   This is a somewhat simplified version of a process manager. In particular, we should ensure we update
   the processes in the correct order (identified by the priority parameter in the add method) and we
   should handle the situation where a process is removed during the update loop. But you get the idea.
   If our game loop is broken into multiple processes, then the update method of our process manager is
   our new game loop and the processes become the core of the game.

The render process
   Lets look at the render process as an example. We could just pull the render code out of the original
   game loop and place it in a process, giving us something like this

class RenderProcess implements IProcess {
	public function start() : Boolean {
		// initialise render system
		return true;
	}

	public function update( time:Number ):void {
		spaceship.render();
		for each( var flyingSaucer:FlyingSaucer in flyingSaucers ) {
			flyingSaucer.render();
		}
		for each( var asteroid:Asteroid in asteroids ) {
			asteroid.render();
		}
		for each( var bullet:Bullet in bullets ) {
			bullet.render();
		}
	}

	public function end() : void {
		// clean-up render system
	}
}

Using an interface
   But this isn't very efficient. We still have to manually render all the different types of game
   object. If we have a common interface for all renderable objects, we can simplify matters a lot.

interface IRenderable {
	function render();
}
class RenderProcess implements IProcess {
	private var targets:Vector.<IRenderable>;

	public function start() : Boolean {
		// initialise render system
		return true;
	}

	public function update( time:Number ):void {
		for each( var target:IRenderable in targets ) {
			target.render();
		}
	}

	public function end() : void {
		// clean-up render system
	}
}

   Then our spaceship class might contain some code like this

class Spaceship implements IRenderable {
	public var view:DisplayObject;
	public var position:Point;
	public var rotation:Number;

	public function render():void {
		view.x = position.x;
		view.y = position.y;
		view.rotation = rotation;
	}
}

   This code is based on the flash display list. If we were blitting, or using stage3d, it would be
   different, but the principles would be the same. We need the image to be rendered, and the position
   and rotation for rendering it. And the render function does the rendering.

Using a base class and inheritance
   In fact, there's nothing in this code that makes it unique to a spaceship. All the code could be
   shared by all renderable objects. The only thing that makes them different is which display object is
   assigned to the view property, and what the position and rotation are. So lets wrap this in a base
   class and use inheritance.

class Renderable implements IRenderable {
	public var view:DisplayObject;
	public var position:Point;
	public var rotation:Number;

	public function render():void {
		view.x = position.x;
		view.y = position.y;
		view.rotation = rotation;
	}
}

class Spaceship extends Renderable {
}

   Of course, all renderable items will extend the renderable class, so we get a simple class heirarchy
   like this

The move process
   To understand the next step, we first need to look at another process and the class it works on. So
   lets try the move process, which updates the position of the objects.

interface IMoveable {
	function move( time:Number );
}
class MoveProcess implements IProcess {
	private var targets:Vector.<IMoveable>;

	public function start():Boolean {
		return true;
	}

	public function update( time:Number ):void {
		for each( var target:IMoveable in targets ) {
			target.move( time );
		}
	}

	public function end():void {
	}
}

class Moveable implements IMoveable {
	public var position:Point;
	public var rotation:Number;
	public var velocity:Point;
	public var angularVelocity:Number;

	public function move( time:Number ):void {
		position.x += velocity.x * time;
		position.y += velocity.y * time;
		rotation += angularVelocity * time;
	}
}

class Spaceship extends Moveable {
}

Multiple inheritance
   That's almost good, but unfortunately we want our spaceship to be both moveable and renderable, and
   many modern programming languages don't allow multiple inheritance.

   Even in those languages that do permit multiple inheritance, we have the problem that the position
   and rotation in the Moveable class should be the same as the position and rotation in the Renderable
   class.

   One common solution is to use an inheritance chain, so that Moveable extends Renderable.

class Moveable extends Renderable implements IMoveable {
	public var velocity:Point;
	public var angularVelocity:Number;

	public function move( time:Number ):void {
		position.x += velocity.x * time;
		position.y += velocity.y * time;
		rotation += angularVelocity * time;
	}
}

class Spaceship extends Moveable {
}

   Now the spaceship is both moveable and renderable. We can apply the same principles to the other game
   objects to get this class hierarchy.

   We can even have static objects that just extend Renderable.

Moveable but not Renderable
   But what if we want a Moveable object that isn't Renderable? An invisible game object, for example?
   Now our class hierarchy breaks down and we need an alternative implementation of the Moveable
   interface that doesn't extend Renderable.

class InvisibleMoveable implements IMoveable {
	public var position:Point;
	public var rotation:Number;
	public var velocity:Point;
	public var angularVelocity:Number;

	public function move( time:Number ):void {
		position.x += velocity.x * time;
		position.y += velocity.y * time;
		rotation += angularVelocity * time;
	}
}

   In a simple game, this is clumsy but manageable, but in a complex game using inheritance to apply the
   processes to objects rapidly becomes unmanageable as you'll soon discover items in your game that
   don't fit into a simple linear inheritance tree, as with the force-field above.

Favour composition over inheritance
   It's long been a sound principle of object-oriented programming to favour composition over
   inheritance. Applying that principle here can rescue us from this potential inheritance mess.

   We'll still need Renderable and Moveable classes, but rather than extending these classes to create
   the spaceship class, we will create a spaceship class that contains an instance of each of these
   classes.

class Renderable implements IRenderable {
	public var view:DisplayObject;
	public var position:Point;
	public var rotation:Number;

	public function render():void {
		view.x = position.x;
		view.y = position.y;
		view.rotation = rotation;
	}
}

class Moveable implements IMoveable {
	public var position:Point;
	public var rotation:Number;
	public var velocity:Point;
	public var angularVelocity:Number;

	public function move( time:Number ):void {
		position.x += velocity.x * time;
		position.y += velocity.y * time;
		rotation += angularVelocity * time;
	}
}

class Spaceship {
	public var renderData:IRenderable;
	public var moveData:IMoveable;
}

   This way, we can combine the various behaviours in any way we like without running into inheritance
   problems.

   The objects made by this composition, the Static Object, Spaceship, Flying Saucer, Asteroid, Bullet
   and Force Field, are collectively called entities.

   Our processes remain unchanged.

interface IRenderable {
	function render();
}

class RenderProcess implements IProcess {
	private var targets:Vector.<IRenderable>;

	public function update(time:Number):void {
		for each(var target:IRenderable in targets) {
			target.render();
		}
	}
}

interface IMoveable {
	function move();
}
class MoveProcess implements IProcess {
	private var targets:Vector.<IMoveable>;

	public function update(time:Number):void {
		for each(var target:IMoveable in targets) {
			target.move( time );
		}
	}
}

   But we don't add the spaceship entity to each process, we add it's components. So when we create the
   spaceship we do something like this

public function createSpaceship():Spaceship {
	var spaceship:Spaceship = new Spaceship();
	...
	renderProcess.addItem( spaceship.renderData );
	moveProcess.addItem( spaceship.moveData );
	...
	return spaceship;
}

   This approach looks good. It gives us the freedom to mix and match process support between different
   game objects without getting into spagetti inheritance chains or repeating ourselves. But there's one
   problem.

What about the shared data?
   The position and rotation properties in the Renderable class instance need to have the same values as
   the position and rotation properties in the Moveable class instance, since the Move process will
   change the values in the Moveable instance and the Render process will use the values in the
   Renderable instance.

class Renderable implements IRenderable {
	public var view:DisplayObject;
	public var position:Point;
	public var rotation:Number;

	public function render():void {
		view.x = position.x;
		view.y = position.y;
		view.rotation = rotation;
	}
}

class Moveable implements IMoveable {
	public var position:Point;
	public var rotation:Number;
	public var velocity:Point;
	public var angularVelocity:Number;

	public function move( time:Number ):void {
		position.x += velocity.x * time;
		position.y += velocity.y * time;
		rotation += angularVelocity * time;
	}
}

class Spaceship {
	public var renderData:IRenderable;
	public var moveData:IMoveable;
}

   To solve this, we need to ensure that both class instances reference the same instances of these
   properties. In Actionscript that means these properties must be objects, because objects can be
   passed by reference while primitives are passed by value.

   So we introduce another set of classes, which we'll call components. These components are just value
   objects that wrap properties into objects for sharing between processes.

class PositionComponent {
	public var x:Number;
	public var y:Number;
	public var rotation:Number;
}

class VelocityComponent {
	public var velocityX:Number;
	public var velocityY:Number;
	public var angularVelocity:Number;
}

class DisplayComponent {
	public var view:DisplayObject;
}

class Renderable implements IRenderable {
	public var display:DisplayComponent;
	public var position:PositionComponent;

	public function render():void {
		display.view.x = position.x;
		display.view.y = position.y;
		display.view.rotation = position.rotation;
	}
}

class Moveable implements IMoveable {
	public var position:PositionComponent;
	public var velocity:VelocityComponent;

	public function move( time:Number ):void {
		position.x += velocity.velocityX * time;
		position.y += velocity.velocityY * time;
		position.rotation += velocity.angularVelocity * time;
	}
}

   When we create the spaceship we ensure the Moveable and Renderable instances share the same instance
   of the PositionComponent.

class Spaceship {
	public function Spaceship() {
		moveData = new Moveable();
		renderData = new Renderable();
		moveData.position = new PositionComponent();
		moveData.velocity = new VelocityComponent();
		renderData.position = moveData.position;
		renderData.display = new DisplayComponent();
	}
}

   The processes remain unaffected by this change.

A good place to pause
   At this point we have a neat separation of tasks. The game loop cycles through the processes, calling
   the update method on each one. Each process contains a collection of objects that implement the
   interface it operates on, and will call the appropriate method of those objects. Those objects each
   do a single important task on their data. Through the system of components, those objects are able to
   share data and thus the combination of multiple processes can produce complex updates in the game
   entities, while keeping each process relatively simple.

   This architecture is similar to a number of entity systems in game development. The architecture
   follows good object-oriented principles and it works. But there's more to come, starting with a
   moment of madness.

Abandoning good object-oriented practice
   The current architecture uses good object-oriented practices like encapsulation and single
   responsibility - the IRenderable and IMoveable implementations encapsulate the data and logic for
   single responsibilities in the updating of game entities every frame - and composition - the
   Spaceship entity is created by combining implementations of the IRenderable and IMoveable interfaces.
   Through the system of components we ensured that, where appropriate, data is shared between the
   different data classes of the entities.

   The next step in this evolution of entity systems is somewhat counter-intuitive, breaking one of the
   core tenets of object-oriented programming. We break the encapsulation of the data and logic in the
   Renderable and Moveable implementations. Specifically, we remove the logic from these classes and
   place it in the processes instead.

   So this

interface IRenderable {
	function render();
}

class Renderable implements IRenderable {
	public var display:DisplayComponent;
	public var position:PositionComponent;

	public function render():void {
		display.view.x = position.x;
		display.view.y = position.y;
		display.view.rotation = position.rotation;
	}
}

class RenderProcess implements IProcess {
	private var targets:Vector.<IRenderable>;

	public function update( time:Number ):void {
		for each( var target:IRenderable in targets ) {
			target.render();
		}
	}
}

   Becomes this

class RenderData {
	public var display:DisplayComponent;
	public var position:PositionComponent;
}

class RenderProcess implements IProcess {
	private var targets:Vector.<RenderData>;

	public function update( time:Number ):void {
		for each( var target:RenderData in targets ) {
			target.display.view.x = target.position.x;
			target.display.view.y = target.position.y;
			target.display.view.rotation = target.position.rotation;
		}
	}
}

   And this

interface IMoveable {
	function move( time:Number );
}

class Moveable implements IMoveable {
	public var position:PositionComponent;
	public var velocity:VelocityComponent;

	public function move( time:Number ):void {
		position.x += velocity.velocityX * time;
		position.y += velocity.velocityY * time;
		position.rotation += velocity.angularVelocity * time;
	}
}

class MoveProcess implements IProcess {
	private var targets:Vector.<IMoveable>;

	public function move( time:Number ):void {
		for each( var target:Moveable in targets ) {
			target.move( time );
		}
	}
}

   Becomes this

class MoveData {
	public var position:PositionComponent;
	public var velocity:VelocityComponent;
}

class MoveProcess implements IProcess {
	private var targets:Vector.<MoveData>;

	public function move( time:Number ):void {
		for each( var target:MoveData in targets ) {
			target.position.x += target.velocity.velocityX * time;
			target.position.y += target.velocity.velocityY * time;
			target.position.rotation += target.velocity.angularVelocity * time;
		}
	}
}

   It's not immediately clear why we'd do this, but bear with me. On the surface, we've removed the need
   for the interface, and we've given the process something more important to do - rather than simply
   delegate its work to the IRenderable or IMoveable implementations, it does the work itself.

   The first apparent consequence of this is that all entities must use the same rendering method, since
   the render code is now in the RenderProcess. But that's not actually the case. We could, for example,
   have two processes, RenderMovieClip and RenderBitmap for example, and they could operate on different
   sets of entities. So we haven't lost any flexibility.

   What we gain is the ability to refactor our entities significantly to produce an architecture with
   clearer separation and simpler configuration. The refactoring starts with a question.

Do we need the data classes?
   Currently, our entity

class Spaceship {
	public var moveData:MoveData;
	public var renderData:RenderData;
}

   Contains two data classes

class MoveData {
	public var position:PositionComponent;
	public var velocity:VelocityComponent;
}

class RenderData {
	public var display:DisplayComponent;
	public var position:PositionComponent;
}

   These data classes in turn contain three components

class PositionComponent {
	public var x:Number;
	public var y:Number;
	public var rotation:Number;
}

class VelocityComponent {
	public var velocityX:Number;
	public var velocityY:Number;
	public var angularVelocity:Number;
}

class DisplayComponent {
	public var view:DisplayObject;
}

   And the data classes are used by the two processes

class MoveProcess implements IProcess {
	private var targets:Vector.<MoveData>;

	public function move( time:Number ):void {
		for each( var target:MoveData in targets ) {
			target.position.x += target.velocity.velocityX * time;
			target.position.y += target.velocity.velocityY * time;
			target.position.rotation += target.velocity.angularVelocity * time;
		}
	}
}

class RenderProcess implements IProcess {
	private var targets:Vector.<RenderData>;

	public function update( time:Number ):void {
		for each( var target:RenderData in targets ) {
			target.display.view.x = target.position.x;
			target.display.view.y = target.position.y;
			target.display.view.rotation = target.position.rotation;
		}
	}
}

   But the entity shouldn't care about the data classes. The components collectively contain the state
   of the entity. The data classes exist for the convenience of the processes. So we refactor the code
   so the spaceship entity contains the components rather than the data classes.

class Spaceship {
	public var position:PositionComponent;
	public var velocity:VelocityComponent;
	public var display:DisplayComponent;
}

class PositionComponent {
	public var x:Number;
	public var y:Number;
	public var rotation:Number;
}

class VelocityComponent {
	public var velocityX:Number;
	public var velocityY:Number;
	public var angularVelocity:Number;
}

class DisplayComponent {
	public var view:DisplayObject;
}

   By removing the data classes, and using the constituent components instead to define the spaceship,
   we have removed any need for the spaceship entity to know what processes may act on it. The spaceship
   now contains the components that define its state. Any requirement to combine these components into
   other data classes for the processes is some other class's responsibility.

Systems and Nodes
   Some core code within the entity system framework (which we'll get to in a minute) will dynamically
   create these data objects as they are required by the processes. In this reduced context, the data
   classes will be mere nodes in the collections (arrays, linked-lists, or otherwise, depending on the
   implementation) used by the processes. So to clarify this we'll rename them as nodes.

class MoveNode {
	public var position:PositionComponent;
	public var velocity:VelocityComponent;
}

class RenderNode {
	public var display:DisplayComponent;
	public var position:PositionComponent;
}

   The processes are unchanged, but in keeping with the more common naming I'll also change their name
   and call them systems.

class MoveSystem implements ISystem {
	private var targets:Vector.<MoveNode>;

	public function update( time:Number ):void {
		for each( var target:MoveNode in targets ) {
			target.position.x += target.velocity.velocityX * time;
			target.position.y += target.velocity.velocityY * time;
			target.position.rotation += target.velocity.angularVelocity * time;
		}
	}
}

class RenderSystem implements ISystem {
	private var targets:Vector.<RenderNode>;

	public function update( time:Number ):void {
		for each( var target:RenderNode in targets ) {
			target.display.view.x = target.position.x;
			target.display.view.y = target.position.y;
			target.display.view.rotation = target.position.rotation;
		}
	}
}

interface ISystem {
	function update( time:Number ):void;
}

And what is an entity?
   One last change - there's nothing special about the Spaceship class. It's just a container for
   components. So we'll just call it Entity and give it a collection of components. We'll access those
   components based on their class type.

class Entity {
	private var components : Dictionary;

	public function add( component:Object ):void {
		var componentClass : Class = component.constructor;
		components[ componentClass ] = component'
	}

	public function remove( componentClass:Class ):void {
		delete components[ componentClass ];
	}

	public function get( componentClass:Class ):Object {
		return components[ componentClass ];
	}
}

   So we'll create our spaceship like this

public function createSpaceship():void {
	var spaceship:Entity = new Entity();
	var position:PositionComponent = new PositionComponent();
	position.x = Stage.stageWidth / 2;
	position.y = Stage.stageHeight / 2;
	position.rotation = 0;
	spaceship.add( position );
	var display:DisplayComponent = new DisplayComponent();
	display.view = new SpaceshipImage();
	spaceship.add( display );
	engine.add( spaceship );
}

The core Engine class
   We mustn't forget the system manager, formerly called the process manager.

class SystemManager {
	private var systems:PrioritisedList;

	public function addSystem( system:ISystem, priority:int ):void {
		systems.add( system, priority );
		system.start();
	}

	public function update( time:Number ):void {
		for each( var system:ISystem in systemes ) {
			system.update( time );
		}
	}

	public function removeSystem( system:ISystem ):void {
		system.end();
		systems.remove( system );
	}
}

   This will be enhanced and will sit at the heart of our entity component system framework. We'll add
   to it the functionality mentioned above to dynamically create nodes for the systems.

   The entities only care about components, and the systems only care about nodes. So to complete the
   entity component system framework, we need code to watch the entities and, as they change, add and
   remove their components to the node collections used by the systems. Because this is the one bit of
   code that knows about both entities and systems, we might consider it central to the game. In Ash, I
   call this the Engine class, and it is an enhanced version of the system manager.

   Every entity and every system is added to and removed from the Engine class when you start using it
   and stop using it. The Engine class keeps track of the components on the entities and creates and
   destroys nodes as necessary, adding those nodes to the node collections. The Engine class also
   provides a way for the systems to get the collections they require.

public class Engine {
	private var entities:EntityList;
	private var systems:SystemList;
	private var nodeLists:Dictionary;

	public function addEntity( entity:Entity ):void {
		entities.add( entity );
		// create nodes from this entity's components and add them to node lists
		// also watch for later addition and removal of components from the entity so
		// you can adjust its derived nodes accordingly
	}

	public function removeEntity( entity:Entity ):void {
		// destroy nodes containing this entity's components
		// and remove them from the node lists
		entities.remove( entity );
	}

	public function addSystem( system:System, priority:int ):void {
		systems.add( system, priority );
		system.start();
	}

	public function removeSystem( system:System ):void {
		system.end();
		systems.remove( system );
	}

	public function getNodeList( nodeClass:Class ):NodeList {
		var nodes:NodeList = new NodeList();
		nodeLists[ nodeClass ] = nodes;
		// create the nodes from the current set of entities
		// and populate the node list
		return nodes;
	}

	public function update( time:Number ):void {
		for each( var system:ISystem in systemes ) {
			system.update( time );
		}
	}
}

   To see one implementation of this architecture, checkout the Ash entity system framework, and see
   the example Asteroids implementation there too.

A step further
   In Actionscript, the Node and Entity classes are necessary for efficiently managing the Components
   and passing them to the Systems. But note that these classes are just glue, the game is defined in
   the Systems and the Components. The Entity class provides a means to find and manage the components
   for each entity and the Node classes provide a means to group components into collections for use in
   the Systems. In other languages and runtime environments it may be more efficient to manage this glue
   differently.

   For example, in a large server-based game we might store the components in a database - they are just
   data after all - with each record (i.e. each component) having a field for the unique id of the
   entity it belongs to along with fields for the other component data. Then we pull the components for
   an entity directly from the database when needed, using the entity id to find it, and we create
   collections of data for the systems to operate on by doing joined queries across the appropriate
   databases. For example, for the move system we would pull records from the postion components table
   and the movement components table where entity ids match and a record exists in both tables (i.e. the
   entity has both a position and a movement component). In this instance the Entity and Node classes
   are not required and the only presence for the entity is the unique id that is used in the data
   tables.

   Similarly, if you have control over the memory allocation for your game it is often more efficient to
   take a similar approach for local game code too, creating components in native arrays of data and
   looking-up the components for an entity based on an id. Some aspects of the game code become more
   complex and slower (e.g. finding the components for a specific entity) but others become much faster
   (e.g. iterating through the component data collections inside a system) because the data is
   efficiently laid out in memory to minimise cache misses and maximise speed.

   The important elements of this architecture are the components and the systems. Everything else is
   configuration and glue. And note that components are data and systems are functions, so we don't even
   need object oriented code to do this.

Conclusion
   So, to summarise, entity component systems originate from a desire to simplify the game loop. From
   that comes an architecture of components, which represent the state of the game, and systems, which
   operate on the state of the game. Systems are updated every frame - this is the game loop. Components
   are combined into entities, and systems operate on the entities that have all the components they are
   interested in. The engine monitors the systems and the components and ensures each system has access
   to a collection of all the components it needs.

   An entity component system framework like Ash provides the basic scaffolding and core management for
   this architecture, without providing any actual component or system classes. You create your game by
   creating the appropriate components and systems.

   An entity component system game engine will provide many standard systems and components on top of
   the basic framework.

   Three entity component system frameworks for Actionscript are my own Ash, Ember2 by Tom
   Davies and Xember by Alec McEachran. Artemis is an entity system framework for Java, that
   has also been ported to C#.

   My next post covers some of the reasons why I like using an entity system framework for my game
   development projects.


---

