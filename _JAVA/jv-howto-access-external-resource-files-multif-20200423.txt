filename: jv_howto_access_external-resource-files-multif_20200423.txt
https://www.novixys.com/blog/read-file-resources-folder-java/

How to Read a File from Resources Folder in Java

1. Introduction
   When you build a java project and pack it into a jar (or a war), the files under the resources folder
   are included into the jar. These files may include configuration files, scripts and other resources
   needed during run time. When the software is executed, it may need to load the contents of these
   files for some kind of processing - may be properties, sql statements, etc. In this article, we show
   you how to load these resources when the program is running.

2. Packaging Resources

   Check out the directory hierarchy below:
   
   src/
   src/main/
   src/main/java/
   src/main/java/sample/
   src/main/java/sample/sample2.java
   src/main/java/sample/sample1.java
   src/main/resources/
   src/main/resources/unicode.txt
   src/main/resources/poems/
   src/main/resources/poems/Frost.txt
   src/main/resources/sample/
   src/main/resources/sample/app.properties
   
   Maven packs all the files and folders under main/resources into the jar file at the the root. You can
   access these files and folders from your java code as shown below.

3. Loading the Resources
   The following code snippet shows how to load resources packed thus into the jar or war file:
String respath = "/poems/Frost.txt";
InputStream in = sample2.class.getResourceAsStream(respath);
if ( in == null )
    throw new Exception("resource not found: " + respath);

   Using the method Class.getResourceAsStream(String), you can get an InputStream to read the
   resource. The method returns null if the resource cannot be found or loaded.

   To read binary resources, you can use directly use the InputStream instance. For reading a text
   resource, you can convert it to a Reader instance, possibly specifying the character encoding:
InputStreamReader inr = new InputStreamReader(in, "UTF-8");
int len;
char cbuf[] = new char[2048];
while ((len = inr.read(cbuf, 0, cbuf.length)) != -1) {
    // do something with cbuf
}

4. Using Absolute Path of Resource
   To load a resource whose full path from the root of the jar file is known, use the full path starting
   with a "/".
InputStream in = sample1.class.getResourceAsStream("/poems/Frost.txt");

5. Loading from Relative Paths
   When you use a relative path (not starting with a "/") to load a resource, it loaded relative to the
   class from which getResourceAsStream() is invoked. For example, to load "app.properties" relative to
   the invoking class, do not start the path with a "/".
InputStream in = sample1.class.getResourceAsStream("app.properties");

Conclusion
   In this article, we demonstrated how to use the Class.getResourceAsStream() method to load resources
   from the jar file or war file. An absolute resource path is resolved from the root of the jar file
   while a relative paths is resolved with respect to the loading class.


---
https://docs.oracle.com/javase/8/docs/technotes/guides/lang/resources.html

Location-Independent Access to Resources

Overview
   A resource is data (images, audio, text, and so on) that a program needs to access in a way that is
   independent of the location of the program code. Java programs can use two mechanisms to access
   resources: Applets use Applet.getCodeBase() to get the base URL for the applet code and then extend
   the base URL with a relative path to load the desired resource, for example with
   Applet.getAudioClip(url). Applications use "well known locations" such as
   System.getProperty("user.home") or System.getProperty("java.home"), then add "/lib/resource", and
   open that file.

   Methods in the classes Class and ClassLoader provide a location-independent way to locate resources.
   For example, they enable locating resources for:
     * An applet loaded from the Internet using multiple HTTP connections.
     * An applet loaded using JAR files.
     * A Java Bean loaded or installed in the CLASSPATH.
     * A "library" installed in the CLASSPATH.

   These methods do not provide specific support for locating localized resources. Localized resources
   are supported by the internationalization facilities.

Resources, names, and contexts
   A resource is identified by a string consisting of a sequence of substrings, delimited by slashes
   (/), followed by a resource name. Each substring must be a valid Java identifier. The resource name
   is of the form shortName or shortName.extension. Both shortName and extension must be Java
   identifiers.

   The name of a resource is independent of the Java implementation; in particular, the path separator
   is always a slash (/). However, the Java implementation controls the details of how the contents of
   the resource are mapped into a file, database, or other object containing the actual resource.

   The interpretation of a resource name is relative to a class loader instance. Methods implemented by
   the ClassLoader class do this interpretation.

System Resources
   A system resource is a resource that is either built-in to the system, or kept by the host
   implementation in, for example, a local file system. Programs access system resources through the
   ClassLoader methods getSystemResource and getSystemResourceAsStream.

   For example, in a particular implementation, locating a system resource may involve searching the
   entries in the CLASSPATH. The ClassLoader methods search each directory, ZIP file, or JAR file entry
   in the CLASSPATH for the resource file, and, if found, returns either an InputStream, or the resource
   name. If not found, the methods return null. A resource may be found in a different entry in the
   CLASSPATH than the location where the class file was loaded.

Non-System Resources
   The implementation of getResource on a class loader depends on the details of the ClassLoader class.
   For example, AppletClassLoader:
     * First tries to locate the resource as a system resource; then, if not found,
     * Searches through the resources in archives (JAR files) already loaded in this CODEBASE; then, if
       not found,
     * Uses CODEBASE and attempts to locate the resource (which may involve contacting a remote site).

   All class loaders will search for a resource first as a system resource, in a manner analogous to
   searcing for class files. This search rule permits overwriting locally any resource. Clients should
   choose a resource name that will be unique (using the company or package name as a prefix, for
   instance).

Resource Names
   A common convention for the name of a resource used by a class is to use the fully qualified name of
   the package of the class, but convert all periods (.) to slashes (/), and add a resource name of the
   form name.extension. To support this, and to simplify handling the details of system classes (for
   which getClassLoader returns null), the class Class provides two convenience methods that call the
   appropriate methods in ClassLoader.

   The resource name given to a Class method may have an initial starting "/" that identifies it as an
   "absolute" name. Resource names that do not start with a "/" are "relative".

   Absolute names are stripped of their starting "/" and are passed, without any further modification,
   to the appropriate ClassLoader method to locate the resource. Relative names are modified according
   to the convention described previously and then are passed to a ClassLoader method.

Using Methods of java.lang.Class
   The Class class implements several methods for loading resources.

   The method getResource() returns a URL for the resource. The URL (and its representation) is specific
   to the implementation and the JVM (that is, the URL obtained in one runtime instance may not work in
   another). Its protocol is usually specific to the ClassLoader loading the resource. If the resource
   does not exist or is not visible due to security considerations, the methods return null.

   If the client code wants to read the contents of the resource as an InputStream, it can apply the
   openStream() method on the URL. This is common enough to justify adding getResourceAsStream() to
   Class and ClassLoader. getResourceAsStream() the same as calling getResource().openStream(), except
   that getResourceAsStream() catches IO exceptions returns a null InputStream.

   Client code can also request the contents of the resource as an object by applying the
   java.net.URL.getContent() method on the URL. This is useful when the resource contains the data for
   an image, for instance. In the case of an image, the result is an awt.image.ImageProducer object, not
   an Image object.

   The getResource and getResourceAsStream methods find a resource with a given name. They return null
   if they do not find a resource with the specified name. The rules for searching for resources
   associated with a given class are implemented by the class's ClassLoader. The Class methods delegate
   to ClassLoader methods, after applying a naming convention: if the resource name starts with "/", it
   is used as is. Otherwise, the name of the package is prepended, after converting all periods (.) to
   slashes (/).
public InputStream getResourceAsStream(String name) {
  name = resolveName(name);
  ClassLoader cl = getClassLoader();
  if (cl==null) {
    return ClassLoader.getSystemResourceAsStream(name); // A system class.
  }
  return cl.getResourceAsStream(name);
}

public java.net.URL getResource(String name) {
  name = resolveName(name);
  ClassLoader cl = getClassLoader();
  if (cl==null) {
    return ClassLoader.getSystemResource(name);  // A system class.
  }
  return cl.getResource(name);
}

   The resolveName method adds a package name prefix if the name is not absolute, and removes any
   leading "/" if the name is absolute. It is possible, though uncommon, to have classes in diffent
   packages sharing the same resource.
private String resolveName(String name) {
  if (name == null) {
    return name;
  }
  if (!name.startsWith("/")) {
    Class c = this;
    while (c.isArray()) {
      c = c.getComponentType();
    }
    String baseName = c.getName();
    int index = baseName.lastIndexOf('.');
    if (index != -1) {
      name = baseName.substring(0, index).replace('.', '/') + "/" + name;
    }
  } else {
    name = name.substring(1);
  }
  return name;
}

Using Methods of java.lang.ClassLoader
   The ClassLoader class has two sets of methods to access resources. One set returns an InputStream for
   the resource. The other set returns a URL. The methods that return an InputStream are easier to use
   and will satisfy many needs, while the methods that return URLs provide access to more complex
   information, such as an Image and an AudioClip.

   The ClassLoadermanges resources similarly to the way it manages classes. A ClassLoader controls how
   to map the name of a resource to its content. ClassLoader also provides methods for accessing system
   resources, analogous to the system classes. The Class class provides some convenience methods that
   delegate functionality to the ClassLoader methods.

   Many Java programs will access these methods indirectly through the I18N (localization) APIs. Others
   will access it through methods in Class. A few will directly invoke the ClassLoader methods.

   The methods in ClassLoader use the given String as the name of the resource without applying any
   absolute/relative transformation (see the methods in Class). The name should not have a leading "/".

   System resources are those that are handled by the host implemenation directly. For example, they may
   be located in the CLASSPATH.

   The name of a resource is a "/"-separated sequence of identifiers. The Class class provides
   convenience methods for accessing resources; the methods implement a convention where the package
   name is prefixed to the short name of the resource.

   Resources can be accessed as an InputStream, or a URL.

   The getSystemResourceAsStream method returns an InputStream for the specified system resource or null
   if it does not find the resource. The resource name may be any system resource.

   The getSystemResource method finds a system resource with the specified name. It returns a URL to the
   resource or null if it does not find the resource. Calling java.net.URL.getContent() with the URL
   will return an object such as ImageProducer, AudioClip, or InputStream.

   The getResourceAsStream method returns an InputStream for the specified resource or null if it does
   not find the resource.

   The getResource method finds a resource with the specified name. It returns a URL to the resource or
   null if it does not find the resource. Calling java.net.URL.getContent() with the URL will return an
   object such as ImageProducer, AudioClip, or InputStream.

Security
   Since getResource() provides access to information, it must have well-defined and well-founded
   security rules. If security considerations do not allow a resource to be visible in some security
   context, the getResource() method will fail (return null) as if the resource were not present at all,
   this addresses existence attacks.

   Class loaders may not provide access to the contents of a .class file for both security and
   performance reasons. Whether it is possible to obtain a URL for a .class file depends on the
   specifics, as shown below.

   There are no specified security issues or restrictions regarding resources that are found by a
   non-system class loader. AppletClassLoader provides access to information that is loaded from a
   source location, either individually, or in a group through a JAR file; thus AppletClassLoader should
   apply the same checkConnect() rules when dealing with URLs through getResource().

   The system ClassLoader provides access to information in the CLASSPATH. A CLASSPATH may contain
   directories and JAR files. Since a JAR file is created intentionally, it has a different significance
   than a directory where things may end up in a more casual manner. In particular, we are more strict
   on getting information out of a directory than out from a JAR file.

   If a resource is in a directory:
     * getResource() invocations will use File.exists() to determine whether to make the corresponding
       file visible to the user. Recall that File.exists() uses the checkRead() method in the security
       manager.
     * the same applies to getResourceAsStream().

   If the resource is in a JAR file:
     * getResource() invocations will succeed for all files, regardless of whether the invocation is
       done from within a system or a non-system class.
     * getResourceAsStream() invocations will succeed for non .class resources, and so will for
       java.net.URL.getContent() on corresponding URLs.

Examples
   This section provides two examples of client code. The first example uses "absolute resource" names
   and traditional mechanisms to get a Class object.
package pkg;

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;

class Test {

  private static final String absName = "/pkg/mumble.baf";

  public static void test1() {
    Class c=null;
    try {
      c = Class.forName("pkg.Test");
    } catch (Exception ex) {
      // This should not happen.
    }
    InputStream s = c.getResourceAsStream(absName);
    // do something with it.
  }

  public void test2() {
    InputStream s = this.getClass().getResourceAsStream(absName);
  // do something with it.
  }
}

   This example uses "relative resource" names and the mechanism available from the compiler through the
   -experimental flag, to get a Class object.
package pkg;

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;

class Test {
  private static final String relName = "mumble.baf";
  public static void test1() {
  InputStream s = Test.class.getResourceAsStream(relName);
  // do something with it.
}

  public void test2() {
    InputStream s = Test.class.getResourceAsStream(relName);
    // do something with it.
  }

API References
     * java.lang.Class
     * java.lang.ClassLoader
     * java.net.URLClassLoader
     * java.util.ResourceBundle
     * java.lang.SecurityManager
     * java.security
 

---
http://www.thinkplexx.com/learn/howto/java/system/java-resource-loading-explained-absolute-and-relative-names-difference-between-classloader-and-class-resource-loading

Java resource loading explained. Absolute and relative names. Difference between ClassLoader and Class
resource loading

   Understanding how Java finds resources is important. Resource loading in Java is "location
   independent", Java also differentiates between absolute and relative resource names. And these names
   are processed by Java ResourceLoader differently. That last little issue may cause problems,
   especially because the "wrong" resource names really work under some circumstances.

   1
   How java locates resources
   Java loads resources from the "environment", in many cases it uses all jars in Classpath to retrieve
   the resource. Resource loading in java is called location independent because it is not relevant
   where your code is running, it just needs correct environment to find the resources.

   Given all jars and paths in Classpath, java will search relatively to each tone to find the resource
   you specified. You specify resources using resource names.

   2
   Absolute and relative resource names
   Resources are referred using resource name:
   getResourceAsStream("/path/resource.xml");

   "/path/resource.xml" is the resource name here.

   The resource name can be:
     * absolute like "/path/resource.xml";
     * relative like "path/resource.xml";


   Relative means, relative to the location, where the method was called. The path will be appended if
   needed.
   Absolute will be used as is, only first / will be removed before the search.

   Example:
package my.location;

class ResourceFinder {
...
public void findResources(){
   InputStream stream1 =
getClass().getResourceAsStream("/path/resource.xml");
   InputStream stream2 =
getClass().getResourceAsStream("path/resource.xml");
}
...
}


   ➕ In this case, stream1 will get the resource, located in classpath path/resource.xml.

   ➕ stream2 will get the resource, located in classpath my/location/path/resource.xml (Relative to
   package where the search was initiated).

   3
   ClassLoader and Class apply resource names differently
   There are ClassLoader.getResource() and Class.getResource() and they work differently!!!

   java docu:
   The methods in ClassLoader use the given String as the name of the
   resource without applying any absolute/relative transformation (cf. the
   methods in Class). The name should not have a leading "/".

   So, to extend our example:
package my.location;

class ResourceFinder {
...
public void findResources(){
   InputStream stream1 =
getClass().getResourceAsStream("/path/resource.xml");
   InputStream stream2 =
getClass().getResourceAsStream("path/resource.xml");
   InputStream stream3 =
getClass().getClassLoader().getResourceAsStream("path/resource.xml");
   InputStream stream4 =
getClass().getClassLoader().getResourceAsStream("/path/resource.xml");

}
...
}


   ➕ stream3 will become resource in classpath under path/resource.xml.

   ⚠ stream4 resource name /path/resource.xml is wrong!

   4
   Where it is important. Example
   I was assessing Maven3 against Maven2 build. Same big project, just call m3.

   Following code has worked well in my previous environment:
InputStream exportFileInputStream =
getClass().getClassLoader().getResourceAsStream("/com/thinkplexx/lang/de/general.xml");


   But after I changed the environment (maven2 build -> maven3 build) the general.xml was missing. I
   know that resource is there.

   Following worked:
InputStream exportFileInputStream =
getClass().getClassLoader().getResourceAsStream("com/thinkplexx/lang/de/general.xml");


   It is a speculation as of how the first snippet could have worked, but it deed. Going to new clean
   environment triggered the bug.


---
https://javarevisited.blogspot.com/2014/07/how-to-load-resources-from-classpath-in-java-example.html

How to Load Resources from Classpath in Java with Example

   Classpath in Java is not only used to load .class files, but also can be used to load resources e.g.
   properties file, images, icons, thumbnails, or any binary content. Java provides API to read these
   resources as InputStream or URL. Suppose, you have a properties file inside config folder of your
   project, and you want to load that properties file, how do you do that? Similarly, you have icons and
   thumbnails for your web applications on icons directory of your project, how do you load them? Answer
   is by using java.lang.Class' getResource() and getResourceAsStream() method. These method accepts
   path of resource as String and returns URL and InputStream respectively. You can obtain a reference
   of Class by calling either getClass() method or by using class literal. If you have an object,
   then you can call getClass() because its a non-static method, on the other hand, if you don't have
   any object, you can simply use .class with name of any class e.g. Sample.class will give you
   reference of java.lang.Class. These methods are available from JDK 1.1 and you can even use them
   anywhere you have access to core Java library. If you are creating J2ME games or application, you can
   use these method to load icons and tiles for your game, and all other resource for your application
   as well.

How does getResourceAsStream works
   Internally this method delegate the loading request of resource to its class loader. If you call
   getResourceAsStream() method on an object which is loaded by BootStrap ClassLoader then it will
   delegate it to ClassLoader.getSystemResourceAsStream(java.lang.String) method.
   We pass path of resource to this method but rules for searching resources associated with a given
   class are implemented by the defining class loader of the class.

   Since you can pass both absolute and relative path to Class.getResourceAsStream(), but
   ClassLoader.getResourceAsStream() takes an absolute path, that's why an absolute resource name is
   constructed from the given resource name using following algorithm :

     If the name begins with a '/' ('\u002f'), then the absolute name of the resource is the portion of
     the name following the '/'. Otherwise, the absolute name is of the following form:
     modified_package_name/name where the modified_package_name is the package name of this object with
     '/' substituted for '.' ('\u002e').

   This means, the resource name passed to the method should look like /com/abc/config/app.properties if
   the app.properties is stored in the com.abc.config package instead of the current class's.
   If you look at the code of java.lang.Class in Eclipse IDE by using short-cut Ctrl+T and typing
   java.lang.Class, you can see how this method works :
    public InputStream getResourceAsStream(String name) {
        name = resolveName(name);
        ClassLoader cl = getClassLoader0();
        if (cl==null) {
            // A system class.
            return ClassLoader.getSystemResourceAsStream(name);
        }
        return cl.getResourceAsStream(name);
}

   This algorithm is implemented at resolveName() method, as seen below :
       /**
     * Add a package name prefix if the name is not absolute Remove leading "/"
     * if name is absolute
     */
    private String resolveName(String name) {
        if (name == null) {
            return name;
        }
        if (!name.startsWith("/")) {
            Class c = this;
            while (c.isArray()) {
                c = c.getComponentType();
            }
            String baseName = c.getName();
            int index = baseName.lastIndexOf('.');
            if (index != -1) {
                name = baseName.substring(0, index).replace('.', '/')
                    +"/"+name;
            }
        } else {
            name = name.substring(1);
        }
        return name;
    }

   How to load Resources from ClassPath in Java with Example
   Main problem comes while loading resource using getResourceAsStream() method is
   NullPointerException, because this method return null if its not able to find the resource. In
   following example, we have a Eclipse project, and I have created a properties file called
   app.properties inside config directory. Now to load that file, I just need to pass "app.properties",
   if I pass anything like "config/app.properties" or "/config/app.properties" getResourceAsStream()
   will return null, and code will subsequently throw NullPointerException as shown below:
Exception in thread "main" java.lang.NullPointerException
    at java.util.Properties$LineReader.readLine(Unknown Source)
    at java.util.Properties.load0(Unknown Source)
    at java.util.Properties.load(Unknown Source)
    at Test.main(Test.java:29)

   to avoid this error you must check output of getResourceAsStream() before using it, defensive
   programming is there just because of this kind of methods.

Java Program to load Resource from Classpath
   Here is our complete Java program to load images, resources, text file or binary file from
   classpath in Java, resource can be anything, what is important is that it must be accessible.
package test;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Properties;

/**
 * Java Program to demonstrate how to load resources e.g. properties file from
 * classpath. There are two ways to load resources in Java, one by using
 * getResourceAsStream() and getResource() method from java.lang.Class. Main
 * difference between these two methods are that one returns an InputStream
 * while other returns a URL object.
 *
 * @author Javin Paul
 */
public class ResourceLoader{

    public static void main(String args[]) {

        // loading resource using getResourceAsStream() method
        InputStream in = ResourceLoader.class.getResourceAsStream("app.properties");

        Properties config = new Properties();
        try {
            config.load(in);
            System.out.println(config.getProperty("name"));
            System.out.println(config.getProperty("version"));

        } catch (IOException e1) {
            e1.printStackTrace();
        }

        // loading resource using getResource() method
        URL resourceURL = Test.class.getResource("app.properties");
        Properties appConfig = new Properties();
        try {
            appConfig.load(resourceURL.openStream());
            System.out.println(appConfig.getProperty("name"));
            System.out.println(appConfig.getProperty("version"));

        } catch (IOException e) {
            e.printStackTrace();
        }

    }

}

Output:
SampleApp
1.0.0
SampleApp
1.0.0

   If you look closely you will find that we have used both getResource() and getResourceAsStream()
   method to load resource from classpath in Java, in this case just properties file. First example
   looks more cleaner than second example because we don't need to open an explicit stream,
   getResourceAsStream() method returns an InputStream, which can be used anywhere. That's all on
   how to load resources from class-path in Java.


---
https://kodejava.org/how-do-i-load-file-from-resources-directory/

How do I load file from resource directory?
July 8, 2019

   In the following code snippet we will learn how to load files from resource directory or folder.
   Resource files can be in a form of image, audio, text, etc. Text resource file for example can be use
   to store application configurations, such as database configuration.

   To load this resource file you can use a couple methods utilizing the java.lang.Class methods or the
   java.lang.ClassLoader methods. Both Class and ClassLoader provides getResource() and
   getResourceAsStream() methods to load resource file. The first method return a URL object while the
   second method return an InputStream.

   When using the Class method, if the resource name started with "/" that identifies it is an absolute
   name. Absolute name means that it will load from the specified directory name or package name. While
   if it is not started with "/" then it is identified as a relative name. This means that it will look
   in the same package as the class that tries to load the resource.
   
App.class.getResource("database.conf");
   The snippet will attempt to load the resource file from the same package as the App class. If the App
   class package is org.kodejava then the database.conf file must be located at /org/kodejava/. This is
   the relative resource name.
   
App.class.getResource("/org/kodejava/conf/database.conf");
   The snippet will attempt to load the resource file from the given package name. You should place the
   configuration file under /org/kodejava/conf/ to enable the application to load it. This is the
   absolute resource name. Below is a snippet that use the Class method to load resources.
   
private void loadUsingClassMethod() throws IOException {
    System.out.println("LoadResourceFile.loadUsingClassMethod");
    Properties properties = new Properties();

    // Load resource relatively to the LoadResourceFile package.
    // This actually load resource from
    // "/org/kodejava/example/lang/database.conf".
    URL resource = getClass().getResource("database.conf");
    properties.load(new FileReader(new File(resource.getFile())));
    System.out.println("JDBC Driver: " + properties.get("jdbc.driver"));

    // Load resource using absolute name. This will read resource
    // from the root of the package. This will load "/database.conf".
    InputStream is = getClass().getResourceAsStream("/database.conf");
    properties.load(is);
    System.out.println("JDBC Driver: " + properties.get("jdbc.driver"));
}

   When we use the ClassLoader method the resource name should not begins with a "/". This method will
   not apply any absolute / relative transformation to the resource name like the Class method. Here a
   snippet of a method that use the ClassLoader method.
   
private void loadUsingClassLoaderMethod() throws IOException {
    System.out.println("LoadResourceFile.loadUsingClassLoaderMethod");
    Properties properties = new Properties();

    // When using the ClassLoader method the resource name should
    // not started with "/". This method will not apply any
    // absolute/relative transformation to the resource name.
    ClassLoader classLoader = getClass().getClassLoader();
    URL resource = classLoader.getResource("database.conf");
    properties.load(new FileReader(new File(resource.getFile())));
    System.out.println("JDBC URL: " + properties.get("jdbc.url"));

    InputStream is = classLoader.getResourceAsStream("database.conf");
    properties.load(is);
    System.out.println("JDBC URL: " + properties.get("jdbc.url"));
}

   Below is the main program that calls the methods above.
   
package org.kodejava.example.lang;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Properties;

public class LoadResourceFile {
    public static void main(String[] args) throws Exception {
        LoadResourceFile demo = new LoadResourceFile();
        demo.loadUsingClassMethod();
        demo.loadUsingClassLoaderMethod();
    }
}

   In the snippet above we load two difference resources. One contains Oracle database configuration and
   the other is MySQL database configuration.

   /resources/org/kodejava/example/lang/database.conf
jdbc.driver=oracle.jdbc.driver.OracleDriver
jdbc.url=jdbc:oracle:thin:@localhost:1521:xe
jdbc.username=kodejava
jdbc.password=kodejava123

   /resources/database.conf
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost/kodejava
jdbc.username=kodejava
jdbc.password=kodejava123

   The result of this code snippet are:
   
LoadResourceFile.loadUsingClassMethod
JDBC Driver: oracle.jdbc.driver.OracleDriver
JDBC Driver: com.mysql.jdbc.Driver

LoadResourceFile.loadUsingClassLoaderMethod
JDBC URL: jdbc:mysql://localhost/kodejava
JDBC URL: jdbc:mysql://localhost/kodejava



---
https://www.codota.com/code/java/methods/java.lang.Class/getResourceAsStream

Best Java code snippets using java.lang.Class.getResourceAsStream (Showing top 20 results out of
55,746)

Common ways to obtain Class
    private void myMethod () {
        Class c =
            // Object obj;
            obj.getClass()
            
            // String className;
            Class.forName(className)
            
            // ClassLoader classLoader; String className;
            classLoader.loadClass(className)
    }

TestResourceUtil.openResource(...)
    /**
    * Returns an InputStream for the given test class and sub-path.
    *
    * @param testClass A Junit test class.
    * @param subPath   The sub-path under androidTest/resources where the desired resource is
    *                  located. Should not be prefixed with a '/'
    */
    public static InputStream openResource(Class<?> testClass, String subPath) {
        return testClass.getResourceAsStream("/" + subPath);
    }
}

Main.versionString()
    private static String versionString() {
        try {
            Properties prop = new Properties();
            InputStream in = Main.class.getResourceAsStream("/okcurl-version.properties");
            prop.load(in);
            in.close();
            return prop.getProperty("version");
        } catch (IOException e) {
        throw new AssertionError("Could not load okcurl-version.properties.");
        }
    }


How to really read text file from classpath in Java
package dummy;

import java.io.*;

public class Test {
    public static void main(String[] args) {
        InputStream stream = Test.class.getResourceAsStream("/SomeTextFile.txt");
        System.out.println(stream != null);
        stream = Test.class.getClassLoader().getResourceAsStream("SomeTextFile.txt");
        System.out.println(stream != null);
    }
}

How to really read text file from classpath in Java
// From ClassLoader, all paths are "absolute" already - there's no context
// from which they could be relative. Therefore you don't need a leading slash.
InputStream in = this.getClass().getClassLoader().getResourceAsStream("SomeTextFile.txt");

// From Class, the path is relative to the package of the class unless
// you include a leading slash, so if you don't want to use the current
// package, include a slash like this:
InputStream in = this.getClass().getResourceAsStream("/SomeTextFile.txt");


Utils.openFontTTF(...)
@Nullable
public static Font openFontTTF(String name) {
    String fontPath = "/fonts/" + name + ".ttf";
    try (InputStream is = Utils.class.getResourceAsStream(fontPath)) {
        Font font = Font.createFont(Font.TRUETYPE_FONT, is);
        return font.deriveFont(12f);
    } catch (Exception e) {
        LOG.error("Failed load font by path: {}", fontPath, e);
        return null;
    }
}

TemplateFile.fromResources(...)
public static TemplateFile fromResources(String path) throws FileNotFoundException {
    InputStream res = TemplateFile.class.getResourceAsStream(path);
    if (res == null) {
        throw new FileNotFoundException("Resource not found: " + path);
    }
    return new TemplateFile(path, res);
}


MainWindow.setEditorTheme(...)
private void setEditorTheme(String editorThemePath) {
    try {
        editorTheme = Theme.load(getClass().getResourceAsStream(editorThemePath));
    } catch (Exception e) {
        LOG.error("Can't load editor theme from classpath: {}", editorThemePath);
        try {
            editorTheme = Theme.load(new FileInputStream(editorThemePath));
        } catch (Exception e2) {
            LOG.error("Can't load editor theme from file: {}", editorThemePath);
        }
    }
}


AbstractStaxXMLReaderTestCase.createTestInputStream()
private InputStream createTestInputStream() {
    return getClass().getResourceAsStream("testContentHandler.xml");
}


ClsSet.load()
public void load() throws IOException, DecodeException {
    try (InputStream input = getClass().getResourceAsStream(CLST_FILENAME)) {
        if (input == null) {
            throw new JadxRuntimeException("Can't load classpath file: " + CLST_FILENAME);
        }
        load(input);
    }
}


StandardClasses.standardClassImage()
public JAXBElement<Image> standardClassImage() throws IOException {
    Image image = ImageIO.read(getClass().getResourceAsStream("spring-ws.png"));
    return new JAXBElement<>(NAME, Image.class, image);
}


ManifestAttributes.loadXML(...)
private Document loadXML(String xml) {
    Document doc;
    try (InputStream xmlStream = ManifestAttributes.class.getResourceAsStream(xml)) {
        if (xmlStream == null) {
            throw new JadxRuntimeException(xml + " not found in classpath");
        }
        DocumentBuilder dBuilder = XmlSecurity.getSecureDbf().newDocumentBuilder();
        doc = dBuilder.parse(xmlStream);
    } catch (Exception e) {
        throw new JadxRuntimeException("Xml load error, file: " + xml, e);
    }
    return doc;
}


HtmlCharacterEntityReferencesTests$CharacterEntityResourceIterator.<init>()
public CharacterEntityResourceIterator() {
    try {
        InputStream inputStream = getClass().getResourceAsStream(DTD_FILE);
        if (inputStream == null) {
            throw new IOException("Cannot find definition resource [" + DTD_FILE + "]");
        }
        tokenizer = new StreamTokenizer(new BufferedReader(new InputStreamReader(inputStream, "UTF-8")));
    }
    catch (IOException ex) {
        throw new IllegalStateException("Failed to open definition resource [" + DTD_FILE + "]");
    }
}


ValuesParser.decodeAndroid()
private static void decodeAndroid() throws IOException {
    InputStream inputStream = new BufferedInputStream(ValuesParser.class.getResourceAsStream("/resources.arsc"));
    ResTableParser androidParser = new ResTableParser();
    androidParser.decode(inputStream);
    androidStrings = androidParser.getStrings();
    androidResMap = androidParser.getResStorage().getResourcesNames();
}


XmlBeanDefinitionReaderTests.withInputSource()
@Test(expected = BeanDefinitionStoreException.class)
public void withInputSource() {
    SimpleBeanDefinitionRegistry registry = new SimpleBeanDefinitionRegistry();
    InputSource resource = new InputSource(getClass().getResourceAsStream("test.xml"));
    new XmlBeanDefinitionReader(registry).loadBeanDefinitions(resource);
}


ResourceHttpMessageConverterTests.shouldNotReadInputStreamResource()
@Test  // SPR-14882
public void shouldNotReadInputStreamResource() throws IOException {
    ResourceHttpMessageConverter noStreamConverter = new ResourceHttpMessageConverter(false);
    try (InputStream body = getClass().getResourceAsStream("logo.jpg") ) {
        this.thrown.expect(HttpMessageNotReadableException.class);
        MockHttpInputMessage inputMessage = new MockHttpInputMessage(body);
        inputMessage.getHeaders().setContentType(MediaType.IMAGE_JPEG);
        noStreamConverter.read(InputStreamResource.class, inputMessage);
    }
}


XmlBeanDefinitionReaderTests.withInputSourceAndExplicitValidationMode()
@Test
public void withInputSourceAndExplicitValidationMode() {
    SimpleBeanDefinitionRegistry registry = new SimpleBeanDefinitionRegistry();
    InputSource resource = new InputSource(getClass().getResourceAsStream("test.xml"));
    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(registry);
    reader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_DTD);
    reader.loadBeanDefinitions(resource);
    testBeanDefinitions(registry);
}


XmlBeanDefinitionReaderTests.withOpenInputStream()
@Test(expected = BeanDefinitionStoreException.class)
public void withOpenInputStream() {
    SimpleBeanDefinitionRegistry registry = new SimpleBeanDefinitionRegistry();
    Resource resource = new InputStreamResource(getClass().getResourceAsStream("test.xml"));
    new XmlBeanDefinitionReader(registry).loadBeanDefinitions(resource);
}


ResourceHttpMessageConverterTests.shouldReadImageResource()
@Test
public void shouldReadImageResource() throws IOException {
    byte[] body = FileCopyUtils.copyToByteArray(getClass().getResourceAsStream("logo.jpg"));
    MockHttpInputMessage inputMessage = new MockHttpInputMessage(body);
    inputMessage.getHeaders().setContentType(MediaType.IMAGE_JPEG);
    inputMessage.getHeaders().setContentDisposition(
        ContentDisposition.builder("attachment").filename("yourlogo.jpg").build());
    Resource actualResource = converter.read(Resource.class, inputMessage);
    assertThat(FileCopyUtils.copyToByteArray(actualResource.getInputStream()), is(body));
    assertEquals("yourlogo.jpg", actualResource.getFilename());
}


ResourceHttpMessageConverterTests.shouldReadInputStreamResource()
@Test  // SPR-13443
public void shouldReadInputStreamResource() throws IOException {
    try (InputStream body = getClass().getResourceAsStream("logo.jpg") ) {
        MockHttpInputMessage inputMessage = new MockHttpInputMessage(body);
        inputMessage.getHeaders().setContentType(MediaType.IMAGE_JPEG);
        inputMessage.getHeaders().setContentDisposition(
            ContentDisposition.builder("attachment").filename("yourlogo.jpg").build());
        Resource actualResource = converter.read(InputStreamResource.class, inputMessage);
        assertThat(actualResource, instanceOf(InputStreamResource.class));
        assertThat(actualResource.getInputStream(), is(body));
        assertEquals("yourlogo.jpg", actualResource.getFilename());
    }
}


XmlBeanDefinitionReaderTests.withOpenInputStreamAndExplicitValidationMode()
@Test
public void withOpenInputStreamAndExplicitValidationMode() {
    SimpleBeanDefinitionRegistry registry = new SimpleBeanDefinitionRegistry();
    Resource resource = new InputStreamResource(getClass().getResourceAsStream("test.xml"));
    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(registry);
    reader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_DTD);
    reader.loadBeanDefinitions(resource);
    testBeanDefinitions(registry);
}



---
https://stackoverflow.com/questions/573679/open-resource-with-relative-path-in-java

open resource with relative path in java

   In my Java app I need to get some files and directories.

   This is the program structure:
./main.java
./package1/guiclass.java
./package1/resources/resourcesloader.java
./package1/resources/repository/modules/            -> this is the dir I need to get
./package1/resources/repository/SSL-Key/cert.jks    -> this is the file I need to get

   guiclass loads the resourcesloader class which will load my resources (directory and file).

   As to the file, I tried
resourcesloader.class.getClass().getResource("repository/SSL-Key/cert.jks").toString()

   in order to get the real path, but this way does not work.

   I have no idea how to do the directory.

***
     * 1
       class.getClass() is not the same as class.getClassLoader(). There is another solution too,
       getResourceAsStream() using a class in the same package as your resource.

***
   Supply the path relative to the classloader, not the class you're getting the loader from. For
   instance:
resourcesloader.class.getClassLoader().getResource("package1/resources/repository/SSL-Key/cert.jks").toString();

***
   I had problems with using the getClass().getResource("filename.txt") method. Upon reading the Java
   docs instructions, if your resource is not in the same package as the class you are trying to access
   the resource from, then you have to give it relative path starting with '/'. The recommended strategy
   is to put your resource files under a "resources" folder in the root directory. So for example if you
   have the structure:
src/main/com/mycompany/myapp

   then you can add a resources folder as recommended by maven in:
src/main/resources

   furthermore you can add subfolders in the resources folder
src/main/resources/textfiles

   and say that your file is called myfile.txt so you have
src/main/resources/textfiles/myfile.txt

   Now here is where the stupid path problem comes in. Say you have a class in your com.mycompany.myapp
   package, and you want to access the myfile.txt file from your resource folder. Some say you need to
   give the:
"/main/resources/textfiles/myfile.txt" path

   or
"/resources/textfiles/myfile.txt"

   both of these are wrong. After I ran mvn clean compile, the files and folders are copied in the:
myapp/target/classes

   folder. But the resources folder is not there, just the folders in the resources folder. So you have:
myapp/target/classes/textfiles/myfile.txt

myapp/target/classes/com/mycompany/myapp/*

   so the correct path to give to the getClass().getResource("") method is:
"/textfiles/myfile.txt"

   here it is:
getClass().getResource("/textfiles/myfile.txt")

   This will no longer return null, but will return your class. I hope this helps somebody. It is
   strange to me, that the "resources" folder is not copied as well, but only the subfolders and files
   directly in the "resources" folder. It would seem logical to me that the "resources" folder would
   also be found under "myapp/target/classes"

***
     * 1
       In my target/classes, I can only see files under main resources and not test resources. Why?
     * Add test folder as your source folder and you are good to go!

***
   In the hopes of providing additional information for those who don't pick this up as quickly as
   others, I'd like to provide my scenario as it has a slightly different setup. My project was setup
   with the following directory structure (using Eclipse):
Project/
  src/                // application source code
    org/
      myproject/
        MyClass.java
  test/               // unit tests
  res/                // resources
    images/           // PNG images for icons
      my-image.png
    xml/              // XSD files for validating XML files with JAXB
      my-schema.xsd
    conf/             // default .conf file for Log4j
      log4j.conf
  lib/                // libraries added to build-path via project settings

   I was having issues loading my resources from the res directory. I wanted all my resources separate
   from my source code (simply for managment/organization purposes). So, what I had to do was add the
   res directory to the build-path and then access the resource via:
static final ClassLoader loader = MyClass.class.getClassLoader();

// in some function
loader.getResource("images/my-image.png");
loader.getResource("xml/my-schema.xsd");
loader.getResource("conf/log4j.conf");

   NOTE: The / is omitted from the beginning of the resource string because I am using
   ClassLoader.getResource(String) instead of Class.getResource(String).

***
   @GianCarlo: You can try calling System property user.dir that will give you root of your java project
   and then do append this path to your relative path for example:
String root = System.getProperty("user.dir");
String filepath = "/path/to/yourfile.txt"; // in case of Windows: "\\path \\to\\yourfile.txt
String abspath = root+filepath;



// using above path read your file into byte []
File file = new File(abspath);
FileInputStream fis = new FileInputStream(file);
byte []filebytes = new byte[(int)file.length()];
fis.read(filebytes);

***
     * 1
       OP wanted to locate a resource in the classpath (most likely in a jar generated during thE build).
       This method does not provide a way to achieve that goal -- you cannot point a File to a resource
       inside a jar file, only to a proper entry in the file system (e.g. the jar itself).


***
   When you use 'getResource' on a Class, a relative path is resolved based on the package the Class is
   in. When you use 'getResource' on a ClassLoader, a relative path is resolved based on the root
   folder.

   If you use an absolute path, both 'getResource' methods will start at the root folder.

***
   For those using eclipse + maven. Say you try to access the file images/pic.jpg in src/main/resources.
   Doing it this way :
ClassLoader loader = MyClass.class.getClassLoader();
File file = new File(loader.getResource("images/pic.jpg").getFile());

   is perfectly correct, but may result in a null pointer exception. Seems like eclipse doesn't
   recognize the folders in the maven directory structure as source folders right away. By removing and
   the src/main/resources folder from the project's source folders list and putting it back
   (project>properties>java build path> source>remove/add Folder), I was able to solve this.

***
resourcesloader.class.getClass()

   Can be broken down to:
Class<resourcesloader> clazz = resourceloader.class;
Class<Class> classClass = clazz.getClass();

   Which means you're trying to load the resource using a bootstrap class.

   Instead you probably want something like:
resourcesloader.class.getResource("repository/SSL-Key/cert.jks").toString()

   If only javac warned about calling static methods on non-static contexts...

***
   Going with the two answers as mentioned above. The first one
resourcesloader.class.getClassLoader().getResource("package1/resources/repository/SSL-Key/cert.jks").toString();
resourcesloader.class.getResource("repository/SSL-Key/cert.jks").toString()

   Should be one and same thing?

***
   I made a small modification on @jonathan.cone's one liner ( by adding .getFile() ) to avoid null
   pointer exception, and setting the path to data directory. Here's what worked for me :
String realmID = new java.util.Scanner(new java.io.File(RandomDataGenerator.class.getClassLoader()Ä
.getResource("data/aa-qa-id.csv").getFile().toString())).next();

***
   In Order to obtain real path to the file you can try this:
URL fileUrl = Resourceloader.class.getResource("resources/repository/SSL-Key/cert.jks");
String pathToClass = fileUrl.getPath;

   Resourceloader is classname here. "resources/repository/SSL-Key/cert.jks" is relative path to the
   file. If you had your guiclass in ./package1/java with rest of folder structure remaining, you would
   take "../resources/repository/SSL-Key/cert.jks" as relative path because of rules defining relative
   path.

   This way you can read your file with BufferedReader. DO NOT USE THE STRING to identify the path to
   the file, because if you have spaces or some characters from not english alphabet in your path, you
   will get problems and the file will not be found.
BufferedReader bufferedReader = new BufferedReader(
                        new InputStreamReader(fileUrl.openStream()));


---
https://www.jverstrynge.com/2012/07/maven-how-to-access-filesdata-in.html

How to Access Files/Data in the Resource Directory at Runtime?
Friday, 27 July 2012

   A common concern of developers using Maven for the first time is how to access a file (binary or
   text) declared as a resource in Maven. Contrary to typical NetBeans projects (for example), maven
   insists on using a standard directory structure:
   My Project
   |-src
     `-main
       |-java
       | `-MyPackage
       |   `-MyClass.java
       `-resources
         `-MyPackage
           `-MyData.txt
             
   In a standard NetBeans project, since MyClass.java uses MyData.txt, both are (often) located in the
   same directory corresponding to the MyPackage Java package. However, in a Maven project, code is
   separated from data in different directories.
   Some developers believe that the Maven directory structure will be replicated in the .jar after
   compilation. Therefore, they are tempted to try to open the data resource with a strategy similar to
   this one:
String loc = new File(".").getAbsolutePath()
  + "\src\main\resources\MyPackage\MyData.txt";
FileInputStream FIS = new FileInputStream(new File(loc));
...

   In other words, they believe they have to handle the Maven directory structure themselves, including
   the absolute path to the current .jar location. This does not work.
   First, one must keep in mind that Maven does not "push" its directory structure in .jars. Both
   MyClass.java and MyData.txt will be located in the same \MyPackage directory within the .jar. You can
   check this by opening the .jar with winzip for example.
   The solution is the following (resource location is relative to Myclass location or package (*)):
InputStream IS = MyClass.class
    .getResourceAsStream("MyData.txt");

Caveat - Encoding Issue
   If your data is not binary, you need to pay attention to the encoding format in the file itself (for
   example, set it to UTF-8) and make sure it is the same encoding as in your Maven project. You should
   have the following setting in your pom.xml:
<properties>
  <project.build.sourceEncoding>
    UTF-8
  </project.build.sourceEncoding>
  ...
<properties>

   This is an issue that took me hours to solve, because encoding/display errors would only happen at
   runtime.
   (*) More on absolute and relative path
   [**1] [http://tshikatshikaaa.blogspot.nl/2012/08/understanding-absolute-and-relative.html]here.
   
---
[**1]
http://tshikatshikaaa.blogspot.nl/2012/08/understanding-absolute-and-relative.html

Understanding Absolute and Relative Path with getResourceAsStream()

Not making the difference between absolute and relative paths when loading resources in Java is a common
source of errors leading to NullPointerException (NPE).

Assuming the following structure and content in a maven project:

My Project
  +-src
    +-main
      |-java
      | +-SomePackage
      |   +-SomeClass.java
      +-resources
        |-Root.txt
        +-SomePackage
          |-MyData.txt
          +-SomePackage2
            +-MySubData.txt

Content will be re-organized as following in the .jar:
  |-Root.txt
  +-SomePackage
    |-SomeClass.java
    |-MyData.txt
    +-SomePackage2
      +-MySubData.txt

The following indicates what works and what does not work to retrieve resource data:

InputStream IS;

IS = SomeClass.class.getResourceAsStream(
    "Root.txt"); // Not OK

IS = SomeClass.class.getResourceAsStream(
    "/Root.txt"); // OK

IS = SomeClass.class.getResourceAsStream(
    "/MyData.txt"); // Not OK

IS = SomeClass.class.getResourceAsStream(
    "MyData.txt"); // OK

IS = SomeClass.class.getResourceAsStream(
    "/SomePackage/MyData.txt"); // OK

IS = SomeClass.class.getResourceAsStream(
    "SomePackage/MyData.txt"); // Not OK

IS = SomeClass.class.getResourceAsStream(
    "MySubData.txt"); // Not OK

IS = SomeClass.class.getResourceAsStream(
    "SomePackage/SomePackage2/MySubData.txt"); // OK

IS = SomeClass.class.getResourceAsStream(
    "/SomePackage/SomePackage2/MySubData.txt"); // Not OK

IS = SomeClass.class.getResourceAsStream(
    "/SomePackage2/MySubData.txt"); // Not OK

IS = SomeClass.class.getResourceAsStream(
    "SomePackage2/MySubData.txt"); // OK

getResourceAsStream() operates relative to the package corresponding to the called Class instance. 


---
