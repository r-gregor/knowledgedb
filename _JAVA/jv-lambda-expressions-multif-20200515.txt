filename: jv_lambda-expressions-multif_20200515.txt
http://tutorials.jenkov.com/java/lambda-expressions.html

Java Lambda Expressions
2019-01-18

   Java lambda expressions are new in Java 8. Java lambda expressions are Java's first step into
   functional programming. A Java lambda expression is thus a function which can be created without
   belonging to any class. A Java lambda expression can be passed around as if it was an object and
   executed on demand.

   Java lambda expressions are commonly used to implement simple event listeners / callbacks, or in
   functional programming with the [64]Java Streams API.

   If you prefer video, I have a video version of this tutorial in this [65]Java Lambda Expression
   YouTube Playlist. Here is the first video in this playlist:

Java Lambdas and the Single Method Interface
   Functional programming is very often used to implement event listeners. Event listeners in Java are
   often defined as Java interfaces with a single method. Here is a fictive single method interface
   example:
public interface StateChangeListener {

    public void onStateChange(State oldState, State newState);

}

   This Java interface defines a single method which is called whenever the state changes (in whatever
   is being observed).

   In Java 7 you would have to implement this interface in order to listen for state changes. Imagine
   you have a class called StateOwner which can register state event listeners. Here is an example:
public class StateOwner {

    public void addStateListener(StateChangeListener listener) { ... }

}

   In Java 7 you could add an event listener using an anonymous interface implementation, like this:
StateOwner stateOwner = new StateOwner();

stateOwner.addStateListener(new StateChangeListener() {

    public void onStateChange(State oldState, State newState) {
        // do something with the old and new state.
    }
});

   First a StateOwner instance is created. Then an anonymous implementation of the StateChangeListener
   interface is added as listener on the StateOwner instance.

   In Java 8 you can add an event listener using a Java lambda expression, like this:
StateOwner stateOwner = new StateOwner();

stateOwner.addStateListener(
    (oldState, newState) -> System.out.println("State changed")
);

   The lambda expressions is this part:
(oldState, newState) -> System.out.println("State changed")

   The lambda expression is matched against the parameter type of the addStateListener() method's
   parameter. If the lambda expression matches the parameter type (in this case the StateChangeListener
   interface) , then the lambda expression is turned into a function that implements the same interface
   as that parameter.

   Java lambda expressions can only be used where the type they are matched against is a single method
   interface. In the example above, a lambda expression is used as parameter where the parameter type
   was the StateChangeListener interface. This interface only has a single method. Thus, the lambda
   expression is matched successfully against that interface.

Matching Lambdas to Interfaces
   A single method interface is also sometimes referred to as a functional interface. Matching a Java
   lambda expression against a functional interface is divided into these steps:
     * Does the interface have only one abstract (unimplemented) method?
     * Does the parameters of the lambda expression match the parameters of the single method?
     * Does the return type of the lambda expression match the return type of the single method?

   If the answer is yes to these three questions, then the given lambda expression is matched
   successfully against the interface.

Interfaces With Default and Static Methods
   From Java 8 a [67]Java interface can contain both default methods and static methods. Both default
   methods and static methods have an implementation defined directly in the interface declaration. This
   means, that a Java lambda expression can implement interfaces with more than one method - as long as
   the interface only has a single unimplemented (AKA abstract) method.

   In other words, an interface is still a functional interface even if it contains default and static
   methods, as long as the interface only contains a single unimplemented (abstract) method. Here is a
   video version of this little section:

   IFRAME: [68]https://www.youtube.com/embed/GxZWMgpMuLs

   The following interface can be implemented with a lambda expression:
import java.io.IOException;
import java.io.OutputStream;

public interface MyInterface {

    void printIt(String text);

    default public void printUtf8To(String text, OutputStream outputStream){
        try {
            outputStream.write(text.getBytes("UTF-8"));
        } catch (IOException e) {
            throw new RuntimeException("Error writing String as UTF-8 to OutputStream", e);
        }
    }

    static void printItToSystemOut(String text){
        System.out.println(text);
    }
}

   Even though this interface contains 3 methods it can be implemented by a lambda expression, because
   only one of the methods is unimplemented. Here is how the implementation looks:
MyInterface myInterface = (String text) -> {
    System.out.print(text);
};

Lambda Expressions vs. Anonymous Interface Implementations

   Even though lambda expressions are close to anonymous interface implementations, there are a few
   differences that are worth noting.

   The major difference is, that an anonymous interface implementation can have state (member variables)
   whereas a lambda expression cannot. Look at this interface:
public interface MyEventConsumer {

    public void consume(Object event);

}


   This interface can be implemented using an anonymous interface implementation, like this:
MyEventConsumer consumer = new MyEventConsumer() {
    public void consume(Object event){
        System.out.println(event.toString() + " consumed");
    }
};

   This anonymous MyEventConsumer implementation can have its own internal state. Look at this redesign:
MyEventConsumer myEventConsumer = new MyEventConsumer() {
    private int eventCount = 0;
    public void consume(Object event) {
        System.out.println(event.toString() + " consumed " + this.eventCount++ + " times.");
    }
};

   Notice how the anonymous MyEventConsumer implementation now has a field named eventCount.

   A lambda expression cannot have such fields. A lambda expression is thus said to be stateless.

Lambda Type Inference
   Before Java 8 you would have to specify what interface to implement, when making anonymous interface
   implementations. Here is the anonymous interface implementation example from the beginning of this
   text:
stateOwner.addStateListener(new StateChangeListener() {

    public void onStateChange(State oldState, State newState) {
        // do something with the old and new state.
    }
});

   With lambda expressions the type can often be inferred from the surrounding code. For instance, the
   interface type of the parameter can be inferred from the method declaration of the addStateListener()
   method (the single method on the StateChangeListener interface). This is called type inference. The
   compiler infers the type of a parameter by looking elsewhere for the type - in this case the method
   definition. Here is the example from the beginning of this text, showing that the StateChangeListener
   interface is not mentioned in the lambda expression:
stateOwner.addStateListener(
    (oldState, newState) -> System.out.println("State changed")
);

   In the lambda expression the parameter types can often be inferred too. In the example above, the
   compiler can infer their type from the onStateChange() method declaration. Thus, the type of the
   parameters oldState and newState are inferred from the method declaration of the onStateChange()
   method.

Lambda Parameters
   Since Java lambda expressions are effectively just methods, lambda expressions can take parameters
   just like methods. The (oldState, newState) part of the lambda expression shown earlier specifies the
   parameters the lambda expression takes. These parameters have to match the parameters of the method
   on the single method interface. In this case, these parameters have to match the parameters of the
   onStateChange() method of the StateChangeListener interface:
public void onStateChange(State oldState, State newState);

   As a minimum the number of parameters in the lambda expression and the method must match.

   Second, if you have specified any parameter types in the lambda expression, these types must match
   too. I haven't shown you how to put types on lambda expression parameters yet (it is shown later in
   this text), but in many cases you don't need them.

Zero Parameters
   If the method you are matching your lambda expression against takes no parameters, then you can write
   your lambda expression like this:
() -> System.out.println("Zero parameter lambda");

   Notice how the parentheses have no content in between. That is to signal that the lambda takes no
   parameters.

One Parameter
   If the method you are matching your Java lambda expression against takes one parameter, you can write
   the lambda expression like this:
(param) -> System.out.println("One parameter: " + param);

   Notice the parameter is listed inside the parentheses.

   When a lambda expression takes a single parameter, you can also omit the parentheses, like this:
 param -> System.out.println("One parameter: " + param);

Multiple Parameters
   If the method you match your Java lambda expression against takes multiple parameters, the parameters
   need to be listed inside parentheses. Here is how that looks in Java code:
(p1, p2) -> System.out.println("Multiple parameters: " + p1 + ", " + p2);

   Only when the method takes a single parameter can the parentheses be omitted.

Parameter T
   Specifying parameter types for a lambda expression may sometimes be necessary if the compiler cannot
   infer the parameter types from the functional interface method the lambda is matching. Don't worry,
   the compiler will tell you when that is the case. Here is a Java lambda parameter type example:
(Car car) -> System.out.println("The car is: " + car.getName());

   As you can see, the type (Car) of the car parameter is written in front of the parameter name itself,
   just like you would when declaring a parameter in a method elsewhere, or when making an anonymous
   implementation of an interface.

var Parameter Types from Java 11
   From Java 11 you can use the var keyword as parameter type. The var keyword was introduced in Java 10
   as [69]local variable type inference. From Java 11 var can also be used for lambda parameter types.
   Here is an example of using the Java var keyword as parameter types in a lambda expression:
Function<String, String> toLowerCase = (var input) -> input.toLowerCase();

   The type of the parameter declared with the var keyword above will be inferred to the type String,
   because the type declaration of the variable has its generic type set to Function<String, String>,
   which means that the parameter type and return type of the Function is String.

Lambda Function Body
   The body of a lambda expression, and thus the body of the function / method it represents, is
   specified to the right of the -> in the lambda declaration: Here is an example:
 (oldState, newState) -> System.out.println("State changed")

   If your lambda expression needs to consist of multiple lines, you can enclose the lambda function
   body inside the { } bracket which Java also requires when declaring methods elsewhere. Here is an
   example:
 (oldState, newState) -> {
    System.out.println("Old state: " + oldState);
    System.out.println("New state: " + newState);
  }

Returning a Value From a Lambda Expression
   You can return values from Java lambda expressions, just like you can from a method. You just add a
   return statement to the lambda function body, like this:
 (param) -> {
    System.out.println("param: " + param);
    return "return value";
  }

   In case all your lambda expression is doing is to calculate a return value and return it, you can
   specify the return value in a shorter way. Instead of this:
 (a1, a2) -> { return a1 > a2; }

   You can write:
 (a1, a2) -> a1 > a2;

   The compiler then figures out that the expression a1 > a2 is the return value of the lambda
   expression (hence the name lambda expressions - as expressions return a value of some kind).

Lambdas as Objects

   A Java lambda expression is essentially an object. You can assign a lambda expression to a variable
   and pass it around, like you do with any other object. Here is an example:
public interface MyComparator {

    public boolean compare(int a1, int a2);

}

MyComparator myComparator = (a1, a2) -> return a1 > a2;

boolean result = myComparator.compare(2, 5);

   The first code block shows the interface which the lambda expression implements. The second code
   block shows the definition of the lambda expression, how the lambda expression is assigned to
   variable, and finally how the lambda expression is invoked by invoking the interface method it
   implements.

Variable Capture
   A Java lambda expression is capable of accessing variables declared outside the lambda function body
   under certain circumstances. I have a video version of this section here:

   IFRAME: [70]https://www.youtube.com/embed/kBc8S40HdoM

   Java lambdas can capture the following types of variables:
     * Local variables
     * Instance variables
     * Static variables

   Each of these variable captures will described in the following sections.

Local Variable Capture
   A Java lambda can capture the value of a local variable declared outside the lambda body. To
   illustrate that, first look at this single method interface:
public interface MyFactory {
    public String create(char[] chars);
}

   Now, look this lambda expression that implements the MyFactory interface:
MyFactory myFactory = (chars) -> {
    return new String(chars);
};

   Right now this lambda expression is only referencing the parameter value passed to it (chars). But we
   can change that. Here is an updated version that references a String variable declared outside the
   lambda function body:
String myString = "Test";

MyFactory myFactory = (chars) -> {
    return myString + ":" + new String(chars);
};

   As you can see, the lambda body now references the local variable myString which is declared outside
   the lambda body. This is possible if, and only if, the variable being references is "effectively
   final", meaning it does not change its value after being assigned. If the myString variable had its
   value changed later, the compiler would complain about the reference to it from inside the lambda
   body.

Instance Variable Capture
   A lambda expression can also capture an instance variable in the object that creates the lambda. Here
   is an example that shows that:
public class EventConsumerImpl {

    private String name = "MyConsumer";

    public void attach(MyEventProducer eventProducer){
        eventProducer.listen(e -> {
            System.out.println(this.name);
        });
    }
}

   Notice the reference to this.name inside the lambda body. This captures the name instance variable of
   the enclosing EventConsumerImpl object. It is even possible to change the value of the instance
   variable after its capture - and the value will be reflected inside the lambda.

   The semantics of this is actually one of the areas where Java lambdas differ from anonymous
   implementations of interfaces. An anonymous interface implementation can have its own instance
   variables which are referenced via the this reference. However, an lambda cannot have its own
   instance variables, so this always points to the enclosing object.

   Note: The above design of an event consumer is not particularly elegant. I just made it like that to
   be able to illustrate instance variable capture.

Static Variable Capture
   A Java lambda expression can also capture static variables. This is not surprising, as static
   variables are reachable from everywhere in a Java application, provided the static variable is
   accessible (packaged scoped or public).

   Here is an example class that creates a lambda which references a static variable from inside the
   lambda body:
public class EventConsumerImpl {
    private static String someStaticVar = "Some text";

    public void attach(MyEventProducer eventProducer){
        eventProducer.listen(e -> {
            System.out.println(someStaticVar);
        });
    }
}

   The value of a static variable is also allowed to change after the lambda has captured it.

   Again, the above class design is a bit nonsensical. Don't think too much about that. The class
   primarily serves to show you that a lambda can access static variables.

Method References as Lambdas
   In the case where all your lambda expression does is to call another method with the parameters
   passed to the lambda, the Java lambda implementation provides a shorter way to express the method
   call. First, here is an example single function interface:
public interface MyPrinter{
    public void print(String s);
}

   And here is an example of creating a Java lambda instance implementing the MyPrinter interface:
MyPrinter myPrinter = (s) -> { System.out.println(s); };

   Because the lambda body only consists of a single statement, we can actually omit the enclosing { }
   brackets. Also, since there is only one parameter for the lambda method, we can omit the enclosing (
   ) brackets around the parameter. Here is how the resulting lambda declaration looks:
MyPrinter myPrinter = s -> System.out.println(s);

   Since all the lambda body does is forward the string parameter to the System.out.println() method, we
   can replace the above lambda declaration with a method reference. Here is how a lambda method
   reference looks:
MyPrinter myPrinter = System.out::println;

   Notice the double colons :: . These signal to the Java compiler that this is a method reference. The
   method referenced is what comes after the double colons. Whatever class or object that owns the
   referenced method comes before the double colons.

   You can reference the following types of methods:
     * Static method
     * Instance method on parameter objects
     * Instance method
     * Constructor

   Each of these types of method references are covered in the following sections.

Static Method References
   The easiest methods to reference are static methods. Here is first an example of a single function
   interface:
public interface Finder {
    public int find(String s1, String s2);
}

   And here is a static method that we want to create a method reference to:
public class MyClass{
    public static int doFind(String s1, String s2){
        return s1.lastIndexOf(s2);
    }
}

   And finally here is a Java lambda expression referencing the static method:
Finder finder = MyClass::doFind;

   Since the parameters of the Finder.find() and MyClass.doFind() methods match, it is possible to
   create a lambda expression that implements Finder.find() and references the MyClass.doFind() method.

Parameter Method Reference
   You can also reference a method of one of the parameters to the lambda. Imagine a single function
   interface that looks like this:
public interface Finder {
    public int find(String s1, String s2);
}

   The interface is intended to represent a component able to search s1 for occurrences of s2. Here is
   an example of a Java lambda expression that calls String.indexOf() to search:
Finder finder = String::indexOf;

   This is equivalent of this lambda definition:
Finder finder = (s1, s2) -> s1.indexOf(s2);

   Notice how the shortcut version references a single method. The Java compiler will attempt to match
   the referenced method against the first parameter type, using the second parameter type as parameter
   to the referenced method.

Instance Method References
   Third, it is also possible to reference an instance method from a lambda definition. First, let us
   look at a single method interface definition:
public interface Deserializer {
    public int deserialize(String v1);
}

   This interface represents a component that is capable of "deserializing" a String into an int.

   Now look at this StringConverter class:
public class StringConverter {
    public int convertToInt(String v1){
        return Integer.valueOf(v1);
    }
}

   The convertToInt() method has the same signature as the deserialize() method of the Deserializer
   deserialize() method. Because of that, we can create an instance of StringConverter and reference its
   convertToInt() method from a Java lambda expression, like this:
StringConverter stringConverter = new StringConverter();

Deserializer des = stringConverter::convertToInt;

   The lambda expression created by the second of the two lines references the convertToInt method of
   the StringConverter instance created on the first line.

Constructor References
   Finally it is possible to reference a constructor of a class. You do that by writing the class name
   followed by ::new, like this:
MyClass::new

   Too see how to use a constructor as a lambda expression, look at this interface definition:
public interface Factory {
    public String create(char[] val);
}

   The create() method of this interface matches the signature of one of the constructors in the String
   class. Therefore this constructor can be used as a lambda. Here is an example of how that looks:
Factory factory = String::new;

   This is equivalent to this Java lambda expression:
Factory factory = chars -> new String(chars);



---
https://www.geeksforgeeks.org/lambda-expressions-java-8/

Lambda Expressions in Java 8

   Lambda expressions basically express instances of [275]functional interfaces (An interface with
   single abstract method is called functional interface. An example is java.lang.Runnable). lambda
   expressions implement the only abstract function and therefore implement functional interfaces

   lambda expressions are added in Java 8 and provide below functionalities.
     * Enable to treat functionality as a method argument, or code as data.
     * A function that can be created without belonging to any class.
     * A lambda expression can be passed around as if it was an object and executed on demand.

   // Java program to demonstrate lambda expressions
   // to implement a user defined functional interface.

   // A sample functional interface (An interface with
   // single abstract method
   interface FuncInterface
   {
       // An abstract function
       void abstractFun(int x);

       // A non-abstract (or default) function
       default void normalFun()
       {
          System.out.println("Hello");
       }
   }

   class Test
   {
       public static void main(String args[])
       {
           // lambda expression to implement above
           // functional interface. This interface
           // by default implements abstractFun()
           FuncInterface fobj = (int x)->System.out.println(2*x);

           // This calls above lambda expression and prints 10.
           fobj.abstractFun(5);
       }
   }

   Output:
10

  +-----------------------------------------------------------------------------------------------+
  |                                                                                               |
  |  (int arg1, String arg2)    ->    {System.out.println("Two arguments "+arg1+" and "+arg2);}   |
  |  \_____________________/   \___/  \_______________________________________________________/   |
  |             |                |                               |                                |
  |         Argument           Arrow                  Body of lambda expression                   |
  |         list               token                                                              |
  |                                                                                               |
  +-----------------------------------------------------------------------------------------------+

   Syntax:
 lambda operator -> body

   where lambda operator can be:
     * Zero parameter:
() -> System.out.println("Zero parameter lambda");
     * One parameter:-
(p) -> System.out.println("One parameter: " + p);
       It is not mandatory to use parentheses, if the type of that variable can be inferred from the
       context
     * Multiple parameters :
(p1, p2) -> System.out.println("Multiple parameters: " + p1 + ", " + p2);

   Please note: Lambda expressions are just like functions and they accept parameters just like
   functions.

   // A Java program to demonstrate simple lambda expressions
   import java.util.ArrayList;
   class Test
   {
       public static void main(String args[])
       {
           // Creating an ArrayList with elements
           // {1, 2, 3, 4}
           ArrayList<Integer> arrL = new ArrayList<Integer>();
           arrL.add(1);
           arrL.add(2);
           arrL.add(3);
           arrL.add(4);

           // Using lambda expression to print all elements
           // of arrL
           arrL.forEach(n -> System.out.println(n));

           // Using lambda expression to print even elements
           // of arrL
           arrL.forEach(n -> { if (n%2 == 0) System.out.println(n); });
       }
   }

   Output :
1
2
3
4
2
4

   Note that lambda expressions can only be used to implement functional interfaces. In the above
   example also, the lambda expression implements Consumer Functional Interface.

   A Java program to demonstrate working of lambda expression with two arguments.

   // Java program to demonstrate working of lambda expressions
   public class Test
   {
       // operation is implemented using lambda expressions
       interface FuncInter1
       {
           int operation(int a, int b);
       }

       // sayMessage() is implemented using lambda expressions
       // above
       interface FuncInter2
       {
           void sayMessage(String message);
       }

       // Performs FuncInter1's operation on 'a' and 'b'
       private int operate(int a, int b, FuncInter1 fobj)
       {
           return fobj.operation(a, b);
       }

       public static void main(String args[])
       {
           // lambda expression for addition for two parameters
           // data type for x and y is optional.
           // This expression implements 'FuncInter1' interface
           FuncInter1 add = (int x, int y) -> x + y;

           // lambda expression multiplication for two parameters
           // This expression also implements 'FuncInter1' interface
           FuncInter1 multiply = (int x, int y) -> x * y;

           // Creating an object of Test to call operate using
           // different implementations using lambda Expressions
           Test tobj = new Test();

           // Add two numbers using lambda expression
           System.out.println("Addition is " +
                             tobj.operate(6, 3, add));

           // Multiply two numbers using lambda expression
           System.out.println("Multiplication is " +
                             tobj.operate(6, 3, multiply));

           // lambda expression for single parameter
           // This expression implements 'FuncInter2' interface
           FuncInter2 fobj = message ->System.out.println("Hello "
                                                    + message);
           fobj.sayMessage("Geek");
       }
   }

   Output:
Addition is 9
Multiplication is 18
Hello Geek

   Important points:
     * The body of a lambda expression can contain zero, one or more statements.
     * When there is a single statement curly brackets are not mandatory and the return type of the
       anonymous function is the same as that of the body expression.
     * When there are more than one statements, then these must be enclosed in curly brackets (a code
       block) and the return type of the anonymous function is the same as the type of the value
       returned within the code block, or void if nothing is returned.


---
https://www.baeldung.com/java-8-lambda-expressions-tips

Lambda Expressions and Functional Interfaces: Tips and Best Practices
February 12, 2020

1. Overview
   Now that Java 8 has reached wide usage, patterns, and best practices have begun to emerge for some of
   its headlining features. In this tutorial, we will take a closer look to functional interfaces and
   lambda expressions.

2. Prefer Standard Functional Interfaces
   Functional interfaces, which are gathered in the java.util.function package, satisfy most
   developers' needs in providing target types for lambda expressions and method references. Each of
   these interfaces is general and abstract, making them easy to adapt to almost any lambda expression.
   Developers should explore this package before creating new functional interfaces.

   Consider an interface Foo:
@FunctionalInterface
public interface Foo {
    String method(String string);
}

   and a method add() in some class UseFoo, which takes this interface as a parameter:
public String add(String string, Foo foo) {
    return foo.method(string);
}

   To execute it, you would write:
Foo foo = parameter -> parameter + " from lambda";
String result = useFoo.add("Message ", foo);

   Look closer and you will see that Foo is nothing more than a function that accepts one argument and
   produces a result. Java 8 already provides such an interface in Function<T,R> from the
   java.util.function package.

   Now we can remove interface Foo completely and change our code to:
public String add(String string, Function<String, String> fn) {
    return fn.apply(string);
}

   To execute this, we can write:
Function<String, String> fn =
  parameter -> parameter + " from lambda";
String result = useFoo.add("Message ", fn);

3. Use the @FunctionalInterface Annotation
   Annotate your functional interfaces with @FunctionalInterface. At first, this annotation seems to
   be useless. Even without it, your interface will be treated as functional as long as it has just one
   abstract method.

   But imagine a big project with several interfaces - it's hard to control everything manually. An
   interface, which was designed to be functional, could accidentally be changed by adding of other
   abstract method/methods, rendering it unusable as a functional interface.

   But using the @FunctionalInterface annotation, the compiler will trigger an error in response to any
   attempt to break the predefined structure of a functional interface. It is also a very handy tool to
   make your application architecture easier to understand for other developers.

   So, use this:

@FunctionalInterface
public interface Foo {
    String method();
}

   instead of just:
public interface Foo {
    String method();
}

4. Don't Overuse Default Methods in Functional Interfaces
   You can easily add default methods to the functional interface. This is acceptable to the functional
   interface contract as long as there is only one abstract method declaration:
@FunctionalInterface
public interface Foo {
    String method();
    default void defaultMethod() {}
}

   Functional interfaces can be extended by other functional interfaces if their abstract methods have
   the same signature. For example:
@FunctionalInterface
public interface FooExtended extends Baz, Bar {}

@FunctionalInterface
public interface Baz {
    String method();
    default void defaultBaz() {}
}

@FunctionalInterface
public interface Bar {
    String method();
    default void defaultBar() {}
}

   Just as with regular interfaces, extending different functional interfaces with the same default
   method can be problematic. For example, assume that interfaces Bar and Baz both have a default method
   defaultCommon(). In this case, you will get a compile-time error:
interface Foo inherits unrelated defaults for defaultCommon() from types Baz and Bar...

   To fix this, defaultCommon() method should be overridden in the Foo interface. You can, of course,
   provide a custom implementation of this method. But if you want to use one of the parent interfaces'
   implementations (for example, from the Baz interface), add following line of code to the
   defaultCommon() method's body:
Baz.super.defaultCommon();

   But be careful. Adding too many default methods to the interface is not a very good architectural
   decision. It is should be viewed as a compromise, only to be used when required, for upgrading
   existing interfaces without breaking backward compatibility.

5. Instantiate Functional Interfaces With Lambda Expressions
   The compiler will allow you to use an inner class to instantiate a functional interface. However,
   this can lead to very verbose code. You should prefer lambda expressions:
Foo foo = parameter -> parameter + " from Foo";

   over an inner class:
Foo fooByIC = new Foo() {
    @Override
    public String method(String string) {
        return string + " from Foo";
    }
};

   The lambda expression approach can be used for any suitable interface from old libraries. It is
   usable for interfaces like Runnable, Comparator, and so on. However, this doesn't mean that you
   should review your whole older codebase and change everything.

6. Avoid Overloading Methods With Functional Interfaces as Parameters

   Use methods with different names to avoid collisions; let's look at an example:
public interface Processor {
    String process(Callable<String> c) throws Exception;
    String process(Supplier<String> s);
}

public class ProcessorImpl implements Processor {
    @Override
    public String process(Callable<String> c) throws Exception {
        // implementation details
    }

    @Override
    public String process(Supplier<String> s) {
        // implementation details
    }
}

   At first glance, this seems reasonable. But any attempt to execute either of the ProcessorImpl's
   methods:

String result = processor.process(() -> "abc");

   ends with an error with the following message:
reference to process is ambiguous
both method process(java.util.concurrent.Callable<java.lang.String>)
in com.baeldung.java8.lambda.tips.ProcessorImpl
and method process(java.util.function.Supplier<java.lang.String>)
in com.baeldung.java8.lambda.tips.ProcessorImpl match

   To solve this problem, we have two options. The first is to use methods with different names:
String processWithCallable(Callable<String> c) throws Exception;

String processWithSupplier(Supplier<String> s);

   The second is to perform casting manually. This is not preferred.
String result = processor.process((Supplier<String>) () -> "abc");

7. Don't Treat Lambda Expressions as Inner Classes
   Despite our previous example, where we essentially substituted inner class by a lambda expression,
   the two concepts are different in an important way: scope.

   When you use an inner class, it creates a new scope. You can hide local variables from the enclosing
   scope by instantiating new local variables with the same names. You can also use the keyword this
   inside your inner class as a reference to its instance.

   However, lambda expressions work with enclosing scope. You can't hide variables from the enclosing
   scope inside the lambda's body. In this case, the keyword this is a reference to an enclosing
   instance.

   For example, in the class UseFoo you have an instance variable value:
private String value = "Enclosing scope value";

   Then in some method of this class place the following code and execute this method.
public String scopeExperiment() {
    Foo fooIC = new Foo() {
        String value = "Inner class value";

        @Override
        public String method(String string) {
            return this.value;
        }
    };
    String resultIC = fooIC.method("");

    Foo fooLambda = parameter -> {
        String value = "Lambda value";
        return this.value;
    };
    String resultLambda = fooLambda.method("");

    return "Results: resultIC = " + resultIC +
      ", resultLambda = " + resultLambda;
}

   If you execute the scopeExperiment() method, you will get the following result: Results: resultIC =
   Inner class value, resultLambda = Enclosing scope value

   As you can see, by calling this.value in IC, you can access a local variable from its instance. But
   in the case of the lambda, this.value call gives you access to the variable value which is defined in
   the UseFoo class, but not to the variable value defined inside the lambda's body.

8. Keep Lambda Expressions Short and Self-explanatory
   If possible, use one line constructions instead of a large block of code. Remember lambdas should be
   an expression, not a narrative. Despite its concise syntax, lambdas should precisely express the
   functionality they provide.

   This is mainly stylistic advice, as performance will not change drastically. In general, however, it
   is much easier to understand and to work with such code.

   This can be achieved in many ways - let's have a closer look.

  8.1. Avoid Blocks of Code in Lambda's Body
   In an ideal situation, lambdas should be written in one line of code. With this approach, the lambda
   is a self-explanatory construction, which declares what action should be executed with what data (in
   the case of lambdas with parameters).

   If you have a large block of code, the lambda's functionality is not immediately clear.

   With this in mind, do the following:
Foo foo = parameter -> buildString(parameter);
private String buildString(String parameter) {
    String result = "Something " + parameter;
    //many lines of code
    return result;
}

   instead of:
Foo foo = parameter -> { String result = "Something " + parameter;
    //many lines of code
    return result;
};

   However, please don't use this "one-line lambda" rule as dogma. If you have two or three lines in
   lambda's definition, it may not be valuable to extract that code into another method.

  8.2. Avoid Specifying Parameter Types
   A compiler in most cases is able to resolve the type of lambda parameters with the help of type
   inference. Therefore, adding a type to the parameters is optional and can be omitted.

   Do this:
(a, b) -> a.toLowerCase() + b.toLowerCase();

   instead of this:
(String a, String b) -> a.toLowerCase() + b.toLowerCase();

  8.3. Avoid Parentheses Around a Single Parameter
   Lambda syntax requires parentheses only around more than one parameter or when there is no parameter
   at all. That is why it is safe to make your code a little bit shorter and to exclude parentheses when
   there is only one parameter.

   So, do this:
a -> a.toLowerCase();

   instead of this:
(a) -> a.toLowerCase();

  8.4. Avoid Return Statement and Braces
   Braces and return statements are optional in one-line lambda bodies. This means, that they can be
   omitted for clarity and conciseness.

   Do this:
a -> a.toLowerCase();

   instead of this:
a -> {return a.toLowerCase()};

  8.5. Use Method References
   Very often, even in our previous examples, lambda expressions just call methods which are already
   implemented elsewhere. In this situation, it is very useful to use another Java 8 feature: method
   references.

   So, the lambda expression:
a -> a.toLowerCase();

   could be substituted by:
String::toLowerCase;

   This is not always shorter, but it makes the code more readable.

9. Use "Effectively Final" Variables
   Accessing a non-final variable inside lambda expressions will cause the compile-time error. But it
   doesn't mean that you should mark every target variable as final.

   According to the "effectively final" concept, a compiler treats every variable as final, as long
   as it is assigned only once.

   It is safe to use such variables inside lambdas because the compiler will control their state and
   trigger a compile-time error immediately after any attempt to change them.

   For example, the following code will not compile:
public void method() {
    String localVariable = "Local";
    Foo foo = parameter -> {
        String localVariable = parameter;
        return localVariable;
    };
}

   The compiler will inform you that:
Variable 'localVariable' is already defined in the scope.

   This approach should simplify the process of making lambda execution thread-safe.

10. Protect Object Variables from Mutation
   One of the main purposes of lambdas is use in parallel computing - which means that they're really
   helpful when it comes to thread-safety.

   The "effectively final" paradigm helps a lot here, but not in every case. Lambdas can't change a
   value of an object from enclosing scope. But in the case of mutable object variables, a state could
   be changed inside lambda expressions.

   Consider the following code:
int[] total = new int[1];
Runnable r = () -> total[0]++;
r.run();

   This code is legal, as total variable remains "effectively final". But will the object it references
   to have the same state after execution of the lambda? No!

   Keep this example as a reminder to avoid code that can cause unexpected mutations.

11. Conclusion
   In this tutorial, we saw some best practices and pitfalls in Java 8's lambda expressions and
   functional interfaces. Despite the utility and power of these new features, they are just tools.
   Every developer should pay attention while using them.


---
https://www.javatpoint.com/java-lambda-expressions

Java Lambda Expressions

   Lambda expression is a new and important feature of Java which was included in Java SE 8. It provides
   a clear and concise way to represent one method interface using an expression. It is very useful in
   collection library. It helps to iterate, filter and extract data from collection.

   The Lambda expression is used to provide the implementation of an interface which has functional
   interface. It saves a lot of code. In case of lambda expression, we don't need to define the method
   again for providing the implementation. Here, we just write the implementation code.

   Java lambda expression is treated as a function, so compiler does not create .class file.

Functional Interface
   Lambda expression provides implementation of functional interface. An interface which has only one
   abstract method is called functional interface. Java provides an anotation @FunctionalInterface,
   which is used to declare an interface as functional interface.

Why use Lambda Expression
    1. To provide the implementation of Functional interface.
    2. Less coding.

Java Lambda Expression Syntax

   Java lambda expression is consisted of three components.

   1) Argument-list: It can be empty or non-empty as well.
   2) Arrow-token: It is used to link arguments-list and body of expression.
   3) Body: It contains expressions and statements for lambda expression.

   No Parameter Syntax
() -> {  
    //Body of no parameter lambda  
}
    
   One Parameter Syntax
(p1) -> {  
    //Body of single parameter lambda  
} 

   Two Parameter Syntax
(p1,p2) -> {  
    //Body of multiple parameter lambda  
} 


   Let's see a scenario where we are not implementing Java lambda expression. Here, we are implementing
   an interface without using lambda expression.

Without Lambda Expression
interface Drawable{  
    public void draw();  
}  
public class LambdaExpressionExample {  
    public static void main(String[] args) {  
        int width=10;  
  
        //without lambda, Drawable implementation using anonymous class  
        Drawable d=new Drawable(){  
            public void draw(){System.out.println("Drawing "+width);}  
        };  
        d.draw();  
    }  
}

   Output:
Drawing 10

Java Lambda Expression Example
   Now, we are going to implement the above example with the help of Java lambda expression.

@FunctionalInterface  //It is optional  
interface Drawable{  
    public void draw();  
}  
  
public class LambdaExpressionExample2 {  
    public static void main(String[] args) {  
        int width=10;  
          
        //with lambda  
        Drawable d2=()->{  
            System.out.println("Drawing "+width);  
        };  
        d2.draw();  
    }  
}

   Output:
Drawing 10

   A lambda expression can have zero or any number of arguments. Let's see the examples:

Java Lambda Expression Example: No Parameter

interface Sayable{  
    public String say();  
}  
public class LambdaExpressionExample3{  
public static void main(String[] args) {  
    Sayable s=()->{  
        return "I have nothing to say.";  
    };  
    System.out.println(s.say());  
}  
}

   Output:
I have nothing to say.

Java Lambda Expression Example: Single Parameter

interface Sayable{  
    public String say(String name);  
}  
  
public class LambdaExpressionExample4{  
    public static void main(String[] args) {  
      
        // Lambda expression with single parameter.  
        Sayable s1=(name)->{  
            return "Hello, "+name;  
        };  
        System.out.println(s1.say("Sonoo"));  
          
        // You can omit function parentheses    
        Sayable s2= name ->{  
            return "Hello, "+name;  
        };  
        System.out.println(s2.say("Sonoo"));  
    }  
} 

   Output:
Hello, Sonoo
Hello, Sonoo

Java Lambda Expression Example: Multiple Parameters

interface Addable{  
    int add(int a,int b);  
}  
  
public class LambdaExpressionExample5{  
    public static void main(String[] args) {  
          
        // Multiple parameters in lambda expression  
        Addable ad1=(a,b)->(a+b);  
        System.out.println(ad1.add(10,20));  
          
        // Multiple parameters with data type in lambda expression  
        Addable ad2=(int a,int b)->(a+b);  
        System.out.println(ad2.add(100,200));  
    }  
}

   Output:
30
300

Java Lambda Expression Example: with or without return keyword

   In Java lambda expression, if there is only one statement, you may or may not use return keyword. You
   must use return keyword when lambda expression contains multiple statements.

interface Addable{  
    int add(int a,int b);  
}  
  
public class LambdaExpressionExample6 {  
    public static void main(String[] args) {  
          
        // Lambda expression without return keyword.  
        Addable ad1=(a,b)->(a+b);  
        System.out.println(ad1.add(10,20));  
          
        // Lambda expression with return keyword.    
        Addable ad2=(int a,int b)->{  
                            return (a+b);   
                            };  
        System.out.println(ad2.add(100,200));  
    }  
}

   Output:
30
300

Java Lambda Expression Example: Foreach Loop

import java.util.*;  
public class LambdaExpressionExample7{  
    public static void main(String[] args) {  
          
        List<String> list=new ArrayList<String>();  
        list.add("ankit");  
        list.add("mayank");  
        list.add("irfan");  
        list.add("jai");  
          
        list.forEach(  
            (n)->System.out.println(n)  
        );  
    }  
} 

   Output:
ankit
mayank
irfan
jai

Java Lambda Expression Example: Multiple Statements

    @FunctionalInterface  
    interface Sayable{  
        String say(String message);  
    }  
      
    public class LambdaExpressionExample8{  
        public static void main(String[] args) {  
          
            // You can pass multiple statements in lambda expression  
            Sayable person = (message)-> {  
                String str1 = "I would like to say, ";  
                String str2 = str1 + message;   
                return str2;  
            };  
                System.out.println(person.say("time is precious."));  
        }  
    }  

   Output:
I would like to say, time is precious.

Java Lambda Expression Example: Creating Thread

   You can use lambda expression to run thread. In the following example, we are implementing run method
   by using lambda expression.

    public class LambdaExpressionExample9{  
        public static void main(String[] args) {  
          
            //Thread Example without lambda  
            Runnable r1=new Runnable(){  
                public void run(){  
                    System.out.println("Thread1 is running...");  
                }  
            };  
            Thread t1=new Thread(r1);  
            t1.start();  
            //Thread Example with lambda  
            Runnable r2=()->{  
                    System.out.println("Thread2 is running...");  
            };  
            Thread t2=new Thread(r2);  
            t2.start();  
        }  
    }  

   Output:
Thread1 is running...
Thread2 is running...

   Java lambda expression can be used in the collection framework. It provides efficient and concise way
   to iterate, filter and fetch data. Following are some lambda and collection examples provided.

Java Lambda Expression Example: Comparator


import java.util.ArrayList;  
import java.util.Collections;  
import java.util.List;  
class Product{  
    int id;  
    String name;  
    float price;  
    public Product(int id, String name, float price) {  
        super();  
        this.id = id;  
        this.name = name;  
        this.price = price;  
    }  
}  
public class LambdaExpressionExample10{  
    public static void main(String[] args) {  
        List<Product> list=new ArrayList<Product>();  
          
        //Adding Products  
        list.add(new Product(1,"HP Laptop",25000f));  
        list.add(new Product(3,"Keyboard",300f));  
        list.add(new Product(2,"Dell Mouse",150f));  
          
        System.out.println("Sorting on the basis of name...");  
  
        // implementing lambda expression  
        Collections.sort(list,(p1,p2)->{  
        return p1.name.compareTo(p2.name);  
        });  
        for(Product p:list){  
            System.out.println(p.id+" "+p.name+" "+p.price);  
        }  
  
    }  
}  

   Output:
Sorting on the basis of name...
2 Dell Mouse 150.0
1 HP Laptop 25000.0
3 Keyboard 300.0

Java Lambda Expression Example: Filter Collection Data


import java.util.ArrayList;  
import java.util.List;  
import java.util.stream.Stream;   
class Product{  
    int id;  
    String name;  
    float price;  
    public Product(int id, String name, float price) {  
        super();  
        this.id = id;  
        this.name = name;  
        this.price = price;  
    }  
}  
public class LambdaExpressionExample11{  
    public static void main(String[] args) {  
        List<Product> list=new ArrayList<Product>();  
        list.add(new Product(1,"Samsung A5",17000f));  
        list.add(new Product(3,"Iphone 6S",65000f));  
        list.add(new Product(2,"Sony Xperia",25000f));  
        list.add(new Product(4,"Nokia Lumia",15000f));  
        list.add(new Product(5,"Redmi4 ",26000f));  
        list.add(new Product(6,"Lenevo Vibe",19000f));  
          
        // using lambda to filter data  
        Stream<Product> filtered_data = list.stream().filter(p -> p.price > 20000);  
          
        // using lambda to iterate through collection  
        filtered_data.forEach(  
                product -> System.out.println(product.name+": "+product.price)  
        );  
    }  
}  

   Output:
Iphone 6S: 65000.0
Sony Xperia: 25000.0
Redmi4 : 26000.0

Java Lambda Expression Example: Event Listener

import javax.swing.JButton;  
import javax.swing.JFrame;  
import javax.swing.JTextField;  
public class LambdaEventListenerExample {  
    public static void main(String[] args) {  
        JTextField tf=new JTextField();  
        tf.setBounds(50, 50,150,20);  
        JButton b=new JButton("click");  
        b.setBounds(80,100,70,30);  
          
        // lambda expression implementing here.  
        b.addActionListener(e-> {tf.setText("hello swing");});  
          
        JFrame f=new JFrame();  
        f.add(tf);f.add(b);  
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  
        f.setLayout(null);  
        f.setSize(300, 200);  
        f.setVisible(true);  
  
    }  
  
}

   Output:
   MESSAGE BOX with "hello swing text field and "click" button.


---
https://beginnersbook.com/2017/10/java-lambda-expressions-tutorial-with-examples/

Java Lambda Expressions Tutorial with examples

   Lambda expression is a new feature which is introduced in Java 8. A lambda expression is an anonymous
   function. A function that doesn't have a name and doesn't belong to any class. The concept of lambda
   expression was first introduced in LISP programming language.

Java Lambda Expression Syntax
   To create a lambda expression, we specify input parameters (if there are any) on the left side of the
   lambda operator ->, and place the expression or block of statements on the right side of lambda
   operator. For example, the lambda expression (x, y) -> x + y specifies that lambda expression takes
   two arguments x and y and returns the sum of these.
//Syntax of lambda expression
(parameter_list) -> {function_body}

Lambda expression vs method in Java
   A method (or function) in Java has these main parts:
   1. Name
   2. Parameter list
   3. Body
   4. return type.

   A lambda expression in Java has these main parts:
   Lambda expression only has body and parameter list.
   1. No name - function is anonymous so we don't care about the name
   2. Parameter list
   3. Body - This is the main part of the function.
   4. No return type - The java 8 compiler is able to infer the return type by checking the code. you
   need not to mention it explicitly.

Where to use the Lambdas in Java
   To use lambda expression, you need to either create your own functional interface or use the pre
   defined functional interface provided by Java. An interface with only single abstract method is
   called functional interface(or Single Abstract method interface), for example: Runnable, callable,
   ActionListener etc.

   To use function interface:
   Pre Java 8: We create anonymous inner classes.
   Post Java 8: You can use lambda expression instead of anonymous inner classes.

Java Lambda expression Example
   Without using Lambda expression: Prior to java 8 we used the anonymous inner classe to implement the
   only abstract method of functional interface.
import java.awt.*;
import java.awt.event.*;
public class ButtonListenerOldWay {
    public static void main(String[] args) {
       Frame frame=new Frame("ActionListener Before Java8");

       Button b=new Button("Click Here");
       b.setBounds(50,100,80,50);

       b.addActionListener(new ActionListener(){
          public void actionPerformed(ActionEvent e){
             System.out.println("Hello World!");
          }
       });
       frame.add(b);

       frame.setSize(200,200);
       frame.setLayout(null);
       frame.setVisible(true);
    }
}

   By using Lambda expression: Instead of creating anonymous inner class, we can create a lambda
   expression like this:
import java.awt.*;
public class ButtonListenerNewWay {
   public static void main(String[] args) {
      Frame frame=new Frame("ActionListener java8");

      Button b=new Button("Click Here");
      b.setBounds(50,100,80,50);

      b.addActionListener(e -> System.out.println("Hello World!"));
      frame.add(b);

      frame.setSize(200,200);
      frame.setLayout(null);
      frame.setVisible(true);
   }
}

   Note:
   1. As you can see that we used less code with lambda expression.
   2. Backward compatibility: You can use the lambda expression with your old code. Lambdas are backward
   compatible so you can use them in existing API when you migrate your project to java 8.

   Lets see few more examples of Lambda expressions.

Example 1: Java Lambda Expression with no parameter
@FunctionalInterface
interface MyFunctionalInterface {

        //A method with no parameter
    public String sayHello();
}
public class Example {

   public static void main(String args[]) {
        // lambda expression
        MyFunctionalInterface msg = () -> {
                return "Hello";
        };
        System.out.println(msg.sayHello());
    }
}

   Output:
Hello

Example 2: Java Lambda Expression with single parameter

@FunctionalInterface
interface MyFunctionalInterface {

        //A method with single parameter
    public int incrementByFive(int a);
}
public class Example {

   public static void main(String args[]) {
        // lambda expression with single parameter num
        MyFunctionalInterface f = (num) -> num+5;
        System.out.println(f.incrementByFive(22));
    }
}

   Output:
27

Example 3: Java Lambda Expression with Multiple Parameters
interface StringConcat {

    public String sconcat(String a, String b);
}
public class Example {

   public static void main(String args[]) {
        // lambda expression with multiple arguments
        StringConcat s = (str1, str2) -> str1 + str2;
        System.out.println("Result: "+s.sconcat("Hello ", "World"));
    }
}

   Output:
Result: Hello World

Example 4: Iterating collections using foreach loop
import java.util.*;
public class Example{
    public static void main(String[] args) {
       List<String> list=new ArrayList<String>();
       list.add("Rick");
       list.add("Negan");
       list.add("Daryl");
       list.add("Glenn");
       list.add("Carl");
       list.forEach(
           // lambda expression
           (names)->System.out.println(names)
       );
    }
}

   We can iterate Maps and other collection classes using lambda expression, refer this guide:
   [**1]Iterating Map and List using lambda expression

---
[**1]
https://beginnersbook.com/2017/01/lambda-expression-iterating-map-and-list-in-java-8/

Lambda Expression  Iterating Map and List in Java 8

I have already covered normal way of iterating Map and list in Java. In this tutorial, we will see how to
iterate (loop) Map and List in Java 8 using Lambda expression.

Iterating Map in Java 8 using Lambda expression

package com.beginnersbook;
import java.util.HashMap;
import java.util.Map;
public class IterateMapUsingLambda {
    public static void main(String[] args) {
        Map<String, Integer> prices = new HashMap<>();
        prices.put("Apple", 50);
        prices.put("Orange", 20);
        prices.put("Banana", 10);
        prices.put("Grapes", 40);
        prices.put("Papaya", 50);
        
        /* Iterate without using Lambda
           for (Map.Entry<String, Integer> entry : prices.entrySet()) {
           System.out.println("Fruit: " + entry.getKey() + ", Price: " + entry.getValue());
           }
        */ 
        
        prices.forEach((k,v)->System.out.println("Fruit: " + k + ", Price: " + v));

    }
}

Output:

Fruit: Apple, Price: 50
Fruit: Grapes, Price: 40
Fruit: Papaya, Price: 50
Fruit: Orange, Price: 20
Fruit: Banana, Price: 10

Iterating List in Java 8 using Lambda expression

package com.beginnersbook;
import java.util.List;
import java.util.ArrayList;
public class IterateListUsingLambda {
    public static void main(String[] argv) {
        List names = new ArrayList<>();
        names.add("Ajay");
        names.add("Ben");
        names.add("Cathy");
        names.add("Dinesh");
        names.add("Tom");
        
        /* Iterate without using Lambda
         Iterator iterator = names.iterator();
         while (iterator.hasNext()) {
            System.out.println(iterator.next());
         } 
        */ 
        names.forEach(name->System.out.println(name));
    }
}

Output:

Ajay
Ben
Cathy
Dinesh
Tom


---
https://www.freecodecamp.org/news/learn-these-4-things-and-working-with-lambda-expressions-b0ab36e0fffc/

How to start working with Lambda Expressions in Java
23 December 2017

   Before Lambda expressions support was added by JDK 8, I'd only used examples of them in languages
   like C# and C++.

   Once this feature was added to Java, I started looking into them a bit closer.

   The addition of lambda expressions adds syntax elements that increase the expressive power of Java.
   In this article, I want to focus on foundational concepts you need to get familiar with so you can
   start adding lambda expressions to your code today.

Quick Introduction
   Lambda expressions take advantage of parallel process capabilities of multi-core environments as seen
   with the support of pipeline operations on data in the Stream API.

   They are anonymous methods (methods without names) used to implement a method defined by a functional
   interface. It's important to know what a functional interface is before getting your hands dirty with
   lambda expressions.

Functional interface
   A functional interface is an interface that contains one and only one abstract method.

   If you take a look at the definition of the Java standard Runnable interface, you will notice how
   it falls into the definition of functional interface because it only defines one method: run().

   In the code sample below, the method computeName is implicitly abstract and is the only method
   defined, making MyName a functional interface.
interface MyName{
  String computeName(String str);
}

   Functional Interface
The Arrow Operator

   Lambda expressions introduce the new arrow operator -> into Java. It divides the lambda expressions
   in two parts:
(n) -> n*n

   The left side specifies the parameters required by the expression, which could also be empty if no
   parameters are required.

   The right side is the lambda body which specifies the actions of the lambda expression. It might be
   helpful to think about this operator as "becomes". For example, "n becomes n*n", or "n becomes n
   squared".

   With functional interface and arrow operator concepts in mind, you can put together a simple lambda
   expression:
interface NumericTest {
        boolean computeTest(int n);
}

public static void main(String args[]) {
        NumericTest isEven = (n) -> (n % 2) == 0;
        NumericTest isNegative = (n) -> (n < 0);

        // Output: false
        System.out.println(isEven.computeTest(5));

        // Output: true
        System.out.println(isNegative.computeTest(-5));
}

   Numeric Test
interface MyGreeting {
        String processName(String str);
}

public static void main(String args[]) {
        MyGreeting morningGreeting = (str) -> "Good Morning " + str + "!";
        MyGreeting eveningGreeting = (str) -> "Good Evening " + str + "!";

        // Output: Good Morning Luis!
        System.out.println(morningGreeting.processName("Luis"));

        // Output: Good Evening Jessica!
        System.out.println(eveningGreeting.processName("Jessica"));
}

   Greeting Lambda
   The variables morningGreeting and eveningGreeting, lines 6 and 7 in the sample above, make a
   reference to MyGreeting interface and define different greeting expressions.

   When writing a lambda expression, it is also possible to explicitly specify the type of the parameter
   in the expression like this:
MyGreeting morningGreeting = (String str) -> "Good Morning " + str + "!";
MyGreeting eveningGreeting = (String str) -> "Good Evening " + str + "!";

   Lambda with Type

Block Lambda Expressions
   So far, I have covered samples of single expression lambdas. There is another type of expression used
   when the code on the right side of the arrow operator contains more than one statement known as block
   lambdas:
interface MyString {
        String myStringFunction(String str);
}

public static void main (String args[]) {
        // Block lambda to reverse string
        MyString reverseStr = (str) -> {
                String result = "";

                for(int i = str.length()-1; i >= 0; i--)
                        result += str.charAt(i);

                return result;
        };

        // Output: omeD adbmaL
        System.out.println(reverseStr.myStringFunction("Lambda Demo"));
}

   Block Lambda

Generic Functional Interfaces
   A lambda expression cannot be generic. But the functional interface associated with a lambda
   expression can. It is possible to write one generic interface and handle different return types like
   this:
interface MyGeneric<T> {
        T compute(T t);
}

public static void main(String args[]){

        // String version of MyGenericInteface
        MyGeneric<String> reverse = (str) -> {
                String result = "";

                for(int i = str.length()-1; i >= 0; i--)
                        result += str.charAt(i);

                return result;
        };

        // Integer version of MyGeneric
        MyGeneric<Integer> factorial = (Integer n) -> {
                int result = 1;

                for(int i=1; i <= n; i++)
                        result = i * result;

                return result;
        };

        // Output: omeD adbmaL
        System.out.println(reverse.compute("Lambda Demo"));

        // Output: 120
        System.out.println(factorial.compute(5));

}

   Generic Functional Interface

Lambda Expressions as arguments
   One common use of lambdas is to pass them as arguments.

   They can be used in any piece of code that provides a target type. I find this exciting, as it lets
   me pass executable code as arguments to methods.

   To pass lambda expressions as parameters, just make sure the functional interface type is compatible
   with the required parameter.
interface MyString {
        String myStringFunction(String str);
}

public static String reverseStr(MyString reverse, String str){
  return reverse.myStringFunction(str);
}

public static void main (String args[]) {
        // Block lambda to reverse string
        MyString reverse = (str) -> {
                String result = "";

                for(int i = str.length()-1; i >= 0; i--)
                        result += str.charAt(i);

                return result;
        };

        // Output: omeD adbmaL
        System.out.println(reverseStr(reverse, "Lambda Demo"));
}

   Lambda Expression as an Argument
   These concepts will give you a good foundation to start working with lambda expressions. Take a look
   at your code and see where you can increase the expressive power of Java.


---
