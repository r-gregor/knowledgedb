filename: jv_design-patterns-in-java-multyf_20201017.txt
https://stackabuse.com/design-patterns-in-java/

Design Patterns in Java

What are Design Patterns?
   Design Patterns are simply sets of standardized practices used in the software development
   industry. They represent solutions, provided by the community, to common problems faced in
   every-day tasks regarding software development.

   There's a myriad of design patterns, and you're probably familiar with some of them
   already. Being familiar with them and knowing them by heart can help you increase the speed
   and quality of your development.

   By using already clearly defined approaches instead of reinventing the wheel, as well as
   well-known industry standards you both help your team and yourself produce high-quality
   applications that are easier to maintain and improve.

   Another important thing to mention is the uniformity and universality. Instead of
   explaining a common concept to someone else, you can simply tell them to utilize a certain
   pattern.

   Most of these patterns apply to multiple languages, not just Java, but some, like the J2EE
   Design Patterns are applicable mostly to Java, or rather Java EE.

   There are three main design pattern categories: Creational Patterns, Structural Patterns
   and Behavioral Patterns, but we'll also dive into J2EE Patterns.

   Creational Patterns, as the name implies, are most concerned about solutions and options
   revolving around instantiating objects, and how to do so more efficiently in the most
   varied of circumstances.

   Structural Patterns are concerned about providing solutions and efficient standards
   regarding class compositions and object structures. Also, they rely on the concept of
   inheritance and interfaces to allow multiple objects or classes to work together and form a
   single working whole.

   Behavioral Patterns are concerned about providing solutions regarding object interaction -
   how do they communicate, how are some dependent on others, and how to segregate them to be
   both dependent and independent and provide both flexibility and testing capabilities.

   J2EE Patterns are concerned about providing solutions regarding Java EE. These patterns are
   widely accepted by other frameworks and projects, like for an example Spring.

Design Patterns in Java
   In that name, we've compiled a list of all the Design Patterns you'll encounter or use as a
   software developer, implemented in Java.

Creational Patterns
     * Factory Method/Template
     * Abstract Factory
     * Builder
     * Prototype
     * Singleton

Structural Patterns
     * Adapter
     * Bridge
     * Filter
     * Composite
     * Decorator
     * Facade
     * Flyweight
     * Proxy

Behavioral Patterns
     * Interpreter
     * Template Method/Pattern
     * Chain of Responsibility
     * Command
     * Iterator
     * Mediator
     * Memento
     * Observer
     * State
     * Strategy
     * Visitor

J2EE Patterns
     * MVC Pattern
     * Business Delegate Pattern
     * Composite Entity Pattern
     * Data Access Object Pattern
     * Front Controller Pattern
     * Intercepting Filter Pattern
     * Service Locator Pattern
     * Transfer Object Pattern

---
https://stackabuse.com/creational-design-patterns-in-java/

Creational Design Patterns in Java

Overview
   This is the first article in a short series dedicated to Design Patterns in Java.

Creational Patterns
   The Creational Patterns in Java that are covered in this article are:
     * Factory Method/Template
     * Abstract Factory
     * Builder
     * Prototype
     * Singleton

Factory Method
   The Factory Method, also often called the Factory Pattern is a widely used design pattern
   that commands object creation.

   In this pattern, a Factory class is created as the parent class of all sub-classes
   belonging to a certain logical segment of related classes.

   Just like a SessionFactory is used to create, update, delete and manipulate all
   Session objects, so is any other factory responsible for their set of child classes.

   It's important to note that the sub-classes can't be reached without using their respective
   factory. This way, their creation is both hidden from the client and is dependent on the
   factory.

Implementation:
   Let's build a small, simple project to demonstrate this.

   We're going to define a few classes belonging to a logic segment, each of them implementing
   the same interface. Then we're going to create a factory for these objects.
public interface Animal {
    void eat();
}

   The interface only has one method for the convenience of presenting the point.

   Now, let's define a few classes that implement this interface, each in their own way:
 public class Dog implements Animal {
    @Override
    public void eat() {
        System.out.println("Dog is eating, woof!");
    }
}

public class Cat implements Animal {
    @Override
    public void eat() {
        System.out.println("Cat is eating, meow!");
    }
}

public class Rabbit implements Animal {
    @Override
    public void eat() {
        System.out.println("Rabbit is eating, squeak!");
    }
}

   Note: These classes are separate .java files, they're grouped together like this for
   readability.

   Now that we have a group of classes, we can designate a factory for them:
public class AnimalFactory {

    public Animal getAnimal(String animal) {
        if(animal.equals(null)) return null;

        if(animal.equalsIgnoreCase("Dog")) {
            return new Dog();
        } else if(animal.equalsIgnoreCase("Cat")) {
            return new Cat();
        } else if(animal.equalsIgnoreCase("Rabbit")) {
            return new Rabbit();
        }
        return null;
    }
}

   This way, we have a factory to instantiate our objects in a predefined way by the factory,
   without direct contact with the objects themselves.

   Now, let's observe the result.
public class Main {
    public static void main(String[] args) {
        AnimalFactory animalFactory = new AnimalFactory();

        Animal animal = animalFactory.getAnimal("dOg");
        animal.eat();

        Animal animal2 = animalFactory.getAnimal("CAT");
        animal2.eat();

        Animal animal3 = animalFactory.getAnimal("raBbIt");
        animal3.eat();
    }
}


   Running this piece of code will yield:
Dog is eating, woof!
Cat is eating, meow!
Rabbit is eating, squeak!

   If you'd like to read a standalone detailed article on The Factory Method Design
   Pattern[https://stackabuse.com/factory-method-design-pattern-in-java/], we've got you covered!

Abstract Factory
   The Abstract Factory design pattern builds upon the Factory Pattern and acts as the highest
   factory in the hierarchy. It represents the practice of creating a factory of factories.

   This pattern is responsible for creating all other factories as its sub-classes, exactly
   like how factories are responsible for creating all of their own sub-classes.

Implementation:
   The previous example can be used as a good base for this implementation.

   The Animal interface is renamed to the Pet interface and each implementation is changed:
public class Dog implements Pet {
    @Override
    public void eat() {
        System.out.println("Dog is eating, woof!");
    }
}

public class Cat implements Pet {
    @Override
    public void eat() {
        System.out.println("Cat is eating, meow!");
    }
}

public class Rabbit implements Pet {
    @Override
    public void eat() {
        System.out.println("Rabbit is eating, squeak!");
    }
}

   A new interface is defined:
public interface Human {
    public void feedPet();
}

   And as usual, a few concrete classes implement this interface:
public class Child implements Human {
    @Override
    public void feedPet() {
        System.out.println("Child is feeding pet irresponsibly.");
    }
}

public class Adult implements Human {
    @Override
    public void feedPet() {
        System.out.println("Adult is feeding pet responsibly.");
    }
}

public class Elder implements Human {
    @Override
    public void feedPet() {
        System.out.println("Elder is overfeeding the pet.");
    }
}

   At this point, we have the adequate classes to create an AbstractFactory as well as the
   respective Factory classes for these two groups: PetFactory and HumanFactory.

   The AbstractFactory's concern is the ability to provide these objects to the
   FactoryProducer, not to instantiate them:
public abstract class AbstractFactory {
    public abstract Pet getPet(String pet);
    public abstract Human getHuman(String human);
}

   Before we define the class that instantiates these objects using the AbstractFactory, we
   need to create our two factories.
public class HumanFactory extends AbstractFactory {

    @Override
    Human getHuman(String human) {
        if(human.equals(null)) return null;

        if(human.equalsIgnoreCase("chILd")) {
            return new Child();
        } else if(human.equalsIgnoreCase("adult")) {
            return new Adult();
        } else if(human.equalsIgnoreCase("elDeR")) {
            return new Elder();
        }
        return null;
    }

    @Override
    Pet getPet(String pet) {
        // don't implement
        return null;
    }

public class PetFactory extends AbstractFactory {

    @Override
    public Pet getPet(String pet) {
        if(pet.equals(null)) return null;

        if(pet.equalsIgnoreCase("Dog")) {
            return new Dog();
        } else if(pet.equalsIgnoreCase("Cat")) {
            return new Cat();
        } else if(pet.equalsIgnoreCase("Rabbit")) {
            return new Rabbit();
        }
        return null;
    }

    @Override
    Human getHuman(String human) {
        //don't implement
        return null;
    }
}

   And now, with these, we can create the FactoryProducer which is charged with the
   responsibility to instantiate the adequate factories, with the help of the AbstractFactory:
public class FactoryProducer {
    public static AbstractFactory getFactory(String factory) {
        if(factory.equalsIgnoreCase("Human")) {
            return new HumanFactory();
        } else if(factory.equalsIgnoreCase("Pet")) {
            return new PetFactory();
        }
        return null;
    }
}

   By passing a String, the FactoryProducer returns the AbstractFactory with their requested
   child factory.

   Now, let's observe the result:
public class Main {
    public static void main(String[] args) {

        AbstractFactory humanFactory = FactoryProducer.getFactory("Human");
        AbstractFactory petFactory = FactoryProducer.getFactory("Pet");

        Human human = humanFactory.getHuman("Child");
        human.feedPet();

        Pet pet = petFactory.getPet("Dog");
        pet.eat();

        Human human2 = humanFactory.getHuman("Elder");
        human2.feedPet();

        Pet pet2 = petFactory.getPet("Rabbit");
        pet2.eat();
    }
}

   By running this piece of code, we are greeted with:
Child is feeding pet irresponsibly.
Dog is eating, woof!
Elder is overfeeding the pet.
Rabbit is eating, squeak!

Builder
   The Builder pattern is used to help build final objects, for classes with a huge amount of
   fields or parameters in a step-by-step manner. It's not very useful in small, simple
   classes that don't have many fields, but complex objects are both hard to read and maintain
   by themselves.

   Initializing an object with more than a few fields using a constructor is messy and
   susceptible to human error.

Implementation:
   Let's define a class with a few fields:
public class Computer {
    private String computerCase;
    private String CPU;
    private String motherboard;
    private String GPU;
    private String HDD;
    private String operatingSystem;
    private int powerSupply;
    private int amountOfRAM;

    public Computer(String computerCase, String CPU, String motherboard, String GPU,
    String HDD, String operatingSystem, int powerSupply, int amountOfRAM) {
        this.computerCase = computerCase;
        this.CPU = CPU;
        this.motherboard = motherboard;
        this.GPU = GPU;
        this.HDD = HDD;
        this.operatingSystem = operatingSystem;
        this.powerSupply = powerSupply;
        this.amountOfRAM = amountOfRAM;
   }

    //getters and setters
}

   The problem is evident - Even a small, simple class like this requires a big and messy
   constructor.

   Classes can easily have considerably more fields than this, which gave birth to the Builder
   design pattern.

   To apply it, we'll nest a static Builder class within the Computer class.

   This builder will be used to build our objects in a clean and readable way, unlike the
   example above:
public class Computer {
    // The same fields should be in `Computer` and `Builder`
    // Private constructor means we can't instantiate it
    // by simply calling `new Computer()`
    private String computerCase;
    private String CPU;
    private String motherboard;
    private String GPU;
    private String HDD;
    private String operatingSystem;
    private int powerSupply;
    private int amountOfRAM;

    public static class Builder {
        private String computerCase;
        private String CPU;
        private String motherboard;
        private String GPU;
        private String HDD;
        private String operatingSystem;
        private int powerSupply;
        private int amountOfRAM;

    public Builder withCase(String computerCase) {
        this.computerCase = computerCase;
        return this;
        }

        public Builder withCPU(String CPU) {
            this.CPU = CPU;
            return this;
        }

        public Builder withMotherboard(String motherboard) {
            this.motherboard = motherboard;
            return this;
        }

        public Builder withGPU(String GPU) {
            this.GPU = GPU;
            return this;
        }

        public Builder withHDD(String HDD) {
            this.HDD = HDD;
            return this;
        }

        public Builder withOperatingSystem(String operatingSystem) {
            this.operatingSystem = operatingSystem;
            return this;
        }

        public Builder withPowerSupply(int powerSupply) {
            this.powerSupply = powerSupply;
            return this;
        }

        public Builder withAmountOfRam(int amountOfRAM) {
            this.amountOfRAM = amountOfRAM;
            return this;
        }

        public Computer build() {
            Computer computer = new Computer();
            computer.computerCase = this.computerCase;
            computer.CPU = this.CPU;
            computer.motherboard = this.motherboard;
            computer.GPU = this.GPU;
            computer.HDD = this.HDD;
            computer.operatingSystem = this.operatingSystem;
            computer.powerSupply = this.powerSupply;
            computer.amountOfRAM = this.amountOfRAM;

            return computer;
        }
   }

   private Computer() {
       //nothing here
   }

    //fields
    //getters and setters
}

   This nested class has the same fields as the Computer class and uses them to build the
   object itself.

   The Computer constructor is made private so that the only way to initialize it is via the
   Builder class.

   With the Builder all set-up, we can initialize Computer objects:
public class Main {
    public static void main(String[] args) {
        Computer computer = new Computer.Builder()
                .withCase("Tower")
                .withCPU("Intel i5")
                .withMotherboard("MSI B360M-MORTAR")
                .withGPU("nVidia Geforce GTX 750ti")
                .withHDD("Toshiba 1TB")
                .withOperatingSystem("Windows 10")
                .withPowerSupply(500)
                .withAmountOfRam(8)
                .build();
    }
}

   This is a much cleaner and more verbose way than writing:
public class Main {
    public static void main(String[] args) {
        Computer computer = new Computer("Tower", "Intel i5", "MSI B360M-MORTAR",
        "nVidia GeForce GTX 750ti, "Toshiba 1TB", "Windows 10", 500, 8);
    }
}

   If you'd like to read a standalone, detailed article on The Builder Design
   Pattern[https://stackabuse.com/the-builder-design-pattern-in-java/], we've got you covered!
   (also in: jv_builder-design-pattern_20201018.txt)

Prototype
   The Prototype pattern is used mainly to minimize the cost of object creation, usually when
   large-scale applications create, update or retrieve objects which cost a lot of resources.

   This is done by copying the object, once it's created, and reusing the copy of the object
   in later requests, to avoid performing another resource-heavy operation. It depends on the
   decision of the developer whether this will be a full or shallow copy of the object, though
   the goal is the same.

Implementation:
   Since this pattern clones objects, it would be fitting to define a class for them:
// to clone the object, the class needs to implement Cloneable
public abstract class Employee implements Cloneable {

    private String id;
    protected String position;
    private String name;
    private String address;
    private double wage;

    abstract void work();

    public Object clone() {
        Object clone = null;
        try {
            clone = super.clone();
        } catch(CloneNotSupportedException ex) {
            ex.printStackTrace();
        }
        return clone;
    }
   //getters and setters
}

   Now, as usual, let's define a few classes that extend Employee:
public class Programmer extends Employee {
    public Programmer() {
        position = "Senior";
    }
    @Override
    void work() {
        System.out.println("Writing code!");
    }
}

public class Janitor extends Employee {
    public Janitor() {
        position = "Part-time";
    }
    @Override
    void work() {
        System.out.println("Cleaning the hallway!");
    }
}

public class Manager extends Employee {
    public Manager() {
        position = "Intern";
    }
    @Override
    void work() {
        System.out.println("Writing a schedule for the project!");
    }
}

   At this point, we have everything we need for a class from a data layer to save, update and
   retrieve these employees for us.

   A Hashtable will be used to simulate a database, and predefined objects will simulate
   objects retrieved via queries:
public class EmployeesHashtable {

    private static Hashtable<String, Employee> employeeMap = new Hashtable<String, Employee>();

    public static Employee getEmployee(String id) {
        Employee cacheEmployee = employeeMap.get(id);
        // a cast is needed because the clone() method returns an Object
        return (Employee) cacheEmployee.clone();
    }

    public static void loadCache() {
        // predefined objects to simulate retrieved objects from the database
        Programmer programmer = new Programmer();
        programmer.setId("ETPN1");
        employeeMap.put(programmer.getId(), programmer);

        Janitor janitor = new Janitor();
        janitor.setId("ETJN1");
        employeeMap.put(janitor.getId(), janitor);

        Manager manager = new Manager();
        manager.setId("ETMN1");
        employeeMap.put(manager.getId(), manager);
    }
}

   To observe the result:
public class Main {
    public static void main(String[] args) {
        EmployeesHashtable.loadCache();

        Employee cloned1 = (Employee) EmployeesHashtable.getEmployee("ETPN1");
        Employee cloned2 = (Employee) EmployeesHashtable.getEmployee("ETJN1");
        Employee cloned3 = (Employee) EmployeesHashtable.getEmployee("ETMN1");

        System.out.println("Employee: " + cloned1.getPosition() + " ID:"
            + cloned1.getId());
        System.out.println("Employee: " + cloned2.getPosition() + " ID:"
            + cloned2.getId());
        System.out.println("Employee: " + cloned3.getPosition() + " ID:"
            + cloned3.getId());
    }
}

   Running this piece of code will yield:
Employee: Senior ID:ETPN1
Employee: Part-time ID:ETJN1
Employee: Intern ID:ETMN1

Singleton
   The Singleton pattern ensures the existence of only one object instance in the whole JVM.

   This is a rather simple pattern and it provides the ability to access this object even
   without instantiating it. Other design patterns use this pattern, like the Abstract
   Factory, Builder, and Prototype patterns we've already covered.

Implementation:
   This is a fairly simple implementation of a Singleton class:
public class SingletonClass {

    private static SingletonClass instance = new SingletonClass();

    private SingletonClass() {}

    public static SingletonClass getInstance() {
        return instance;
    }

    public void showMessage() {
        System.out.println("I'm a singleton object!");
    }
}


   This class is creating a static object of itself, which represents the global instance.

   By providing a private constructor, the class cannot be instantiated.

   A static method getInstance() is used as a global access point for the rest of the
   application.

   Any number of public methods can be added to this class, but there's no need to do so for
   this tutorial.

   With this, our class fulfills all requirements to become a Singleton.

   Let's define some code that retrieves this object and runs a method:
public class Main {
    public static void main(String[] args) {
        SingletonClass singletonClass = SingletonClass.getInstance();
        singletonClass.showMessage();
    }
}

   Running this code will result in:
I'm a singleton object!

Conclusion

   With this, all Creational Design Patterns in Java are fully covered, with working examples.

   If you'd like to continue reading about Design Patterns in Java, the following article
   covers Structural Design Patterns.


---
https://stackabuse.com/structural-design-patterns-in-java/

Structural Design Patterns in Java

Overview
   This is the second article in a short series dedicated to Design Patterns in Java, and a
   direct continuation from the previous article - Creational Design Patterns in Java.

Structural Patterns
   Structural Patterns are concerned about providing solutions and efficient standards
   regarding class compositions and object structures. Also, they rely on the concept of
   inheritance and interfaces to allow multiple objects or classes to work together and form a
   single working whole.

   The Structural Patterns in Java that are covered in this article are:
     * Adapter
     * Bridge
     * Filter
     * Composite
     * Decorator
     * Facade
     * Flyweight
     * Proxy

Adapter
   The Adapter pattern, as the name implies, adapts one interface to another. It acts as a
   bridge between two unrelated, and sometimes even completely incompatible interfaces,
   similar to how a scanner acts as a bridge between a paper and a computer.

   A computer can't store a paper as a PDF document, but a scanner, which combines the
   functionalities of both, can scan it and allow the computer to store it.

Implementation
   The Builder interface is our most general interface, and it provides a method that accepts
   a building type and its location:
public interface Builder {
    public void build(String type, String location);
}

   The AdvancedBuilder interface provides two methods, one to build a house, and one to build
   a skyscrapper:
public interface AdvancedBuilder {
    public void buildHouse(String location);
    public void buildSkyscrapper(String location);
}

   These two interfaces are unrelated. Yes, they share the theme, but they're unrelated as far
   as code is concerned.

   At this point, a concrete class implementing the AdvancedBuilder interface is created:
public class HouseBuilder implements AdvancedBuilder {
    @Override
    public void buildHouse(String location) {
        System.out.println("Building a house located in the " + location + "area!");
    }

    @Override
    public void buildSkyscrapper(String location) {
        //don't implement
    }
}

   And of course, by the same analogy, another concrete class is created:
public class SkyscrapperBuilder implements AdvancedBuilder {
    @Override
    public void buildSkyscrapper(String location) {
        System.out.println("Building a skyscrapper in the " + location + "area!");
    }

    @Override
    public void buildHouse(String location) {
        //don't implement
    }
}


   Here comes the adapter part - to connect these two interfaces, a BuilderAdapter
   implementing Builder is made:
public class BuilderAdapter implements Builder {
    AdvancedBuilder advancedBuilder;

    public BuilderAdapter(String type) {
        if(type.equalsIgnoreCase("House")) {
            advancedBuilder = new HouseBuilder();
        } else if(type.equalsIgnoreCase("Skyscrapper")) {
            advancedBuilder = new SkyscrapperBuilder();
        }
    }

    @Override
    public void build(String type, String location) {
        if(type.equalsIgnoreCase("House")) {
            advancedBuilder.buildHouse(location);
        } else if(type.equalsIgnoreCase("Skyscrapper")) {
            advancedBuilder.buildSkyscrapper(location);
        }
    }
}

   With the adapter working, we can finally implement the solution and use the Builder
   interface's method with the BuilderAdapter to build the supported building types.
public class BuilderImplementation implements Builder {
    BuilderAdapter builderAdapter;

    @Override
    public void build(String type, String location) {
        if(type.equalsIgnoreCase("House") || type.equalsIgnoreCase("Skyscrapper")) {
            builderAdapter = new BuilderAdapter(type);
            builderAdapter.build(type, location);
        } else {
            System.out.println("Invalid building type.");
        }
    }
}

   And to observe the result:
public class Main {
    public static void main(String[] args) {
        BuilderImplementation builderImpl = new BuilderImplementation();

        builderImpl.build("house", "Downtown");
        builderImpl.build("Skyscrapper", "City Center");
        builderImpl.build("Skyscrapper", "Outskirts");
        builderImpl.build("Hotel", "City Center");
    }
}

   Running the piece of code above will yield:
Building a house located in the Downtown area!
Building a skyscrapper in the City Center area!
Building a skyscrapper in the Outskirts area!
Invalid building type.

Bridge
   The Bridge pattern is used to segregate abstract classes from their implementations and act
   as a bridge between them. This way, both the abstract class and the implementation can
   change structurally without affecting the other.

   If this is by any means confusing, refer to the implementation to see its use.

Implementation
   As usual, an interface is the starting point:
public interface FeedingAPI {
    public void feed(int timesADay, int amount, String typeOfFood);
}

   After which, two concrete classes implement it:
public class BigDog implements FeedingAPI {
    @Override
    public void feed(int timesADay, int amount, String typeOfFood) {
        System.out.println("Feeding a big dog, " + timesADay + " times a day with " +
            amount + " g of " + typeOfFood);
    }
}

public class SmallDog implements FeedingAPI {
    @Override
    public void feed(int timesADay, int amount, String typeOfFood) {
        System.out.println("Feeding a small dog, " + timesADay + " times a day with " +
            amount + " g of " + typeOfFood);
    }
}


   Using the FeedingAPI interface, an abstract Animal class is created:
public abstract class Animal {
    protected FeedingAPI feedingAPI;

    protected Animal(FeedingAPI feedingAPI) {
        this.feedingAPI = feedingAPI;
    }
    public abstract void feed();
}

   This is where the Bridge pattern kicks in. A bridge class is created that segregates the
   abstract Animal class from its implementation:
public class Dog extends Animal{
    private int timesADay, amount;
    private String typeOfFood;

    public Dog(int timesADay, int amount, String typeOfFood, FeedingAPI feedingAPI) {
        super(feedingAPI);
        this.timesADay = timesADay;
        this.amount = amount;
        this.typeOfFood = typeOfFood;
    }

    public void feed() {
        feedingAPI.feed(timesADay, amount, typeOfFood);
    }
}

   And to observe the result:
public class Main {
    public static void main(String[] args) {
        Animal bigDog = new Dog(3, 500, "Meat", new BigDog());
        Animal smallDog = new Dog(2, 250, "Granules", new SmallDog());

        bigDog.feed();
        smallDog.feed();
    }
}

   Running this piece of code will yield:
Feeding a big dog, 3 times a day with 500 g of Meat
Feeding a small dog, 2 times a day with 250 g of Granules

Filter
   The Filter pattern is used when we need a way to filter through sets of objects with
   different custom criteria. We can chain criteria for an even narrower filter, which is done
   in a decoupled way.

Implementation
   Starting off with an Employee class which we will filter using different Criteria:
public class Employee {
    private String name;
    private String gender;
    private String position;

    public Employee(String name, String gender, String position) {
        this.name = name;
        this.gender = gender;
        this.position = position;
    }
    //getters
}

   The Criteria interface is fairly simple, and all other specific criteria will implement its
   method in their own way:
public interface Criteria {
    public List<Employee> criteria(List<Employee> employeeList);
}

   With the foundation of the filtering system in place, let's define a few different
   criteria:
     * CriteriaMale - A criteria to look for male employees
     * CriteriaFemale - A criteria to look for female employees
     * CriteriaSenior - A criteria to look for senior employees
     * CriteriaJunior - A criteria to look for junior employees
     * AndCriteria - A criteria to look for employees who pass both criteria we apply
     * OrCriteria - A criteria to look for employees who pass either of the criteria we apply

   CriteriaMale:
public class CriteriaMale implements Criteria {

    @Override
    public List<Employee> criteria(List<Employee> employeeList) {
        List<Employee> maleEmployees = new ArrayList<>();

        for(Employee employee : employeeList) {
            if(employee.getGender().equalsIgnoreCase("Male")) {
                maleEmployees.add(employee);
            }
        }
        return maleEmployees;
    }
}

   Simple for loop that adds all male employees to a list, and returns it.

   CriteriaFemale:
public class CriteriaFemale implements Criteria {

    @Override
    public List<Employee> criteria(List<Employee> employeeList) {
        List<Employee> femaleEmployees = new ArrayList<>();

        for(Employee employee : employeeList) {
            if(employee.getGender().equalsIgnoreCase("Female")) {
                femaleEmployees.add(employee);
            }
        }
        return femaleEmployees;
    }
}

   Same as above, but for female employees.

   CriteriaSenior:
public class CriteriaSenior implements Criteria{

    @Override
    public List<Employee> criteria(List<Employee> employeeList) {
         List<Employee> seniorEmployees = new ArrayList<>();

        for(Employee employee : employeeList) {
            if(employee.getPosition().equalsIgnoreCase("Senior")) {
                seniorEmployees.add(employee);
            }
        }
        return seniorEmployees;
    }
}

   Same as above, but checks the position of the employee, not the gender.

   CriteriaJunior:
public class CriteriaJunior implements Criteria {

    @Override
    public List<Employee> criteria(List<Employee> employeeList) {
                 List<Employee> juniorEmployees = new ArrayList<>();

        for(Employee employee : employeeList) {
            if(employee.getPosition().equalsIgnoreCase("Junior")) {
                juniorEmployees.add(employee);
            }
        }
        return juniorEmployees;
    }
}

   Same as above, but for Junior employees.

   AndCriteria:
public class AndCriteria implements Criteria {

    private Criteria firstCriteria;
    private Criteria secondCriteria;

    public AndCriteria(Criteria firstCriteria, Criteria secondCriteria) {
        this.firstCriteria = firstCriteria;
        this.secondCriteria = secondCriteria;
    }

    @Override
    public List<Employee> criteria(List<Employee> employeeList) {
        List<Employee> firstCriteriaEmployees = firstCriteria.criteria(employeeList);
        return secondCriteria.criteria(firstCriteriaEmployees);
    }
}

   The list of employees is filtered through by the first criteria, and then the already
   filtered list is filtered again, with the second criteria.

   OrCriteria:
    private Criteria firstCriteria;
    private Criteria secondCriteria;

    public OrCriteria(Criteria firstCriteria, Criteria secondCriteria) {
        this.firstCriteria = firstCriteria;
        this.secondCriteria = secondCriteria;
    }


    @Override
    public List<Employee> criteria(List<Employee> employeeList) {
        List<Employee> firstCriteriaEmployees = firstCriteria.criteria(employeeList);
        List<Employee> secondCriteriaEmployees = secondCriteria.criteria(employeeList);

        for (Employee employee : secondCriteriaEmployees) {
            if(!firstCriteriaEmployees.contains(employee)) {
                firstCriteriaEmployees.add(employee);
            }
        }
        return firstCriteriaEmployees;
    }
}

   Two lists of employees are made, based on the individual criteria. If the first list
   doesn't contain an employee that the second list does, the employee is added to the list.

   This way, both lists are practically merged in the end.

   Now that all of the Criteria implementations are in place, let's make a list of employees
   that will act as a list retrieved from a database, and then run a few criteria:
public class Main {
    public static void main(String[] args) {
        List<Employee> employeeList = new ArrayList<>();

        //adding employees to the list
        employeeList.add(new Employee("David", "Male", "Senior"));
        employeeList.add(new Employee("Scott", "Male", "Senior"));
        employeeList.add(new Employee("Rhett", "Male", "Junior"));
        employeeList.add(new Employee("Andrew", "Male", "Junior"));
        employeeList.add(new Employee("Susan", "Female", "Senior"));
        employeeList.add(new Employee("Rebecca", "Female", "Junior"));
        employeeList.add(new Employee("Mary", "Female", "Junior"));
        employeeList.add(new Employee("Juliette", "Female", "Senior"));
        employeeList.add(new Employee("Jessica", "Female", "Junior"));
        employeeList.add(new Employee("Mike", "Male", "Junior"));
        employeeList.add(new Employee("Chris", "Male", "Junior"));

        //initialization of the different criteria classes
        Criteria maleEmployees = new CriteriaMale();
        Criteria femaleEmployees = new CriteriaFemale();
        Criteria seniorEmployees = new CriteriaSenior();
        Criteria juniorEmployees = new CriteriaJunior();
        //AndCriteria and OrCriteria accept two Criteria as their constructor
        arguments and return filtered lists
        Criteria seniorFemale = new AndCriteria(seniorEmployees, femaleEmployees);
        Criteria juniorOrMale = new OrCriteria(juniorEmployees, maleEmployees);

        System.out.println("Male employees: ");
        printEmployeeInfo(maleEmployees.criteria(employeeList));

        System.out.println("\nFemale employees: ");
        printEmployeeInfo(femaleEmployees.criteria(employeeList));

        System.out.println("\nSenior female employees: ");
        printEmployeeInfo(seniorFemale.criteria(employeeList));

        System.out.println("\nJunior or male employees: ");
        printEmployeeInfo(juniorOrMale.criteria(employeeList));
    }


    //simple method to print out employee info
    public static void printEmployeeInfo(List<Employee> employeeList) {
        for (Employee employee : employeeList) {
            System.out.println("Employee info: | Name: "
                    + employee.getName() + ", Gender: "
                    + employee.getGender() + ", Position: "
                    + employee.getPosition() + " |");
        }
    }
}


   Running this piece of code will yield:
Male employees:
Employee info: | Name: David, Gender: Male, Position: Senior |
Employee info: | Name: Scott, Gender: Male, Position: Senior |
Employee info: | Name: Rhett, Gender: Male, Position: Junior |
Employee info: | Name: Andrew, Gender: Male, Position: Junior |
Employee info: | Name: Mike, Gender: Male, Position: Junior |
Employee info: | Name: Chris, Gender: Male, Position: Junior |

Female employees:
Employee info: | Name: Susan, Gender: Female, Position: Senior |
Employee info: | Name: Rebecca, Gender: Female, Position: Junior |
Employee info: | Name: Mary, Gender: Female, Position: Junior |
Employee info: | Name: Juliette, Gender: Female, Position: Senior |
Employee info: | Name: Jessica, Gender: Female, Position: Junior |

Senior female employees:
Employee info: | Name: Susan, Gender: Female, Position: Senior |
Employee info: | Name: Juliette, Gender: Female, Position: Senior |

Junior or male employees:
Employee info: | Name: Rhett, Gender: Male, Position: Junior |
Employee info: | Name: Andrew, Gender: Male, Position: Junior |
Employee info: | Name: Rebecca, Gender: Female, Position: Junior |
Employee info: | Name: Mary, Gender: Female, Position: Junior |
Employee info: | Name: Jessica, Gender: Female, Position: Junior |
Employee info: | Name: Mike, Gender: Male, Position: Junior |
Employee info: | Name: Chris, Gender: Male, Position: Junior |
Employee info: | Name: David, Gender: Male, Position: Senior |
Employee info: | Name: Scott, Gender: Male, Position: Senior |

Composite
   The Composite pattern is used when we need a way to treat a whole group of objects in a
   similar, or the same manner.

   This is usually done by the class that "owns" the group of objects and provides a set of
   methods to treat them equally as if they were a single object.

Implementation
   Let's start off with the Employee class. This class will be instantiated multiple times to
   form a group of employees:
public class Employee {
    private String name;
    private String position;
    private int wage;
    private List<Employee> coworkers;

    public Employee(String name, String position, int wage) {
        this.name = name;
        this.position = position;
        this.wage = wage;
        coworkers = new ArrayList<Employee>();
    }

    public void addCoworker(Employee employee) {
        coworkers.add(employee);
    }

    public void removeCoworker(Employee employee) {
        coworkers.remove(employee);
    }

    public List<Employee> getCoworkers() {
        return coworkers;
    }

    public String toString() {
        return "Employee : | Name: " + name + ", Position: " + position + ", Wage: "
             + wage + " |";
    }
}

   The class has a list of Employee within it, this is our group of objects that we want to
   target as a single object.
public class StackAbuseJavaDesignPatterns {
    public static void main(String[] args) {
        Employee employee1 = new Employee("David", "Programmer", 1500);
        Employee employee2 = new Employee("Scott", "CEO", 3000);
        Employee employee3 = new Employee("Andrew", "Manager", 2000);
        Employee employee4 = new Employee("Scott", "Janitor", 500);
        Employee employee5 = new Employee("Juliette", "Marketing", 1000);
        Employee employee6 = new Employee("Rebecca", "Sales", 2000);
        Employee employee7 = new Employee("Chris", "Programmer", 1750);
        Employee employee8 = new Employee("Ivan", "Programmer", 1200);

        employee3.addCoworker(employee1);
        employee3.addCoworker(employee7);
        employee3.addCoworker(employee8);

        employee1.addCoworker(employee7);
        employee1.addCoworker(employee8);

        employee2.addCoworker(employee3);
        employee2.addCoworker(employee5);
        employee2.addCoworker(employee6);

        System.out.println(employee2);
        for (Employee headEmployee : employee2.getCoworkers()) {
            System.out.println(headEmployee);

            for(Employee employee : headEmployee.getCoworkers()) {
                System.out.println(employee);
            }
        }
    }
}

   Here, several employees are instantiated. The CEO has a few employees as close coworkers,
   and some of them have their own close coworkers, in lower positions.

   In the end, the head employees are close coworkers of the CEO, and the regular employees
   are coworkers of the head employees.

   Running the code above will yield:
Employee : | Name: Scott, Position: CEO, Wage: 3000 |
Employee : | Name: Andrew, Position: Manager, Wage: 2000 |
Employee : | Name: David, Position: Programmer, Wage: 1500 |
Employee : | Name: Chris, Position: Programmer, Wage: 1750 |
Employee : | Name: Ivan, Position: Programmer, Wage: 1200 |
Employee : | Name: Juliette, Position: Marketing, Wage: 1000 |
Employee : | Name: Rebecca, Position: Sales, Wage: 2000 |

Decorator
   The Decorator pattern is used to alter an individual instance of a class at runtime, by
   creating a decorator class which wraps the original class.

   This way, changing or adding functionalities of the decorator object won't affect the
   structure or the functionalities of the original object.

   It differs from classic inheritance in the fact that it's done at runtime, and applies only
   to an individual instance, whereas inheritance will affect all instances, and is done at
   compile time.

Implementation
   Following the description above, let's define an interface:
public interface Computer {
    void assemble();
}

   And by implementing that interface, we'll define a class which we will, using the Decorator
   pattern, make susceptible to change during runtime:
public class BasicComputer implements Computer {
    @Override
    public void assemble() {
        System.out.print("Assembling a basic computer.");
    }
}

   Now, for the decorator class:
public abstract class ComputerDecorator implements Computer {
    protected Computer computer;

    public ComputerDecorator(Computer computer) {
        this.computer = computer;
    }

    @Override
    public void assemble() {
        this.computer.assemble();
    }
}

   Our concrete classes will extend this one inheriting its functionality and adding their own
   functionality in the process:
public class GamingComputer extends ComputerDecorator {
    public GamingComputer(Computer computer) {
        super(computer);
    }

    @Override
    public void assemble() {
        super.assemble();
        System.out.print(" Adding characteristics of a gaming computer! ");
    }
}

public class WorkComputer extends ComputerDecorator {
    public WorkComputer(Computer computer) {
        super(computer);
    }

    @Override
    public void assemble() {
        super.assemble();
        System.out.print(" Adding characteristics of a work computer! ");
    }
}

   With these concrete classes fully defined, we can observe the result:
public class Main {
    public static void main(String[] args) {
        Computer gamingComputer = new GamingComputer(new BasicComputer());
        gamingComputer.assemble();
        System.out.println("\n");

        Computer workComputer = new WorkComputer(new GamingComputer(new
            BasicComputer()));
        workComputer.assemble();
    }
}

   Running this piece of code will yield:
Assembling a basic computer. Adding characteristics of a gaming computer!

Assembling a basic computer. Adding characteristics of a gaming computer!  Adding characteristics of
 a work computer!

Facade
   The Facade pattern provides a simple and top-level interface for the client and allows it
   to access the system, without knowing any of the system logic and inner-workings.

Implementation
   We'll define a ZooKeeper class that will act like an interface for the user which wants to
   feed the animals in the Zoo.

   We're starting off with an Animal interface:
public interface Animal {
    void feed();
}

   And concrete classes that implement it:
public class Lion implements Animal {
    @Override
    public void feed() {
        System.out.println("The lion is being fed!");
    }
}

public class Wolf implements Animal {
    @Override
    public void feed() {
        System.out.println("The wolf is being fed!");
    }
}

public class Bear implements Animal {
    @Override
    public void feed() {
        System.out.println("The bear if being fed!");
    }
}

   This is the cue for the ZooKeeper class:
public class ZooKeeper {
    private Animal lion;
    private Animal wolf;
    private Animal bear;

    public ZooKeeper() {
        lion = new Lion();
        wolf = new Wolf();
        bear = new Bear();
    }

    public void feedLion() {
        lion.feed();
    }

    public void feedWolf() {
        wolf.feed();
    }

    public void feedBear() {
        bear.feed();
    }
}

   By using this interface, the client doesn't concern themselves with the logic behind
   feeding the animals.

   To observe the result:
public class Main {
    public static void main(String[] args) {
        ZooKeeper zookeeper = new ZooKeeper();

        zookeeper.feedLion();
        zookeeper.feedWolf();
        zookeeper.feedBear();
    }
}

   Running this piece of code will yield:
The lion is being fed!
The wolf is being fed!
The bear if being fed!

Flyweight
   The Flyweight pattern is concerned with reducing the strain on the JVM and its memory. This
   is crucial for devices without much memory, as well as optimization of the application.

   When a certain application needs to create many instances of the same class, a common pool
   is created so that similar ones can be reused, instead of created each time.

   The most well-known implementation of this design pattern is the String Pool in Java.
   Strings are used perhaps more often than any other object in the language and thus, they
   consumed a large portion of the resources. By creating a pool of common Strings and
   assigning multiple reference variables to the ones with the same content, and only creating
   new Strings when no match is found made a huge impact on the performance of Java.

Implementation
   As usual, let's start with an interface:
public interface Attendee {
    public void listenToConcert();
}

   A concrete class implements this interface:
public class AttendeeImpl implements Attendee {
    private String name;
    private int age;

    public AttendeeImpl(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public void listenToConcert() {
        System.out.println(name + " is listening to concert " + age + " years old!");
    }
}

   These attendees will all be created by an AttendeeFactory and put into a HashMap. It's
   important to note that the method creates a new AttendeeImpl object if none already exist.
   On the other hand, if it does exist, the method returns it.

   This is the point of the Flyweight pattern. To return a new object only if a matching
   object doesn't already exist:
public class AttendeeFactory {
    private static final HashMap attendees = new HashMap();

    public static Attendee getAttendee(String name) {
        AttendeeImpl attendeeImpl = (AttendeeImpl)attendees.get(name);
            if(attendeeImpl == null) {
                attendeeImpl = new AttendeeImpl(name);
                attendees.put(name, attendeeImpl);
                System.out.println("Creating a new attendee: " + name);
            }
         return attendeeImpl;
    }
}

   And to see the result, we'll create 10 attendees with random names from the name pool and
   random age.
public class StackAbuseJavaDesignPatterns {

    private static final String[] names = {"David", "Scott", "Andrew", "Rhett"};

    public static void main(String[] args) {
        for(int i = 0; i < 10; ++i) {
            AttendeeImpl attendeeImpl = (AttendeeImpl) AttendeeFactory.getAttendee(getRandomName());
            attendeeImpl.setAge(getRandomAge());
            attendeeImpl.listenToConcert();
        }
    }

    private static String getRandomName() {
        int randomName = new Random().nextInt(names.length);
        return names[randomName];
    }

    private static int getRandomAge() {
        return (int)(Math.random()*80);
    }
}

   Running this piece of code will yield different values each time, but should look something
   like this:
Creating a new attendee: Scott
Scott is listening to concert 32 years old!
Scott is listening to concert 1 years old!
Creating a new attendee: Andrew
Andrew is listening to concert 8 years old!
Creating a new attendee: Rhett
Rhett is listening to concert 58 years old!
Andrew is listening to concert 76 years old!
Scott is listening to concert 56 years old!
Rhett is listening to concert 43 years old!
Scott is listening to concert 51 years old!
Creating a new attendee: David
David is listening to concert 31 years old!
David is listening to concert 29 years old!

Proxy
   The Proxy pattern is used when we want to limit the capabilities and the functionalities of
   a class, by using another class which limits it.

   By using this proxy class, the client uses the interface it defines, to access the original
   class. This ensures that the client can't do anything out of order with the original class
   since all of his requests pass through our proxy class.

Implementation
   Let's define a common interface for the original and proxy class:
public interface MediaFile {
    void printName();
}

   This interface will be implemented by a class, for which we will define a proxy class:
public class MediaFileImpl implements MediaFile {
    private String fileName;

    public MediaFileImpl(String fileName){
       this.fileName = fileName;
       loadFromDisk(fileName);
    }

    @Override
    public void printName() {
       System.out.println("Displaying " + fileName);
    }

    private void loadFromDisk(String fileName){
       System.out.println("Loading " + fileName);
    }
}

public class ProxyMediaFile implements MediaFile {

 private MediaFileImpl mediaFileImpl;
   private String fileName;

   public ProxyMediaFile(String fileName){
      this.fileName = fileName;
   }

   @Override
   public void printName() {
      if(mediaFileImpl == null){
         mediaFileImpl = new MediaFileImpl(fileName);
      }
      mediaFileImpl.printName();
   }
}

   With these two concrete classes finished, let's observe the result:
public class Main {
    public static void main(String[] args) {
      MediaFile mediaFile = new ProxyMediaFile("movie.mp4");

      mediaFile.printName();
      mediaFile.printName();
    }
}

   Running this piece of code will yield:
Loading movie.mp4
Displaying movie.mp4
Displaying movie.mp4

Conclusion
   With this, all Structural Design Patterns in Java are fully covered, with working examples.

   If you'd like to continue reading about Design Patterns in Java, the following article
   covers Behavioral Design Patterns.


---
https://stackabuse.com/behavioral-design-patterns-in-java/

Behavioral Design Patterns in Java

Overview
   This is the third article in a short series dedicated to Design Patterns in Java, and a
   direct continuation from the previous article - Structural Design Patterns in Java.

Behavioral Patterns
   Behavioral Patterns are concerned with providing solutions regarding object interaction -
   how they communicate, how are some dependent on others, and how to segregate them to be
   both dependent and independent and provide both flexibility and testing capabilities.

   The Behavioral Patterns in Java that are covered in this article are:
     * Interpreter
     * Template Method/Pattern
     * Chain of Responsibility
     * Command
     * Iterator
     * Mediator
     * Memento
     * Observer
     * State
     * Strategy
     * Visitor

Interpreter
   The Interpreter pattern is used anytime we need to evaluate any kind of language grammar or
   expressions. A good example of this pattern would be Google Translate, which interprets
   the input, and shows us the output in another language.

   Another example would be the Java compiler. The compiler interprets Java code and
   translates it into bytecode that the JVM uses to perform operations on the device it runs
   on.

   This pattern also represents a great way to write simple programs that understand
   human-like syntax.

Implementation
   We'll be making a simple implementation with simple grammar, otherwise, it would become
   convoluted and far too complex for the sake of this tutorial.

   To realize this design pattern, we'll have to define an interpreter engine, accompanied by
   different expressions which it will use to interpret the command.

   Let's define an interface for all of these expressions:
public interface Expression {
    public int interpret(InterpreterEngine engine);
}

   This interpreter engine is simple:
public class InterpreterEngine {
    public int add(String input) {
        String[] tokens = interpret(input);
        int num1 = Integer.parseInt(tokens[0]);
        int num2 = Integer.parseInt(tokens[1]);
        return (num1+num2);
    }

    public int multiply(String input) {
        String[] tokens = interpret(input);
        int num1 = Integer.parseInt(tokens[0]);
        int num2 = Integer.parseInt(tokens[1]);
        return (num1*num2);
    }

    private String[] interpret(String input) {
        String string = input.replaceAll("[^0-9]", " ");
        string = string.replaceAll("( )+", " ").trim();
        String[] tokens = string.split(" ");
        return tokens;
    }
}

   It replaces all non-digit characters with empty characters, and splits the input into
   tokens. This basically leaves us without digits.

   Now, let's implement the Expression interface with a few concrete classes:
public class AddExpression implements Expression {
    private String expression;

    public AddExpression(String expression) {
        this.expression = expression;
    }

    @Override
    public int interpret(InterpreterEngine engine) {
        return engine.add(expression);
    }
}

public class MultiplyExpression implements Expression {
    private String expression;

    public MultiplyExpression(String expression) {
        this.expression = expression;
    }

    @Override
    public int interpret(InterpreterEngine engine) {
        return engine.multiply(expression);
    }
}

   And to illustrate the point of the pattern:
public class Main {
    private InterpreterEngine engine;

    public Main(InterpreterEngine engine) {
        this.engine = engine;
    }

    public int interpret(String input) {
        Expression expression = null;

        if(input.contains("add")) {
            expression = new AddExpression(input);
        } else if(input.contains("multiply")) {
            expression = new MultiplyExpression(input);
        }

        int result = expression.interpret(engine);
        System.out.println(input);
        return result;
    }

    public static void main(String[] args) {
        Main main = new Main(new InterpreterEngine());

        System.out.println("Result: " + main .interpret("add 15 and 25"));
        System.out.println("Result: " + main .interpret("multiply " + main .interpret("add 5 and 5")
 + " and 10"));
    }
}

   Since we discarded all non-digit characters, here's the place to evaluate whether the
   interpreter should add or multiply the input.

   Running this piece of code will yield:
add 15 and 25
Result: 40
add 5 and 5
multiply 10 and 10
Result: 100

Template Method
   The Template Method, otherwise known as Template Pattern is all around us. It boils down to
   defining an abstract class that provides predefined ways to run its methods. Sub-classes
   that inherit these methods must also follow the way defined in the abstract class.

   In some cases, the abstract class may already include a method implementation, not just
   instructions, if it's a functionality that will be shared amongst all or most of the
   sub-classes.

Implementation
   In a company, all employees have a few shared responsibilities:
public abstract class Employee {
    abstract void work();
    abstract void takePause();
    abstract void getPaid();

    public final void comeToWork() {
        work();
        takePause();
        work();
        getPaid();
    }
}

   They all come to work, all get a break and get paid.

   Different employees do different kinds of work:
public class Programmer extends Employee {

    @Override
    void work() {
        System.out.println("Writing code.");
    }

    @Override
    void takePause() {
        System.out.println("Taking a small break from writing code.");
    }

    @Override
    void getPaid() {
        System.out.println("Getting paid for developing the project.");
    }
}

public class Manager extends Employee {

    @Override
    void work() {
        System.out.println("Managing other employees.");
    }

    @Override
    void takePause() {
        System.out.println("Taking a small break from managing employees.");
    }

    @Override
    void getPaid() {
        System.out.println("Getting paid for overseeing the development of the project.");
    }
}

   But they still follow the template of working, taking a pause, and getting paid, which is
   all laid out by the interface.

   To illustrate the point of this pattern:
public class Main {
    public static void main(String[] args) {
        Employee employee = new Programmer();
        employee.comeToWork();

        System.out.println();

        employee = new Manager();
        employee.comeToWork();
    }
}

   Running this piece of code will yield:
Writing code.
Taking a small break from writing code.
Writing code.
Getting paid for developing the project.

Managing other employees.
Taking a small break from managing employees.
Managing other employees.
Getting paid for overseeing the development of the project.

Chain of Responsibility
   The Chain of Responsibility pattern is widely used and adopted. It defines a chain of
   objects, that collectively, one after another, process the request - where each processor
   in the chain has its own processing logic.

   Each of these processing units decides who should continue processing the request next, and
   each has a reference to the next in line.

   It's important to note that it's very handy for decoupling the sender from the receiver.

Implementation
   As usual, let's define an abstract class:
public abstract class Employee {
    public static int PROGRAMER = 1;
    public static int LEAD_PROGRAMER = 2;
    public static int MANAGER = 3;

    protected int authorityLevel;

    protected Employee nextEmployee;

    public void setNextEmployee(Employee employee) {
        this.nextEmployee = employee;
    }

    public void doWork(int authorityLevel, String message) {
        if(this.authorityLevel <= authorityLevel) {
            write(message);
        }
        if(nextEmployee != null) {
            nextEmployee.doWork(authorityLevel, message);
        }
    }

    abstract protected void write(String message);
}

   This abstract class contains authority levels for all of the employees. A programmer is
   located less on the hierarchy than a lead programmer, which is in turn, lower than a
   manager.

   We've also included a reference to the next employee, which you'll see why is important
   soon enough.

   A common method for all these classes is defined, with an authority check. If a certain
   class doesn't have the authority, it passes the request to the next one in the chain of
   responsibility.

   Now, let's extend this class:
public class Programmer extends Employee {

    public Programmer(int authorityLevel) {
        this.authorityLevel = authorityLevel;
    }

    @Override
    protected void write(String message) {
        System.out.println("Programmer is working on project: " + message);
    }
}

public class LeadProgrammer extends Employee {

    public LeadProgrammer(int authorityLevel) {
        this.authorityLevel = authorityLevel;
    }

    @Override
    protected void write(String message) {
         System.out.println("Lead programmer is working on project: " + message);
    }
}

public class Manager extends Employee {

    public Manager(int authorityLevel) {
        this.authorityLevel = authorityLevel;
    }

    @Override
    protected void write(String message) {
         System.out.println("Manager is working on project: " + message);
    }
}

   As mentioned above, each of these units provide their own processing logic.

   To illustrate the point of this pattern:
public class Main {
    private static Employee getChainOfEmployees() {
        Employee programmer = new Programmer(Employee.PROGRAMER);
        Employee leadProgrammer = new LeadProgrammer(Employee.LEAD_PROGRAMER);
        Employee manager = new Manager(Employee.MANAGER);

        programmer.setNextEmployee(leadProgrammer);
        leadProgrammer.setNextEmployee(manager);

        return programmer;
    }

    public static void main(String[] args) {
        Employee employeeChain = getChainOfEmployees();

        employeeChain.doWork(Employee.PROGRAMER, "This is basic programming work.");
        employeeChain.doWork(Employee.LEAD_PROGRAMER, "This is marginally more
            sophisticated programming work.");
        employeeChain.doWork(Employee.MANAGER, "This is the work for a manager.");
    }
}

   First off, a static method getChainOfEmployees() is defined. This method is used to set the
   authority levels of each unit, via their constructors, and to define the order of
   responsibility.

   By setting the next Employee for Programmer, we're basically telling it who to go to, if
   the request is out of scope for it.

   Naturally, a programmer will turn to their designated LeadProgrammer. If the request is too
   much even for them to handle, they will turn to their Manager for help.

   Running this piece of code will yield:
Programmer is working on project: This is basic programming work.
Programmer is working on project: This is marginally more sophisticated programming work.
Lead programmer is working on project: This is marginally more sophisticated programming work.
Programmer is working on project: This is the work for a manager.
Lead programmer is working on project: This is the work for a manager.
Manager is working on project: This is the work for a manager.

   A Programmer is assigned to work on a request on their own authority level, and they do it
   gracefully.

   Then, a new request comes in, needing the authority of a LeadProgrammer, so they take over.

   Finally, another request comes in, needing the authority of a Manager. The programmer asks
   their designated lead programmer for help, which in turn decides to ask their manager for
   help, and the manager happily complies and does the job.

Command
   Another decoupling design pattern, the Command pattern works by wrapping the request from
   the sender in an object called a command. This command is then passed to the invoker
   object, which proceeds to look for the adequate way to process the request.

   Once it finds the adequate way, it passes the command, where it will be executed.

Implementation
   Let's simulate a programmer's job for this pattern. A client can send an Order - a command,
   for an Application - a request. The programmer can then make the application, and sell it
   to the client.

   Let's make our command:
public interface Order {
    void placeOrder();
}

   And our request:
public class Application {
    private String name = "Computer Application";
    private int quantity = 2;

    public void make() {
        System.out.println(quantity + " application(s) are made for the client.");
    }

    public void sell() {
        System.out.println(quantity + "application(s) are sold to the client.");
    }
}

   Assuming that the programmer accepted work with the client, it would be fitting to make the
   application:
public class MakeApplication implements Order {
    private Application application;

    public MakeApplication(Application application) {
        this.application = application;
    }

    @Override
    public void placeOrder() {
        application.make();
    }
}

   And after making it, the programmer will proceed to sell it:
public class SellApplication implements Order {
    private Application application;

    public SellApplication(Application application) {
        this.application = application;
    }

    @Override
    public void placeOrder() {
        application.sell();
    }
}

   An invoker object is needed, to which we send the request:
public class Programmer {
    private List<Order> orderList = new ArrayList<>();

    public void takeOrder(Order order) {
        orderList.add(order);
    }

    public void placeOrders() {
        for(Order order : orderList) {
            order.placeOrder();
        }
        orderList.clear();
    }
}

   The request, even though it's an Application is wrapped as an Order - a command, as
   described before the implementation.

   And to illustrate the point of this pattern:
public class Main {
    public static void main(String[] args) {
        // command
        Application application = new Application();

        / /wrapping requests
        MakeApplication makeApplication = new MakeApplication(application);
        SellApplication sellApplication = new SellApplication(application);

        // invoker
        Programmer programmer = new Programmer();
        programmer.takeOrder(makeApplication);
        programmer.takeOrder(sellApplication);

        // invoker processed the wrapped request
        programmer.placeOrders();
    }
}

   Running this piece of code will yield:
2 application(s) are made for the client.
2 application(s) are sold to the client.

Iterator
   The Iterator pattern is used as the core pattern of Java's Collection Framework. It's
   used to access the members of collections all the while hiding the underlying
   implementation.

Implementation
   This is a fairly simple implementation and is used as the core pattern in multiple
   frameworks, including the framework mentioned above.

   We will be making a simple iterator to print out the names of our employees.

   All of our employees have their own sector in which they operate. So working under a sector
   also includes an iterator for all of them.

   So let's go ahead and define our Iterator:
public interface Iterator {
    public boolean hasNext();
    public Object next();
}

   This iterator will be stored in a container of sorts. In our case, a work Sector:
public interface Sector {
    public Iterator getIterator();
}

   Now, let's define a repository for our employees:
public class EmployeeRepository implements Sector {
    public String[] employees = {"David", "Scott", "Rhett", "Andrew", "Jessica"};

    @Override
    public Iterator getIterator() {
        return new EmployeeIterator();
    }

    private class EmployeeIterator implements Iterator {
        int index;

        @Override
        public boolean hasNext() {
            if(index < employees.length) {
                return true;
            }
            return false;
        }

        @Override
        public Object next() {
            if(this.hasNext()) {
                return employees[index++];
            }
            return null;
        }
    }
}

   For the sake of simplicity, we've only used an array of Strings and avoided defining a
   seperate Employee class.

   To illustrate the point of this pattern:
public class Main {
    public static void main(String[] args) {

        EmployeeRepository employeeRepository = new EmployeeRepository();

        for(Iterator iterator = employeeRepository.getIterator();
                iterator.hasNext();) {
            String employee = (String)iterator.next();
            System.out.println("Employee: " + employee);
        }
    }
}

   Running this piece of code will yield:
Employee: David
Employee: Scott
Employee: Rhett
Employee: Andrew
Employee: Jessica

Mediator
   Similar to the Adapter pattern, but with a different goal. The Mediator pattern acts as a
   bridge and, as the name implies, the mediator between different objects which communicate
   in any way. In large-scale applications, direct communication means tight-coupling which
   makes it hard to test, maintain and scale.

   The Mediator pattern addresses this issue by acting as a third party over which the
   communication is done, decoupling them in the process.

Implementation
   This is a fairly simple implementation, and probably the most notorious one is a chat
   between two individuals.

   A User object wishes to communicate with another, so they use a mediator platform between
   them to do so - a Chat:
public class Chat {
    public static void showMessage(User user, String message) {
        System.out.println(new Date().toString() + "[" + user.getName() + "]: " + message);
    }
}

   This class contains only one method and, accepting a User and a String, it formats the
   parameters and shows the message.
public class User {
    private String name;

    public User(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }

    public void sendMessage(String message) {
        Chat.showMessage(this, message);
    }
}

   Our User class defines a sendMessage() method. This method calls upon the static method
   from the Chat class with this instance of the user and a String as the arguments.

   To illustrate the point of this pattern:
public class Main {
    public static void main(String[] args) {
        User david = new User("David");
        User scott = new User("Scott");

        david.sendMessage("Hi Scott! How are you?");
        scott.sendMessage("I'm great! Thanks for asking. How are you?");
    }
}

   These two objects don't communicate directly. None of them point to any reference variable
   or another object, yet the Chat class acts as a mediator and connects them.

   Running this piece of code will yield:
Fri Aug 31 14:14:19 CEST 2018[David]: Hi Scott! How are you?
Fri Aug 31 14:14:19 CEST 2018[Scott]: I'm great! Thanks for asking. How are you?

Memento
   The Memento pattern is concerned with previous states of the object. This means that the
   pattern is used when we want to save some state of an object, in the case we might want to
   restore the object to that state later on.

Implementation
   This pattern relies on the work of three classes, also known as actor classes. The Memento
   object contains a state that we wish to save for later use. The Originator object creates
   and stores states in the Memento objects, while the CareTaker object takes care of the
   restoration process.

   Let's firstly define our memento:
public class Memento {
    private String state;

    public Memento(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }
}

   Then our originator and caretaker:
public class Originator {
    private String state;

    public void setState(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }

    public Memento saveStateToMemento() {
        return new Memento(state);
    }

    public void getStateFromMemento(Memento memento) {
        state = memento.getState();
    }
}

public class CareTaker {
    private List<Memento> mementoList = new ArrayList<>();

    public void add(Memento memento) {
        mementoList.add(memento);
    }
    public Memento get(int index) {
        return mementoList.get(index);
    }
}

   And to illustrate the point of the pattern:
public class Main {
    public static void main(String[] args) {
        Originator originator = new Originator();
        CareTaker careTaker = new CareTaker();

        originator.setState("State 1 at " + System.currentTimeMillis());
        originator.setState("State 2 at " + System.currentTimeMillis());
        careTaker.add(originator.saveStateToMemento());

        originator.setState("State 3 at " + System.currentTimeMillis());
        careTaker.add(originator.saveStateToMemento());

        System.out.println("Current state: " + originator.getState());

        originator.getStateFromMemento(careTaker.get(0));
        System.out.println("First saved state: " + originator.getState());
        originator.getStateFromMemento(careTaker.get(1));
        System.out.println("Second saved state: " + originator.getState());
    }
}

   Running this piece of code will yield:
Current state: State 3 at 1535705131218
First saved state: State 2 at 1535705131218
Second saved state: State 3 at 1535705131218

Observer
   The Observer pattern is used to monitor the state of a certain object, often in a group or
   one-to-many relationship. In such cases, most of the time, the changed state of a single
   object can affect the state of the rest, so there must be a system to note the change and
   alert the other objects.

   While Java does provide both a class and an interface with this pattern in mind, it's not
   widespread because it wasn't realized in an ideal way.

Implementation
   To illustrate this pattern, we'll build a small office with a CEO, Manager, LeadProgrammer
   and a Programmer.

   The programmer will be observed by his superiors, which have an opinion of him based on how
   well he does his job:
public class Programmer {
    private List<Observer> observers = new ArrayList<>();
    private String state;

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
        notifyObservers();
    }

    public void attach(Observer observer) {
        observers.add(observer);
    }

    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update();
        }
    }
}

   There's a one-to-many relationship with his observers, and each change of state notifies
   them all.

   All of these observers have a couple of things in common:
public abstract class Observer {
    protected Programmer programmer;
    public abstract void update();
}

   But each have their own implementation:
public class CEO extends Observer {

    public CEO(Programmer programmer) {
        this.programmer = programmer;
        this.programmer.attach(this);
    }

    @Override
    public void update() {
        if(this.programmer.getState().equalsIgnoreCase("Successful")) {
            System.out.println("CEO is happy with Manager and Lead Programmer.");
        } else {
            System.out.println("CEO is unhappy with Manager and Lead Programmer.");
        }
    }
}

public class Manager extends Observer {

    public Manager(Programmer programmer) {
        this.programmer = programmer;
        this.programmer.attach(this);
    }

    @Override
    public void update() {
        if(this.programmer.getState().equalsIgnoreCase("Successful")) {
            System.out.println("Manager is happy with Lead Programmer and this Programmer.");
        } else {
            System.out.println("Manager is unhappy with Lead Programmer and this Programmer.");
        }
    }
}

public class LeadProgrammer extends Observer {

    public LeadProgrammer(Programmer programmer) {
        this.programmer = programmer;
        this.programmer.attach(this);
    }

     @Override
    public void update() {
        if(this.programmer.getState().equalsIgnoreCase("Successful")) {
            System.out.println("Lead Programmer is proud of his Programmer.");
        } else {
            System.out.println("Lead Programmer is not proud of his Programmer.");
        }
    }
}

   The CEO doesn't concern himself with the programmer, but rather the result, leaving it in
   the capable hands of the Manager and the LeadProgrammer. The manager is concerned mostly
   whether the lead programmer can guide the programmer to do his job. And finally, the lead
   programmer is mainly concerned by what the programmer does.

   To illustrate the point of this pattern:
public class Main {
    public static void main(String[] args) {
        Programmer programmer = new Programmer();

        new CEO(programmer);
        new Manager(programmer);
        new LeadProgrammer(programmer);

        System.out.println("Programmer successfully did his job!");
        programmer.setState("Successful");
        System.out.println("Programmer failed his new assignment.");
        programmer.setState("Failed");
    }
}

   Running this piece of code will yield:
Programmer successfully did his job!
CEO is happy with Manager and Lead Programmer.
Manager is happy with Lead Programmer and this Programmer.
Lead Programmer is proud of his Programmer.
Programmer failed his new assignment.
CEO is unhappy with Manager and Lead Programmer.
Manager is unhappy with Lead Programmer and this Programmer.
Lead Programmer is not proud of his Programmer.

State
   The State pattern is used when a specific object needs to change its behavior, based on its
   state. This is accomplished by providing each of these objects with one or more state
   objects.

   Based on these state objects, we can completely change the behavior of the concerned
   object.

Implementation
   Let's define a simple interface:
public interface State {
    public void doAction(Context context);
}

   This state will be carried through a context:
public class Context {
    private State state;

    public Context() {
        state = null;
    }

    public void setState(State state) {
        this.state = state;
    }

    public State getState() {
        return state;
    }
}

   And two concrete classes implement it:
public class ApplicationStart implements State {

    @Override
    public void doAction(Context context) {
        System.out.println("The application is in the starting state of development.");
        context.setState(this);
    }
    public String toString() {
        return "Starting state.";
    }
}

public class ApplicationFinish implements State {

    @Override
    public void doAction(Context context) {
        System.out.println("The application is in the finished state of development.");
        context.setState(this);
    }
    public String toString() {
        return "Finished state.";
    }
}

   Now to illustrate the point of this pattern:
public class Main {
    public static void main(String[] args) {
        Context context = new Context();

        ApplicationStart start = new ApplicationStart();
        start.doAction(context);

        System.out.println(context.getState());

        ApplicationFinish finish = new ApplicationFinish();
        finish.doAction(context);

        System.out.println(context.getState());
    }
}

   Running this piece of code will yield:
The application is in the starting state of development.
Starting state.
The application is in the finished state of development.
Finished state.

   As you can see, the behavior of the carrier is changed by the state.

Strategy
   The Strategy pattern is employed in situations where algorithms or class' behavior should
   be dynamic. This means that both the behavior and the algorithms can be changed at runtime,
   based on the input of the client.

   Similar to the State Pattern, this pattern employs multiple strategy objects which define
   different strategies for the targeted class. The targeted class adapts its algorithms and
   behaviors based on these strategies.

Implementation
   Let's start off with defining a strategy:
public interface Strategy {
    public String build(String location);
}

   This strategy will be used to build different types of building, in different locations.
   These building types implement the strategy each in a different way:
public class Skyscraper implements Strategy {

    @Override
    public String build(String location) {
        return "Building a skyscraper in the " + location + " area.";
    }
}

public class House implements Strategy {

    @Override
    public String build(String location) {
        return "Building a house in the " + location + " area.";
    }
}

public class Mall implements Strategy {

    @Override
    public String build(String location) {
        return "Building a mall in the " + location + " area.";
    }
}

   Similar to the State pattern, a Context class will use the strategy:
public class BuildContext {
    private Strategy strategy;

    public BuildContext(Strategy strategy) {
        this.strategy = strategy;
    }

    public String executeStrategy(String location) {
        return strategy.build(location);
    }
}

   And to illustrate the point of this pattern:
public class Main {
    public static void main(String[] args) {
        BuildContext buildContext = new BuildContext(new Skyscraper());
        System.out.println("Requesting a skyscraper: " + buildContext.executeStrategy("Downtown"));

        buildContext = new BuildContext(new House());
        System.out.println("Requesting a house: " + buildContext.executeStrategy("Outskirts"));

        buildContext = new BuildContext(new Mall());
        System.out.println("Requesting a mall: " + buildContext.executeStrategy("City Centre"));
    }
}

   Running this piece of code will yield:
Requesting a skyscrapper: Building a skyscrapper in the Downtown area.
Requesting a house: Building a house in the Outskirts area.
Requesting a mall: Building a mall in the City Centre area.

Visitor
   The Visitor pattern is used to move the operational logic from each individual element of a
   group, into a new class, which does the operation for them utilizing the data from each
   individual element.

   This is done by making all of the elements accept a "visitor". This visitor will perform
   changes in a separate class, without changing the structure of the visited class at all.
   This makes it easy to add new functionality without changing visited classes at all.

   That being said, the objects don't have to be the same and can be unrelated, implementing
   different interfaces etc. An example would be an application that counts the number of
   users on a website. Some of these users are admins, some are customers, some are moderators
   etc.

   Even though they can implement different interfaces and serve different functions, this
   pattern can help acquire the correct number of users.

Implementation
   Each item in our shop will be able to accept a visitor:
public interface Item {
    public int accept(Visitor visitor);
}

   And here's our visitor:
public interface Visitor {
    int visit(Pen pen);
    int visit(Notebook notebook);
}

   Let's define concrete classes for our shop items:
public class Pen implements Item {
    private int price;
    private String model;

    public Pen(int price, String model) {
        this.price = price;
        this.model = model;
    }

    public int getPrice() {
        return price;
    }

    public String getModel() {
        return model;
    }

    @Override
    public int accept(Visitor visitor) {
        return visitor.visit(this);
    }
}

public class Notebook implements Item {
    private int price;
    private int numberOfPages;

    public Notebook(int price, int numberOfPages) {
        this.price = price;
        this.numberOfPages = numberOfPages;
    }

    public int getPrice() {
        return price;
    }

    public int getNumberOfPages() {
        return numberOfPages;
    }

    @Override
    public int accept(Visitor visitor) {
        return visitor.visit(this);
    }
}

   And now let's implement the visitor interface and showcase this design pattern. The
   implementation class will have its own logic for calculating the price of the items, not
   the items themselves:
public class VisitorImpl implements Visitor {

    @Override
    public int visit(Pen pen) {
        int price = pen.getPrice();
        System.out.println(pen.getModel() + " costs " + price);
        return price;
    }

    @Override
    public int visit(Notebook notebook) {
        int price = 0;
        if(notebook.getNumberOfPages() > 250) {
            price = notebook.getPrice()-5;
        } else {
            price = notebook.getPrice();
        }
        System.out.println("Notebook costs " + price);

        return price;
    }
}

   And to illustrate the point of the pattern:
public class StackAbuseJavaDesignPatterns {
    public static void main(String[] args) {
        Item[] items = new Item[]{new Pen(10, "Parker"), new Pen(5, "Pilot"), new Notebook(50, 150),
 new Notebook(75, 300)};

        int total = getTotalPrice(items);
        System.out.println("Total price of items: " + total);
    }

    private static int getTotalPrice(Item[] items) {
        Visitor visitor = new VisitorImpl();
        int result = 0;
        for(Item item : items) {
            result = result + item.accept(visitor);
        }
        return result;
    }
}

   Running this piece of code will yield:
Parker costs 10
Pilot costs 5
Notebook costs 50
Notebook costs 70
Total price of items: 135

Conclusion
   With this, all Behavioral Design Patterns in Java are fully covered, with working examples.

   If you'd like to continue reading about Design Patterns in Java, the following article
   covers J2EE Design Patterns.


---
https://stackabuse.com/java-j2ee-design-patterns/

Java J2EE Design Patterns

Overview
   This is the fourth and final article in a short series dedicated to Design Patterns in
   Java, and a direct continuation from the previous article - Behavioral Design Patterns
   in Java.

J2EE Patterns
   J2EE Patterns are concerned about providing solutions regarding Java EE. These patterns are
   widely accepted by other frameworks and projects. Like, for an example: Spring.

   The J2EE Patterns that are covered in this article are:
     * MVC Pattern
     * Business Delegate Pattern
     * Composite Entity Pattern
     * Data Access Object Pattern
     * Front Controller Pattern
     * Intercepting Filter Pattern
     * Service Locator Pattern
     * Transfer Object Pattern

MVC Pattern
   This is one of the most notorious and most-used patterns from this category. It revolves
   around the idea of Model-View-Controller, which is where the abbreviation comes from.

   Models are basically objects, or POJO's to be exact, used as blueprints/models for all of
   the objects that will be used in the application.

   Views represent the presentational aspect of the data and information located in the
   models.

   Controllers controls both of these. They serve as a connection between the two. Controllers
   both instantiate, update and delete models, populate them with information, and then send
   the data to the views to present to the end-user.

Implementation
   That being said, let's start with the first of the three components of this pattern - the
   model:
public class Employee {
    private int employeeId;
    private String name;

    public int getEmployeeId() {
        return employeeId;
    }
    public void setEmployeeId(int id) {
        this.employeeId = id;
    }
    public String getName() {
        return name;
    }
    public void setEmployeeName(String name) {
        this.name = name;
    }
}

   We need a way to present the data from the model, so we define a view for that very
   purpose:
public class EmployeeView {
    public void printEmployeeInformation(String employeeName, int employeeId) {
        System.out.println("Employee information: ");
        System.out.println("ID: " + employeeId);
        System.out.println("Name: " + employeeName);
    }
}

   The view is responsible for formatting the information in a user-friendly way.

   Once that is out of the way, let's define the controller. This controller will utilize both
   the model and the view to instantiate the model, populate it with some data, and then push
   it to the view for the client to see:
public class EmployeeController {
    private Employee employee;
    private EmployeeView employeeView;

    public EmployeeController(Employee employee, EmployeeView employeeView) {
        this.employee = employee;
        this.employeeView = employeeView;
    }

    public String getEmployeeName() {
        return employee.getName();
    }
    public void setEmployeeName(String name) {
        employee.setEmployeeName(name);
    }
    public int getEmployeeId() {
        return employee.getEmployeeId();
    }
    public void setEmployeeId(int id) {
        employee.setEmployeeId(id);
    }
    public void updateView() {
        employeeView.printEmployeeInformation(employee.getName(), employee.getEmployeeId());
    }
}

   With all three components of this pattern complete, we can wrap this example up.

   To illustrate the point of this pattern:
public class Main {
    public static void main(String[] args) {
       Employee employee = getEmployeeFromDatabase();
       EmployeeView view = new EmployeeView();
       EmployeeController controller = new EmployeeController(employee, view);

       controller.updateView();

       controller.setEmployeeId(5);

       controller.updateView();
    }

    // simulating a database
    public static Employee getEmployeeFromDatabase() {
        Employee employee = new Employee();
        employee.setEmployeeName("David");
        employee.setEmployeeId(1);
        return employee;
    }
}

   Running this piece of code will yield:
Employee information:
ID: 1
Name: David
Employee information:
ID: 5
Name: David

Business Delegate Pattern
   The Business Delegate pattern is used to decouple the presentation layer from the business
   layer to minimize the number of requests between the client (presentation) and the business
   tiers.

Implementation
   Let's start off by defining an interface for our business services:
public interface BusinessService {
    public void process();
}

   Afterwards, let's define two concrete classes implementing this interface:
public class EJBService implements BusinessService {
    @Override
    public void process() {
        System.out.println("Processing using the EJB Service.");
    }
}

public class JMSService implements BusinessService {
    @Override
    public void process() {
        System.out.println("Processing using the JSM Service.");
    }
}

   Let's define a lookup service. The lookup service object should provide the relative
   business implementations and business object access to the business delegate logic:
public class BusinessLookUp {
    public BusinessService getBusinessService(String type) {
        if (type.equalsIgnoreCase("ejb")) {
            return new EJBService();
        } else if (type.equalsIgnoreCase("JMS")) {
            return new JMSService();
        } else {
            return null;
        }
    }
}

   Now, we can define our business delegate:
public class BusinessDelegate {
    private BusinessLookUp lookupService = new BusinessLookUp();
    private BusinessService businessService;
    private String type;

    public void setServiceType(String type) {
        this.type = type;
    }

    public void process() {
        businessService = lookupService.getBusinessService(type);
        businessService.process();
    }
}

   It acts as an access point to the business services for the Client to use:
public class Client {
    BusinessDelegate businessDelegate;

    public Client(BusinessDelegate businessDelegate) {
        this.businessDelegate = businessDelegate;
    }

    public void process() {
        businessDelegate.process();
    }
}

   And now to illustrate the point of this pattern:
public class Main {
    public static void main(String[] args) {
        BusinessDelegate businessDelegate = new BusinessDelegate();
        businessDelegate.setServiceType("EJB");

        Client client = new Client(businessDelegate);
        client.process();

        businessDelegate.setServiceType("JMS");
        client.process();
    }
}

   Running this piece of code will yield:
Processing using the EJB Service.
Processing using the JSM Service.

Composite Entity Pattern
   The Composite Entity pattern represents a graph of objects, which when updated, triggers an
   update for all the dependent entities in the graph.

   It is mainly employed in Enterprise JavaBeans (EJB) which isn't a very popular API as
   it has been replaced by other frameworks and tools like the Spring Framework and its
   numerous tools.

Implementation
   Let's define two classes which feature data that would need to update another class:
public class Employee {
    private String name;
    private String jobSuccess;

    public void setJobSuccess(String jobSuccess) {
        this.jobSuccess = jobSuccess;
    }

    public String getJobSuccess() {
        return jobSuccess;
    }
}

public class Manager {
    private String name;
    private String satisfaction;

    public void setSatisfaction(String satisfaction) {
        this.satisfaction = satisfaction;
    }

    public String getSatisfaction() {
        return satisfaction;
    }
}

   If the Employee does well, the Manager is satisfied and vice versa.

   Since the point of this pattern is to not allow the beans to act as "fine-grained" objects
   alone, we're introduced with a Coarse-Grained Object. This object manages its own
   relationships to other objects:
public class CoarseGrainedObject {
    Employee employee = new Employee();
    Manager manager = new Manager();

    public void setData(String jobSuccess, String satisfaction) {
        employee.setJobSuccess(jobSuccess);
        manager.setSatisfaction(satisfaction);
    }

    public String[] getData() {
        return new String[] {"Employee : " + employee.getJobSuccess(),"Manager: " +
            manager.getSatisfaction()};
    }
}

   Afterwards, we need to define a CompositeEntity class. This class is itself a
   coarse-grained object and can reference another:
public class CompositeEntity {
    private CoarseGrainedObject cgo = new CoarseGrainedObject();

    public void setData(String jobSuccess, String satisfaction) {
        cgo.setData(jobSuccess, satisfaction);
    }

    public String[] getData() {
        return cgo.getData();
    }
}

   With that in place, we just need a Client to use the CompositeEntity:
public class Client {
    private CompositeEntity compositeEntity = new CompositeEntity();

    public void print() {
        for (int i = 0; i < compositeEntity.getData().length; i++) {
            System.out.println(compositeEntity.getData()[i]);
        }
    }

    public void setData(String jobSuccess, String satisfaction) {
        compositeEntity.setData(jobSuccess, satisfaction);
    }
}

   And to illustrate the point of this pattern:
public class Main {
    public static void main(String[] args) {
        Client client = new Client();
        client.setData("Successful", "Satisfied");
        client.print();
        client.setData("Failed", "Unsatisfied");
        client.print();
    }
}

   Running this piece of code will yield:
Employee : Successful
Manager: Satisfied
Employee : Failed
Manager: Unsatisfied

Data Access Object Pattern
   The Data Access Object pattern, most often shortened to DAO is a pattern in which objects
   are dedicated to the communication with the Data Layer.

   These objects often instantiate "SessionFactories" for this purpose and handle all of the
   logic behind communicating with the database.

   The standard practice is to create a DAO interface, followed by a concrete class
   implementing the interface and all methods defined in it.

Implementation
   Following the standard practice, let's define our DAO interface:
public interface EmployeeDAO {
    public List<Employee> getAllEmployees();
    public Employee getEmployeeById(int id);
    public void addEmployee(Employee e);
    public void updateEmployee(Employee e);
    public void deleteEmployee(Employee e);
}

   And our concrete implementation class along with it:
public class EmployeeDAOImpl implements EmployeeDAO {
    List<Employee> employeeList;

    public EmployeeDAOImpl() {
        employeeList = new ArrayList<Employee>();
        Employee david = new Employee(5, "David");
        Employee scott = new Employee(7, "Scott");
        Employee jessica = new Employee(12, "Jessica");
        Employee rebecca = new Employee(16, "Rebecca");
        employeeList.add(david);
        employeeList.add(scott);
        employeeList.add(jessica);
        employeeList.add(rebecca);
    }

    @Override
    public List<Employee> getAllEmployees() {
        return employeeList;
    }
    @Override
    public Employee getEmployeeById(int id) {
        return employeeList.get(id);
    }
    @Override
    public void addEmployee(Employee e) {
        employeeList.add(e);
        System.out.println("Successfully added " + e.getName());
    }
    @Override
    public void updateEmployee(Employee e) {
        employeeList.get(e.getEmployeeId()).setEmployeeName(e.getName());
        System.out.println("Successfully update name of employee with id: " + e.getEmployeeId());
    }
    @Override
    public void deleteEmployee(Employee e) {
        employeeList.remove(e.getEmployeeId());
        System.out.println("Successfully removed employee: " + e.getName() + "with the ID: " + e.get
EmployeeId());
    }
}

   We will be using these two classes to add, retrieve, update, or delete users from our
   database:
public class Employee {
    private int employeeId;
    private String name;

    public Employee(int id, String name) {
        this.employeeId = id;
        this.name = name;
    }

    public int getEmployeeId() {
        return employeeId;
    }
    public void setEmployeeId(int id) {
        this.employeeId = id;
    }
    public String getName() {
        return name;
    }
    public void setEmployeeName(String name) {
        this.name = name;
    }
}

   And to illustrate the point of this pattern:
public class Main {
    public static void main(String[] args) {
        EmployeeDAO employeeDao = new EmployeeDAOImpl();

        for(Employee employee : employeeDao.getAllEmployees()) {
            System.out.println("Employee info: |Name: " + employee.getName() + ", ID: " + employee.g
etEmployeeId() + "|");
        }
    }
}

   Running this piece of code will yield:
Employee info: |Name: David, ID: 5|
Employee info: |Name: Scott, ID: 7|
Employee info: |Name: Jessica, ID: 12|
Employee info: |Name: Rebecca, ID: 16|

Front Controller Pattern
   Upon sending a request, the Front Controller is the first controller it reaches. Based on
   the request, it decides which controller is the most adequate to handle it, after which it
   passes the request to the chosen controller.

   The Front Controller is most often used in Web Applications in the form of a Dispatcher
   Servlet.

Implementation
   For this implementation, we'll be defining two simple views, a FrontController and a
   Dispatcher:
public class MainView {
    public void showView() {
        System.out.println("Showing main view.");
    }
}

public class EmployeeView {
    public void showView() {
        System.out.println("Showing Employee view.");
    }
}

   A request for either of these two can come up at any point. We use the Dispatcher to deal
   with the request, pointing to the correct view, after the FrontController processed the
   request initially:
public class Dispatcher {
    private MainView mainView;
    private EmployeeView employeeView;

    public Dispatcher() {
        mainView = new MainView();
        employeeView = new EmployeeView();
    }

    public void dispatch(String request) {
        if(request.equalsIgnoreCase("EMPLOYEE")) {
            employeeView.showView();
        } else {
            mainView.showView();
        }
    }
}

public class FrontController {
    private Dispatcher dispatcher;

    public FrontController() {
        dispatcher = new Dispatcher();
    }

    private boolean isAuthenticUser() {
        System.out.println("User has successfully authenticated.");
        return true;
    }

    private void trackRequest(String request) {
        System.out.println("Request: " + request);
    }

    public void dispatchRequest(String request) {
        trackRequest(request);

        if(isAuthenticUser()) {
            dispatcher.dispatch(request);
        }
    }
}

   And to illustrate the point of the pattern:
public class Main {
    public static void main(String[] args) {
        FrontController frontController = new FrontController();
        frontController.dispatchRequest("MAIN");
        frontController.dispatchRequest("EMPLOYEE");
    }
}

   Running this piece of code will yield:
Request: MAIN
User has successfully authenticated.
Showing main view.
Request: EMPLOYEE
User has successfully authenticated.
Showing Employee view.

Intercepting Filter Pattern
   Filters are used before the request is even passed to the adequate controllers for
   processing. These filters can exist in the form of a Filter Chain and include multiple
   filters, or simply exist as one Filter.

   Nevertheless, they run checks on authorization, authentication, supported browsers, whether
   the request path violates any constraints and restrictions etc.

Implementation
   We'll make a simple filter chain with a couple of filters to intercept the request after
   reaching the target.

   Let's start off with defining an interface for the Filter itself:
public interface Filter {
    public void execute(String request);
}

   And a couple of concrete implementations:
public class AuthenticationFilter implements Filter {
    @Override
    public void execute(String request) {
        System.out.println("Authentication request: " + request);
    }
}

public class DebuggingFilter implements Filter {
    @Override
    public void execute(String request) {
        System.out.println("Logging request: " + request);
    }
}

   And finally, the Target of the request:
public class Target {
    public void execute(String request) {
        System.out.println("Executing request: " + request);
    }
}

   By defining a FilterChain, we can add multiple filters to intercept a request. Let's define
   one for our two filters:
public class FilterChain {
    private List<Filter> filters = new ArrayList<>();
    private Target target;

    public void addFilter(Filter filter) {
        filters.add(filter);
    }

    public void execute(String request) {
        for (Filter filter : filters) {
            filter.execute(request);
        }
        target.execute(request);
    }

    public void setTarget(Target target) {
        this.target = target;
    }
}

   We now need a manager class to help manage this FilterChain:
public class FilterManager {
    FilterChain filterChain;

    public FilterManager(Target target) {
        filterChain = new FilterChain();
        filterChain.setTarget(target);
    }

    public void addFilter(Filter filter) {
        filterChain.addFilter(filter);
    }

    public void filterRequest(String request) {
        filterChain.execute(request);
    }
}

   And finally, the Client will use the FilterManager to send a request to the application:
public class Client {
    FilterManager filterManager;

    public void setFilterManager(FilterManager filterManager) {
        this.filterManager = filterManager;
    }

    public void sendRequest(String request) {
        filterManager.filterRequest(request);
    }
}

   Now to illustrate the point of this pattern:
public class Main {
    public static void main(String[] args) {
        FilterManager filterManager = new FilterManager(new Target());
        filterManager.addFilter(new AuthenticationFilter());
        filterManager.addFilter(new DebuggingFilter());

        Client client = new Client();
        client.setFilterManager(filterManager);
        client.sendRequest("Index");
    }
}

   Running this piece of code will yield:
Authentication request: Index
Logging request: Index
Executing request: Index

   The request has been put through both filters from the FilterChain, before being forwarded
   to the Target.

Service Locator Pattern
   A pattern often seen in Web Applications, the Service Locator pattern is used to decouple
   the Service Consumers and the concrete classes like DAO implementations.

   The pattern looks for the adequate service, saves it in cache storage to reduce the number
   of requests and therefore the strain on the server and provides the application with their
   instances.

Implementation
   Let's start this implementation by defining a common Service interface:
public interface Service {
    public String getServiceName();
    public void execute();
}

   A couple of concrete classes will implement this interface:
public class EmployeeService implements Service {
    @Override
    public String getServiceName() {
        return "Employee Service";
    }

    @Override
    public void execute() {
        System.out.println("Executing Employee Service...");
    }
}

public class CustomerService implements Service {
    @Override
    public String getServiceName() {
        return "Customer Service";
    }

    @Override
    public void execute() {
        System.out.println("Executing Customer Service...");
    }
}

   According to the pattern, when looking up for these services, we should cache them to
   reduce server strain:
public class Cache {
    private List<Service> services;

    public Cache() {
        services = new ArrayList<Service>();
    }

    public Service getService(String serviceName) {
        for(Service service : services) {
            if(service.getServiceName().equalsIgnoreCase(serviceName)) {
                System.out.println("Returning cached " + serviceName);
                return service;
            }
        }
        return null;
    }

    public void addService(Service newService) {
        boolean exists = false;

        for(Service service : services){
            if(service.getServiceName().equalsIgnoreCase(newService.getServiceName())) {
                exists = true;
            }
        }
        if(!exists) {
            services.add(newService);
        }
    }
}

   We also need a class to look for, and instantiate our services:
public class InitialContext {
    public Object lookup(String jndiName) {
        if(jndiName.equalsIgnoreCase("EmployeeService")) {
            System.out.println("Looking up and initializing Employee Service...");
            return new EmployeeService();
        } else if(jndiName.equalsIgnoreCase("CustomerService")) {
            System.out.println("Looking up and initializing Customer Service...");
            return new CustomerService();
        }
        return null;
    }
}

   And finally, we can define a Locator class to expose to the client, that uses the
   InitialContext class to look for services, and the Cache class to cache them for further
   use.
public class Locator {
    private static Cache cache;

    static {
        cache = new Cache();
    }

    public static Service getService(String jndiName) {
        Service service = cache.getService(jndiName);

        if(service != null) {
            return service;
        }

        InitialContext context = new InitialContext();
        Service service1 = (Service)context.lookup(jndiName);
        cache.addService(service1);
        return service1;
    }
}

   And to illustrate the point of this pattern:
public class Main {
    public static void main(String[] args) {
        Service service = Locator.getService("EmployeeService");
        service.execute();
        service = Locator.getService("CustomerService");
        service.execute();
    }
}

   Running this piece of code will yield:
Looking up and initializing Employee Service...
Executing Employee Service...
Looking up and initializing Customer Service...
Executing Customer Service...

Transfer Object Pattern
   This pattern is used to transfer objects with lots of fields and parameters in one go. The
   Transfer Object pattern employs new objects, used only for transfer purposes, usually
   passed to the DAO.

   These objects are serializable POJOs. They have fields, their respective getters and
   setters, and no other logic.

Implementation
   An object may look like this:
public class EmployeeVO {
    private int employeeId;
    private String name;

    public EmployeeVO(int employeeId, String name) {
        this.employeeId = employeeId;
        this.name = name;
    }

    public int getEmployeeId() {
        return employeeId;
    }

    public void setEmployeeId(int id) {
        this.employeeId = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

   Please note that the object contains only a few fields for brevity.

   An example of a new object, that's employed for transfer purposes only:
public class EmployeeBO {
    List<EmployeeVO> employees;

    public EmployeeBO() {
        employees = new ArrayList<>();
        EmployeeVO david = new EmployeeVO(1, "David");
        EmployeeVO scott = new EmployeeVO(2, "Scott");
        EmployeeVO jessica = new EmployeeVO(3, "Jessica");
        employees.add(david);
        employees.add(scott);
        employees.add(jessica);
    }

    public void deleteEmployee(EmployeeVO employee) {
        employees.remove(employee.getEmployeeId());
        System.out.println("Employee with ID: " + employee.getEmployeeId() + " was successfully dele
ted.");
    }

    public List<EmployeeVO> getAllEmployees() {
        return employees;
    }

    public EmployeeVO getEmployee(int id) {
        return employees.get(id);
    }

    public void updateEmployee(EmployeeVO employee) {
        employees.get(employee.getEmployeeId()).setName(employee.getName());
        System.out.println("Employee with ID: " + employee.getEmployeeId() + " successfully updated.
");
    }
}

   And to illustrate the point of the pattern:
public class Main {
    public static void main(String[] args) {
        EmployeeBO employeeBo = new EmployeeBO();

        for(EmployeeVO employee : employeeBo.getAllEmployees()) {
            System.out.println("Employee: |" + employee.getName() + ", ID: " + employee.getEmployeeI
d() + "|");
        }

        EmployeeVO employee = employeeBo.getAllEmployees().get(0);
        employee.setName("Andrew");
        employeeBo.updateEmployee(employee);

        employee = employeeBo.getEmployee(0);
        System.out.println("Employee: |" + employee.getName() + ", ID: " + employee.getEmployeeId()
+ "|");

    }
}

   Running this piece of code will yield:
Employee: |David, ID: 1|
Employee: |Scott, ID: 2|
Employee: |Jessica, ID: 3|
Employee with ID: 1 successfully updated.
Employee: |Andrew, ID: 1|

Conclusion
   With this, all J2EE Design Patterns in Java are fully covered, with working examples.

   This concludes our short series of articles on Java Design Patterns.


---
