https://javabeginnerstutorial.com/core-java-tutorial/inner-class/

Inner Class
April 21, 2012

   Java Inner classes are class within Class. Inner class instance has special relationship
   with Outer class. This special relationship gives inner class access to member of outer
   class as if they are the part of outer class.

        Note: Java Inner class instance has access to all member of the outer class(Public, Private
        & Protected)

Syntax for creating Inner Class

//outer class
class OuterClass {
    //inner class
    class InnerClass {
    }
}

Type of Inner class
     * Static
     * Method Local
     * Anonymous
     * Other then above these normal inner class

Normal Inner Class
   Inner classes which are not method local , static or anonymous are normal inner class.
//outer class
class OuterClass {
    //inner class
    class InnerClass {
    }
}

   If you compile above code it will produce two class file.
outer.class
inner$outer.class

         Note: You can't directly execute the inner class's .class file with java command.

   As it is not static inner class so we can't use static keyword with it.

How to access Inner Class
   Inner class can be accessed only through live instance of outer class.

  Within Outer Class
   Outer class can create instance of the inner class in the same way as normal class member.
class OuterClass {
    private int i = 9;

    // Creating instance of inner class and calling inner class function
    public void createInner() {
        InnerClass i1 = new InnerClass();
        i1.getValue();
    }

    // inner class declarataion
    class InnerClass {
        public void getValue() {
            // accessing private variable from outer class
            System.out.println("value of i -" + i);
        }
    }
}

  From Outside Outer Class
   Create outer class instance and then inner class instance.

class MainClass {

    public static void main(String[] args) {
        // Creating outer class instance
        OuterClass outerclass = new OuterClass();

        // Creating inner class instance
        OuterClass.InnerClass innerclass = outerclass.new InnerClass();

        // Classing inner class method
        innerclass.getValue();
    }
}

   Above code can also be replaced with
OuterClass.InnerClass innerClass = new OuterClass.new InnerClass();

  this keyword
   There are some rules associated with [37]this and it refer the currently executing Object.
   So in case of Inner class "this" keyword will refer the currently executing inner class
   Object. But to get this for outer class use "OuterClass.this".

  Modifiers Applied
   Normal inner class will be treated like member of the outer class so it can have several
   [38]Modifiers as opposed to Class.
          + final
          + abstract
          + public
          + private
          + protected
          + strictfp

   Note: Don't get confused with the modifiers of Class and Inner Class. They are completely
   different.

Method Local Inner Class
   When an inner class is defined inside the method of Outer Class it becomes Method local
   inner class.

  Syntax for Creating Method Local Inner Class

class OuterClass {
    private int i = 9;

    // Creating instance of inner class and calling inner class function
    public void innerMethod() {
        // inner class declarataion inside method
        class InnerClass {
            public void getValue() {
                // accessing private variable from outer class
                System.out.println("value of i -" + i);
            }
        }
        //inner class instance creation
        InnerClass i1 = new InnerClass();
        i1.getValue();
    }
}

   Now definition of inner class is inside a method in Outer class. Still the instance of the
   outer class can be created but only after definition of inner class as you can see above.

        Note:
     * Method local inner class can be instantiated within the method where it is defined and
       no where else.
     * Method local inner class can not use the variable defined in method where it id defined
       still it can use the instance variable.
     * If method local variable is "Final" method local inner class can use it.(* Now variable
       is Final)

  Modifiers Applied to Method Local Inner Class
   Method local inner classes are eligible for modifiers like local variable so an method
   local inner class can have final or abstract.

Cheatsheet
     * Inner class is member of enclosing class.
     * Outer class reference is required to initiate inner class.
     * Inner class are of 4 type.
     * Inner classes defined within method are method local inner class.
     * Method local inner class can not access method local variable.
     * Final & Abstract are the only modifiers available to method local inner class.
     * Ananymous inner class don't have any name.
     * Inner classes having Static modifier are known as Static inner class.
     * Static nested class can not access non static member of outer class.


---
https://www.quora.com/Why-do-we-need-inner-classes-in-Java

Why do we need inner classes in Java?

***
   Inner classes are used for logical grouping of classes. In cases where your class B is used
   only by class A it's better to put Class B as an inner class to Class A. This improves
   encapsulation and readability of the code. We have different ways to implement inner class
   a) static nested class b) inner class c) anonymous class. We have to understand basic
   differences between them to use it efficiently.

   a)
   Static nested class: Static nested class do not have access to the non static members of
   its enclosed class. So static nested class is just like any other top level classes. You
   don't need instance of parent class to access the static nested class. Static nested class
   can be effectively used for singleton object
   creation ( i don't usually prefer singleton creation unless its required for use case which
   is rare scenario ) . But this is fairly simpler way for singleton object creation than enum
   and DCL.

   Eg for static nested class: Entry class in Linked list class.

   b)
   Inner class: This allows you to share some members between the parent and inner class. You
   need an instance of parent class to create instance of inner class. In this case, you
   define inner class because it makes sense to define some functionality inside a separate
   class (inner class) but still parent class should be able to access it. This is more than
   just logical grouping.

   E.g.: ListItr class inside linked list class

   c)
   Anonymous class: This is not actually an inner class. If you want to implement a
   functionality only once, then it makes no sense to define a separate class. So in this
   case, you can define anonymous class.



---
https://www.geeksforgeeks.org/nested-classes-java/

Nested Classes in Java

   In java, it is possible to define a class within another class, such classes are known as
   nested classes. They enable you to logically group classes that are only used in one place,
   thus this increases the use of [160]encapsulation, and create more readable and
   maintainable code.
     * The scope of a nested class is bounded by the scope of its enclosing class. Thus in
       above example, class NestedClass does not exist independently of class OuterClass.
     * A nested class has access to the members, including private members, of the class in
       which it is nested. However, reverse is not true i.e. the enclosing class does not have
       access to the members of the nested class.
     * A nested class is also a member of its enclosing class.
     * As a member of its enclosing class, a nested class can be declared private, public,
       protected, or package private(default).
     * Nested classes are divided into two categories:
         1. static nested class : Nested classes that are declared static are called static
            nested classes.
         2. inner class : An inner class is a non-static nested class.

   Syntax:
class OuterClass
{
...
    class NestedClass
    {
        ...
    }
}

                                      Static nested classes

   As with class methods and variables, a static nested class is associated with its outer
   class. And like static class methods, a static nested class cannot refer directly to
   instance variables or methods defined in its enclosing class: it can use them only through
   an object reference.
   They are accessed using the enclosing class name.
OuterClass.StaticNestedClass

   For example, to create an object for the static nested class, use this syntax:
OuterClass.StaticNestedClass nestedObject =
     new OuterClass.StaticNestedClass();

   // Java program to demonstrate accessing
   // a static nested class

   // outer class
   class OuterClass
   {
       // static member
       static int outer_x = 10;

       // instance(non-static) member
       int outer_y = 20;

       // private member
       private static int outer_private = 30;

       // static nested class
       static class StaticNestedClass
       {
           void display()
           {
               // can access static member of outer class
               System.out.println("outer_x = " + outer_x);

               // can access display private static member of outer class
               System.out.println("outer_private = " + outer_private);

               // The following statement will give compilation error
               // as static nested class cannot directly access non-static membera
               // System.out.println("outer_y = " + outer_y);

           }
       }
   }

   // Driver class
   public class StaticNestedClassDemo
   {
       public static void main(String[] args)
       {
           // accessing a static nested class
           OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();

           nestedObject.display();

       }
   }


                                          Inner classes

   To instantiate an inner class, you must first instantiate the outer class. Then, create the
   inner object within the outer object with this syntax:
OuterClass.InnerClass innerObject = outerObject.new InnerClass();

   There are two special kinds of inner classes :
    1. Local inner classes
    2. Anonymous inner classes

   // Java program to demonstrate accessing
   // a inner class

   // outer class
   class OuterClass
   {
       // static member
       static int outer_x = 10;

       // instance(non-static) member
       int outer_y = 20;

       // private member
       private int outer_private = 30;

       // inner class
       class InnerClass
       {
           void display()
           {
               // can access static member of outer class
               System.out.println("outer_x = " + outer_x);

               // can also access non-static member of outer class
               System.out.println("outer_y = " + outer_y);

               // can also access private member of outer class
               System.out.println("outer_private = " + outer_private);

           }
       }
   }

   // Driver class
   public class InnerClassDemo
   {
       public static void main(String[] args)
       {
           // accessing an inner class
           OuterClass outerObject = new OuterClass();
           OuterClass.InnerClass innerObject = outerObject.new InnerClass();

           innerObject.display();

       }
   }

   Output:
outer_x = 10
outer_y = 20
outer_private = 30

                 Difference between static and inner(non-static nested) classes
     * Static nested classes do not directly have access to other members(non-static variables
       and methods) of the enclosing class because as it is static, it must access the
       non-static members of its enclosing class through an object. That is, it cannot refer
       to non-static members of its enclosing class directly. Because of this restriction,
       static nested classes are seldom used.
     * Non-static nested classes (inner classes) has access to all members(static and
       non-static variables and methods, including private) of its outer class and may refer
       to them directly in the same way that other non-static members of the outer class do.
       This article is contributed by Gaurav Miglani. If you like GeeksforGeeks and would like
       to contribute, you can also write an article using [164]contribute.geeksforgeeks.org or
       mail your article to contribute@geeksforgeeks.org. See your article appearing on the
       GeeksforGeeks main page and help other Geeks.
       Please write comments if you find anything incorrect, or you want to share more
       information about the topic discussed above.


---
https://dzone.com/articles/what-are-nested-classes-and

What are Nested Classes and Why Do We Need Them?
Apr. 06, 15

   If a class A is declared inside another class B then that class A is a nested class. It is
   a member of enclosing class. If a nested class is marked static then it is called static
   nested class and if it not then it is called non-static nested class or inner class.

   There is nothing called top level static class or static inner class. We only have static
   nested class.

Why do we need nested class?
   As per [33]Oracle's official page:
    1. If a class is useful to only one other class then it seems logical to embed this class
       as a nested class. For example if a class RedBlackNode (represents node of a Red Black
       Tree) is used only by class RedBlackTree then it makes sense to make RedBlackNode a
       nested class in the class RedBlackTree.So it is a  way of logically grouping classes
       that are only used in one place.
    2. A nested class increases encapsulation. Consider a class A whose members are declared
       private, but class B needs to access them. In that case we can hide class B in A and B
       can access members of A in spite of the fact that they are private. Also B can be
       hidden from outside world when declared private.
    3. It can lead to more readable and maintainable code.

Is nested class violation of encapsulation?
   Some developers feel that nested class is an extreme violation of nested class. IMO this
   feature is safe if it is used safely. It is not a violation of encapsulation and does not
   violate programming principle. As I mentioned above nested class B (when declared private)
   is hidden from outside world and it needs to be part of class A in some ways, also members
   of class A are still private, so IMO it is perfectly fine and follows [34]Single
   Responsibility Principle. If you are not sure whether you need a nested class or not then I
   believe it is better to avoid them, but if you really need them then it is fine to use
   them.

How do we use static nested class and non-static nested class (inner class)?
   Static nested classes are always accessed using the enclosing class's name.
OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();

   An instance of inner class (non-static class) can exist only with in an instance of Outer
   class.
OuterClass.InnerClass innerObject = outerObject.new InnerClass();

Types of Non-static nested class (Inner Class)
   There are two types: anonymous and local. We generally use an anonymous class (class with
   no name) when we create an instance of a class with some overloading of a method, without
   having to subclass a class. We can simply instantiate anonymous inner class without making
   a separate class. The classical example of [35]anonymous class is initializing an anonymous
   class for Runnable interface:
Thread thread = new Thread(new Runnable() {
        @Override
        public void run() {
            System.out.println("New Thread started.");
        }
    });

   IMO, after Java 8 it makes more sense to make use of Lambda expression in such places to
   replace anonymous class as below:
Thread thread = new Thread(() -> System.out.println("New Thread started"));

   Another type is [36]local class. Local classes are classes that are defined in a block,
   which is a group of zero or more statements between balanced braces. We typically find
   local classes defined in the body of a method.
public class ValidateUser {
    public void validateEmails(String emailId, String alternativeEmailId) {

        final int emailIdLength = 20;

        class Email {

            String formattedEmail;

            Email(String email) {
                 if(email.length() == emailIdLength)
                    formattedEmail = email;
                else
                    formattedEmail = null;
            }

            public String getFormattedEmail() {
                return formattedEmail;
            }

            // Valid in JDK 8 and later
            public void printOriginalEmailId() {
                System.out.println("Original email id is: " + emailId);
            }

        }

        Email email = new Email(emailId);
        if(email.getFormattedEmail() == null) {
            System.out.println("Email is invalid");
        }

        Email alternativeEmail = new Email(alternativeEmailId);
        if(alternativeEmail.getFormattedEmail() == null) {
            System.out.println("Alternative email is invalid");
        }

    } // method validateEmails ends here.
}

   In the above example method validateEmails validates the emails provided by the user. It
   defines a local inner class Email to represent the email-id for a user. A local class has
   access to members of enclosing class. It also has access to local variables that are
   declared final. In the above example field emailIdLength is final and can be accessed in
   the constructor of the local class Email.

   However starting in Java 8 there are two changes:
    1. A local class can access local variables and parameters of the enclosing block that
       are final or effectively final. A variable or parameter whose value is never changed
       after it is initialized is effectively final. Suppose the variable emailIdLength is not
       final and its value is changed in the constructor of local class Email, in that case
       this variable is not effectively final and compiler will complain.
    2. If we declare the local class in a method it can access the parameters of the enclosing
       method. In the above example the method printOriginalEmailId was able to access the
       method parameter emailId.

Should I always mark a nested class static?
   As [37]Jon Skeet points out, it is a better idea if we need a nested class then to start
   with a static nested class and then decide if it really needs to be non-static (inner
   class) based on the usage. Whenever we see an inner class we need to decide whether we
   really need it with extra complexity and implicit (rather than explicit and more clean)
   reference to the outer containing class?

   If an instance of inner class is strongly referenced then the outer instance is strongly
   referenced too. This can lead to some confusion when the outer instance is not garbage
   collected even though it appears that nothing references it. We must remember that an inner
   class maintains an implicit reference to the instance of outer class.

   How to figure out if we need an inner class (non-static nested class) ?

   The point to note is: Inner classes are not allowed to have static methods or fields. If we
   feel that we are passing a lot of stuff in the constructor of a top level class then it is
   an hint that we can make use of an inner class. An inner class can see all the fields of
   the outer class, it means we don't have to deal with the outer class fields as if they come
   from an outer class.

Difference between static nested class and non-static nested (inner class) class
   Static Nested class
   Non-static nested class (Inner class)
   Does not need instance of outer class as it is not associated with any instance of outer
   class.
   Needs instance of outer class for initialization.
   Uses static keyword so it means it is static member of the outer class and can be accessed
   like that.
   Not a static member and every instance of inner class needs an implicit reference to
   instance of outer class.
   Nested classes can be imported using static imports in Java.
   Not applicable.

   Inner class needs an instance of outer class for initialization whereas static nested class
   does not need an instance of outer class as it is associated to the whole class and not to
   an instance.
    1. Static nested class is static member and can be accessed like any other static member.
    2. Static nested classes can be imported using static imports in Java.
    3. Static nested classes should always be preferred as explained.

   First of all we need to understand that static keyword can only be applied to a nested
   class and not to outer class. If we make anything final then it becomes constant, something
   that is final value and cannot be changed any further by any means. If a class is final
   then it simply means it cannot be inherited. So if we mark a nested class (static or
   non-static) final then it cannot be inherited, like any regular final class.

Can we mark the nested classes final?
   First of all we need to understand that static keyword can only be applied to a nested
   class and not to outer class. If we make anything final then it becomes constant, something
   that is final value and cannot be changed any further by any means. If a class is final
   then it simply means it cannot be inherited. So if we mark a nested class (static or
   non-static) final then it cannot be inherited, like any regular final class.

Can we extend nested class (static or inner)?
   Yes we can extends both of them. Consider the following class which contains one static
   nested class and one inner class.
public class OuterClass {
    static class StaticNestedClass {
        void display() {
            System.out.println("Inside StaticNestedClass");
        }
    }
    class InnerClass {
        void display() {
            System.out.println("Inside InnerClass");
        }
    }
}

   The following class extends Outerclass and its nested class also extends respective nested
   classes:
public class OuterClassDerivedClass extends OuterClass{
    static class StaticNestedDerivedClass extends OuterClass.StaticNestedClass {
        @Override
        void display() {
            System.out.println("Inside StaticNestedDerivedClass");
        }
    }
    class InnerDerivedClass extends OuterClass.InnerClass {
        @Override
        void display() {
            System.out.println("Inside InnerDerivedClass");
        }
    }
}

   Now we can test these classes as:
public class InheritanceTest {
    public static void main(String[] args) {
        OuterClass outerClass = new OuterClass();
        OuterClass.InnerClass innerClass = outerClass.new InnerClass();
        innerClass.display();
        OuterClass.StaticNestedClass staticNestedClass = new OuterClass.StaticNestedClass();
        staticNestedClass.display();

        OuterClassDerivedClass outerClassDerivedClass = new OuterClassDerivedClass();
        OuterClassDerivedClass.InnerDerivedClass innerDerivedClass = outerClassDerivedClass.new Inne
rDerivedClass();
        innerDerivedClass.display();
        OuterClassDerivedClass.StaticNestedDerivedClass staticNestedDerivedClass = new OuterClassDer
ivedClass.StaticNestedDerivedClass();
        staticNestedDerivedClass.display();
    }
}

   As expected the output will be:

   Inside InnerClass

   Inside StaticNestedClass

   Inside InnerDerivedClass

   Inside StaticNestedDerivedClass

Can a Java File contain more than one public class?
   A Java file can contain only one public class except for public nested classes. Check the
   class below:
public class Sample {
    public class InnerClassOne {
        public void display() {
            System.out.println("In class innerClassOne");
        }
    }
    public class InnerClassTwo {
        public void display() {
            System.out.println("In class innerClassTwo");
        }
    }
    static public class StaticNestedClassOne {
        public void display() {
            System.out.println("In class StaticNestedClassOne");
        }
    }
    static public class StaticNestedClassTwo {
        public void display() {
            System.out.println("In class StaticNestedClassTwo");
        }
    }
}

   This can be tested as:
Sample sample = new Sample();
Sample.InnerClassOne innerClassOne = sample.new InnerClassOne();
Sample.InnerClassTwo innerClassTwo = sample.new InnerClassTwo();

Sample.StaticNestedClassOne staticNestedClassOne = new Sample.StaticNestedClassOne();
Sample.StaticNestedClassTwo staticNestedClassTwo = new Sample.StaticNestedClassTwo();

innerClassOne.display();
innerClassTwo.display();
staticNestedClassOne.display();
staticNestedClassTwo.display();

Can a nested class extend its outer class itself?
   Yes it can. If we look inside the class Arc2D in java.awt.geom package, we will notice that
   it has static nested class Float and Double which extend the outer class itself.
public abstract class Arc2D extends RectangularShape {
  public static class Float extends Arc2D implements Serializable { .. }
  public static class Double extends Arc2D implements Serializable { .. }
}

   This is done to logically group the classes and their logic. If a user wishes to use
   abstract class Arc2D then it is helpful to find the implementations that they can use in
   the class itself.

   In the similar way a non-static nested class or inner class can also extend its own outer
   class. But why would we want an inner class to extend its outer class? For example we can
   have an outer class Car which can have an inner class Wheel and every instance of Car must
   be having an instance of Wheel. Now it does not make conceptual sense for an inner class to
   extend its outer class. IMO that would be a problematic design and should be avoided.


---
https://www.programmerinterview.com/java-questions/when-to-use-inner-classes-in-java/

When should inner classes be used in Java?

   Inner classes were introduced in version 1.1 of Java. Ever since they were introduced they
   inspired a lot of different opinions among people – but we won't present any opinions here,
   just facts. Knowing when to use inner classes is very important, because using inner
   classes in the wrong situations can lead to code that's difficult to understand and
   maintain.

A class can be a member of another class, which is an inner class

   Inner classes allow you to define one class inside another class – which is why they are
   called "inner" classes. A class can have member classes, just like how classes can have
   member variables and methods. There are many different types of inner classes, but we won't
   get into the different types of inner classes since the purpose of this article is just to
   explain when and why you should use inner classes in Java.

   In object oriented programming you are probably aware of the fact that classes need to be
   specialized because it allows for greater reuse and flexibility. This is because a class
   only needs code that allows an object of that class to do whatever it needs to do, and no
   more.

   But, there are other situations when you actually need to write some code that seems like
   it belongs in it's very own class. But, at the same time, the code that you want to write
   needs to be intimately tied to some other class's code. So, the question is what to do in
   this situation? Well, this is where inner classes are very useful. Don't worry if you are
   confused – we have a simple example to help you understand why inner classes are necessary,
   and how they can help you.

An example of when inner classes are necessary
   Suppose you have a Java GUI (Graphical User Interface) class that acts as a chat client
   like Gchat or Facebook Chat. Think about what methods would need to be present in a class
   like that which represents a chat client – you will need a method that will read user input
   from the chat box, methods to actually send the user input to the server and to whoever the
   user is chatting with, even a method that detects that you are typing so that Gchat can
   display the "XZY is typing" text to your friends, etc.

Event handlers
   But, there is one key thing missing here. How exactly will those methods be called? Well,
   as an example, think about how Gchat works – you type in some text and when you are ready
   to send it to whoever you're chatting with, you press the "Enter" or "Return" key on your
   keyboard. So, the "Enter" key could be considered one event that triggers a call to one of
   the methods we mentioned earlier. And, if our chat client class wants to detect if someone
   is typing in a window, then clearly the event that would trigger the call is someone typing
   – so we would need some code to detect when someone is actually typing in a window in real
   time – basically when they are pressing a button inside their chat window.

   So, these events – like typing in a window and pressing the "RETURN" key – will also need
   some methods to detect when they occur, and those event handling methods can then call the
   appropriate chat client methods. For example, when the event handler method that handles
   the "RETURN" key button pressed event is called, then that method can call the method to
   send the user input to the server.

There are two types of methods needed in our example
   So, it should be clear that there will need to be two different types of methods that will
   drive your chat client application: 1. Chat client specific methods like those that will
   read user input from the chat box and send user input to the server. 2. Event handling
   methods that will respond to actual events that occur in the chat client window – like
   hitting the "RETURN" key, detecting consistent typing, etc.

   Because it's clear that there will need to be two different types of methods, then from an
   Object Oriented Design perspective, it seems like we should have two different classes: one
   class for the chat client specific methods and one class for the event handling methods.
   That does follow the normal object oriented design practices – because we are creating
   classes that specialize in what they do.

The problem with having two separate classes
   But, in this particular example, there is a problem with having two separate classes. And
   that problem is the fact that the event handling code is very much related/tied to the code
   that belongs to the chat client. This makes sense, as we talked about earlier with our
   GChat example; as soon as a user in GChat hits "RETURN" or "ENTER" on the keyboard that
   should trigger an event, which should then grab the text from the chat client window. And,
   the chat client window would be a particular instance (basically an object) of the chat
   client class. For example, if you are talking to your friend Bob in GChat, he will have one
   window in Gmail and you will have one window open in Gmail, and each window is an object of
   the chat client class. So there will be two separate objects of the chat client class – one
   for you and one for Bob.

   Now, if Bob types something and hits the RETURN key, the event handler code that responds
   to the RETURN key being pushed will need to be able to communicate with Bob's chat client
   class object so that it can grab the text from Bob's chat client class window, or the text
   field where that text is actually stored. The key here is thinking in terms of objects – an
   object of the chat client class is created for each person using GChat, so you will have
   your own object and Bob will have his own object. This means that the event handling code
   will need to access an chat client object's text field – which is a member of the class,
   and an instance variable. So, it should be clear that the event handling code needs access
   to the members of a chat client class object in order to be able to effectively help.

Why don't we just combine the event handling code with the chat client code?
   Combining the event handling methods with the chat client specific methods in one big class
   sounds like a good idea at first, but there is one big problem: If both the event handling
   code and the chat client code need to inherit some code from different classes then you are
   in trouble, because Java does not support [626]multiple inheritance – meaning that our one
   "big class" can not inherit from two different classes.
   [INS: :INS]

   This means that we want some sort of solution where the event handling code is in it's very
   own class – which would allow it to inherit from any class it needs, because it's not
   bundled together in one class with the chat client code as well. This is also better object
   oriented design. But, we also want the event handling class to have easy access to the chat
   client's member variables – even the private instance variables. One possible solution is
   to make everything in the chat client class public so that anyone can access it, including
   the event handling code. But, making everything public is a bad idea.

Inner classes to the rescue
   Now, this is why inner classes were created – for situations exactly like the one we
   described above. An instance of an inner class can access members of an instance of the
   outer class, because an inner class is just another member of the outer class. And, inner
   classes can even access the private members of the outer class – yes you did read that
   correctly!

Does an inner class violate encapsulation?
   No, an inner class does not violate encapsulation because of the fact that an inner class
   is authored by the same person who created the outer class – so having an inner class was
   an intentional design decision.

What about nested classes? Are nested classes the same thing as inner classes?
   You've probably heard the term nested class as well, and may be confused as to what the
   difference between an inner class and a nested class is – you can read about the difference
   here:    Inner versus nested classes
            [https://www.programmerinterview.com/index.php/java-questions/inner-vs-nested-classes/]
            --> HERE: jv_inner-classes_multif_20190423.txt


---
https://www.geeksforgeeks.org/anonymous-inner-class-java/¸

Anonymous Inner Class in Java

Prerequisites :- Nested Classes in Java
It is an inner class without a name and for which only a single object is created. An anonymous inner class
can be useful when making an instance of an object with certain “extras” such as overloading methods of a
class or interface, without having to actually subclass a class.

Anonymous inner classes are useful in writing implementation classes for listener interfaces in graphics
programming.

Anonymous inner class are mainly created in two ways:

    Class (may be abstract or concrete)
    Interface

Syntax: The syntax of an anonymous class expression is like the invocation of a constructor, except that there
is a class definition contained in a block of code.

// Test can be interface,abstract/concrete class
Test t = new Test()
{
   // data members and methods
   public void test_method()
   {
      ........
      ........
    }
};

To understand anonymous inner class, let us take a simple program


filter_none

edit

play_arrow

brightness_4
//Java program to demonstrate need for Anonymous Inner class
interface Age
{
    int x = 21;
    void getAge();
}
class AnonymousDemo
{
    public static void main(String[] args)
    {
        // Myclass is implementation class of Age interface
        MyClass obj=new MyClass();

        // calling getage() method implemented at Myclass
        obj.getAge();
    }
}

// Myclass implement the methods of Age Interface
class MyClass implements Age
{
    @Override
    public void getAge()
    {
        // printing the age
        System.out.print("Age is "+x);
    }
}

In the program, interface Age is created with getAge() method and x=21.  Myclass is written as implementation
class of Age interface. As done in Program, there is no need to write a  separate class Myclass. Instead,
directly copy the code of Myclass into this parameter, as shown here:

Age oj1 = new Age() {
            @Override
            public void getAge() {
                System.out.print("Age is "+x);
            }
        };

Here, an object to Age is not created but an object of Myclass is created and copied in the entire class code
as shown above. This is possible only with anonymous inner class. Such a class is called ‘anonymous inner class’,
so here we call ‘Myclass’ as anonymous inner class.

Anonymous inner class version of the above Program
filter_none

edit

play_arrow

brightness_4
//Java program to demonstrate Anonymous inner class
interface Age
{
    int x = 21;
    void getAge();
}
class AnonymousDemo
{
    public static void main(String[] args) {

        // Myclass is hidden inner class of Age interface
        // whose name is not written but an object to it
        // is created.
        Age oj1 = new Age() {
            @Override
            public void getAge() {
                 // printing  age
                System.out.print("Age is "+x);
            }
        };
        oj1.getAge();
    }
}

Types of anonymous inner class : Based on declaration and behavior, there are 3 types of anonymous Inner classes:

        Anonymous Inner class that extends a class : We can have an anonymous inner class that extends
        a class.For example,we know that we can create a thread by extending a Thread class. Suppose we need
        an immediate thread but we don’t want to create a class that extend Thread class all the time. By the
        help of this type of Anonymous Inner class we can define a ready thread as follows:
        filter_none

        edit

        play_arrow

        brightness_4
        //Java program to illustrate creating an immediate thread
        //Using Anonymous Inner class that extends a Class
        class MyThread
        {
            public static void main(String[] args)
            {
                //Here we are using Anonymous Inner class
                //that extends a class i.e. Here a Thread class
                Thread t = new Thread()
                {
                    public void run()
                    {
                        System.out.println("Child Thread");
                    }
                };
                t.start();
                System.out.println("Main Thread");
            }
        }

        Output:

        Main Thread
        Child Thread
        OR
        Child Thread
        Main Thread

        Anonymous Inner class that implements a interface : We can also have an anonymous inner class that
        implements an interface.For example, we also know that by implementing Runnable interface we can
        create a Thread. Here we use anonymous Inner class that implements an interface.
        filter_none

        edit

        play_arrow

        brightness_4
        //Java program to illustrate defining a thread
        //Using Anonymous Inner class that implements an interface
        class MyThread
        {
            public static void main(String[] args)
            {
                //Here we are using Anonymous Inner class
                //that implements a interface i.e. Here Runnable interface
                Runnable r = new Runnable()
                {
                    public void run()
                    {
                        System.out.println("Child Thread");
                    }
                };
                Thread t = new Thread(r);
                t.start();
                System.out.println("Main Thread");
            }
        }

        Output:

        Main Thread
        Child Thread
        OR
        Child Thread
        Main Thread

        Anonymous Inner class that defines inside method/constructor argument : Anonymous inner classes in
        method/constructor arguments are often used in graphical user interface (GUI) applications. To get you
        familiar with syntax lets have a look on the following program that creates a thread using this type
        of Anonymous Inner class :
        filter_none

        edit

        play_arrow

        brightness_4
        //Java program to illustrate defining a thread
        //Using Anonymous Inner class that define inside argument
        class MyThread
        {
            public static void main(String[] args)
            {
                //Here we are using Anonymous Inner class
                //that define inside argument, here constructor argument
                Thread t = new Thread(new Runnable()
                {
                    public void run()
                    {
                        System.out.println("Child Thread");
                    }
                });

                t.start();

                System.out.println("Main Thread");
            }
        }

        Output:

        Main Thread
        Child Thread
        OR
        Child Thread
        Main Thread

Difference between Normal/Regular class and Anonymous Inner class:

    A normal class can implement any number of interfaces but anonymous inner class can implement only one
    interface at a time.
    A regular class can extend a class and implement any number of interface simultaneously. But anonymous
    Inner class can extend a class or can implement an interface but not both at a time.
    For regular/normal class, we can write any number of constructors but we cant write any constructor for
    anonymous Inner class because anonymous class does not have any name and while defining constructor class
    name and constructor name must be same.

Accessing Local Variables of the Enclosing Scope, and Declaring and Accessing Members of the Anonymous Class
Like local classes, anonymous classes can capture variables; they have the same access to local variables of
the enclosing scope:

    An anonymous class has access to the members of its enclosing class.
    An anonymous class cannot access local variables in its enclosing scope that are not declared as final or
    effectively final.
    Like a nested class, a declaration of a type (such as a variable) in an anonymous class shadows any other
    declarations in the enclosing scope that have the same name.

Anonymous classes also have the same restrictions as local classes with respect to their members:

    We cannot declare static initializers or member interfaces in an anonymous class.
    An anonymous class can have static members provided that they are constant variables.

Note that you can declare the following in anonymous classes:

    Fields
    Extra methods (even if they do not implement any methods of the supertype)
    Instance initializers
    Local classes

However, constructors can not be declared in an anonymous class.


---
