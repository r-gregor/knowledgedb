filename: jv_access-a-resources-outside-a-jar-from-the-jar-multif_20200818.txt
https://stackoverflow.com/questions/8775303/read-properties-file-outside-jar-file

Read properties file outside JAR file

   I have a JAR file where all my code is archived for running. I have to access a properties file which
   need to be changed/edited before each run. I want to keep the properties file in the same directory
   where the JAR file is. Is there anyway to tell Java to pick up the properties file from that
   directory ?

   Note: I do not want to keep the properties file in home directory or pass the path of the properties
   file in command line argument.

***
   So, you want to treat your .properties file on the same folder as the main/runnable jar as a file
   rather than as a resource of the main/runnable jar. In that case, my own solution is as follows:

   First thing first: your program file architecture shall be like this (assuming your main program is
   main.jar and its main properties file is main.properties):
./ - the root of your program
 |__ main.jar
 |__ main.properties

   With this architecture, you can modify any property in the main.properties file using any text editor
   before or while your main.jar is running (depending on the current state of the program) since it is
   just a text-based file. For example, your main.properties file may contain:
app.version=1.0.0.0
app.name=Hello

   So, when you run your main program from its root/base folder, normally you will run it like this:
java -jar ./main.jar

   or, straight away:
java -jar main.jar

   In your main.jar, you need to create a few utility methods for every property found in your
   main.properties file; let say the app.version property will have getAppVersion() method as follows:

/**
 * Gets the app.version property value from
 * the ./main.properties file of the base folder
 *
 * @return app.version string
 * @throws IOException
 */

import java.util.Properties;

public static String getAppVersion() throws IOException{

    String versionString = null;

    //to load application's properties, we use this class
    Properties mainProperties = new Properties();

    FileInputStream file;

    //the base folder is ./, the root of the main.properties file
    String path = "./main.properties";

    //load the file handle for main.properties
    file = new FileInputStream(path);

    //load all the properties from this file
    mainProperties.load(file);

    //we have loaded the properties, so close the file handle
    file.close();

    //retrieve the property we are intrested, the app.version
    versionString = mainProperties.getProperty("app.version");

    return versionString;
}

   In any part of the main program that needs the app.version value, we call its method as follows:
String version = null;
try{
    version = getAppVersion();
}
catch (IOException ioe){
    ioe.printStackTrace();
}

***
       This solution works. Thanks for understanding the exact requirement and detailed code.I verified
       that the properties file is not inside the jar file but still it could access the file from the
       same directory where the jar file is. In this way there not absolute path hard code is is
       required . Both jar and property file now can be copied to any directory and run independently.
       - Neil Jan 9 '12 at 7:50
     * 3
       The file will not found if you execute the command from outside for ex: {{java -jar
       build/main.jar}}. Do you have any fix for that, @eee? - Darian Jul 9 '15 at 3:56
     * @Darian There is nothing to fix here; It only works as designed where the jar and the properties
       file must be on the same ./ root folder (same directory level) as to what I have described in the
       file organization architecture. (as per requirement set by the original poster) - ecle Jul 9
       '15 at 4:57
     * @Darian, so if you want to execute java -jar build/main.jar, you need to put the properties file
       in build folder as well so that it is on the same directory level as the jar. - ecle Jul 9
       '15 at 5:02
     * 7
       Thanks for your response @eee, the problem is I don't know where user will execute the java -jar
       path/to/jar/file. But I found the solution in another question: String path =
       ClassLoader.getSystemClassLoader().getResource(".").getPath() + "/main.properties"; - Darian
       Jul 9 '15 at 9:05

***
   I did it by other way.
Properties prop = new Properties();
try {

    File jarPath=new File(MyClass.class.getProtectionDomain().getCodeSource().getLocation().getPath());
    String propertiesPath=jarPath.getParentFile().getAbsolutePath();
    System.out.println("propertiesPath-"+propertiesPath);
    prop.load(new FileInputStream(propertiesPath+"/importer.properties"));
} catch (IOException e1) {
    e1.printStackTrace();
}

    1. Get Jar file path.
    2. Get Parent folder of that file.
    3. Use that path in InputStreamPath with your properties file name.

***
   There's always a problem accessing files on your file directory from a jar file. Providing the
   classpath in a jar file is very limited. Instead try using a bat file or a sh file to start your
   program. In that way you can specify your classpath anyway you like, referencing any folder anywhere
   on the system.

***
   I have a similar case: wanting my *.jar file to access a file in a directory next to said *.jar file.
   Refer to THIS ANSWER as well.

   My file structure is:
./ - the root of your program
|__ *.jar
|__ dir-next-to-jar/some.txt

   I'm able to load a file (say, some.txt) to an InputStream inside the *.jar file with the following:
InputStream stream = null;
try {
    stream = ThisClassName.class.getClass().getResourceAsStream("/dir-next-to-jar/some.txt");
} catch(Exception e) {
    System.out.print("error file to stream: ");
    System.out.println(e.getMessage());
}

   Then do whatever you will with the stream

***
   I have an example of doing both by classpath or from external config with log4j2.properties
package org.mmartin.app1;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.LoggerContext;
import org.apache.logging.log4j.LogManager;


public class App1 {
    private static Logger logger=null;
    private static final String LOG_PROPERTIES_FILE = "config/log4j2.properties";
    private static final String  CONFIG_PROPERTIES_FILE = "config/config.properties";

    private Properties properties= new Properties();

    public App1() {
        System.out.println("--Logger intialized with classpath properties file--");
        intializeLogger1();
        testLogging();
        System.out.println("--Logger intialized with external file--");
        intializeLogger2();
        testLogging();
    }




    public void readProperties()  {
        InputStream input = null;
        try {
            input = new FileInputStream(CONFIG_PROPERTIES_FILE);
            this.properties.load(input);
        } catch (IOException e) {
            logger.error("Unable to read the config.properties file.",e);
            System.exit(1);
        }
    }

    public void printProperties() {
        this.properties.list(System.out);
    }

    public void testLogging() {
        logger.debug("This is a debug message");
        logger.info("This is an info message");
        logger.warn("This is a warn message");
        logger.error("This is an error message");
        logger.fatal("This is a fatal message");
        logger.info("Logger's name: "+logger.getName());
    }


    private void intializeLogger1() {
        logger = LogManager.getLogger(App1.class);
    }
    private void intializeLogger2() {
        LoggerContext context = (org.apache.logging.log4j.core.LoggerContext) LogManager.getContext(false);
        File file = new File(LOG_PROPERTIES_FILE);
        // this will force a reconfiguration
        context.setConfigLocation(file.toURI());
        logger = context.getLogger(App1.class.getName());
    }

    public static void main(String[] args) {
        App1 app1 = new App1();
        app1.readProperties();
        app1.printProperties();
    }
}

// OUTPUT:
--Logger intialized with classpath properties file--
[DEBUG] 2018-08-27 10:35:14.510 [main] App1 - This is a debug message
[INFO ] 2018-08-27 10:35:14.513 [main] App1 - This is an info message
[WARN ] 2018-08-27 10:35:14.513 [main] App1 - This is a warn message
[ERROR] 2018-08-27 10:35:14.513 [main] App1 - This is an error message
[FATAL] 2018-08-27 10:35:14.513 [main] App1 - This is a fatal message
[INFO ] 2018-08-27 10:35:14.514 [main] App1 - Logger's name: org.mmartin.app1.App1
--Logger intialized with external file--
[DEBUG] 2018-08-27 10:35:14.524 [main] App1 - This is a debug message
[INFO ] 2018-08-27 10:35:14.525 [main] App1 - This is an info message
[WARN ] 2018-08-27 10:35:14.525 [main] App1 - This is a warn message
[ERROR] 2018-08-27 10:35:14.525 [main] App1 - This is an error message
[FATAL] 2018-08-27 10:35:14.525 [main] App1 - This is a fatal message
[INFO ] 2018-08-27 10:35:14.525 [main] App1 - Logger's name: org.mmartin.app1.App1
-- listing properties --
dbpassword=password
database=localhost
dbuser=user

***
   This works for me. Load your properties file from current directory
Properties properties = new Properties();
properties.load(new FileReader(new File(".").getCanonicalPath() + File.separator + "java.properties"));
properties.forEach((k, v) -> {
            System.out.println(k + " : " + v);
        });

   Make sure, that java.properties is at the current directory . You can just write a little startup
   script that switches into to the right directory in before, like
#! /bin/bash
scriptdir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd $scriptdir
java -jar MyExecutable.jar
cd -

   In your project just put the java.properties file in your project root, in order to make this code
   work from your IDE as well.

***
   Here if you mention .getPath() then that will return the path of Jar and I guess you will need its
   parent to refer to all other config files placed with the jar. This code works on Windows. Add the
   code within the main class.
File jarDir = new File(MyAppName.class.getProtectionDomain().getCodeSource().getLocation().getPath());
String jarDirpath = jarDir.getParent();

System.out.println(jarDirpath);


---
https://stackoverflow.com/questions/39081215/access-a-resource-outside-a-jar-from-the-jar

Access a resource outside a jar from the jar

   I'm trying to access a resource from a jar file. The resource is located in the same directory where
   is the jar.
my-dir:
 tester.jar
 test.jpg

   I tried different things including the following, but every time the input stream is null:

   [1]
String path = new File(".").getAbsolutePath();
InputStream inputStream = this.getClass().getResourceAsStream(path.replace("\\.", "\\") + "test.jpg");

   [2]
File f = new File(this.getClass().getProtectionDomain().getCodeSource().getLocation().toURI().getPath());
InputStream inputStream = this.getClass().getResourceAsStream(f.getParent() + "test.jpg");

   Can you give me some hints? Thanks.

***
     * 1
       getResourceAsStream gets a resource from the jar.
       docs.oracle.com/javase/7/docs/api/java/io/FileInputStream.html - tkausl Aug 22 '16 at
       13:47
     * 1
       "getResourceXXX" will load resources from the classpath, what you need is to open the jpg as a
       file or add my-dir to the classpath. - folkol Aug 22 '16 at 13:47
     * 1
       Have you tried splitting up the code, so you are at least certain that you obtain the correct
       path to the .jpg file? - Lars Kristensen Aug 22 '16 at 13:48
     * @LarsKristensen - I did print the path to the .jpg and it seems correct with option [1] - mdp
       Aug 22 '16 at 14:05

***
   If you are sure, that your application's current folder is the folder of the jar, you can simply call
   InputStream f = new FileInputStream("test.jpg");

   The getResource methods will load stuff using the classloader, not through filesystem. This is why
   your approach (1) failed.

   If the folder containing your *.jar and image file is in the classpath, you can get the image
   resource as if it was on the default-package:
class.getClass().getResourceAsStream("/test.jpg");

   Beware: The image is now loaded in the classloader, and as long as the application runs, the image is
   not unloaded and served from memory if you load it again.

   If the path containing the jar file is not given in the classpath, your approach to get the jarfile
   path is good. But then simply access the file directly through the URI, by opening a stream on it:
URL u = this.getClass().getProtectionDomain().getCodeSource().getLocation();
// u2 is the url derived from the codesource location
InputStream s = u2.openStream();

***
   Use this tutorial to help you create a URL to a single file in a jar file.

   Here's an example:
String jarPath = "/home/user/myJar.jar";
String urlStr = "jar:file://" + jarPath + "!/test.jpg";
InputStream is = null;
try {
    URL url = new URL(urlStr);
    is = url.openStream();
    Image image = ImageIO.read(is);
}
catch(Exception e) {
    e.printStackTrace();
}
finally {
    try {
        is.close();
    } catch(Exception IGNORE) {}
}


---
https://stackoverflow.com/questions/46861589/accessing-resource-files-from-external-modules
Accessing resource files from external modules

   So far until non-modularized java, you would simply put a file in src/main/java/resources make sure
   it is in classpath and then load it with
file = getClass().getClassLoader().getResourceAsStream("myfilename");

   from pretty much anywhere in the classpath.

   Now with modules, the plot thickens.

   My project setup is the following:
module playground.api {
    requires java.base;
    requires java.logging;
    requires framework.core;
}

   Config file is placed inside src/main/resources/config.yml.

   Project is run with
java -p target/classes:target/dependency -m framework.core/com.framework.Main

   Since the main class does not reside in my own project, but in an external framework module, it can't
   see config.yml. Now the question is, is there a way to somehow put my config file into the module or
   open it up? Do I have to change the way file is loaded by framework upstream?

   I tried using "exports" or "opens" in module-info but it wants to have a package name, not a folder
   name.

   How to achieve this in best practical way so it would work as in Java 8 and with as little changes as
   possible?
 
***
     * 3
       Does com.framework.Main read resources using Class.getResource? - Naman Oct 21 '17 at 10:55
     * 5
       If code in a module needs to access one of its own resources then the Class.getResourceXXX
       methods should be used (the parameter name is a resource name, not a file name btw). If the
       resource is in another module and you have the Module object then you can use
       Module.getResourceAsStream. If you want to search the module path and class path then
       ClassLoader.getResourceXXX will work as before but the Module needs to open the package
       containing the resource. Resources in the top-most directory or META-INF/* are not encapsulated
       so ClassLoader.getResource will work. - Alan Bateman Oct 21 '17 at 11:41
     * 2
       Related how-to-let-an-automatic-module-find-its-own-resources-in-java-9 - Naman Oct 22
       '17 at 11:40
     * 2
       src/main/resources/config.yml is the file path in the src tree, it is not the resource name. Look
       in the JAR file, is config.yml in the top-level directory of the JAR file? If so then the
       framework with locate it with ClassLoader.getResourceXXX as before. - Alan Bateman Oct 22 '17
       at 17:39
     * 3
       Right, you shouldn't add the module classes to the class path with -cp. Can you instead add
       --add-moduels playground.api to the command line. The initial module (the module you specify to
       -m) is com.framework.Main and I assume that nobody requires playground.api so it's not being
       resolved (you can quickly check this by adding --show-module-resolution to trace resolution at
       startup). - Alan Bateman Oct 22 '17 at 18:21

***
   While you are using the java command to launch an application as follows:-
java -p target/classes:target/dependency -m framework.core/com.framework.Main

     * you are specifying the modulepath using the option -p alternate for --module-path which would look
       up into target/classes and target/dependency for your modules.
     * Alongside, using -m alternate for --module specifies the initial module to resolve with the name
       framework.core and constructs the module graph with the main class to execute explicitly listed
       as com.framework.Main.

   Now, the problem here seems to be that the module framework.core doesn't require or read
   playground.api module because of which the module graph doesn't include the desired module consisting
   of the actual resource config.yml.

   As suggested by @Alan, a good way to list out the module resolution output during startup is to
   make use of the --show-module-resolution option.

     I just naively tried to opens src/main/resources, doesn't compile ofc

   Since the resource in your module is at the root level, it is, therefore, not encapsulated
   and does not need to be opened or exported to any other module.

   In your case, you just need to make sure that the module playground.api ends up in the module graph
   and then the resource would be accessible to the application. To specify root modules to resolve in
   addition to the initial module, you can make use of the --add-modules option.

   Hence the overall solution to work for you along with some debugging shall be :
java --module-path target/classes:target/dependency
     --module framework.core/com.framework.Main
     --add-modules playground.api
     --show-module-resolution

***
// to scan the module path
ClassLoader.getSystemResources(resourceName)

// if you know a class where the resource is
Class.forName(className).getResourceAsStream(resourceName)

// if you know the module containing the resource
ModuleLayer.boot().findModule(moduleName).getResourceAsStream(resourceName)

   See a working example below.

   Given:
.
+-- FrameworkCore
|   +-- src
|       +-- FrameworkCore
|           +-- com
|           |   +-- framework
|           |       +-- Main.java
|           +-- module-info.java
+-- PlaygroundApi
    +-- src
        +-- PlaygroundApi
            +-- com
            |  +-- playground
            |      +-- api
            |          +-- App.java
            +-- config.yml
            +-- module-info.java

   Main.java could be
package com.framework;

import java.io.*;
import java.net.URL;
import java.util.Optional;
import java.util.stream.Collectors;

public class Main {
    public static void main( String[] args )
    {
        // load from anywhere in the modulepath
        try {
            URL url = ClassLoader.getSystemResources("config.yml").nextElement();
            InputStream is = url.openStream();
            Main.read(is);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        // load from the the module where a given class is
        try {
            InputStream is = Class.forName("com.playground.api.App").getResourceAsStream("/config.yml");
            Main.read(is);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }

        // load from a specific module
        Optional<Module> specificModule = ModuleLayer.boot().findModule("PlaygroundApi");
        specificModule.ifPresent(module -> {
            try {
                InputStream is = module.getResourceAsStream("config.yml");
                Main.read(is);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }

    private static void read(InputStream is) {
        String s = new BufferedReader(new InputStreamReader(is)).lines().collect(Collectors.joining("\n"));
        System.out.println("config.yml: " + s);
    }
}

   And you would launch with
java --module-path ./FrameworkCore/target/classes:./PlaygroundApi/target/classes \
     --add-modules FrameworkCore,PlaygroundApi \
       com.framework.Main

   To clone this example: git clone https://github.com/j4n0/SO-46861589.git

***
     * 1
       See App.java:20 to load a resource from the same module. - Jano Oct 22 '17 at 12:56
     * I'll try this just to see if it works however, I have a problem with this. Ideally, framework
       module should not care about which module contains the resource file nor should it care that the
       module in question is called "PlaygroundApi". If I make 100 projects, each one will have a
       different module name which means I need to make the module name in framework code configurable.
       Kinda painful but doable I guess. - cen Oct 22 '17 at 16:45
     * 1
       The answer is a bit misleading as there the framework should only need to the use the Module API
       then it wants to locate a resource in a specific module. As note in one of the early comments, a
       resource is only encapsulated if it's in a module package, in which case the module-info.java can
       open the package to allow the framework locate the resource. - Alan Bateman Oct 22 '17 at
       17:45
     * Thanks. I split the code and added the Classloader for top resources anywhere in the module path.
       - Jano Oct 22 '17 at 20:17
     * 1
       The intro section in your answer is good now. I guess someone should write an answer to summarize
       the real issue now as it turned out not to be a resource encapsulation issue. - Alan Bateman
       Oct 23 '17 at 9:47


---
https://docs.oracle.com/javase/8/docs/technotes/guides/lang/resources.html

Location-Independent Access to Resources

Overview
   A resource is data (images, audio, text, and so on) that a program needs to access in a way that is
   independent of the location of the program code. Java programs can use two mechanisms to access
   resources: Applets use Applet.getCodeBase() to get the base URL for the applet code and then extend
   the base URL with a relative path to load the desired resource, for example with
   Applet.getAudioClip(url). Applications use "well known locations" such as
   System.getProperty("user.home") or System.getProperty("java.home"), then add "/lib/resource", and
   open that file.

   Methods in the classes Class and ClassLoader provide a location-independent way to locate resources.
   For example, they enable locating resources for:
     * An applet loaded from the Internet using multiple HTTP connections.
     * An applet loaded using JAR files.
     * A Java Bean loaded or installed in the CLASSPATH.
     * A "library" installed in the CLASSPATH.

   These methods do not provide specific support for locating localized resources. Localized resources
   are supported by the internationalization facilities.

Resources, names, and contexts
   A resource is identified by a string consisting of a sequence of substrings, delimited by slashes
   (/), followed by a resource name. Each substring must be a valid Java identifier. The resource name
   is of the form shortName or shortName.extension. Both shortName and extension must be Java
   identifiers.

   The name of a resource is independent of the Java implementation; in particular, the path separator
   is always a slash (/). However, the Java implementation controls the details of how the contents of
   the resource are mapped into a file, database, or other object containing the actual resource.

   The interpretation of a resource name is relative to a class loader instance. Methods implemented by
   the ClassLoader class do this interpretation.

System Resources
   A system resource is a resource that is either built-in to the system, or kept by the host
   implementation in, for example, a local file system. Programs access system resources through the
   ClassLoader methods getSystemResource and getSystemResourceAsStream.

   For example, in a particular implementation, locating a system resource may involve searching the
   entries in the CLASSPATH. The ClassLoader methods search each directory, ZIP file, or JAR file entry
   in the CLASSPATH for the resource file, and, if found, returns either an InputStream, or the resource
   name. If not found, the methods return null. A resource may be found in a different entry in the
   CLASSPATH than the location where the class file was loaded.

Non-System Resources
   The implementation of getResource on a class loader depends on the details of the ClassLoader class.
   For example, AppletClassLoader:
     * First tries to locate the resource as a system resource; then, if not found,
     * Searches through the resources in archives (JAR files) already loaded in this CODEBASE; then, if
       not found,
     * Uses CODEBASE and attempts to locate the resource (which may involve contacting a remote site).

   All class loaders will search for a resource first as a system resource, in a manner analogous to
   searcing for class files. This search rule permits overwriting locally any resource. Clients should
   choose a resource name that will be unique (using the company or package name as a prefix, for
   instance).

Resource Names
   A common convention for the name of a resource used by a class is to use the fully qualified name of
   the package of the class, but convert all periods (.) to slashes (/), and add a resource name of the
   form name.extension. To support this, and to simplify handling the details of system classes (for
   which getClassLoader returns null), the class Class provides two convenience methods that call the
   appropriate methods in ClassLoader.

   The resource name given to a Class method may have an initial starting "/" that identifies it as an
   "absolute" name. Resource names that do not start with a "/" are "relative".

   Absolute names are stripped of their starting "/" and are passed, without any further modification,
   to the appropriate ClassLoader method to locate the resource. Relative names are modified according
   to the convention described previously and then are passed to a ClassLoader method.

Using Methods of java.lang.Class
   The Class class implements several methods for loading resources.

   The method getResource() returns a URL for the resource. The URL (and its representation) is specific
   to the implementation and the JVM (that is, the URL obtained in one runtime instance may not work in
   another). Its protocol is usually specific to the ClassLoader loading the resource. If the resource
   does not exist or is not visible due to security considerations, the methods return null.

   If the client code wants to read the contents of the resource as an InputStream, it can apply the
   openStream() method on the URL. This is common enough to justify adding getResourceAsStream() to
   Class and ClassLoader. getResourceAsStream() the same as calling getResource().openStream(), except
   that getResourceAsStream() catches IO exceptions returns a null InputStream.

   Client code can also request the contents of the resource as an object by applying the
   java.net.URL.getContent() method on the URL. This is useful when the resource contains the data for
   an image, for instance. In the case of an image, the result is an awt.image.ImageProducer object, not
   an Image object.

   The getResource and getResourceAsStream methods find a resource with a given name. They return null
   if they do not find a resource with the specified name. The rules for searching for resources
   associated with a given class are implemented by the class's ClassLoader. The Class methods delegate
   to ClassLoader methods, after applying a naming convention: if the resource name starts with "/", it
   is used as is. Otherwise, the name of the package is prepended, after converting all periods (.) to
   slashes (/).
public InputStream getResourceAsStream(String name) {
    name = resolveName(name);
    ClassLoader cl = getClassLoader();
    if (cl==null) {
        return ClassLoader.getSystemResourceAsStream(name); // A system class.
    }
    return cl.getResourceAsStream(name);
}

public java.net.URL getResource(String name) {
    name = resolveName(name);
    ClassLoader cl = getClassLoader();
    if (cl==null) {
        return ClassLoader.getSystemResource(name);  // A system class.
    }
    return cl.getResource(name);
}

   The resolveName method adds a package name prefix if the name is not absolute, and removes any
   leading "/" if the name is absolute. It is possible, though uncommon, to have classes in diffent
   packages sharing the same resource.
private String resolveName(String name) {
    if (name == null) {
        return name;
    }
    if (!name.startsWith("/")) {
        Class c = this;
        while (c.isArray()) {
            c = c.getComponentType();
        }
        String baseName = c.getName();
        int index = baseName.lastIndexOf('.');
        if (index != -1) {
            name = baseName.substring(0, index).replace('.', '/') + "/" + name;
        }
    } else {
        name = name.substring(1);
    }
    return name;
}

Using Methods of java.lang.ClassLoader
   The ClassLoader class has two sets of methods to access resources. One set returns an InputStream for
   the resource. The other set returns a URL. The methods that return an InputStream are easier to use
   and will satisfy many needs, while the methods that return URLs provide access to more complex
   information, such as an Image and an AudioClip.

   The ClassLoadermanges resources similarly to the way it manages classes. A ClassLoader controls how
   to map the name of a resource to its content. ClassLoader also provides methods for accessing system
   resources, analogous to the system classes. The Class class provides some convenience methods that
   delegate functionality to the ClassLoader methods.

   Many Java programs will access these methods indirectly through the I18N (localization) APIs. Others
   will access it through methods in Class. A few will directly invoke the ClassLoader methods.

   The methods in ClassLoader use the given String as the name of the resource without applying any
   absolute/relative transformation (see the methods in Class). The name should not have a leading "/".

   System resources are those that are handled by the host implemenation directly. For example, they may
   be located in the CLASSPATH.

   The name of a resource is a "/"-separated sequence of identifiers. The Class class provides
   convenience methods for accessing resources; the methods implement a convention where the package
   name is prefixed to the short name of the resource.

   Resources can be accessed as an InputStream, or a URL.

   The getSystemResourceAsStream method returns an InputStream for the specified system resource or null
   if it does not find the resource. The resource name may be any system resource.

   The getSystemResource method finds a system resource with the specified name. It returns a URL to the
   resource or null if it does not find the resource. Calling java.net.URL.getContent() with the URL
   will return an object such as ImageProducer, AudioClip, or InputStream.

   The getResourceAsStream method returns an InputStream for the specified resource or null if it does
   not find the resource.

   The getResource method finds a resource with the specified name. It returns a URL to the resource or
   null if it does not find the resource. Calling java.net.URL.getContent() with the URL will return an
   object such as ImageProducer, AudioClip, or InputStream.

Security
   Since getResource() provides access to information, it must have well-defined and well-founded
   security rules. If security considerations do not allow a resource to be visible in some security
   context, the getResource() method will fail (return null) as if the resource were not present at all,
   this addresses existence attacks.

   Class loaders may not provide access to the contents of a .class file for both security and
   performance reasons. Whether it is possible to obtain a URL for a .class file depends on the
   specifics, as shown below.

   There are no specified security issues or restrictions regarding resources that are found by a
   non-system class loader. AppletClassLoader provides access to information that is loaded from a
   source location, either individually, or in a group through a JAR file; thus AppletClassLoader should
   apply the same checkConnect() rules when dealing with URLs through getResource().

   The system ClassLoader provides access to information in the CLASSPATH. A CLASSPATH may contain
   directories and JAR files. Since a JAR file is created intentionally, it has a different significance
   than a directory where things may end up in a more casual manner. In particular, we are more strict
   on getting information out of a directory than out from a JAR file.

   If a resource is in a directory:
     * getResource() invocations will use File.exists() to determine whether to make the corresponding
       file visible to the user. Recall that File.exists() uses the checkRead() method in the security
       manager.
     * the same applies to getResourceAsStream().

   If the resource is in a JAR file:
     * getResource() invocations will succeed for all files, regardless of whether the invocation is
       done from within a system or a non-system class.
     * getResourceAsStream() invocations will succeed for non .class resources, and so will for
       java.net.URL.getContent() on corresponding URLs.

Examples
   This section provides two examples of client code. The first example uses "absolute resource" names
   and traditional mechanisms to get a Class object.
package pkg;

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;

class Test {

    private static final String absName = "/pkg/mumble.baf";
    
    public static void test1() {
        Class c=null;
        try {
            c = Class.forName("pkg.Test");
        } catch (Exception ex) {
            // This should not happen.
        }
        InputStream s = c.getResourceAsStream(absName);
        // do something with it.
    }
    
    public void test2() {
        InputStream s = this.getClass().getResourceAsStream(absName);
    // do something with it.
    }
}

   This example uses "relative resource" names and the mechanism available from the compiler through the
   -experimental flag, to get a Class object.
package pkg;

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;

class Test {
    private static final String relName = "mumble.baf";
    public static void test1() {
        InputStream s = Test.class.getResourceAsStream(relName);
        // do something with it.
    }

  public void test2() {
        InputStream s = Test.class.getResourceAsStream(relName);
        // do something with it.
    }
}

API References

     * java.lang.Class
     * java.lang.ClassLoader
     * java.net.URLClassLoader
     * java.util.ResourceBundle
     * java.lang.SecurityManager
     * java.security
 

---
https://github.com/google/guava/issues/3868

Resources.getResource() not working on modular project (openjdk 11)? #3868
Apr 20, 2020

   This is a maven project, and have one image in resources directory:
+- src
   +- main
       +- java
       +- resources
          +-imgs
            +-logo.png

   I use:
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>29.0-jre</version>
        </dependency>

Code Snippet:

public class Test {
    public static void main(String[] args) {
        URL resource = Resources.getResource(Test.class, "/imgs/logo.png");
    }
}


   Will get error, when I add module-info.java:
Exception in thread "main" java.lang.IllegalArgumentException: resource /imgs/logo.png relative to com.ctxx.Test not found.
        at com.google.common@29.0-jre/com.google.common.base.Preconditions.checkArgument(Preconditions.java:441)
        at com.google.common@29.0-jre/com.google.common.io.Resources.getResource(Resources.java:208)
        at OpenJFXAndOpenJDK/com.ctxx.Test.main(Test.java:15)

   but when I delete module-info.java from project, it works well.

Code Snippet2:

public class Test {
    public static void main(String[] args) {
        URL resource1 = Resources.getResource("imgs/logo.png");
        System.out.println(resource1);
    }
}


   when I add module-info.java to project, get error:
Exception in thread "main" java.lang.IllegalArgumentException: resource imgs/logo.png not found.
        at com.google.common@29.0-jre/com.google.common.base.Preconditions.checkArgument(Preconditions.java:217)
        at com.google.common@29.0-jre/com.google.common.io.Resources.getResource(Resources.java:195)
        at OpenJFXAndOpenJDK/com.ctxx.Test.main(Test.java:14)

   but when I delete module-info.java from project, it works well.

***
@netdpb netdpb commented Apr 20, 2020

   I think that JPMS says that if a resource is in a module, then ClassLoader.getResource() will hide it
   from callers of that method that aren't in the module. So maybe if you call
   getClass().getClassLoader().getResource() directly instead of Resources.getResource() it'll work.

   I'm not a JPMS expert, but putting opens imgs to com.google.common; into your module-info.java should
   tell JPMS that Guava is allowed to load resources (and do other reflection) on the imgs package in
   your module.

   Otherwise you can put opens imgs; into module-info.java to make that packages open to reflection by
   every module.

   I don't think this is a Guava-specific issue, so I'm going to close this bug. Please reopen if you
   think there's something else we can do here.

   
***
@cpovirk cpovirk commented Apr 20, 2020
   I suspect that using a different classloader isn't enough. I can't find the specific JPMS reference
   that I thought I had bookmarked, but I came across A JPMS Migration Guide for the Impatient,
   which suggests that Module.getResourceAsStream may be somewhat better than
   ClassLoader.getResourceAsStream. (Even the Module version is sometimes not sufficient, but I
   suspect that it is for the submitter of this issue, since imgs is probably not the name of a Java
   package.) That doc also mentions a jrt: URL scheme, about which I know nothing.

   I think we should have some issue open about Resources.getResource and JPMS, covering:
     * documentation on it similar to that on ClassLoader.getResourceAsStream
     * feature requests for additional methods like Modules.resourceAsByteSource

   That could be this issue, one new issue, or multiple new issues. Opinions?

***
   thanks! opens imgs works well.



---
https://www.javatpoint.com/java-class-getresource-method

Java Class getResource() Method

The getResource() method of java Class class is used to return the resources of the module in which this class
exists. The value returned from this function exists in the form of the object of the URL class.

Syntax
    public URL getResource(String name)  

Parameter
name - the name of the desired resource

Returns
A URL object.

Throws
NullPointerException

Example 1

// import statements
import java.net.URL;
import java.lang.*;

public class ClassgetResourceExample1 {  
    public static void main(String[] args) throws Exception {  
        ClassgetResourceExample1 obj = new ClassgetResourceExample1();  
        Class class1 = obj.getClass();  
        URL url = class1.getResource("ClassgetResourceExample1.java");  
        System.out.println("Value URL = " + url);  
        URL url2 = class1.getResource("file1.txt");  
        System.out.println("Value URL = " + url2);  
    }  
}  


Output:

Value URL = null
Value URL = file:/C:/Users/Suman/Documents/NetBeansProjects/calendar/build/classes/Class/file1.txt

Example 2

//import statements  
import java.net.URL;   
import java.lang.*;  
public class ClassgetResourceExample2 {  
    public static void main(String[] args) throws Exception {  
        ClassgetResourceExample2 obj = new ClassgetResourceExample2();  
        Class class1 = obj.getClass();  
        URL url = class1.getResource("file1.txt");  
        System.out.println("Value URL = " + url);  
        url = class1.getResource("newfolder/file2.txt");  
        System.out.println("Value URL = " + url);  
    }  
}  


Output:
Value URL = file:/C:/Users/Suman/Documents/NetBeansProjects/calendar/build/classes/Class/file1.txt
Value URL = file:/C:/Users/Suman/Documents/NetBeansProjects/calendar/build/classes/Class/newfolder/file2.txt



---
https://www.javatpoint.com/java-class

Java Class class

Java Class class instances represent the classes and interfaces in a running java application. Every Array
belongs to a class is a Class object and it is shared by all arrays (with same element type and number of
dimensions).

Methods

Method                       Description
asSubclass(Class<U> clazz)   It casts this Class object to represent a subclass of the class represented by
                             the given class object.
cast(Object obj)             It casts an object to the class or interface represented by this Class object.
desiredAssertionStatus()     It returns the assertion status that would be assigned to this class if it was
                             to be initialized at the time when this method is called.
forName(String className)    It returns the Class object associated with the class or interface with the
                             specified string name.
forName(String name, boolean It returns the Class object associated with the class or interface with the
initialize,ClassLoader       specified string name, using the given class loader.
loader)
getAnnotatedInterfaces()     It returns an array of Annotated Type objects that represents the use of types
                             to specify super interfaces of the entity represented by this Class object.
getAnnotatedSuperclass()     It returns an Annotated Type object that represents the usage of a type to
                             specify the superclass of the entity as represented by this Class object.
getAnnotation(Class<A>       This method returns this element's annotation for the given type, if such an
annotationClass)             annotation is present, else it returns null.
getAnnotations()             This method returns annotations that are present on this element.
getAnnotationsByType(Class   This method returns annotations that are associated with this element.
<A>annotationClass)
getCanonicalName()           It returns the canonical name of the underlying class as defined by the Java
                             Language Specification.
                             It returns an array containing Class objects representing all the public
getClasses()                 interfaces and classes that are members of the class and are represented by this
                             Class object.
getClassLoader()             This method returns the class loader for the class.
getComponentType()           This method returns the Class representing the component type of an array.
getConstructor(Class<?>...   It returns a Constructor object that reflects the specified public constructor
parameterTypes)              of the class represented by this Class object.
getConstructors()            It returns an array which contains the Constructor's objects reflecting all the
                             public constructors of the class represented by this Class object.
getDeclaredAnnotation(Class  It returns this element's annotation for the specified type if such an
<A>annotationClass)          annotation is directly present, else it returns null.
getDeclaredAnnotations()     It returns annotations that are present on this element.
getDeclaredAnnotationsByType It returns this element's annotation(s) for the specified type if such
(Class<A> annotationClass)   annotations are either directly or indirectly present.
getDeclaredClasses()         It returns an array of Class objects reflecting all the interfaces and classes
                             which are declared as the members of the class represented by this Class object.
getDeclaredConstructor(Class It returns a Constructor object that reflects the given constructor of the class
<?>... parameterTypes)       or interface represented by the Class object.
getDeclaredConstructors()    It returns an array of Constructor objects reflecting all the constructors
                             declared by the class represented by this Class object.
getDeclaredField(String      It returns a Field object that reflects the declared field of the class or
name)                        interface represented by the Class object.
getDeclaredMethod(String     It returns a Method object that reflects the given declared method of the class
name, Class<?>...            or interface as represented by this Class object.
parameterTypes)
                             It returns the class or interface represented by this Class object (which is a
getDeclaringClass()          member of another class) and the Class object representing the class in which it
                             was declared.
getEnclosingClass()          It returns the immediately enclosing class of the underlying class.
                             If the invoked Class's object represents a local or anonymous class within a
getEnclosingConstructor()    constructor then it returns a Constructor object representing the immediately
                             enclosing constructor of the underlying class.
                             If the invoked Class object represents a local or anonymous class within a
getEnclosingMethod()         method then it returns a Method object which represents the immediately
                             enclosing method of the underlying class.
getEnumConstants()           It returns the elements of this enum class or null if this Class object does not
                             represent an enum type.
getField(String name)        It returns a Field object that reflects the specified public member field of the
                             interface or class represented by this Class object.
getFields()                  It returns an array containing Field objects reflecting all the accessible
                             public fields of the interface or class represented by this Class object.
getGenericInterfaces()       Returns the Types representing the interfaces directly implemented by the class
                             or interface represented by this object
getGenericSuperclass()       Returns the Type representing the direct superclass of the entity (class,
                             interface, primitive type or void) represented by this Class.
getInterfaces()              It determines the interfaces implemented by the interface or class represented
                             by this object.
getMethod(String name, Class It returns a method object that gives the specified public
<?>... parameterTypes)       member method of the interface or class represented by this Class object
                             It returns an array containing Method objects reflecting all the public methods
getMethods()                 of the class or interface represented by this Class object. It also includes the
                             declared methods of the class or interface and those inherited from super
                             classes and super interfaces
getModifiers()               It returns the Java language modifiers for this class or interface, encoded in
                             an integer.
getName()                    It returns the name of the entity represented by this Class object, as a String.
getPackage()                 It simply gets the package for this class.
getProtectionDomain()        It returns the Protection Domain of this class.
getResource(String name)     This method searches for a resource with the given name.
getResourceAsStream(String   This method searches for a resource with a given name.
name)
getSigners()                 It returns the signers of this class.
getSimpleName()              This method returns the name of the underlying class as given in the source
                             code.
getSuperclass()              This method returns the Class which represents the superclass of the entity
                             represented by this Class.
getTypeName()                This method returns an informative string for the name of this type.
                             It returns an array of Type Variable objects that represent the type variables
getTypeParameters()          declared by the generic declaration represented by this Generic Declaration
                             object, in declaration order.
isAnnotation()               This method returns a Boolean value 'true' if this Class object represents an
                             annotation type.
isAnnotationPresent(Class<?  This method returns a Boolean value 'true' if an annotation is present on this
extendsAnnotation>           element, else it returns false.
annotationClass)
isAnonymousClass()           This method returns a Boolean value 'true' if and only if the underlying class
                             is an anonymous class.
isArray()                    This method determines if this Class object represents an array class.
isAssignableFrom(Class<?>    This method checks if the interface or class represented by this Class object is
cls)                         either same, or is a superclass or super interface of the class or interface
                             represented by the given Class parameter.
isEnum()                     It returns a Boolean value 'true' if and only if this class was declared as an
                             enum in the source code.
isInstance(Object obj)       It checks if the specified Object is assignment-compatible with the object
                             represented by this Class.
isInterface()                It checks if the given Class object represents an interface type.
isLocalClass()               This method returns a Boolean value 'true' if the underlying class is a local
                             class.
isMemberClass()              This method returns a Boolean value 'true' if the underlying class is a member
                             class.
isPrimitive()                This method checks if the specified Class object represents a primitive type or
                             not.
isSynthetic()                This method returns a Boolean value 'true' if this class is a synthetic class
                             else it returns false.
newInstance()                This method creates a new instance of the class represented by this Class
                             object.
toGenericString()            This method returns a string describing this Class, including information about
                             modifiers and the type arguments.
toString()                   This method converts the object to a string.

Example 1

public class JavaClassExample1 {  
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {  
        // returns the Class object for the class with the given name  
        Class class1 = Class.forName("java.lang.String");  
        Class class2 = int.class;  
        System.out.print("Class represented by class1: ");  
        // applying toString method on class1  
        System.out.println(class1.toString());  
        System.out.print("Class represented by class2: ");  
        // applying toString() method on class2  
        System.out.println(class2.toString());  
        String s = "JavaTpoint";  
        int i = 10;  
  
        // checking for Class instance  
        boolean b1 = class1.isInstance(s);  
        boolean b2 = class1.isInstance(i);  
        System.out.println("is p instance of String : " + b1);  
        System.out.println("is j instance of String : " + b2);  
    }  
}  


Output:

Class represented by class1: class java.lang.String
Class represented by class2: int
is p instance of String : true
is j instance of String : false


---
https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/6.4/html/development_guide/
sect-use_the_class_loader_programmatically_in_a_deployment

3.6. Use the Class Loader Programmatically in a Deployment

3.6.1. Programmatically Load Classes and Resources in a Deployment
   You can programmatically find or load classes and resources in your application code. The method you
   choose will depend on a number of factors. This topic describes the methods available and provides
   guidelines for when to use them.

   Load a Class Using the Class.forName() Method
          You can use the Class.forName() method to programmatically load and initialize classes. This
          method has two signatures.

        Class.forName(String className)
                This signature takes only one parameter, the name of the class you need to load. With
                this method signature, the class is loaded by the class loader of the current class and
                initializes the newly loaded class by default.

        Class.forName(String className, boolean initialize, ClassLoader loader)
                This signature expects three parameters: the class name, a boolean value that specifies
                whether to initialize the class, and the ClassLoader that should load the class.

          The three argument signature is the recommended way to programmatically load a class. This
          signature allows you to control whether you want the target class to be initialized upon load.
          It is also more efficient to obtain and provide the class loader because the JVM does not need
          to examine the call stack to determine which class loader to use. Assuming the class
          containing the code is named CurrentClass, you can obtain the class's class loader using
          CurrentClass.class.getClassLoader() method.

          The following example provides the class loader to load and initialize the TargetClass class:

          Example 3.7. Provide a class loader to load and initialize the TargetClass.
Class<?> targetClass = Class.forName("com.myorg.util.TargetClass", true, CurrentClass.class.getClassLoader());

   Find All Resources with a Given Name
          If you know the name and path of a resource, the best way to load it directly is to use the
          standard Java development kit Class or ClassLoader API.

        Load a Single Resource
                To load a single resource located in the same directory as your class or another class
                in your deployment, you can use the Class.getResourceAsStream() method.

                Example 3.8. Load a single resource in your deployment.
InputStream inputStream = CurrentClass.class.getResourceAsStream("targetResourceName");

        Load All Instances of a Single Resource
                To load all instances of a single resource that are visible to your deployment's class
                loader, use the Class.getClassLoader().getResources(String resourceName) method, where
                resourceName is the fully qualified path of the resource. This method returns an
                Enumeration of all URL objects for resources accessible by the class loader with the
                given name. You can then iterate through the array of URLs to open each stream using the
                openStream() method.

                Example 3.9. Load all instances of a resource and iterate through the result.
Enumeration<URL> urls = CurrentClass.class.getClassLoader().getResources("full/path/to/resource");
while (urls.hasMoreElements()) {
    URL url = urls.nextElement();
    InputStream inputStream = null;
    try {
        inputStream = url.openStream();
        // Process the inputStream
        ...
    } catch(IOException ioException) {
        // Handle the error
    } finally {
        if (inputStream != null) {
            try {
                inputStream.close();
            } catch (Exception e) {
                // ignore
            }
        }
    }
}

                Note

                Because the URL instances are loaded from local storage, it is not necessary to use the
                openConnection() or other related methods. Streams are much simpler to use and minimize
                the complexity of the code.

   Load a Class File From the Class Loader
          If a class has already been loaded, you can load the class file that corresponds to that class
          using the following syntax:

          Example 3.10. Load a class file for a class that has been loaded.
InputStream inputStream = CurrentClass.class.getResourceAsStream(TargetClass.class.getSimpleName() + ".class");

          If the class is not yet loaded, you must use the class loader and translate the path:

          Example 3.11. Load a class file for a class that has not been loaded.
String className = "com.myorg.util.TargetClass"
InputStream inputStream = CurrentClass.class.getClassLoader().getResourceAsStream(className.replace('.', '/')+ ".class");

3.6.2. Programmatically Iterate Resources in a Deployment
   The JBoss Modules library provides several APIs for iterating all deployment resources. The JavaDoc
   for the JBoss Modules API is located here: http://docs.jboss.org/jbossmodules/1.3.0.Final/api/.
   To use these APIs, you must add the following dependency to the MANIFEST.MF:
Dependencies: org.jboss.modules

   It is important to note that while these APIs provide increased flexibility, they will also run much
   more slowly than a direct path lookup.
   This topic describes some of the ways you can programmatically iterate through resources in your
   application code.

   List Resources Within a Deployment and Within All Imports
          There are times when it is not possible to look up resources by the exact path. For example,
          the exact path may not be known or you may need to examine more than one file in a given path.
          In this case, the JBoss Modules library provides several APIs for iterating all deployment
          resources. You can iterate through resources in a deployment by utilizing one of two methods.

        Iterate All Resources Found in a Single Module
                The ModuleClassLoader.iterateResources() method iterates all the resources within this
                module class loader. This method takes two arguments: the starting directory name to
                search and a boolean that specifies whether it should recurse into subdirectories.

                The following example demonstrates how to obtain the ModuleClassLoader and obtain the
                iterator for resources in the bin/ directory, recursing into subdirectories.

                Example 3.12. Find resources in the "bin" directory, recursing into subdirectories.
ModuleClassLoader moduleClassLoader = (ModuleClassLoader) TargetClass.class.getClassLoader();
Iterator<Resource> mclResources = moduleClassLoader.iterateResources("bin",true);

                The resultant iterator may be used to examine each matching resource and query its name
                and size (if available), open a readable stream, or acquire a URL for the resource.

        Iterate All Resources Found in a Single Module and Imported Resources
                The Module.iterateResources() method iterates all the resources within this module class
                loader, including the resources that are imported into the module. This method returns a
                much larger set than the previous method. This method requires an argument, which is a
                filter that narrows the result to a specific pattern. Alternatively,
                PathFilters.acceptAll() can be supplied to return the entire set.

                Example 3.13. Find the entire set of resources in this module, including imports.
ModuleClassLoader moduleClassLoader = (ModuleClassLoader) TargetClass.class.getClassLoader();
Module module = moduleClassLoader.getModule();
Iterator<Resource> moduleResources = module.iterateResources(PathFilters.acceptAll());

   Find All Resources That Match a Pattern
          If you need to find only specific resources within your deployment or within your deployment's
          full import set, you need to filter the resource iteration. The JBoss Modules filtering APIs
          give you several tools to accomplish this.

        Examine the Full Set of Dependencies
                If you need to examine the full set of dependencies, you can use the
                Module.iterateResources() method's PathFilter parameter to check the name of each
                resource for a match.

        Examine Deployment Dependencies
                If you need to look only within the deployment, use the
                ModuleClassLoader.iterateResources() method. However, you must use additional methods to
                filter the resultant iterator. The PathFilters.filtered() method can provide a filtered
                view of a resource iterator this case. The PathFilters class includes many static
                methods to create and compose filters that perform various functions, including finding
                child paths or exact matches, or matching an Ant-style "glob" pattern.

   Additional Code Examples For Filtering Resouces
          The following examples demonstrate how to filter resources based on different criteria.

          Example 3.14. Find all files named "messages.properties" in your deployment.
ModuleClassLoader moduleClassLoader = (ModuleClassLoader) TargetClass.class.getClassLoader();
Iterator<Resource> mclResources = PathFilters.filtered(PathFilters.match("**/messages.properties"), \
moduleClassLoader.iterateResources("", true));

          Example 3.15. Find all files named "messages.properties" in your deployment and imports.
ModuleClassLoader moduleClassLoader = (ModuleClassLoader) TargetClass.class.getClassLoader();
Module module = moduleClassLoader.getModule();
Iterator<Resource> moduleResources = module.iterateResources(PathFilters.match("**/message.properties));

          Example 3.16. Find all files inside any directory named "my-resources" in your deployment.
ModuleClassLoader moduleClassLoader = (ModuleClassLoader) TargetClass.class.getClassLoader();
Iterator<Resource> mclResources = PathFilters.filtered(PathFilters.match("**/my-resources/**"), moduleClassLoa
der.iterateResources("", true));

          Example 3.17. Find all files named "messages" or "errors" in your deployment and imports.
ModuleClassLoader moduleClassLoader = (ModuleClassLoader) TargetClass.class.getClassLoader();
Module module = moduleClassLoader.getModule();
Iterator<Resource> moduleResources = module.iterateResources(PathFilters.any(PathFilters.match("**/messages"), \
 PathFilters.match("**/errors"));

          Example 3.18. Find all files in a specific package in your deployment.
ModuleClassLoader moduleClassLoader = (ModuleClassLoader) TargetClass.class.getClassLoader();
Iterator<Resource> mclResources = moduleClassLoader.iterateResources("path/form/of/packagename", false);


---
