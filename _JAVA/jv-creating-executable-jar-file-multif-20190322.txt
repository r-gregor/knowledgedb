filename: jv_creating_executable_jar_file-multif_20190322.txt
http://www.jdatalab.com/java/2017/01/17/java-archive-file.html

Packaging Java Application in a JAR
Jan 17, 2017

   How do we run a Java application without an IDE?
   After finishing developing and testing in an IDE, before distributing it for deployment, it is good
   to test the application outside of the IDE.

   A Java application is built into a JAR file. The JAR file will run from the command line.

1. JAR (Java Archive) File
   A JAR (Java Archive) file is a compressed package that is executable by Java Runtime Environment
   (JRE). Multiple Java class files can be bundled into a single archive file with file extension .jar.

2. Creating the JAR File
   Once a Java project has been completed inside an IDE, start to build the project and create a JAR
   file.

   (For NetBeans)

   Specify the Main Class
   Be sure to have the main class specified in the project. To do so, right click the project name under
   the Projects tab. Select Set Configuration and then Customize. The value in the field Main Class
   should be a class that has the main method.

   Build the Project
   Right click the project name under the Projects tab. Select Clean and Build. Or in the top menu bar,
   Run -> Clean and Build Project.

   The following change will be made during the build:
     * Two new folders, build and dist, are added to the project folder (referred to as the PROJECT_HOME
       folder).
     * All the sources are compiled into .class files, which are placed into the PROJECT_HOME\build
       folder.
     * A JAR file is created inside the PROJECT_HOME\dist folder.
     * Beside the JDK, if any libraries have been specified for the project, a lib folder will be
       created in the folder dist. The libraries will be copied into dist\lib.
     * The manifest file in the JAR is updated to include entries that designate main class and any
       libraries that are on the project's classpath.

3. Example
   Follow the instructions above, build a JAR file (inside the NetBeans) for Echo application (which is
   discussed in the post [21]Java Review: Application ).

   After the build completes, navigate to the PROJECT_HOME/dist folder. There are two files named
   Echo.jar and README.TXT.

   README.TXT contains the information about how to launch the application.

   To read the content, open README.TXT in a text editor. Part of the content is copied below that are
   instructions of running the application.
To run the project from the command line, go to the dist folder and
type the following:

java -jar "Echo.jar"

To distribute this project, zip up the dist folder (including the lib folder)
and distribute the ZIP file.

4. Launching the JAR File

   To run the application from the command line,
     * Inside the dist folder

   Navigate to the dist folder and type the following command:
java -jar "Echo.jar" coffee data 12 anything better
     * Outside of the dist folder

   To run the application from the command line outside of the dist folder, enter the full path
   (absolute path) to the jar file in the command:
java -jar "C:\PROJECT_HOME\dist\Echo.jar" coffee data 12 anything better

     Windows uses back slashes. Other operating systems and Web use forward slashes.

5. Distributing the Project
   As indicated in READEME.TXT, to distribute the project,
     * Zip up the dist folder (including the lib subfolder if there is one)
     * Send the ZIP file to the people who should be the recipients.


---
http://www.jdatalab.com/information_system/2017/01/21/java-application-example.html

Java Application: an example
Jan 21, 2017

   A Java application may consist of one or more classes. A class with the main method can be designated
   as the Main class.

   This example has the following parts.
    1. Problem Statement
    2. Step 1: Set up a Java Project MyApp
    3. Step 2: Create three Packages
    4. Step 3: Create a new Java Class classes.Person
    5. Step 4: Create a new Java Class managers.PersonManager
    6. Step 5: Create a new Java Class apps.StaffManagement
    7. Step 6: Configure and Run the Project
    8. Step 7: Build a Distribution
    9. Step 8. Run the Application
   10. Step 9. Share the Distribution
   11. Exercise
   12. Possible Further Improvements

Problem Statement
   The purpose of this example is about illustrating one structural design in an application prototype.
   The prototype contains three classes.

   The class, Person, is designed to meet the following object specifics:
     * It possesses the following private property members: firstName, lastName, gender, email, bDate
     * It must have a constructor Person() that initializes lastName, firstName and gender for each new
       Person instance.
     * It allows outsiders to read its property members.
     * Person.setEmail: Person allows outsides to update the email value.
     * Person.toString: Person can custom a string representation by overriding the default
       Object.toString method.
     * Person.print: Person can print its String representation to the console.

   The class, PersonManager, will perform the following functions to manage a collection of Person
   objects:
     * PersonManager has a property managerName.
     * PersonManager has a property staff which stores a collection of Person in an ArrayList.
     * Each new PersonManager instance can be initialized with a managerName value by constructor.
     * PersonManager provides interfaces to read its property values.
     * PersonManager.addPerson: create and add a Person instance into staff.
     * PersonManager.addPeople: add a collection of Person instances into staff.
     * PersonManager.printStaff: print each Person by calling Person.print method.

   The class, StaffManagement, is the Main class that will perform the following functions that have
   been designed for the application prototype:
     * Instantiate a new PersonManager with a managerName "staffManager".
     * Call staffManager to add three new Person instances, each with specific firstName, lastName and
       gender values.
     * Call staffManager to print the staff list.
     * Update the email value for each staff.
     * Call staffManager to print the staff list after email update.

   The following instructions are based on NetBeans IDE 8.2 for Windows.

Step 1: Set up a Java Project
    1. Launch NetBeans.
    2. Create a new Java project by following the menu path: File -> New Project.
    3. Then choose Java Application. Click Next.
    4. Enter the name "MyApp". Specify a different project location if needed. Uncheck the box
       "Create Main Class".
    5. Click Finish.

   A new project will open under the Project tab, showing the following project tree.

        MyApp/
        |
        +-- Libraries/
        |   |
        |   +-- JDK_1.8_default
        |
        +-- Source_Packages/
            |
            +-- default_package

    
Step 2: Create three Packages
   Create three packages named "classes", "managers" and "apps".

   To create a new package in a project, right click the node "Source Packages" in the project tree.
   Follow the menu path: New->Java Package. Enter a name for the package. Click Finish.

   Up to now, the project tree should look like the picture below, except you won't have three .java
   file in each package. In the following parts, these classes will be added into each package.

            MyApp/
            |
            +-- Libraries/
            |   |
            |   +-- JDK_1.8_default
            |
            +-- Source_Packages/
            |   |
            |   +-- apps/
            |   |   |
            |   |   +-- StafManagement.java
            |   |
            |   +-- classes/
            |   |   |
            |   |   +-- Person.java
            |   |   
            |   +-- managers/
            |       |
            |       +-- PersonManager.java
            |
            +-- Test_Libraries/
            |
            +-- Test_Packages/


Step 3: Create a new Java Class classes.Person

   Right click the target package "classes". Follow New -> Java Class. Enter the name "Person".
   Click Finish.
   An editor tab titled Person.java will immediately open with the default code.
   Enter the following source for classes.Person:
   
<code>
package classes;

public class Person {

    private String firstName;
    private String lastName;
    private String gender;
    private String bDate;
    private String email;

    public Person(String firstName, String lastName, String gender) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.gender = gender;
    }

    public void print(){
        // Print Person in its String format
        System.out.println(this.toString());
    }

    @Override
    public String toString() {
        // Custom a string representation
        return "Person{"
                + "firstName=" + firstName
                + ", lastName=" + lastName
                + ", gender=" + gender
                + ", bDate=" + bDate
                + ", email=" + email
                + '}';
    }

    public String getEmail() {
        return email;
    }
    public void setEmail(String email) {
        this.email = email;
    }
    public String getbDate() {
        return bDate;
    }

    public String getGender() {
        return gender;
    }

    public String getLastName() {
        return lastName;
    }

    public String getFirstName() {
        return firstName;
    }

}// End Class
</code>

Step 4: Create a new Java Class managers.PersonManager
   In the package "managers", add the Java class PersonManager.
   Enter the following source for managers.PersonManager:

<code>
package managers;

import classes.Person;
import java.util.ArrayList;
import java.util.Arrays;

public class PersonManager {

    private String managerName;
    private ArrayList<Person> staff;

    public PersonManager(String managerName) {
        this.managerName = managerName;
        this.staff = new ArrayList<>();
    }

    public void addPerson(String firstName, String lastName, String gender) {
        // Add a new person
        Person temp = new Person(firstName, lastName, gender);
        this.staff.add(temp);
    }

    public void addPeople(String[] fNames, String[] lNames, String[] genders) {
        // Add a group of people
        for (String x : fNames) {
            int pos = Arrays.asList(fNames).indexOf(x);
            this.addPerson(x, lNames[pos], genders[pos]);
        }
    }

    public void printStaff() {
        // Print all person items in ArrayList staff
        this.staff
            .stream()
            .forEach((person) -> {person.print();});
    }

    public String getManagerName() {
        return managerName;
    }

    public ArrayList<Person> getStaff() {
        return staff;
    }

}//End Class
</code>


Step 5: Create a new Java Class apps.StaffManagement
   In the package "apps", add the Java class StaffManagement.
   Enter the following source for apps.StaffManagementn:

<code>
package apps;

import managers.PersonManager;

public class StaffManagement {

    public static void main(String[] args) {
        // Instantiate a manager
        PersonManager staffManager = new PersonManager("Staff");
        // Operation set 1
        System.out.println("~~~Initializing three new staff... ");
        String[] fNames = {"Alpha","Betta","Cita"};
        String[] lNames = {"Cat","Dog","Pig"};
        String[] genders = {"f","m","f"};
        staffManager.addPeople(fNames, lNames, genders);
        staffManager.printStaff();

        // Operation set 2
        String[] emails = {"acat@org.com", "bdog@org.com", "cpig@org.com"};
        staffManager
                .getStaff()
                .stream()
                .forEach(p ->{
                    int pos = staffManager.getStaff().indexOf(p);
                    p.setEmail(emails[pos]);
                });
        System.out.println("~~~After updating emails: ");
        staffManager.printStaff();
    }//End main

}// End staffManagement
</code>


Step 6: Configure and Run the Project
   Right click the project name in the Projects tab. Follow the menu path: Set Configuration ->
   Customize ...

   In the Main Class: field, click Browse ... button to select apps.StaffManagement. Click Select Main
   Class button.
   Click OK button to finish configuration.
   Again right click the project name in the Projects tab. Click Run to run the project.


Step 7: Build a Distribution
   In the Projects tab, right click Clean and Build. In the %PROJECT_HOME% folder, a new folder
   'dist' will be created for storing at least two files: MyApp.jar and README.TXT.

Step 8: Run the Application

   To run the project jar file from the command line, go to the dist folder in the %PROJECT_HOME%
   directory and type the following:
java -jar "MyApp.jar"

   Or run the jar file anywhere by providing the full path:
java -jar "%PROJECT_HOME%\dist\MyApp.jar"

   A possible screenshot is shown below for Windows console.
C:\> java -jar G:\Projects\MyApp\dist\MyApp.jar
~~~Initializing three new staff...
Person{firstName=Alpha, lastName=Cat, gender=f, bDate=null, email=null}
Person{firstName=Betta, lastName=Dog, gender=m, bDate=null, email=null}
Person{firstName=Cita, lastName=Pig, gender=f, bDate=null, email=null}
~~~After updating emails:
Person{firstName=Alpha, lastName=Cat, gender=f, bDate=null, email=acat@org.com}
Person{firstName=Betta, lastName=Dog, gender=m, bDate=null, email=bdog@org.com}
Person{firstName=Cita, lastName=Pig, gender=f, bDate=null, email=cpig@org.com}

Step 9: Share the Distribution
   Compress the entire dist folder into a compressed file (such as a zip file). Send the zip file to the
   target people.

Exercise:
   Make a new format of printing/reporting each Person instance from PersonManager.staff.

Possible Further Improvements:
   The class managers.PersonManager can further be augmented to support more functions including, but
   not limited to:
     * PersonManager.sortStaffByName: Sort people by their names
     * PersonManager.groupStaffByGender: Partition people into two groups for male and female
     * PersonManager.searchStaffByName: Search people for a given name


Workout
   Make a Java project that contains a Main class and the Triangle class (Triangle.java is available at
   the post [http://www.jdatalab.com/java/2017/01/09/java-review-classes.html]Java Review: Classes, Instances,
   Properties, Methods.)

   The main class has the main method that will take three arguments from the user, create a new
   Triangle instance and assign the three arguments as integers to three side lengths a, b and c in
   order. Then the user should be notified by the text in the console, telling the user if his triangle
   is valid or not.

   Note: Each command-line argument in the main method is of type String. In order to take the numerical
   value from an argument, apply Integer.parseInt to the argument.

   For example, to convert (parse) the second argument in args to a numerical value, the expression is
Integer.parseInt(args[1])

   Submission (in a zip file):
    1. Your application in a .jar file
    2. The source file of all the classes (Triangle.java and the Main class)


---
https://docs.oracle.com/javase/tutorial/deployment/jar/build.html

Creating a JAR File

   The basic format of the command for creating a JAR file is:
jar cf jar-file input-file(s)

   The options and arguments used in this command are:
     * The c option indicates that you want to create a JAR file.
     * The f option indicates that you want the output to go to a file rather than to stdout.
     * jar-file is the name that you want the resulting JAR file to have. You can use any filename for a
       JAR file. By convention, JAR filenames are given a .jar extension, though this is not required.
     * The input-file(s) argument is a space-separated list of one or more files that you want to
       include in your JAR file. The input-file(s) argument can contain the wildcard * symbol. If any of
       the "input-files" are directories, the contents of those directories are added to the JAR archive
       recursively.

   The c and f options can appear in either order, but there must not be any space between them.

   This command will generate a compressed JAR file and place it in the current directory. The command
   will also generate a default manifest file for the JAR archive.

   Note:
   The metadata in the JAR file, such as the entry names, comments, and contents of the manifest, must
   be encoded in UTF8.

   You can add any of these additional options to the cf options of the basic command:
   CAPTION: jar command options

   Option   Description
   v        Produces verbose output on stdout while the JAR file is being built. The verbose output tells you
            the name of each file as it's added to the JAR file.
            
   0(zero)  Indicates that you don't want the JAR file to be compressed.
   
   M        Indicates that the default manifest file should not be produced.
   
   m        Used to include manifest information from an existing manifest file. The format for using this
            option is: jar cmf jar-file existing-manifest input-file(s)
            Modifying a Manifest File for more information about this option.
            Warning: The manifest must end with a new line or carriage return. The last line will not be parsed
            properly if it does not end with a new line or carriage return.
            
   -C       To change directories during execution of the command. See below for an example.

   
   Note:
   When you create a JAR file, the time of creation is stored in the JAR file. Therefore, even if the
   contents of the JAR file do not change, when you create a JAR file multiple times, the resulting
   files are not exactly identical. You should be aware of this when you are using JAR files in a build
   environment. It is recommended that you use versioning information in the manifest file, rather than
   creation time, to control versions of a JAR file. See the Setting Package Version Information
   section.

An Example
   Let us look at an example. A simple TicTacToe applet. You can see the source code of this applet by
   downloading the JDK Demos and Samples bundle from Java SE Downloads. This demo contains class
   files, audio files, and images having this structure:

                                 TicTacToe folder Hierarchy

                                       +-----------+
                                       | TicTacToe |
                                       +-----------+
                                             |
                            +----------------+--+---------------+
                            |                   |               |
                    +-----------------+     +-------+       +--------+
                    | TicTacToe.class |     | audio |       | images |
                    +-----------------+     +-------+       +--------+

   The audio and images subdirectories contain sound files and GIF images used by the applet.

   You can obtain all these files from jar/examples directory when you download the entire Tutorial
   online. To package this demo into a single JAR file named TicTacToe.jar, you would run this command
   from inside the TicTacToe directory:
jar cvf TicTacToe.jar TicTacToe.class audio images

   The audio and images arguments represent directories, so the Jar tool will recursively place them and
   their contents in the JAR file. The generated JAR file TicTacToe.jar will be placed in the current
   directory. Because the command used the v option for verbose output, you would see something similar
   to this output when you run the command:
adding: TicTacToe.class (in=3825) (out=2222) (deflated 41%)
adding: audio/ (in=0) (out=0) (stored 0%)
adding: audio/beep.au (in=4032) (out=3572) (deflated 11%)
adding: audio/ding.au (in=2566) (out=2055) (deflated 19%)
adding: audio/return.au (in=6558) (out=4401) (deflated 32%)
adding: audio/yahoo1.au (in=7834) (out=6985) (deflated 10%)
adding: audio/yahoo2.au (in=7463) (out=4607) (deflated 38%)
adding: images/ (in=0) (out=0) (stored 0%)
adding: images/cross.gif (in=157) (out=160) (deflated -1%)
adding: images/not.gif (in=158) (out=161) (deflated -1%)

   You can see from this output that the JAR file TicTacToe.jar is compressed. The Jar tool compresses
   files by default. You can turn off the compression feature by using the 0 (zero) option, so that the
   command would look like:
jar cvf0 TicTacToe.jar TicTacToe.class audio images

   You might want to avoid compression, for example, to increase the speed with which a JAR file could
   be loaded by a browser. Uncompressed JAR files can generally be loaded more quickly than compressed
   files because the need to decompress the files during loading is eliminated. However, there is a
   tradeoff in that download time over a network may be longer for larger, uncompressed files.

   The Jar tool will accept arguments that use the wildcard * symbol. As long as there weren't any
   unwanted files in the TicTacToe directory, you could have used this alternative command to construct
   the JAR file:
jar cvf TicTacToe.jar *

   Though the verbose output doesn't indicate it, the Jar tool automatically adds a manifest file to the
   JAR archive with path name META-INF/MANIFEST.MF. See the [34]Working with Manifest Files: The Basics
   section for information about manifest files.

   In the above example, the files in the archive retained their relative path names and directory
   structure. The Jar tool provides the -C option that you can use to create a JAR file in which the
   relative paths of the archived files are not preserved. It's modeled after TAR's -C option.

   As an example, suppose you wanted to put audio files and gif images used by the TicTacToe demo into a
   JAR file, and that you wanted all the files to be on the top level, with no directory hierarchy. You
   could accomplish that by issuing this command from the parent directory of the images and audio
   directories:
jar cf ImageAudio.jar -C images . -C audio .

   The -C images part of this command directs the Jar tool to go to the images directory, and the .
   following -C images directs the Jar tool to archive all the contents of that directory. The
   -C audio . part of the command then does the same with the audio directory. The resulting JAR file
   would have this table of contents:
META-INF/MANIFEST.MF
cross.gif
not.gif
beep.au
ding.au
return.au
yahoo1.au
yahoo2.au

   By contrast, suppose that you used a command that did not employ the -C option:
jar cf ImageAudio.jar images audio

   The resulting JAR file would have this table of contents:
META-INF/MANIFEST.MF
images/cross.gif
images/not.gif
audio/beep.au
audio/ding.au
audio/return.au
audio/yahoo1.au
audio/yahoo2.au


---
https://dzone.com/articles/java-8-how-to-create-executable-fatjar-without-ide

Create an Executable Fat JAR With Your Command Line

   Want to get an executable fat JAR file up and running with just your command line? See the groundwork
   you need to lay and how to get it done.

   This article is a unification of my blog posts reviewing the possibility of creating fat JARs
   (Java Archive file) in Java without using any additional plugin, IDE, or any other tool - just pure
   command line and Java.

   In the world of build tools (Ant, Maven, or Gradle) it might not even seem useful to
   think about the command line. The most famous IDEs (IntelliJ, Eclipse, or NetBeans) offer building
   tools and implementation immediately. But let's say you only have the command line and no Internet
   access.

   What will you do then?

Part 1: Compile ExecutableOne.jar
   The goal of this first part is to create an executable JAR file. Let's call it ExecutableOne.jar.
   Opening up your comand line, let's start with creation of a simple project folder: executable-one.
   The example project structure is following the Maven Standard Directory Layout structure.
./libs
./out
./README.md
./src
./src/main
./src/main/java
./src/main/java/com
./src/main/java/com/exec
./src/main/java/com/exec/one
./src/main/resources

   As our intent is to create an executable JAR file, we have to create a main class. Let's do it in the
   package: com.exec.one. The package can be found in the folder SRC/MAIN/JAVA of our sample project
   structure.
package com.exec.one;

public class Main {
    public static void main(String[] args){
        System.out.println("Main Class Start");
    }
}

   Inside the folder SRC/MAIN/RESOURCES, we create the META-INF folder, and then inside, we place
   MANIFEST.FM file there. Let's open the newly created MANIFEST.FM file and put in a basic description.
Manifest-Version: 1.0
Class-Path: .

Main-Class: com.exec.one.Main

   Note: There will be the only one MANIFEST.FM file per JAR file.

   The MANIFEST.FM file contains details on how the JAR file will be used. We're not going into deep
   details - let's stay focused on the options we have defined.
    1. Manifest-Version : manifest file version.
    2. Class-Path: The application or extension class loader uses the value of this attribute to
       construct its internal search path. Originally, the class loader downloads and opens each element
       in its search path. For these purposes, a simple linear search algorithm has been used.
    3. Main-Class: There is the name of the class that the launcher will load at the startup time.

   Now, we create the JAR file without any *.jar library. The LIBS folder in our project structure is
   still empty. To do so, we need to first compile the project by using javac. Meanwhile, we'll store
   the output in the OUT folder. Let's go back to our command line and, inside the root of the project,
   type:
$> javac -cp ./src/main/java ./src/main/java/com/exec/one/*.java -d ./out/

   The project has been compiled into the OUT directory. You can check it by using the ls command.
   The second step is to create an executable JAR file from the resources located inside the OUT
   directory. We go back to the command line and execute the following command:
$> jar cvfm ExecutableOne.jar ./src/main/resources/META-INF/MANIFEST.MF -C ./out/ .

   Let's briefly review/explain the JAR tool options we have used:
     * c: indicates we want to create a new JAR file.
     * v: generates verbose output to standard output.
     * f: specifies the jarfile to be created.
     * m: indicates the manifest file we use. The manifest file includes name-value pairs.
     * -C: indicates temporary changes to the directory. Classes are added from this directory to the
       JAR file. The dot indicates all classes (files).

   For the final output, open the command line and type:
$> java -jar ./ExecutableOne.jar

standard output:
Main Class Start


   Great job! Let's move to Part 2.

Part 2.: Compile ExecutableOne.jar With Additional Packages
   The main goal of this section is to show how you how to compile an executable JAR file with
   additional packages included. For such purposes, we've created MagicService. This service provides us
   with the getMessage() method and prints the message to the standard output.

   Let's open the command line and create a new folder, SERVICE, with file MagicService.java:
$> mkdir src/main/java/com/exec/one/service
$> vim src/main/java/com/exec/one/service/MagicService.java

   The newly created MagicService can be used in the following example:
package com.exec.one.service;

public class MagicService {

  private final String message;

    public MagicService(){
        this.message = "Magic Message";
    }

    public String getMessage(){
         return message;
    }

}

   The MagicService is located in a different place in the package structure than the Main class. Now we
   go back to the Main class and import the newly created MagicService. After the import and service
   instantiation, the Main class will receive the access to the getMessage() method. The Main class will
   change in following manner.
package com.exec.one;

import com.exec.one.service.MagicService;

public class Main {

    public static void main(String[] args){
        System.out.println("Main Class Start");
        MagicService service = new MagicService();
        System.out.println("MESSAGE : " + service.getMessage());
     }
}

   Now we have reached the point where the code is ready to compile. Let's go back to the command line
   and go into the root folder of the Executable-One project. The first step will be to
   compile/recompile the Executable-One project into the OUT folder. For these purposes, we need to add
   the location of the newly created class MagicService.java.
javac -cp ./src/main/java ./src/main/java/com/exec/one/*.java ./src/main/java/com/exec/one/**/*.java -d ./out/

   The second step is to create an executable JAR file from the compiled classes. We don't need to make
   any changes to the command because we have not changed the JAR file logic. It means that the
   MANIFEST.FM file stays as it is, without any changes:
1 Manifest-Version: 1.0
2 Class-Path: .
3 Main-Class: com.exec.one.Main

   Now we can again execute command similar to that of Part 1 in the root directory of the sample
   project:
jar cvfm ExecutableOne.jar ./src/main/resources/META-INF/MANIFEST.MF -C ./out/ .

   By executing the created JAR file, we obtain the message printed into the standard output.
$> java -jar ExecutableOne.jar
output:
Main Class Start
MESSAGE : Magic Message

   Congratulations! Great job, again !

Part 3: Create an Executable Fat JAR
   The goal of this part is to create a fat JAR (Java Archive) file that contains all the necessary
   dependencies of the developed program. As the external library, we need to use the JAR file we
   created in Part 2. In Part 3, we create a new sample project call it "Executable-Two" (which you can
   download from the link above).

   The executable-two project has following folder structure:
./libs
./libs/ExecutableOne.jar
./out
./README.md
./src
./src/main
./src/main/java
./src/main/java/com
./src/main/java/com/exec
./src/main/java/com/exec/two
./src/main/java/com/exec/two/Main.java
./src/main/resources
./src/main/resources/META-INF
./src/main/resources/META-INF/MANIFEST.MF

   The LIBS folder contains the previously created JAR file "ExecutableOne.jar." The "ExecutableOne.jar"
   contains the MagicService class, which we will use inside "ExecutableTwo." We will instantiate the
   class MagicService and execute the public method getMessage(). All this will happen inside the Main
   class of the project "ExecutableTwo".

   Let's create following Main class in the project package com.exec.two:
package com.exec.two;
import com.exec.one.service.MagicService;

public class Main {

    public static void main(String[] args){

        System.out.println("Executable-Two Main");
        MagicService service = new MagicService();
        System.out.println("MagicService from Executable-ONE");
        System.out.println("MESSAGE: " + service.getMessage());
     }
}

   Now we have everything prepared for our fat JAR file creation. We imported MagicService from the JAR
   library we have previously created and executed its getMessage() method. For the next few steps, we
   will use javac and the JAR tools provided by the Java JDK. Let's go back to the command line and compile
   the project. In the command, we need to inform the compiler that we should extend its classpath to
   the used library.
$> javac -cp ./src/main/java
./src/main/java/com/exec/two/*.java -d ./out/
-classpath ./libs/ExecutableOne.jar

   The "Executable-Two" project has been successfully compiled into the OUT directory.
   Now it's time to properly prepare the OUT directory for fat JAR creation. Inside the OUT directory,
   we have the compiled classes that we have created for "Executable-Two." Meanwhile, the JAR tool only
   reads the file physically located on the filesystem - it won't read the compressed JAR file. Of
   course, that means that the JAR tool will not decompress and read any *.jar file located inside the
   OUT directory.

   The result is that even when we copy the ExecutableOne.jar into the OUT directory, the JAR tool will
   not unpack the ExecutableOne.jar file, and the library will be added (in its compressed form) to the
   result. Of course, because it's compressed, it will be ignored.

   The problem is that the $> java -jar tool does not read inner packaged *.jar archive files!

   It implies that we need to unpack the previously created Java Archive (JAR) "Executable-One.jar" into
   the "Executable-Two" project 's OUT directory. Open the command line and type:
$cp libs/ExecutableOne.jar ./out/
$cd ./out
$tar xf ExecutableOne.jar
$rm ExecutableOne.jar

   Now, the "Executable-Two" project output directory is ready to be used as the source folder for the
   new JAR file.

   Note: Inside every executable JAR file, there is only one MANIFEST.FM file available.

   For packing our "Executable-Two" project into the JAR archive file, we use the newly created manifest
   file located in the folder ./src/main/resources/META-INF/ :
Manifest-Version: 1.0

Class-Path: .

Main-Class: com.exec.two.Main

   And now we can pack all that together by typing:
$> jar cvfm ExecutableTwo.jar ./src/main/resources/META-INF/MANIFEST.FM -C./out/ .

   When we do execute the newly created fat JAR file, "ExecutableTwo.jar", we receive the following
   output.
$> java -jar ./ExecutableTwo.jar
output:
Executable-Two Main
MagicService from Executable-ONE
MESSAGE: Magic Message

   Congratulations! You've executed your fat JAR file!


---
https://introcs.cs.princeton.edu/java/85application/jar/jar.html

Distributing your Application as an executable JAR file

   A JAR (Java ARchive) is a way of packaging together all of the resources associated with a program
   (class files, images, sounds, etc.). Putting your program in a JAR allows it to be distributed as a
   single executable file, saving space and simplifying the download process. The information in this
   tutorial applies to Java version 1.2 or higher. For more information about JAR files, follow [1]Sun's
   tutorial. To learn about [2]signing the JAR and [3]Java Web Start.

   A simple example. Let's say we wanted to distribute the simple program [4]Hello.java as a JAR. First,
   we create a text file named Hello.mf which contains:
Manifest-Version: 1.0
Main-Class: Hello

   Then, we create the archive by typing:
jar cmf Hello.mf Hello.jar Hello.class Hello.java

   and run it by typing:
java -jar Hello.jar

   The file Hello.jar can now be downloaded and executed.

   Creating an executable JAR file. Here is the general procedure for creating an executable JAR:
    1. Compile your java code, generating all of the program's class files.
    2. Create a manifest file containing the following 2 lines:
Manifest-Version: 1.0
Main-Class: name of class containing main


       The name of the file should end with the .mf suffix. It is important that the file ends with a
       blank line.
       
    3. To create the JAR, type the following command:
jar cmf manifest-file jar-file input-files

       The input-files must include any class files, images, sounds, etc. that your program uses.
       Optionally, you can include the program's .java files in the JAR. See below for adding
       directories ot the JAR.
       
    4. To view the contents of the JAR, type:
jar tf jar-file

    5. Execute the application from the command line by typing:
java -jar jar-file

       If the application is GUI-based, you can also launch it by double-clicking the JAR file.

   Accessing resources in a JAR. In general, the first step in accessing a JAR resource involves
   creating a URL. This might require modifying your program. For example, you can no longer use the
   following code fragment to read in an image that is stored in a file as follows

Image image = Toolkit.getDefaultToolkit().getImage(filename);

   Instead, create the URL object using

URL url = getClass.getResource(filename);
Image image = Toolkit.getDefaultToolkit().getImage(url);

   Or, if the code is in a static method of class X, then create the URL with

URL url = X.class.getResource(filename);

   Now, the resource can be accessed the same way, regardless of whether it is in a JAR or the current
   directory. See the method play(filename) in StdDraw.java for an example involving audio clips, and
   and the constructor In(String s) in In.java for an example involving text files.

   JAR Subdirectories. The JAR format also support storing files in a directory structure. Consider a
   program Sample.java, which uses the Turtle Graphics interface to display a collection of pictures
   stored in a subdirectory called images. Our working directory looks like:

MyDirectory/
    Sample.java
    Turtle.java
    
    Images/
        image1.jpg
        image2.jpg
        image3.jpg
    
    Sample.class
    Turtle.class
    Sample.mf

    
   The Manifest should read:

Manifest-Version: 1.0
Main-Class: Sample


   To create the JAR, type:

jar cmf Sample.mf Sample.jar Sample.class Turtle.class Sample.java Turtle.java images

   The contents listing appears as:

META-INF/
META-INF/MANIFEST.MF
Sample.class
Turtle.class
Sample.java
Turtle.java
images/
images/image1.gif
images/image2.gif
images/image3.gif

   Notice that the directory structure is still preserved (the META-INF directory is created to hold the
   manifest and other general information about the JAR).


---
https://coderwall.com/p/ssuaxa/how-to-make-a-jar-file-linux-executable

How to make a JAR file Linux executable

java
   Every Java programmer knows - or should known - that it is possible to create a runnable Java package
   archive (JAR), so that in order to launch an application it is enough to specify the jar file name on
   the Java interpreter command line along with the -jar parameter. For example:
$> java -jar helloworld.jar

   There are plenty of tutorials showing how to implement this feature using Ant, Maven, Eclipse,
   Netbens, etc.

   Anyway in its basic form, it just requires to add a MANIFEST.MF file to the jar package. The manifest
   must contain an entry Main-Class that specifies which is the class defining the main method for your
   application. For example:
$> javac HelloWorld.java
$> echo Main-Class: HelloWorld > MANIFEST.MF
$> jar -cvmf MANIFEST.MF helloworld.jar HelloWorld.class

   But this still requires your users to invoke the Java interpreter with the -jar option. There are
   many reasons why it would be preferable to have your app runnable by simply invoking it on the
   terminal shell like any other command.

   Here comes the protip!

   This technique it is based on the ability to append a generic binary payload to a Linux shell script.
   Read more about this here:
   http://www.linuxjournal.com/content/add-binary-payload-your-shell-scripts

   Taking advantage of this possibility the trick is just to embed a runnable jar file into a Bash
   script file. The script when executed will launch the Java interpreter specifying itself as the jar
   to run. Too complex? Much more easier to do in practice, than to explain!

   Let's say that you have a runnable jar named helloworld.jar

   Copy the Bash script below to a file named stub.sh
#!/bin/sh
MYSELF=`which "$0" 2>/dev/null`
[ $? -gt 0 -a -f "$0" ] && MYSELF="./$0"
java=java
if test -n "$JAVA_HOME"; then
    java="$JAVA_HOME/bin/java"
fi
exec "$java" $java_args -jar $MYSELF "$@"
exit 1 

   Than append the jar file to the saved script and grant the execute permission to the file resulting
   with the following command:
cat stub.sh helloworld.jar > hello.run && chmod +x helloworld.run

   That's all!

   Now you can execute the app just typing helloworld.run on your shell terminal.

   The script is smart enough to pass any command line parameters to the Java application transparently.
   Cool! Isn't it ?!

   In the case your are a Windows guy, obviously this will not work (except you will run a Linux
   compatibility layer like Cygwin).

   Anyway exist tools that are able to wrap a Java application into a native Windows .exe binary file,
   producing a result similar to the one explained in this tutorial.
   See for example http://launch4j.sourceforge.net/


---
https://www.tecmint.com/create-and-execute-jar-file-in-linux/

How to Create and Execute a .Jar File in Linux Terminal
August 23, 2018

   A JAR (Java ARchive) is platform-independent file format used to aggregate many Java class files and
   associated metadata and resources such as text, images, etc, into a single file for distribution.

   It allows Java runtimes to efficiently deploy an entire application in one archive file, and provides
   many benefits such as security, its elements may be compressed, shortening download times, allows for
   package sealing and versioning, supports portability. It also supports packaging for extensions.

   In this article, we will show how to create a simple Java application and bundle it into a JAR file,
   and demonstrate how to execute a .jar file from the Linux terminal.

   To do this, you must have java command line tool installed to launche a Java application, and the
   -jar flag to execute a program encapsulated in a JAR file. When this flag is used, the specified JAR
   file is the source of all user classes, and other class path settings are ignored.

How to Create a JAR File in Linux

   1. First start by writing a simple Java class with a main method for an application called
   TecmintApp, for demonstration purpose.
$> vim TecmintApp.java

   Copy and paste the following code to TecmintApp.java file.
public class TecmintApp {
    public static void main(String[] args) {
        System.out.println(" Just executed TecmintApp! ");
    }
}

   Save the file and close it.

   2. Next, we need to compile and pack the class into a JAR file using the javac and jar utilities as
   shown.
$> javac -d . TecmintApp.java
$> ls
$> jar cvf tecmintapp.jar TecmintApp.class
$> ls

   3. Once tecmintapp.jar created, now you can excute the file using java command as shown.
$> java -jar tecmintapp.jar

no main manifest attribute, in tecmintapp.jar

   From the output of the above command, we encountered an error. The JVM (Java Virtual Machine)
   couldn't find our main manifest attribute, thus it could not locate the main class containing the
   main method (public static void main (String[] args)).

   The JAR file should have a manifest that contains a line in the form Main-Class:classname that
   defines the class with the main method that serves as our application's starting point.

   4. To fix the above error, we will need to update the JAR file to include a manifest attribute
   together with our code. Let's create a MANIFEST.MF file.
$> vim MANIFEST.MF

   Copy and paste the following line to MANIFEST.MF file.
Main-Class:  TecmintApp

   Save the file and let's add the file MANIFEST.MF to our tecmintapp.jar using following command.
$> jar cvmf MANIFEST.MF tecmintapp.jar TecmintApp.class

   5. Finally, when we executed the JAR file again, it should produce the expected result as shown in
   the output.
$> java -jar tecmintapp.jar

Just executed TecmintApp!

   For more information, see the java, javac and jar command man pages.
$> man java
$> man javac
$> man jar

   That's all! In this short article, we have explained how to create a simple Java application and
   bundle it into a JAR file, and demonstrated how to execute a .jar file from the terminal. If you have
   any questions or supplementary ideas to share, use the feedback form below.


---
