filename: jv_sending-email-via-gmail-2020-multif_20201002.txt
https://pepipost.com/tutorials/examples-for-sending-emails-from-javamail-api/

Simple examples for sending emails from JavaMail API
2020-06-01 

Introduction
   JavaMail API provides a platform-independent and protocol-independent framework to build mail and
   messaging client applications using Java.

   Java Mail API is generic and provides abstract classes containing objects that are being defined in
   the email system and act as an interface to email applications.

   JavaMail API is generic for reading and sending emails. And require service providers to interact
   with mail servers running on transport protocol like:
    1. Simple Mail Transfer Protocol(SMTP)
       SMTP is internet standard for sending and receiving Email across IP networks it uses TCP with
       most popularly port 25 to send and receive. SSL can secure connections. JavaMail API has packages
       and core classes com.sun.mail.smtp. This acts as an SMTP protocol provider to connect any SMTP
       servers.
    2. Internet Message Access Protocol(IMAP)
       IMAP server listens mostly on port 143. And, IMAP over SSL uses the assigned port 993. Using IMAP
       protocol provider in JavaMail API package: com.sun.mail.imap.
    3. Post Office Protocol (POP)
       POP3 is an internet standard protocol used by local email clients to access email from a remote
       server over TCP/IP.POP3 server listens on port 110. Following is the POP3 protocol provider in
       JavaMail API: com.sun.mail.pop3

Installing JavaMail API
   To use JavaMail API, you would require to add two jars in your CLASSPATH:
    1. mail.jar
    2. activation.jar.

   If you are using Maven, Create a Maven Project referring this link.
Note: JavaBeans Activation Framework (JAF) extension that provides the (activation.jar) javax.activation
package is already present in Java SE 6 and later versions.

Send Emails
   To Send Email, you will need an SMTP server. In case you don't have an SMTP server, you can
   install one or just use some SMTP service providers like Pepipost.

   Here, are few helpful tutorials in case you want to install the SMTP server on your machine:
     * How To Install Postfix CentOS 7
     * Installing Postfix as a Send-Only SMTP Server on Debian 10 (2019)

Sample Code to Send Email Using SMTP

<code>
package com.sendemail;
import java.util.Properties;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
public class SendMail {
    public static void main(String[] args) {
        // Mention the Recipient's email address
        String to = "fromaddress@gmail.com";
        // Mention the Sender's email address
        String from = "toaddress@gmail.com";
        // Mention the SMTP server address. Below Gmail's SMTP server is being used to send email
        String host = "smtp.gmail.com";
        // Get system properties
        Properties properties = System.getProperties();
        // Setup mail server
        properties.put("mail.smtp.host", host);
        properties.put("mail.smtp.port", "465");
        properties.put("mail.smtp.ssl.enable", "true");
        properties.put("mail.smtp.auth", "true");
        // Get the Session object.// and pass username and password
        Session session = Session.getInstance(properties, new javax.mail.Authenticator() {
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication("fromaddress@gmail.com", "*******");
            }
        });
        // Used to debug SMTP issues
        session.setDebug(true);
        try {
            // Create a default MimeMessage object.
            MimeMessage message = new MimeMessage(session);
            // Set From: header field of the header.
            message.setFrom(new InternetAddress(from));
            // Set To: header field of the header.
            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));
            // Set Subject: header field
            message.setSubject("This is the Subject Line!");
            // Now set the actual message
            message.setText("This is actual message");
            System.out.println("sending...");
            // Send message
            Transport.send(message);
            System.out.println("Sent message successfully....");
        } catch (MessagingException mex) {
            mex.printStackTrace();
        }
    }
}
</code>

   Let's break down the above code into three parts, for better understanding:

   #1. Getting The Mail Session:
   The session is the context of how you are going to interact with the mail host. Helpful in debugging
   output from the mail host, timeouts, and managing authentication mechanisms. Session class provides
   two methods to get the session object:

   - getDefaultInstance(): Return default session.overloaded as below:
public static Session getDefaultInstance(Properties props)
public static Session getDefaultInstance(Properties props,Authenticator auth)

   - getInstance(): Returns new session.
public static Session getInstance(Properties props)
public static Session getInstance(Properties props,Authenticator auth)

   Authenticator class represents an object that knows how to obtain authentication for a network
   connection. One must register the Authenticator with the Session when you create a session object.

   #2. Creating Message Content:
   To create the message, need to pass session object in MimeMessage class constructor:
MimeMessage message=new MimeMessage(session);

   The message object will be used to store information.
   like from address, to address, subject and message body. InternetAddress represents an RFC 822
   address.

   #3. Transporting Message over the selected protocol:
   Transport class is being used for message transport mechanism. This class uses the SMTP protocol to
   send a message. That's it you have sent an email over SMTP using Java Mail API.


Errors while Sending Mail Using Java Mail API
#Error 1: Build Error javax.mail.internet.MimeMessage cannot be resolved.

   Solution: This occurs if javax.mail.internet.MimeMessage is missing in your classpath. Add it or if
   using maven add dependencies in pom.xml.

#Error 2: SendFailedException.getValidUnsentAddresses() not returning value as expected.
   Solution: You need to enable property mail.smtp.reportsuccess and mail.smtp.sendpartial .

#Error 3: Unable to give multiple CC's
   Solution: Use the below code:
    Address[] cc = new Address[] {InternetAddress.parse("abc@abc.com"),
                               InternetAddress.parse("abc@def.com"),
                               InternetAddress.parse("ghi@abc.com")};
    message.addRecipients(Message.RecipientType.CC, cc);

#Error 4: Email sent through SMTP which contains German characters (umlauts) content is not displaying
correctly.
   Solution: You must set proper encoding for message subject, body etc.
   as follow:
setContent(content, "UTF-8")

   mail.mime.charset by default uses the Java charset, as specified in the file.encoding. file.encoding
   property is specified when JVM starts up however you can set it up while running your java program as
   follow:
java -Dfile.encoding=UTF-8 ... com.x.Main

   By the time you reach here, you would have explored much of JavaMail API.

   One Fact:
   Oracle Java JDK and JVM are paid, but JavaMail API still is free and opensource as it is published
   under Common Development and Distribution License (CDDL) v1.1 and GNU General Public License (GPL) v2
   with Classpath Exception.
   JavaMail API is widely used in Android, Spring Applications.

   Let's See Some examples of sending email using various properties of JavaMail API.


Send an email through SMTP without authentication.

   Sample Code:

<code>
package com.sendemail;

import java.util.Properties;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

public class SendMail {

    public static void main(String[] args) {

        // Mention the Recipient's email address
        String to = "fromaddress@gmail.com";

        // Mention the Sender's email address
        String from = "toaddress@gmail.com";

        // Get system properties
        Properties properties = System.getProperties();

        // Setup mail server
        properties.put("mail.smtp.host", "smtp.host.com");
        properties.put("mail.smtp.port", "465");

        // Get the Session object and pass username and password
        Session session = Session.getInstance(properties);

        try {
            // Create a default MimeMessage object.
            MimeMessage message = new MimeMessage(session);

            // Set From: header field of the header.
            message.setFrom(new InternetAddress(from));

            // Set To: header field of the header.
            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));

            // Set Subject: header field
            message.setSubject("This is the Subject Line!");

            // Now set the actual message
            message.setText("This is actual message");

            System.out.println("sending...");
            // Send message
            Transport.send(message);
            System.out.println("Sent message successfully....");
        } catch (MessagingException mex) {
            mex.printStackTrace();
        }
    }
}
</code>

   For the above code to work there should be no authentication at your SMTP server.

   But in real life SMTP servers uses authentication like TLS or SSL.
   Let's jump to an example of setting TLS or SSL.

Send email using TLS and SSL authentication
   To establish an SSL/TLS connection, applications using JavaMail API (client) must be able to verify
   that the security certificate presented by the server is trusted by the client's application. Trusted
   certificates are maintained in a Java Keystore file on the client.
    1. Using TLS
       You need to set mail.smtp.starttls.enable to true.
       By default 587 ports default to TLS.
       Here is sample code:

<code>
package com.sendemail;
import java.util.Properties;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

public class SendMail {

    public static void main(String[] args) {

        // Mention the Recipient's email addess
        String to = "toaddress@gmail.com";

        // Mention the Sender's email address
        String from = "fromaddress@gmail.com";

        // Mention the SMTP server address. Below Gmail's SMTP server is being used to send email
        String host = "smtp.gmail.com";

        // Get system properties
        Properties properties = System.getProperties();

        // Setup mail server
        properties.put("mail.smtp.host", host);
        properties.put("mail.smtp.port", "587");
        properties.put("mail.smtp.starttls.enable", "true");
        properties.put("mail.smtp.auth", "true");

        // Get the Session object.// and pass username and password
        Session session = Session.getInstance(properties, new javax.mail.Authenticator() {

            protected PasswordAuthentication getPasswordAuthentication() {

                return new PasswordAuthentication("fromaddress@gmail.com", "*******");

            }

        });

        // Used to debug SMTP issues
        session.setDebug(true);

        try {
            // Create a default MimeMessage object.
            MimeMessage message = new MimeMessage(session);

            // Set From: header field of the header.
            message.setFrom(new InternetAddress(from));

            // Set To: header field of the header.
            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));

            // Set Subject: header field
            message.setSubject("This is the Subject Line!");

            // Now set the actual message
            message.setText("This is actual message");

            System.out.println("sending...");
            // Send message
            Transport.send(message);
            System.out.println("Sent message successfully....");
        } catch (MessagingException mex) {
            mex.printStackTrace();
        }

    }
}
</code>

   2. Using SSL
   In earlier releases, it was necessary to explicitly set a socket factory property to enable the use
   of SSL. From Java Mail API 1.5 it is no longer needed, as the support for SSL is in-built.

   JavaMail API has a special SSL socket factory that can simplify dealing with servers with self-signed
   certificates.

   class com.sun.mail.util.MailSSLSocketFactory can be used as a simple socket factory to allow trusting
   all or some hosts.

   MailSSLSocketFactory avoids the need for managing keystore, or configure your own TrustManager and
   add a certificate in keystore.

   Sample Code:

<code>
package com.sendemail;

import java.util.Properties;

import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
import com.sun.mail.util.MailSSLSocketFactory;

public class SendMail {

    public static void main(String[] args) {

        // Mention the Recipient's email address
        String to = "toaddress@gmail.com";

        // Mention the Sender's email address
        String from = "fromaddress@gmail.com";

        // Mention the SMTP server address. Below Gmail's SMTP server is being used to send email
        String host = "smtp.gmail.com";

        MailSSLSocketFactory sf = new MailSSLSocketFactory();
    sf.setTrustAllHosts(true);
    // or
    // sf.setTrustedHosts(new String[] { "my-server" });

        // Get system properties
        Properties properties = System.getProperties();

        // Setup mail server
        properties.put("mail.smtp.host", host);
        properties.put("mail.smtp.port", "587");
        properties.put("mail.smtp.starttls.enable", "true");
        properties.put("mail.smtp.auth", "true");
        props.put("mail.smtp.ssl.socketFactory", sf);
        // Get the Session object.// and pass username and password
        Session session = Session.getInstance(properties, new javax.mail.Authenticator() {

            protected PasswordAuthentication getPasswordAuthentication() {

                return new PasswordAuthentication("fromaddress@gmail.com", "*******");

            }

        });

        // Used to debug SMTP issues
        session.setDebug(true);

        try {
            // Create a default MimeMessage object.
            MimeMessage message = new MimeMessage(session);

            // Set From: header field of the header.
            message.setFrom(new InternetAddress(from));

            // Set To: header field of the header.
            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));

            // Set Subject: header field
            message.setSubject("This is the Subject Line!");

            // Now set the actual message
            message.setText("This is actual message");

            System.out.println("sending...");
            // Send message
            Transport.send(message);
            System.out.println("Sent message successfully....");
        } catch (MessagingException mex) {
            mex.printStackTrace();
        }

    }

}
</code>

Sending Inline Image in Email

   Here is sample code :

<code>
package com.sendemail;

import java.util.Properties;
import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.activation.FileDataSource;
import javax.mail.BodyPart;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;

public class SendInlineImagesInEmail {
   public static void main(String[] args) {
      // Mention the Recipient's email address
      String to = "recipientemail@gmail.com";

      // Mention the Sender's email address
      String from = "fromemail@gmail.com";
      final String username = "rishabhmishra131";//change accordingly
      final String password = "******";//change accordingly

      // Mention the SMTP server address. Below Pepipost's SMTP server is being used to send email
      String host = "smtp.pepipost.com";

      Properties props = new Properties();
      props.put("mail.smtp.auth", "true");
      props.put("mail.smtp.starttls.enable", "true");
      props.put("mail.smtp.host", host);
      props.put("mail.smtp.port", "587");

      Session session = Session.getInstance(props,
         new javax.mail.Authenticator() {
            protected PasswordAuthentication getPasswordAuthentication() {
               return new PasswordAuthentication(username, password);
            }
         });

      try {

         // Create a default MimeMessage object.
         Message message = new MimeMessage(session);

         // Set From: header field of the header.
         message.setFrom(new InternetAddress(from));

         // Set To: header field of the header.
         message.setRecipients(Message.RecipientType.TO,
            InternetAddress.parse(to));

         // Set Subject: header field
         message.setSubject("Testing Subject");

         // This mail will have two parts, BODY and embedded image
         MimeMultipart multipart = new MimeMultipart("related");

         // first part (the html)
         BodyPart messageBodyPart = new MimeBodyPart();
         String htmlText = "<H1>Hello</H1><img src=\"cid:image-id\">";
         messageBodyPart.setContent(htmlText, "text/html");
         // add it
         multipart.addBodyPart(messageBodyPart);

         // second part (the image)
         messageBodyPart = new MimeBodyPart();
         DataSource fds = new FileDataSource(
            "/home/rishabh.mishra/sampleimage.png");

         messageBodyPart.setDataHandler(new DataHandler(fds));
         messageBodyPart.setHeader("Content-ID", "<image-id>");

         // add image to the multipart
         multipart.addBodyPart(messageBodyPart);

         // put everything together
         message.setContent(multipart);
         // Send message
         Transport.send(message);

         System.out.println("Sent message successfully....");

      } catch (MessagingException e) {
         throw new RuntimeException(e);
      }
   }
}
</code>

   Here in this example image file has been used as an attachment. So, you have to set the Content-ID
   header for the image file and then use the same Content-ID in the email message body with:
<img src='cid:image-id'>


Common Errors/Exceptions with JavaMail API
   JavaMail API has it own com.sun.mail.smtp  package for sending mail using SMTP protocol through which
   your program can access the SMTP server. The list for exception which com.sun.mail.smtp  throws is as
   follows :
    1. SMTPAddressFailedException
       Most common error which occurs when email cannot be sent.
    2. SMTPAddressSucceededException
       This exception is used to notify successful message in order to turn off. Set
       mail.smtp.reportsuccess property false.
    3. SMTPSenderFailedException
       Error when email cannot be sent.
    4. SMTPSendFailedException
       Occurs when sender address is rejected at Mailer server end

   Few Examples :
   - SMTPAddressFailedException :
com.sun.mail.smtp.SMTPAddressFailedException: 550 5.7.1 Unable to relay

   The above error is from the SMTP server, not JavaMail. It usually occurs when your mail server is not
   configured to send email through it.
   ]https://javaee.github.io/javamail/FAQ#norelay

   So setting up an approach for handling error would be enabling logs for an email client. Once you
   have logged the share the error with your administrator who handles email clients.

   The JavaMail logs go to system OUT, which is probably your catalina.out, the localhost<xxx> file or
   WEB-INF\logs\jasperserver.log - depending on your configuration.

   - SMTPSendFailedException
com.sun.mail.smtp.SMTPSendFailedException: 530-5.5.1 Authentication Required

   Above error occurs when your SMTP user and password is incorrect or you have updated the config but
   not reload app server.

   Note: This error usually occurs while sending a mail with Gmail because Google doesn't allow to send
   an email without authentication.

Conclusion
   Hope this tutorial helped to learn the details of Java Mail APIs. Various use case scenarios, like
   sending email using SMTP, exploring the authentication mechanism, sending inline images and using
   TLS/SSL were covered as a part of this tutorial.


---
https://www.journaldev.com/2532/javamail-example-send-mail-in-java-smtp

JavaMail Example - Send Mail in Java using SMTP

   Today we will look into JavaMail Example to send email in java programs. Sending emails is one of the
   common tasks in real life applications and that's why Java provides robust JavaMail API that we can
   use to send emails using SMTP server. JavaMail API supports both TLS and SSL authentication for
   sending emails.

JavaMail Example
   Today we will learn how to use JavaMail API to send emails using SMTP server with no authentication,
   TLS and SSL authentication and how to send attachments and attach and use images in the email body.
   For TLS and SSL authentication, I am using GMail SMTP server because it supports both of them.

   JavaMail API is not part of standard JDK, so you will have to download it from it's official website
   i.e JavaMail Home Page. Download the latest version of the JavaMail reference implementation and
   include it in your project build path. The jar file name will be javax.mail.jar.

   If you are using Maven based project, just add below dependency in your project.
<dependency>
        <groupId>com.sun.mail</groupId>
        <artifactId>javax.mail</artifactId>
        <version>1.5.5</version>
</dependency>

   Java Program to send email contains following steps:
    1. Creating javax.mail.Session object
    2. Creating javax.mail.internet.MimeMessage object, we have to set different properties in this
       object such as recipient email address, Email Subject, Reply-To email, email body, attachments
       etc.
    3. Using javax.mail.Transport to send the email message.

   The logic to create session differs based on the type of SMTP server, for example if SMTP server
   doesn't require any authentication we can create the Session object with some simple properties
   whereas if it requires TLS or SSL authentication, then logic to create will differ.

   So I will create a utility class with some utility methods to send emails and then I will use this
   utility method with different SMTP servers.

JavaMail Example Program
   Our EmailUtil class that has a single method to send email looks like below, it requires
   javax.mail.Session and some other required fields as arguments. To keep it simple, some of the
   arguments are hard coded but you can extend this method to pass them or read it from some config
   files.

<code>
package com.journaldev.mail;

import java.io.UnsupportedEncodingException;
import java.util.Date;

import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.activation.FileDataSource;
import javax.mail.BodyPart;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;

public class EmailUtil {

    /**
     * Utility method to send simple HTML email
     * @param session
     * @param toEmail
     * @param subject
     * @param body
     */
    public static void sendEmail(Session session, String toEmail, String subject, String body) {
        try {
            MimeMessage msg = new MimeMessage(session);
            //set message headers
            msg.addHeader("Content-type", "text/HTML; charset=UTF-8");
            msg.addHeader("format", "flowed");
            msg.addHeader("Content-Transfer-Encoding", "8bit");
            msg.setFrom(new InternetAddress("no_reply@example.com", "NoReply-JD"));
            msg.setReplyTo(InternetAddress.parse("no_reply@example.com", false));
            msg.setSubject(subject, "UTF-8");
            msg.setText(body, "UTF-8");
            msg.setSentDate(new Date());
            msg.setRecipients(Message.RecipientType.TO, InternetAddress.parse(toEmail, false));
            System.out.println("Message is ready");
            Transport.send(msg);

            System.out.println("EMail Sent Successfully!!");
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code>

   Notice that I am setting some header properties in the MimeMessage, they are used by the email
   clients to properly render and display the email message. Rest of the program is simple and self
   understood.

   Now let's create our program to send email without authentication.

Send Mail in Java using SMTP without authentication

<code>
package com.journaldev.mail;

import java.util.Properties;
import javax.mail.Session;

public class SimpleEmail {

    public static void main(String[] args) {

        System.out.println("SimpleEmail Start");
        String smtpHostServer = "smtp.example.com";
        String emailID = "email_me@example.com";
        Properties props = System.getProperties();
        props.put("mail.smtp.host", smtpHostServer);
        Session session = Session.getInstance(props, null);
        EmailUtil.sendEmail(session, emailID,"SimpleEmail Testing Subject", "SimpleEmail Testing Body");
    }
}
</code>

   Notice that I am using Session.getInstance() to get the Session object by passing the Properties
   object. We need to set the mail.smtp.host property with the SMTP server host. If the SMTP server is
   not running on default port (25), then you will also need to set mail.smtp.port property. Just run
   this program with your no-authentication SMTP server and by setting recipient email id as your own
   email id and you will get the email in no time.

   The program is simple to understand and works well, but in real life most of the SMTP servers use
   some sort of authentication such as TLS or SSL authentication. So we will now see how to create
   Session object for these authentication protocols.

Send Email in Java SMTP with TLS Authentication

<code>
package com.journaldev.mail;

import java.util.Properties;

import javax.mail.Authenticator;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;

public class TLSEmail {

    /**
       Outgoing Mail (SMTP) Server
       requires TLS or SSL: smtp.gmail.com (use authentication)
       Use Authentication: Yes
       Port for TLS/STARTTLS: 587
     */
    public static void main(String[] args) {
        final String fromEmail = "myemailid@gmail.com";     //requires valid gmail id
        final String password = "mypassword";               // correct password for gmail id
        final String toEmail = "myemail@yahoo.com";         // can be any email id
        System.out.println("TLSEmail Start");
        Properties props = new Properties();
        props.put("mail.smtp.host", "smtp.gmail.com");      //SMTP Host
        props.put("mail.smtp.port", "587");                 //TLS Port
        props.put("mail.smtp.auth", "true");                //enable authentication
        props.put("mail.smtp.starttls.enable", "true");     //enable STARTTLS

        //create Authenticator object to pass in Session.getInstance argument
        Authenticator auth = new Authenticator() {
            //override the getPasswordAuthentication method
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication(fromEmail, password);
            }
        };
        
        Session session = Session.getInstance(props, auth);
        EmailUtil.sendEmail(session, toEmail,"TLSEmail Testing Subject", "TLSEmail Testing Body");
    }
}
</code>

   Since I am using GMail SMTP server that is accessible to all, you can set the correct variables in
   above program and run for yourself. Believe me it works!! 🙂

Java SMTP Example with SSL Authentication

<code>
package com.journaldev.mail;

import java.util.Properties;

import javax.mail.Authenticator;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;

public class SSLEmail {

    /**
       Outgoing Mail (SMTP) Server
       requires TLS or SSL: smtp.gmail.com (use authentication)
       Use Authentication: Yes
       Port for SSL: 465
     */
    public static void main(String[] args) {
        final String fromEmail = "myemailid@gmail.com";         //requires valid gmail id
        final String password = "mypassword";                   // correct password for gmail id
        final String toEmail = "myemail@yahoo.com";             // can be any email id
        System.out.println("SSLEmail Start");
        Properties props = new Properties();
        props.put("mail.smtp.host", "smtp.gmail.com");          //SMTP Host
        props.put("mail.smtp.socketFactory.port", "465");       //SSL Port
        props.put("mail.smtp.socketFactory.class",
            "javax.net.ssl.SSLSocketFactory");                  //SSL Factory Class
        props.put("mail.smtp.auth", "true");                    //Enabling SMTP Authentication
        props.put("mail.smtp.port", "465");                     //SMTP Port

        Authenticator auth = new Authenticator() {
            //override the getPasswordAuthentication method
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication(fromEmail, password);
            }
        };

        Session session = Session.getDefaultInstance(props, auth);
        System.out.println("Session created");
        EmailUtil.sendEmail(session, toEmail,"SSLEmail Testing Subject", "SSLEmail Testing Body");

        EmailUtil.sendAttachmentEmail(session, toEmail,"SSLEmail Testing Subject with Attachment", \
        "SSLEmail Testing Body with Attachment");

        EmailUtil.sendImageEmail(session, toEmail,"SSLEmail Testing Subject with Image", \
        "SSLEmail Testing Body with Image");
    }
}
</code>

   The program is almost same as TLS authentication, just some properties are different. As you can see
   that I am calling some other methods from EmailUtil class to send attachment and image in email but I
   haven't defined them yet. Actually I kept them to show later and keep it simple at start of the
   tutorial.

JavaMail Example - send mail in java with attachment
   To send a file as attachment, we need to create an object of javax.mail.internet.MimeBodyPart and
   javax.mail.internet.MimeMultipart. First add the body part for the text message in the email and then
   use FileDataSource to attach the file in second part of the multipart body. The method looks like
   below.

<code>
/**
 * Utility method to send email with attachment
 * @param session
 * @param toEmail
 * @param subject
 * @param body
 */
public static void sendAttachmentEmail(Session session, String toEmail, String subject, String body){
    try {
        MimeMessage msg = new MimeMessage(session);
        msg.addHeader("Content-type", "text/HTML; charset=UTF-8");
        msg.addHeader("format", "flowed");
        msg.addHeader("Content-Transfer-Encoding", "8bit");
        msg.setFrom(new InternetAddress("no_reply@example.com", "NoReply-JD"));
        msg.setReplyTo(InternetAddress.parse("no_reply@example.com", false));
        msg.setSubject(subject, "UTF-8");
        msg.setSentDate(new Date());
        msg.setRecipients(Message.RecipientType.TO, InternetAddress.parse(toEmail, false));
    
        // Create the message body part
        BodyPart messageBodyPart = new MimeBodyPart();
    
        // Fill the message
        messageBodyPart.setText(body);
    
        // Create a multipart message for attachment
        Multipart multipart = new MimeMultipart();
    
        // Set text message part
        multipart.addBodyPart(messageBodyPart);
    
        // Second part is attachment
        messageBodyPart = new MimeBodyPart();
        String filename = "abc.txt";
        DataSource source = new FileDataSource(filename);
        messageBodyPart.setDataHandler(new DataHandler(source));
        messageBodyPart.setFileName(filename);
        multipart.addBodyPart(messageBodyPart);
    
        // Send the complete message parts
        msg.setContent(multipart);
    
        // Send message
        Transport.send(msg);
        System.out.println("EMail Sent Successfully with attachment!!");
        
    } catch (MessagingException e) {
        e.printStackTrace();
        
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    }
}
</code>

   The program might look complex at first look but it's simple, just create a body part for text
   message and another body part for attachment and then add them to the multipart. You can extend this
   method to attach multiple files too.

JavaMail example - send mail in java with image
   Since we can create HTML body message, if the image file is located at some server location we can
   use img element to show them in the message. But sometimes we want to attach the image in the email
   and then use it in the email body itself. You must have seen so many emails that have image
   attachments and are also used in the email message.

   The trick is to attach the image file like any other attachment and then set the Content-ID header
   for image file and then use the same content id in the email message body with <img
   src='cid:image_id'>.

<code>
/**
 * Utility method to send image in email body
 * @param session
 * @param toEmail
 * @param subject
 * @param body
 */
public static void sendImageEmail(Session session, String toEmail, String subject, String body) {
    try {
        MimeMessage msg = new MimeMessage(session);
        msg.addHeader("Content-type", "text/HTML; charset=UTF-8");
        msg.addHeader("format", "flowed");
        msg.addHeader("Content-Transfer-Encoding", "8bit");
        msg.setFrom(new InternetAddress("no_reply@example.com", "NoReply-JD"));
        msg.setReplyTo(InternetAddress.parse("no_reply@example.com", false));
        msg.setSubject(subject, "UTF-8");
        msg.setSentDate(new Date());
        msg.setRecipients(Message.RecipientType.TO, InternetAddress.parse(toEmail, false));
    
        // Create the message body part
        BodyPart messageBodyPart = new MimeBodyPart();
        messageBodyPart.setText(body);
    
        // Create a multipart message for attachment
        Multipart multipart = new MimeMultipart();
    
        // Set text message part
        multipart.addBodyPart(messageBodyPart);
    
        // Second part is image attachment
        messageBodyPart = new MimeBodyPart();
        String filename = "image.png";
        DataSource source = new FileDataSource(filename);
        messageBodyPart.setDataHandler(new DataHandler(source));
        messageBodyPart.setFileName(filename);
        
        //Trick is to add the content-id header here
        messageBodyPart.setHeader("Content-ID", "image_id");
        multipart.addBodyPart(messageBodyPart);
    
        //third part for displaying image in the email body
        messageBodyPart = new MimeBodyPart();
        messageBodyPart.setContent("<h1>Attached Image</h1>" +
            "<img src='cid:image_id'>", "text/html");
        multipart.addBodyPart(messageBodyPart);
    
        //Set the multipart message to the email message
        msg.setContent(multipart);
    
        // Send message
        Transport.send(msg);
        System.out.println("EMail Sent Successfully with image!!");
     
    } catch (MessagingException e) {
        e.printStackTrace();
        
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    }
}
</code>

JavaMail API Troubleshooting Tips
    1. java.net.UnknownHostException comes when your system is not able to resolve the IP address for
       the SMTP server, it might be wrong or not accessible from your network. For example, GMail SMTP
       server is smtp.gmail.com and if I use smtp.google.com, I will get this exception. If the hostname
       is correct, try to ping the server through command line to make sure it's accessible from your
       system.
pankaj@Pankaj:~/CODE$ ping smtp.gmail.com
PING gmail-smtp-msa.l.google.com (74.125.129.108): 56 data bytes
64 bytes from 74.125.129.108: icmp_seq=0 ttl=46 time=38.308 ms
64 bytes from 74.125.129.108: icmp_seq=1 ttl=46 time=42.247 ms
64 bytes from 74.125.129.108: icmp_seq=2 ttl=46 time=38.164 ms
64 bytes from 74.125.129.108: icmp_seq=3 ttl=46 time=53.153 ms

    2. If your program is stuck in Transport send() method call, check that SMTP port is correct. If
       it's correct then use telnet to verify that it's accessible from you machine, you will get output
       like below.
pankaj@Pankaj:~/CODE$ telnet smtp.gmail.com 587
Trying 2607:f8b0:400e:c02::6d...
Connected to gmail-smtp-msa.l.google.com.
Escape character is '^]'.
220 mx.google.com ESMTP sx8sm78485186pab.5 - gsmtp
HELO
250 mx.google.com at your service

   That's all for JavaMail example to send mail in java using SMTP server with different authentication
   protocols, attachment and images. I hope it will solve all your needs for sending emails in java
   programs.


---
https://crunchify.com/java-mailapi-example-send-an-email-via-gmail-smtp/

Java MailAPI Example - Send an Email via GMail SMTP (TLS Authentication)
May 11th, 2019

   In this Java Tutorial we will see how to send an email using GMail SMTP protocol in Java. I'm
   using JavaMail API v1.6.2. It is very robust solution available in the market.

   The JavaMail API provides a platform-independent and protocol-independent framework to build mail
   and messaging applications. The JavaMail API is available as an optional package for use with
   Java SE platform and is also included in the Java EE platform. The JavaMail 1.6.2 release
   contains several bug fixes and enhancements.

Are you getting this error?
   Exception in thread "main" java.lang.NoClassDefFoundError: com/sun/mail/util/MailLogger
   at javax.mail.Session.initLogger(Session.java:227)
   at javax.mail.Session.<init>(Session.java:212)
   at javax.mail.Session.getDefaultInstance(Session.java:315)
   ...

   com.sun.mail.util.MailLogger is part of JavaMail API. It is already included in Enterprise Edition
   environment (EE), but it is not included in Standard Edition environment (SE).

   If you are running your test, tests in SE environment which means what you have to bother about
   adding it manually to your classpath when running tests.

Solution:

   If you have maven project then try adding below two dependencies to pom.xml file to
   avoid below error:
   pom.xml
   <dependency>
       <groupId>javax.mail</groupId>
       <artifactId>mail</artifactId>
       <version>1.5.0-b01</version>
   </dependency>

   <dependency>
       <groupId>javax.mail</groupId>
       <artifactId>javax.mail-api</artifactId>
       <version>1.6.2</version>
   </dependency>

   If you want to convert your project to Maven project to have pom.xml file then follow the
   tutorial.

Java Example:

   CrunchifyJavaMailExample.java

<code>
package crunchify.com.tutorial;

import java.util.Properties;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.AddressException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

/**
* @author Crunchify.com
*
*/

public class CrunchifyJavaMailExample {

    static Properties mailServerProperties;
    static Session getMailSession;
    static MimeMessage generateMailMessage;

    public static void main(String args[]) throws AddressException, MessagingException {
        generateAndSendEmail();
        System.out.println("\n\n ===> Your Java Program has just sent an Email successfully. Check your email..");
    }

    public static void generateAndSendEmail() throws AddressException, MessagingException {

        // Step1
        System.out.println("\n 1st ===> setup Mail Server Properties..");
        mailServerProperties = System.getProperties();
        mailServerProperties.put("mail.smtp.port", "587");
        mailServerProperties.put("mail.smtp.auth", "true");
        mailServerProperties.put("mail.smtp.starttls.enable", "true");
        System.out.println("Mail Server Properties have been setup successfully..");

        // Step2
        System.out.println("\n\n 2nd ===> get Mail Session..");
        getMailSession = Session.getDefaultInstance(mailServerProperties, null);
        generateMailMessage = new MimeMessage(getMailSession);
        generateMailMessage.addRecipient(Message.RecipientType.TO, new InternetAddress("test1@crunchify.com"));
        generateMailMessage.addRecipient(Message.RecipientType.CC, new InternetAddress("test2@crunchify.com"));
        generateMailMessage.setSubject("Greetings from Crunchify..");
        String emailBody = "Test email by Crunchify.com JavaMail API example. " + "<br><br> Regards, \
        <br>Crunchify Admin";
        generateMailMessage.setContent(emailBody, "text/html");
        System.out.println("Mail Session has been created successfully..");

        // Step3
        System.out.println("\n\n 3rd ===> Get Session and Send mail");
        Transport transport = getMailSession.getTransport("smtp");

        // Enter your correct gmail UserID and Password
        // if you have 2FA enabled then provide App Specific Password
        transport.connect("smtp.gmail.com", "<----- Your GMAIL ID ----->", "<----- Your GMAIL PASSWORD \
        ----->");
        transport.sendMessage(generateMailMessage, generateMailMessage.getAllRecipients());
        transport.close();
    }
}
</code>

   Output:
   1st ===> setup Mail Server Properties..
   Mail Server Properties have been setup successfully..

   2nd ===> get Mail Session..
   Mail Session has been created successfully..

   3rd ===> Get Session and Send mail
   ===> Your Java Program has just sent an Email successfully. Check your email..

   Email Sample:
   [IMAGE]Crunchify.com JavaMail API Example With 2 Factor Authentication Enabled

Getting error? How to triage an issue?
     * If you've turned on 2-Step Verification for your account, you might need to enter an App password.
     * Important: If you're still having problems, visit
       http://www.google.com/accounts/DisplayUnlockCaptcha and sign in with your Gmail username and
       password. If necessary, enter the letters in the distorted picture.


---
https://mkyong.com/java/javamail-api-sending-email-via-gmail-smtp-example/

JavaMail API - Sending email via Gmail SMTP example
April 10, 2019

   In this article, we will show you how to send an email via Gmail SMTP server.

   To send email in Java, we need JavaMail
   pom.xml
        <dependency>
                <groupId>com.sun.mail</groupId>
                <artifactId>javax.mail</artifactId>
                <version>1.6.2</version>
        </dependency>

1. Gmail SMTP via TLS
SMTP = smtp.gmail.com
Port = 587

   SendEmailTLS.java

<code>
package com.mkyong;

import javax.mail.*;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
import java.util.Properties;

public class SendEmailTLS {

    public static void main(String[] args) {

        final String username = "username@gmail.com";
        final String password = "password";

        Properties prop = new Properties();
        prop.put("mail.smtp.host", "smtp.gmail.com");
        prop.put("mail.smtp.port", "587");
        prop.put("mail.smtp.auth", "true");
        prop.put("mail.smtp.starttls.enable", "true"); //TLS

        Session session = Session.getInstance(prop,
            new javax.mail.Authenticator() {
                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(username, password);
                }
            });

        try {

            Message message = new MimeMessage(session);
            message.setFrom(new InternetAddress("from@gmail.com"));
            message.setRecipients(
                Message.RecipientType.TO,
                InternetAddress.parse("to_username_a@gmail.com, to_username_b@yahoo.com")
            );
            message.setSubject("Testing Gmail TLS");
            message.setText("Dear Mail Crawler,"
                + "\n\n Please do not spam my email!");

            Transport.send(message);

            System.out.println("Done");

        } catch (MessagingException e) {
            e.printStackTrace();
        }
    }

}
</code>

2. Gmail via SSL
   2.1 The logic is the same, just pass in different properties values.
SMTP = smtp.gmail.com
Port = 465

   SendEmailSSL.java

<code>
package com.mkyong;

import javax.mail.*;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
import java.util.Properties;

public class SendEmailSSL {

    public static void main(String[] args) {

        final String username = "username@gmail.com";
        final String password = "password";

        Properties prop = new Properties();
        prop.put("mail.smtp.host", "smtp.gmail.com");
        prop.put("mail.smtp.port", "465");
        prop.put("mail.smtp.auth", "true");
        prop.put("mail.smtp.socketFactory.port", "465");
        prop.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");

        Session session = Session.getInstance(prop,
            new javax.mail.Authenticator() {
                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(username, password);
                }
            });

        try {

            Message message = new MimeMessage(session);
            message.setFrom(new InternetAddress("from@gmail.com"));
            message.setRecipients(
                Message.RecipientType.TO,
                InternetAddress.parse("to_username_a@gmail.com, to_username_b@yahoo.com")
            );
            message.setSubject("Testing Gmail SSL");
            message.setText("Dear Mail Crawler,"
                + "\n\n Please do not spam my email!");

            Transport.send(message);

            System.out.println("Done");

        } catch (MessagingException e) {
            e.printStackTrace();
        }
    }

}
</code>

3. Application-specific password required
   3.1 If 2-Step verification is ON. We will hits the following error message :
Caused by: javax.mail.AuthenticationFailedException: 534-5.7.9 Application-specific password required. \
Learn more at 534 5.7.9  https://support.google.com/mail/?p=InvalidSecondFactor - gsmtp
        at com.sun.mail.smtp.SMTPTransport$Authenticator.authenticate(SMTPTransport.java:965)
        at com.sun.mail.smtp.SMTPTransport.authenticate(SMTPTransport.java:876)
        at com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:780)
        at javax.mail.Service.connect(Service.java:388)
        at javax.mail.Service.connect(Service.java:246)
        at javax.mail.Service.connect(Service.java:195)
        at javax.mail.Transport.send0(Transport.java:254)
        at javax.mail.Transport.send(Transport.java:124)
        at com.mkyong.calculator.SendEmail.main(SendEmail.java:41)

   3.2 To fix it, follow this [https://support.google.com/accounts/answer/185833?p=InvalidSecondFactor]guide
   to create an App Password

   URL : https://support.google.com/accounts/answer/185833?p=InvalidSecondFactor
   URL : https://myaccount.google.com/security

   No difference in code, just puts the newly generated app password instead.
   SendEmail.java

<code>
package com.mkyong;

import javax.mail.*;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
import java.util.Properties;

public class SendEmail {

    public static void main(String[] args) {

        final String username = "username@gmail.com";
        final String password = "puts your app password here"; // update here
            // same code...
    }

}
</code>

   java.net.UnknownHostException: smtp.gmail.com
   Make sure firewall or proxy server didn't block this smtp.gmail.com


---
https://www.baeldung.com/java-email

Sending Emails with Java
February 12, 2020

1. Overview
   In this quick tutorial, we're going to look at sending an email with and without attachments - using
   the core Java mail library.

2. Project Setup and Dependency
   For this article, we'll be using a simple Maven-based project with a dependency on the Java mail
   library:
<dependency>
    <groupId>javax.mail</groupId>
    <artifactId>mail</artifactId>
    <version>1.5.0-b01</version>
</dependency>

3. Sending a Plain Text and an HTML Email
   First, we need to configure the library with our email service provider's credentials. Then, we'll
   create a Session that'll be used in constructing our message for sending.

   The configuration is via a Java Properties object:

<code>
Properties prop = new Properties();
prop.put("mail.smtp.auth", true);
prop.put("mail.smtp.starttls.enable", "true");
prop.put("mail.smtp.host", "smtp.mailtrap.io");
prop.put("mail.smtp.port", "25");
prop.put("mail.smtp.ssl.trust", "smtp.mailtrap.io");
</code>

   In the properties configuration above, we configured the email host as Mailtrap and use the port
   provided by the service as well.

   Now let's move further by creating a session with our username and password:

<code>
Session session = Session.getInstance(prop, new Authenticator() {
    @Override
    protected PasswordAuthentication getPasswordAuthentication() {
        return new PasswordAuthentication(username, password);
    }
});
</code>

   The username and password are given by the mail service provider alongside the host and port
   parameters.

   Now that we have a mail Session object, let's create a MimeMessage for sending:

<code>
Message message = new MimeMessage(session);
message.setFrom(new InternetAddress("from@gmail.com"));
message.setRecipients(
  Message.RecipientType.TO, InternetAddress.parse("to@gmail.com"));
message.setSubject("Mail Subject");

String msg = "This is my first email using JavaMailer";

MimeBodyPart mimeBodyPart = new MimeBodyPart();
mimeBodyPart.setContent(msg, "text/html");

Multipart multipart = new MimeMultipart();
multipart.addBodyPart(mimeBodyPart);

message.setContent(multipart);

Transport.send(message);
</code>

   In the snippet above, we first created a message instance with the necessary properties - to, from
   and subject. Followed by a mimeBodyPartthat has an encoding of text/html, since our message is styled
   in HTML.

   The next thing we did is to create an instance of MimeMultipart object that we can use to wrap
   the mimeBodyPart we created.

   Finally, we set the multipart object as the content of our message and use the
   send()of Transport object to do the mail sending.

   So, we can say that the mimeBodyPartis contained in the multipart that is contained in
   the message. Hence, a multipart can contain more than one mimeBodyPart.

   This is going to be the focus of the next section.

4. Sending Email With an Attachment
   Next, to send an attachment, we only need to create another MimeBodyPartand attach the file(s) to it:
MimeBodyPart attachmentBodyPart = new MimeBodyPart();
attachmentBodyPart.attachFile(new File("path/to/file"));

   We can then add the new body part to the MimeMultipartobject we created earlier:
multipart.addBodyPart(attachmentBodyPart);

   That's all we need to do.

   Once again, we set the multipart instance as the content of the message object and finally we'll use
   the send() to do the mail sending.

5. Conclusion
   In conclusion, we've seen how to use the native Java mail library to send emails even with
   attachment.

   As always, the complete source code is available over on Github:
*** EmailService.java:
<code>
package com.baeldung.mail;

import javax.mail.*;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;
import java.io.File;
import java.util.Properties;

public class EmailService {

    private String host = "";
    private int port = 0;
    private String username = "";
    private String password = "";


    public EmailService(String host, int port, String username, String password) {

        this.host = host;
        this.port = port;
        this.username = username;
        this.password = password;

        sendMail();
    }

    private void sendMail() {

        Properties prop = new Properties();
        prop.put("mail.smtp.auth", true);
        prop.put("mail.smtp.starttls.enable", "true");
        prop.put("mail.smtp.host", host);
        prop.put("mail.smtp.port", port);
        prop.put("mail.smtp.ssl.trust", host);

        Session session = Session.getInstance(prop, new Authenticator() {
            @Override
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication(username, password);
            }
        });

        try {

                Message message = new MimeMessage(session);
                message.setFrom(new InternetAddress("from@gmail.com"));
                message.setRecipients(Message.RecipientType.TO, InternetAddress.parse("to@gmail.com"));
                message.setSubject("Mail Subject");

                String msg = "This is my first email using JavaMailer";

                MimeBodyPart mimeBodyPart = new MimeBodyPart();
                mimeBodyPart.setContent(msg, "text/html");

                MimeBodyPart attachmentBodyPart = new MimeBodyPart();
                attachmentBodyPart.attachFile(new File("pom.xml"));

                Multipart multipart = new MimeMultipart();
                multipart.addBodyPart(mimeBodyPart);
                multipart.addBodyPart(attachmentBodyPart);

                message.setContent(multipart);

                Transport.send(message);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String ... args) {
        new EmailService("smtp.mailtrap.io", 25, "87ba3d9555fae8", "91cb4379af43ed");
    }
}
</code>

*** MailWithAttachmentService.java:
<code>
package com.baeldung.mail.mailwithattachment;

import java.io.File;
import java.io.IOException;
import java.util.Properties;
import javax.mail.BodyPart;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.AddressException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;

public class MailWithAttachmentService {

    private String username = "";
    private String password = "";
    private String host = "";
    private String port = "";

    MailWithAttachmentService() {
    }

    MailWithAttachmentService(String username, String password, String host, String port) {
        this.username = username;
        this.password = password;
        this.host = host;
        this.port = port;
    }

    public Session getSession() {
        Properties props = new Properties();
        props.put("mail.smtp.auth", "true");
        props.put("mail.smtp.starttls.enable", "true");
        props.put("mail.smtp.host", this.host);
        props.put("mail.smtp.port", this.port);

        Session session = Session.getInstance(props, new javax.mail.Authenticator() {
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication(username, password);
            }
        });
        return session;
    }

    public Message createMail(Session session) throws AddressException, MessagingException, IOException {
        Message message = new MimeMessage(session);
        message.setFrom(new InternetAddress("mail@gmail.com"));
        message.setRecipients(Message.RecipientType.TO, InternetAddress.parse("mail@gmail.com"));
        message.setSubject("Testing Subject");

        BodyPart messageBodyPart = new MimeBodyPart();
        messageBodyPart.setText("This is message body");

        Multipart multipart = new MimeMultipart();
        multipart.addBodyPart(messageBodyPart);

        MimeBodyPart attachmentPart = new MimeBodyPart();
        MimeBodyPart attachmentPart2 = new MimeBodyPart();

        attachmentPart.attachFile(new File("C:\\Document1.txt"));
        attachmentPart2.attachFile(new File("C:\\Document2.txt"));

        multipart.addBodyPart(attachmentPart);
        multipart.addBodyPart(attachmentPart2);

        message.setContent(multipart);

        return message;
    }

    public void sendMail(Session session) throws MessagingException, IOException {

        Message message = createMail(session);
        Transport.send(message);
    }

}
</code>


---
https://pepipost.com/tutorials/send-email-in-java-using-gmail-smtp/

How To Send Email In Java Using Gmail SMTP?
2020-07-17

Introduction
   Sending Email is the most common and necessary requirement for most of the applications. Java
   provides Java Mail API - a platform and protocol independent framework to build mail and messaging
   applications.

   The JavaMail reference implementation is licensed under the Common Development and Distribution
   License (CDDL) v1.1 and GNU General Public License (GPL) v2 with Classpath Exception.

   In this guide, you will get detailed steps on how to setup JavaMail in your Java Project and
   implement JavaMail API to build and send emails on SMTP protocol.

Prerequisites
     * Eclipse IDE
     * Java Runtime Environment

Step 1 - Create new Maven Project
    1. Click onFile > New > Project > Maven > Maven Project
    2. Select Create a simple project(skip archetype selection) and click Finish.
    3. Give Artifact Id and group Id to your project.
    4. This will give the default project structure as below:
    5. A default pom.xml is created:
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" \
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
   <modelVersion>4.0.0</modelVersion>
   <groupId>SendEmail</groupId>
   <artifactId>SendEmail</artifactId>
   <version>0.0.1-SNAPSHOT</version>
   <name>SendEmail</name>
   <description>This artiface will send emails using Java Mail API</description>
</project>

    6. Add following dependencies in your pom.xml file.
<dependencies>
    <dependency>
            <groupId>com.sun.mail</groupId>
            <artifactId>javax.mail</artifactId>
            <version>1.6.2</version>
        </dependency>
  </dependencies>

   This will add javax.mail.jar 1.6.2 into your project resources.

   Final pom.xml:
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:s
chemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>SendEmail</groupId>
  <artifactId>SendEmail</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <name>SendEmail</name>
  <description>This artiface will send emails using Java Mail API</description>
  <dependencies>
    <dependency>
            <groupId>com.sun.mail</groupId>
            <artifactId>javax.mail</artifactId>
            <version>1.6.2</version>
        </dependency>
  </dependencies>
</project>

Step 2 - Create Java Class
    1. Right click on Project and create new package and name it com.sendemail
    2. Right click on package and create SendMail class
       check to create main method:
   In your code, we would require to import the following packages and class.
     * import java.util.Properties:
       The Properties class represents a persistent set of properties. The Properties can be saved to a
       stream or loaded from a stream.
     * import javax.mail.Message:
       This class models an email message. To send a message,subclass of Message (e.g. MimeMessage) is
       instantiated, the attributes and content are filled in, and message is sent using the
       Transport.send method.
     * import javax.mail.MessagingException:
       This is base class for all exceptions thrown by the Messaging classes
     * import javax.mail.PasswordAuthentication:
       This class is simply a repository for a user name and a password.
     * import javax.mail.Session:
       Session class represents a mail session.
     * import javax.mail.Transport:
       This is abstract class that models a message transport.
     * import javax.mail.internet.InternetAddress:
       This class represents an Internet email address using the syntax of RFC822
     * import javax.mail.internet.MimeMessage:
       This class represents a MIME style email message. It implements the Message abstract class and
       the MimePart interface.

Sending Email Through Java Using Gmail SMTP

   Below is the full Java code to send emails using Gmail SMTP server, with the description of each
   line:

<code>
package com.sendemail;

import java.util.Properties;

import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

public class SendMail {

    public static void main(String[] args) {

        // Recipient's email ID needs to be mentioned.
        String to = "fromaddress@gmail.com";

        // Sender's email ID needs to be mentioned
        String from = "toaddress@gmail.com";

        // Assuming you are sending email from through gmails smtp
        String host = "smtp.gmail.com";

        // Get system properties
        Properties properties = System.getProperties();

        // Setup mail server
        properties.put("mail.smtp.host", host);
        properties.put("mail.smtp.port", "465");
        properties.put("mail.smtp.ssl.enable", "true");
        properties.put("mail.smtp.auth", "true");

        // Get the Session object.// and pass username and password
        Session session = Session.getInstance(properties, new javax.mail.Authenticator() {

            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication("fromaddress@gmail.com", "*******");
            }

        });

        // Used to debug SMTP issues
        session.setDebug(true);

        try {
            // Create a default MimeMessage object.
            MimeMessage message = new MimeMessage(session);

            // Set From: header field of the header.
            message.setFrom(new InternetAddress(from));

            // Set To: header field of the header.
            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));

            // Set Subject: header field
            message.setSubject("This is the Subject Line!");

            // Now set the actual message
            message.setText("This is actual message");

            System.out.println("sending...");
            // Send message
            Transport.send(message);
            System.out.println("Sent message successfully....");
        } catch (MessagingException mex) {
            mex.printStackTrace();
        }

    }

}
</code>

   If you want to send HTML content to replace message.setText("This is actual message") with below
   code:
    // Send the actual HTML message.
       message.setContent(
              "<h1>This is actual message embedded in HTML tags</h1>",
             "text/html");

Step 3 - Test Java Code
   Run Java Application and email will be sent to the recipient. Your console will look like this.
   [image]

   You have successfully sent email using your Java Code.

   Now let's send file attachment in your email.

Optional Steps
Step 4 - Send Email with Attachment.
   To send a mail with an attachment will have to import a few more classes.

   1. import java.io.File and import java.io.IOException
   File Class is an abstract representation of file and directory path names and IOException class is a
   general class of exceptions produced by failed or interrupted I/O operations.

   2. import javax.mail.internet.MimeMultipart
   This Class is an implementation of the abstract Multipart class that uses MIME conventions for data.

   3. import javax.mail.internet.MimeBodyPart
   This class represents a MIME body part.
   MimeBodyPart uses the InternetHeaders class to parse and store the headers of that body part.

   Below is the java code to send an attachment in the email.

   The code has two MIME Body part one carrying attachment and other carrying text for email, this is
   added in Multipart, then this multipart is used to set as the content of the message.

<code>
Multipart multipart = new MimeMultipart();

            MimeBodyPart attachmentPart = new MimeBodyPart();

            MimeBodyPart textPart = new MimeBodyPart();

            try {

                File f =new File("H:\\fakepath\\file1.PNG");

                attachmentPart.attachFile(f);
                textPart.setText("This is text");
                multipart.addBodyPart(textPart);
                multipart.addBodyPart(attachmentPart);

            } catch (IOException e) {

                e.printStackTrace();

            }

            message.setContent(multipart);
</code>

   Here is a running Java Code to send attachments in email:

Java Code To Send Attachment In Email

<code>
package com.sendemail;

import java.io.File;
import java.io.IOException;
import java.util.Properties;

import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;

public class SendMail {

    public static void main(String[] args) {

        // Recipient's email ID needs to be mentioned.
        String to = "toaddress@gmail.com";

        // Sender's email ID needs to be mentioned
        String from = "fromaddress@gmail.com";

        // Assuming you are sending email from through gmails smtp
        String host = "smtp.gmail.com";

        // Get system properties
        Properties properties = System.getProperties();

        // Setup mail server
        properties.put("mail.smtp.host", host);
        properties.put("mail.smtp.port", "465");
        properties.put("mail.smtp.ssl.enable", "true");
        properties.put("mail.smtp.auth", "true");

        // Get the Session object.// and pass
        Session session = Session.getInstance(properties, new javax.mail.Authenticator() {

            protected PasswordAuthentication getPasswordAuthentication() {

                return new PasswordAuthentication("youremail@gmail.com", "*******");

            }

        });
        //session.setDebug(true);
        try {
            // Create a default MimeMessage object.
            MimeMessage message = new MimeMessage(session);

            // Set From: header field of the header.
            message.setFrom(new InternetAddress(from));

            // Set To: header field of the header.
            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));

            // Set Subject: header field
            message.setSubject("This is the Subject Line!");

            Multipart multipart = new MimeMultipart();

            MimeBodyPart attachmentPart = new MimeBodyPart();

            MimeBodyPart textPart = new MimeBodyPart();

            try {

                File f =new File("H:\\pepipost_tutorials\\javaemail1.PNG");

                attachmentPart.attachFile(f);
                textPart.setText("This is text");
                multipart.addBodyPart(textPart);
                multipart.addBodyPart(attachmentPart);

            } catch (IOException e) {
                e.printStackTrace();
            }

            message.setContent(multipart);

            System.out.println("sending...");
            // Send message
            Transport.send(message);
            System.out.println("Sent message successfully....");
        } catch (MessagingException mex) {
            mex.printStackTrace();
        }

    }

}
</code>

Conclusion
   Now you have implemented Java Mail API successfully and can send emails using any SMTP Servers
   from your project.


---
https://cloud.google.com/appengine/docs/standard/java/mail/sending-mail-with-mail-api

Sending Mail with the Mail API

   The Mail service API for Java supports the JavaMail (javax.mail) interface for sending email
   messages.

   This solution is no longer recommended: This page describes how to use a legacy App Engine service.
   Apps that use this service can only run in the Java 8 runtime and will need to upgrade to a
   recommended solution before migrating to the Java 11 runtime.

Before you begin
   Register your sender emails as authorized senders. For more information, see who can send email.

Sending email messages
   To send email messages, use the JavaMail classes included with the App Engine SDK.

   When you create a JavaMail Session, if you do not provide any SMTP server configuration, App Engine
   uses the Mail service for sending messages. Alternatively, add SMTP configuration for supported
   third-party mail providers such as Mailgun, Mailjet, or SendGrid.

   To send a message:
    1. Create a message using a JavaMail Session object.
    2. Create a MimeMessage object.
    3. To set the message sender and recipient, use the InternetAddress class.
         1. Identify the sender by calling the setFrom() method on the MimeMessage object. Optionally,
            you can provide a personal name as a string in the second parameter.
         2. Identify the recipient by passing a recipient type and an address to the addRecipient()
            method. The recipient type can be Message.RecipientType.TO, Message.RecipientType.CC or
            Message.RecipientType.BCC.
       The InternetAddress constructor raises an AddressException if the email address appears to be
       invalid.
    4. To set a "reply to" address, use the setReplyTo() method.
    5. Establish the contents of the message by calling methods on the MimeMessage object. Set the
       subject with setSubject() and set the plaintext body content with setText().
    6. To send the message, use the static method send() on the Transport class.

   The Mail service allows you to specify a limited set of headers on outgoing email messages. For more
   information, see Optional headers you can use.

   The following code sample demonstrates how to send mail:
   appengine-java8/mail/src/main/java/com/example/appengine/mail/MailServlet.java

   
Properties props = new Properties();
Session session = Session.getDefaultInstance(props, null);

<code>
try {
    Message msg = new MimeMessage(session);
    msg.setFrom(new InternetAddress("admin@example.com", "Example.com Admin"));
    msg.addRecipient(Message.RecipientType.TO,
                    new InternetAddress("user@example.com", "Mr. User"));
    msg.setSubject("Your Example.com account has been activated");
    msg.setText("This is a test");
    Transport.send(msg);
} catch (AddressException e) {
    // ...
} catch (MessagingException e) {
    // ...
} catch (UnsupportedEncodingException e) {
    // ...
}
</code>

   Calls to the Mail service are asynchronous and return immediately. The Mail service manages the
   process of contacting the recipients' mail servers and delivering the message. If there is a problem
   sending the message to any recipient, or if a recipient's mail server returns a "bounce" message, the
   error message goes to the sender.

Sending multi-part messages
   You can send multi-part messages, such as a message with file attachments, or a message with a
   plaintext message body and an HTML message body.

   To send a multi-part message:
    1. Create a MimeMultipart object to contain the parts, then create a MimeBodyPart object for each
       attachment or alternate message body and add it to the container.'
    2. Assign the container to the content for MimeMessage.

   The following code sample demonstrates how to send a multi-part message:
   appengine-java8/mail/src/main/java/com/example/appengine/mail/MailServlet.java

<code>
String htmlBody = "";          // ...
byte[] attachmentData = null;  // ...
Multipart mp = new MimeMultipart();

MimeBodyPart htmlPart = new MimeBodyPart();
htmlPart.setContent(htmlBody, "text/html");
mp.addBodyPart(htmlPart);

MimeBodyPart attachment = new MimeBodyPart();
InputStream attachmentDataStream = new ByteArrayInputStream(attachmentData);
attachment.setFileName("manual.pdf");
attachment.setContent(attachmentDataStream, "application/pdf");
mp.addBodyPart(attachment);

msg.setContent(mp);
</code>

   For security purposes, message parts and attachments must be of one of several allowed types, and
   attachment filenames must end in a recognized filename extension for the type. For a list of allowed
   types and filename extensions, see Mail with attachments.

   (Submit) Send feedback

   Except as otherwise noted, the content of this page is licensed under the Creative Commons
   Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For
   details, see the Google Developers Site Policies. Java is a registered trademark of Oracle
   and/or its affiliates.


---
https://stackoverflow.com/questions/59069456/sending-an-email-using-gmail-through-java

Sending an Email using gmail through Java

   I am trying to send email through java using this code:

<code>
package send_email;
import java.util.Properties;
import javax.mail.*;
import javax.mail.internet.*;
/**
 *
 * @author A
 */
public class Send_email {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        String host="smtp.gmail.com";
        final String user="***@gmail.com";  //change accordingly
        final String password="****";       //change accordingly
    
        String to="*******@gmail.com";      //change accordingly
    
        //Get the session object
        Properties props = new Properties();
        props.put("mail.smtp.host",host);
        props.put("mail.smtp.auth", "true");
    
        Session session = Session.getDefaultInstance(props,
            new javax.mail.Authenticator() {
                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(user,password);
                }
            });
    
        //Compose the message
        try {
            MimeMessage message = new MimeMessage(session);
            message.setFrom(new InternetAddress(user));
            message.addRecipient(Message.RecipientType.TO,new InternetAddress(to));
            message.setSubject("javatpoint");
            message.setText("This is simple program of sending email using JavaMail API");
        
            //send the message
            Transport.send(message);
        
            System.out.println("message sent successfully...");
    
        } catch (MessagingException e) {
            e.printStackTrace();
        }
    }
}
</code>

   But I get the following error :
javax.mail.MessagingException: Could not connect to SMTP host: smtp.gmail.com, port: 25, response: 554
    at com.sun.mail.smtp.SMTPTransport.openServer(SMTPTransport.java:1694)
    at com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:525)
    at javax.mail.Service.connect(Service.java:313)
    at javax.mail.Service.connect(Service.java:172)
    at javax.mail.Service.connect(Service.java:121)
    at javax.mail.Transport.send0(Transport.java:190)
    at javax.mail.Transport.send(Transport.java:120)
    at send_email.Send_email.main(Send_email.java:48)
BUILD SUCCESSFUL (total time: 0 seconds)

   I have allowed port 25 through firewall and then I have tested it using telnet " telnet
   smtp.gmail.com 25 " but I get this error 554 OutgoingFilter "You are temporarily deferred due to
   sending spam or virus please contact 16333 for more information"

   So how do I fix this error?

   Edit : I am now getting this error through Telnet "421 Cannot connect to SMTP server 108.177.15.109
   (108.177.15.109:25), connect er ror 10060

   Connection to host lost. " Edit _2 : I found that the port for gmail SMTP is 587 and I have changed
   the session object accordingly to
Properties p = new Properties();
p.put("mail.smtp.auth", "true");
p.put("mail.transport.protocol", "smtp");
p.put("mail.smtp.host", "smtp.gmail.com");
p.put("mail.smtp.port", "587");
p.put("mail.smtp.starttls.enable","true");
p.put("mail.smtp.starttls.required","true");

   This code was provided down there. However I get the following error :
javax.mail.MessagingException: Could not convert socket to TLS;
  nested exception is:
    javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed:
 sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to reques
ted target
    at com.sun.mail.smtp.SMTPTransport.startTLS(SMTPTransport.java:1652)
    at com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:534)
    at javax.mail.Service.connect(Service.java:313)
    at javax.mail.Service.connect(Service.java:172)
    at javax.mail.Service.connect(Service.java:121)
    at javax.mail.Transport.send0(Transport.java:190)
    at javax.mail.Transport.send(Transport.java:120)
    at send_email.Send_email.main(Send_email.java:52)
Caused by: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building
failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path \
to requested target
    at sun.security.ssl.Alerts.getSSLException(Alerts.java:192)
    at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1946)
    at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:316)
    at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:310)
    at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1640)
    at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:223)
    at sun.security.ssl.Handshaker.processLoop(Handshaker.java:1037)
    at sun.security.ssl.Handshaker.process_record(Handshaker.java:965)
    at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1064)
    at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1367)
    at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1395)
    at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1379)
    at com.sun.mail.util.SocketFetcher.configureSSLSocket(SocketFetcher.java:503)
    at com.sun.mail.util.SocketFetcher.startTLS(SocketFetcher.java:443)
    at com.sun.mail.smtp.SMTPTransport.startTLS(SMTPTransport.java:1647)
    ... 7 more
Caused by: sun.security.validator.ValidatorException: PKIX path building failed: \
sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to \
requested target
    at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:397)
    at sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:302)
    at sun.security.validator.Validator.validate(Validator.java:262)
    at sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:330)
    at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:237)
    at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:132)
    at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1622)
    ... 17 more
Caused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification \
path to requested target
    at sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:141)
    at sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:126)
    at java.security.cert.CertPathBuilder.build(CertPathBuilder.java:280)
    at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:392)
    ... 23 more

   However the telenet when connecting through this new port gives me the following : 220 smtp.gmail.com
   ESMTP a24sm5897091wmb.29 - gsmtp Which I think this means that I am connected through telnet.

***
   Try these settings
Properties p = new Properties();
p.put("mail.smtp.auth", "true");
p.put("mail.transport.protocol", "smtp");
p.put("mail.smtp.host", "smtp.gmail.com");
p.put("mail.smtp.port", "587");
p.put("mail.smtp.starttls.enable","true");
p.put("mail.smtp.starttls.required","true");

***
   You can use one of the following techniques to get the SMTP server:
    1. Install and use any SMTP server such as Postcast server, Apache James server, email server, etc
    2. Use the SMTP server provided by the host provider e.g. my SMTP the server is mail.xxx.com
    3. Use the SMTP Server provided by other companies e.g. Gmail etc.

   For sending the email using JavaMail API, you need to load the two jar files: - mail.jar -
   activation.jar Below is the example

<code>
import java.util.*;
import javax.mail.*;
import javax.mail.internet.*;
import javax.activation.*;

public class TestSendEmail {

    public static void main(String [] args) {
        // Recipient's email ID needs to be mentioned.
        String to = "abcd@gmail.com";
    
        // Sender's email ID needs to be mentioned
        String from = "test@gmail.com";
    
        // Assuming you are sending email from localhost
        String host = "localhost";
    
        // Get system properties
        Properties properties = System.getProperties();
    
        // Setup mail server
        properties.setProperty("mail.smtp.host", host);
    
        // Get the default Session object.
        Session session = Session.getDefaultInstance(properties);
    
        try {
            // Create a default MimeMessage object.
            MimeMessage message = new MimeMessage(session);
    
            // Set From: header field of the header.
            message.setFrom(new InternetAddress(from));
    
            // Set To: header field of the header.
            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));
    
            // Set Subject: header field
            message.setSubject(Subject Line!");
    
            // Now set the actual message
            message.setText("actual message");
    
            // Send message
            Transport.send(message);
            System.out.println("Sent message successfully....");
            
        } catch (MessagingException mex) {
            mex.printStackTrace();
        }
    }
}
</code>


---
