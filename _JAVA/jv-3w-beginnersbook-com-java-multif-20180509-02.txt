filename: w3_beginnersbook_com_java-multif_20180509.txt
https://beginnersbook.com/2013/05/java-introduction/

=== TOC ==============================================
Java Tutorial
     * Java Introduction
     * JVM - Java Virtual Machine
     * First Java Program
     * Variables
     * Data Types
     * Operators
     * Java If-else
     * Java Switch-Case
     * Java For loop
     * Java while loop
     * Java do-while loop
     * Continue statement
     * break statement

OOPs Concepts
     * OOPs Concepts
     * Constructor
     * Static keyword
     * Inheritance
     * Types of inheritance
     * Aggregation
     * Association
     * Super Keyword
     * Method overloading
     * Method overriding
     * Overloading vs Overriding
     * Polymorphism
     * Types of polymorphism
     * Static and dynamic binding
     * Abstract class and methods
     * Interface
     * Abstract class vs interface
     * Encapsulation
     * Packages
     * Access modifiers
     * Garbage Collection
     * Inner classes
     * Static import
     * Static constructor
     * Java Interview Q

MORE ...
     * Java String
     * Exception handling
     * Java Multithreading
     * Java I/O
     * Java Serialization
     * Java Regex
     * Java AWT
     * Java Swing
     * Java Enum
     * Java Annotations

Recently Added..
     * JSON Tutorial
=== TOC ==============================================

Introduction to Java programming

   JAVA was developed by Sun Microsystems Inc in 1991, later acquired by Oracle Corporation. It was
   developed by James Gosling and Patrick Naughton. It is a simple programming language.  Writing,
   compiling and debugging a program is easy in java.  It helps to create modular programs and reusable
   code.

Java terminology
   Before we start learning Java, lets get familiar with common java terms.

   Java Virtual Machine (JVM)
   This is generally referred as JVM. Before, we discuss about JVM lets see the phases of program
   execution. Phases are as follows: we write the program, then we compile the program and at last we
   run the program.
   1) Writing of the program is of course done by java programmer like you and me.
   2) Compilation of program is done by javac compiler, javac is the primary java compiler included in
   java development kit (JDK). It takes java program as input and generates java bytecode as output.
   3) In third phase, JVM executes the bytecode generated by compiler. This is called program run phase.

   So, now that we understood that the primary function of JVM is to execute the bytecode produced by
   compiler. Each operating system has different JVM, however the output they produce after execution of
   bytecode is same across all operating systems. That is why we call java as platform independent
   language.

   bytecode
   As discussed above, javac compiler of JDK compiles the java source code into bytecode so that it can
   be executed by JVM. The bytecode is saved in a .class file by compiler.

   Java Development Kit(JDK)
   While explaining JVM and bytecode, I have used the term JDK. Let’s discuss about it. As the name
   suggests this is complete java development kit that includes JRE (Java Runtime Environment),
   compilers and various tools like JavaDoc, Java debugger etc.
   In order to create, compile and run Java program you would need JDK installed on your computer.

   Java Runtime Environment(JRE)
   JRE is a part of JDK which means that JDK includes JRE. When you have JRE installed on your system,
   you can run a java program however you won’t be able to compile it. JRE includes JVM, browser plugins
   and applets support. When you only need to run a java program on your computer, you would only need
   JRE.

   These are the basic java terms that confuses beginners in java. For complete java glossary refer this
   link: https://docs.oracle.com/javase/tutorial/information/glossary.html

Main Features of JAVA

Java is a platform independent language
   Compiler(javac) converts source code (.java file) to the byte code(.class file). As mentioned above,
   JVM executes the bytecode produced by compiler. This byte code can run on any platform such as
   Windows, Linux, Mac OS etc. Which means a program that is compiled on windows can run on Linux and
   vice-versa. Each operating system has different JVM, however the output they produce after execution
   of bytecode is same across all operating systems. That is why we call java as platform independent
   language.

Java is an Object Oriented language
   Object oriented programming is a way of organizing programs as collection of objects, each of which
   represents an instance of a class.

   4 main concepts of Object Oriented programming are:
    1. Abstraction
    2. Encapsulation
    3. Inheritance
    4. Polymorphism

Simple
   Java is considered as one of simple language because it does not have complex features like Operator
   overloading, Multiple inheritance, pointers and Explicit memory allocation.

Robust Language
   Robust means reliable. Java programming language is developed in a way that puts a lot of emphasis on
   early checking for possible errors, that’s why java compiler is able to detect errors that are not
   easy to detect in other programming languages. The main features of java that makes it robust are
   garbage collection, Exception Handling and memory allocation.

Secure
   We don’t have pointers and we cannot access out of bound arrays (you get
   ArrayIndexOutOfBoundsException if you try to do so) in java. That’s why several security flaws like
   stack corruption or buffer overflow is impossible to exploit in Java.

Java is distributed
   Using java programming language we can create distributed applications. RMI(Remote Method Invocation)
   and EJB(Enterprise Java Beans) are used for creating distributed applications in java. In simple
   words: The java programs can be distributed on more than one systems that are connected to each other
   using internet connection. Objects on one JVM (java virtual machine) can execute procedures on a
   remote JVM.

Multithreading
   Java supports multithreading. Multithreading is a Java feature that allows concurrent execution
   of two or more parts of a program for maximum utilisation of CPU.

Portable
   As discussed above, java code that is written on one machine can run on another machine. The platform
   independent byte code can be carried to any platform for execution that makes java code portable.


---
https://beginnersbook.com/2013/05/jvm/

Java Virtual Machine (JVM), Difference JDK, JRE & JVM – Core Java

   Java is a high level programming language. A program written in high level language cannot be run on
   any machine directly. First, it needs to be translated into that particular machine language. The
   javac compiler does this thing, it takes java program (.java file containing source code) and
   translates it into machine code (referred as byte code or .class file).

   Java Virtual Machine (JVM) is a virtual machine that resides in the real machine (your computer) and
   the machine language for JVM is byte code. This makes it easier for compiler as it has to generate
   byte code for JVM rather than different machine code for each type of machine. JVM executes the byte
   code generated by compiler and produce output. JVM is the one that makes java platform independent.

   So, now we understood that the primary function of JVM is to execute the byte code produced by
   compiler. Each operating system has different JVM, however the output they produce after execution of
   byte code is same across all operating systems. Which means that the byte code generated on Windows
   can be run on Mac OS and vice versa. That is why we call java as platform independent language. The
   same thing can be seen in the diagram below:
   JVM

     So to summarise everything: The Java Virtual machine (JVM) is the virtual machine that runs on
     actual machine (your computer) and executes Java byte code. The JVM doesn’t understand Java source
     code, that’s why we need to have javac compiler that compiles *.java files to obtain *.class files
     that contain the byte codes understood by the JVM. JVM makes java portable (write once, run
     anywhere). Each operating system has different JVM, however the output they produce after
     execution of byte code is same across all operating systems.

JVM Architecture
   jvm architecture
   Lets see how JVM works:
   Class Loader: The class loader reads the .class file and save the byte code in the method area.

   Method Area: There is only one method area in a JVM which is shared among all the classes. This holds
   the class level information of each .class file.

   Heap: Heap is a part of JVM memory where objects are allocated. JVM creates a Class object for each
   .class file.

   Stack: Stack is a also a part of JVM memory but unlike Heap, it is used for storing temporary
   variables.

   PC Registers: This keeps the track of which instruction has been executed and which one is going to
   be executed. Since instructions are executed by threads, each thread has a separate PC register.

   Native Method stack: A native method can access the runtime data areas of the virtual machine.

   Native Method interface: It enables java code to call or be called by native applications. Native
   applications are programs that are specific to the hardware and OS of a system.

   Garbage collection: A class instance is explicitly created by the java code and after use it is
   automatically destroyed by garbage collection for memory management.

JVM Vs JRE Vs JDK
   JRE: JRE is the environment within which the java virtual machine runs. JRE contains Java virtual
   Machine(JVM), class libraries, and other files excluding development tools such as compiler and
   debugger.
   Which means you can run the code in JRE but you can’t develop and compile the code in JRE.

   JVM: As we discussed above, JVM runs the program by using class, libraries and files provided by JRE.
   JRE
   JDK: JDK is a superset of JRE, it contains everything that JRE has along with development tools such
   as compiler, debugger etc.


---
https://beginnersbook.com/2013/05/first-java-program/

How to Compile and Run your First Java Program

   In this tutorial, we will see how to write, compile and run a java program. I will also cover java
   syntax, code conventions and several ways to run a java program.

Simple Java Program:

public class FirstJavaProgram {
  public static void main(String[] args){
    System.out.println("This is my first program in java");
  }//End of main
}//End of FirstJavaProgram Class

   Output: This is my first program in java

How to compile and run the above program

     Prerequisite: You need to have java installed on your system. You can get the java from here.

   Step 1: Open a text editor, like Notepad on windows and TextEdit on Mac. Copy the above program and
   paste it in the text editor.

     You can also use IDE like Eclipse to run the java program but we will cover that part later in the
     coming tutorials. For the sake of simplicity, I will only use text editor and command prompt (or
     terminal) for this tutorial

   Step 2: Save the file as FirstJavaProgram.java. You may be wondering why we have named the file as
   FirstJavaProgram, the thing is that we should always name the file same as the public class name. In
   our program, the public class name is FirstJavaProgram, that’s why our file name should be
   FirstJavaProgram.java.

   Step 3: In this step, we will compile the program. For this, open command prompt (cmd) on Windows, if
   you are Mac OS then open Terminal.
   To compile the program, type the following command and hit enter.
javac FirstJavaProgram.java

     You may get this error when you try to compile the program: “javac’ is not recognized as an
     internal or external command, operable program or batch file“. This error occurs when the java
     path is not set in your system

   If you get this error then you first need to set the path before compilation.

   Set Path in Windows:
   Open command prompt (cmd), go to the place where you have installed java on your system and locate
   the bin directory, copy the complete path and write it in the command like this.
set path=C:\Program Files\Java\jdk1.8.0_121\bin

   Note: Your jdk version may be different. Since I have java version 1.8.0_121 installed on my system,
   I mentioned the same while setting up the path.

   Set Path in Mac OS X
   Open Terminal, type the following command and hit return.
export JAVA_HOME=/Library/Java/Home

   Type the following command on terminal to confirm the path.
echo $JAVA_HOME

   That’s it.

     The steps above are for setting up the path temporary which means when you close the command
     prompt or terminal, the path settings will be lost and you will have to set the path again next
     time you use it. I will share the permanent path setup guide in the coming tutorial.

   Step 4: After compilation the .java file gets translated into the .class file(byte code). Now we can
   run the program. To run the program, type the following command and hit enter:
java FirstJavaProgram

     Note that you should not append the .java extension to the file name while running the program.

Closer look to the First Java Program
   Now that we have understood how to run a java program, let have a closer look at the program we have
   written above.
public class FirstJavaProgram {

   This is the first line of our java program. Every java application must have at least one class
   definition that consists of class keyword followed by class name. When I say keyword, it means that
   it should not be changed, we should use it as it is. However the class name can be anything.

   I have made the class public by using public access modifier, I will cover access modifier in a
   separate post, all you need to know now that a java file can have any number of classes but it can
   have only one public class and the file name should be same as public class name.
public static void main(String[] args)  {

   This is our next line in the program, lets break it down to understand it:
   public: This makes the main method public that means that we can call the method from outside the
   class.

   static: We do not need to create object for static methods to run. They can run itself.

   void: It does not return anything.

   main: It is the method name. This is the entry point method from which the JVM can run your program.

   (String[] args): Used for command line arguments that are passed as strings. We will cover that in a
   separate post.
System.out.println("This is my first program in java");

   This method prints the contents inside the double quotes into the console and inserts a newline
   after.

   Checkout these basic java programs before reading next topic:
     * Java Program to read number (entered by user)
     * Java Program to check if a number is positive or negative
     * Java Program to add two numbers
            20. https://beginnersbook.com/2017/09/java-examples/
            21. https://beginnersbook.com/2017/09/java-program-to-read-integer-value-from-the-standard-input/
            22. https://beginnersbook.com/2017/09/java-program-to-check-if-number-is-positive-or-negative/
            23. https://beginnersbook.com/2017/09/java-program-to-add-two-numbers/


---
https://beginnersbook.com/2017/08/variables-in-java/

Variables in Java

   A variable is a name which is associated with a value that can be changed. For example when I write
   int i=10; here variable name is i which is associated with value 10, int is a data type that
   represents that this variable can hold integer values. We will cover the data types in the next
   tutorial. In this tutorial, we will discuss about variables.

How to Declare a variable in Java
   To declare a variable follow this syntax:
data_type variable_name = value;

   here value is optional because in java, you can declare the variable first and then later assign the
   value to it.

   For example: Here num is a variable and int is a data type. We will discuss the data type in next
   tutorial so do not worry too much about it, just understand that int data type allows this num
   variable to hold integer values. You can read data types here but I would recommend you to finish
   reading this guide before proceeding to the next one.
int num;

   Similarly we can assign the values to the variables while declaring them, like this:
char ch = 'A';
int number = 100;

   or we can do it like this:
char ch;
int number;
...
ch = 'A';
number  = 100;

Variables naming convention in java
   1) Variables naming cannot contain white spaces, for example: int num ber = 100; is invalid because
   the variable name has space in it.
   2) Variable name can begin with special characters such as $ and _
   3) As per the java coding standards the variable name should begin with a lower case letter, for
   example int number; For lengthy variables names that has more than one words do it like this: int
   smallNumber; int bigNumber; (start the second word with capital letter).
   4) Variable names are case sensitive in Java.

Types of Variables in Java
   There are three types of variables in Java.
   1) Local variable 2) Static (or class) variable 3) Instance variable

Static (or class) Variable
   Static variables are also known as class variable because they are associated with the class and
   common for all the instances of class. For example, If I create three objects of a class and access
   this static variable, it would be common for all, the changes made to the variable using one of the
   object would reflect when you access it through other objects.

Example of static variable

public class StaticVarExample {
   public static String myClassVar="class or static variable";

   public static void main(String args[]){
      StaticVarExample obj = new StaticVarExample();
      StaticVarExample obj2 = new StaticVarExample();
      StaticVarExample obj3 = new StaticVarExample();

      //All three will display "class or static variable"
      System.out.println(obj.myClassVar);
      System.out.println(obj2.myClassVar);
      System.out.println(obj3.myClassVar);

      //changing the value of static variable using obj2
      obj2.myClassVar = "Changed Text";

      //All three will display "Changed Text"
      System.out.println(obj.myClassVar);
      System.out.println(obj2.myClassVar);
      System.out.println(obj3.myClassVar);
   }
}

   Output:
class or static variable
class or static variable
class or static variable
Changed Text
Changed Text
Changed Text

   As you can see all three statements displayed the same output irrespective of the instance through
   which it is being accessed. That’s is why we can access the static variables without using the
   objects like this:
System.out.println(myClassVar);

     Do note that only static variables can be accessed like this. This doesn’t apply for instance and
     local variables.

Instance variable
   Each instance(objects) of class has its own copy of instance variable. Unlike static variable,
   instance variables have their own separate copy of instance variable. We have changed the instance
   variable value using object obj2 in the following program and when we displayed the variable using
   all three objects, only the obj2 value got changed, others remain unchanged. This shows that they
   have their own copy of instance variable.

Example of Instance variable

public class InstanceVarExample {
   String myInstanceVar="instance variable";

   public static void main(String args[]){
        InstanceVarExample obj = new InstanceVarExample();
        InstanceVarExample obj2 = new InstanceVarExample();
        InstanceVarExample obj3 = new InstanceVarExample();

        System.out.println(obj.myInstanceVar);
        System.out.println(obj2.myInstanceVar);
        System.out.println(obj3.myInstanceVar);


        obj2.myInstanceVar = "Changed Text";


        System.out.println(obj.myInstanceVar);
        System.out.println(obj2.myInstanceVar);
        System.out.println(obj3.myInstanceVar);
   }
}

   Output:
instance variable
instance variable
instance variable
instance variable
Changed Text
instance variable

Local Variable
   These variables are declared inside method of the class. Their scope is limited to the method which
   means that You can’t change their values and access them outside of the method.

   In this example, I have declared the instance variable with the same name as local variable, this is
   to demonstrate the scope of local variables.

Example of Local variable

public class VariableExample {
   // instance variable
   public String myVar="instance variable";

   public void myMethod(){
        // local variable
        String myVar = "Inside Method";
        System.out.println(myVar);
   }
   public static void main(String args[]){
      // Creating object
      VariableExample obj = new VariableExample();

      /* We are calling the method, that changes the
       * value of myVar. We are displaying myVar again after
       * the method call, to demonstrate that the local
       * variable scope is limited to the method itself.
       */
      System.out.println("Calling Method");
      obj.myMethod();
      System.out.println(obj.myVar);
   }
}

   Output:
Calling Method
Inside Method
instance variable

     If I hadn’t declared the instance variable and only declared the local variable inside method then
     the statement System.out.println(obj.myVar); would have thrown compilation error. As you cannot
     change and access local variables outside the method.

   Check out these related java examples before proceeding to the next topic:
    1. Java Program to Find ASCII value of a Character
    2. Java Program to Multiply two Numbers
    3. Java Program to Calculate Area of Triangle
        21. https://beginnersbook.com/2017/09/java-program-to-find-ascii-value-of-a-character/
        22. https://beginnersbook.com/2017/09/java-program-to-multiply-two-numbers/
        23. https://beginnersbook.com/2014/01/java-program-to-calculate-area-of-triangle/    


---
https://beginnersbook.com/2017/08/data-types-in-java/

Data Types in Java

   Data type defines the values that a variable can take, for example if a variable has int data type,
   it can only take integer values. In java we have two categories of data type: 1) Primitive data types
   2) Non-primitive data types – Arrays and Strings are non-primitive data types, we will discuss them
   later in the coming tutorials. Here we will discuss primitive data types and literals in Java.

   Java is a statically typed language. A language is statically typed, if the data type of a variable
   is known at compile time. This means that you must specify the type of the variable (Declare the
   variable) before you can use it.
   In the last tutorial about Java Variables, we learned how to declare a variable, lets recall it:
int num;

   So in order to use the variable num in our program, we must declare it first as shown above. It is a
   good programming practice to declare all the variables ( that you are going to use) in the beginning
   of the program.

1) Primitive data types
   In Java, we have eight primitive data types: boolean, char, byte, short, int, long, float and double.
   Java developers included these data types to maintain the portability of java as the size of these
   primitive data types do not change from one operating system to another.
   [INS: :INS]

   byte, short, int and long data types are used for storing whole numbers.

   float and double are used for fractional numbers.

   char is used for storing characters(letters).

   boolean data type is used for variables that holds either true or false.

byte:
   This can hold whole number between -128 and 127. Mostly used to save memory and when you are certain
   that the numbers would be in the limit specified by byte data type.
   Default size of this data type: 1 byte.
   Default value: 0
   Example:
class JavaExample {
    public static void main(String[] args) {

        byte num;

        num = 113;
        System.out.println(num);
    }
}

   Output:
113

     Try the same program by assigning value assigning 150 value to variable num, you would get type
     mismatch error because the value 150 is out of the range of byte data type. The range of byte as I
     mentioned above is -128 to 127.

short:
   This is greater than byte in terms of size and less than integer. Its range is -32,768 to 32767.
   Default size of this data type: 2 byte
short num = 45678;

   int: Used when short is not large enough to hold the number, it has a wider range: -2,147,483,648 to
   2,147,483,647
   Default size: 4 byte
   Default value: 0
   Example:
class JavaExample {
    public static void main(String[] args) {

        short num;

        num = 150;
        System.out.println(num);
    }
}

   Output:
150

   The byte data type couldn’t hold the value 150 but a short data type can because it has a wider
   range.

long:
   Used when int is not large enough to hold the value, it has wider range than int data type, ranging
   from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.
   size: 8 bytes
   Default value: 0
   Example:
class JavaExample {
    public static void main(String[] args) {

        long num = -12332252626L;
        System.out.println(num);
    }
}

   Output:
-12332252626

   double: Sufficient for holding 15 decimal digits
   size: 8 bytes
   Example:
class JavaExample {
    public static void main(String[] args) {

        double num = -42937737.9d;
        System.out.println(num);
    }
}

   Output:
-4.29377379E7

   float: Sufficient for holding 6 to 7 decimal digits
   size: 4 bytes
class JavaExample {
    public static void main(String[] args) {

        float num = 19.98f;
        System.out.println(num);
    }
}

   Output:
19.98

   boolean: holds either true of false.
class JavaExample {
    public static void main(String[] args) {

        boolean b = false;
        System.out.println(b);
    }
}

   Output:
false

   char: holds characters.
   size: 2 bytes
class JavaExample {
    public static void main(String[] args) {

        char ch = 'Z';
        System.out.println(ch);
    }
}

   Output:
Z

Literals in Java
   A literal is a fixed value that we assign to a variable in a Program.
int num=10;

   Here value 10 is a Integer literal.
char ch = 'A';

   Here A is a char literal

Integer Literal
   Integer literals are assigned to the variables of data type byte, short, int and long.
byte b = 100;
short s = 200;
int num = 13313131;
long l = 928389283L;

Float Literals
   Used for data type float and double.
double num1 = 22.4;
float num2 = 22.4f;

   Note: Always suffix float value with the “f” else compiler will consider it as double.

Char and String Literal
   Used for char and String type.
char ch = 'Z';
String str = "BeginnersBook";

   Check out these basic java programs before proceeding to the next topic:
    1. Java Program to Add two Numbers
    2. Java Program to Multiply two numbers
    3. Java Program to read a number (entered by user)
        21. https://beginnersbook.com/2017/09/java-program-to-add-two-numbers/
        22. https://beginnersbook.com/2017/09/java-program-to-multiply-two-numbers/
        23. https://beginnersbook.com/2017/09/java-program-to-read-integer-value-from-the-standard-input/


---
https://beginnersbook.com/2017/08/operators-in-java/

Operators in Java

   An operator is a character that represents an action, for example + is an arithmetic operator that
   represents addition.

Types of Operator in Java
   1) Basic Arithmetic Operators
   2) Assignment Operators
   3) Auto-increment and Auto-decrement Operators
   4) Logical Operators
   5) Comparison (relational) operators
   6) Bitwise Operators
   7) Ternary Operator

1) Basic Arithmetic Operators
   Basic arithmetic operators are: +, -, *, /, %
   + is for addition.

   – is for subtraction.
   [INS: :INS]

   * is for multiplication.

   / is for division.

   % is for modulo.
   Note: Modulo operator returns remainder, for example 10 % 5 would return 0

Example of Arithmetic Operators

public class ArithmeticOperatorDemo {
   public static void main(String args[]) {
      int num1 = 100;
      int num2 = 20;

      System.out.println("num1 + num2: " + (num1 + num2) );
      System.out.println("num1 - num2: " + (num1 - num2) );
      System.out.println("num1 * num2: " + (num1 * num2) );
      System.out.println("num1 / num2: " + (num1 / num2) );
      System.out.println("num1 % num2: " + (num1 % num2) );
   }
}

   Output:
num1 + num2: 120
num1 - num2: 80
num1 * num2: 2000
num1 / num2: 5
num1 % num2: 0

   Checkout these java programs related to arithmetic Operators in Java:
    1. Java Program to Add two numbers
    2. Java Program to Multiply two Numbers

2) Assignment Operators
   Assignments operators in java are: =, +=, -=, *=, /=, %=
   num2 = num1 would assign value of variable num1 to the variable.

   num2+=num1 is equal to num2 = num2+num1

   num2-=num1 is equal to num2 = num2-num1

   num2*=num1 is equal to num2 = num2*num1

   num2/=num1 is equal to num2 = num2/num1

   num2%=num1 is equal to num2 = num2%num1

Example of Assignment Operators

public class AssignmentOperatorDemo {
   public static void main(String args[]) {
      int num1 = 10;
      int num2 = 20;

      num2 = num1;
      System.out.println("= Output: "+num2);

      num2 += num1;
      System.out.println("+= Output: "+num2);

      num2 -= num1;
      System.out.println("-= Output: "+num2);

      num2 *= num1;
      System.out.println("*= Output: "+num2);

      num2 /= num1;
      System.out.println("/= Output: "+num2);

      num2 %= num1;
      System.out.println("%= Output: "+num2);
   }
}

   Output:
= Output: 10
+= Output: 20
-= Output: 10
*= Output: 100
/= Output: 10
%= Output: 0

3) Auto-increment and Auto-decrement Operators
   ++ and —
   num++ is equivalent to num=num+1;

   num–- is equivalent to num=num-1;

Example of Auto-increment and Auto-decrement Operators

public class AutoOperatorDemo {
   public static void main(String args[]){
      int num1=100;
      int num2=200;
      num1++;
      num2--;
      System.out.println("num1++ is: "+num1);
      System.out.println("num2-- is: "+num2);
   }
}

   Output:
num1++ is: 101
num2-- is: 199

4) Logical Operators
   Logical Operators are used with binary variables. They are mainly used in conditional statements and
   loops for evaluating a condition.

   Logical operators in java are: &&, ||, !

   Let’s say we have two boolean variables b1 and b2.

   b1&&b2 will return true if both b1 and b2 are true else it would return false.

   b1||b2 will return false if both b1 and b2 are false else it would return true.

   !b1 would return the opposite of b1, that means it would be true if b1 is false and it would return
   false if b1 is true.

Example of Logical Operators

public class LogicalOperatorDemo {
   public static void main(String args[]) {
      boolean b1 = true;
      boolean b2 = false;

      System.out.println("b1 && b2: " + (b1&&b2));
      System.out.println("b1 || b2: " + (b1||b2));
      System.out.println("!(b1 && b2): " + !(b1&&b2));
   }
}

   Output:
b1 && b2: false
b1 || b2: true
!(b1 && b2): true

5) Comparison(Relational) operators
   We have six relational operators in Java: ==, !=, >, <, >=, <=

   == returns true if both the left side and right side are equal

   != returns true if left side is not equal to the right side of operator.

   > returns true if left side is greater than right.

   < returns true if left side is less than right side.

   >= returns true if left side is greater than or equal to right side.

   <= returns true if left side is less than or equal to right side.

Example of Relational operators

   Note: This example is using if-else statement which is our next tutorial, if you are finding it
   difficult to understand then refer if-else in Java.
public class RelationalOperatorDemo {
   public static void main(String args[]) {
      int num1 = 10;
      int num2 = 50;
      if (num1==num2) {
         System.out.println("num1 and num2 are equal");
      }
      else{
         System.out.println("num1 and num2 are not equal");
      }

      if( num1 != num2 ){
         System.out.println("num1 and num2 are not equal");
      }
      else{
         System.out.println("num1 and num2 are equal");
      }

      if( num1 > num2 ){
         System.out.println("num1 is greater than num2");
      }
      else{
         System.out.println("num1 is not greater than num2");
      }

      if( num1 >= num2 ){
         System.out.println("num1 is greater than or equal to num2");
      }
      else{
         System.out.println("num1 is less than num2");
      }

      if( num1 < num2 ){
         System.out.println("num1 is less than num2");
      }
      else{
         System.out.println("num1 is not less than num2");
      }

      if( num1 <= num2){
         System.out.println("num1 is less than or equal to num2");
      }
      else{
         System.out.println("num1 is greater than num2");
      }
   }
}

   Output:
num1 and num2 are not equal
num1 and num2 are not equal
num1 is not greater than num2
num1 is less than num2
num1 is less than num2
num1 is less than or equal to num2

   Check out these related java programs related to relational operators:
    1. Java Program to check if number is positive or negative
    2. Java Program to check whether number is even or odd

6) Bitwise Operators
   There are six bitwise Operators: &, |, ^, ~, <<, >>

   num1 = 11; /* equal to 00001011*/
   num2 = 22; /* equal to 00010110 */

   Bitwise operator performs bit by bit processing.
   num1 & num2 compares corresponding bits of num1 and num2 and generates 1 if both bits are equal, else
   it returns 0. In our case it would return: 2 which is 00000010 because in the binary form of num1 and
   num2 only second last bits are matching.

   num1 | num2 compares corresponding bits of num1 and num2 and generates 1 if either bit is 1, else it
   returns 0. In our case it would return 31 which is 00011111

   num1 ^ num2 compares corresponding bits of num1 and num2 and generates 1 if they are not equal, else
   it returns 0. In our example it would return 29 which is equivalent to 00011101

   ~num1 is a complement operator that just changes the bit from 0 to 1 and 1 to 0. In our example it
   would return -12 which is signed 8 bit equivalent to 11110100

   num1 << 2 is left shift operator that moves the bits to the left, discards the far left bit, and
   assigns the rightmost bit a value of 0. In our case output is 44 which is equivalent to 00101100

     Note: In the example below we are providing 2 at the right side of this shift operator that is the
     reason bits are moving two places to the left side. We can change this number and bits would be
     moved by the number of bits specified on the right side of the operator. Same applies to the right
     side operator.

   num1 >> 2 is right shift operator that moves the bits to the right, discards the far right bit, and
   assigns the leftmost bit a value of 0. In our case output is 2 which is equivalent to 00000010

Example of Bitwise Operators

public class BitwiseOperatorDemo {
  public static void main(String args[]) {

     int num1 = 11;  /* 11 = 00001011 */
     int num2 = 22;  /* 22 = 00010110 */
     int result = 0;

     result = num1 & num2;
     System.out.println("num1 & num2: "+result);

     result = num1 | num2;
     System.out.println("num1 | num2: "+result);

     result = num1 ^ num2;
     System.out.println("num1 ^ num2: "+result);

     result = ~num1;
     System.out.println("~num1: "+result);

     result = num1 << 2;
     System.out.println("num1 << 2: "+result); result = num1 >> 2;
     System.out.println("num1 >> 2: "+result);
  }
}

   Output:
num1 & num2: 2
num1 | num2: 31
num1 ^ num2: 29
~num1: -12
num1 << 2: 44 num1 >> 2: 2

   Check out this program: Java Program to swap two numbers using bitwise operator

7) Ternary Operator
   This operator evaluates a boolean expression and assign the value based on the result.
   Syntax:
variable num1 = (expression) ? value if true : value if false

   If the expression results true then the first value before the colon (:) is assigned to the variable
   num1 else the second value is assigned to the num1.

Example of Ternary Operator

public class TernaryOperatorDemo {

   public static void main(String args[]) {
        int num1, num2;
        num1 = 25;
        /* num1 is not equal to 10 that's why
         * the second value after colon is assigned
         * to the variable num2
         */
        num2 = (num1 == 10) ? 100: 200;
        System.out.println( "num2: "+num2);

        /* num1 is equal to 25 that's why
         * the first value is assigned
         * to the variable num2
         */
        num2 = (num1 == 25) ? 100: 200;
        System.out.println( "num2: "+num2);
   }
}

   Output:
num2: 200
num2: 100

   Check out these related java programs:
    1. Java Program to find Largest of three numbers using Ternary Operator
    2. Java Program to find the smallest of three numbers using Ternary Operator

Operator Precedence in Java
   This determines which operator needs to be evaluated first if an expression has more than one
   operator. Operator with higher precedence at the top and lower precedence at the bottom.
   Unary Operators
   ++  – –  !  ~

   Multiplicative
   *  / %

   Additive
   +  –

   Shift
   <<  >>  >>>

   Relational
   >  >=  <  <=

   Equality
   ==  !=

   Bitwise AND
   &

   Bitwise XOR
   ^

   Bitwise OR
   |

   Logical AND
   &&

   Logical OR
   ||

   Ternary
   ?:

   Assignment
   =  +=  -=  *=  /=  %=  >  >=  <  <=  &=  ^=  |=


---
https://beginnersbook.com/2017/08/if-else-statement-in-java/

If, If..else Statement in Java with Examples

   When we need to execute a set of statements based on a condition then we need to use control flow
   statements. For example, if a number is greater than zero then we want to print “Positive Number” but
   if it is less than zero then we want to print “Negative Number”. In this case we have two print
   statements in the program, but only one print statement executes at a time based on the input value.
   We will see how to write such type of conditions in the java program using control statements.

   In this tutorial, we will see four types of control statements that you can use in java programs
   based on the requirement: In this tutorial we will cover following conditional statements:

   a) if statement
   b) nested if statement
   c) if-else statement
   d) if-else-if statement

If statement
   If statement consists a condition, followed by statement or a set of statements as shown below:
   [INS: :INS]
if(condition){
  Statement(s);
}

   The statements gets executed only when the given condition is true. If the condition is false then
   the statements inside if statement body are completely ignored.
   if statement flow diagram

Example of if statement

public class IfStatementExample {

   public static void main(String args[]){
      int num=70;
      if( num < 100 ){
          /* This println statement will only execute,
           * if the above condition is true
           */
          System.out.println("number is less than 100");
      }
   }
}

   Output:
number is less than 100

Nested if statement in Java

   When there is an if statement inside another if statement then it is called the nested if statement.
   The structure of nested if looks like this:
if(condition_1) {
   Statement1(s);

   if(condition_2) {
      Statement2(s);
   }
}

   Statement1 would execute if the condition_1 is true. Statement2 would only execute if both the
   conditions( condition_1 and condition_2) are true.

Example of Nested if statement

public class NestedIfExample {

   public static void main(String args[]){
        int num=70;
        if( num < 100 ){
           System.out.println("number is less than 100");
           if(num > 50){
              System.out.println("number is greater than 50");
           }
        }
   }
}

   Output:
number is less than 100
number is greater than 50

If else statement in Java

   This is how an if-else statement looks:
if(condition) {
   Statement(s);
}
else {
   Statement(s);
}

   The statements inside “if” would execute if the condition is true, and the statements inside “else”
   would execute if the condition is false.
   If else flow diagram

Example of if-else statement

public class IfElseExample {

   public static void main(String args[]){
     int num=120;
     if( num < 50 ){
        System.out.println("num is less than 50");
     }
     else {
        System.out.println("num is greater than or equal 50");
     }
   }
}

   Output:
num is greater than or equal 50

if-else-if Statement

   if-else-if statement is used when we need to check multiple conditions. In this statement we have
   only one “if” and one “else”, however we can have multiple “else if”. It is also known as if else if
   ladder. This is how it looks:
if(condition_1) {
   /*if condition_1 is true execute this*/
   statement(s);
}
else if(condition_2) {
   /* execute this if condition_1 is not met and
    * condition_2 is met
    */
   statement(s);
}
else if(condition_3) {
   /* execute this if condition_1 & condition_2 are
    * not met and condition_3 is met
    */
   statement(s);
}
.
.
.
else {
   /* if none of the condition is true
    * then these statements gets executed
    */
   statement(s);
}

   Note: The most important point to note here is that in if-else-if statement, as soon as the condition
   is met, the corresponding set of statements get executed, rest gets ignored. If none of the condition
   is met then the statements inside “else” gets executed.

Example of if-else-if

public class IfElseIfExample {

   public static void main(String args[]){
        int num=1234;
        if(num <100 && num>=1) {
          System.out.println("Its a two digit number");
        }
        else if(num <1000 && num>=100) {
          System.out.println("Its a three digit number");
        }
        else if(num <10000 && num>=1000) {
          System.out.println("Its a four digit number");
        }
        else if(num <100000 && num>=10000) {
          System.out.println("Its a five digit number");
        }
        else {
          System.out.println("number is not between 1 & 99999");
        }
   }
}

   Output:
Its a four digit number


---
https://beginnersbook.com/2017/08/java-switch-case/

Switch Case statement in Java with example

   Switch case statement is used when we have number of options (or choices) and we may need to perform
   a different task for each choice.

   The syntax of Switch case statement looks like this –
switch (variable or an integer expression)
{
     case constant:
     //Java code
     ;
     case constant:
     //Java code
     ;
     default:
     //Java code
     ;
}

     Switch Case statement is mostly used with break statement even though it is optional. We will
     first see an example without break statement and then we will discuss switch case with break

A Simple Switch Case Example

public class SwitchCaseExample1 {

   public static void main(String args[]){
     int num=2;
     switch(num+2)
     {
        case 1:
          System.out.println("Case1: Value is: "+num);
        case 2:
          System.out.println("Case2: Value is: "+num);
        case 3:
          System.out.println("Case3: Value is: "+num);
        default:
          System.out.println("Default: Value is: "+num);
      }
   }
}

   Output:

Default: Value is: 2

   Explanation: In switch I gave an expression, you can give variable also. I gave num+2, where num
   value is 2 and after addition the expression resulted 4. Since there is no case defined with value 4
   the default case got executed. This is why we should use default in switch case, so that if there is
   no catch that matches the condition, the default block gets executed.

Switch Case Flow Diagram
   First the variable, value or expression which is provided in the switch parenthesis is evaluated and
   then based on the result, the corresponding case block is executed that matches the result.
   switch case flow diagram

Break statement in Switch Case
   Break statement is optional in switch case but you would use it almost every time you deal with
   switch case. Before we discuss about break statement, Let’s have a look at the example below where I
   am not using the break statement:
public class SwitchCaseExample2 {

   public static void main(String args[]){
      int i=2;
      switch(i)
      {
         case 1:
           System.out.println("Case1 ");
         case 2:
           System.out.println("Case2 ");
         case 3:
           System.out.println("Case3 ");
         case 4:
           System.out.println("Case4 ");
         default:
           System.out.println("Default ");
      }
   }
}

   Output:
Case2
Case3
Case4
Default

     In the above program, we have passed integer value 2 to the switch, so the control switched to the
     case 2, however we don’t have break statement after the case 2 that caused the flow to pass to the
     subsequent cases till the end. The solution to this problem is break statement

   Break statements are used when you want your program-flow to come out of the switch body. Whenever a
   break statement is encountered in the switch body, the execution flow would directly come out of the
   switch, ignoring rest of the cases

   Let’s take the same example but this time with break statement.

Example with break statement

public class SwitchCaseExample2 {

   public static void main(String args[]){
      int i=2;
      switch(i)
      {
         case 1:
           System.out.println("Case1 ");
           break;
         case 2:
           System.out.println("Case2 ");
           break;
         case 3:
           System.out.println("Case3 ");
           break;
         case 4:
           System.out.println("Case4 ");
           break;
         default:
           System.out.println("Default ");
      }
   }
}

   Output:
Case2

   Now you can see that only case 2 had been executed, rest of the cases were ignored.

   Why didn’t I use break statement after default?
   The control would itself come out of the switch after default so I didn’t use it, however if you
   still want to use the break after default then you can use it, there is no harm in doing that.

Few points about Switch Case

   1) Case doesn’t always need to have order 1, 2, 3 and so on. It can have any integer value after case
   keyword. Also, case doesn’t need to be in an ascending order always, you can specify them in any
   order based on the requirement.

   2) You can also use characters in switch case. for example –
public class SwitchCaseExample2 {

   public static void main(String args[]){
      char ch='b';
      switch(ch)
      {
         case 'd':
           System.out.println("Case1 ");
           break;
         case 'b':
           System.out.println("Case2 ");
           break;
         case 'x':
           System.out.println("Case3 ");
           break;
         case 'y':
           System.out.println("Case4 ");
           break;
         default:
           System.out.println("Default ");
      }
   }
}

   3) The expression given inside switch should result in a constant value otherwise it would not be
   valid.
   For example:

   Valid expressions for switch:
switch(1+2+23)
switch(1*2+3%4)

   Invalid switch expressions:
switch(ab+cd)
switch(a+b+c)

   4) Nesting of switch statements are allowed, which means you can have switch statements inside
   another switch. However nested switch statements should be avoided as it makes program more complex
   and less readable.


---
https://beginnersbook.com/2015/03/for-loop-in-java-with-example/

For loop in Java with example

   Loops are used to execute a set of statements repeatedly until a particular condition is satisfied.
   In Java we have three types of basic loops: for, while and do-while. In this tutorial we will learn
   how to use “for loop” in Java.

Syntax of for loop:

for(initialization; condition ; increment/decrement)
{
   statement(s);
}

Flow of Execution of the for Loop
   As a program executes, the interpreter always keeps track of which statement is about to be executed.
   We call this the control flow, or the flow of execution of the program.
   for loop Java

   First step: In for loop, initialization happens first and only one time, which means that the
   initialization part of for loop only executes once.

   Second step: Condition in for loop is evaluated on each iteration, if the condition is true then the
   statements inside for loop body gets executed. Once the condition returns false, the statements in
   for loop does not execute and the control gets transferred to the next statement in the program after
   for loop.

   Third step: After every execution of for loop’s body, the increment/decrement part of for loop
   executes that updates the loop counter.

   Fourth step: After third step, the control jumps to second step and condition is re-evaluated.

Example of Simple For loop

class ForLoopExample {
    public static void main(String args[]){
         for(int i=10; i>1; i--){
              System.out.println("The value of i is: "+i);
         }
    }
}

   The output of this program is:
The value of i is: 10
The value of i is: 9
The value of i is: 8
The value of i is: 7
The value of i is: 6
The value of i is: 5
The value of i is: 4
The value of i is: 3
The value of i is: 2

   In the above program:
   int i=1 is initialization expression
   i>1 is condition(Boolean expression)
   i– Decrement operation

Infinite for loop
   The importance of Boolean expression and increment/decrement operation co-ordination:
class ForLoopExample2 {
    public static void main(String args[]){
         for(int i=1; i>=1; i++){
              System.out.println("The value of i is: "+i);
         }
    }
}

   This is an infinite loop as the condition would never return false. The initialization step is
   setting up the value of variable i to 1, since we are incrementing the value of i, it would always be
   greater than 1 (the Boolean expression: i>1) so it would never return false. This would eventually
   lead to the infinite loop condition. Thus it is important to see the co-ordination between Boolean
   expression and increment/decrement operation to determine whether the loop would terminate at some
   point of time or not.

   Here is another example of infinite for loop:
// infinite loop
for ( ; ; ) {
    // statement(s)
}

For loop example to iterate an array:

   Here we are iterating and displaying array elements using the for loop.
class ForLoopExample3 {
    public static void main(String args[]){
         int arr[]={2,11,45,9};
         //i starts with 0 as array index starts with 0 too
         for(int i=0; i<arr.length; i++){
              System.out.println(arr[i]);
         }
    }
}

   Output:
2
11
45
9

Enhanced For loop
   Enhanced for loop is useful when you want to iterate Array/Collections, it is easy to write and
   understand.

   Let’s take the same example that we have written above and rewrite it using enhanced for loop.
class ForLoopExample3 {
   public static void main(String args[]){
      int arr[]={2,11,45,9};
      for (int num : arr) {
         System.out.println(num);
      }
   }
}

   Output:
2
11
45
9

   Note: In the above example, I have declared the num as int in the enhanced for loop. This will change
   depending on the data type of array. For example, the enhanced for loop for string type would look
   like this:
String arr[]={"hi","hello","bye"};
for (String str : arr) {
         System.out.println(str);
}


---
https://beginnersbook.com/2015/03/while-loop-in-java-with-examples/

While loop in Java with examples

   In the last tutorial, we discussed for loop. In this tutorial we will discuss while loop. As
   discussed in previous tutorial, loops are used to execute a set of statements repeatedly until a
   particular condition is satisfied.

Syntax of while loop

while(condition)
{
   statement(s);
}

How while Loop works?
   In while loop, condition is evaluated first and if it returns true then the statements inside while
   loop execute. When condition returns false, the control comes out of loop and jumps to the next
   statement after while loop.

     Note: The important point to note when using while loop is that we need to use increment or
     decrement statement inside while loop so that the loop variable gets changed on each iteration,
     and at some point condition returns false. This way we can end the execution of while loop
     otherwise the loop would execute indefinitely.

Simple while loop example

class WhileLoopExample {
    public static void main(String args[]){
         int i=10;
         while(i>1){
              System.out.println(i);
              i--;
         }
    }
}

   Output:
10
9
8
7
6
5
4
3
2

Infinite while loop

class WhileLoopExample2 {
    public static void main(String args[]){
         int i=10;
         while(i>1)
         {
             System.out.println(i);
              i++;
         }
    }
}

   This loop would never end, its an infinite while loop. This is because condition is i>1 which would
   always be true as we are incrementing the value of i inside while loop.

   Here is another example of infinite while loop:
while (true){
    statement(s);
}

Example: Iterating an array using while loop

   Here we are iterating and displaying array elements using while loop.
class WhileLoopExample3 {
    public static void main(String args[]){
         int arr[]={2,11,45,9};
         //i starts with 0 as array index starts with 0 too
         int i=0;
         while(i<4){
              System.out.println(arr[i]);
              i++;
         }
    }
}

   Output:
2
11
45
9


---
https://beginnersbook.com/2015/03/do-while-loop-in-java-with-example/

do-while loop in Java with example

   In the last tutorial, we discussed while loop. In this tutorial we will discuss do-while loop in
   java. do-while loop is similar to while loop, however there is a difference between them: In while
   loop, condition is evaluated before the execution of loop’s body but in do-while loop condition is
   evaluated after the execution of loop’s body.

Syntax of do-while loop:

do
{
   statement(s);
} while(condition);

How do-while loop works?

   First, the statements inside loop execute and then the condition gets evaluated, if the condition
   returns true then the control gets transferred to the “do” else it jumps to the next statement after
   do-while.
   do while loop java

do-while loop example

class DoWhileLoopExample {
    public static void main(String args[]){
         int i=10;
         do{
              System.out.println(i);
              i--;
         }while(i>1);
    }
}

   Output:
10
9
8
7
6
5
4
3
2

Example: Iterating array using do-while loop

   Here we have an integer array and we are iterating the array and displaying each element using
   do-while loop.
   [INS: :INS]
class DoWhileLoopExample2 {
    public static void main(String args[]){
         int arr[]={2,11,45,9};
         //i starts with 0 as array index starts with 0
         int i=0;
         do{
              System.out.println(arr[i]);
              i++;
         }while(i<4);
    }
}

   Output:
   2
   11
   45
   9


---
https://beginnersbook.com/2017/08/java-continue-statement/

Continue Statement in Java with example

   Continue statement is mostly used inside loops. Whenever it is encountered inside a loop, control
   directly jumps to the beginning of the loop for next iteration, skipping the execution of statements
   inside loop’s body for the current iteration. This is particularly useful when you want to continue
   the loop but do not want the rest of the statements(after continue statement) in loop body to execute
   for that particular iteration.

   Syntax:
   continue word followed by semi colon.
continue;

Example: continue statement inside for loop

public class ContinueExample {

   public static void main(String args[]){
        for (int j=0; j<=6; j++)
        {
           if (j==4)
           {
              continue;
           }

           System.out.print(j+" ");
        }
   }
}

   Output:
0 1 2 3 5 6

     As you may have noticed, the value 4 is missing in the output, why? because when the value of
     variable j is 4, the program encountered a continue statement, which makes it to jump at the
     beginning of for loop for next iteration, skipping the statements for current iteration
     (that’s the reason println didn’t execute when the value of j was 4).

   Continue Statement

Example: Use of continue in While loop

   Same thing you can see here. We are iterating this loop from 10 to 0 for counter value and when the
   counter value is 7 the loop skipped the print statement and started next iteration of the while
   loop.
public class ContinueExample2 {

   public static void main(String args[]){
        int counter=10;
        while (counter >=0)
        {
           if (counter==7)
           {
               counter--;
               continue;
           }
           System.out.print(counter+" ");
           counter--;
        }
   }
}


   Output:
10 9 8 6 5 4 3 2 1 0

Example of continue in do-While loop

public class ContinueExample3 {

   public static void main(String args[]){
        int j=0;
        do
        {
           if (j==7)
           {
                 j++;
                 continue;
           }
           System.out.print(j+ " ");
           j++;
       }while(j<10);

   }
}

   Output:
0 1 2 3 4 5 6 8 9


---
https://beginnersbook.com/2017/08/java-break-statement/

Break statement in Java with example

   The break statement is usually used in following two scenarios:

   a) Use break statement to come out of the loop instantly. Whenever a break statement is encountered
   inside a loop, the control directly comes out of loop and the loop gets terminated for rest of the
   iterations. It is used along with if statement, whenever used inside loop so that the loop gets
   terminated for a particular condition.

   The important point to note here is that when a break statement is used inside a nested loop, then
   only the inner loop gets terminated.

   b) It is also used in switch case control. Generally all cases in switch case are followed by a
   break statement so that whenever the program control jumps to a case, it doesn’t execute subsequent
   cases (see the example below). As soon as a break is encountered in switch-case block, the control
   comes out of the switch-case body.
   [INS: :INS]

   Syntax of break statement:
   “break” word followed by semi colon
break;

Example – Use of break in a while loop

   In the example below, we have a while loop running from o to 100 but since we have a break
   statement that only occurs when the loop value reaches 2, the loop gets terminated and the control
   gets passed to the next statement in program after the loop body.
public class BreakExample1 {
   public static void main(String args[]){
      int num =0;
      while(num<=100)
      {
          System.out.println("Value of variable is: "+num);
          if (num==2)
          {
             break;
          }
          num++;
      }
      System.out.println("Out of while-loop");
  }
}

   Output:
Value of variable is: 0
Value of variable is: 1
Value of variable is: 2
Out of while-loop

Example – Use of break in a for loop

   The same thing you can see here. As soon as the var value hits 99, the for loop gets terminated.
public class BreakExample2 {

   public static void main(String args[]){
        int var;
        for (var =100; var>=10; var --)
        {
            System.out.println("var: "+var);
            if (var==99)
            {
                 break;
            }
         }
         System.out.println("Out of for-loop");
   }
}

   Output:
var: 100
var: 99
Out of for-loop

Example – Use of break statement in switch-case

public class BreakExample3 {

   public static void main(String args[]){
        int num=2;

        switch (num)
        {
            case 1:
               System.out.println("Case 1 ");
               break;
            case 2:
               System.out.println("Case 2 ");
               break;
            case 3:
               System.out.println("Case 3 ");
               break;
            default:
               System.out.println("Default ");
        }
   }
}


   Output:
Case 2

   In this example, we have break statement after each Case block, this is because if we don’t have it
   then the subsequent case block would also execute. The output of the same program without break would
   be Case 2 Case 3 Default.


---
https://beginnersbook.com/2013/04/oops-concepts/

OOPs concepts in Java

   Object-oriented programming System(OOPs) is a programming paradigm based on the concept of “objects”
   that contain data and methods. The primary purpose of object-oriented programming is to increase the
   flexibility and maintainability of programs. Object oriented programming brings together data and its
   behaviour(methods) in a single location(object) makes it easier to understand how a program works. We
   will cover each and every feature of OOPs in detail so that you won’t face any difficultly
   understanding OOPs Concepts.

OOPs Concepts – Table of Contents

    1. What is an Object
    2. What is a class
    3. Constructor in Java
    4. Object Oriented Programming Features
          + Abstraction
          + Encapsulation
          + Inheritance
          + Polymorphism
    5. Abstract Class and Methods
    6. Interfaces in Java

What is an Object

   OOPs Concepts Object Class
   Object: is a bundle of data and its behaviour(often known as methods).

   Objects have two characteristics: They have states and behaviors.

   Examples of states and behaviors
   Example 1:
   Object: House
   State: Address, Color, Area
   Behavior: Open door, close door

   So if I had to write a class based on states and behaviours of House. I can do it like this: States
   can be represented as instance variables and behaviours as methods of the class. We will see how to
   create classes in the next section of this guide.
class House {
   String address;
   String color;
   double are;
   void openDoor() {
      //Write code here
   }
   void closeDoor() {
      //Write code here
   }
 ...
 ...
}

   Example 2:
   Let’s take another example.
   Object: Car
   State: Color, Brand, Weight, Model
   Behavior: Break, Accelerate, Slow Down, Gear change.

   Note: As we have seen above, the states and behaviors of an object, can be represented by variables
   and methods in the class respectively.

Characteristics of Objects:
   If you find it hard to understand Abstraction and Encapsulation, do not worry as I have covered these
   topics in detail with examples in the next section of this guide.
    1. Abstraction
    2. Encapsulation
    3. Message passing

   Abstraction: Abstraction is a process where you show only “relevant” data and “hide” unnecessary
   details of an object from the user.

   Encapsulation: Encapsulation simply means binding object state(fields) and behaviour(methods)
   together. If you are creating class, you are doing encapsulation.

   Message passing
   A single object by itself may not be very useful. An application contains many objects. One object
   interacts with another object by invoking methods on that object. It is also referred to as Method
   Invocation. See the diagram below.

   OOPs concepts, Message passing

What is a Class in OOPs Concepts
   A class can be considered as a blueprint using which you can create as many objects as you like. For
   example, here we have a class Website that has two data members (also known as fields, instance
   variables and object states). This is just a blueprint, it does not represent any website, however
   using this we can create Website objects (or instances) that represents the websites. We have created
   two objects, while creating objects we provided separate properties to the objects using constructor.
public class Website {
   //fields (or instance variable)
   String webName;
   int webAge;

   // constructor
   Website(String name, int age){
      this.webName = name;
      this.webAge = age;
   }
   public static void main(String args[]){
      //Creating objects
      Website obj1 = new Website("beginnersbook", 5);
      Website obj2 = new Website("google", 18);

     //Accessing object data through reference
     System.out.println(obj1.webName+" "+obj1.webAge);
     System.out.println(obj2.webName+" "+obj2.webAge);
   }
}

   Output:
beginnersbook 5
google 18

What is a Constructor
   Constructor looks like a method but it is in fact not a method. It’s name is same as class name
   and it does not return any value. You must have seen this statement in almost all the programs I have
   shared above:
MyClass obj = new MyClass();

   If you look at the right side of this statement, we are calling the default constructor of class
   myClass to create a new object (or instance).

   We can also have parameters in the constructor, such constructors are known as parametrized
   constructors.

Example of constructor

public class ConstructorExample {

   int age;
   String name;

   //Default constructor
   ConstructorExample(){
        this.name="Chaitanya";
        this.age=30;
   }

   //Parameterized constructor
   ConstructorExample(String n,int a){
        this.name=n;
        this.age=a;
   }
   public static void main(String args[]){
        ConstructorExample obj1 = new ConstructorExample();
        ConstructorExample obj2 =
                       new ConstructorExample("Steve", 56);
        System.out.println(obj1.name+" "+obj1.age);
        System.out.println(obj2.name+" "+obj2.age);
   }
}

   Output:
Chaitanya 30
Steve 56

Object Oriented Programming features
   OOPs features, Object-oriented-programming-features
   These four features are the main OOPs Concepts that you must learn to understand the Object Oriented
   Programming in Java

Abstraction
   Abstraction is a process where you show only “relevant” data and “hide” unnecessary details of an
   object from the user. For example, when you login to your bank account online, you enter your user_id
   and password and press login, what happens when you press login, how the input data sent to server,
   how it gets verified is all abstracted away from the you. Read more about it here: Abstraction in
   Java.

Encapsulation
   Encapsulation simply means binding object state(fields) and behavior(methods) together. If you are
   creating class, you are doing encapsulation.

Encapsulation example in Java

   How to
   1) Make the instance variables private so that they cannot be accessed directly from outside the
   class. You can only set and get values of these variables through the methods of the class.
   2) Have getter and setter methods in the class to set and get the values of the fields.
class EmployeeCount
{
   private int numOfEmployees = 0;
   public void setNoOfEmployees (int count)
   {
       numOfEmployees = count;
   }
   public double getNoOfEmployees ()
   {
       return numOfEmployees;
   }
}
public class EncapsulationExample
{
   public static void main(String args[])
   {
      EmployeeCount obj = new EmployeeCount ();
      obj.setNoOfEmployees(5613);
      System.out.println("No Of Employees: "+(int)obj.getNoOfEmployees());
    }
}

   Output:
No Of Employees: 5613

   The class EncapsulationExample that is using the Object of class EmployeeCount will not able to get
   the NoOfEmployees directly. It has to use the setter and getter methods of the same class to set and
   get the value.
   So what is the benefit of encapsulation in java programming
   Well, at some point of time, if you want to change the implementation details of the class
   EmployeeCount, you can freely do so without affecting the classes that are using it.

Inheritance
   The process by which one class acquires the properties and functionalities of another class is called
   inheritance. Inheritance provides the idea of reusability of code and each sub class defines only
   those features that are unique to it, rest of the features can be inherited from the parent class.
    1. Inheritance is a process of defining a new class based on an existing class by extending its
       common data members and methods.
    2. Inheritance allows us to reuse of code, it improves reusability in your java application.
    3. The parent class is called the base class or super class. The child class that extends the base
       class is called the derived class or sub class or child class.

   Note: The biggest advantage of Inheritance is that the code in base class need not be rewritten in
   the child class.
   The variables and methods of the base class can be used in the child class as well.

Syntax: Inheritance in Java
   To inherit a class we use extends keyword. Here class A is child class and class B is parent class.
class A extends B
{
}

Inheritance Example
   In this example, we have a parent class Teacher and a child class MathTeacher. In the MathTeacher
   class we need not to write the same code which is already present in the present class. Here we have
   college name, designation and does() method that is common for all the teachers, thus MathTeacher
   class does not need to write this code, the common data members and methods can inherited from the
   Teacher class.
class Teacher {
   String designation = "Teacher";
   String college = "Beginnersbook";
   void does(){
        System.out.println("Teaching");
   }
}
public class MathTeacher extends Teacher{
   String mainSubject = "Maths";
   public static void main(String args[]){
      MathTeacher obj = new MathTeacher();
      System.out.println(obj.college);
      System.out.println(obj.designation);
      System.out.println(obj.mainSubject);
      obj.does();
   }
}

   Output:
Beginnersbook
Teacher
Maths
Teaching

   Note: Multi-level inheritance is allowed in Java but not multiple inheritance
   multilevel and multiple inheritance diagram representation, Object oriented programming concepts

   Types of Inheritance:
   Single Inheritance: refers to a child and parent class relationship where a class extends the another
   class.

   Multilevel inheritance: refers to a child and parent class relationship where a class extends the
   child class. For example class A extends class B and class B extends class C.

   Hierarchical inheritance: refers to a child and parent class relationship where more than one classes
   extends the same class. For example, class B extends class A and class C extends class A.

   Multiple Inheritance: refers to the concept of one class extending more than one classes, which means
   a child class has two parent classes. Java doesn’t support multiple inheritance, read more about it
   here.

     Most of the new OO languages like Small Talk, Java, C# do not support Multiple inheritance.
     Multiple Inheritance is supported in C++.

Polymorphism
   Polymorphism is a object oriented programming feature that allows us to perform a single action
   in different ways. For example, lets say we have a class Animal that has a method animalSound(), here
   we cannot give implementation to this method as we do not know which Animal class would extend Animal
   class. So, we make this method abstract like this:
public abstract class Animal{
   ...
   public abstract void animalSound();
}

   Now suppose we have two Animal classes Dog and Lion that extends Animal class. We can provide the
   implementation detail there.
public class Lion extends Animal{
...
    @Override
    public void animalSound(){
        System.out.println("Roar");
    }
}

   and
public class Dog extends Animal{
...
    @Override
    public void animalSound(){
        System.out.println("Woof");
    }
}

   As you can see that although we had the common action for all subclasses animalSound() but there were
   different ways to do the same action. This is a perfect example of polymorphism (feature that allows
   us to perform a single action in different ways).

   Types of Polymorphism
   1) Static Polymorphism
   2) Dynamic Polymorphism

Static Polymorphism:

   Polymorphism that is resolved during compiler time is known as static polymorphism. Method
   overloading can be considered as static polymorphism example.
   Method Overloading: This allows us to have more than one methods with same name in a class that
   differs in signature.
class DisplayOverloading
{
    public void disp(char c)
    {
         System.out.println(c);
    }
    public void disp(char c, int num)
    {
         System.out.println(c + " "+num);
    }
}
public class ExampleOverloading
{
   public static void main(String args[])
   {
       DisplayOverloading obj = new DisplayOverloading();
       obj.disp('a');
       obj.disp('a',10);
   }
}

   Output:
a
a 10

     When I say method signature I am not talking about return type of the method, for example if two
     methods have same name, same parameters and have different return type, then this is not a valid
     method overloading example. This will throw compilation error.

Dynamic Polymorphism
   It is also known as Dynamic Method Dispatch. Dynamic polymorphism is a process in which a call to an
   overridden method is resolved at runtime rather, thats why it is called runtime polymorphism.

   Example
class Animal{
   public void animalSound(){
        System.out.println("Default Sound");
   }
}
public class Dog extends Animal{

   public void animalSound(){
        System.out.println("Woof");
   }
   public static void main(String args[]){
        Animal obj = new Dog();
        obj.animalSound();
   }
}

   Output:
Woof

   Since both the classes, child class and parent class have the same method animalSound. Which of the
   method will be called is determined at runtime by JVM.

   Few more overriding examples:
Animal obj = new Animal();
obj.animalSound();
// This would call the Animal class method

Dog obj = new Dog();
obj.animalSound();
// This would call the Dog class method

Animal obj = new Dog();
obj.animalSound();
// This would call the Dog class method

IS-A & HAS-A Relationships
   A Car IS-A Vehicle and HAS-A License then the code would look like this:
public class Vehicle{ }
public class Car extends Vehicle{
   private License myCarLicense;
}

Abstract Class and methods in OOPs Concepts

   Abstract method:
   1) A method that is declared but not defined. Only method signature no body.
   2) Declared using the abstract keyword
   3) Example :
abstract public void playInstrument();

   5) Used to put some kind of compulsion on the class who inherits the class has abstract methods. The
   class that inherits must provide the implementation of all the abstract methods of parent class else
   declare the subclass as abstract.
   6) These cannot be abstract
     * Constructors
     * Static methods
     * Private methods
     * Methods that are declared “final”

   Abstract Class
   An abstract class outlines the methods but not necessarily implements all the methods.
abstract class A{
   abstract void myMethod();
   void anotherMethod(){
      //Does something
   }
}

   Note 1: There can be some scenarios where it is difficult to implement all the methods in the base
   class. In such scenarios one can define the base class as an abstract class which signifies that this
   base class is a special kind of class which is not complete on its own.

   A class derived from the abstract base class must implement those methods that are not
   implemented(means they are abstract) in the abstract class.

   Note 2: Abstract class cannot be instantiated which means you cannot create the object of abstract
   class. To use this class, you need to create another class that extends this abstract class provides
   the implementation of abstract methods, then you can use the object of that child class to call
   non-abstract parent class methods as well as implemented methods(those that were abstract in parent
   but implemented in child class).

   Note 3: If a child does not implement all the abstract methods of parent class(the abstract class),
   then the child class must need to be declared abstract.

Example of Abstract class and Methods
   Here we have an abstract class Animal that has an abstract method animalSound(), since the animal
   sound differs from one animal to another, there is no point in giving the implementation to this
   method as every child class must override this method to give its own implementation details. That’s
   why we made it abstract.
   Now each animal must have a sound, by making this method abstract we made it compulsory to the child
   class to give implementation details to this method. This way we ensures that every animal has a
   sound.
//abstract class
abstract class Animal{
   //abstract method
   public abstract void animalSound();
}
public class Dog extends Animal{

   public void animalSound(){
        System.out.println("Woof");
   }
   public static void main(String args[]){
        Animal obj = new Dog();
        obj.animalSound();
   }
}

   Output:
Woof

Interfaces in Java
   An interface is a blueprint of a class, which can be declared by using interface keyword. Interfaces
   can contain only constants and abstract methods (methods with only signatures no body).Like abstract
   classes, Interfaces cannot be instantiated, they can only be implemented by classes or extended by
   other interfaces. Interface is a common way to achieve full abstraction in Java.

   Note:
    1. Java does not support Multiple Inheritance, however a class can implement more than one
       interfaces
    2. Interface is similar to an abstract class but it contains only abstract methods.
    3. Interfaces are created by using interface keyword instead of the keyword class
    4. We use implements keyword while implementing an interface(similar to extending a class with
       extends keyword)

   Interface: Syntax
class ClassName extends Superclass implements Interface1, Interface2, ....

Example of Interface:

   Interface example diagram

   Note:
    1. All methods in an interface are implicitly public and abstract. Using the keyword abstract before
       each method is optional.
    2. An interface may contain final variables.
    3. A class can extend only one other class, but it can implement any number of interfaces.
    4. When a class implements an interface it has to give the definition of all the abstract methods of
       interface, else it can be declared as abstract class
    5. An interface reference can point to objects of its implementing classes.

   Generalization and Specialization:
   In order to implement the concept of inheritance in an OOPs, one has to first identify the
   similarities among different classes so as to come up with the base class.

   This process of identifying the similarities among different classes is called Generalization.
   Generalization is the process of extracting shared characteristics from two or more classes, and
   combining them into a generalized superclass. Shared characteristics can be attributes or methods.

   In contrast to generalization, specialization means creating new subclasses from an existing class.
   If it turns out that certain attributes or methods only apply to some of the objects of the class, a
   subclass can be created.

Access Specifiers
   Well, you must have seen public, private keyword in the examples I have shared above. They are called
   access specifiers as they decide the scope of a data member, method or class.

   There are four types of access specifiers in java:
   public: Accessible to all. Other objects can also access this member variable or function.
   private: Not accessible by other objects. Private members can be accessed only by the methods in the
   same class. Object accessible only in class in which they are declared.
   protected: The scope of a protected variable is within the class which declares it and in the class
   which inherits from the class (Scope is class and subclass).
   Default: Scope is Package Level. We do not need to explicitly mention default as when we do not
   mention any access specifier it is considered as default.

What will we learn in the next tutorials on OOPs Concepts
   Although we have covered almost all the OOPs concepts here, but whatever we have learned in this
   guide is in brief, these topics are wide and there is so much scope to learn these topics in detail
   with the help of examples. Thats why I have covered each and every topic in detail along with
   examples and diagrams in the next tutorials.
   How can you read the next tutorials in a sequential manner? There are couple of ways to do it – 1)
   Tutorial links are provided in the left sidebar, go though them in the given sequence.
   2) Go to the main java tutorial page that has all the links to the tutorials in the sequential
   manner.
   If you find any difficulty understanding these OOPs Concepts then drop a comment below and I will get
   back to you as soon as possible.


---
https://beginnersbook.com/2013/03/constructors-in-java/

Constructors in Java – A complete study!!

   Constructor is a block of code that initializes the newly created object. A constructor resembles an
   instance method in java but it’s not a method as it doesn’t have a return type. In short constructor
   and method are different(More on this at the end of this guide). People often refer constructor as
   special type of method in Java.

   Constructor has same name as the class and looks like this in a java code.
public class MyClass{
   //This is the constructor
   MyClass(){
   }
   ..
}

     Note that the constructor name matches with the class name and it doesn’t have a return type.

How does a constructor work

   To understand the working of constructor, lets take an example. lets say we have a class MyClass.
   When we create the object of MyClass like this:
MyClass obj = new MyClass()

   The new keyword here creates the object of class MyClass and invokes the constructor to initialize
   this newly created object.

   You may get a little lost here as I have not shown you any initialization example, lets have a look
   at the code below:

A simple constructor program in java
   Here we have created an object obj of class Hello and then we displayed the instance variable name of
   the object. As you can see that the output is BeginnersBook.com which is what we have passed to the
   name during initialization in constructor. This shows that when we created the object obj the
   constructor got invoked. In this example we have used this keyword, which refers to the current
   object, object obj in this example. We will cover this keyword in detail in the next tutorial.
public class Hello {
   String name;
   //Constructor
   Hello(){
      this.name = "BeginnersBook.com";
   }
   public static void main(String[] args) {
      Hello obj = new Hello();
      System.out.println(obj.name);
   }
}

   Output:
BeginnersBook.com

   new keyword invoked the constructor

Types of Constructors
   There are three types of constructors: Default, No-arg constructor and Parameterized.
   types of constructor

Default constructor
   If you do not implement any constructor in your class, Java compiler inserts a default
   constructor into your code on your behalf. This constructor is known as default constructor. You
   would not find it in your source code(the java file) as it would be inserted into the code during
   compilation and exists in .class file. This process is shown in the diagram below:
   default constructor

     If you implement any constructor then you no longer receive a default constructor from Java
     compiler.

no-arg constructor:
   Constructor with no arguments is known as no-arg constructor. The signature is same as default
   constructor, however body can have any code unlike default constructor where the body of the
   constructor is empty.

     Although you may see some people claim that that default and no-arg constructor is same but in
     fact they are not, even if you write public Demo() { } in your class Demo it cannot be called
     default constructor since you have written the code of it.

Example: no-arg constructor

class Demo
{
     public Demo()
     {
         System.out.println("This is a no argument constructor");
     }
     public static void main(String args[]) {
         new Demo();
     }
}

   Output:
   This is a no argument constructor

Parameterized constructor
   Constructor with arguments(or you can say parameters) is known as Parameterized constructor.

Example: parameterized constructor

   In this example we have a parameterized constructor with two parameters id and name. While creating
   the objects obj1 and obj2 I have passed two arguments so that this constructor gets invoked after
   creation of obj1 and obj2.
public class Employee {

   int empId;
   String empName;

   //parameterized constructor with two parameters
   Employee(int id, String name){
       this.empId = id;
       this.empName = name;
   }
   void info(){
        System.out.println("Id: "+empId+" Name: "+empName);
   }

   public static void main(String args[]){
        Employee obj1 = new Employee(10245,"Chaitanya");
        Employee obj2 = new Employee(92232,"Negan");
        obj1.info();
        obj2.info();
   }
}

   Output:
Id: 10245 Name: Chaitanya
Id: 92232 Name: Negan

Example2: parameterized constructor

   In this example, we have two constructors, a default constructor and a parameterized constructor.
   When we do not pass any parameter while creating the object using new keyword then default
   constructor is invoked, however when you pass a parameter then parameterized constructor that matches
   with the passed parameters list gets invoked.
class Example2
{
      private int var;
      //default constructor
      public Example2()
      {
             this.var = 10;
      }
      //parameterized constructor
      public Example2(int num)
      {
             this.var = num;
      }
      public int getValue()
      {
              return var;
      }
      public static void main(String args[])
      {
              Example2 obj = new Example2();
              Example2 obj2 = new Example2(100);
              System.out.println("var is: "+obj.getValue());
              System.out.println("var is: "+obj2.getValue());
      }
}


   Output:
var is: 10
var is: 100

What if you implement only parameterized constructor in class

class Example3
{
      private int var;
      public Example3(int num)
      {
             var=num;
      }
      public int getValue()
      {
              return var;
      }
      public static void main(String args[])
      {
              Example3 myobj = new Example3();
              System.out.println("value of var is: "+myobj.getValue());
      }
}

   Output: It will throw a compilation error. The reason is, the statement Example3 myobj = new
   Example3() is invoking a default constructor which we don’t have in our program. when you don’t
   implement any constructor in your class, compiler inserts the default constructor into your code,
   however when you implement any constructor (in above example I have implemented parameterized
   constructor with int parameter), then you don’t receive the default constructor by compiler into your
   code.

   If we remove the parameterized constructor from the above code then the program would run fine,
   because then compiler would insert the default constructor into your code.

Constructor Chaining
   When A constructor calls another constructor of same class then this is called constructor chaining.

Super()
   Whenever a child class constructor gets invoked it implicitly invokes the constructor of parent
   class. You can also say that the compiler inserts a super(); statement at the beginning of child
   class constructor.
class MyParentClass {
   MyParentClass(){
        System.out.println("MyParentClass Constructor");
   }
}
class MyChildClass extends MyParentClass{
   MyChildClass() {
        System.out.println("MyChildClass Constructor");
   }
   public static void main(String args[]) {
        new MyChildClass();
   }
}

   Output:
MyParentClass Constructor
MyChildClass Constructor

Constructor Overloading
   Constructor overloading is a concept of having more than one constructor with different parameters
   list, in such a way so that each constructor performs a different task.
   constructor overloading

Java Copy Constructor
   A copy constructor is used for copying the values of one object to another object.
class JavaExample{
   String web;
   JavaExample(String w){
        web = w;
   }

   /* This is the Copy Constructor, it
    * copies the values of one object
    * to the another object (the object
    * that invokes this constructor)
    */
   JavaExample(JavaExample je){
        web = je.web;
   }
   void disp(){
        System.out.println("Website: "+web);
   }

   public static void main(String args[]){
        JavaExample obj1 = new JavaExample("BeginnersBook");

        /* Passing the object as an argument to the constructor
         * This will invoke the copy constructor
         */
        JavaExample obj2 = new JavaExample(obj1);
        obj1.disp();
        obj2.disp();
   }
}

   Output:
Website: BeginnersBook
Website: BeginnersBook

Quick Recap

    1. Every class has a constructor whether it’s a normal class or a abstract class.
    2. Constructors are not methods and they don’t have any return type.
    3. Constructor name should match with class name .
    4. Constructor can use any access specifier, they can be declared as private also. Private
       constructors are possible in java but there scope is within the class only.
    5. Like constructors method can also have name same as class name, but still they have return type,
       though which we can identify them that they are methods not constructors.
    6. If you don’t implement any constructor within the class, compiler will do it for.
    7. this() and super() should be the first statement in the constructor code. If you don’t mention
       them, compiler does it for you accordingly.
    8. Constructor overloading is possible but overriding is not possible. Which means we can have
       overloaded constructor in our class but we can’t override a constructor.
    9. Constructors can not be inherited.
   10. If Super class doesn’t have a no-arg(default) constructor then compiler would not insert a
       default constructor in child class as it does in normal scenario.
   11. Interfaces do not have constructors.
   12. Abstract class can have constructor and it gets invoked when a class, which implements
       interface, is instantiated. (i.e. object creation of concrete class).
   13. A constructor can also invoke another constructor of the same class – By using this(). If you
       want to invoke a parameterized constructor then do it like this: this(parameter list).

Difference between Constructor and Method
   I know I should have mentioned it at the beginning of this guide but I wanted to cover everything in
   a flow. Hope you don’t mind :)
    1. The purpose of constructor is to initialize the object of a class while the purpose of a method
       is to perform a task by executing java code.
    2. Constructors cannot be abstract, final, static and synchronised while methods can be.
    3. Constructors do not have return types while methods do.


---
https://beginnersbook.com/2013/04/java-static-class-block-methods-variables/

Java – Static Class, Block, Methods and Variables

   Static keyword can be used with class, variable, method and block. Static members belong to the class
   instead of a specific instance, this means if you make a member static, you can access it without
   object. Let’s take an example to understand this:

   Here we have a static method myMethod(), we can call this method without any object because when we
   make a member static it becomes class level. If we remove the static keyword and make it non-static
   then we must need to create an object of the class in order to call it.

     Static members are common for all the instances(objects) of the class but non-static members are
     separate for each instance of class.

class SimpleStaticExample
{
    // This is a static method
    static void myMethod()
    {
        System.out.println("myMethod");
    }

    public static void main(String[] args)
    {
          /* You can see that we are calling this
           * method without creating any object.
           */
           myMethod();
    }
}

   Output:

myMethod

Static Block
   Static block is used for initializing the static variables.This block gets executed when the class is
   loaded in the memory. A class can have multiple Static blocks, which will execute in the same
   sequence in which they have been written into the program.

Example 1: Single static block

   As you can see that both the static variables were intialized before we accessed them in the main
   method.
class JavaExample{
   static int num;
   static String mystr;
   static{
      num = 97;
      mystr = "Static keyword in Java";
   }
   public static void main(String args[])
   {
      System.out.println("Value of num: "+num);
      System.out.println("Value of mystr: "+mystr);
   }
}

   Output:
Value of num: 97
Value of mystr: Static keyword in Java

Example 2: Multiple Static blocks

   Lets see how multiple static blocks work in Java. They execute in the given order which means the
   first static block executes before second static block. That’s the reason, values initialized by
   first block are overwritten by second block.
class JavaExample2{
   static int num;
   static String mystr;
   //First Static block
   static{
      System.out.println("Static Block 1");
      num = 68;
      mystr = "Block1";
  }
  //Second static block
  static{
      System.out.println("Static Block 2");
      num = 98;
      mystr = "Block2";
  }
  public static void main(String args[])
  {
      System.out.println("Value of num: "+num);
      System.out.println("Value of mystr: "+mystr);
   }
}

   Output:
Static Block 1
Static Block 2
Value of num: 98
Value of mystr: Block2

Java Static Variables
   A static variable is common to all the instances (or objects) of the class because it is a class
   level variable. In other words you can say that only a single copy of static variable is created and
   shared among all the instances of the class. Memory allocation for such variables only happens once
   when the class is loaded in the memory.
   Few Important Points:
     * Static variables are also known as Class Variables.
     * Unlike non-static variables, such variables can be accessed directly in static and non-static
       methods.

Example 1: Static variables can be accessed directly in Static method

   Here we have a static method disp() and two static variables var1 and var2. Both the variables are
   accessed directly in the static method.
class JavaExample3{
  static int var1;
  static String var2;
  //This is a Static Method
  static void disp(){
      System.out.println("Var1 is: "+var1);
      System.out.println("Var2 is: "+var2);
  }
  public static void main(String args[])
  {
      disp();
  }
}

   Output:
Var1 is: 0
Var2 is: null

Example 2: Static variables are shared among all the instances of class

   In this example, String variable is non-static and integer variable is Static. As you can see in the
   output that the non-static variable is different for both the objects but the static variable is
   shared among them, thats the reason the changes made to the static variable by object ob2 reflects in
   both the objects.
class JavaExample{
   //Static integer variable
   static int var1=77;
   //non-static string variable
   String var2;

   public static void main(String args[])
   {
        JavaExample ob1 = new JavaExample();
        JavaExample ob2 = new JavaExample();
        /* static variables can be accessed directly without
         * any instances. Just to demonstrate that static variables
         * are shared, I am accessing them using objects so that
         * we can check that the changes made to static variables
         * by one object, reflects when we access them using other
         * objects
         */
        //Assigning the value to static variable using object ob1
        ob1.var1=88;
        ob1.var2="I'm Object1";
        /* This will overwrite the value of var1 because var1 has a single
         * copy shared among both the objects.
         */
        ob2.var1=99;
        ob2.var2="I'm Object2";
        System.out.println("ob1 integer:"+ob1.var1);
        System.out.println("ob1 String:"+ob1.var2);
        System.out.println("ob2 integer:"+ob2.var1);
        System.out.println("ob2 STring:"+ob2.var2);
   }
}

   Output:
ob1 integer:99
ob1 String:I'm Object1
ob2 integer:99
ob2 STring:I'm Object2


Java Static Methods
   Static Methods can access class variables(static variables) without using object(instance) of the
   class, however non-static methods and non-static variables can only be accessed using objects.
   Static methods can be accessed directly in static and non-static methods.
   Syntax:
   Static keyword followed by return type, followed by method name.
static return_type method_name();

Example 1: static method main is accessing static variables without object

class JavaExample{
   static int i = 10;
   static String s = "Beginnersbook";
   //This is a static method
   public static void main(String args[])
   {
       System.out.println("i:"+i);
       System.out.println("s:"+s);
   }
}

   Output:
i:10
s:Beginnersbook

Example 2: Static method accessed directly in static and non-static method

class JavaExample{
  static int i = 100;
  static String s = "Beginnersbook";
  //Static method
  static void display()
  {
     System.out.println("i:"+i);
     System.out.println("i:"+s);
  }

  //non-static method
  void funcn()
  {
      //Static method called in non-static method
      display();
  }
  //static method
  public static void main(String args[])
  {
          JavaExample obj = new JavaExample();
          //You need to have object to call this non-static method
          obj.funcn();

      //Static method called in another static method
      display();
   }
}

   Output:
i:100
i:Beginnersbook
i:100
i:Beginnersbook

Static Class
   A class can be made static only if it is a nested class.
    1. Nested static class doesn’t need reference of Outer class
    2. A static class cannot access non-static members of the Outer class

   We will see these two points with the help of an example:

Static class Example

class JavaExample{
   private static String str = "BeginnersBook";

   //Static class
   static class MyNestedClass{
        //non-static method
        public void disp() {

           /* If you make the str variable of outer class
            * non-static then you will get compilation error
            * because: a nested static class cannot access non-
            * static members of the outer class.
            */
           System.out.println(str);
        }

   }
   public static void main(String args[])
   {
       /* To create instance of nested class we didn't need the outer
        * class instance but for a regular nested class you would need
        * to create an instance of outer class first
        */
        JavaExample.MyNestedClass obj = new JavaExample.MyNestedClass();
        obj.disp();
   }
}

   Output:
BeginnersBook


---
https://beginnersbook.com/2013/03/inheritance-in-java/

Inheritance in Java Programming with examples

   The process by which one class acquires the properties(data members) and functionalities(methods) of
   another class is called inheritance. The aim of inheritance is to provide the reusability of code so
   that a class has to write only the unique features and rest of the common properties and
   functionalities can be extended from the another class.
   Child Class:
   The class that extends the features of another class is known as child class, sub class or derived
   class.

   Parent Class:
   The class whose properties and functionalities are used(inherited) by another class is known as
   parent class, super class or Base class.

     Inheritance is a process of defining a new class based on an existing class by extending its
     common data members and methods.
     Inheritance allows us to reuse of code, it improves reusability in your java application.
     Note: The biggest advantage of Inheritance is that the code that is already present in base class
     need not be rewritten in the child class.

   This means that the data members(instance variables) and methods of the parent class can be used in
   the child class as.

     If you are finding it difficult to understand what is class and object then refer the guide that I
     have shared on object oriented programming: OOPs Concepts

   Lets back to the topic:

Syntax: Inheritance in Java
   To inherit a class we use extends keyword. Here class XYZ is child class and class ABC is parent
   class. The class XYZ is inheriting the properties and methods of ABC class.
class XYZ extends ABC
{
}

Inheritance Example

   In this example, we have a base class Teacher and a sub class PhysicsTeacher. Since class
   PhysicsTeacher extends the designation and college properties and work() method from base class, we
   need not to declare these properties and method in sub class.
   Here we have collegeName, designation and work() method which are common to all the teachers so we
   have declared them in the base class, this way the child classes like MathTeacher, MusicTeacher and
   PhysicsTeacher do not need to write this code and can be used directly from base class.
class Teacher {
   String designation = "Teacher";
   String collegeName = "Beginnersbook";
   void does(){
        System.out.println("Teaching");
   }
}

public class PhysicsTeacher extends Teacher{
   String mainSubject = "Physics";
   public static void main(String args[]){
        PhysicsTeacher obj = new PhysicsTeacher();
        System.out.println(obj.collegeName);
        System.out.println(obj.designation);
        System.out.println(obj.mainSubject);
        obj.does();
   }
}

   Output:
Beginnersbook
Teacher
Physics
Teaching

     Based on the above example we can say that PhysicsTeacher IS-A Teacher. This means that a child
     class has IS-A relationship with the parent class. This is inheritance is known as IS-A
     relationship between child and parent class

   Note:
   The derived class inherits all the members and methods that are declared as public or protected. If
   the members or methods of super class are declared as private then the derived class cannot use them
   directly. The private members can be accessed only in its own class. Such private members can only be
   accessed using public or protected getter and setter methods of super class as shown in the example
   below.
class Teacher {
   private String designation = "Teacher";
   private String collegeName = "Beginnersbook";
   public String getDesignation() {
        return designation;
   }
   protected void setDesignation(String designation) {
        this.designation = designation;
   }
   protected String getCollegeName() {
        return collegeName;
   }
   protected void setCollegeName(String collegeName) {
        this.collegeName = collegeName;
   }
   void does(){
        System.out.println("Teaching");
   }
}

public class JavaExample extends Teacher{
   String mainSubject = "Physics";
   public static void main(String args[]){
        JavaExample obj = new JavaExample();
        /* Note: we are not accessing the data members
         * directly we are using public getter method
         * to access the private members of parent class
         */
        System.out.println(obj.getCollegeName());
        System.out.println(obj.getDesignation());
        System.out.println(obj.mainSubject);
        obj.does();
   }
}

   The output is:
Beginnersbook
Teacher
Physics
Teaching

   The important point to note in the above example is that the child class is able to access the
   private members of parent class through protected methods of parent class. When we make a instance
   variable(data member) or method protected, this means that they are accessible only in the class
   itself and in child class. These public, protected, private etc. are all access specifiers and we
   will discuss them in the coming tutorials.

Types of inheritance
   To learn types of inheritance in detail, refer: Types of Inheritance in Java.
   Single Inheritance: refers to a child and parent class relationship where a class extends the another
   class.

   Multilevel inheritance: refers to a child and parent class relationship where a class extends the
   child class. For example class C extends class B and class B extends class A.

   Hierarchical inheritance: refers to a child and parent class relationship where more than one
   classes extends the same class. For example, classes B, C & D extends the same class A.

   Multiple Inheritance: refers to the concept of one class extending more than one classes, which means
   a child class has two parent classes. For example class C extends both classes A and B. Java doesn’t
   support multiple inheritance.

   Hybrid inheritance: Combination of more than one types of inheritance in a single program. For
   example class A & B extends class C and another class D extends class A then this is a hybrid
   inheritance example because it is a combination of single and hierarchical inheritance.

Constructors and Inheritance
   Constructor of sub class is invoked when we create the object of subclass, it by default invokes
   the default constructor of super class. Hence, in inheritance the objects are constructed top-down.
   The superclass constructor can be called explicitly using the super keyword, but it should be
   first statement in a constructor. The super keyword refers to the superclass, immediately above of
   the calling class in the hierarchy. The use of multiple super keywords to access an ancestor class
   other than the direct parent is not permitted.
class ParentClass{
   //Parent class constructor
   ParentClass(){
        System.out.println("Constructor of Parent");
   }
}
class JavaExample extends ParentClass{
   JavaExample(){
        /* It by default invokes the constructor of parent class
         * You can use super() to call the constructor of parent.
         * It should be the first statement in the child class
         * constructor, you can also call the parameterized constructor
         * of parent class by using super like this: super(10), now
         * this will invoke the parameterized constructor of int arg
         */
        System.out.println("Constructor of Child");
   }
   public static void main(String args[]){
        //Creating the object of child class
        new JavaExample();
   }
}

   Output:
Constructor of Parent
Constructor of Child

Inheritance and Method Overriding
   When we declare the same method in child class which is already present in the parent class the this
   is called method overriding. In this case when we call the method from child class object, the
   child class version of the method is called. However we can call the parent class method using super
   keyword as I have shown in the example below:
class ParentClass{
   //Parent class constructor
   ParentClass(){
        System.out.println("Constructor of Parent");
   }
   void disp(){
        System.out.println("Parent Method");
   }
}
class JavaExample extends ParentClass{
   JavaExample(){
        System.out.println("Constructor of Child");
   }
   void disp(){
        System.out.println("Child Method");
        //Calling the disp() method of parent class
        super.disp();
   }
   public static void main(String args[]){
        //Creating the object of child class
        JavaExample obj = new JavaExample();
        obj.disp();
   }
}

   The output is :
Constructor of Parent
Constructor of Child
Child Method
Parent Method


---
https://beginnersbook.com/2013/05/java-inheritance-types/

Types of inheritance in Java: Single,Multiple,Multilevel & Hybrid

   Below are Various types of inheritance in Java. We will see each one of them one by one with the help
   of examples and flow diagrams.

1) Single Inheritance
   Single inheritance is damn easy to understand. When a class extends another one class only then we
   call it a single inheritance. The below flow diagram shows that class B extends only one class which
   is A. Here A is a parent class of B and B would be  a child class of A.

Single Inheritance

   Single Inheritance example program in Java
Class A
{
   public void methodA()
   {
     System.out.println("Base class method");
   }
}

Class B extends A
{
   public void methodB()
   {
     System.out.println("Child class method");
   }
   public static void main(String args[])
   {
     B obj = new B();
     obj.methodA(); //calling super class method
     obj.methodB(); //calling local method
  }
}

2) Multiple Inheritance
   “Multiple Inheritance” refers to the concept of one class extending (Or inherits) more than one base
   class. The inheritance we learnt earlier had the concept of one base class or parent. The problem
   with “multiple inheritance” is that the derived class will have to manage the dependency on two base
   classes.
   [INS: :INS]

   Multiple-Inheritance

   Note 1: Multiple Inheritance is very rarely used in software projects. Using Multiple inheritance
   often leads to problems in the hierarchy. This results in unwanted complexity when further extending
   the class.

   Note 2: Most of the new OO languages like Small Talk, Java, C# do not support Multiple inheritance.
   Multiple Inheritance is supported in C++.

3) Multilevel Inheritance
   Multilevel inheritance refers to a mechanism in OO technology where one can inherit from a derived
   class, thereby making this derived class the base class for the new class. As you can see in below
   flow diagram C is subclass or child class of B and B is a child class of A. For more details and
   example refer – Multilevel inheritance in Java.

   Multilevel-Inheritance

   Multilevel Inheritance example program in Java
Class X
{
   public void methodX()
   {
     System.out.println("Class X method");
   }
}
Class Y extends X
{
public void methodY()
{
System.out.println("class Y method");
}
}
Class Z extends Y
{
   public void methodZ()
   {
     System.out.println("class Z method");
   }
   public static void main(String args[])
   {
     Z obj = new Z();
     obj.methodX(); //calling grand parent class method
     obj.methodY(); //calling parent class method
     obj.methodZ(); //calling local method
  }
}

4) Hierarchical Inheritance
   In such kind of inheritance one class is inherited by many sub classes. In below example class B,C
   and D inherits the same class A. A is parent class (or base class) of B,C & D. Read More at
   – Hierarchical Inheritance in java with example program.

5) Hybrid Inheritance
   In simple terms you can say that Hybrid inheritance is a combination of Single and Multiple
   inheritance. A typical flow diagram would look like below. A hybrid inheritance can be achieved in
   the java in a same way as multiple inheritance can be!! Using interfaces. yes you heard it right. By
   using interfaces you can have multiple as well as hybrid inheritance in Java.


---
https://beginnersbook.com/2013/05/aggregation/

OOPs concepts – What is Aggregation in java?

   Aggregation is a special form of association. It is a relationship between two classes like
   association, however its a directional association, which means it is strictly a one way
   association. It represents a HAS-A relationship.

Aggregation Example in Java
   For example consider two classes Student class and Address class. Every student has an address so the
   relationship between student and address is a Has-A relationship. But if you consider its vice
   versa then it would not make any sense as an Address doesn’t need to have a Student necessarily. Lets
   write this example in a java program.
   Student Has-A Address
class Address
{
   int streetNum;
   String city;
   String state;
   String country;
   Address(int street, String c, String st, String coun)
   {
       this.streetNum=street;
       this.city =c;
       this.state = st;
       this.country = coun;
   }
}
class StudentClass
{
   int rollNum;
   String studentName;
   //Creating HAS-A relationship with Address class
   Address studentAddr;
   StudentClass(int roll, String name, Address addr){
       this.rollNum=roll;
       this.studentName=name;
       this.studentAddr = addr;
   }
   public static void main(String args[]){
       Address ad = new Address(55, "Agra", "UP", "India");
       StudentClass obj = new StudentClass(123, "Chaitanya", ad);
       System.out.println(obj.rollNum);
       System.out.println(obj.studentName);
       System.out.println(obj.studentAddr.streetNum);
       System.out.println(obj.studentAddr.city);
       System.out.println(obj.studentAddr.state);
       System.out.println(obj.studentAddr.country);
   }
}

   Output:
123
Chaitanya
55
Agra
UP
India

   The above example shows the Aggregation between Student and Address classes. You can see that in
   Student class I have declared a property of type Address to obtain student address. Its
   a typical example of Aggregation in Java.

Why we need Aggregation?
   To maintain code re-usability. To understand this lets take the same example again. Suppose there are
   two other classes College and Staff along with above two classes Student and Address. In order to
   maintain Student’s address, College Address and Staff’s address we don’t need to use the same code
   again and again. We just have to use the reference of Address class while defining each of these
   classes like:
Student Has-A Address (Has-a relationship between student and address)
College Has-A Address (Has-a relationship between college and address)
Staff Has-A Address (Has-a relationship between staff and address)

   Hence we can improve code re-usability by using Aggregation relationship.

   So if I have to write this in a program, I would do it like this:
class Address
{
   int streetNum;
   String city;
   String state;
   String country;
   Address(int street, String c, String st, String coun)
   {
       this.streetNum=street;
       this.city =c;
       this.state = st;
       this.country = coun;
   }
}
class StudentClass
{
   int rollNum;
   String studentName;
   //Creating HAS-A relationship with Address class
   Address studentAddr;
   StudentClass(int roll, String name, Address addr){
       this.rollNum=roll;
       this.studentName=name;
       this.studentAddr = addr;
   }
   ...
}
class College
{
   String collegeName;
   //Creating HAS-A relationship with Address class
   Address collegeAddr;
   College(String name, Address addr){
       this.collegeName = name;
       this.collegeAddr = addr;
   }
   ...
}
class Staff
{
   String employeeName;
   //Creating HAS-A relationship with Address class
   Address employeeAddr;
   Staff(String name, Address addr){
       this.employeeName = name;
       this.employeeAddr = addr;
   }
   ...
}

   As you can see that we didn’t write the Address code in any of the three classes, we simply created
   the HAS-A relationship with the Address class to use the Address code. The dot dot(…) part in the
   above code can be replaced with the public static void main method, the code in it would be similar
   to what we have seen in the first example.


---
https://beginnersbook.com/2013/05/association/

OOPs concepts – What is Association in java?

   In this article we will discuss Association in Java. Association establishes relationship between two
   separate classes through their objects. The relationship can be one to one, One to many, many to one
   and many to many.

Association Example

class CarClass{
   String carName;
   int carId;
   CarClass(String name, int id)
   {
        this.carName = name;
        this.carId = id;
   }
}
class Driver extends CarClass{
   String driverName;
   Driver(String name, String cname, int cid){
        super(cname, cid);
        this.driverName=name;
   }
}
class TransportCompany{
   public static void main(String args[])
   {
        Driver obj = new Driver("Andy", "Ford", 9988);
        System.out.println(obj.driverName+" is a driver of car Id: "+obj.carId);
   }
}

   Output:
Andy is a driver of car Id: 9988

   In the above example, there is a one to one relationship(Association) between two classes: CarClass
   and Driver. Both the classes represent two separate entities.

Association vs Aggregation vs Composition
   Lets discuss difference between Association, Aggregation and Composition:
   
   Although all three are related terms, there are some major differences in the way they relate two
   classes. Association is a relationship between two separate classes and the association can be of any
   type say one to one, one to may etc. It joins two entirely separate entities.

   Aggregation is a special form of association which is a unidirectional one way relationship
   between classes (or entities), for e.g. Wallet and Money classes. Wallet has Money but money doesn’t
   need to have Wallet necessarily so its a one directional relationship. In this relationship both the
   entries can survive if other one ends. In our example if Wallet class is not present, it does not
   mean that the Money class cannot exist.

   Composition is a restricted form of Aggregation in which two entities (or you can say classes) are
   highly dependent on each other. For e.g. Human and Heart. A human needs heart to live and a heart
   needs a Human body to survive. In other words when the classes (entities) are dependent on each other
   and their life span are same (if one dies then another one too) then its a composition. Heart class
   has no sense if Human class is not present.


---
https://beginnersbook.com/2014/07/super-keyword-in-java-with-example/

Super keyword in java with example

   The super keyword refers to the objects of immediate parent class. Before learning super keyword you
   must have the knowledge of inheritance in Java so that you can understand the examples given in
   this guide.

The use of super keyword
   1) To access the data members of parent class when both parent and child class have member with same
   name
   2) To explicitly call the no-arg and parameterized constructor of parent class
   3) To access the method of parent class when child class has overridden that method.

   Now lets discuss them in detail with the help of examples:

1) How to use super keyword to access the variables of parent class
   When you have a variable in child class which is already present in the parent class then in order to
   access the variable of parent class, you need to use the super keyword.
   [INS: :INS]

   Lets take an example to understand this: In the following program, we have a data member num declared
   in the child class, the member with the same name is already present in the parent class. There is no
   way you can access the num variable of parent class without using super keyword. .
//Parent class or Superclass or base class
class Superclass
{
   int num = 100;
}
//Child class or subclass or derived class
class Subclass extends Superclass
{
   /* The same variable num is declared in the Subclass
    * which is already present in the Superclass
    */
    int num = 110;
    void printNumber(){
        System.out.println(num);
    }
    public static void main(String args[]){
        Subclass obj= new Subclass();
        obj.printNumber();
    }
}

   Output:
   110

   Accessing the num variable of parent class:
   By calling a variable like this, we can access the variable of parent class if both the classes
   (parent and child) have same variable.
super.variable_name

   Let’s take the same example that we have seen above, this time in print statement we are passing
   super.num instead of num.
class Superclass
{
   int num = 100;
}
class Subclass extends Superclass
{
   int num = 110;
   void printNumber(){
        /* Note that instead of writing num we are
         * writing super.num in the print statement
         * this refers to the num variable of Superclass
         */
        System.out.println(super.num);
   }
   public static void main(String args[]){
        Subclass obj= new Subclass();
        obj.printNumber();
   }
}

   Output:
   100
   As you can see by using super.num we accessed the num variable of parent class.

2) Use of super keyword to invoke constructor of parent class
   When we create the object of sub class, the new keyword invokes the constructor of child class,
   which implicitly invokes the constructor of parent class. So the order to execution when we create
   the object of child class is: parent class constructor is executed first and then the child class
   constructor is executed. It happens because compiler itself adds super()(this invokes the no-arg
   constructor of parent class) as the first statement in the constructor of child class.

   Let’s see an example to understand what I have explained above:
class Parentclass
{
   Parentclass(){
        System.out.println("Constructor of parent class");
   }
}
class Subclass extends Parentclass
{
   Subclass(){
        /* Compile implicitly adds super() here as the
         *  first statement of this constructor.
         */
        System.out.println("Constructor of child class");
   }
   Subclass(int num){
        /* Even though it is a parameterized constructor.
         * The compiler still adds the no-arg super() here
         */
        System.out.println("arg constructor of child class");
   }
   void display(){
        System.out.println("Hello!");
   }
   public static void main(String args[]){
        /* Creating object using default constructor. This
         * will invoke child class constructor, which will
         * invoke parent class constructor
         */
        Subclass obj= new Subclass();
        //Calling sub class method
        obj.display();
        /* Creating second object using arg constructor
         * it will invoke arg constructor of child class which will
         * invoke no-arg constructor of parent class automatically
         */
        Subclass obj2= new Subclass(10);
        obj2.display();
   }
}

   Output:
Constructor of parent class
Constructor of child class
Hello!
Constructor of parent class
arg constructor of child class
Hello!

Parameterized super() call to invoke parameterized constructor of parent class

   We can call super() explicitly in the constructor of child class, but it would not make any sense
   because it would be redundant. It’s like explicitly doing something which would be implicitly done
   otherwise.
   However when we have a constructor in parent class that takes arguments then we can use parameterized
   super, like super(100); to invoke parameterized constructor of parent class from the constructor
   of child class.
   Let’s see an example to understand this:
class Parentclass
{
   //no-arg constructor
   Parentclass(){
        System.out.println("no-arg constructor of parent class");
   }
   //arg or parameterized constructor
   Parentclass(String str){
        System.out.println("parameterized constructor of parent class");
   }
}
class Subclass extends Parentclass
{
   Subclass(){
       /* super() must be added to the first statement of constructor
        * otherwise you will get a compilation error. Another important
        * point to note is that when we explicitly use super in constructor
        * the compiler doesn't invoke the parent constructor automatically.
        */
        super("Hahaha");
        System.out.println("Constructor of child class");

   }
   void display(){
        System.out.println("Hello");
   }
   public static void main(String args[]){
        Subclass obj= new Subclass();
        obj.display();
   }
}

   Output:
parameterized constructor of parent class
Constructor of child class
Hello

   There are few important points to note in this example:
   1) super()(or parameterized super must be the first statement in constructor otherwise you will get
   the compilation error: “Constructor call must be the first statement in a constructor”
   2) When we explicitly placed super in the constructor, the java compiler didn’t call the default
   no-arg constructor of parent class.

3) How to use super keyword in case of method overriding

   When a child class declares a same method which is already present in the parent class then this is
   called method overriding. We will learn method overriding in the next tutorials of this series.
   For now you just need to remember this: When a child class overrides a method of parent class, then
   the call to the method from child class object always call the child class version of the method.
   However by using super keyword like this: super.method_name you can call the method of parent class
   (the method which is overridden). In case of method overriding, these terminologies are used:
   Overridden method: The method of parent class Overriding method: The method of child class Lets take
   an example to understand this concept:
class Parentclass
{
   //Overridden method
   void display(){
        System.out.println("Parent class method");
   }
}
class Subclass extends Parentclass
{
   //Overriding method
   void display(){
        System.out.println("Child class method");
   }
   void printMsg(){
        //This would call Overriding method
        display();
        //This would call Overridden method
        super.display();
   }
   public static void main(String args[]){
        Subclass obj= new Subclass();
        obj.printMsg();
   }
}

   Output:
Child class method
Parent class method

What if the child class is not overriding any method: No need of super

   When child class doesn’t override the parent class method then we don’t need to use the super keyword
   to call the parent class method. This is because in this case we have only one version of each method
   and child class has access to the parent class methods so we can directly call the methods of parent
   class without using super.
class Parentclass
{
   void display(){
        System.out.println("Parent class method");
   }
}
class Subclass extends Parentclass
{
   void printMsg(){
        /* This would call method of parent class,
         * no need to use super keyword because no other
         * method with the same name is present in this class
         */
        display();
   }
   public static void main(String args[]){

        Subclass obj= new Subclass();
        obj.printMsg();
   }
}

   Output:
Parent class method


---
https://beginnersbook.com/2013/05/method-overloading/

Method Overloading in Java with examples

   Method Overloading is a feature that allows a class to have more than one method having the same
   name, if their argument lists are different. It is similar to constructor overloading in Java,
   that allows a class to have more than one constructor having different argument lists.

   let’s get back to the point, when I say argument list it means the parameters that a method has: For
   example the argument list of a method add(int a, int b) having two parameters is different from the
   argument list of the method add(int a, int b, int c) having three parameters.

Three ways to overload a method
   In order to overload a method, the argument lists of the methods must differ in either of these:
   1. Number of parameters.
   For example: This is a valid case of overloading
add(int, int)
add(int, int, int)

   2. Data type of parameters.
   For example:
   [INS: :INS]
add(int, int)
add(int, float)

   3. Sequence of Data type of parameters.
   For example:
add(int, float)
add(float, int)

   Invalid case of method overloading:
   When I say argument list, I am not talking about return type of the method, for example if two
   methods have same name, same parameters and have different return type, then this is not a valid
   method overloading example. This will throw compilation error.
int add(int, int)
float add(int, int)

   Method overloading is an example of Static Polymorphism. We will discuss polymorphism and
   types of it in a separate tutorial.

   Points to Note:
   1. Static Polymorphism is also known as compile time binding or early binding.
   2. Static binding happens at compile time. Method overloading is an example of static binding
   where binding of method call to its definition happens at Compile time.

Method Overloading examples
   As discussed in the beginning of this guide, method overloading is done by declaring same method with
   different parameters. The parameters must be different in either of these: number, sequence or types
   of parameters (or arguments). Lets see examples of each of these cases.

     Argument list is also known as parameter list

Example 1: Overloading – Different Number of parameters in argument list

   This example shows how method overloading is done by having different number of parameters
class DisplayOverloading
{
    public void disp(char c)
    {
         System.out.println(c);
    }
    public void disp(char c, int num)
    {
         System.out.println(c + " "+num);
    }
}
class Sample
{
   public static void main(String args[])
   {
       DisplayOverloading obj = new DisplayOverloading();
       obj.disp('a');
       obj.disp('a',10);
   }
}

   Output:
a
a 10

   In the above example – method disp() is overloaded based on the number of parameters – We have two
   methods with the name disp but the parameters they have are different. Both are having different
   number of parameters.

Example 2: Overloading – Difference in data type of parameters

   In this example, method disp() is overloaded based on the data type of parameters – We have two
   methods with the name disp(), one with parameter of char type and another method with the parameter
   of int type.
class DisplayOverloading2
{
    public void disp(char c)
    {
        System.out.println(c);
    }
    public void disp(int c)
    {
       System.out.println(c );
    }
}

class Sample2
{
    public static void main(String args[])
    {
        DisplayOverloading2 obj = new DisplayOverloading2();
        obj.disp('a');
        obj.disp(5);
    }
}

   Output:
a
5

Example3: Overloading – Sequence of data type of arguments

   Here method disp() is overloaded based on sequence of data type of parameters – Both the methods have
   different sequence of data type in argument list. First method is having argument list as (char, int)
   and second is having (int, char). Since the sequence is different, the method can be overloaded
   without any issues.
class DisplayOverloading3
{
   public void disp(char c, int num)
   {
       System.out.println("I’m the first definition of method disp");
   }
   public void disp(int num, char c)
   {
       System.out.println("I’m the second definition of method disp" );
   }
}
class Sample3
{
   public static void main(String args[])
   {
       DisplayOverloading3 obj = new DisplayOverloading3();
       obj.disp('x', 51 );
       obj.disp(52, 'y');
   }
}

   Output:
I’m the first definition of method disp
I’m the second definition of method disp

Method Overloading and Type Promotion
   When a data type of smaller size is promoted to the data type of bigger size than this is called type
   promotion, for example: byte data type can be promoted to short, a short data type can be promoted to
   int, long, double etc.

   What it has to do with method overloading?
   Well, it is very important to understand type promotion else you will think that the program will
   throw compilation error but in fact that program will run fine because of type promotion.
   Lets take an example to see what I am talking here:
class Demo{
   void disp(int a, double b){
        System.out.println("Method A");
   }
   void disp(int a, double b, double c){
        System.out.println("Method B");
   }
   public static void main(String args[]){
        Demo obj = new Demo();
        /* I am passing float value as a second argument but
         * it got promoted to the type double, because there
         * wasn't any method having arg list as (int, float)
         */
        obj.disp(100, 20.67f);
   }
}

   Output:
Method A

   As you can see that I have passed the float value while calling the disp() method but it got promoted
   to the double type as there wasn’t any method with argument list as (int, float)

   But this type promotion doesn’t always happen, lets see another example:
class Demo{
   void disp(int a, double b){
        System.out.println("Method A");
   }
   void disp(int a, double b, double c){
        System.out.println("Method B");
   }
   void disp(int a, float b){
        System.out.println("Method C");
   }
   public static void main(String args[]){
        Demo obj = new Demo();
        /* This time promotion won't happen as there is
         * a method with arg list as (int, float)
         */
        obj.disp(100, 20.67f);
   }
}

   Output:
Method C

   As you see that this time type promotion didn’t happen because there was a method with matching
   argument type.
   Type Promotion table:
   The data type on the left side can be promoted to the any of the data type present in the right side
   of it.
byte → short → int → long
short → int → long
int → long → float → double
float → double
long → float → double

Lets see few Valid/invalid cases of method overloading

   Case 1:
int mymethod(int a, int b, float c)
int mymethod(int var1, int var2, float var3)

   Result: Compile time error. Argument lists are exactly same. Both methods are having same number,
   data types and same sequence of data types.

   Case 2:
int mymethod(int a, int b)
int mymethod(float var1, float var2)

   Result: Perfectly fine. Valid case of overloading. Here data types of arguments are different.

   Case 3:
int mymethod(int a, int b)
int mymethod(int num)

   Result: Perfectly fine. Valid case of overloading. Here number of arguments are different.

   Case 4:
float mymethod(int a, float b)
float mymethod(float var1, int var2)

   Result: Perfectly fine. Valid case of overloading. Sequence of the data types of parameters are
   different, first method is having (int, float) and second is having (float, int).

   Case 5:
int mymethod(int a, int b)
float mymethod(int var1, int var2)

   Result: Compile time error. Argument lists are exactly same. Even though return type of methods are
   different, it is not a valid case. Since return type of method doesn’t matter while overloading a
   method.

   Guess the answers before checking it at the end of programs:
   Question 1 – return type, method name and argument list same.
class Demo
{
   public int myMethod(int num1, int num2)
   {
       System.out.println("First myMethod of class Demo");
       return num1+num2;
   }
   public int myMethod(int var1, int var2)
   {
       System.out.println("Second myMethod of class Demo");
       return var1-var2;
   }
}
class Sample4
{
   public static void main(String args[])
   {
       Demo obj1= new Demo();
       obj1.myMethod(10,10);
       obj1.myMethod(20,12);
   }
}

   Answer:
   It will throw a compilation error: More than one method with same name and argument list cannot be
   defined in a same class.

   Question 2 – return type is different. Method name & argument list same.
class Demo2
{
   public double myMethod(int num1, int num2)
   {
      System.out.println("First myMethod of class Demo");
      return num1+num2;
   }
   public int myMethod(int var1, int var2)
   {
      System.out.println("Second myMethod of class Demo");
      return var1-var2;
   }
}
class Sample5
{
   public static void main(String args[])
   {
      Demo2 obj2= new Demo2();
      obj2.myMethod(10,10);
      obj2.myMethod(20,12);
   }
}

   Answer:
   It will throw a compilation error: More than one method with same name and argument list cannot be
   given in a class even though their return type is different. Method return type doesn’t matter in
   case of overloading.


---
https://beginnersbook.com/2014/01/method-overriding-in-java-with-example/

Method overriding in java with example

   Declaring a method in sub class which is already present in parent class is known as method
   overriding. Overriding is done so that a child class can give its own implementation to a method
   which is already provided by the parent class. In this case the method in parent class is called
   overridden method and the method in child class is called overriding method. In this guide, we will
   see what is method overriding in Java and why we use it.

Method Overriding Example
   Lets take a simple example to understand this. We have two classes: A child class Boy and a parent
   class Human. The Boy class extends Human class. Both the classes have a common method void eat(). Boy
   class is giving its own implementation to the eat() method or in other words it is overriding the
   eat() method.

   The purpose of Method Overriding is clear here. Child class wants to give its own implementation so
   that when it calls this method, it prints Boy is eating instead of Human is eating.
class Human{
   //Overridden method
   public void eat()
   {
      System.out.println("Human is eating");
   }
}
class Boy extends Human{
   //Overriding method
   public void eat(){
      System.out.println("Boy is eating");
   }
   public static void main( String args[]) {
      Boy obj = new Boy();
      //This will call the child class version of eat()
      obj.eat();
   }
}

   Output:

Boy is eating

Advantage of method overriding
   The main advantage of method overriding is that the class can give its own specific implementation to
   a inherited method without even modifying the parent class code.

   This is helpful when a class has several child classes, so if a child class needs to use the parent
   class method, it can use it and the other classes that want to have different implementation can use
   overriding feature to make changes without touching the parent class code.

Method Overriding and Dynamic Method Dispatch
   Method Overriding is an example of runtime polymorphism. When a parent class reference points to
   the child class object then the call to the overridden method is determined at runtime, because
   during method call which method(parent class or child class) is to be executed is determined by the
   type of object. This process in which call to the overridden method is resolved at runtime is known
   as dynamic method dispatch. Lets see an example to understand this:
class ABC{
   //Overridden method
   public void disp()
   {
        System.out.println("disp() method of parent class");
   }
}
class Demo extends ABC{
   //Overriding method
   public void disp(){
        System.out.println("disp() method of Child class");
   }
   public void newMethod(){
        System.out.println("new method of child class");
   }
   public static void main( String args[]) {
        /* When Parent class reference refers to the parent class object
         * then in this case overridden method (the method of parent class)
         *  is called.
         */
        ABC obj = new ABC();
        obj.disp();

        /* When parent class reference refers to the child class object
         * then the overriding method (method of child class) is called.
         * This is called dynamic method dispatch and runtime polymorphism
         */
        ABC obj2 = new Demo();
        obj2.disp();
   }
}

   Output:
disp() method of parent class
disp() method of Child class

   In the above example the call to the disp() method using second object (obj2) is runtime polymorphism
   (or dynamic method dispatch).
   Note: In dynamic method dispatch the object can call the overriding methods of child class and all
   the non-overridden methods of base class but it cannot call the methods which are newly declared in
   the child class. In the above example the object obj2 is calling the disp(). However if you try to
   call the newMethod() method (which has been newly declared in Demo class) using obj2 then you would
   give compilation error with the following message:
Exception in thread "main" java.lang.Error: Unresolved compilation
problem: The method xyz() is undefined for the type ABC

Rules of method overriding in Java

    1. Argument list: The argument list of overriding method (method of child class) must match the
       Overridden method(the method of parent class). The data types of the arguments and their sequence
       should exactly match.
    2. Access Modifier of the overriding method (method of subclass) cannot be more restrictive than
       the overridden method of parent class. For e.g. if the Access Modifier of parent class method is
       public then the overriding method (child class method ) cannot have private, protected and
       default Access modifier,because all of these three access modifiers are more restrictive than
       public.
       For e.g. This is not allowed as child class disp method is more restrictive(protected) than base
       class(public)
class MyBaseClass{
   public void disp()
   {
       System.out.println("Parent class method");
   }
}
class MyChildClass extends MyBaseClass{
   protected void disp(){
      System.out.println("Child class method");
   }
   public static void main( String args[]) {
      MyChildClass obj = new MyChildClass();
      obj.disp();
   }
}
       Output:
Exception in thread "main" java.lang.Error: Unresolved compilation
problem: Cannot reduce the visibility of the inherited method from MyBaseClass
       However this is perfectly valid scenario as public is less restrictive than protected. Same
       access modifier is also a valid one.
class MyBaseClass{
   protected void disp()
   {
       System.out.println("Parent class method");
   }
}
class MyChildClass extends MyBaseClass{
   public void disp(){
      System.out.println("Child class method");
   }
   public static void main( String args[]) {
      MyChildClass obj = new MyChildClass();
      obj.disp();
   }
}
       Output:
Child class method
    3. private, static and final methods cannot be overridden as they are local to the class. However
       static methods can be re-declared in the sub class, in this case the sub-class method would act
       differently and will have nothing to do with the same static method of parent class.
    4. Overriding method (method of child class) can throw unchecked exceptions, regardless of
       whether the overridden method(method of parent class) throws any exception or not. However the
       overriding method should not throw checked exceptions that are new or broader than the ones
       declared by the overridden method. We will discuss this in detail with example in the upcoming
       tutorial.
    5. Binding of overridden methods happen at runtime which is known as dynamic binding.
    6. If a class is extending an abstract class or implementing an interface then it has to
       override all the abstract methods unless the class itself is a abstract class.

Super keyword in Method Overriding
   The super keyword is used for calling the parent class method/constructor. super.myMethod() calls
   the myMethod() method of base class while super() calls the constructor of base class. Let’s see
   the use of super in method Overriding.
   As we know that we we override a method in child class, then call to the method using child class
   object calls the overridden method. By using super we can call the overridden method as shown in the
   example below:
class ABC{
   public void myMethod()
   {
        System.out.println("Overridden method");
   }
}
class Demo extends ABC{
   public void myMethod(){
        //This will call the myMethod() of parent class
        super.myMethod();
        System.out.println("Overriding method");
   }
   public static void main( String args[]) {
        Demo obj = new Demo();
        obj.myMethod();
   }
}

   Output:
Class ABC: mymethod()
Class Test: mymethod()

   As you see using super keyword, we can access the overriden method.


---
https://beginnersbook.com/2014/01/difference-between-method-overloading-and-overriding-in-java/

Difference between method Overloading and Overriding in java

   In this tutorial we will discuss the difference between overloading and overriding in Java. If you
   are new to these terms then refer the following posts:
    1. Method overloading in java
    2. Method overriding in java

Overloading vs Overriding in Java
    1. Overloading happens at compile-time while Overriding happens at runtime: The binding of
       overloaded method call to its definition has happens at compile-time however binding of
       overridden method call to its definition happens at runtime.
    2. Static methods can be overloaded which means a class can have more than one static method of same
       name. Static methods cannot be overridden, even if you declare a same static method in child
       class it has nothing to do with the same method of parent class.
    3. The most basic difference is that overloading is being done in the same class while for
       overriding base and child classes are required. Overriding is all about giving a specific
       implementation to the inherited method of parent class.
    4. Static binding is being used for overloaded methods and dynamic binding is being used for
       overridden/overriding methods.
    5. Performance: Overloading gives better performance compared to overriding. The reason is that the
       binding of overridden methods is being done at runtime.
    6. private and final methods can be overloaded but they cannot be overridden. It means a class can
       have more than one private/final methods of same name but a child class cannot override the
       private/final methods of their base class.
    7. Return type of method does not matter in case of method overloading, it can be same or different.
       However in case of method overriding the overriding method can have more specific return type
       (refer this).
    8. Argument list should be different while doing method overloading. Argument list should be same in
       method Overriding.

Overloading example

//A class for adding upto 5 numbers
class Sum
{
    int add(int n1, int n2)
    {
        return n1+n2;
    }
    int add(int n1, int n2, int n3)
    {
        return n1+n2+n3;
    }
    int add(int n1, int n2, int n3, int n4)
    {
        return n1+n2+n3+n4;
    }
    int add(int n1, int n2, int n3, int n4, int n5)
    {
        return n1+n2+n3+n4+n5;
    }
    public static void main(String args[])
    {
        Sum obj = new Sum();
        System.out.println("Sum of two numbers: "+obj.add(20, 21));
        System.out.println("Sum of three numbers: "+obj.add(20, 21, 22));
        System.out.println("Sum of four numbers: "+obj.add(20, 21, 22, 23));
        System.out.println("Sum of five numbers: "+obj.add(20, 21, 22, 23, 24));
    }
}

   Output:
Sum of two numbers: 41
Sum of three numbers: 63
Sum of four numbers: 86
Sum of five numbers: 110

   Here we have 4 versions of same method add. We are overloading the method add() here.

Overriding example

package beginnersbook.com;
class CarClass
{
    public int speedLimit()
    {
        return 100;
    }
}
class Ford extends CarClass
{
    public int speedLimit()
    {
        return 150;
    }
    public static void main(String args[])
    {
        CarClass obj = new Ford();
        int num= obj.speedLimit();
        System.out.println("Speed Limit is: "+num);
    }
}

   Output:

Speed Limit is: 150

   Here speedLimit() method of class Ford is overriding the speedLimit() method of class CarClass.


---
https://beginnersbook.com/2013/03/polymorphism-in-java/

Polymorphism in Java with example

   Polymorphism is one of the OOPs feature that allows us to perform a single action in different
   ways. For example, lets say we have a class Animal that has a method sound(). Since this is a generic
   class so we can’t give it a implementation like: Roar, Meow, Oink etc. We had to give a generic
   message.
public class Animal{
   ...
   public void sound(){
      System.out.println("Animal is making a sound");
   }
}

   Now lets say we two subclasses of Animal class: Horse and Cat that extends (see Inheritance)
   Animal class. We can provide the implementation to the same method like this:
public class Horse extends Animal{
...
    @Override
    public void sound(){
        System.out.println("Neigh");
    }
}

   and
public class Cat extends Animal{
...
    @Override
    public void sound(){
        System.out.println("Meow");
    }
}

   As you can see that although we had the common action for all subclasses sound() but there were
   different ways to do the same action. This is a perfect example of polymorphism (feature that allows
   us to perform a single action in different ways). It would not make any sense to just call the
   generic sound() method as each Animal has a different sound. Thus we can say that the action this
   method performs is based on the type of object.

What is polymorphism in programming?
   Polymorphism is the capability of a method to do different things based on the object that it is
   acting upon. In other words, polymorphism allows you define one interface and have multiple
   implementations. As we have seen in the above example that we have defined the method sound() and
   have the multiple implementations of it in the different-2 sub classes.
   Which sound() method will be called is determined at runtime so the example we gave above is a
   runtime polymorphism example.

     Types of polymorphism and method overloading & overriding are covered in the separate tutorials.
     You can refer them here:
     1. Method Overloading in Java – This is an example of compile time (or static polymorphism)
     2. Method Overriding in Java – This is an example of runtime time (or dynamic polymorphism)
     3. Types of Polymorphism – Runtime and compile time – This is our next tutorial where we have
     covered the types of polymorphism in detail. I would recommend you to go though method overloading
     and overriding before going though this topic.

   Lets write down the complete code of it:

Example 1: Polymorphism in Java

   Runtime Polymorphism example:
   Animal.java
public class Animal{
   public void sound(){
      System.out.println("Animal is making a sound");
   }
}

   Horse.java
class Horse extends Animal{
    @Override
    public void sound(){
        System.out.println("Neigh");
    }
    public static void main(String args[]){
        Animal obj = new Horse();
        obj.sound();
    }
}

   Output:
Neigh

   Cat.java
public class Cat extends Animal{
    @Override
    public void sound(){
        System.out.println("Meow");
    }
    public static void main(String args[]){
        Animal obj = new Cat();
        obj.sound();
    }
}

   Output:
Meow

Example 2: Compile time Polymorphism

   Method Overloading on the other hand is a compile time polymorphism example.
class Overload
{
    void demo (int a)
    {
       System.out.println ("a: " + a);
    }
    void demo (int a, int b)
    {
       System.out.println ("a and b: " + a + "," + b);
    }
    double demo(double a) {
       System.out.println("double a: " + a);
       return a*a;
    }
}
class MethodOverloading
{
    public static void main (String args [])
    {
        Overload Obj = new Overload();
        double result;
        Obj .demo(10);
        Obj .demo(10, 20);
        result = Obj .demo(5.5);
        System.out.println("O/P : " + result);
    }
}

   Here the method demo() is overloaded 3 times: first method has 1 int parameter, second method has 2
   int parameters and third one is having double parameter. Which method is to be called is determined
   by the arguments we pass while calling methods. This happens at runtime so this type of polymorphism
   is known as compile time polymorphism.

   Output:
a: 10
a and b: 10,20
double a: 5.5
O/P : 30.25


---
https://beginnersbook.com/2013/04/runtime-compile-time-polymorphism/

Types of polymorphism in java- Runtime and Compile time polymorphism

   In the last tutorial we discussed Polymorphism in Java. In this guide we will see types of
   polymorphism. There are two types of polymorphism in java:
   1) Static Polymorphism also known as compile time polymorphism
   2) Dynamic Polymorphism also known as runtime polymorphism

Compile time Polymorphism (or Static polymorphism)
   Polymorphism that is resolved during compiler time is known as static polymorphism. Method
   overloading is an example of compile time polymorphism.
   Method Overloading: This allows us to have more than one method having the same name, if the
   parameters of methods are different in number, sequence and data types of parameters. We have already
   discussed Method overloading here: If you didn’t read that guide, refer: Method Overloading in
   Java

Example of static Polymorphism
   Method overloading is one of the way java supports static polymorphism. Here we have two definitions
   of the same method add() which add method would be called is determined by the parameter list at the
   compile time. That is the reason this is also known as compile time polymorphism.
class SimpleCalculator
{
    int add(int a, int b)
    {
         return a+b;
    }
    int  add(int a, int b, int c)
    {
         return a+b+c;
    }
}
public class Demo
{
   public static void main(String args[])
   {
           SimpleCalculator obj = new SimpleCalculator();
       System.out.println(obj.add(10, 20));
       System.out.println(obj.add(10, 20, 30));
   }
}

   Output:

30
60

Runtime Polymorphism (or Dynamic polymorphism)
   It is also known as Dynamic Method Dispatch. Dynamic polymorphism is a process in which a call to an
   overridden method is resolved at runtime, thats why it is called runtime polymorphism. I have already
   discussed method overriding in detail in a separate tutorial, refer it: Method Overriding in
   Java.

   Example
   In this example we have two classes ABC and XYZ. ABC is a parent class and XYZ is a child class. The
   child class is overriding the method myMethod() of parent class. In this example we have child class
   object assigned to the parent class reference so in order to determine which method would be called,
   the type of the object would be determined at run-time. It is the type of object that determines
   which version of the method would be called (not the type of reference).

     To understand the concept of overriding, you should have the basic knowledge of inheritance in
     Java.

class ABC{
   public void myMethod(){
        System.out.println("Overridden Method");
   }
}
public class XYZ extends ABC{

   public void myMethod(){
        System.out.println("Overriding Method");
   }
   public static void main(String args[]){
        ABC obj = new XYZ();
        obj.myMethod();
   }
}

   Output:
Overriding Method

   When an overridden method is called through a reference of parent class, then type of the object
   determines which method is to be executed. Thus, this determination is made at run time.
   Since both the classes, child class and parent class have the same method animalSound. Which version
   of the method(child class or parent class) will be called is determined at runtime by JVM.

   Few more overriding examples:
ABC obj = new ABC();
obj.myMethod();
// This would call the myMethod() of parent class ABC

XYZ obj = new XYZ();
obj.myMethod();
// This would call the myMethod() of child class XYZ

ABC obj = new XYZ();
obj.myMethod();
// This would call the myMethod() of child class XYZ

   In the third case the method of child class is to be executed because which method is to be executed
   is determined by the type of object and since the object belongs to the child class, the child class
   version of myMethod() is called.


---
https://beginnersbook.com/2013/04/java-static-dynamic-binding/

Static and dynamic binding in java

   Association of method call to the method body is known as binding. There are two types of binding:
   Static Binding that happens at compile time and Dynamic Binding that happens at runtime. Before
   I explain static and dynamic binding in java, lets see few terms that will help you understand this
   concept better.

What is reference and object?

class Human{
....
}
class Boy extends Human{
   public static void main( String args[]) {
       /*This statement simply creates an object of class
        *Boy and assigns a reference of Boy to it*/
       Boy obj1 = new Boy();

       /* Since Boy extends Human class. The object creation
        * can be done in this way. Parent class reference
        * can have child class reference assigned to it
        */
       Human obj2 = new Boy();
   }
}

Static and Dynamic Binding in Java
   As mentioned above, association of method definition to the method call is known as binding. There
   are two types of binding: Static binding and dynamic binding. Lets discuss them.

Static Binding or Early Binding
   The binding which can be resolved at compile time by compiler is known as static or early binding.
   The binding of static, private and final methods is compile-time. Why? The reason is that the
   these method cannot be overridden and the type of the class is determined at the compile time. Lets
   see an example to understand this:

Static binding example
   Here we have two classes Human and Boy. Both the classes have same method walk() but the method is
   static, which means it cannot be overriden so even though I have used the object of Boy class while
   creating object obj, the parent class method is called by it. Because the reference is of Human type
   (parent class). So whenever a binding of static, private and final methods happen, type of the class
   is determined by the compiler at compile time and the binding happens then and there.
   [INS: :INS]
class Human{
   public static void walk()
   {
       System.out.println("Human walks");
   }
}
class Boy extends Human{
   public static void walk(){
       System.out.println("Boy walks");
   }
   public static void main( String args[]) {
       /* Reference is of Human type and object is
        * Boy type
        */
       Human obj = new Boy();
       /* Reference is of HUman type and object is
        * of Human type.
        */
       Human obj2 = new Human();
       obj.walk();
       obj2.walk();
   }
}

   Output:
Human walks
Human walks

Dynamic Binding or Late Binding
   When compiler is not able to resolve the call/binding at compile time, such binding is known as
   Dynamic or late Binding. Method Overriding is a perfect example of dynamic binding as in
   overriding both parent and child classes have same method and in this case the type of the object
   determines which method is to be executed. The type of object is determined at the run time so this
   is known as dynamic binding.

Dynamic binding example
   This is the same example that we have seen above. The only difference here is that in this example,
   overriding is actually happening since these methods are not static, private and final. In case of
   overriding the call to the overriden method is determined at runtime by the type of object thus late
   binding happens. Lets see an example to understand this:
class Human{
   //Overridden Method
   public void walk()
   {
       System.out.println("Human walks");
   }
}
class Demo extends Human{
   //Overriding Method
   public void walk(){
       System.out.println("Boy walks");
   }
   public static void main( String args[]) {
       /* Reference is of Human type and object is
        * Boy type
        */
       Human obj = new Demo();
       /* Reference is of HUman type and object is
        * of Human type.
        */
       Human obj2 = new Human();
       obj.walk();
       obj2.walk();
   }
}

   Output:
Boy walks
Human walks

   As you can see that the output is different than what we saw in the static binding example, because
   in this case while creation of object obj the type of the object is determined as a Boy type so
   method of Boy class is called. Remember the type of the object is determined at the runtime.

Static Binding vs Dynamic Binding
   Lets discuss the difference between static and dynamic binding in Java.
    1. Static binding happens at compile-time while dynamic binding happens at runtime.
    2. Binding of private, static and final methods always happen at compile time since these methods
       cannot be overridden. When the method overriding is actually happening and the reference of
       parent type is assigned to the object of child class type then such binding is resolved during
       runtime.
    3. The binding of overloaded methods is static and the binding of overridden methods is dynamic.


---
https://beginnersbook.com/2013/05/java-abstract-class-method/

Abstract Class in Java with example

   A class that is declared using “abstract” keyword is known as abstract class. It can have abstract
   methods(methods without body) as well as concrete methods (regular methods with body). A normal
   class(non-abstract class) cannot have abstract methods. In this guide we will learn what is a
   abstract class, why we use it and what are the rules that we must remember while working with it in
   Java.

     An abstract class can not be instantiated, which means you are not allowed to create an object of
     it. Why? We will discuss that later in this guide.

Why we need an abstract class?
   Lets say we have a class Animal that has a method sound() and the subclasses(see inheritance) of
   it like Dog, Lion, Horse, Cat etc. Since the animal sound differs from one animal to another, there
   is no point to implement this method in parent class. This is because every child class must override
   this method to give its own implementation details, like Lion class will say “Roar” in this method
   and Dog class will say “Woof”.

   So when we know that all the animal child classes will and should override this method, then there is
   no point to implement this method in parent class. Thus, making this method abstract would be the
   good choice as by making this method abstract we force all the sub classes to implement this method(
   otherwise you will get compilation error), also we need not to give any implementation to this method
   in parent class.

   Since the Animal class has an abstract method, you must need to declare this class abstract.

   Now each animal must have a sound, by making this method abstract we made it compulsory to the child
   class to give implementation details to this method. This way we ensures that every animal has a
   sound.

Abstract class Example

//abstract parent class
abstract class Animal{
   //abstract method
   public abstract void sound();
}
//Dog class extends Animal class
public class Dog extends Animal{

   public void sound(){
        System.out.println("Woof");
   }
   public static void main(String args[]){
        Animal obj = new Dog();
        obj.sound();
   }
}

   Output:
Woof

   Hence for such kind of scenarios we generally declare the class as abstract and later concrete
   classes extend these classes and override the methods accordingly and can have their own methods as
   well.

Abstract class declaration

   An abstract class outlines the methods but not necessarily implements all the methods.
//Declaration using abstract keyword
abstract class A{
   //This is abstract method
   abstract void myMethod();

   //This is concrete method with body
   void anotherMethod(){
      //Does something
   }
}

Rules
   Note 1: As we seen in the above example, there are cases when it is difficult or often unnecessary to
   implement all the methods in parent class. In these cases, we can declare the parent class as
   abstract, which makes it a special class which is not complete on its own.

   A class derived from the abstract class must implement all those methods that are declared as
   abstract in the parent class.

   Note 2: Abstract class cannot be instantiated which means you cannot create the object of it. To use
   this class, you need to create another class that extends this this class and provides the
   implementation of abstract methods, then you can use the object of that child class to call
   non-abstract methods of parent class as well as implemented methods(those that were abstract in
   parent but implemented in child class).

   Note 3: If a child does not implement all the abstract methods of abstract parent class, then the
   child class must need to be declared abstract as well.

     Do you know? Since abstract class allows concrete methods as well, it does not provide 100%
     abstraction. You can say that it provides partial abstraction. Abstraction is a process where you
     show only “relevant” data and “hide” unnecessary details of an object from the user.

     Interfaces on the other hand are used for 100% abstraction (See more about abstraction
     here).
     You may also want to read this: Difference between abstract class and Interface in Java

Why can’t we create the object of an abstract class?

   Because these classes are incomplete, they have abstract methods that have no body so if java allows
   you to create object of this class then if someone calls the abstract method using that object then
   What would happen?There would be no actual implementation of the method to invoke.
   Also because an object is concrete. An abstract class is like a template, so you have to extend it
   and build on it before you can use it.

Example to demonstrate that object creation of abstract class is not allowed

   As discussed above, we cannot instantiate an abstract class. This program throws a compilation error.
abstract class AbstractDemo{
   public void myMethod(){
      System.out.println("Hello");
   }
   abstract public void anotherMethod();
}
public class Demo extends AbstractDemo{

   public void anotherMethod() {
        System.out.print("Abstract method");
   }
   public static void main(String args[])
   {
      //error: You can't create object of it
      AbstractDemo obj = new AbstractDemo();
      obj.anotherMethod();
   }
}

   Output:
Unresolved compilation problem: Cannot instantiate the type AbstractDemo

   Note: The class that extends the abstract class, have to implement all the abstract methods of it,
   else you have to declare that class abstract as well.

Abstract class vs Concrete class

   A class which is not abstract is referred as Concrete class. In the above example that we have seen
   in the beginning of this guide, Animal is a abstract class and Cat, Dog & Lion are concrete classes.

   Key Points:
    1. An abstract class has no use until unless it is extended by some other class.
    2. If you declare an abstract method in a class then you must declare the class abstract as well.
       you can’t have abstract method in a concrete class. It’s vice versa is not always true: If a
       class is not having any abstract method then also it can be marked as abstract.
    3. It can have non-abstract method (concrete) as well.

   I have covered the rules and examples of abstract methods in a separate tutorial, You can find the
   guide here: Abstract method in Java
   For now lets just see some basics and example of abstract method.
   1) Abstract method has no body.
   2) Always end the declaration with a semicolon(;).
   3) It must be overridden. An abstract class must be extended and in a same way abstract method
   must be overridden.
   4) A class has to be declared abstract to have abstract methods.

   Note: The class which is extending abstract class must override all the abstract methods.

Example of Abstract class and method

abstract class MyClass{
   public void disp(){
     System.out.println("Concrete method of parent class");
   }
   abstract public void disp2();
}

class Demo extends MyClass{
   /* Must Override this method while extending
    * MyClas
    */
   public void disp2()
   {
       System.out.println("overriding abstract method");
   }
   public static void main(String args[]){
       Demo obj = new Demo();
       obj.disp2();
   }
}

   Output:
overriding abstract method


---
https://beginnersbook.com/2013/05/java-interface/

Interface in java with example programs

   In the last tutorial we discussed abstract class which is used for achieving partial abstraction.
   Unlike abstract class an interface is used for full abstraction. Abstraction is a process where you
   show only “relevant” data and “hide” unnecessary details of an object from the user(See:
   Abstraction). In this guide, we will cover what is an interface in java, why we use it and what
   are rules that we must follow while using interfaces in Java Programming.

What is an interface in Java?
   Interface looks like a class but it is not a class. An interface can have methods and variables just
   like the class but the methods declared in interface are by default abstract (only method signature,
   no body, see: Java abstract method). Also, the variables declared in an interface are public,
   static & final by default. We will cover this in detail, later in this guide.

What is the use of interface in Java?
   As mentioned above they are used for full abstraction. Since methods in interfaces do not have body,
   they have to be implemented by the class before you can access them. The class that implements
   interface must implement all the methods of that interface. Also, java programming language does not
   allow you to extend more than one class, However you can implement more than one interfaces in your
   class.

   Syntax:
   Interfaces are declared by specifying a keyword “interface”. E.g.:
   [INS: :INS]
interface MyInterface
{
   /* All the methods are public abstract by default
    * As you see they have no body
    */
   public void method1();
   public void method2();
}

Example of an Interface in Java
   This is how a class implements an interface. It has to provide the body of all the methods that are
   declared in interface or in other words you can say that class has to implement all the methods of
   interface.

     Do you know? class implements interface but an interface extends another interface.

interface MyInterface
{
   /* compiler will treat them as:
    * public abstract void method1();
    * public abstract void method2();
    */
   public void method1();
   public void method2();
}
class Demo implements MyInterface
{
   /* This class must have to implement both the abstract methods
    * else you will get compilation error
    */
   public void method1()
   {
        System.out.println("implementation of method1");
   }
   public void method2()
   {
        System.out.println("implementation of method2");
   }
   public static void main(String arg[])
   {
        MyInterface obj = new Demo();
        obj.method1();
   }
}

   Output:
implementation of method1

Interface and Inheritance
   As discussed above, an interface can not implement another interface. It has to extend the other
   interface. See the below example where we have two interfaces Inf1 and Inf2. Inf2 extends Inf1 so If
   class implements the Inf2 it has to provide implementation of all the methods of interfaces Inf2 as
   well as Inf1.

     Learn more about inheritance here: Java Inheritance

interface Inf1{
   public void method1();
}
interface Inf2 extends Inf1 {
   public void method2();
}
public class Demo implements Inf2{
   /* Even though this class is only implementing the
    * interface Inf2, it has to implement all the methods
    * of Inf1 as well because the interface Inf2 extends Inf1
    */
    public void method1(){
        System.out.println("method1");
    }
    public void method2(){
        System.out.println("method2");
    }
    public static void main(String args[]){
        Inf2 obj = new Demo();
        obj.method2();
    }
}

   In this program, the class Demo only implements interface Inf2, however it has to provide the
   implementation of all the methods of interface Inf1 as well, because interface Inf2 extends Inf1.

Tag or Marker interface in Java
   An empty interface is known as tag or marker interface. For example Serializable, EventListener,
   Remote(java.rmi.Remote) are tag interfaces. These interfaces do not have any field and methods in it.
   Read more about it here.

Nested interfaces
   An interface which is declared inside another interface or class is called nested interface. They
   are also known as inner interface. For example Entry interface in collections framework is declared
   inside Map interface, that’s why we don’ use it directly, rather we use it like this: Map.Entry.

   Key points: Here are the key points to remember about interfaces:
   1) We can’t instantiate an interface in java. That means we cannot create the object of an interface

   2) Interface provides full abstraction as none of its methods have body. On the other hand abstract
   class provides partial abstraction as it can have abstract and concrete(methods with body) methods
   both.

   3) implements keyword is used by classes to implement an interface.

   4) While providing implementation in class of any method of an interface, it needs to be mentioned as
   public.

   5) Class that implements any interface must implement all the methods of that interface, else the
   class should be declared abstract.

   6) Interface cannot be declared as private, protected or transient.

   7) All the interface methods are by default abstract and public.

   8) Variables declared in interface are public, static and final by default.
interface Try
{
   int a=10;
   public int a=10;
   public static final int a=10;
   final int a=10;
   static int a=0;
}

   All of the above statements are identical.

   9) Interface variables must be initialized at the time of declaration otherwise compiler will throw
   an error.
interface Try
{
      int x;//Compile-time error
}

   Above code will throw a compile time error as the value of the variable x is not initialized at the
   time of declaration.

   10) Inside any implementation class, you cannot change the variables declared in interface because by
   default, they are public, static and final. Here we are implementing the interface “Try” which has a
   variable x. When we tried to set the value for variable x we got compilation error as the variable x
   is public static final by default and final variables can not be re-initialized.
class Sample implements Try
{
  public static void main(String args[])
  {
     x=20; //compile time error
  }
}

   11) An interface can extend any interface but cannot implement it. Class implements interface and
   interface extends interface.

   12) A class can implement any number of interfaces.

   13) If there are two or more same methods in two interfaces and a class implements both interfaces,
   implementation of the method once is enough.
interface A
{
   public void aaa();
}
interface B
{
   public void aaa();
}
class Central implements A,B
{
   public void aaa()
   {
        //Any Code here
   }
   public static void main(String args[])
   {
        //Statements
    }
}

   14) A class cannot implement two interfaces that have methods with same name but different return
   type.
interface A
{
   public void aaa();
}
interface B
{
   public int aaa();
}

class Central implements A,B
{

   public void aaa() // error
   {
   }
   public int aaa() // error
   {
   }
   public static void main(String args[])
   {

   }
}

   15) Variable names conflicts can be resolved by interface name.
interface A
{
    int x=10;
}
interface B
{
    int x=100;
}
class Hello implements A,B
{
    public static void Main(String args[])
    {
       /* reference to x is ambiguous both variables are x
        * so we are using interface name to resolve the
        * variable
        */
       System.out.println(x);
       System.out.println(A.x);
       System.out.println(B.x);
    }
}

Advantages of interface in java:
   Advantages of using interfaces are as follows:
    1. Without bothering about the implementation part, we can achieve the security of implementation
    2. In java, multiple inheritance is not allowed, however you can use interface to make use of it
       as you can implement more than one interface.


---
https://beginnersbook.com/2013/05/abstract-class-vs-interface-in-java/

Difference Between Abstract Class and Interface in Java

   In this article, we will discuss the difference between Abstract Class and Interface in Java with
   examples. I have covered the abstract class and interface in separate tutorials of OOPs Concepts
   so I would recommend you to read them first, before going though the differences.
   1. Abstract class in java
   2. Interface in Java
    Abstract Class  Interface
   1  An abstract class can extend only one class or one abstract class at a time  An interface can
   extend any number of interfaces at a time
   2   An abstract class can extend another concrete (regular) class or abstract class  An interface can
   only extend another interface
   3  An abstract class can have both abstract and concrete methods  An interface can have only abstract
   methods
   4  In abstract class keyword “abstract” is mandatory to declare a method as an abstract  In an
   interface keyword “abstract” is optional to declare a method as an abstract
   5  An abstract class can have protected and public abstract methods  An interface can have only have
   public abstract methods
   6  An abstract class can have static, final or static final variable with any access specifier
   interface can only have public static final (constant) variable

   Each of the above mentioned points are explained with an example below:

Abstract class vs interface in Java

Difference No.1: Abstract class can extend only one class or one abstract class at a time

class Example1{
   public void display1(){
      System.out.println("display1 method");
   }
}
abstract class Example2{
   public void display2(){
      System.out.println("display2 method");
   }
}
abstract class Example3 extends Example1{
   abstract void display3();
}
class Example4 extends Example3{
   public void display3(){
      System.out.println("display3 method");
   }
}
class Demo{
   public static void main(String args[]){
       Example4 obj=new Example4();
       obj.display3();
   }
}

   Output:
display3 method

   Interface can extend any number of interfaces at a time
   [INS: :INS]
//first interface
interface Example1{
    public void display1();
}
//second interface
interface Example2 {
    public void display2();
}
//This interface is extending both the above interfaces
interface Example3 extends Example1,Example2{
}
class Example4 implements Example3{
    public void display1(){
        System.out.println("display2 method");
    }
    public void display2(){
        System.out.println("display3 method");
    }
}
class Demo{
    public static void main(String args[]){
        Example4 obj=new Example4();
        obj.display1();
    }
}

   Output:
display2 method

Difference No.2: Abstract class can be extended(inherited) by a class or an abstract class

class Example1{
   public void display1(){
      System.out.println("display1 method");
   }
}
abstract class Example2{
   public void display2(){
       System.out.println("display2 method");
   }
}
abstract class Example3 extends Example2{
   abstract void display3();
}
class Example4 extends Example3{
   public void display2(){
       System.out.println("Example4-display2 method");
   }
   public void display3(){
       System.out.println("display3 method");
   }
}
class Demo{
   public static void main(String args[]){
       Example4 obj=new Example4();
       obj.display2();
   }
}

   Output:
Example4-display2 method

   Interfaces can be extended only by interfaces. Classes has to implement them instead of extend
interface Example1{
    public void display1();
}
interface Example2 extends Example1{
}
class Example3 implements Example2{
   public void display1(){
      System.out.println("display1 method");
   }
}
class Demo{
   public static void main(String args[]){
      Example3 obj=new Example3();
      obj.display1();
   }
}

   Output:
display1 method

Difference No.3: Abstract class can have both abstract and concrete methods

abstract class Example1 {
   abstract void display1();
   public void display2(){
     System.out.println("display2 method");
   }
}
class Example2 extends Example1{
   public void display1(){
      System.out.println("display1 method");
   }
}
class Demo{
   public static void main(String args[]){
     Example2 obj=new Example2();
     obj.display1();
   }
}

   Interface can only have abstract methods, they cannot have concrete methods
interface Example1{
   public abstract void display1();
}
class Example2 implements Example1{
   public void display1(){
      System.out.println("display1 method");
   }
}
class Demo{
   public static void main(String args[]){
      Example2 obj=new Example2();
      obj.display1();
   }
}

   Output:
display1 method

Difference No.4: In abstract class, the keyword ‘abstract’ is mandatory to declare a method as an abstract

abstract class Example1{
   public abstract void display1();
}

class Example2 extends Example1{
   public void display1(){
      System.out.println("display1 method");
   }
   public void display2(){
      System.out.println("display2 method");
   }
}
class Demo{
   public static void main(String args[]){
       Example2 obj=new Example2();
       obj.display1();
   }
}

   In interfaces, the keyword ‘abstract’ is optional to declare a method as an abstract because all the
   methods are abstract by default
interface Example1{
    public void display1();
}
class Example2 implements Example1{
    public void display1(){
        System.out.println("display1 method");
    }
    public void display2(){
        System.out.println("display2 method");
    }
}
class Demo{
   public static void main(String args[]){
       Example2 obj=new Example2();
       obj.display1();
   }
}

Difference No.5: Abstract class can have protected and public abstract methods

abstract class Example1{
   protected abstract void display1();
   public abstract void display2();
   public abstract void display3();
}
class Example2 extends Example1{
   public void display1(){
       System.out.println("display1 method");
   }
   public void display2(){
      System.out.println("display2 method");
   }
   public void display3(){
      System.out.println("display3 method");
   }
}
class Demo{
   public static void main(String args[]){
      Example2 obj=new Example2();
      obj.display1();
   }
}

   Interface can have only public abstract methods
interface Example1{
   void display1();
}
class Example2 implements Example1{
   public void display1(){
      System.out.println("display1 method");
   }
   public void display2(){
      System.out.println("display2 method");
   }
}
class Demo{
   public static void main(String args[]){
       Example2 obj=new Example2();
       obj.display1();
   }
}

Difference No.6: Abstract class can have static, final or static final variables with any access specifier

abstract class Example1{
   private int numOne=10;
   protected final int numTwo=20;
   public static final int numThree=500;
   public void display1(){
      System.out.println("Num1="+numOne);
   }
}
class Example2 extends Example1{
   public void display2(){
      System.out.println("Num2="+numTwo);
      System.out.println("Num2="+numThree);
   }
}
class Demo{
   public static void main(String args[]){
      Example2 obj=new Example2();
      obj.display1();
      obj.display2();
   }
}

   Interface can have only public static final (constant) variable
interface Example1{
   int numOne=10;
}
class Example2 implements Example1{
   public void display1(){
      System.out.println("Num1="+numOne);
   }
}
class Demo{
   public static void main(String args[]){
      Example2 obj=new Example2();
      obj.display1();
   }
}


---
https://beginnersbook.com/2013/05/encapsulation-in-java/

Encapsulation in Java with example

   Encapsulation simply means binding object state(fields) and behaviour(methods) together. If you are
   creating class, you are doing encapsulation. In this guide we will see how to do encapsulation in
   java program, if you are looking for a real-life example of encapsulation then refer this guide:
   OOPs features explained using real-life examples.

     For other OOPs topics such as inheritance and polymorphism, refer OOPs concepts

   Lets get back to the topic.

What is encapsulation?
   The whole idea behind encapsulation is to hide the implementation details from users. If a data
   member is private it means it can only be accessed within the same class. No outside class can access
   private data member (variable) of other class.

   However if we setup public getter and setter methods to update (for example void setSSN(int ssn))and
   read (for example  int getSSN()) the private data fields then the outside class can access those
   private data fields via public methods.

   This way data can only be accessed by public methods thus making the private fields and their
   implementation hidden for outside classes. That’s why encapsulation is known as data hiding. Lets see
   an example to understand this concept better.

Example of Encapsulation in Java
   How to implement encapsulation in java:
   1) Make the instance variables private so that they cannot be accessed directly from outside the
   class. You can only set and get values of these variables through the methods of the class.
   2) Have getter and setter methods in the class to set and get the values of the fields.
class EncapsulationDemo{
    private int ssn;
    private String empName;
    private int empAge;

    //Getter and Setter methods
    public int getEmpSSN(){
        return ssn;
    }

    public String getEmpName(){
        return empName;
    }

    public int getEmpAge(){
        return empAge;
    }

    public void setEmpAge(int newValue){
        empAge = newValue;
    }

    public void setEmpName(String newValue){
        empName = newValue;
    }

    public void setEmpSSN(int newValue){
        ssn = newValue;
    }
}
public class EncapsTest{
    public static void main(String args[]){
         EncapsulationDemo obj = new EncapsulationDemo();
         obj.setEmpName("Mario");
         obj.setEmpAge(32);
         obj.setEmpSSN(112233);
         System.out.println("Employee Name: " + obj.getEmpName());
         System.out.println("Employee SSN: " + obj.getEmpSSN());
         System.out.println("Employee Age: " + obj.getEmpAge());
    }
}

   Output:
Employee Name: Mario
Employee SSN: 112233
Employee Age: 32

   In above example all the three data members (or data fields) are private(see: Access Modifiers in
   Java) which cannot be accessed directly. These fields can be accessed via public methods only. Fields
   empName, ssn and empAge are made hidden data fields using encapsulation technique of OOPs.

Advantages of encapsulation
    1. It improves maintainability and flexibility and re-usability: for e.g. In the above code the
       implementation code of void setEmpName(String name) and String getEmpName() can be changed at any
       point of time. Since the implementation is purely hidden for outside classes they would still be
       accessing the private field empName using the same methods (setEmpName(String name) and
       getEmpName()). Hence the code can be maintained at any point of time without breaking the classes
       that uses the code. This improves the re-usability of the underlying class.
    2. The fields can be made read-only (If we don’t define setter methods in the class) or write-only
       (If we don’t define the getter methods in the class). For e.g. If we have a field(or variable)
       that we don’t want to be changed so we simply define the variable as private and instead of set
       and get both we just need to define the get method for that variable. Since the set method is not
       present there is no way an outside class can modify the value of that field.
    3. User would not be knowing what is going on behind the scene. They would only be knowing that to
       update a field call set method and to read a field call get method but what these set and get
       methods are doing is purely hidden from them.

   Encapsulation is also known as “data Hiding“.


---
https://beginnersbook.com/2013/03/packages-in-java/

Packages in java and how to use them

   A package as the name suggests is a pack(group) of classes, interfaces and other packages. In java we
   use packages to organize our classes and interfaces. We have two types of packages in Java: built-in
   packages and the packages we can create (also known as user defined package). In this guide we will
   learn what are packages, what are user-defined packages in java and how to use them.

   In java we have several built-in packages, for example when we need user input, we import a package
   like this:
import java.util.Scanner

   Here:
   → java is a top level package
   → util is a sub package
   → and Scanner is a class which is present in the sub package util.

   Before we see how to create a user-defined package in java, lets see the advantages of using a
   package.

Advantages of using a package in Java
   These are the reasons why you should use packages in Java:
     * Reusability: While developing a project in java, we often feel that there are few things that we
       are writing again and again in our code. Using packages, you can create such things in form of
       classes inside a package and whenever you need to perform that same task, just import that
       package and use the class.
     * Better Organization: Again, in large java projects where we have several hundreds of classes, it
       is always required to group the similar types of classes in a meaningful package name so that you
       can organize your project better and when you need something you can quickly locate it and use
       it, which improves the efficiency.
     * Name Conflicts: We can define two classes with the same name in different packages so to avoid
       name collision, we can use packages

Types of packages in Java
   As mentioned in the beginning of this guide that we have two types of packages in java.
   1) User defined package: The package we create is called user-defined package.
   2) Built-in package: The already defined package like java.io.*, java.lang.* etc are known as
   built-in packages.

   We have already discussed built-in packages, lets discuss user-defined packages with the help of
   examples.

Example 1: Java packages
   I have created a class Calculator inside a package name letmecalculate. To create a class inside a
   package, declare the package name in the first statement in your program. A class can have only one
   package declaration.
   Calculator.java file created inside a package letmecalculate
package letmecalculate;

public class Calculator {
   public int add(int a, int b){
        return a+b;
   }
   public static void main(String args[]){
        Calculator obj = new Calculator();
        System.out.println(obj.add(10, 20));
   }
}

   Now lets see how to use this package in another program.
import letmecalculate.Calculator;
public class Demo{
   public static void main(String args[]){
        Calculator obj = new Calculator();
        System.out.println(obj.add(100, 200));
   }
}

   To use the class Calculator, I have imported the package letmecalculate. In the above program I have
   imported the package as letmecalculate.Calculator, this only imports the Calculator class. However if
   you have several classes inside package letmecalculate then you can import the package like this, to
   use all the classes of this package.
import letmecalculate.*;

Example 2: Creating a class inside package while importing another package
   As we have seen that both package declaration and package import should be the first statement in
   your java program. Lets see what should be the order when we are creating a class inside a package
   while importing another package.
//Declaring a package
package anotherpackage;
//importing a package
import letmecalculate.Calculator;
public class Example{
   public static void main(String args[]){
        Calculator obj = new Calculator();
        System.out.println(obj.add(100, 200));
   }
}

   So the order in this case should be:
   → package declaration
   → package import

Example 3: Using fully qualified name while importing a class
   You can use fully qualified name to avoid the import statement. Lets see an example to understand
   this:
   Calculator.java
package letmecalculate;
public class Calculator {
   public int add(int a, int b){
        return a+b;
   }
   public static void main(String args[]){
        Calculator obj = new Calculator();
        System.out.println(obj.add(10, 20));
   }
}

   Example.java
//Declaring a package
package anotherpackage;
public class Example{
   public static void main(String args[]){
        //Using fully qualified name instead of import
        letmecalculate.Calculator obj =
                new letmecalculate.Calculator();
        System.out.println(obj.add(100, 200));
   }
}

   In the Example class, instead of importing the package, I have used the full qualified name such as
   package_name.class_name to create the object of it. You may also want to read: static import in
   Java

Sub packages in Java

   A package inside another package is known as sub package. For example If I create a package inside
   letmecalculate package then that will be called sub package.

   Lets say I have created another package inside letmecalculate and the sub package name is multiply.
   So if I create a class in this subpackage it should have this package declaration in the beginning:
package letmecalculate.multiply;

   Multiplication.java
package letmecalculate.multiply;
public class Multiplication {
        int product(int a, int b){
                return a*b;
        }
}

   Now if I need to use this Multiplication class I have to either import the package like this:
import letmecalculate.multiply;

   or I can use fully qualified name like this:
letmecalculate.multiply.Multiplication obj =
     new letmecalculate.multiply.Multiplication();

Points to remember:

   1. Sometimes class name conflict may occur. For example: Lets say we have two packages abcpackage and
   xyzpackage and both the packages have a class with the same name, let it be JavaExample.java. Now
   suppose a class import both these packages like this:
import abcpackage.*;
import xyzpackage.*;

   This will throw compilation error. To avoid such errors you need to use the fully qualified name
   method that I have shown above. For example
abcpackage.JavaExample obj = new abcpackage.JavaExample();
xyzpackage.JavaExample obj2 = new xyzpackage.JavaExample();

   This way you can avoid the import package statements and avoid that name conflict error.

   2. I have already discussed this above, let me mention it again here. If we create a class inside a
   package while importing another package then the package declaration should be the first statement,
   followed by package import. For example:
package abcpackage;
import xyzpackage.*;

   3. A class can have only one package declaration but it can have more than one package import
   statements. For example:
package abcpackage; //This should be one
import xyzpackage;
import anotherpackage;
import anything;

   4. The wild card import like package.* should be used carefully when working with subpackages. For
   example: Lets say: we have a package abc and inside that package we have another package foo, now foo
   is a subpackage.

   classes inside abc are: Example1, Example 2, Example 3
   classes inside foo are: Demo1, Demo2

   So if I import the package abc using wildcard like this:
import abc.*;

   Then it will only import classes Example1, Example2 and Example3 but it will not import the classes
   of sub package.

   To import the classes of subpackage you need to import like this:
import abc.foo.*;

   This will import Demo1 and Demo2 but it will not import the Example1, Example2 and Example3.

   So to import all the classes present in package and subpackage, we need to use two import statements
   like this:
import abc.*;
import abc.foo.*;


---
https://beginnersbook.com/2013/05/java-access-modifiers/

Java Access Modifiers – Public, Private, Protected & Default

   You must have seen public, private and protected keywords while practising java programs, these are
   called access modifiers. An access modifier restricts the access of a class, constructor, data member
   and method in another class. In java we have four access modifiers:
   1. default
   2. private
   3. protected
   4. public

1. Default access modifier
   When we do not mention any access modifier, it is called default access modifier. The scope of this
   modifier is limited to the package only. This means that if we have a class with the default access
   modifier in a package, only those classes that are in this package can access this class. No other
   class outside this package can access this class. Similarly, if we have a default method or data
   member in a class, it would not be visible in the class of another package. Lets see an example to
   understand this:

Default Access Modifier Example in Java
     To understand this example, you must have the knowledge of packages in java.

   In this example we have two classes, Test class is trying to access the default method of Addition
   class, since class Test belongs to a different package, this program would throw compilation error,
   because the scope of default modifier is limited to the same package in which it is declared.
   Addition.java

package abcpackage;

public class Addition {
   /* Since we didn't mention any access modifier here, it would
    * be considered as default.
    */
   int addTwoNumbers(int a, int b){
        return a+b;
   }
}

   Test.java
package xyzpackage;

/* We are importing the abcpackage
 * but still we will get error because the
 * class we are trying to use has default access
 * modifier.
 */
import abcpackage.*;
public class Test {
   public static void main(String args[]){
        Addition obj = new Addition();
        /* It will throw error because we are trying to access
         * the default method in another package
         */
        obj.addTwoNumbers(10, 21);
   }
}

   Output:
Exception in thread "main" java.lang.Error: Unresolved compilation problem:
The method addTwoNumbers(int, int) from the type Addition is not visible
at xyzpackage.Test.main(Test.java:12)

2. Private access modifier
   The scope of private modifier is limited to the class only.
    1. Private Data members and methods are only accessible within the class
    2. Class and Interface cannot be declared as private
    3. If a class has private constructor then you cannot create the object of that class from
       outside of the class.

   Let’s see an example to understand this:

Private access modifier example in java

   This example throws compilation error because we are trying to access the private data member and
   method of class ABC in the class Example. The private data member and method are only accessible
   within the class.
class ABC{
   private double num = 100;
   private int square(int a){
        return a*a;
   }
}
public class Example{
   public static void main(String args[]){
        ABC obj = new ABC();
        System.out.println(obj.num);
        System.out.println(obj.square(10));
   }
}

   Output:
Compile - time error

3. Protected Access Modifier
   Protected data member and method are only accessible by the classes of the same package and the
   subclasses present in any package. You can also say that the protected access modifier is similar to
   default access modifier with one exception that it has visibility in sub classes.
   Classes cannot be declared protected. This access modifier is generally used in a parent child
   relationship.

Protected access modifier example in Java

   In this example the class Test which is present in another package is able to call the
   addTwoNumbers() method, which is declared protected. This is because the Test class extends class
   Addition and the protected modifier allows the access of protected members in subclasses (in any
   packages).
   Addition.java
package abcpackage;
public class Addition {

   protected int addTwoNumbers(int a, int b){
        return a+b;
   }
}

   Test.java
package xyzpackage;
import abcpackage.*;
class Test extends Addition{
   public static void main(String args[]){
        Test obj = new Test();
        System.out.println(obj.addTwoNumbers(11, 22));
   }
}

   Output:
33

4. Public access modifier
   The members, methods and classes that are declared public can be accessed from anywhere. This
   modifier doesn’t put any restriction on the access.

public access modifier example in java

   Lets take the same example that we have seen above but this time the method addTwoNumbers() has
   public modifier and class Test is able to access this method without even extending the Addition
   class. This is because public modifier has visibility everywhere.
   Addition.java
package abcpackage;

public class Addition {

   public int addTwoNumbers(int a, int b){
        return a+b;
   }
}

   Test.java
package xyzpackage;
import abcpackage.*;
class Test{
   public static void main(String args[]){
      Addition obj = new Addition();
      System.out.println(obj.addTwoNumbers(100, 1));
   }
}

   Output:
101

   Lets see the scope of these access modifiers in tabular form:

The scope of access modifiers in tabular form

------------+-------+---------+--------------+--------------+--------
            | Class | Package | Subclass     | Subclass     |Outside|
            |       |         |(same package)|(diff package)|Class  |
————————————+———————+—————————+——————————----+—————————----—+————————
public      | Yes   |  Yes    |    Yes       |    Yes       |   Yes |
————————————+———————+—————————+—————————----—+—————————----—+————————
protected   | Yes   |  Yes    |    Yes       |    Yes       |   No  |
————————————+———————+—————————+————————----——+————————----——+————————
default     | Yes   |  Yes    |    Yes       |    No        |   No  |
————————————+———————+—————————+————————----——+————————----——+————————
private     | Yes   |  No     |    No        |    No        |   No  |
------------+-------+---------+--------------+--------------+--------


---
https://beginnersbook.com/2013/04/java-garbage-collection/

Garbage Collection in Java

   When JVM starts up, it creates a heap area which is known as runtime data area. This is where all the
   objects (instances of class) are stored. Since this area is limited, it is required to manage this
   area efficiently by removing the objects that are no longer in use. The process of removing unused
   objects from heap memory is known as Garbage collection and this is a part of memory management in
   Java.

   Languages like C/C++ don’t support automatic garbage collection, however in java, the garbage
   collection is automatic.

   Now we know that the garbage collection in java is automatic. Lets see when does java performs
   garbage collection.

When does java perform garbage collection?

   1. When the object is no longer reachable:

BeginnersBook obj = new BeginnersBook();
obj = null;

   Here the reference obj was pointing to the object of class BeginnersBook but since we have assigned a
   null value to it, this is no longer pointing to that object, which makes the BeginnersBook object
   unreachable and thus unusable. Such objects are automatically available for garbage collection in
   Java.

   Another example is:
char[] sayhello = { 'h', 'e', 'l', 'l', 'o'};
String str = new String(sayhello);
str = null;

   Here the reference str of String class was pointing to a string “hello” in the heap memory but since
   we have assigned the null value to str, the object “hello” present in the heap memory is unusable.

   2. When one reference is copied to another reference:
BeginnersBook obj1 = new BeginnersBook();
BeginnersBook obj2 = new BeginnersBook();
obj2 = obj1;

   Here we have assigned the reference obj1 to obj2, which means the instance (object) pointed by
   (referenced by) obj2 is not reachable and available for garbage collection.

How to request JVM for garbage collection
   We now know that the unreachable and unusable objects are available for garbage collection but the
   garbage collection process doesn’t happen instantly. Which means once the objects are ready for
   garbage collection they must to have to wait for JVM to run the memory cleanup program that performs
   garbage collection. However you can request to JVM for garbage collection by calling System.gc()
   method (see the example below).

Garbage Collection Example in Java
   In this example we are demonstrating the garbage collection by calling System.gc(). In this code we
   have overridden a finalize() method. This method is invoked just before a object is destroyed by
   java garbage collection process. This is the reason you would see in the output that this method has
   been invoked twice.
public class JavaExample{
   public static void main(String args[]){
        /* Here we are intentionally assigning a null
         * value to a reference so that the object becomes
         * non reachable
         */
        JavaExample obj=new JavaExample();
        obj=null;

        /* Here we are intentionally assigning reference a
         * to the another reference b to make the object referenced
         * by b unusable.
         */
        JavaExample a = new JavaExample();
        JavaExample b = new JavaExample();
        b = a;
        System.gc();
   }
   protected void finalize() throws Throwable
   {
        System.out.println("Garbage collection is performed by JVM");
   }
}

   Output:
Garbage collection is performed by JVM
Garbage collection is performed by JVM


---
https://beginnersbook.com/2013/05/inner-class/

Inner classes in java: Anonymous inner and static nested class

What is an inner class?
   Inner class are defined inside the body of another class (known as outer class). These classes can
   have access modifier or even can be marked as abstract and final. Inner classes have special
   relationship with outer class instances. This relationship allows them to have access to outer class
   members including private members too.

Inner classes can be defined in four different following ways as mentioned below:
   1) Inner class
   2) Method – local inner class
   3) Anonymous inner class
   4) Static nested class

1) Inner class
   An inner class is declared inside the curly braces of another enclosing class. Inner class is coded
   inside a Top level class as shown below:-
//Top level class definition
class MyOuterClassDemo {
   private int myVar= 1;

   // inner class definition
   class MyInnerClassDemo {
      public void seeOuter () {
         System.out.println("Value of myVar is :" + myVar);
      }
    } // close inner class definition
} // close Top level class definition

   Inner class acts as a member of the enclosing class and can have any access modifiers: abstract,
   final, public, protected, private, static.
   Inner class can access all members of the outer class including those marked private as shown in the
   above example where inner class is accessing the private variable "myVar" of outer class.
   [INS: :INS]

   Instantiating an inner class
   To instantiate an instance of inner class, there should be a live instance of outer class. An inner
   class instance can be created only from an outer class instance. An inner class shares a special
   relationship with an instance of the enclosing class.
   Instantiating an inner class from within code in outer class:
class MyOuterClassDemo {
   private int x= 1;
   public void innerInstance()
   {
       MyInnerClassDemo inner = new MyInnerClassDemo();
       inner. seeOuter();
   }
   public static void main(String args[]){
       MyOuterClassDemo obj = new MyOuterClassDemo();
       obj.innerInstance();
   }
   // inner class definition
   class MyInnerClassDemo {
       public void seeOuter () {
          System.out.println("Outer Value of x is :" + x);
       }
   } // close inner class definition
} // close Top level class definition

   Output:
Outer Value of x is :1

   Instantiating an inner class from outside the outer class Instance Code:
   The public static void main code in the above example can be replaced with this one. It will also
   give the same output.
public static void main(String args[]){
   MyOuterClassDemo.MyInnerClassDemo inner = new MyOuterClassDemo().new MyInnerClassDemo();
   inner. seeOuter();
}

2) Method–Local inner classes
   A method local inner class is defined within a method of the enclosing class. If you want to use
   inner class , you must instantiate the inner class in the same method, but after the class definition
   code. Only two modifiers are allowed for method-local inner class which are abstract and final.The
   inner class can use the local variables of the method (in which it is present), only if they are
   marked final.
//Top level class definition
class MyOuterClassDemo {
   private int x= 1;

   public void doThings(){
      String name ="local variable";
      // inner class defined inside a method of outer class
      class MyInnerClassDemo {
        public void seeOuter () {
           System.out.println("Outer Value of x is :" + x);
           System.out.println("Value of name is :" + name);//compilation error!!
        } //close inner class method
      } // close inner class definition
   } //close Top level class method
} // close Top level class

   The above code will throw a compilation error as Inner class cannot use the non-final variables of
   the method, in which it is defined.
   This is how it can be fixed: If we mark the variable as final then inner class can use it.
final String name ="local variable";// inner object can use it

3) Anonymous Inner Classes
   It is a type of inner class which
    1. has no name
    2. can be instantiated only once
    3. is usually declared inside a method or a code block ,a curly braces ending with semicolon.
    4. is accessible only at the point where it is defined.
    5. does not have a constructor simply because it does not have a name
    6. cannot be static

   Example:
package beginnersbook.com;
class Pizza{
   public void eat()
   {
      System.out.println("pizza");
   }
}
class Food {
   /* There is no semicolon(;)
    * semicolon is present at the curly braces of the method end.
    */
   Pizza p = new Pizza(){
      public void eat()
      {
         System.out.println("anonymous pizza");
      }
   };
}

4) Static Nested Classes
   A static nested classes are the inner classes marked with static modifier.Because this is static in
   nature so this type of inner class doesn’t share any special kind of relationship with an instance of
   outer class.A static nested class cannot access non static members of outer class.

   Example:
class Outer{
   static class Nested{}
}

   A static nested class can be instantiated like this:
class Outer{// outer class
   static class Nested{}// static nested class
}

class Demo{
   public static void main(string[] args){
      // use both class names
      Outer.Nested n= new Outer.Nested();
   }
}

   Reference(s)
   Java 2 by Kathy Sierra and Bert Bates


---
https://beginnersbook.com/2013/05/java-static-import/

Java static import with example

   Static import allows you to access the static member of a class directly without using the fully
   qualified name.
   To understand this topic, you should have the knowledge of packages in Java. Static imports are
   used for saving your time by making you type less. If you hate to type same thing again and again
   then you may find such imports interesting.

   Lets understand this with the help of examples:

Example 1: Without Static Imports

class Demo1{
   public static void main(String args[])
   {
      double var1= Math.sqrt(5.0);
      double var2= Math.tan(30);
      System.out.println("Square of 5 is:"+ var1);
      System.out.println("Tan of 30 is:"+ var2);
   }
}

   Output:
Square of 5 is:2.23606797749979
Tan of 30 is:-6.405331196646276

Example 2: Using Static Imports

import static java.lang.System.out;
import static java.lang.Math.*;
class Demo2{
   public static void main(String args[])
   {
      //instead of Math.sqrt need to use only sqrt
      double var1= sqrt(5.0);
      //instead of Math.tan need to use only tan
      double var2= tan(30);
      //need not to use System in both the below statements
      out.println("Square of 5 is:"+var1);
      out.println("Tan of 30 is:"+var2);
   }
}

   Output:

Square of 5 is:2.23606797749979
Tan of 30 is:-6.405331196646276

   Points to note:
   1) Package import syntax:
import static java.lang.System.out;
import static java.lang.Math.*;

   2) Note comments given in the above code.

When to use static imports?
   If you are going to use static variables and methods a lot then it’s fine to use static imports. for
   example if you wanna write a code with lot of mathematical calculations then you may want to use
   static import.
   Drawbacks
   It makes the code confusing and less readable so if you are going to use static members very few
   times in your code then probably you should avoid using it. You can also use wildcard(*) imports.


---
https://beginnersbook.com/2013/05/static-constructor/

Java static constructor – Is it really Possible to have them in Java?

   Have you heard of static constructor in Java? I guess yes but the fact is that they are not allowed
   in Java. A constructor can not be marked as static in Java.  Before I explain the reason let’s have a
   look at the following piece of code:
public class StaticTest
{
     /* See below - I have marked the constructor as static */
     public static StaticTest()
     {
         System.out.println("Static Constructor of the class");
     }
     public static void main(String args[])
     {
         /*Below: I'm trying to create an object of the class
          *that should invoke the constructor
          */
         StaticTest obj = new StaticTest();
     }
}

   Output: You would get the following error message when you try to run the above java code.
   “modifier static not allowed here”

Why java doesn’t support static constructor?
   It’s actually pretty simple to understand – Everything that is marked static belongs to the class
   only, for example static method cannot be inherited in the sub class because they belong to the class
   in which they have been declared. Refer static keyword.
   Lets back to the point, since each constructor is being called by its subclass during creation of the
   object of its subclass, so if you mark constructor as static the subclass will not be able to access
   the constructor of its parent class because it is marked static and thus belong to the class only.
   This will violate the whole purpose of inheritance concept and that is reason why a constructor
   cannot be static.

   Let’s understand this with the help of an example –

   StaticConstructorExample
public class StaticDemo
{
     public StaticDemo()
     {
         /*Constructor of this class*/
         System.out.println("StaticDemo");
     }
}
public class StaticDemoChild extends StaticDemo
{
     public StaticDemoChild()
     {
          /*By default super() is hidden here */
          System.out.println("StaticDemoChild");
     }
     public void display()
     {
          System.out.println("Just a method of child class");
     }
     public static void main(String args[])
     {
          StaticDemoChild obj = new StaticDemoChild();
          obj.display();
     }
}

   Output:
   StaticDemo
   StaticDemoChild
   Just a method of child class

   Did you notice? When we created the object of child class, it first invoked the constructor of parent
   class and then the constructor of it’s own class. It happened because the new keyword creates the
   object and then invokes the constructor for initialization, since every child class constructor by
   default has super() as first statement which calls it’s parent class’s constructor. The statement
   super() is used to call the parent class(base class) constructor.

   This is the reason why constructor cannot be static – Because if we make them static they cannot be
   called from child class thus object of child class cannot be created.

     Another good point mentioned by Prashanth in the comment section: Constructor definition should
     not be static because constructor will be called each and every time when object is created. If
     you made constructor as static then the constructor will be called before object creation same
     like main method.

Static Constructor Alternative – Static Blocks
   Java has static blocks which can be treated as static constructor. Let’s consider the below program –

   Static-Block-Example
public class StaticDemo{
    static{
        System.out.println("static block of parent class");
    }
}
public class StaticDemoChild extends StaticDemo{
    static{
        System.out.println("static block of child class");
    }
    public void display()
    {
        System.out.println("Just a method of child class");
    }
    public static void main(String args[])
    {
        StaticDemoChild obj = new StaticDemoChild();
        obj.display();
    }
}

   Output:
   static block of parent class
   static block of child class
   Just a method of child class

   In the above example we have used static blocks in both the classes which worked perfectly. We cannot
   use static constructor so it’s a good alternative if we want to perform a static task during object
   creation.


---
https://beginnersbook.com/2013/05/java-interview-questions/

100+ Core Java Interview Questions

   Hi Friends, In this article, we have shared 100+ java interview questions for both beginners and
   experienced folks.

Table of Contents

    1. Basic Questions
    2. OOPs interview Questions
    3. Exception handling interview Questions
    4. Java Multithreading interview Questions
    5. Serialization interview Questions
    6. String Interview Questions
    7. Java Collections interview Questions
    8. Applet interview Questions

Basic Questions

   Q) Is Java platform independent?
   Yes. Java is a platform independent language. We can write java code on one platform and run it on
   another platform. For e.g. we can write and compile the code on windows and can run it on Linux or
   any other supported platform. This is one of the main features of java.

   Q) What all memory areas are allocated by JVM?
   Heap, Stack, Program Counter Register and Native Method Stack

   Q) Java vs. C ++?
   The following features of java make it different from the C++:
   [INS: :INS]
     * Simple
     * Multi-threaded
     * Distributed Application
     * Robust
     * Security
     * Complexities are removed (Pointers, Operator overloading, Multiple inheritance).

   Q) What is javac ?
   It produces the java byte code from *.java file. It is the intermediate representation of your source
   code that contains instructions.

   Q) What is class?
   Class is nothing but a template that describes the data and behavior associated with instances of
   that class

   Q) What is the base class of all classes?
   java.lang.Object

   Q) Path and ClassPath
   Path specifies the location of .exe files while classpath is used for specifying the location of
   .class files.

   Q) Different Data types in Java.
     * byte – 8 bit (are esp. useful when working with a stream of data from a network or a file).
     * short – 16 bit
     * char – 16 bit Unicode
     * int – 32 bit (whole number)
     * float – 32 bit (real number)
     * long – 64 bit (Single precision)
     * double – 64 bit (double precision)

   Note: Any time you have an integer expression involving bytes, shorts, ints and literal numbers, the
   entire expression is promoted to int before the calculation is done.

   Q) What is Unicode?
   Java uses Unicode to represent the characters. Unicode defines a fully international character set
   that can represent all of the characters found in human languages.

   Q) What are Literals?
   A literal is a value that may be assigned to a primitive or string variable or passed as an argument
   to a method.

   Q) Dynamic Initialization?
   Java allows variables to be initialized dynamically, using any expression valid at the time the
   variable is declared.

   Q) What is Type casting in Java?
   To create a conversion between two incompatible types, we must use a cast. There are two types of
   casting in java: automatic casting (done automatically) and explicit casting (done by programmer).

   Q) Arrays?
   An array is a group of fixed number of same type values. Read more about Arrays here.

   Q) What is BREAK statement in java?
   It is also referred as terminator. In Java, the break statement can be used in following two cases:
     * It terminates a statement sequence in a switch-case statement.
     * It can be used to come out of a loop

   Q) Why can’t I do myArray.length () ? Arrays are just objects, right?
   Yes, the specification says that arrays are object references just like classes are. You can even
   invoke the methods of Object such as toString () and hashCode () on an array. However, length is a
   data item of an array and not a method. So you have to use myArray.length.

   Q) How can I put all my classes and resources into one file and run it?
   Use a JAR file. Put all the files in a JAR, then run the app like this:

   Java -jar [-options] jarfile [args...]

   Q) Can I declare a data type inside loop in java?
   Any Data type declaration should not be inside the loop.

   Q) Advantage over jdk 1.0 vs. jdk 1.1 ?
   Jdk1.1 release consists of Java Unicode character to support the multiple language fonts, along with
   Event Handling, Java security, Java Beans, RMI, SQL are the major feature provided.

   Q) java.lang.* get imported by default. For using String and Exception classes, you don’t need to
   explicitly import this package. The major classes inside this package are
     * Object class
     * Data type wrapper classes
     * Math class
     * String class
     * System and Runtime classes
     * Thread classes
     * Exception classes
     * Process classes
     * Class classes

   Q) Arrays can be defined in different ways. Write them down.
int arr[] = null;
int arr[][] = new int arr[][];
int [][] arr = new arr [][];
int [] arr [] = new arr[][];

OOPs Interview Questions

   Q) Four main principles of OOPS language?
     * Inheritance
     * Polymorphism
     * Data Encapsulation
     * Abstraction

   Q) What is inheritance?
   The process by which one class acquires the properties and functionalities of another class.
   Inheritance brings reusability of code in a java application. Read more here.

   Q) Does Java support Multiple Inheritances?
   When a class extends more than one classes then it is called multiple inheritance. Java doesn’t
   support multiple inheritance whereas C++ supports it, this is one of the difference between java and
   C++.  Refer this: Why java doesn’t support multiple inheritance?

   Q) What is Polymorphism and what are the types of it?
   Polymorphism is the ability of an object to take many forms. The most common use of polymorphism in
   OOPs is to have more than one method with the same name in a single class. There are two types of
   polymorphism: static polymorphism and dynamic polymorphism, read them in detail here.

   Q) What is the method overriding?
   It is a feature using which a child class overrides the method of parent class. It is only applicable
   when the method in child class has the signature same as parent class. Read more about method
   overriding here.

   Q) Can we override a static method?
   No, we cannot override a static method.

   Q) What is method overloading?
   Having more than one method with the same name but different number, sequence or types of arguments
   is known is method overloading. Read more about it here.

   Q) Does Java support operator overloading?
   Operator overloading is not supported in Java.

   Q) Can we overload a method by just changing the return type and without changing the signature of
   method?
   No, We cannot do this.

   Q) Is it possible to overload main() method of a class?
   Yes, we can overload main() method as well.

   Q) What is the difference between method overloading and method overriding?
   There are several differences; You can read them here: Overloading Vs Overriding.

   Q) What is static and dynamic binding?
   Binding refers to the linking of method call to its body. A binding that happens at compile time is
   known as static binding while binding at runtime is known as dynamic binding.

   Q) What is Encapsulation?
   Encapsulation means the localization of the information or knowledge within an object.
   Encapsulation is also called as “Information Hiding”. Read it here in detail.

   Q) Abstract class?
   An abstract class is a class which can’t be instantiated (we cannot create the object of abstract
   class), we can only extend such classes. It provides the generalized form that will be shared by all
   of its subclasses, leaving it to each subclass to fill in the details. We can achieve partial
   abstraction using abstract classes, to achieve full abstraction we use interfaces.

   Q) What is Interface in java?
   An interface is a collection of abstract methods. A class implements an interface, thereby inheriting
   the abstract methods of the interface. Read more about interface here.

   Q) What is the difference between abstract class and interface?
   1) abstract class can have abstract and non-abstract methods. An interface can only have abstract
   methods.
   2) An abstract class can have static methods but an interface cannot have static methods.
   3) abstract class can have constructors but an interface cannot have constructors.

   Q) Which access modifiers can be applied to the inner classes?
   public ,private , abstract, final, protected.

   Q) What are Constructors?
   Constructors are used for creating an instance of a class, they are invoked when an instance of class
   gets created. Constructor name and class name should be same and it doesn’t have a return type.
   Read more about constructors here.

   Q) Can we inherit the constructors?
   No, we cannot inherit constructors.

   Q) Can we mark constructors final?
   No, Constructor cannot be declared final.

   Q) What is default and parameterized constructors?
   Default: Constructors with no arguments are known as default constructors, when you don’t declare any
   constructor in a class, compiler creates a default one automatically.

   Parameterized: Constructor with arguments are known as parameterized constructors.

   Q) Can a constructor call another constructor?
   Yes. A constructor can call the another constructor of same class using this keyword. For e.g. this()
   calls the default constructor.
   Note: this() must be the first statement in the calling constructor.

   Q) Can a constructor call the constructor of parent class?
   Yes. In fact it happens by default. A child class constructor always calls the parent class
   constructor. However we can still call it using super keyword. For e.g. super() can be used for
   calling super class default constructor.

   Note: super() must be the first statement in a constructor.

   Q)THIS keyword?
   The THIS keyword is a reference to the current object.

   Q) Can this keyword be assigned null value?
   No, this keyword cannot have null values assigned to it.

   Q) Explain ways to pass the arguments in Java?
   In java, arguments can be passed in 2 ways,

   Pass by value – Changes made to the parameter of the subroutines have no effect on the argument used
   to call it.
   Pass by reference – Changes made to the parameter will affect the argument used to call the
   subroutine.

   Q) What is static variable in java?
   Static variables are also known as class level variables. A static variable is same for all the
   objects of that particular class in which it is declared.

   Q) What is static block?
   A static block gets executed at the time of class loading. They are used for initializing static
   variables.

   Q) What is a static method?
   Static methods can be called directly without creating the instance (Object) of the class. A static
   method can access all the static variables of a class directly but it cannot access non-static
   variables without creating instance of class.

   Q) Explain super keyword in Java?
   super keyword references to the parent class. There are several uses of super keyword:
     * It can be used to call the superclass(Parent class) constructor.
     * It can be used to access a method of the superclass that has been hidden by subclass (Calling
       parent class version, In case of method overriding).
     * To call the constructor of parent class.

   Q) Use of final keyword in Java?
   Final methods – These methods cannot be overridden by any other method.
   Final variable – Constants, the value of these variable can’t be changed, its fixed.
   Final class – Such classes cannot be inherited by other classes. These type of classes will be used
   when application required security or someone don’t want that particular class. More details.

   Q) What is a Object class?
   This is a special class defined by java; all other classes are subclasses of object class. Object
   class is superclass of all other classes. Object class has the following methods
     * objectClone () – to creates a new object that is same as the object being cloned.
     * boolean equals(Object obj) – determines whether one object is equal to another.
     * finalize() – Called by the garbage collector on an object when garbage collection determines that
       there are no more references to the object. A subclass overrides the finalize method to dispose
       of system resources or to perform other cleanup.
     * toString () – Returns a string representation of the object.

   Q) What are Packages?
   A Package can be defined as a grouping of related types (classes, interfaces, enumerations and
   annotations )

   Q)What is the difference between import java.util.Date and java.util.* ?
   The star form (java.util.* ) includes all the classes of that package and that may increase the
   compilation time – especially if you import several packages. However it doesn’t have any effect
   run-time performance.

   Q) What is static import?
   Read it here.

   Q) Garbage collection in java?
   Since objects are dynamically allocated by using the new operator, java handles the de-allocation of
   the memory automatically when no references to an object exist for a long time is called garbage
   collection. The whole purpose of Garbage collection is efficient memory management.

   Q) Use of finalize() method in java?
   finalize() method is used to free the allocated resource.

   Q) How many times does the garbage collector calls the finalize() method for an object?
   The garbage collector calls the finalize() method Only once for an object.

   Q) What are two different ways to call garbage collector?
   System.gc() OR Runtime.getRuntime().gc().

   Q) Can the Garbage Collection be forced by any means?
   No, its not possible. you cannot force garbage collection. you can call system.gc() methods for
   garbage collection but it does not guarantee that garbage collection would be done.

Exception handling Interview Questions

   Q) What is an exception?
   Exceptions are abnormal conditions that arise during execution of the program. It may occur due to
   wrong user input or wrong logic written by programmer.

   Q) Exceptions are defined in which java package? OR which package has definitions for all the
   exception classes?
   Java.lang.Exception
   This package contains definitions for Exceptions.

   Q) What are the types of exceptions?
   There are two types of exceptions: checked and unchecked exceptions.
   Checked exceptions: These exceptions must be handled by programmer otherwise the program would throw
   a compilation error.
   Unchecked exceptions: It is up to the programmer to write the code in such a way to avoid unchecked
   exceptions. You would not get a compilation error if you do not handle these exceptions. These
   exceptions occur at runtime.

   Q) What is the difference between Error and Exception?
   Error: Mostly a system issue. It always occur at run time and must be resolved in order to proceed
   further.
   Exception: Mostly an input data issue or wrong logic in code. Can occur at compile time or run time.

   Q) What is throw keyword in exception handling?
   The throw keyword is used for throwing user defined or pre-defined exception.

   Q) What is throws keyword?
   If a method does not handle a checked exception, the method must declare it using the throwskeyword.
   The throws keyword appears at the end of a method’s signature.

   Q) Difference between throw and throws in Java
   Read the difference here: Java – throw vs throws.

   Q) Can static block throw exception?
   Yes, A static block can throw exceptions. It has its own limitations: It can throw only Runtime
   exception (Unchecked exceptions), In order to throw checked exceptions you can use a try-catch block
   inside it.

   Q) What is finally block?
   Finally block is a block of code that always executes, whether an exception occurs or not.
   Finally block follows try block or try-catch block.

   Q) ClassNotFoundException vs NoClassDefFoundError?
   1) ClassNotFoundException occurs when loader could not find the required class in class path.
   2) NoClassDefFoundError occurs when class is loaded in classpath, but one or more of the class which
   are required by other class, are removed or failed to load by compiler.

   Q) Can we have a try block without catch or finally block?
   No, we cannot have a try block without catch or finally block. We must have either one of them or
   both.

   Q) Can we have multiple catch blocks following a single try block?
   Yes we can have multiple catch blocks in order to handle more than one exception.

   Q) Is it possible to have finally block without catch block?
   Yes, we can have try block followed by finally block without even using catch blocks in between.

   When a finally block does not get executed?
   The only time finally won’t be called is if you call System.exit() or if the JVM crashes first.

   Q) Can we handle more than one exception in a single catch block?
   Yes we can do that using if-else statement but it is not considered as a good practice. We should
   have one catch block for one exception.

   Q) What is a Java Bean?
   A JavaBean is a Java class that follows some simple conventions including conventions on the names of
   certain methods to get and set state called Introspection. Because it follows conventions, it can
   easily be processed by a software tool that connects Beans together at runtime. JavaBeans are
   reusable software components.

Java Multithreading Interview Questions

   Q) What is Multithreading?
   It is a process of executing two or more part of a program simultaneously. Each of these parts is
   known as threads. In short the process of executing multiple threads simultaneously is known as
   multithreading.

   Q) What is the main purpose of having multithread environment?
   Maximizing CPU usage and reducing CPU idle time

   Q) What are the main differences between Process and thread? Explain in brief.
   1)  One process can have multiple threads. A thread is a smaller part of a process.
   2)  Every process has its own memory space, executable code and a unique process identifier (PID)
   while every thread has its own stack in Java but it uses process main memory and shares it with other
   threads.
   3) Threads of same process can communicate with each other using keyword like wait and notify etc.
   This process is known as inter process communication.

   Q) How can we create a thread in java?
   There are following two ways of creating a thread:
   1)  By Implementing Runnable interface.
   2)  By Extending Thread class.

   Q) Explain yield and sleep?
   yield() – It causes the currently executing thread object to temporarily pause and allow other
   threads to execute.

   sleep() – It causes the current thread to suspend execution for a specified period. When a thread
   goes into sleep state it doesn’t release the lock.

   Q) What is the difference between sleep() and wait()?
   sleep() – It causes the current thread to suspend execution for a specified period. When a thread
   goes into sleep state it doesn’t release the lock

   wait() – It causes current thread to wait until either another thread invokes the notify() method or
   the notifyAll() method for this object, or a specified amount of time has elapsed.

   Q) What is a daemon thread?
   A daemon thread is a thread, that does not prevent the JVM from exiting when the program finishes but
   the thread is still running. An example for a daemon thread is the garbage collection.

   Q) What does join( ) method do?
   if you use join() ,it makes sure that as soon as a thread calls join,the current thread(yes,currently
   running thread) will not execute unless the thread you have called join is finished.

   Q) Preemptive scheduling vs. time slicing?
   1) The preemptive scheduling is prioritized. The highest priority process should always be the
   process that is currently utilized.
   2) Time slicing means task executes for a defined slice/ period of time and then enter in the pool of
   ready state. The scheduler then determines which task execute next based on priority or other factor.

   Q) Can we call run() method of a Thread class?
   Yes, we can call run() method of a Thread class but then it will behave like a normal method. To
   actually execute it in a Thread, you should call Thread.start() method to start it.

   Q) What is Starvation?
   Starvation describes a situation where a thread is unable to gain regular access to shared resources
   and is unable to make progress. This happens when shared resources are made unavailable for long
   periods by “greedy” threads. For example, suppose an object provides a synchronized method that often
   takes a long time to return. If one thread invokes this method frequently, other threads that also
   need frequent synchronized access to the same object will often be blocked.

   Q) What is deadlock?
   Deadlock describes a situation where two or more threads are blocked forever, waiting for each other.

Serialization interview Questions

   Q: What is Serialization and de-serialization?
   Serialization is a process of converting an object and its attributes to the stream of bytes.
   De-serialization is recreating the object from stream of bytes; it is just a reverse process of
   serialization. To know more about serialization with example program, refer this article.

   Q) Do we need to implement any method of Serializable interface to make an object serializable?
   No. In order to make an object serializable we just need to implement the interface Serializable. We
   don’t need to implement any methods.

   Q) What is a transient variable?
   1) transient variables are not included in the process of serialization.
   2) They are not the part of the object’s serialized state.
   3) Variables which we don’t want to include in serialization are declared as transient.

String interview questions

   Q) A string class is immutable or mutable?
   String class is immutable that’s the reason once its object gets created, it cannot be changed
   further.

   Q) Difference between StringBuffer and StringBuilder class?
   1) StringBuffer is thread-safe but StringBuilder is not thread safe.
   2) StringBuilder is faster than StringBuffer.
   3) StringBuffer is synchronized whereas StringBuilder is not synchronized.

   Q) What is toString() method in Java?
   The toString() method returns the string representation of any object.

Java collections interview questions

   Q) What is List?
   Elements can be inserted or accessed by their position in the list, using a zero-based index.
   A list may contain duplicate elements.

   Q) What is Map?
   Map interface maps unique keys to values. A key is an object that we use to retrieve a value later. A
   map cannot contain duplicate keys: Each key can map to at most one value.

   Q) What is Set?
   A Set is a Collection that cannot contain duplicate elements.

   Q) Why ArrayList is better than Arrays?
   Array can hold fixed number of elements. ArrayList can grow dynamically.

   Q) What is the difference between ArrayList and LinkedList?
   1) LinkedList store elements within a doubly-linked list data structure. ArrayList store elements
   within a dynamically resizing array.
   2) LinkedList is preferred for add and update operations while ArrayList is a good choice for search
   operations. Read more here.

   Q) For addition and deletion. Which one is most preferred: ArrayList or LinkedList?
   LinkedList. Because deleting or adding a node in LinkedList is faster than ArrayList.

   Q) For searches. Which one is most preferred: ArrayList or LinkedList?
   ArrayList. Searching an element is faster in ArrayList compared to LinkedList.

   Q) What is the difference between ArrayList and Vector?
   1) Vector is synchronized while ArrayList is not synchronized.
   2) By default, Vector doubles the size of its array when it is re-sized internally. ArrayList
   increases by half of its size when it is re-sized. More details.

   Q) What is the difference between Iterator and ListIterator?
   Following are the major differences between them:
   1) Iterator can be used for traversing Set, List and Map. ListIterator can only be used for
   traversing a List.
   2) We can traverse only in forward direction using Iterator. ListIterator can be used for traversing
   in both the directions(forward and backward). Read more at: ListIterator vs Iterator.

   Q) Difference between TreeSet and SortedSet?
   TreeSet implements SortedSet interface.

   Q) What is the difference between HashMap and Hashtable?
   1) Hashtable is synchronized. HashMap is not synchronized.
   2) Hashtable does not allow null keys or values. HashMap allows one null key and any number of null
   values. Read more here.

   Q) What is the difference between Iterator and Enumeration?
   1) Iterator allows to remove elements from the underlying collection during the iteration using its
   remove() method. We cannot add/remove elements from a collection when using enumerator.
   2) Iterator has improved method names.
   Enumeration.hasMoreElement() -> Iterator.hasNext()
   Enumeration.nextElement() -> Iterator.next().

Applet Interview Questions

   Q) How do you do file I/O from an applet?
   Unsigned applets are simply not allowed to read or write files on the local file system .

   Unsigned applets can, however, read (but not write) non-class files bundled with your applet on the
   server, called resource files

   Q) What is container ?
   A component capable of holding another component is called as container.
   Container
   Panel
   Applet
   Window
   Frame
   Dialog

   Learning)
    1. Flow Layout is default for panel.
    2. Border Layout is default for Frames.

   Q) On Windows, generally frames are invisible, how to make it visible. ?
Frame f = new Frame();
f.setSize(300,200);  //height and width
f.setVisible(true) ;  // Frames appears

   Q) JFC – Java Foundation Class
   Swing
   AWT
   Java2D
   Drag and Drop
   Accessibility

   Learning) Listeners and Methods?
   ActionListerner – actionPerformed();
   ItemListerner – itemStateChanged();
   TextListener – textValueChanged();
   FocusListener – focusLost(); & FocusGained();

   WindowListener – windowActified(); windowDEactified(); windowIconified(); windowDeiconified();
   windowClosed(); windowClosing(); windowOpened();

   MouseMotionListener – mouseDragged(); & mouseMoved();

   MouseListener – mousePressed(); mouseReleased(); mouseEntered(); mouseExited(); mouseClicked();

   Learnings)
   parseInt – to convert string to int.
   getBytes – string to byte array

   Q) Applet Life cycle?
   Following stage of any applets life cycle, starts with init(), start(), paint(), stop() and
   destroy().

   Q) showStatus() ?–
   To display the message at the bottom of the browser when applet is started.

   Q) What is the Event handling?
   Is irrespective of any component, if any action performed/done on Frame, Panel or on window, handling
   those actions are called Event Handling.

   Q) What is Adapter class?
   Adapter class is an abstract class.

   Advantage of adapter: To perform any window listener, we need to include all the methods used by the
   window listener whether we use those methods are not in our class like Interfaces whereas with
   adapter class, its sufficient to include only the methods required to override. Straight opposite to
   Interface.

   Further readings:
   If you have finished reading above interview questions then you can go through the below tutorials to
   sharpen your knowledge in java. We will keep adding new question and answers to the above list.


---
https://beginnersbook.com/2013/12/java-strings/

Java – String Class and its methods explained with examples

   String is a sequence of characters, for e.g. “Hello” is a string of 5 characters. In java, string is
   an immutable object which means it is constant and can cannot be changed once it has been created. In
   this tutorial we will learn about String class and String methods in detail along with many other
   Java String tutorials.

Creating a String
   There are two ways to create a String in Java
    1. String literal
    2. Using new keyword

String literal
   In java, Strings can be created like this: Assigning a String literal to a String instance:
String str1 = "Welcome";
String str2 = "Welcome";

   The problem with this approach: As I stated in the beginning that String is an object in Java.
   However we have not created any string object using new keyword above. The compiler does that task
   for us it creates a string object having the string literal (that we have provided , in this case it
   is “Welcome”) and assigns it to the provided string instances.

   But if the object already exist in the memory it does not create a new Object rather it assigns the
   same old object to the new instance, that means even though we have two string instances above(str1
   and str2) compiler only created on string object (having the value “Welcome”) and assigned the same
   to both the instances. For example there are 10 string instances that have same value, it means that
   in memory there is only one object having the value and all the 10 string instances would be pointing
   to the same object.

   What if we want to have two different object with the same string? For that we would need to create
   strings using new keyword.

Using New Keyword
   As we saw above that when we tried to assign the same string object to two different literals,
   compiler only created one object and made both of the literals to point the same object. To overcome
   that approach we can create strings like this:
String str1 = new String("Welcome");
String str2 = new String("Welcome");

   In this case compiler would create two different object in memory having the same string.

A Simple Java String Example

public class Example{
   public static void main(String args[]){
        //creating a string by java string literal
        String str = "Beginnersbook";
        char arrch[]={'h','e','l','l','o'};
        //converting char array arrch[] to string str2
        String str2 = new String(arrch);

        //creating another java string str3 by using new keyword
        String str3 = new String("Java String Example");

        //Displaying all the three strings
        System.out.println(str);
        System.out.println(str2);
        System.out.println(str3);
   }
}

   Output:
Beginnersbook
hello
Java String Example

Java String Methods
   Here are the list of the methods available in the Java String class. These methods are explained in
   the separate tutorials with the help of examples. Links to the tutorials are provided below:
    1. char charAt(int index): It returns the character at the specified index. Specified index
       value should be between 0 to length() -1 both inclusive. It throws IndexOutOfBoundsException if
       index<0||>= length of String.
    2. boolean equals(Object obj): Compares the string with the specified string and returns true if
       both matches else false.
    3. boolean equalsIgnoreCase(String string): It works same as equals method but it doesn’t
       consider the case while comparing strings. It does a case insensitive comparison.
    4. int compareTo(String string): This method compares the two strings based on the Unicode value
       of each character in the strings.
    5. int compareToIgnoreCase(String string): Same as CompareTo method however it ignores the case
       during comparison.
    6. boolean startsWith(String prefix, int offset): It checks whether the substring (starting from
       the specified offset index) is having the specified prefix or not.
    7. boolean startsWith(String prefix): It tests whether the string is having specified prefix, if
       yes then it returns true else false.
    8. boolean endsWith(String suffix): Checks whether the string ends with the specified suffix.
    9. int hashCode(): It returns the hash code of the string.
   10. int indexOf(int ch): Returns the index of first occurrence of the specified character ch in
       the string.
   11. int indexOf(int ch, int fromIndex): Same as indexOf method however it starts searching in the
       string from the specified fromIndex.
   12. int lastIndexOf(int ch): It returns the last occurrence of the character ch in the string.
   13. int lastIndexOf(int ch, int fromIndex): Same as lastIndexOf(int ch) method, it starts search
       from fromIndex.
   14. int indexOf(String str): This method returns the index of first occurrence of specified
       substring str.
   15. int lastindexOf(String str): Returns the index of last occurrence of string str.
   16. String substring(int beginIndex): It returns the substring of the string. The substring
       starts with the character at the specified index.
   17. String substring(int beginIndex, int endIndex): Returns the substring. The substring starts
       with character at beginIndex and ends with the character at endIndex.
   18. String concat(String str): Concatenates the specified string “str” at the end of the string.
   19. String replace(char oldChar, char newChar): It returns the new updated string after changing
       all the occurrences of oldChar with the newChar.
   20. boolean contains(CharSequence s): It checks whether the string contains the specified
       sequence of char values. If yes then it returns true else false. It throws NullPointerException
       of ‘s’ is null.
   21. String toUpperCase(Locale locale): Converts the string to upper case string using the rules
       defined by specified locale.
   22. String toUpperCase(): Equivalent to toUpperCase(Locale.getDefault()).
   23. public String intern(): This method searches the specified string in the memory pool and if
       it is found then it returns the reference of it, else it allocates the memory space to the
       specified string and assign the reference to it.
   24. public boolean isEmpty(): This method returns true if the given string has 0 length. If the
       length of the specified Java String is non-zero then it returns false.
   25. public static String join(): This method joins the given strings using the specified
       delimiter and returns the concatenated Java String
   26. String replaceFirst(String regex, String replacement): It replaces the first occurrence of
       substring that fits the given regular expression “regex” with the specified replacement string.
   27. String replaceAll(String regex, String replacement): It replaces all the occurrences of
       substrings that fits the regular expression regex with the replacement string.
   28. String[] split(String regex, int limit): It splits the string and returns the array of
       substrings that matches the given regular expression. limit is a result threshold here.
   29. String[] split(String regex): Same as split(String regex, int limit) method however it does
       not have any threshold limit.
   30. String toLowerCase(Locale locale): It converts the string to lower case string using the
       rules defined by given locale.
   31. public static String format(): This method returns a formatted java String
   32. String toLowerCase(): Equivalent to toLowerCase(Locale. getDefault()).
   33. String trim(): Returns the substring after omitting leading and trailing white spaces from
       the original string.
   34. char[] toCharArray(): Converts the string to a character array.
   35. static String copyValueOf(char[] data): It returns a string that contains the characters of
       the specified character array.
   36. static String copyValueOf(char[] data, int offset, int count): Same as above method with two
       extra arguments – initial offset of subarray and length of subarray.
   37. void getChars(int srcBegin, int srcEnd, char[] dest, int destBegin): It copies the characters
       of src array to the dest array. Only the specified range is being copied(srcBegin to srcEnd) to
       the dest subarray(starting fromdestBegin).
   38. static String valueOf(): This method returns a string representation of passed arguments such
       as int, long, float, double, char and char array.
   39. boolean contentEquals(StringBuffer sb): It compares the string to the specified string
       buffer.
   40. boolean regionMatches(int srcoffset, String dest, int destoffset, int len): It compares the
       substring of input to the substring of specified string.
   41. boolean regionMatches(boolean ignoreCase, int srcoffset, String dest, int destoffset, int
       len): Another variation of regionMatches method with the extra boolean argument to specify
       whether the comparison is case sensitive or case insensitive.
   42. byte[] getBytes(String charsetName): It converts the String into sequence of bytes using the
       specified charset encoding and returns the array of resulted bytes.
   43. byte[] getBytes(): This method is similar to the above method it just uses the default
       charset encoding for converting the string into sequence of bytes.
   44. int length(): It returns the length of a String.
   45. boolean matches(String regex): It checks whether the String is matching with the
       specified regular expression regex.
   46. int codePointAt(int index):It is similar to the charAt method however it returns the Unicode code
       point value of specified index rather than the character itself.


---
https://beginnersbook.com/2013/04/java-exception-handling/

Exception handling in java with examples

   Exception handling is one of the most important feature of java programming that allows us to handle
   the runtime errors caused by exceptions. In this guide, we will learn what is an exception, types of
   it, exception classes and how to handle exceptions in java with examples.

What is an exception?
   An Exception is an unwanted event that interrupts the normal flow of the program. When an exception
   occurs program execution gets terminated. In such cases we get a system generated error message. The
   good thing about exceptions is that they can be handled in Java. By handling the exceptions we can
   provide a meaningful message to the user about the issue rather than a system generated message,
   which may not be understandable to a user.

Why an exception occurs?
   There can be several reasons that can cause a program to throw exception. For example: Opening a
   non-existing file in your program, Network connection problem, bad input data provided by user etc.

Exception Handling
   If an exception occurs, which has not been handled by programmer then program execution gets
   terminated and a system generated error message is shown to the user. For example look at the system
   generated exception below:
   An exception generated by the system is given below

 Exception in thread "main" java.lang.ArithmeticException: / by zero at ExceptionDemo.main(ExceptionDemo.java:
5)
 ExceptionDemo : The class name
 main : The method name
 ExceptionDemo.java : The filename
 java:5 : Line number

   This message is not user friendly so a user will not be able to understand what went wrong. In order
   to let them know the reason in simple language, we handle exceptions. We handle such conditions and
   then prints a user friendly warning message to user, which lets them correct the error as most of the
   time exception occurs due to bad data provided by user.

Advantage of exception handling
   Exception handling ensures that the flow of the program doesn’t break when an exception occurs. For
   example, if a program has bunch of statements and an exception occurs mid way after executing certain
   statements then the statements after the exception will not execute and the program will terminate
   abruptly.
   By handling we make sure that all the statements execute and the flow of program doesn’t break.

Difference between error and exception
   Errors indicate that something severe enough has gone wrong, the application should crash rather than
   try to handle the error.

   Exceptions are events that occurs in the code. A programmer can handle such conditions and take
   necessary corrective actions. Few examples:
   NullPointerException – When you try to use a reference that points to null.
   ArithmeticException – When bad data is provided by user, for example, when you try to divide a number
   by zero this exception occurs because dividing a number by zero is undefined.
   ArrayIndexOutOfBoundsException – When you try to access the elements of an array out of its bounds,
   for example array size is 5 (which means it has five elements) and you are trying to access the 10th
   element.

   Exception classes hierarchy

Types of exceptions
   There are two types of exceptions in Java:
   1)Checked exceptions
   2)Unchecked exceptions

   I have covered this in detail in a separate tutorial: Checked and Unchecked exceptions in Java.

Checked exceptions
   All exceptions other than Runtime Exceptions are known as Checked exceptions as the compiler checks
   them during compilation to see whether the programmer has handled them or not. If these exceptions
   are not handled/declared in the program, you will get compilation error. For example, SQLException,
   IOException, ClassNotFoundException etc.

Unchecked Exceptions
   Runtime Exceptions are also known as Unchecked Exceptions. These exceptions are not checked at
   compile-time so compiler does not check whether the programmer has handled them or not but it’s the
   responsibility of the programmer to handle these exceptions and provide a safe exit. For example,
   ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException etc.

     Compiler will never force you to catch such exception or force you to declare it in the method
     using throws keyword.

What topics are covered in the next tutorials

    1. Try-catch in Java
    2. Nested Try Catch
    3. Checked and unchecked exceptions
    4. Finally block in Java
    5. try-catch-finally
    6. finally block & return statement
    7. Throw exception in Java
    8. Example of throw keyword
    9. Example of throws clause
   10. Throws in Java
   11. throw vs throws
   12. Exception handling examples


---
https://beginnersbook.com/2013/03/multithreading-in-java/

Multithreading in java with examples

   Before we talk about multithreading, let’s discuss threads. A thread is a light-weight smallest part
   of a process that can run concurrently with the other parts(other threads) of the same process.
   Threads are independent because they all have separate path of execution that’s the reason if an
   exception occurs in one thread, it doesn’t affect the execution of other threads. All threads of a
   process share the common memory. The process of executing multiple threads simultaneously is known as
   multithreading.

   Let’s summarize the discussion in points:
   1. The main purpose of multithreading is to provide simultaneous execution of two or more parts of a
   program to maximum utilize the CPU time. A multithreaded program contains two or more parts that can
   run concurrently. Each such part of a program called thread.

   2. Threads are lightweight sub-processes, they share the common memory space. In Multithreaded
   environment, programs that are benefited from multithreading, utilize the maximum CPU time so that
   the idle time can be kept to minimum.

   3. A thread can be in one of the following states:
   NEW – A thread that has not yet started is in this state.
   RUNNABLE – A thread executing in the Java virtual machine is in this state.
   BLOCKED – A thread that is blocked waiting for a monitor lock is in this state.
   WAITING – A thread that is waiting indefinitely for another thread to perform a particular action is
   in this state.
   TIMED_WAITING – A thread that is waiting for another thread to perform an action for up to a
   specified waiting time is in this state.
   TERMINATED – A thread that has exited is in this state.
   A thread can be in only one state at a given point in time.

Multitasking vs Multithreading vs Multiprocessing vs parallel processing
   If you are new to java you may get confused among these terms as they are used quite frequently when
   we discuss multithreading. Let’s talk about them in brief.

   Multitasking: Ability to execute more than one task at the same time is known as multitasking.

   Multithreading: We already discussed about it. It is a process of executing multiple threads
   simultaneously. Multithreading is also known as Thread-based Multitasking.

   Multiprocessing: It is same as multitasking, however in multiprocessing more than one CPUs are
   involved. On the other hand one CPU is involved in multitasking.

   Parallel Processing: It refers to the utilization of multiple CPUs in a single computer system.

Creating a thread in Java
   There are two ways to create a thread in Java:
   1) By extending Thread class.
   2) By implementing Runnable interface.

   Before we begin with the programs(code) of creating threads, let’s have a look at these methods of
   Thread class. We have used few of these methods in the example below.
     * getName(): It is used for Obtaining a thread’s name
     * getPriority(): Obtain a thread’s priority
     * isAlive(): Determine if a thread is still running
     * join(): Wait for a thread to terminate
     * run(): Entry point for the thread
     * sleep(): suspend a thread for a period of time
     * start(): start a thread by calling its run() method

Method 1: Thread creation by extending Thread class

   Example 1:
class MultithreadingDemo extends Thread{
  public void run(){
    System.out.println("My thread is in running state.");
  }
  public static void main(String args[]){
     MultithreadingDemo obj=new MultithreadingDemo();
     obj.start();
  }
}

   Output:
My thread is in running state.

   Example 2:
class Count extends Thread
{
   Count()
   {
     super("my extending thread");
     System.out.println("my thread created" + this);
     start();
   }
   public void run()
   {
     try
     {
        for (int i=0 ;i<10;i++)
        {
           System.out.println("Printing the count " + i);
           Thread.sleep(1000);
        }
     }
     catch(InterruptedException e)
     {
        System.out.println("my thread interrupted");
     }
     System.out.println("My thread run is over" );
   }
}
class ExtendingExample
{
   public static void main(String args[])
   {
      Count cnt = new Count();
      try
      {
         while(cnt.isAlive())
         {
           System.out.println("Main thread will be alive till the child thread is live");
           Thread.sleep(1500);
         }
      }
      catch(InterruptedException e)
      {
        System.out.println("Main thread interrupted");
      }
      System.out.println("Main thread's run is over" );
   }
}

   Output:
my thread createdThread[my runnable thread,5,main]
Main thread will be alive till the child thread is live
Printing the count 0
Printing the count 1
Main thread will be alive till the child thread is live
Printing the count 2
Main thread will be alive till the child thread is live
Printing the count 3
Printing the count 4
Main thread will be alive till the child thread is live
Printing the count 5
Main thread will be alive till the child thread is live
Printing the count 6
Printing the count 7
Main thread will be alive till the child thread is live
Printing the count 8
Main thread will be alive till the child thread is live
Printing the count 9
mythread run is over
Main thread run is over

Method 2: Thread creation by implementing Runnable Interface

   A Simple Example
class MultithreadingDemo implements Runnable{
  public void run(){
    System.out.println("My thread is in running state.");
  }
  public static void main(String args[]){
     MultithreadingDemo obj=new MultithreadingDemo();
     Thread tobj =new Thread(obj);
     tobj.start();
 }
}

   Output:
My thread is in running state.

   Example Program 2:
   Observe the output of this program and try to understand what is happening in this program. If you
   have understood the usage of each thread method then you should not face any issue, understanding
   this example.
class Count implements Runnable
{
   Thread mythread ;
   Count()
   {
      mythread = new Thread(this, "my runnable thread");
      System.out.println("my thread created" + mythread);
      mythread.start();
   }
   public void run()
   {
      try
      {
        for (int i=0 ;i<10;i++)
        {
          System.out.println("Printing the count " + i);
          Thread.sleep(1000);
        }
     }
     catch(InterruptedException e)
     {
        System.out.println("my thread interrupted");
     }
     System.out.println("mythread run is over" );
   }
}
class RunnableExample
{
    public static void main(String args[])
    {
       Count cnt = new Count();
       try
       {
          while(cnt.mythread.isAlive())
          {
            System.out.println("Main thread will be alive till the child thread is live");
            Thread.sleep(1500);
          }
       }
       catch(InterruptedException e)
       {
          System.out.println("Main thread interrupted");
       }
       System.out.println("Main thread run is over" );
    }
}

   Output:
my thread createdThread[my runnable thread,5,main]
Main thread will be alive till the child thread is live
Printing the count 0
Printing the count 1
Main thread will be alive till the child thread is live
Printing the count 2
Main thread will be alive till the child thread is live
Printing the count 3
Printing the count 4
Main thread will be alive till the child thread is live
Printing the count 5
Main thread will be alive till the child thread is live
Printing the count 6
Printing the count 7
Main thread will be alive till the child thread is live
Printing the count 8
Main thread will be alive till the child thread is live
Printing the count 9
mythread run is over
Main thread run is over

Thread priorities
     * Thread priorities are the integers which decide how one thread should be treated with respect to
       the others.
     * Thread priority decides when to switch from one running thread to another, process is called
       context switching
     * A thread can voluntarily release control and the highest priority thread that is ready to run is
       given the CPU.
     * A thread can be preempted by a higher priority thread no matter what the lower priority thread is
       doing. Whenever a higher priority thread wants to run it does.
     * To set the priority of the thread setPriority() method is used which is a method of the class
       Thread Class.
     * In place of defining the priority in integers, we can use MIN_PRIORITY, NORM_PRIORITY or
       MAX_PRIORITY.

Methods: isAlive() and join()
     * In all the practical situations main thread should finish last else other threads which have
       spawned from the main thread will also finish.
     * To know whether the thread has finished we can call isAlive() on the thread which returns true if
       the thread is not finished.
     * Another way to achieve this by using join() method, this method when called from the parent
       thread makes parent thread wait till child thread terminates.
     * These methods are defined in the Thread class.
     * We have used isAlive() method in the above examples too.

Synchronization
     * Multithreading introduces asynchronous behavior to the programs. If a thread is writing some data
       another thread may be reading the same data at that time. This may bring inconsistency.
     * When two or more threads need access to a shared resource there should be some way that the
       resource will be used only by one resource at a time. The process to achieve this is called
       synchronization.
     * To implement the synchronous behavior java has synchronous method. Once a thread is inside a
       synchronized method, no other thread can call any other synchronized method on the same object.
       All the other threads then wait until the first thread come out of the synchronized block.
     * When we want to synchronize access to objects of a class which was not designed for the
       multithreaded access and the code of the method which needs to be accessed synchronously is not
       available with us, in this case we cannot add the synchronized to the appropriate methods. In
       java we have the solution for this, put the calls to the methods (which needs to be synchronized)
       defined by this class inside a synchronized block in following manner.

Synchronized(object)
{
    // statement to be synchronized
}

Inter-thread Communication

   We have few methods through which java threads can communicate with each other. These methods are
   wait(), notify(), notifyAll(). All these methods can only be called from within a synchronized
   method.
   1) To understand synchronization java has a concept of monitor. Monitor can be thought of as a box
   which can hold only one thread. Once a thread enters the monitor all the other threads have to wait
   until that thread exits the monitor.
   2) wait()  tells the calling thread to give up the monitor and go to sleep until some other thread
   enters the same monitor and calls notify().
   3) notify() wakes up the first thread that called wait() on the same object.
   notifyAll() wakes up all the threads that called wait() on the same object. The highest priority
   thread will run first.


---
https://beginnersbook.com/java-io-tutorial-with-examples/

Java I/O tutorial with examples

   I have written several tutorials on Java I/O. You can find out the links of all the tutorials below.
   The tutorials are explained with the help of very basic and simple examples so that even a beginner
   can learn with ease. I will continue to write more tutorials on I/O and will add the links below:

  18. https://beginnersbook.com/2014/01/how-to-create-a-file-in-java/
  19. https://beginnersbook.com/2014/01/how-to-read-file-in-java-bufferedinputstream/
  20. https://beginnersbook.com/2014/01/how-to-read-file-in-java-using-bufferedreader/
  21. https://beginnersbook.com/2014/01/how-to-write-to-a-file-in-java-using-fileoutputstream/
  22. https://beginnersbook.com/2014/01/how-to-write-to-file-in-java-using-bufferedwriter/
  23. https://beginnersbook.com/2014/01/how-to-append-to-a-file-in-java/
  24. https://beginnersbook.com/2014/01/how-to-delete-file-in-java-delete-method/
  25. https://beginnersbook.com/2014/01/how-to-rename-file-in-java-renameto-method/
  26. https://beginnersbook.com/2014/07/how-to-compress-a-file-in-gzip-format/
  27. https://beginnersbook.com/2014/05/how-to-copy-a-file-to-another-file-in-java/
  28. https://beginnersbook.com/2014/05/how-to-get-the-last-modified-date-of-a-file-in-java/
  29. https://beginnersbook.com/2014/05/how-to-make-a-file-read-only-in-java/
  30. https://beginnersbook.com/2015/01/how-to-check-if-a-file-is-hidden-in-java/

---
https://beginnersbook.com/2014/07/java-serialization/

Java Serialization

   Here we are gonna discuss how to serialize and de-serialize an object and what is the use of it.

What is Java Serialization?
   Serialization is a mechanism to convert an object into stream of bytes so that it can be written into
   a file, transported through a network or stored into database. De-serialization is just a vice versa.
   In simple words serialization is converting an object to stream of bytes and de-serialization is
   rebuilding the object from stream of bytes. Java Serialiation API provides the features to perform
   seralization & de-serialization. A class must implement java.io.Serializable interface to be eligible
   for serialization.

   Lets take an example to understand the concepts better:

   Example
   This class implements Serializable interface which means it can be serialized. All the fields of this
   class can be written to a file after being converted to stream of bytes, except those fields that are
   declared transient. In the below example we have two transient fields, these fields will not take
   part in serialization.
   Student.java

public class Student implements java.io.Serializable{
  private int stuRollNum;
  private int stuAge;
  private String stuName;
  private transient String stuAddress;
  private transient int stuHeight;

  public Student(int roll, int age, String name,
  String address, int height) {
    this.stuRollNum = roll;
    this.stuAge = age;
    this.stuName = name;
    this.stuAddress = address;
    this.stuHeight = height;
  }

  public int getStuRollNum() {
    return stuRollNum;
  }
  public void setStuRollNum(int stuRollNum) {
    this.stuRollNum = stuRollNum;
  }
  public int getStuAge() {
    return stuAge;
  }
  public void setStuAge(int stuAge) {
    this.stuAge = stuAge;
  }
  public String getStuName() {
    return stuName;
  }
  public void setStuName(String stuName) {
    this.stuName = stuName;
  }
  public String getStuAddress() {
    return stuAddress;
  }
  public void setStuAddress(String stuAddress) {
    this.stuAddress = stuAddress;
  }
  public int getStuHeight() {
    return stuHeight;
  }
  public void setStuHeight(int stuHeight) {
    this.stuHeight = stuHeight;
  }
}

Serialization of Object
   This class is writing an object of Student class to the Student.ser file. We are using
   FileOutputStream and ObjectOutputStream to write the object to File.

   Note: As per the best practices of Java Serialization, the file name should have .ser extension.
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.IOException;
public class SendClass
{
  public static void main(String args[])
  {
    Student obj = new Student(101, 25, "Chaitanya", "Agra", 6);
    try{
      FileOutputStream fos = new FileOutputStream("Student.ser");
      ObjectOutputStream oos = new ObjectOutputStream(fos);
      oos.writeObject(obj);
      oos.close();
      fos.close();
      System.out.println("Serialzation Done!!");
   }catch(IOException ioe){
      System.out.println(ioe);
    }
  }
}

   Output:
Serialzation Done!!

De-serialization of Object
   This class would rebuilt the object of Student class after reading the stream of bytes from the file.
   Observe the output of this class, student address and student height fields are having null & 0
   values consecutively. This is because these fields were declared transient in the Student class.
import java.io.FileInputStream;
import java.io.ObjectInputStream;
import java.io.IOException;
public class AcceptClass {

 public static void main(String args[])
 {
    Student o=null;
    try{
      FileInputStream fis = new FileInputStream("Student.ser");
      ObjectInputStream ois = new ObjectInputStream(fis);
      o = (Student)ois.readObject();
      ois.close();
      fis.close();
    }
    catch(IOException ioe)
    {
       ioe.printStackTrace();
       return;
    }catch(ClassNotFoundException cnfe)
     {
       System.out.println("Student Class is not found.");
       cnfe.printStackTrace();
       return;
     }
    System.out.println("Student Name:"+o.getStuName());
    System.out.println("Student Age:"+o.getStuAge());
    System.out.println("Student Roll No:"+o.getStuRollNum());
    System.out.println("Student Address:"+o.getStuAddress());
    System.out.println("Student Height:"+o.getStuHeight());
 }
}

   Output:
Student Name:Chaitanya
Student Age:25
Student Roll No:101
Student Address:null
Student Height:0


---
https://beginnersbook.com/2014/08/java-regex-tutorial/

Java Regular Expressions (java regex) Tutorial with examples

   Regular expressions are used for defining String patterns that can be used for searching,
   manipulating and editing a text. These expressions are also known as Regex (short form of Regular
   expressions).

Lets take an example to understand it better:
   In the below example, the regular expression .*book.* is used for searching the occurrence of string
   “book” in the text.
import java.util.regex.*;
class RegexExample1{
   public static void main(String args[]){
      String content = "This is Chaitanya " +
            "from Beginnersbook.com.";

      String pattern = ".*book.*";

      boolean isMatch = Pattern.matches(pattern, content);
      System.out.println("The text contains 'book'? " + isMatch);
   }
}

   Output:
The text contains 'book'? true

   In this tutorial we will learn how to define patterns and how to use them. The java.util.regex API
   (the package which we need to import while dealing with Regex) has two main classes:


   1) java.util.regex.Pattern – Used for defining patterns
   2) java.util.regex.Matcher – Used for performing match operations on text using patterns

java.util.regex.Pattern class:

1) Pattern.matches()
   We have already seen the usage of this method in the above example where we performed the search for
   string “book” in a given text. This is one of simplest and easiest way of searching a String in a
   text using Regex.
String content = "This is a tutorial Website!";
String patternString = ".*tutorial.*";
boolean isMatch = Pattern.matches(patternString, content);
System.out.println("The text contains 'tutorial'? " + isMatch);

   As you can see we have used matches() method of Pattern class to search the pattern in the given
   text. The pattern .*tutorial.* allows zero or more characters at the beginning and end of the String
   “tutorial” (the expression .* is used for zero and more characters).

   Limitations: This way we can search a single occurrence of a pattern in a text. For matching multiple
   occurrences you should use the Pattern.compile() method (discussed in the next section).

2) Pattern.compile()
   In the above example we searched a string “tutorial” in the text, that is a case sensitive search,
   however if you want to do a CASE INSENSITIVE search or want to do search multiple occurrences then
   you may need to first compile the pattern using Pattern.compile() before searching it in text. This
   is how this method can be used for this case.
String content = "This is a tutorial Website!";
String patternString = ".*tuToRiAl.";
Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);

   Here we have used a flag Pattern.CASE_INSENSITIVE for case insensitive search, there are several
   other flags that can be used for different-2 purposes. To read more about such flags refer this
   document.

   Now what: We have obtained a Pattern instance but how to match it? For that we would be needing a
   Matcher instance, which we can get using Pattern.matcher() method. Lets discuss it.

3) Pattern.matcher() method
   In the above section we learnt how to get a Pattern instance using compile() method. Here we will
   learn How to get Matcher instance from Pattern instance by using matcher() method.
String content = "This is a tutorial Website!";
String patternString = ".*tuToRiAl.*";
Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);
Matcher matcher = pattern.matcher(content);
boolean isMatched = matcher.matches();
System.out.println("Is it a Match?" + isMatched);

   Output:
Is it a Match?true

4) Pattern.split()
   To split a text into multiple strings based on a delimiter (Here delimiter would be specified using
   regex), we can use Pattern.split() method. This is how it can be done.
import java.util.regex.*;
class RegexExample2{
public static void main(String args[]){
        String text = "ThisIsChaitanya.ItISMyWebsite";
    // Pattern for delimiter
        String patternString = "is";
        Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);
        String[] myStrings = pattern.split(text);
        for(String temp: myStrings){
            System.out.println(temp);
        }
        System.out.println("Number of split strings: "+myStrings.length);
}}

   Output:
Th

Chaitanya.It
MyWebsite
Number of split strings: 4

   The second split String is null in the output.

java.util.regex.Matcher Class

   We already discussed little bit about Matcher class above. Lets recall few things:

Creating a Matcher instance

String content = "Some text";
String patternString = ".*somestring.*";
Pattern pattern = Pattern.compile(patternString);
Matcher matcher = pattern.matcher(content);

Main methods

   matches(): It matches the regular expression against the whole text passed to the Pattern.matcher()
   method while creating Matcher instance.
...
Matcher matcher = pattern.matcher(content);
boolean isMatch = matcher.matches();

   lookingAt(): Similar to matches() method except that it matches the regular expression only against
   the beginning of the text, while matches() search in the whole text.

   find(): Searches the occurrences of of the regular expressions in the text. Mainly used when we are
   searching for multiple occurrences.

   start() and end(): Both these methods are generally used along with the find() method. They are used
   for getting the start and end indexes of a match that is being found using find() method.

Lets take an example to find out the multiple occurrences using Matcher methods:

package beginnersbook.com;
import java.util.regex.*;
class RegexExampleMatcher{
public static void main(String args[]){
  String content = "ZZZ AA PP AA QQQ AAA ZZ";

  String string = "AA";
  Pattern pattern = Pattern.compile(string);
  Matcher matcher = pattern.matcher(content);

  while(matcher.find()) {
     System.out.println("Found at: "+ matcher.start()
                +
                " - " + matcher.end());
  }
}
}

   Output:
Found at: 4 - 6
Found at: 10 - 12
Found at: 17 - 19

   Now we are familiar with Pattern and Matcher class and the process of matching a regular expression
   against the text. Lets see what kind of various options we have to define a regular expression:

1) String Literals
   Lets say you just want to search a particular string in the text for e.g. “abc” then we can simply
   write the code like this: Here text and regex both are same.
   Pattern.matches("abc", "abc")

2) Character Classes
   A character class matches a single character in the input text against multiple allowed characters in
   the character class. For example [Cc]haitanya would match all the occurrences of String “chaitanya”
   with either lower case or upper case C”. Few more examples:
   Pattern.matches("[pqr]", "abcd"); It would give false as no p,q or r in the text
   Pattern.matches("[pqr]", "r"); Return true as r is found
   Pattern.matches("[pqr]", "pq"); Return false as any one of them can be in text not both.

   Here is the complete list of various character classes constructs:
   [abc]: It would match with text if the text is having either one of them(a,b or c) and only once.
   [^abc]:  Any single character except a, b, or c (^ denote negation)
   [a-zA-Z]:  a through z, or A through Z, inclusive (range)
   [a-d[m-p]]:  a through d, or m through p: [a-dm-p] (union)
   [a-z&&[def]]:  Any one of them (d, e, or f)
   [a-z&&[^bc]]: a through z, except for b and c: [ad-z] (subtraction)
   [a-z&&[^m-p]]:  a through z, and not m through p: [a-lq-z] (subtraction)

Predefined Character Classes – Metacharacters
   These are like short codes which you can use while writing regex.
Construct       Description
.   ->          Any character (may or may not match line terminators)
\d  ->          A digit: [0-9]
\D  ->          A non-digit: [^0-9]
\s  ->          A whitespace character: [ \t\n\x0B\f\r]
\S  ->          A non-whitespace character: [^\s]
\w  ->          A word character: [a-zA-Z_0-9]
\W  ->          A non-word character: [^\w]

   For e.g.
   Pattern.matches("\\d", "1"); would return true
   Pattern.matches("\\D", "z"); return true
   Pattern.matches(".p", "qp"); return true, dot(.) represent any character

Boundary Matchers
^       Matches the beginning of a line.
$       Matches then end of a line.
\b      Matches a word boundary.
\B      Matches a non-word boundary.
\A      Matches the beginning of the input text.
\G      Matches the end of the previous match
\Z      Matches the end of the input text except the final terminator if any.
\z      Matches the end of the input text.

   For e.g.
   Pattern.matches("^Hello$", "Hello"): return true, Begins and ends with Hello
   Pattern.matches("^Hello$", "Namaste! Hello"): return false, does not begin with Hello
   Pattern.matches("^Hello$", "Hello Namaste!"): return false, Does not end with Hello

Quantifiers
Greedy      Reluctant       Possessive      Matches
X?          X??             X?+             Matches X once, or not at all (0 or 1 time).
X*          X*?             X*+             Matches X zero or more times.
X+          X+?             X++             Matches X one or more times.
X{n}        X{n}?           X{n}+           Matches X exactly n times.
X{n,}       X{n,}?          X{n,}+          Matches X at least n times.
X{n, m)     X{n, m)?        X{n, m)+        Matches X at least n time, but at most m times.

Few examples

import java.util.regex.*;
class RegexExample{
public static void main(String args[]){
   // It would return true if string matches exactly "tom"
   System.out.println(
     Pattern.matches("tom", "Tom")); //False

   /* returns true if the string matches exactly
    * "tom" or "Tom"
    */
   System.out.println(
     Pattern.matches("[Tt]om", "Tom")); //True
   System.out.println(
     Pattern.matches("[Tt]om", "Tom")); //True

   /* Returns true if the string matches exactly "tim"
    * or "Tim" or "jin" or "Jin"
    */
   System.out.println(
     Pattern.matches("[tT]im|[jJ]in", "Tim"));//True
   System.out.println(
     Pattern.matches("[tT]im|[jJ]in", "jin"));//True

   /* returns true if the string contains "abc" at
    * any place
    */
   System.out.println(
     Pattern.matches(".*abc.*", "deabcpq"));//True

   /* returns true if the string does not have a
    * number at the beginning
    */
   System.out.println(
     Pattern.matches("^[^\\d].*", "123abc")); //False
   System.out.println(
     Pattern.matches("^[^\\d].*", "abc123")); //True

   // returns true if the string contains of three letters
   System.out.println(
     Pattern.matches("[a-zA-Z][a-zA-Z][a-zA-Z]", "aPz"));//True
   System.out.println(
     Pattern.matches("[a-zA-Z][a-zA-Z][a-zA-Z]", "aAA"));//True
   System.out.println(
     Pattern.matches("[a-zA-Z][a-zA-Z][a-zA-Z]", "apZx"));//False

   // returns true if the string contains 0 or more non-digits
   System.out.println(
     Pattern.matches("\\D*", "abcde")); //True
   System.out.println(
     Pattern.matches("\\D*", "abcde123")); //False

   /* Boundary Matchers example
    * ^ denotes start of the line
    * $ denotes end of the line
    */
   System.out.println(
     Pattern.matches("^This$", "This is Chaitanya")); //False
   System.out.println(
     Pattern.matches("^This$", "This")); //True
   System.out.println(
     Pattern.matches("^This$", "Is This Chaitanya")); //False
}
}


---
https://beginnersbook.com/2015/06/java-awt-tutorial/

Java AWT tutorial for beginners

   AWT stands for Abstract Window Toolkit. It is a platform dependent API for creating Graphical User
   Interface (GUI) for java programs.

   Why AWT is platform dependent? Java AWT calls native platform (Operating systems) subroutine for
   creating components such as textbox, checkbox, button etc. For example an AWT GUI having a button
   would have a different look and feel across platforms like windows, Mac OS & Unix, this is because
   these platforms have different look and feel for their native buttons and AWT directly calls their
   native subroutine that creates the button. In simple, an application build on AWT would look like a
   windows application when it runs on Windows, but the same application would look like a Mac
   application when runs on Mac OS.

   AWT is rarely used now days because of its platform dependent and heavy-weight nature. AWT components
   are considered heavy weight because they are being generated by underlying operating system (OS). For
   example if you are instantiating a text box in AWT that means you are actually asking OS to create a
   text box for you.

   Swing is a preferred API for window based applications because of its platform independent and
   light-weight nature. Swing is built upon AWT API however it provides a look and feel unrelated to the
   underlying platform. It has more powerful and flexible components than AWT. In addition to familiar
   components such as buttons, check boxes and labels, Swing provides several advanced components such
   as tabbed panel, scroll panes, trees, tables, and lists. We will discuss Swing in detail in a
   separate tutorial.


AWT hierarchy

   Java AWT hierarchy diagram

Components and containers
   All the elements like buttons, text fields, scrollbars etc are known as components. In AWT we have
   classes for each component as shown in the above diagram. To have everything placed on a screen to a
   particular position, we have to add them to a container. A container is like a screen wherein we are
   placing components like buttons, text fields, checkbox etc. In short a container contains and
   controls the layout of components. A container itself is a component (shown in the above hierarchy
   diagram) thus we can add a container inside container.

   Types of containers:
   As explained above, a container is a place wherein we add components like text field, button,
   checkbox etc. There are four types of containers available in AWT: Window, Frame, Dialog and Panel.
   As shown in the hierarchy diagram above, Frame and Dialog are subclasses of Window class.

   Window: An instance of the Window class has no border and no title
   Dialog: Dialog class has border and title. An instance of the Dialog class cannot exist without an
   associated instance of the Frame class.
   Panel: Panel does not contain title bar, menu bar or border. It is a generic container for holding
   components. An instance of the Panel class provides a container to which to add components.
   Frame: A frame has title, border and menu bars. It can contain several components like buttons, text
   fields, scrollbars etc. This is most widely used container while developing an application in AWT.

Java AWT Example
   We can create a GUI using Frame in two ways:
   1) By extending Frame class
   2) By creating the instance of Frame class
   Lets have a look at the example of each one.

AWT Example 1: creating Frame by extending Frame class

import java.awt.*;
/* We have extended the Frame class here,
 * thus our class "SimpleExample" would behave
 * like a Frame
 */
public class SimpleExample extends Frame{
    SimpleExample(){
        Button b=new Button("Button!!");

        // setting button position on screen
        b.setBounds(50,50,50,50);

        //adding button into frame
        add(b);

        //Setting Frame width and height
        setSize(500,300);

        //Setting the title of Frame
        setTitle("This is my First AWT example");

        //Setting the layout for the Frame
        setLayout(new FlowLayout());

        /* By default frame is not visible so
         * we are setting the visibility to true
         * to make it visible.
         */
        setVisible(true);
    }
    public static void main(String args[]){
         // Creating the instance of Frame
         SimpleExample fr=new SimpleExample();
    }
}

   Output:
   AWT example 1

AWT Example 2: creating Frame by creating instance of Frame class

import java.awt.*;
public class Example2 {
   Example2()
   {
      //Creating Frame
      Frame fr=new Frame();

      //Creating a label
      Label lb = new Label("UserId: ");

      //adding label to the frame
      fr.add(lb);

      //Creating Text Field
      TextField t = new TextField();

      //adding text field to the frame
      fr.add(t);

      //setting frame size
      fr.setSize(500, 300);

      //Setting the layout for the Frame
      fr.setLayout(new FlowLayout());

      fr.setVisible(true);
   }
   public static void main(String args[])
   {
       Example2 ex = new Example2();
   }
}

   Output:
   AWT example 2


---
https://beginnersbook.com/2015/07/java-swing-tutorial/

Java Swing Tutorial for beginners

   Swing is a part of Java Foundation classes (JFC), the other parts of JFC are java2D and Abstract
   window toolkit (AWT). AWT, Swing & Java 2D are used for building graphical user interfaces (GUIs) in
   java. In this tutorial we will mainly discuss about Swing API which is used for building GUIs on the
   top of AWT and are much more light-weight compared to AWT.

A Simple swing example
   In the below example we would be using several swing components that you have not learnt so far in
   this tutorial. We will be discussing each and everything in detail in the coming swing tutorials.
   The below swing program would create a login screen.
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JPasswordField;
import javax.swing.JTextField;
public class SwingFirstExample {

    public static void main(String[] args) {
        // Creating instance of JFrame
        JFrame frame = new JFrame("My First Swing Example");
        // Setting the width and height of frame
        frame.setSize(350, 200);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        /* Creating panel. This is same as a div tag in HTML
         * We can create several panels and add them to specific
         * positions in a JFrame. Inside panels we can add text
         * fields, buttons and other components.
         */
        JPanel panel = new JPanel();
        // adding panel to frame
        frame.add(panel);
        /* calling user defined method for adding components
         * to the panel.
         */
        placeComponents(panel);

        // Setting the frame visibility to true
        frame.setVisible(true);
    }

    private static void placeComponents(JPanel panel) {

        /* We will discuss about layouts in the later sections
         * of this tutorial. For now we are setting the layout
         * to null
         */
        panel.setLayout(null);

        // Creating JLabel
        JLabel userLabel = new JLabel("User");
        /* This method specifies the location and size
         * of component. setBounds(x, y, width, height)
         * here (x,y) are cordinates from the top left
         * corner and remaining two arguments are the width
         * and height of the component.
         */
        userLabel.setBounds(10,20,80,25);
        panel.add(userLabel);

        /* Creating text field where user is supposed to
         * enter user name.
         */
        JTextField userText = new JTextField(20);
        userText.setBounds(100,20,165,25);
        panel.add(userText);

        // Same process for password label and text field.
        JLabel passwordLabel = new JLabel("Password");
        passwordLabel.setBounds(10,50,80,25);
        panel.add(passwordLabel);

        /*This is similar to text field but it hides the user
         * entered data and displays dots instead to protect
         * the password like we normally see on login screens.
         */
        JPasswordField passwordText = new JPasswordField(20);
        passwordText.setBounds(100,50,165,25);
        panel.add(passwordText);

        // Creating login button
        JButton loginButton = new JButton("login");
        loginButton.setBounds(10, 80, 80, 25);
        panel.add(loginButton);
    }

}

   Output:
   Swing Login Screen Example

   In the above example we have used several components. Let’s discuss a bit about them first then we
   will discuss them in detail in the next tutorials.
   JFrame – A frame is an instance of JFrame. Frame is a window that can have title, border, menu,
   buttons, text fields and several other components. A Swing application must have a frame to have the
   components added to it.
   JPanel – A panel is an instance of JPanel. A frame can have more than one panels and each panel can
   have several components. You can also call them parts of Frame. Panels are useful for grouping
   components and placing them to appropriate locations in a frame.

   JLabel – A label is an instance of JLabel class. A label is unselectable text and images. If you want
   to display a string or an image on a frame, you can do so by using labels. In the above example we
   wanted to display texts “User” & “Password” just before the text fields , we did this by creating and
   adding labels to the appropriate positions.

   JTextField – Used for capturing user inputs, these are the text boxes where user enters the data.

   JPasswordField – Similar to text fields but the entered data gets hidden and displayed as dots on
   GUI.

   JButton – A button is an instance of JButton class. In the above example we have a button “Login”.


---
https://beginnersbook.com/2014/09/java-enum-examples/

Java Enum Tutorial with examples

   An enum is a special type of data type which is basically a collection (set) of constants. In this
   tutorial we will learn how to use enums in Java and what are the possible scenarios where we can use
   them.

This is how we define Enum

public enum Directions{
  EAST,
  WEST,
  NORTH,
  SOUTH
}

   Here we have a variable Directions of enum type, which is a collection of four constants EAST, WEST,
   NORTH and SOUTH.

   How to assign value to a enum type?
Directions dir = Directions.NORTH;

   The variable dir is of type Directions (that is a enum type). This variable can take any value, out
   of the possible four values (EAST, WEST, NORTH, SOUTH). In this case it is set to NORTH.

Use of Enum types in if-else statements
   This is how we can use an enum variable in a if-else logic.
/* You can assign any value here out of
 * EAST, WEST, NORTH, SOUTH. Just for the
 * sake of example, I'm assigning to NORTH
 */
Directions dir = Directions.NORTH;

if(dir == Directions.EAST) {
  // Do something. Write your logic
} else if(dir == Directions.WEST) {
     // Do something else
  } else if(dir == Directions.NORTH) {
     // Do something
    } else {
        /* Do Something. Write logic for
         * the remaining constant SOUTH
         */
      }

Enum Example

   This is just an example to demonstrate the use enums. If you understand the core part and basics, you
   would be able to write your own logic based on the requirement.
public enum Directions{
          EAST,
          WEST,
          NORTH,
          SOUTH
}
public class EnumDemo
{
   public static void main(String args[]){
        Directions dir = Directions.NORTH;
        if(dir == Directions.EAST) {
            System.out.println("Direction: East");
        } else if(dir == Directions.WEST) {
            System.out.println("Direction: West");
          } else if(dir == Directions.NORTH) {
              System.out.println("Direction: North");
            } else {
                System.out.println("Direction: South");
              }
   }
}

   Output:
Direction: North

Use of Enum in Switch-Case Statements

   Here is the example to demonstrate the use of enums in switch-case statements.
public enum Directions{
          EAST,
          WEST,
          NORTH,
          SOUTH
}
public class EnumDemo
{
   Directions dir;
   public EnumDemo(Directions dir) {
      this.dir = dir;
   }
   public void getMyDirection() {
     switch (dir) {
       case EAST:
          System.out.println("In East Direction");
          break;

       case WEST:
          System.out.println("In West Direction");
          break;

       case NORTH:
          System.out.println("In North Direction");
          break;

       default:
          System.out.println("In South Direction");
          break;
     }
   }

    public static void main(String[] args) {
        EnumDemo obj1 = new EnumDemo(Directions.EAST);
        obj1.getMyDirection();
        EnumDemo obj2 = new EnumDemo(Directions.SOUTH);
        obj2.getMyDirection();
    }
}

   Output:
In East Direction
In South Direction

How to iterate through an Enum variable

class EnumDemo
{
    public static void main(String[] args) {
        for (Directions dir : Directions.values()) {
            System.out.println(dir);
        }
    }
}

   This code would display all the four constants.

Enum Fields and Methods

   Lets take an example first then we will discuss it in detail:
public enum Directions{
  EAST ("E"),
  WEST ("W"),
  NORTH ("N"),
  SOUTH ("S")
  ;
  /* Important Note: Must have semicolon at
   * the end when there is a enum field or method
   */
  private final String shortCode;

  Directions(String code) {
      this.shortCode = code;
  }

  public String getDirectionCode() {
      return this.shortCode;
  }
}
public class EnumDemo
{
    public static void main(String[] args) {
        Directions dir = Directions.SOUTH;
        System.out.println(dir.getDirectionCode());
        Directions dir2 = Directions.EAST;
        System.out.println(dir2.getDirectionCode());
    }
}

   Output:
S
E

   As you can see in this example we have a field shortCode for each of the constant, along with a
   method getDirectionCode() which is basically a getter method for this field. When we define a
   constant like this EAST ("E"), it calls the enum constructor (Refer the constructor Directions in the
   above example) with the passed argument. This way the passed value is set as an value for the field
   of the corresponding enum’s constant [EAST(“E”) => Would call constructor Directions(“E”) =>
   this.shortCode = code => this.shortCode = “E” => shortCode field of constant EAST is set to “E”].

Important points to Note:
   1) While defining Enums, the constants should be declared first, prior to any fields or methods.
   2) When there are fields and methods declared inside Enum, the list of enum constants must end with a
   semicolon(;).

##########################################################
---
https://beginnersbook.com/2014/09/java-annotations/

Java Annotations tutorial with examples

   Java Annotations allow us to add metadata information into our source code, although they are not
   a part of the program itself. Annotations were added to the java from JDK 5. Annotation has no direct
   effect on the operation of the code they annotate (i.e. it does not affect the execution of the
   program).

   In this tutorial we are going to cover following topics: Usage of annotations, how to apply
   annotations, what predefined annotation types are available in the Java and how to create custom
   annotations.

What’s the use of Annotations?
   1) Instructions to the compiler: There are three built-in annotations available in Java (@Deprecated,
   @Override & @SuppressWarnings) that can be used for giving certain instructions to the compiler. For
   example the @override annotation is used for instructing compiler that the annotated method is
   overriding the method. More about these built-in annotations with example is discussed in the next
   sections of this article.

   2) Compile-time instructors: Annotations can provide compile-time instructions to the compiler that
   can be further used by sofware build tools for generating code, XML files etc.


   3) Runtime instructions: We can define annotations to be available at runtime which we can access
   using java reflection and can be used to give instructions to the program at runtime. We will
   discuss this with the help of an example, later in this same post.

Annotations basics
   An annotation always starts with the symbol @ followed by the annotation name. The symbol @ indicates
   to the compiler that this is an annotation.

   For e.g. @Override
   Here @ symbol represents that this is an annotation and the Override is the name of this annotation.

   Where we can use annotations?
   Annotations can be applied to the classes, interfaces, methods and fields. For example the below
   annotation is being applied to the method.
@Override
void myMethod() {
    //Do something
}

   What this annotation is exactly doing here is explained in the next section but to be brief it is
   instructing compiler that myMethod() is a overriding method which is overriding the method
   (myMethod()) of super class.

Built-in Annotations in Java
   Java has three built-in annotations:
     * @Override
     * @Deprecated
     * @SuppressWarnings

1) @Override:
   While overriding a method in the child class, we should use this annotation to mark that method. This
   makes code readable and avoid maintenance issues, such as: while changing the method signature of
   parent class, you must change the signature in child classes (where this annotation is being used)
   otherwise compiler would throw compilation error. This is difficult to trace when you haven’t used
   this annotation.

   Example:
public class MyParentClass {

    public void justaMethod() {
        System.out.println("Parent class method");
    }
}


public class MyChildClass extends MyParentClass {

    @Override
    public void justaMethod() {
        System.out.println("Child class method");
    }
}

   I believe the example is self explanatory. To read more about this annotation, refer this article:
   @Override built-in annotation.

2) @Deprecated
   @Deprecated annotation indicates that the marked element (class, method or field) is deprecated and
   should no longer be used. The compiler generates a warning whenever a program uses a method, class,
   or field that has already been marked with the @Deprecated annotation. When an element is deprecated,
   it should also be documented using the Javadoc @deprecated tag, as shown in the following example.
   Make a note of case difference with @Deprecated and @deprecated. @deprecated is used for
   documentation purpose.

   Example:
/**
 * @deprecated
 * reason for why it was deprecated
 */
@Deprecated
public void anyMethodHere(){
    // Do something
}

   Now, whenever any program would use this method, the compiler would generate a warning. To read more
   about this annotation, refer this article: Java – @Deprecated annotation.

3) @SuppressWarnings
   This annotation instructs compiler to ignore specific warnings. For example in the below code, I am
   calling a deprecated method (lets assume that the method deprecatedMethod() is marked with
   @Deprecated annotation) so the compiler should generate a warning, however I am using
   @@SuppressWarnings annotation that would suppress that deprecation warning.
@SuppressWarnings("deprecation")
    void myMethod() {
        myObject.deprecatedMethod();
}

Creating Custom Annotations
     * Annotations are created by using @interface, followed by annotation name as shown in the below
       example.
     * An annotation can have elements as well. They look like methods. For example in the below code,
       we have four elements. We should not provide implementation for these elements.
     * All annotations extends java.lang.annotation.Annotation interface. Annotations cannot include any
       extends clause.

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Documented
@Target(ElementType.METHOD)
@Inherited
@Retention(RetentionPolicy.RUNTIME)
public @interface MyCustomAnnotation{
    int studentAge() default 18;
    String studentName();
    String stuAddress();
    String stuStream() default "CSE";
}

   Note: All the elements that have default values set while creating annotations can be skipped while
   using annotation. For example if I’m applying the above annotation to a class then I would do it like
   this:
@MyCustomAnnotation(
    studentName="Chaitanya",
    stuAddress="Agra, India"
)
public class MyClass {
...
}

   As you can see, we have not given any value to the studentAge and stuStream elements as it is
   optional to set the values of these elements (default values already been set in Annotation
   definition, but if you want you can assign new value while using annotation just the same way as we
   did for other elements). However we have to provide the values of other elements (the elements that
   do not have default values set) while using annotation.

   Note: We can also have array elements in an annotation. This is how we can use them:
   Annotation definition:
@interface MyCustomAnnotation {
    int      count();
    String[] books();
}

   Usage:
@MyCustomAnnotation(
    count=3,
    books={"C++", "Java"}
)
public class MyClass {

}

   Lets back to the topic again: In the custom annotation example we have used these four annotations:
   @Documented, @Target, @Inherited & @Retention. Lets discuss them in detail.

@Documented
   @Documented annotation indicates that elements using this annotation should be documented by JavaDoc.
   For example:
java.lang.annotation.Documented
@Documented
public @interface MyCustomAnnotation {
  //Annotation body
}
@MyCustomAnnotation
public class MyClass {
     //Class body
}

   While generating the javadoc for class MyClass, the annotation @MyCustomAnnotation would be included
   in that.

@Target
   It specifies where we can use the annotation. For example: In the below code, we have defined the
   target type as METHOD which means the below annotation can only be used on methods.
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

@Target({ElementType.METHOD})
public @interface MyCustomAnnotation {

}
public class MyClass {
   @MyCustomAnnotation
   public void myMethod()
   {
       //Doing something
   }
}

   Note: 1) If you do not define any Target type that means annotation can be applied to any element.
   2) Apart from ElementType.METHOD, an annotation can have following possible Target values.
   ElementType.METHOD
   ElementType.PACKAGE
   ElementType.PARAMETER
   ElementType.TYPE
   ElementType.ANNOTATION_TYPE
   ElementType.CONSTRUCTOR
   ElementType.LOCAL_VARIABLE
   ElementType.FIELD

@Inherited
   The @Inherited annotation signals that a custom annotation used in a class should be inherited by all
   of its sub classes. For example:
java.lang.annotation.Inherited

@Inherited
public @interface MyCustomAnnotation {

}
@MyCustomAnnotation
public class MyParentClass {
  ...
}
public class MyChildClass extends MyParentClass {
   ...
}

   Here the class MyParentClass is using annotation @MyCustomAnnotation which is marked with @inherited
   annotation. It means the sub class MyChildClass inherits the @MyCustomAnnotation.

@Retention

   It indicates how long annotations with the annotated type are to be retained.
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
@interface MyCustomAnnotation {

}

   Here we have used RetentionPolicy.RUNTIME. There are two other options as well. Lets see what do they
   mean:
   RetentionPolicy.RUNTIME: The annotation should be available at runtime, for inspection via java
   reflection.
   RetentionPolicy.CLASS: The annotation would be in the .class file but it would not be available at
   runtime.
   RetentionPolicy.SOURCE: The annotation would be available in the source code of the program, it would
   neither be in the .class file nor be available at the runtime.

   That’s all for this topic “Java Annotation”. Should you have any questions, feel free to drop a line
   below.


---
https://beginnersbook.com/2015/04/json-tutorial/

JSON Tutorial: Learn JSON in 10 Minutes

   JSON stands for JavaScript Object Notation. JSON objects are used for transferring data between
   server and client, XML serves the same purpose. However JSON objects have several advantages over XML
   and we are going to discuss them in this tutorial along with JSON concepts and its usages.

   Let’s have a look at the piece of a JSON data: It basically has key-value pairs.
var chaitanya = {
   "firstName" : "Chaitanya",
   "lastName" : "Singh",
   "age" :  "28"
};

   Features of JSON:
     * It is light-weight
     * It is language independent
     * Easy to read and write
     * Text based, human readable data exchange format

Why use JSON?
   Standard Structure: As we have seen so far that JSON objects are having a standard structure that
   makes developers job easy to read and write code, because they know what to expect from JSON.

   Light weight: When working with AJAX, it is important to load the data quickly and asynchronously
   without requesting the page re-load. Since JSON is light weighted, it becomes easier to get and load
   the requested data quickly.

   Scalable: JSON is language independent, which means it can work well with most of the modern
   programming language. Let’s say if we need to change the server side language, in that case it would
   be easier for us to go ahead with that change as JSON structure is same for all the languages.

JSON vs. XML
   Let see how JSON and XML look when we store the records of 4 students in a text based format so that
   we can retrieve it later when required.

   JSON style:
{"students":[
   {"name":"John", "age":"23", "city":"Agra"},
   {"name":"Steve", "age":"28", "city":"Delhi"},
   {"name":"Peter", "age":"32", "city":"Chennai"},
   {"name":"Chaitanya", "age":"28", "city":"Bangalore"}
]}

   XML style:
<students>
  <student>
    <name>John</name> <age>23</age> <city>Agra</city>
  </student>
  <student>
    <name>Steve</name> <age>28</age> <city>Delhi</city>
  </student>
  <student>
    <name>Peter</name> <age>32</age> <city>Chennai</city>
  </student>
  <student>
    <name>Chaitanya</name> <age>28</age> <city>Bangalore</city>
  </student>
</students>

   As you can clearly see JSON is much more light-weight compared to XML. Also, in JSON we take
   advantage of arrays that is not available in XML.

JSON data structure types and how to read them:
    1. JSON objects
    2. JSON objects in array
    3. Nesting of JSON objects

1) JSON objects:
var chaitanya = {
  "name" : "Chaitanya Singh",
  "age" : "28",
  "website" : "beginnersbook"
};

   The above text creates an object that we can access using the variable chaitanya. Inside an object we
   can have any number of key-value pairs like we have above. We can access the information out of a
   JSON object like this:
document.writeln("The name is:  " +chaitanya.name);
document.writeln("his age is: " + chaitanya.age);
document.writeln("his website is: "+ chaitanya.website);

2) JSON objects in array
   In the above example we have stored the information of one person in a JSON object suppose we want to
   store the information of more than one person; in that case we can have an array of objects.
var students = [{
   "name" : "Steve",
   "age" :  "29",
   "gender" : "male"

},
{
   "name" : "Peter",
   "age" : "32",
   "gender" : "male"

},
{
   "name" : "Sophie",
   "age" : "27",
   "gender" : "female"
}];

   To access the information out of this array, we do write the code like this:
document.writeln(students[0].age); //output would be: 29
document.writeln(students[2].name); //output: Sophie

   You got the point, right? Let’s carry on with the next type.

3) Nesting of JSON objects:
   Another way of doing the same thing that we have done above.
var students = {
  "steve" : {
  "name" : "Steve",
  "age" :  "29",
  "gender" : "male"
},

"pete" : {
  "name" : "Peter",
  "age" : "32",
  "gender" : "male"
},

"sop" : {
  "name" : "Sophie",
  "age" : "27",
  "gender" : "female"
}
}

   Do like this to access the info from above nested JSON objects:
document.writln(students.steve.age); //output: 29
document.writeln(students.sop.gender); //output: female

JSON & JavaScript:
   JSON is considered as a subset of JavaScript but that does not mean that JSON cannot be used with
   other languages. In fact it works well with PHP, Perl, Python, Ruby, Java, Ajax and many more.

   Just to demonstrate how JSON can be used along with JavaScript, here is an example:
   If you have gone though the above tutorial, you are familiar with the JSON structures. A JSON file
   type is .json

   How to read data from json file and convert it into a JavaScript object?
   We have two ways to do this.
   1) Using eval function, but this is not suggested due to security reasons (malicious data can be sent
   from the server to the client and then eval in the client script with harmful effects).
   2) Using JSON parser: No security issues plus it is faster than eval. Here is how to use it:
var chaitanya = {
"name" : "Chaitanya Singh",
"age" : "28",
"website" : "beginnersbook"
};

   We are converting the above JSON object to javascript object using JSON parser:
var myJSObject = JSON.parse(chaitanya);

   How to convert JavaScript object to JSON text?
   By using method stringify
var jsonText= JSON.stringify(myJSObject);

   I guess the 10 minutes are over. Bookmark this page as I will be adding more tutorials on JSON and
   will add the links to those tutorials here.


---
