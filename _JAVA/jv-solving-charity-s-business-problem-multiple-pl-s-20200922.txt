filename: jv_solving-charity-s-business-problem-multiple-pl-s_20200922.txt
https://opensource.com/article/20/9/problem-solving-java

Solve a real-world problem using Java

21 Sep 2020
See how Java differs from Python and Groovy as it's used to solve a charity's real-world problem.

   As I wrote in the first two articles in this series, I enjoy solving small problems by writing small
   programs in different languages, so I can compare the different ways they approach the solution. The
   example I'm using in this series is dividing bulk supplies into hampers of similar value to
   distribute to struggling neighbors in your community, which you can [**1]read about in the first
   article in this series.

   In the first article, I solved this problem [**1]using the Groovy programming language, which is like
   Python in many ways, but syntactically it's more like C and Java. In the second article, I
   [**2]solved it in Python with a very similar design and effort, which demonstrates the resemblance
   between the languages.

   Now I'll try it in Java.

The Java solution
   When working in Java, I find myself declaring utility classes to hold tuples of data (the new record
   feature is going to be great for that), rather than using the language support for maps offered in
   Groovy and Python. This is because Java encourages creating maps that map one specific type to
   another specific type, but in Groovy or Python, it's cool to have a map with mixed-type keys and
   mixed-type values.

   The first task is to define these utility classes, and the first is the Unit class:

class Unit {
    private String item, brand;
    private int price;
    public Unit(String item, String brand, int price) {
        this.item = item;
        this.brand = brand;
        this.price = price;
    }
    public String getItem() { return this.item; }
    public String getBrand() { return this.brand; }
    public int getPrice() { return this.price; }
    
    @Override
    public String toString() {
        return String.format("item: %s brand: %s price: %d",item,brand,price);
    }
}

   There's nothing too startling here. I effectively created a class whose instances are immutable since
   there are no setters for fields item, brand, or price and they are declared private. As a general
   rule, I don't see value in creating a mutable data structure unless I'm going to mutate it; and in
   this application, I don't see any value in mutating the Unit class.

   While more effort is required to create these utility classes, creating them encourages a bit more
   design effort than just using a map, which can be a good thing. In this case, I realized that a bulk
   package is composed of a number of individual units, so I created the Pack class:

class Pack {
    private Unit unit;
    private int count;
    public Pack(String item, String brand, int unitCount, int packPrice) {
        this.unit = new Unit(item, brand, unitCount > 0 ? packPrice / unitCount : 0);
        this.count = unitCount;
    }
    public String getItem() { return unit.getItem(); }
    public String getBrand() { return unit.getBrand(); }
    public int getUnitPrice() { return unit.getPrice(); }
    public int getUnitCount() { return count; }
    public List<Unit> unpack() {
        return Collections.nCopies(count, unit);
    }
    
    @Override
    public String toString() {
        return String.format("item: %s brand: %s unitCount: %dunitPrice: %d",\
        unit.getItem(),unit.getBrand(),count,unit.getPrice());
    }
}

   Similar to the Unit class, the Pack class is immutable. A couple of things worth mentioning here:
    1. I could have passed a Unit instance into the Pack constructor. I chose not to because the
       bundled, physical nature of a bulk package encouraged me to think of the "unit-ness" as an
       internal thing not visible from the outside but that requires unpacking to expose the units. Is
       this an important decision in this case? Probably not, but to me, at least, it's always good to
       think through this kind of consideration.
    2. Which leads to the unpack() method. The Pack class creates the list of Unit instances only when
       you call this method-that is, the class is lazy. As a general design principle, I've found it's
       worthwhile to decide whether a class' behavior should be eager or lazy, and when it doesn't seem
       to matter, I go with lazy. Is this an important decision in this case? Maybe-this lazy design
       enables a new list of Unit instances to be generated on every call of unpack(), which could prove
       to be a good thing down the road. In any case, getting in the habit of always thinking about
       eager vs. lazy behavior is a good habit.

   The sharp-eyed reader will note that, unlike in the Groovy and Python examples where I was mostly
   focused on compact code and spent way less time thinking about design decisions, here, I separated
   the definition of a Pack from the number of Pack instances purchased. Again, from a design
   perspective, this seemed like a good idea as the Pack is conceptually quite independent of the number
   of Pack instances acquired.

   Given this, I need one more utility class: the Bought class:

class Bought {
    private Pack pack;
    private int count;
    public Bought(Pack pack, int packCount) {
        this.pack = pack;
        this.count = packCount;
    }
    public String getItem() { return pack.getItem(); }
    public String getBrand() { return pack.getBrand(); }
    public int getUnitPrice() { return pack.getUnitPrice(); }
    public int getUnitCount() { return pack.getUnitCount() * count; }
    public List<Unit> unpack() {
        return Collections.nCopies(count, pack.unpack())
            .stream()
            .flatMap(List::stream)
            .collect(Collectors.toList());
    }
    
    @Override
    public String toString() {
        return String.format("item: %s brand: %s bought: %d pack(s) totalUnitCount: %d \
        unitPrice: %d",pack.getItem(),pack.getBrand(),count,pack.getUnitCount() * count,pack.getUnitPrice());
    }
}

   Notably:
    1. I decided to pass a Pack into the constructor. Why? Because to my way of thinking, the physical
       structure of the purchased bulk packages is external, not internal, as in the case of the
       individual bulk packages. Once again, it may not be important in this application, but I believe
       it's always good to think about these things. If nothing else, note that I am not married to
       symmetry!
    2. Once again the unpack() method demonstrates the lazy design principle. This goes to more effort
       to generate a list of Unit instances (rather than a list of lists of Unit instances, which would
       be easier but require flattening further out in the code).

   OK! Time to move on and solve the problem. First, declare the purchased packs:

        var packs = new Bought[] {
            new Bought(new Pack("Rice","Best Family",10,5650),1),
            new Bought(new Pack("Spaghetti","Best Family",1,327),10),
            new Bought(new Pack("Sardines","Fresh Caught",3,2727),3),
            new Bought(new Pack("Chickpeas","Southern Style",2,2600),5),
            new Bought(new Pack("Lentils","Southern Style",2,2378),5),
            new Bought(new Pack("Vegetable oil","Crafco",12,10020),1),
            new Bought(new Pack("UHT milk","Atlantic",6,4560),2),
            new Bought(new Pack("Flour","Neighbor Mills",10,5200),1),
            new Bought(new Pack("Tomato sauce","Best Family",1,190),10),
            new Bought(new Pack("Sugar","Good Price",1,565),10),
            new Bought(new Pack("Tea","Superior",5,2720),2),
            new Bought(new Pack("Coffee","Colombia Select",2,4180),5),
            new Bought(new Pack("Tofu","Gourmet Choice",1,1580),10),
            new Bought(new Pack("Bleach","Blanchite",5,3550),2),
            new Bought(new Pack("Soap","Sunny Day",6,1794),2)
        };

   This is pretty nice from a readability perspective: there is one pack of Best Family Rice containing
   10 units that cost 5,650 (using those crazy monetary units, like in the other examples). It's
   straightforward to see that in addition to the one bulk pack of 10 bags of rice, the organization
   acquired 10 bulk packs of one bag each of spaghetti. The utility classes are doing some work under
   the covers, but that's not important at this point because of the great design job!

   Note the var keyword is used here; it's one of the nice features in recent versions of Java that help
   make the language a bit less verbose (the principle is called DRY-don't repeat yourself) by letting
   the compiler infer the variable's data type from the right-side expression's type. This looks kind of
   similar to the Groovy def keyword, but since Groovy by default is dynamically typed and Java is
   statically typed, the typing information inferred in Java by var persists throughout the lifetime of
   that variable.

   Finally, it's worth mentioning that packs here is an array and not a List instance. If you were
   reading this data from a separate file, you would probably prefer to create it as a list.

   Next, unpack the bulk packages. Because the unpacking of Pack instances is delegated into lists of
   Unit instances, you can use that like this:

        var units = Stream.of(packs)
            .flatMap(bought -> {
                return bought.unpack().stream(); })
            .collect(Collectors.toList());

   This uses some of the nice functional programming features introduced in later Java versions. Convert
   the array packs declared previously to a Java stream, use flatmap() with a lambda to flatten the
   sublists of units generated by the unpack() method of the Bought class, and collect the resulting
   stream elements back into a list.

   As in the Groovy and Java solutions, the final step is repacking the units into the hampers for
   distribution. Here's the code-it's not much wordier than the Groovy version (tiresome semicolons
   aside) nor really all that different:

        var valueIdeal = 5000;
        var valueMax = Math.round(valueIdeal * 1.1);
        var rnd = new Random();
        var hamperNumber = 0;                         // [1]
        while (units.size() > 0) {                    // [2]
            hamperNumber++;
            var hamper = new ArrayList<Unit>();
            var value = 0;                            // [2.1]
            for (boolean canAdd = true; canAdd; ) {   // [2.2]
                var u = rnd.nextInt(units.size());            // [2.2.1]
                canAdd = false;                               // [2.2.2]
                for (int o = 0; o < units.size(); o++) {      // [2.2.3]
                    var uo = (u + o) % units.size();
                    var unit = units.get(uo);                      // [2.2.3.1]
                    if (units.size() < 3 ||
                            !hamper.contains(unit) &&
                            (value + unit.getPrice()) < valueMax) { // [2.2.3.2]
                        hamper.add(unit);
                        value += unit.getPrice();
                        units.remove(uo);                           // [2.2.3.3]
                        canAdd = units.size() > 0;
                        break;                                      // [2.2.3.4]
                    }
                }
               }                                                // [2.2.4]
               System.out.println();
               System.out.printf("Hamper %d value %d:\n",hamperNumber,value);
               hamper.forEach(unit -> {
                   System.out.printf("%-25s%-25s%7d\n", unit.getItem(), unit.getBrand(),
                          unit.getPrice());
               });                                                      // [2.3]
               System.out.printf("Remaining units %d\n",units.size());  // [2.4]

   Some clarification, with numbers in brackets in the comments above (e.g., [1]) corresponding to the
   clarifications below:
     * 1. Set up the ideal and maximum values to be loaded into any given hamper, initialize Java's
       random number generator and the hamper number.
     * 2. This while {} loop will redistribute units into hampers as long as there are more available:
          + 2.1 Increment the hamper number, get a new empty hamper (a list of Unit instances), and set
            its value to 0.
          + 2.2 This for {} loop will add as many units to the hamper as possible:
               o 2.2.1 Get a random number between zero and the number of remaining units minus 1.
               o 2.2.2 Assume you can't find more units to add.
               o 2.2.3 This for {} loop, starting at the randomly chosen index, will try to find a unit
                 that can be added to the hamper.
                    # 2.2.3.1 Figure out which unit to look at.
                    # 2.2.3.2 Add this unit to the hamper if there are only a few left or if the value
                      of the hamper isn't too high once the unit is added and that unit isn't already in
                      the hamper.
                    # 2.2.3.3 Add the unit to the hamper, increment the hamper value by the unit price,
                      and remove the unit from the available units list.
                    # 2.2.3.4 As long as there are units left, you can add more, so break out of this
                      loop to keep looking.
               o 2.2.4 On exit from this for {} loop, if you inspected every remaining unit and could
                 not find one to add to the hamper, the hamper is complete; otherwise, you found one and
                 can continue looking for more.
          + 2.3 Print out the contents of the hamper.
          + 2.4 Print out the remaining units info.

   When you run this code, the output looks quite similar to the output from the Groovy and Python
   programs:

   Hamper 1 value 5465:
   Tofu                     Gourmet Choice              1580
   Bleach                   Blanchite                    710
   Coffee                   Colombia Select             2090
   Flour                    Neighbor Mills               520
   Sugar                    Good Price                   565
   Remaining units 150
   Hamper 2 value 5482:
   Sardines                 Fresh Caught                 909
   Tomato sauce             Best Family                  190
   Vegetable oil            Crafco                       835
   UHT milk                 Atlantic                     760
   Chickpeas                Southern Style              1300
   Lentils                  Southern Style              1189
   Soap                     Sunny Day                    299
   Remaining units 143
   Hamper 3 value 5353:
   Soap                     Sunny Day                    299
   Rice                     Best Family                  565
   UHT milk                 Atlantic                     760
   Flour                    Neighbor Mills               520
   Vegetable oil            Crafco                       835
   Bleach                   Blanchite                    710
   Tomato sauce             Best Family                  190
   Sardines                 Fresh Caught                 909
   Sugar                    Good Price                   565
   Remaining units 134
   ...
   Hamper 23 value 5125:
   Sardines                 Fresh Caught                 909
   Rice                     Best Family                  565
   Spaghetti                Best Family                  327
   Lentils                  Southern Style              1189
   Chickpeas                Southern Style              1300
   Vegetable oil            Crafco                       835
   Remaining units 4
   Hamper 24 value 2466:
   UHT milk                 Atlantic                     760
   Spaghetti                Best Family                  327
   Vegetable oil            Crafco                       835
   Tea                      Superior                     544
   Remaining units 0

   The last hamper is abbreviated in contents and value.

Closing thoughts
   The similarities in the "working code" with the Groovy original are obvious-the close relationship
   between Groovy and Java is evident. Groovy and Java diverged in a few ways in things that were added
   to Java after Groovy was released, such as the var vs. def keywords and the superficial similarities
   and differences between Groovy closures and Java lambdas. Moreover, the whole Java streams framework
   adds a great deal of power and expressiveness to the Java platform (full disclosure, in case it's not
   obvious-I am but a babe in the Java streams woods).

   Java's intent to use maps for mapping instances of a single type to instances of another single type
   pushes you to use utility classes, or tuples, instead of the more inherently flexible intents in
   Groovy maps (which are basically just Map<Object,Object> plus a lot of syntactic sugar to vanish the
   kinds of casting and instanceof hassles that you would create in Java) or in Python. The bonus from
   this is the opportunity to apply some real design effort to these utility classes, which pays off at
   least insofar as it instills good habits in the programmer.

   Aside from the utility classes, there isn't a lot of additional ceremony nor boilerplate in the Java
   code compared to the Groovy code. Well, except that you need to add a bunch of imports and wrap the
   "working code" in a class definition, which might look like this:

import java.lang.*;
import java.util.*;
import java.util.Collections.*;
import java.util.stream.*;
import java.util.stream.Collectors.*;
import java.util.Random.*;
public class Distribute {
    static public void main(String[] args) {
        // the working code shown above
    }
}
class Unit { ... }
class Pack { ... }
class Bought { ... }

   The same fiddly bits are necessary in Java as they are in Groovy and Python when it comes to grabbing
   stuff out of the list of Unit instances for the hampers, involving random numbers, loops through
   remaining units, etc.

   Another issue worth mentioning-this isn't a particularly efficient approach. Removing elements from
   ArrayLists, being careless about repeated expressions, and a few other things make this less suitable
   for a huge redistribution problem. I've been a bit more careful here to stick with integer data. But
   at least it's quite quick to execute.

   Yes, I'm still using the dreaded while { ... } and for { ... }. I still haven't thought of a way to use
   map and reduce style stream processing in conjunction with a random selection of units for
   repackaging. Can you?

   Stay tuned for the next articles in this series, with versions in Julia and Go.


---
[**1]
https://opensource.com/article/20/9/groovy

Managing a non-profit organization's supply chain with Groovy
04 Sep 2020

Let's use Groovy to solve a charity's distribution problem.
   There are many reasons I'm a big fan of Java, but perhaps most of all, because of the particular
   combo of static typing and object-orientedness that imbues its design. However, when I need a quick
   solution, especially to a "solve it and forget it" problem dealing with data, I usually reach for
   Groovy (or sometimes Python) instead, especially if the library that addresses my problem
   exists and is well-documented. Sometimes even awk will do. But I keep meaning to start using
   Julia more, and then there's Go.

   Every so often, I run across a different kind of problem, and when it is sufficiently compact,
   sometimes I will solve it in a few languages, just to learn more about how each addresses the
   problem.

   Recently, a non-programmer colleague introduced me to just such a problem. It goes like this:

     Many people living in community XYZ struggle to make ends meet on a daily basis. Employment
     opportunities in the community are limited and tend to be low-paying. The cost of living is
     comparatively high: water, electricity, and healthcare are expensive. Post-secondary education,
     whether academic or technical, means moving to the nearest city. On the plus side, the community
     is small and close-knit. People help each other out as much as their circumstances permit.

     COVID-19 has hit this community hard in the economic sense. Although there haven't been any
     infections yet, the two main employers in the town are facing financial ruin and have laid off
     almost all of their workers. The government has helped out, but the amount of help is not enough
     for the families struggling the hardest.

     A local branch of a national charity has received some funding to provide support to families in
     need. Seeking to stretch this funding as much as possible, the charity arranges to buy bulk lots
     of food and household supplies, then break up the bulk lots into family hampers of approximately
     equal monetary value. Their question is, how to do so?

   My colleague thought that perhaps I could help him with a spreadsheet to handle the distribution.
   However, to me, this seemed to be the perfect little problem to solve with a small program. What
   might the steps be?
    1. Unpack the bulk packages into their individual units.
    2. While there are still units left:
         A. Grab a fresh hamper.
         B. Set the hamper value to zero.
         C. While the hamper value is less than the ideal hamper value and there are still units left:
              1. Pick a unit at random.
              2. If that unit isn't in the hamper and if the hamper value wouldn't be too high by adding
                 it:
                   a. Move the unit to the hamper.
                   b. Increment the hamper value by the unit price.

   That seems like a good first approximation. It also seems like the perfect small algorithm to
   implement in Groovy.

The Groovy solution

   In Java, I find myself declaring utility classes to hold tuples of data (the new record feature is
   going to be great for that). In Groovy, I tend to use the language support for maps. Let's use a list
   of maps to hold the bulk items picked up from the wholesaler:

    def packs = [
        [item:'Rice',brand:'Best Family',units:10,price:5650,quantity:1],
        [item:'Spaghetti',brand:'Best Family',units:1,price:327,quantity:10],
        [item:'Sardines',brand:'Fresh Caught',units:3,price:2727,quantity:3],
        [item:'Chickpeas',brand:'Southern Style',units:2,price:2600,quantity:5],
        [item:'Lentils',brand:'Southern Style',units:2,price:2378,quantity:5],
        [item:'Vegetable oil',brand:'Crafco',units:12,price:10020,quantity:1],
        [item:'UHT milk',brand:'Atlantic',units:6,price:4560,quantity:2],
        [item:'Flour',brand:'Neighbor Mills',units:10,price:5200,quantity:1],
        [item:'Tomato sauce',brand:'Best Family',units:1,price:190,quantity:10],
        [item:'Sugar',brand:'Good Price',units:1,price:565,quantity:10],
        [item:'Tea',brand:'Superior',units:5,price:2720,quantity:2],
        [item:'Coffee',brand:'Colombia Select',units:2,price:4180,quantity:5],
        [item:'Tofu',brand:'Gourmet Choice',units:1,price:1580,quantity:10],
        [item:'Bleach',brand:'Blanchite',units:5,price:3550,quantity:2],
        [item:'Soap',brand:'Sunny Day',units:6,price:1794,quantity:2]]

   There is one bulk pack of 10 bags of rice and 10 bulk packs with one bag each of spaghetti. In the
   above, the variable packs is set to a list (actually a Java ArrayList underneath) of maps (actually a
   Java HashMap underneath). Because Groovy is dynamically typed (by default, anyway), I use def to
   declare the packs variable and am happy to have both String and Integer values in my maps.

   And yes, those prices do look a bit strange, but this problem happened in a place with a different
   currency.

   The next step is to unpack these bulk packages. Unpacking the single bulk package of rice yields 10
   units of rice; that is, the total number of units yielded is units * quantity. Groovy provides a
   handy function called collectMany that can be used to flatten lists of lists, so the code to carry
   out the unpacking is really straightforward:

    def units = packs.collectMany { pack ->
        [[item:pack.item, brand:pack.brand, price:(pack.price / pack.units)]] *
                    (pack.units * pack.quantity)
    }

   Note that collectMany takes a Closure as its argument; so this is a kind of locally declared function
   with a single parameter, pack, that returns a list of (units * quantity) maps, with each map
   including the item, brand, and calculated unit price from the corresponding bulk pack. Of note here
   is that the Groovy multiply operator (*) with a list on the left side and a number (N) on the right
   will produce a list with the original items replicated in order N times.

   The final step is to repack the units into the hampers for distribution. But first, I need to get a
   bit more specific about the ideal hamper value, and I might as well not be overly restrictive when
   there are just a few units left:

   def valueIdeal = 5000
   def valueMax = valueIdeal * 1.1

    OK! Let's repack the hampers:
    
    def rnd = new Random()
    def hamperNumber = 0    // [1]
    while (units.size()) {  // [2]
        hamperNumber++
        def hamper = []
        def value = 0       // [2.1]
        for (boolean canAdd = true; canAdd; ) {        // [2.2]
            int u = rnd.nextInt(units.size())          // [2.2.1]
            canAdd = false                             // [2.2.2]
            for (int o = 0; o < units.size(); o++) {   // [2.2.3]
                int uo = (u + o) % units.size()
                def unit = units[uo]                   // [2.2.3.1]
                if (units.size() < 3 ||
                            !(unit in hamper) &&
                            (value + unit.price) < valueMax) { // [2.2.3.2]
                    hamper.add(unit)
                    value += unit.price
                    units.remove(uo)                   // [2.2.3.3]
                    canAdd = units.size() > 0
                    break                              // [2.2.3.4]
                }
            }                                          // [2.2.4]
        }
        println ""
        println "Hamper $hamperNumber value $value:"
        hamper.each { item ->
            printf "%-25s%-25s%7.2f\n",item.item,item.brand,item.price
        }                                                                   // [2.3]
        println "Remaining units ${units.size()} average price = $avgPrice" // [2.4]
    }

   Some clarification, with numbers in brackets in the comments above (e.g., [1]) corresponding to the
   clarifications below:
     * 1. Initialize Groovy's random number generator and the hamper number.
     * 2. This while {} loop will redistribute units into hampers as long as there are more available:
          + 2.1 Increment the hamper number, get a new empty hamper (a list of units), and set its value
            to 0.
          + 2.2 This for {} loop will add as many units to the hamper as possible:
               o 2.2.1 Get a random number between zero and the number of remaining units minus 1.
               o 2.2.2 Assume you can't find more units to add.
               o 2.2.3 This for {} loop, starting at the randomly chosen index, will try to find a unit
                 that can be added to the hamper.
                    # 2.2.3.1 Figure out which unit to look at.
                    # 2.2.3.2 Add this unit to the hamper if there are only a few left or if the value
                      of the hamper isn't too high once the unit is added.
                    # 2.2.3.3 Add the unit to the hamper, increment the hamper value by the unit price,
                      and remove the unit from the available units list.
                    # 2.2.3.4 As long as there are units left, you can add more, so break out of this
                      loop to keep looking.
               o 2.2.4 On exit from this for {} loop, if you inspected every remaining unit and could
                 not find one to add to the hamper, the hamper is complete; otherwise, you found one and
                 can continue looking for more.
          + 2.3 Print out the contents of the hamper.
          + 2.4 Print out the remaining units info.

   When you run this code, the output looks like:

   Hamper 1 value 5414:
   Vegetable oil            Crafco                    835.00
   Coffee                   Colombia Select          2090.00
   Tofu                     Gourmet Choice           1580.00
   Sardines                 Fresh Caught              909.00
   Remaing units 151
   Hamper 2 value 5309:
   Flour                    Neighbor Mills            520.00
   Sugar                    Good Price                565.00
   Vegetable oil            Crafco                    835.00
   Coffee                   Colombia Select          2090.00
   Rice                     Best Family               565.00
   Tomato sauce             Best Family               190.00
   Tea                      Superior                  544.00
   Remaing units 144
   Hamper 3 value 5395:
   Flour                    Neighbor Mills            520.00
   UHT milk                 Atlantic                  760.00
   Tomato sauce             Best Family               190.00
   Tofu                     Gourmet Choice           1580.00
   Spaghetti                Best Family               327.00
   Sugar                    Good Price                565.00
   Sardines                 Fresh Caught              909.00
   Tea                      Superior                  544.00
   Remaing units 136
   ...
   Hamper 23 value 5148:
   Flour                    Neighbor Mills            520.00
   Tea                      Superior                  544.00
   Chickpeas                Southern Style           1300.00
   Lentils                  Southern Style           1189.00
   Vegetable oil            Crafco                    835.00
   UHT milk                 Atlantic                  760.00
   Remaing units 3
   Hamper 24 value 3955:
   Chickpeas                Southern Style           1300.00
   Sugar                    Good Price                565.00
   Coffee                   Colombia Select          2090.00
   Remaing units 0

   The last hamper is abbreviated in contents and value.

Closing thoughts
   Note there is some fiddly business about being able to add units to the hamper. Basically, you pick a
   random position in the list of units and, starting at that position, iterate through the list until
   you either find a unit whose price allows it to be included or until you exhaust the list. Also, when
   there are only a few items left, you just toss them into the last hamper.

   Another issue worth mentioning: This isn't a particularly efficient approach. Removing elements from
   ArrayLists, letting Groovy use its default BigDecimal, and a few other things make this less suitable
   for a huge redistribution problem. Still, it runs quite rapidly on my aging dual-core machine.

   And one final thought-using while { ... } and for { ... }? Really? Not some cool functional code? Afraid
   so. I couldn't think of a way to use map and reduce style closures in Groovy in collaboration with a
   random selection of units for repackaging. Can you?

   In another article article, I'll solve this in Python, and future articles will do it in Java, Julia,
   and Go.


---
[**2]
https://opensource.com/article/20/9/solve-problem-python

Use Python to solve a charity's business problem
14 Sep 2020

Comparing how different programming languages solve the same problem is fun and instructive. Next up,
Python.

   In my first article in this series, I described a problem of dividing bulk supplies into hampers
   of similar value to distribute to struggling neighbors in your community. I also wrote about how I
   enjoy solving small problems like this with small programs in various languages and comparing how
   they do it.

   In the first article, I solved this problem with the Groovy programming language. Groovy is like
   Python in many ways, but syntactically it's more like C and Java. Therefore, it should be
   interesting and instructive to create the same solution in Python.

The Python solution
   In Java, I declare utility classes to hold tuples of data (the new record feature is going to be
   great for that). In Groovy, I use the language support for maps, and I follow the same approach in
   Python.

   Use a list of dictionaries to hold the bulk items picked up from the wholesaler:

    packs = [
            {'item':'Rice','brand':'Best Family','units':10,'price':5650,'quantity':1},
            {'item':'Spaghetti','brand':'Best Family','units':1,'price':327,'quantity':10},
            {'item':'Sardines','brand':'Fresh Caught','units':3,'price':2727,'quantity':3},
            {'item':'Chickpeas','brand':'Southern Style','units':2,'price':2600,'quantity':5},
            {'item':'Lentils','brand':'Southern Style','units':2,'price':2378,'quantity':5},
            {'item':'Vegetable oil','brand':'Crafco','units':12,'price':10020,'quantity':1},
            {'item':'UHT milk','brand':'Atlantic','units':6,'price':4560,'quantity':2},
            {'item':'Flour','brand':'Neighbor Mills','units':10,'price':5200,'quantity':1},
            {'item':'Tomato sauce','brand':'Best Family','units':1,'price':190,'quantity':10},
            {'item':'Sugar','brand':'Good Price','units':1,'price':565,'quantity':10},
            {'item':'Tea','brand':'Superior','units':5,'price':2720,'quantity':2},
            {'item':'Coffee','brand':'Colombia Select','units':2,'price':4180,'quantity':5},
            {'item':'Tofu','brand':'Gourmet Choice','units':1,'price':1580,'quantity':10},
            {'item':'Bleach','brand':'Blanchite','units':5,'price':3550,'quantity':2},
            {'item':'Soap','brand':'Sunny Day','units':6,'price':1794,'quantity':2}]

   There is one bulk pack of 10 bags of rice and 10 bulk packs with one bag each of spaghetti. In the
   above, the variable packs is set to a Python list of dictionaries. This turns out to be very similar
   to the Groovy approach. A few points worth noting about the difference between Groovy and Python:
    1. In Python, there is no keyword used to define the variable packs; Python expects the first use to
       set a value.
    2. Python dictionary keys (e.g., item, brand, units, price, quantity) require quotes to indicate
       they are strings; Groovy assumes these are strings, but accepts quotes as well.
    3. In Python, the notation { ... } indicates a dictionary declaration; Groovy uses the same square
       brackets as a list, but the structure in both cases must have key-value pairs.

   And, yes, those prices aren't in US dollars.

   Next, unpack the bulk packages. Unpacking the single bulk package of rice, for example, will yield 10
   units of rice; that is, the total number of units yielded is units * quantity. The Groovy script uses
   a handy function called collectMany that can be used to flatten out lists of lists. As far as I know,
   Python doesn't have anything similar, so use two list comprehensions to produce the same result:

    units = [[{'item':pack['item'],'brand':pack['brand'],
            'price':(pack['price'] / pack['units'])}] *
            (pack['units'] * pack['quantity']) for pack in packs]
    units = [x for sublist in units for x in sublist]

   The first list comprehension (assignment to units) builds the list of lists of dictionaries. The
   second "flattens" that into just a list of dictionaries. Note that both Python and Groovy provide
   an * operator that takes a list on the left and a number N on the right and replicates the list N
   times.

   The final step is to repack the units into the hampers for distribution. As in the Groovy version,
   you need to get a bit more specific about the ideal hamper value, and you might as well not be overly
   restrictive when you get down to just a few units left:

    valueIdeal = 5000
    valueMax = valueIdeal * 1.1

   OK! Repack the hampers:

    import random
    hamperNumber = 0           # [1]
    while len(units) > 0:      # [2]
        hamperNumber += 1
        hamper = []
        value = 0
        canAdd = True              # [2.1]
        while canAdd:              # [2.2]
            u = random.randint(0,len(units)-1)  # [2.2.1]
            canAdd = False                      # [2.2.2]
            o = 0                               # [2.2.3]
            while o < len(units):               # [2.2.4]
                uo = (u + o) % len(units)
                unit = units[uo]
                unitPrice = unit['price']          # [2.2.4.1]
                if len(units) < 3 or not (unit in hamper) and (value + unitPrice) < valueMax:
                                                    # [2.2.4.2]
                    hamper.append(unit)
                    value += unitPrice
                    units.pop(u)                   # [2.2.4.3]
                    canAdd = len(units) > 0
                    break                          # [2.2.4.4]
                o += 1                             # [2.2.4.5]
                                                # [2.2.5]
        print('')
        print('Hamper',hamperNumber,'value',value)
        for item in hamper:
            print('%-25s%-25s%7.2f' % (item['item'],item['brand'],item['price'])) # [2.3]
        print('Remaining units',len(units))                                       # [2.4]

   Some clarification, with numbers in brackets in the comments above (e.g., [1]) corresponding to the
   clarifications below:
     * 1. Import Python's random number generator facilities and initialize the hamper number.
     * 2. This while loop will redistribute units into hampers as long as there are more available:
          + 2.1 Increment the hamper number, get a new empty hamper (a list of units), and set its value
            to 0; start off assuming you can add more items to the hamper.
          + 2.2 This while loop will add as many units to the hamper as possible (the Groovy code used a
            for loop, but Python's for loops expect to iterate over something, while Groovy has the more
            traditional C form of for loop):
               o 2.2.1 Get a random number between zero and the number of remaining units minus 1.
               o 2.2.2 Assume you can't find more units to add.
               o 2.2.3 Create a variable to be used for the offset from the starting point where you're
                 looking for items to put in the hamper.
               o 2.2.4 Starting at the randomly chosen index, this while loop will try to find a unit
                 that can be added to the hamper (once again, note that the Python for loop probably
                 isn't suitable here since the length of the list will change during processing).
                    # 2.2.4.1. Figure out which unit to look at (random starting point + offset) and get
                      its price.
                    # 2.2.4.2 You can add this unit to the hamper if there are only a few left or if the
                      value of the hamper isn't too high once the unit is added.
                    # 2.2.4.3 Add the unit to the hamper, increment the hamper value by the unit price,
                      remove the unit from the available units list.
                    # 2.2.4.4 As long as there are units left, you can add more, so break out of this
                      loop to keep looking.
                    # 2.2.4.5 Increment the offset.
               o 2.2.5 On exit from this while loop, if you inspected every remaining unit and could not
                 find one to add to the hamper, the hamper is complete; otherwise, you found one and can
                 continue looking for more.
          + 2.3 Print out the contents of the hamper.
          + 2.4 Print out the remaining units info.

   When you run this code, the output looks quite similar to the output from the Groovy program:

   Hamper 1 value 5304.0
   UHT milk                 Atlantic                  760.00
   Tomato sauce             Best Family               190.00
   Rice                     Best Family               565.00
   Coffee                   Colombia Select          2090.00
   Sugar                    Good Price                565.00
   Vegetable oil            Crafco                    835.00
   Soap                     Sunny Day                 299.00
   Remaining units 148
   Hamper 2 value 5428.0
   Tea                      Superior                  544.00
   Lentils                  Southern Style           1189.00
   Flour                    Neighbor Mills            520.00
   Tofu                     Gourmet Choice           1580.00
   Vegetable oil            Crafco                    835.00
   UHT milk                 Atlantic                  760.00
   Remaining units 142
   Hamper 3 value 5424.0
   Soap                     Sunny Day                 299.00
   Chickpeas                Southern Style           1300.00
   Sardines                 Fresh Caught              909.00
   Rice                     Best Family               565.00
   Vegetable oil            Crafco                    835.00
   Spaghetti                Best Family               327.00
   Lentils                  Southern Style           1189.00
   Remaining units 135
   ...
   Hamper 21 value 5145.0
   Tomato sauce             Best Family               190.00
   Tea                      Superior                  544.00
   Chickpeas                Southern Style           1300.00
   Spaghetti                Best Family               327.00
   UHT milk                 Atlantic                  760.00
   Vegetable oil            Crafco                    835.00
   Lentils                  Southern Style           1189.00
   Remaining units 4
   Hamper 22 value 2874.0
   Sardines                 Fresh Caught              909.00
   Vegetable oil            Crafco                    835.00
   Rice                     Best Family               565.00
   Rice                     Best Family               565.00
   Remaining units 0

   The last hamper is abbreviated in contents and value.

Closing thoughts
   At a glance, there isn't a whole lot of difference between the Python and Groovy versions of this
   program. Both have a similar set of constructs that make handling lists and dictionaries very
   straightforward. Neither requires a lot of "boilerplate code" or other "ceremonial" actions.

   Also, as in the Groovy example, there is some fiddly business about being able to add units to the
   hamper. Basically, you pick a random position in the list of units and, starting at that position,
   iterate through the list until you either find a unit whose price allows it to be included or until
   you exhaust the list. Also, when there are only a few items left, you just toss them into the last
   hamper.

   Another issue worth mentioning: This isn't a particularly efficient approach. Removing elements from
   lists, being careless about repeated expressions, and a few other things make this less suitable for
   a huge redistribution problem. Still, it runs in a blink on my old machine.

   If you are shuddering at my use of while loops and mutating the data in this code, you probably wish
   I made it more functional. I couldn't think of a way to use map and reduce features in Python in
   conjunction with a random selection of units for repackaging. Can you?

   In the next article, I'll re-do this in Java just to see how much less effort Groovy and Python are,
   and future articles will cover Julia and Go.


---
