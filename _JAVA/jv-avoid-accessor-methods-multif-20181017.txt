filename: jv_avoid-accessor-methods-multif_20181017.txt
https://dzone.com/articles/gettersetterthe-most-hated-practice-in-java

Getter/Setter: The Most Hated Practice in Java

You should use getter/setter. If you don't, you are not a good programmer. Really? Creating getters and
setters is an excellent way to pollute your code.

   You should use getter/setter.
   You should use getter/setter.
   You should use getter/setter.
   If you don't, you are not a good programmer. Really?

   But, creating getters and setters is an excellent way to pollute your code. Most of the time, you
   don't do anything with the variable in getter and setter methods. Why bother having them after all?
   If your company pays you by lines of code, I bet you will never complain about having them. (You'd
   rather quit that company instead. I mean after you have generated a million lines of useless code ;P)

   Actually, getter and setter methods are not useful at all if you're really sure that you will not use
   your class differently from your initial intention. I emphasized the word `really` because code
   almost always evolves beyond our initial intent. That's why it has become good practice to have
   getter and setter methods for a variable and never allow accessing a variable directly! Look at the
   following code:
class YourClass {
    public int myVar;
}
class SomeoneElseClass {
    public void doSomethingWithYourClass(YourClass yc){
        yc.myVar = getValueFromBlackhole();
        transmitToWhitehole(yc);
    }
}

   One day, you think it's better to add the validation logic for the variable myVar because other
   people keep sending incorrect values to your system. Without a setter, you can't fix it by yourself.
   You have to ask other people to change their code if you want to change the visibility of the
   variable myVar from public to private and expose the setter method that alters the variable myVar. If
   the only person who uses your code is the person that sits next to you, it would not be difficult to
   politely ask them do so. The worse solution is asking them to add the validation logic before setting
   myVar variable in their code. Imagine that there are a lot of people who are using your code and you
   don't know them. Furthermore, if they are a customer, they're not going to fix your problem. That's
   why people keep saying you should use getter and setter methods.

   This good practice can become irrelevant when you use a language that can hook getter and setter
   methods to the existing interface. So, you don't have to pollute your code by writing getter and
   setter methods explicitly right from the get-go.

   I will show you why you don't have to declare getter and setter methods in some languages.

Python
   In Python, you can declare the public variable that allows other classes access it directly. It
   sounds really bad if you're a Java programmer but for Python folks, this is normal because they can
   change their mind later by adding the property function (method) without affecting the interface.
//Your class
class YourClass(object):
    my_var = 0
class SomeoneElseClass(object):
    def do_something(self, yc):
        yc.my_var = get_value_from_blackhole()
        transmit_to_whitehole(yc)

   When you want to add the setter method for the variable my_var later, you can do so by using
   annotations as the following:
class YourClass(object):
    my_var = 0
    @property
    def my_var(self):
        return self._my_var

    @my_var.setter
    def my_var(self, value):
        print("Easy peasy")
        self._my_var = value

   The alternative approach is to use the property function instead of annotations.
class YourClass(object):
    def get_my_var(self):
        return self._my_var
    def set_my_var(self, value):
        print("Easy peasy")
        self._my_var = value
    my_var = property(get_my_var, set_my_var)

C#.NET
   C# has special syntax for the property feature unlike Python that uses either annotations or
   functions. You might be mistaken that the following code is Java code. Yes, it does compile in Java.
   So, I adjusted the code format a bit to make it more like .NET :).
class YourClass
{
    public int MyVar;
}
class SomeoneElseClass
{
    public void DoSomethingWithYourClass(YourClass yc)
    {
        yc.MyVar = GetValueFromBlackhole();
        TransmitToWhitehole(yc);
    }
}

   When you want to add a setter method, you can do so by declaring a property using the same name as a
   public variable and change the backing variable name to something else. Note that if you want to add
   the mutator (setter) to the property, you also have to add the accessor (getter). Otherwise, it won't
   compile. In contrast, you can add just the accessor without having the mutator.
class YourClass
{
    //rename MyVar to myVar and use it as backing variable
    private int myVar;
    //add property MyVar to replace MyVar variable
    public int MyVar
    {
        get { return myVar; }
        set
        {
            System.Console.WriteLine("Easy peasy");
            myVar = value;
        }
    }
}

Scala
   Scala doesn't have special keywords, annotations, or functions to implement the property feature like
   in Python, .NET, and some other languages. Scala uses naming convention to do that and the compiler
   knows how to handle it specially.
class YourClass() {
    var myVar = ""
}
class SomeoneElseClass() {
    def doSomething(yc: YourClass) = {
        yc.myVar = getValueFromBlackhole()
        transmitToWhitehole(yc)
    }
}

   If you want to add the setter method for the variable myVar, you have to rename the variable myVar to
   _myVar (can be any name that will not collide with myVar) and change its visibility to private. You
   also have to declare the function named myVar for the accessor and myVar_= for the mutator. Note that
   you have to declare both accessor and mutator methods in order to make the mutator works. (same rule
   as Python and C#.NET)
class YourClass() {
    //rename myVar variable to _myVar
    private var _myVar = 0
    //getter
    def myVar = _myVar
    //setter
    def myVar_= (value: Int): Unit = _myVar = value
}

   But, really? Who uses this feature in Scala anyway :P. Some Scala folks don't even know that this
   feature exists. You can program Scala the same way you do with Java, but that's discouraging. Scala
   folks seem to enjoy having no mutable state in their program and make their code functional as much
   as possible. Mutable states are for exceptional cases only, such as with low-level I/O.

What About Java?
   Sorry, Java doesn't have property feature out of the box, and it seems like they don't have a plan to
   add it in the near future. At least, not in Java 9 or 10. Nevertheless, you can use a framework that
   can generate getter and setter methods for you. If you're interested, take a look at [36]project
   lombok. It is basically a code generation framework that generates the getter and setter methods for
   you behind the scenes. It also can generate other methods such as toString(), equals(), and
   hashCode(). It's very nice to use this tool when you have a lot of data classes (no business logic
   just a plain POJO holding attributes).

   When you have lombok working in your project, you just have to annotate your data class with @Data
   annotation like the following.
public class @Data YourClass {
    private int myVar;
}

   lombok will generate code and compile. You won't see the code that it generates but it will be
   similar to the following.
public class YourClass {
    private int myVar;

    public int getMyVar(){
        return myVar;
    }

    public void setMyVar(String myVar){
        this.myVar = myVar;
    }
    @Override public String toString(){
        return "YourClass(" + this.getMyVar() + ")";
    }
    protected boolean canEqual(Object other) {
        return other instanceof YourClass;
    }
    @Override public boolean equals(Object o) {
        if (o == this) return true;
        if(! (o instanceof YourClass)) return false;
        YourClass other = (YourClass)o;
        if(!other.canEquals((Object)this)) return false;
        if(this.getMyVar() != other.getMyVar()) return false;
        return true;
    }
    @Override public int hashCode() {
        final int PRIME = 59;
        int result = 1;
        result = (result * PRIME) + this.geMyVar();
        return result;
    }
}

   That's nice, isn't it? I know that other languages provide this feature out of the box. But, if you
   have to use Java, lombok is the way to go.

   BloomReach CMS: the API-first CMS of the future. Open-source & enterprise-grade. - As a Java
   developer, you will feel at home using Maven builds and your favorite IDE (e.g. Eclipse or IntelliJ)
   and continuous integration server (e.g. Jenkins). Manage your Java objects using Spring Framework,
   write your templates in JSP or Freemarker.


---
https://sanaulla.info/2015/01/17/getting-rid-of-getters-and-setters-in-your-pojo/

Getting rid of Getters and Setters in your POJO
January 17, 2015

   We all have read in Java books about encapsulation of fields in Java class and also when ever you
   code you are asked to take special care in encapsulating the fields and providing explicit Getters
   and Setters. And these are very strict instructions. Lets step back a bit and find out the reason
   behind encapsulating the fields. Its all done to have a control over the access and modification of
   the fields. One might want to allow the user of the class to access data from only few fields or
   control the update of data of the fields in the class and so on. And on other occassions the
   frameworks would need these getters and setters to populate your POJOs(Plain Old Java Objects).

   Now the pain involved in adding these getters and setters is quite a bit and this pain has been
   reduced by the IDEs which allow you to generate the getters and setters for the fields. But these
   generated code make your class definition very verbose and hide the actual business logic, if any,
   which you might have it inside the class definition. There have been lot of ways by which you can get
   away with defining the getters and setters explicitly and I have even blogged about [27]using Project
   Lombok to use annotations to declare the getters and setters. I have come across another approach to
   avoid defining the getters and setters and this approach doesn't even auto generate the code or use
   annotations to define them. I am sure I have read this approach somewhere but unable to recall, so
   its something which has been used and I am trying to create an awareness among my readers about this
   approach via this blog post.

   Let me first define the class with the getters and setters and then show how to get rid of them
class TaskWithGettersSetters {
  public TaskWithGettersSetters(String title, String notes,
      LocalDateTime deadline, String assignedTo) {
    this.title = title;
    this.notes = notes;
    this.addedOn = LocalDateTime.now();
    this.deadline = deadline;
    this.assignedTo = assignedTo;
  }

  public TaskWithGettersSetters() {
  }

  private String        title;
  private String        notes;
  private LocalDateTime addedOn;
  private LocalDateTime deadline;
  private String        assignedTo;

  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }

  public String getNotes() {
    return notes;
  }

  public void setNotes(String notes) {
    this.notes = notes;
  }

  public LocalDateTime getAddedOn() {
    return addedOn;
  }

  public void setAddedOn(LocalDateTime addedOn) {
    this.addedOn = addedOn;
  }

  public LocalDateTime getDeadline() {
    return deadline;
  }

  public void setDeadline(LocalDateTime deadline) {
    this.deadline = deadline;
  }

  public String getAssignedTo() {
    return assignedTo;
  }

  public void setAssignedTo(String assignedTo) {
    this.assignedTo = assignedTo;
  }

}

   There is nothing to explain in the above code, pretty clear with fields being private and public
   getters and setters. The class definition is about 60 lines. Let see how we can define class without
   providing getters and setters:
class Task {

  public Task(String title, String notes, LocalDateTime deadline,
      String assignedTo) {
    this.title = title;
    this.notes = notes;
    this.addedOn = LocalDateTime.now();
    this.deadline = deadline;
    this.assignedTo = assignedTo;
  }

  public final String        title;
  public final String        notes;
  public final LocalDateTime addedOn;
  public final LocalDateTime deadline;
  public final String        assignedTo;

}

   The above is what I call class definition on diet. It is less verbose and is just 18 lines. You must
   be scared looking at the public modifiers for the fields and also confused looking at the final
   modifiers to the field. Let me explain the ideology behind this approach:
    1. As the fields are final they cannot be modified after initialized so we need not worry about the
       scare of data in the field getting modified. And we have to provide a constructor which will
       initialize these fields, otherwise compiler will shout at you for not understanding what final
       modifier is.
    2. The data in the fields can be accessed by using the fields directly and not via the getter
       methods.
    3. This approach enforces immutability of objects i.e if we have to update the field we have to
       create a new object with the updated value of the field.

   Now having Immutable objects provides lots of advantages few of them being:
     * Writing concurrent code is quite easy because we need not worry about getting locks on the object
       as we are never going to modify the object, we can just read the object data and cannot modify
       due to the use of final.
     * Immutable objects leads to having lot of short lived objects which helps in reducing the GC
       overhead involved in managing long lived objects and objects with lot of live references.

   We can even provide a [28]factory method for creating instances of Task. Lets see the above class in
   action:
import java.time.LocalDateTime;

public class GettingRidOfGettersSettersDemo {
  public static void main(String[] args) {
    //One can make use of Factory method to initialize the data
    Task task1 = new Task("Task 1", "some notes", LocalDateTime.now().plusDays(5), "sana");
    //Very clean approach to access the field data - no getYYY() noise
    System.out.println(task1.title + " assigned to " + task1.assignedTo);
    Task task2  = new Task("Task 2", "some notes", LocalDateTime.now().plusDays(6), "raj");
    System.out.println(task2.title + " assigned to " + task2.assignedTo);
  }
}

   Update:
   Thanks a lot for the comments and your thoughts both here and on DZone. I spent some time in
   identifying how one can work without the need for getters and setters in scenarios mentioned where
   without getters and setters its not possible. One such scenario is marsalling and unmarshalling of
   JSON and another scenario is where we have a List of some values as property and we need to give an
   read only access to the users of the object. The below are examples of using POJOs without getters
   and setters in JSON marshalling and unmarshalling using GSON and Jackson JSON libraries:

   The below is the code for using GSON JSON Library:
public class GsonParserDemo {

  public static void main(String[] args) {
    HashMap<String, Object> jsonData = new HashMap<String, Object>();
    jsonData.put("name", "sanaulla");
    jsonData.put("place", "bangalore");
    jsonData.put("interests", Arrays.asList("blogging", "coding"));
    Gson gson = new Gson();

    String jsonString = gson.toJson(jsonData);
    System.out.println("From Map: " + jsonString);

    Person person = gson.fromJson(jsonString, Person.class);

    System.out.println("From Person.class: " + gson.toJson(person));
  }

  class Person {
    public final String name;
    public final String place;
    private final List<String> interests;

    public Person(String name, String place, List<String> interests) {
      this.name = name;
      this.place = place;
      this.interests = interests;
    }

    public List<String> interests(){
      return Collections.unmodifiableList(interests);
    }
  }
}

   The output of above code is:
From Map: {"name":"sanaulla","place":"bangalore","interests":["blogging","coding"]}
From Person.class: {"name":"sanaulla","place":"bangalore","interests":["blogging","coding"]}

   To note : GSON doesn't use constructor nor getters and setters to map JSON to Java class.

   The below is the code for using Jackson JSON Library:
public class JacksonParserDemo {
  public static void main(String[] args) throws JsonGenerationException,
      JsonMappingException, IOException {
    HashMap<String, String> jsonData = new HashMap<String, String>();
    jsonData.put("name", "sanaulla");
    jsonData.put("place", "bangalore");

    ObjectMapper objectMapper = new ObjectMapper();

    String jsonString = objectMapper.writeValueAsString(jsonData);
    System.out.println("Json from map : " + jsonString);

    Person person = objectMapper.readValue(jsonString, Person.class);
    System.out.println("Json from Person : "
        + objectMapper.writeValueAsString(person));
  }

}
class Person {

  public final String name;

  public final String place;

  @JsonCreator
  public Person(@JsonProperty("name") String name,
      @JsonProperty("place") String place) {
    this.name = name;
    this.place = place;
  }

}

   The output of the above code is:
Json from map : {"name":"sanaulla","place":"bangalore"}
Json from Person : {"name":"sanaulla","place":"bangalore"}

   I am investigating some concerns raised about Object Relational Mappers and the Joda Time.


---
https://www.edc4it.com/blog/java/java-developers-please-stop-using-getterssetters-in-your-domain-objects.html

Java Developers, please stop using getters/setters (in your Domain Objects)!
March 2011

   Every time I see developers at work or inspect code from them it strikes me how many getters and
   setters are used in domain objects (this post is not about value objects/data transfer objects; these
   are just fancy data structures in language that does not allow them).

Your code?
   Most developers just write or generate getters/setters without even thinking about it (remember I am
   taking about domain objects here, again no problem for data-carrying objects). Recall from your
   Object-oriented training/reading that OO is all about behaviour and that state (data) is the result
   of this behaviour (iow you first find the methods and then perhaps define the necessary fields to
   support that behaviour)

   Let's take a look at an example:
public class Member{
    private String username;
    private String email;
    private boolean active;
    // more state ...

    public String getUsername(){ ...}
    public String setUsername(String s){ ...}

    public String getEmail(){ ...}
    public String setEmail(String s){ ...}

    public String isActive(){ ...}
    public String setActive(boolean s){ ...}

    //Actual methods ...
    public Loan addLoan(Book book) {...}
    public void returnBook(Loan loan) {...}
    //etc

    //equals() and hasCode() base on username
}

   Looks familiar? Now the question is, why are these getters and setters there (yes, you are right they
   were probably generated by using this terrible feature of your IDE)?

Setters
   Let's start with those "setters" (not even an English word, closes comes the "bird dogs", such as the
   English Setter). Do the methods setEmail, setActive and setUsername really make sense if you put your
   OO hat on? Recall object state changes due to behaviour, what is the behaviour that changes the state
   of these fields (and how were they found in the first place, if you don't take OO's behaviour-first
   route!!??!)

   Actually there is probably behaviour that requires the state of the object to change. You introduced
   a setter with a reason. There is another object calling it! The behaviour is in that "caller" object
   should be inside this Member object! Recall "cohesion"?

   Perhaps the code below (only looking at these setters) makes more sense:
public class Member{
  private String username;
  private String email;
  private boolean active;
  // more state ...

  //Actual methods ...
  public void activateMembership(){
        this.active=true;
  }

  public void changeEmailAddress(String newEmail){
        // perhaps some business rules?
  this.email = newEmail;
  }

  public Loan addLoan(Book book) {...}
  public void returnBook(Loan loan) {...}
  //etc

}

   If you think we just throwing letters around and naming the same thing different, then you are wrong.
   It is all about OO principles and how you should thing when you develop using OO. Notice also that
   there is no setUsername (which unfortunately is often the situation as a registered member)

Getters
   Often the same for these getters. it should not be automatism to have getters for the state of an
   object. Let's take for example the isActive. This method should be born from an actual requirement in
   one of your iterations, leave it out until that moment comes! Perhaps in all the iterations so far,
   the active flag is only used internally by the object in order to enforce the business rule that only
   active members can borrow books and make reservations.

   There are probably two reasons to have getters:
     * Access outside architectural OO boundaries (for example to show on the UI to present to a user)
     * When another object in fact needs to raw state (first look if the responsibilities lie correct!)

But JPA...
   I hear somebody saying "But what about all these frameworks like JPA and Hibernate" (if you were
   thinking "Spring", then keep in mind that Spring Framework is not a framework around domain objects,
   but around PUFO's ([14]Pure Fubricated Objects).

   No problem, in fact using "properties" in JPA/Hibernate does not make a lot of sense (hmm i'm using
   that word quite often). These ORM frameworks need to persist the state of an object; the state of an
   object are captured in its fields, not methods. Therefore you always better use the JPA annotations
   on the fields as opposed to the property methods!

But JSF...
   "But what if i want to use my domain objects in my view, such as JSF?"...hmmm that makes my
   architectural hairs in my neck stand up, but let's say you follow that approach (I'm an
   advocate/evangelist of Service and Component based Application Architectures, were domain objects are
   never exposed beyond the boundaries of component that owns them).

   Yes in this situation you need to butcher and ruin your Object Oriented design and use getters and
   setters (but these kind of things always happen if you don't follow a correct architecture, code
   starts producing a terrible stench). The problem here is actually Java's approach to properties. If
   at the early start of Java, they listened more to Borland they would have had properties as a first
   class programming concept (like is the case in C#).

   TLDR: stop using getters/setters in domain objects! If you still need them (e.g, exposing them to
   your view), then either change your software architecture or get nose clips and air freshener in the
   office to protect you from your code's odor.
   Published 23 March 2011, tags [design, anemic domain model, oop, getters and setters]


---
https://blog.codecentric.de/en/2016/02/write-accessor-methods/

Why do you write accessor methods?

   We all know the getXxx() and setXxx() methods in languages like Java. They appear in almost every
   project and everybody uses them. But why do we cling to these methods? Do we need them? What about
   just making the fields public? If you are also asking yourself these questions please read on.

Object Inspection
   Where are these methods coming from? For different purposes there was the need to inspect objects at
   runtime. The JDK 1.1 therefore brought the [35]Reflection API, which allows to examine and manipulate
   objects. This new API is used by the [36]JavaBean Specification, which amongst other things defines a
   standard how to use reflection to access properties of objects.

   JavaBeans are often mentioned in discussions about Java objects that simply hold values. Usually it
   is said that a Java object has to meet three conditions to be considered a JavaBean:
     * a constructor without any arguments (aka default constructor)
     * private attributes with their accessor methods (getters and setters)
     * implements the java.io.Serializable interface

   The original specification is much more than these three lines - it's about 114 pages - and it has a
   completely different focus:

     The goal of the JavaBeans APIs is to define a software component model for Java, so that
     third-party ISVs [Independent Software Vendors] can create and ship Java components that can be
     composed together into applications by end users.

     A Java Bean is a reusable software component that can be manipulated visually in a builder tool.

   When reading these two quotes (or even better the whole spec), one can see, that the document is
   about composable components (often graphical), that have properties and behaviour. The properties of
   these components should be editable in a graphical tool (builder), which leads to the requirements
   listed above. The building tool can then use introspection as defined in the JavaBean specification
   to manipulate the properties and serialization to store the beans. But the spec is much more than
   that, JavaBeans should support many more features, e.g. events. Properties of JavaBeans can be much
   more complex than just storing and returning a value of a private field. The value can be computed,
   there are bound properties which perform notifications on changes and there can even be constrained
   properties, whose value changes can be rejected through vetoes.

   In conclusion we can see that JavaBeans is a specification for (visual) application components with
   behaviour. So it is surprising that it is regularly mentioned in the context of data objects without
   behaviour. So we have to ask: is the spec really the best fit for such objects?

   The reason behind the widespread use of the bean specification might be, that the standardized way of
   accessing properties (originally intended for builder tools) is also a basic requirement for other
   tools like mappers and marshallers, which work with the data part of objects.

   So nowadays, getters and setters are everywhere, especially when objects are processed by standard
   frameworks or libraries. The accessor methods do not even have to be hand-written, but can be
   generated quite easily by the IDE or even more convenient at compile-time by tools like [37]Project
   Lombok, [38]Joda Beans and the [39]case [40]objects of Scala. But on the other side this creates the
   risk, that programmers don't think about these methods and simply generate all possible accessors
   without asking if they are indeed needed. And these methods may be harmful, as they can break basic
   principles of object-orientation.

The Object Oriented Perspective
   The basic idea of object-oriented programming is to have objects, which combine state and behaviour.
   The state is owned by the object and therefore internal and encapsulated. Encapsulation means that
   the structure and details of the internal data are not part of the public interface.

   On the other side are data objects like entities and value objects (as defined in Domain Driven
   Design) or data transfer objects ([41]DTOs), which typically have private instance variables and
   public getter/setter methods. These methods commonly mirror the internal structure and directly
   access all internal variables without further logic. This leads to two issues (see [42]also) :
    1. These objects do not follow the general idea of object orientation, as there is no data hiding
       within these objects.
    2. As a consequence, developers tend to create anemic domain models, which do not provide domain
       specific operations, but only hold data. A consequence is that the interaction with the "data
       holding objects" is through getter and setter invocations.

   For example an address change of a customer should be performed by calling
   customer.changeAddress(...) instead of customer.setAddress(...). The difference is that
   changeAddress() can perform other actions e.g. change verification flags or send notifications.
   Unfortunately the existence of the accessor methods allows the developer to easily solve his problem
   (change the address) without being required to think about proper method names and semantics. You are
   not alone in this: we see the widespread usage of accessor methods in all projects. Because our mind
   is shaped to use accessor methods it requires a lot of effort to avoid this pattern.

   We have already mentioned that frameworks and libraries may require to use setter and getter methods.
   But how often is it really required by the 3rd-party software?

Frameworks as a Cause?
   Usually in each project different frameworks are used to handle objects. So there is for example
   Jackson to process JSON and Hibernate as an ORM (Object-Relational Mapper). Because we find these two
   frameworks in almost every Java project we want to take a closer look whether these frameworks do
   need accessor methods and how the JavaBeans Specification is related to this. A simple data model has
   been chosen to examine these questions:

   A company has an address and an unsorted set of customers. Each customer also has an address. An
   address consists of a street, house number, zip code and city. All the attributes of an address are
   strings.

   Let's consider three variant: private fields with and without accessor methods and public fields. We
   examine both Jackson (version 2.7.0) and Hibernate (version 5.0.7) in our tests.

   We start with private fields. Jackson and Hibernate work fine with accessor methods. That is the
   standard way (jackson-normal, hibernate-normal). Without these methods, Jackson requires a
   configuration statement to set and access the fields (jackson-normal-without-accessors):
     objectMapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);

   Hibernate also supports objects without accessor methods:

     Although not required, it is recommended to follow JavaBean conventions by defining getters and
     setters for you entities persistent attributes. Hibernate can also directly access the entity's
     fields.

     Attributes (whether fields or getters/setters) need not be declared public. Hibernate can deal
     with attributes declared with public, protected, package or private visibility.

   After verification we can confirm that Hibernate works without additional adjustments. Such objects
   (private fields and no accessor methods) are only useful if you have domain methods which work with
   the private fields. These methods of course may also return some of the fields directly or a
   computation based on the private fields (like a view). In this regard such objects match closely the
   ideal we described in the object-oriented section above.

   Making your fields public is unconventional but not a problem for Jackson and Hibernate
   (jackson-public-fields, hibernate-public-fields). In such a case the accessor methods are
   rendered superfluous and the source code can shrink. Please note that in the JPA
   specification public fields are forbidden (from section 2.2): "The instance variables of a class
   must be private, protected, or package visibility independent of whether field access or property
   access is used." So it turns out that the behaviour we observe with Hibernate contradicts the JPA
   specification by supporting public fields. This deviation from the specification is also the reason
   why the Eclipse IDE shows errors for public fields: "The Java field for attribute 'name' is
   public/final". These errors can be disabled by changing the JPA settings under: project settings /
   JPA / Errors/Warnings / Attribute / The java field for attribute is final/public - error to warning,
   info or ignore.

   As a last experiment we made the fields final in addition to public to reflect the intention of value
   objects. The fields are initialized in the constructor which therefore gets all values as parameters.
   Jackson supports this but requires an annotation for the constructor
   ([51]jackson-final-public-fields):
  @JsonCreator
  public Customer(@JsonProperty("firstName") String firstName,
                  @JsonProperty("lastName") String lastName,
                  @JsonProperty("customerAddress") Address customerAddress) {
  ...
  }

   Java 8 supports the discovery of parameter names using reflection. Jackson can use such data and with
   an additional maven dependency the annotation shown above is unnecessary
   (jackson-final-public-fields-no-annotations).

   Hibernate is used mostly for storing and retrieving entities. These types of object do not benefit
   from final fields and therefore we did not test Hibernate with public final fields.

   The following table shows how the two frameworks deal with different field visibilities and/or the
   existence of accessor methods.
   Framework                        Jackson Hibernate
   Field Visibility Accessor Methods
   Private          existent         +      +
                    non-existent     +      +*
   Public           non-existent     +      +**

   * Hibernate supports this but the scenario is only useful if domain methods are present.
   ** Hibernate supports this but internal structure of entity is disclosed.

   We found that the Jackson and Hibernate framework do not require accessor methods. So you can choose
   to either make the fields public (and maybe even final) to allow easy interaction with value objects.
   Or you can make the fields private for entities and ensure that object orientation is followed.

   Be careful that frameworks (like Hibernate) may differ from other implementations of the
   Specification (like JPA) and that additional effort is required if you switch to another
   implementation.

Alternative Approach
   How would an alternative approach without getters and setters look like? As stated above, domain
   objects should fulfill business needs with domain-specific methods and apply real object orientation.
   Thus, the internal data is protected from direct access, but instead the object offers business
   related methods which operate on the data. Here is a simple example:
  public class Employee {
    enum EmploymentState{
      CURRENT_EMPLOYEE, FORMER_EMPLOYEE;
    }

    private boolean accessToOfficeBerlin;
    private boolean accessToWebapp;
    private double salary;
    private EmploymentState employmentState;
    private Date dismissalDate;

    public void dismiss(){
      if(employmentState == EmploymentState.FORMER_EMPLOYEE){
        throw new IllegalStateException("employee already dismissed");
      }

      employmentState = EmploymentState.FORMER_EMPLOYEE;
      dismissalDate = new Date();

      accessToOfficeBerlin = false;
      accessToWebapp = false;

      salary = 0.0;
    }
  }

   If the dismissal would be done via setter-methods, the developer could forget to set a property. This
   could break invariants, like having a dismissal date for former employees.

   A special type of data objects are value objects. These represent a value without identity, rather
   than an entity. A value object is characterized only by its attributes. Examples are colors, dates or
   amounts of money. They are often used  as parameters. Value objects should be immutable for several
   reasons. It simplifies development, since instances could be easily shared and passing them as
   parameters has no risk of unintentional manipulation. Being immutable also stresses the meaning of a
   value, represented by an instance. Manipulation of the value results in a new value and therefore in
   a new instance. An immutable object can not have setters. Instead it has methods with meaningful
   names to construct new objects.

   The Java 8 Date/Time API is an example built around immutable instances:
  LocalTime now = LocalTime.now();
  System.out.println(now);
  LocalTime in15Minutes = now.plusMinutes(15);// creates a new object
  System.out.println(now);// prints the same as the statement above

   In addition to value objects there are also DTOs. Such objects are used on system boundaries to
   transfer pure data between systems. Examples might be a mapping to a database or transferring data as
   XML/JSON. As shown above, you should verify that the framework you use really needs getters and
   setters. If an object can be completely created by its constructor, then such an object doesn't even
   have to be mutable. If you can not make the fields final it may still be possible to reduce the
   source code size and decrease the complexity by avoiding the accessor methods and use just public
   fields. Such mutable public fields should not be a problem for DTOs, as these objects have a very
   short lifetime and are not used in other parts of the application. Be aware that there is a risk that
   DTOs in general are used not only on the system boundaries but also within the application to a
   larger extent which may lead to bad design.

Conclusion
   So does it mean you can avoid writing getters and setters at all? Not really. There are situations
   where they can be used safely. Especially for the display of data (the V in MVC) there is a need to
   access data and a simple getter does this job very well. Getters may be more relevant at this place
   than setters - you don't need to generate both together!

   To have these accessor methods is also fine if a framework really needs them. But in such cases  it
   is possible to decouple this code from the rest of the application to prevent setters from being used
   in other parts.

   You should always be aware of the risks involved when accessor methods are added and ensure that you
   clearly understand the need, before you add and use such methods. Don't accept the reasons "they are
   easy to generate" and "everybody does it this way". Use domain-specific terminology and business
   logic and by doing so avoid anemic domain models.


---
http://typicalprogrammer.com/doing-it-wrong-getters-and-setters

Doing it wrong: getters and setters
14 Jun 2008

   Every getter and setter in your code represents a failure to encapsulate and creates unnecessary
   coupling. A profusion of getters and setters (also referred to as accessors, accessor methods, and
   properties) is a sign of a poorly-designed set of classes.

   A long time ago programmers discovered that reducing the scope (visibility) of data as much as
   possible led to more reliable and maintainable code. Before programming languages supported
   encapsulation or objects, programmers who cared to write better code followed best practices and
   idioms (what would be called patterns today) that encouraged limiting scope and data hiding. Back in
   the old days these ideas were discussed in terms of module strength and coupling. To learn the
   concepts without the distraction of OOP and "design patterns" terminology see Glenford Myers' books
   Reliable Software Through Composite Design and Composite/Structured Design.

   Today most of the popular programming languages support objects, limiting scope, modularity, passing
   by value, and sophisticated built-in types. There should be no reason to deliberately expose an
   object's data to the rest of the code because the language can enforce encapsulation and data hiding.
   Correct object-oriented design requires an object to encapsulate and hide its data, and to expose
   methods that are verbs acting on the object (not on individual properties of the object). The large
   majority of accessors are nouns - nothing more than pointless proxies for direct access to the
   object's private data.

   Others have pointed this out - see Allen Holub's article "[9]Why getter and setter methods are evil"
   from JavaWorld, for example. But the articles questioning the use of accessors are outnumbered by
   articles explaining how to write them. As with so many programming topics there is more argument
   about the details than about the big picture. Java and C# developers have IDEs that generate getters
   and setters automatically, implying that accessors are a good idea. Instead I think the IDE should
   yellow-flag every public member variable and accessor - they are warnings of bad design.

   This article was prompted by a discussion with some of my own colleagues about how to write accessors
   in ActionScript (Flex). Unfortunately by the time we had that discussion the code we are working on
   was already full of accessors and public variables; introducing a standard for writing accessors
   would do nothing to eliminate the coupling created by the leaky objects. It would, however, insure
   that the code looked the same no matter who wrote it, a greatly overrated goal in my opinion. I was
   too polite to criticize the code's design, and too realistic to expect it would be rewritten because
   it fails to meet even minimal standards of modularity or data hiding. Although enough of us know good
   code when we see it, correct software design is a custom more honored in the breach than the
   observance.

   Here's an example of arguing about the wrong thing. In a popular blog posting "[10]Python is not
   Java" Phillip J. Eby explains how to write accessors the Pythonic way:

     Getters and setters are evil. Evil, evil, I say! Python objects are not Java beans. Do not write
     getters and setters. This is what the 'property' built-in is for. And do not take that to mean
     that you should write getters and setters, and then wrap them in 'property'. That means that until
     you prove that you need anything more than a simple attribute access, don't write getters and
     setters. They are a waste of CPU time, but more important, they are a waste of programmer time.
     Not just for the people writing the code and tests, but for the people who have to read and
     understand them as well.

     In Java, you have to use getters and setters because using public fields gives you no opportunity
     to go back and change your mind later to using getters and setters. So in Java, you might as well
     get the chore out of the way up front. In Python, this is silly, because you can start with a
     normal attribute and change your mind at any time, without affecting any clients of the class. So,
     don't write getters and setters.

   At least Java has refactoring IDEs and compiler type enforcement that make changing the type or
   meaning of a public member variable easy to find and fix. In Python those kinds of changes would
   manifest themselves in a series of runtime errors. This kind of article explains why Java and C#
   programmers (wrongly) conclude that Python needs static typing and a refactoring IDE. The correct
   inference is that getters and setters should be avoided because they break the encapsulation OOP
   offers. Avoiding them for performance or refactoring reasons misses the point.

   Frequently I find that accessors are one of the side-effects of over-application of object oriented
   programming, especially when coding proceeds without a clear OO design. If your language insists that
   you implement everything as an object you have to devise workarounds for situations that don't fit
   the object/message (noun/verb) OOP paradigm. Pretty soon a folklore grows around how to "correctly"
   implement accessors, and programmers focus more on implementing accessors the right way when they
   should be trying to eliminate the need for them in the first place. You can see the same thing with
   other OOP workarounds - the lore surrounding singletons is an even richer mine of how to do the wrong
   thing the right way.

   Programmers who learned how to write getters and setters - especially if their IDE wrote the code for
   them - transfer that baggage to new languages they learn. That's why there is no shortage of articles
   debating how to write accessors in languages that shouldn't need them, e.g. Python, JavaScript, Ruby.

   I've written hundreds of thousands of lines of code in my career, much of it in object-oriented
   languages, and I have rarely needed to expose a member variable or write an accessor. When I have
   it's been to fit in with a code base that is already full of exposed data and accessors; in code like
   that, correctly designed object-oriented code is a square peg because none of the other classes hide
   their data or act on other objects through messages.

   Trying to stop the proliferation of accessors is futile, but you can stop using them yourself. In the
   same way that writers try to eliminate passive voice and weak verbs from their writing, programmers
   can try to avoid getters and setters as much as practical. And when you see code with rampant getters
   and setters or public member variables you can recognize it as the mess it probably is.


---
http://stupidpythonideas.blogspot.com/2015/01/why-dont-you-want-getters-and-setters.html

Why don't you want getters and setters?
If you've migrated to Python from C++ or one of its descendants (Java, C#, D, etc.), or to a lesser extent
from other OO languages (Objective C, Ruby, etc.), the first time you asked for help on StackOverflow or
CodeReview or python-list or anywhere else, the first response you got was probably: "Get rid of those
getters and setters."

If you asked why, you probably got no more of an answer than "You don't need them in Python."

That's exactly the response you should get-but that doesn't mean it's a bad question, just that SO is
the wrong place to answer it (especially in comments).

To answer the question, we have to look at why getters and setters are idiomatic in those other languages,
and see why the same idioms aren't appropriate in Python.
Encapsulation
The first reason you're usually given for using getters and setters is "for encapsulation: consumers of
your class shouldn't even know that it has an attribute x, much less be able to change it willy-nilly."

As an argument for getters and setters, this is nonsense. (And the people who write the C++ standard
agree, but they can't stop people from writing misleading textbooks or tutorials.) Consumers of your
class do know that you have an attribute x, and can change it willy-nilly, because you have a method
named set_x. That's the conventional and idiomatic name for a setter for the x attribute, and it would
be highly confusing to have a method with that name that did anything else.

The point of encapsulation is that the class's interface should be based on what the class does, not on what
its state is. If what it does is just represent a point with x and y values, then the x and y attributes
themselves are meaningful, and a getter and setter don't make them any more meaningful. If what it does
is fetch a URL, parse the resulting JSON, fetch all referenced documents, and index them, then the HTTP
connection pool is not meaningful, and a getter and setter don't make it any more meaningful. Adding a
getter and setter almost never improves encapsulation in any meaningful way.
Computed properties
"Almost always" isn't "always". Say what your class does is represent a point more abstractly, with x, y,
r, and theta values. Maybe x and y are attributes, maybe they're computed on the fly from r and theta. Or
maybe they're sometimes stored as attributes, sometimes computed, depending on how you constructed or
most recently set the instance.

In that case, you obviously do need getters and setters-not to hide the x and y attributes, but to
hide the fact that there may not even be any x and y attributes.

That being said, is this really part of the interface, or just an implementation artifact? Often it's
the latter. In that case, in Python (as in some C++ derived languages, like C#, but not in C++ itself),
you can, and often should, still present them as attributes even if they really aren't, by using @property:

    class Point:
        @property
        def x(self):
            if self._x is None:
                self._x, self._y = Point._polar_to_rect(self._r, self._theta)
            return self.x
        @x.setter
        def x(set, value):
            if self._x is None:
                _, self._y = Point._polar_to_rect(self._r, self._theta)
            self._x = x
            self._r, self._theta = None, None
        # etc.
        
Lifecycle management
Sometimes, at least in C++ and traditional ObjC, even the "dumb" version of encapsulation idea isn't
actually wrong, just oversimplified. Preventing people from setting your attribute by giving them a method
to set your attribute is silly-but in C++, direct access to an attribute allows you to do more than
just set the attribute, it allows you to store a reference to it. And, since C++ isn't garbage-collected,
this means that there's nothing stopping some code from keeping that reference around after your instance
goes out of scope, at which point they've now got a reference to garbage. In fact, this can be a major
source of bugs in C++ code.

If you instead provide a getter or setter, you can ensure that consumers can only get a copy of the
attribute. Or, if you need to provide a reference, you can hold the object by smart pointer and return a
new smart pointer to the object. (Of course this means that people who-usually as a misguided attempt at
optimization-write getters that return a const reference, or that return objects that aren't copy-safe,
like raw pointers, are defeating the entire purpose of having getters and setters in the first place...)

This rationale, which makes perfect sense in C++, is irrelevant to Python. Python is garbage collected. And
Python doesn't provide any way to take references to attributes in the first place; the only thing you
can do is get a new (properly-GC-tracked) reference to the value of the attribute. If your instance
goes away, but someone else is still referencing one of the values you had in an attribute, that value
is still alive and perfectly usable.

Interface stability
Maybe today, you're storing x and y as attributes, but what if you want to change your implementation
to compute them on the fly?

In some languages, like C++, if you're worried about that, the only option you have is to create useless
getters and setters today, so that if you change the implementation tomorrow, your interface doesn't
have to change.

In Python, just expose the attribute; if you change the implementation tomorrow, change the attribute
to a @property, and your interface doesn't have to change.
Interface inheritance
In most languages, a subclass can change the semantics by overriding a getter and setter, but they can't
do the same to a normal attribute.

Even in languages that have properties, in most cases, defining a property with the same name as a
base-class attribute will not affect the base class's code-or, in many languages, even consumers of
the base class's interface; all it'll do is shadow the base class's attribute with a different attribute
for subclasses and direct consumers of the derived class's interface.

Also, in most languages without two-stage initialization, the derived class's code doesn't get a chance
to run until the base class's initializer has finished, so it's not just difficult, but impossible,
to affect how it stores its attributes.

In Python, attribute access is fully dynamic, and two-stage initialization means that __init__ methods
can work downward toward the root instead of upward toward the leaf, so the answer is, again, just @property.
Design by contract
Some tutorials and textbooks explain the need for setters by arguing that you can add pre- and post-condition
tests to the setter, to preserve class invariants. Which is all well and good, but every case I've ever seen,
they go on to show a simple void set_x(int x) {x_ = x; } in the first example, and every subsequent one.

Needless to say, if you really are going to implement DBC today, this is just a case of "computed
properties", and if you're just thinking you might want to implement it later, it's a case of "interface
stability".
Read-only attributes
Sometimes, you want to expose an attribute, but make it read-only. In many languages, like C++, there's
no way to do that but with a getter (and no corresponding setter). In Python, again, the answer is @property.

C++, Java, etc. also give you a way to create class-wide constants. Python doesn't really have constants,
so some people try to simulate this by adding a getter. Again, though, the answer is @property. Or,
consider whether you really need to enforce the fact that it's a constant. Why would someone try to
change it? What would happen if they did?
Access control
C++ and most of its descendants provide three levels of access control-public is the interface to
everyone, protected is additional interface for subclasses, and private is only usable by the class's
own methods and its friends. Sometimes you might want to make an attribute read-only for your subclasses
but writable for your own methods (or read-only for your consumers but writable for your subclasses). The
only way to do this is to make the attribute private (or protected) and add a protected (or public) getter.

First, almost any OO design where this makes sense is probably not idiomatic for Python. (In fact, it's
probably not even idiomatic for modern C++, but a lot of people are still programming 90s-style C++, and
at any rate, it's much more idiomatic in Java. However, nobody is writing 90s-style OO in Python.) Often
you can flatten out and simplify your hierarchy by passing around closures or methods, or by duck typing
(that is, implicitly subtyping by just implementing the right methods, instead of subclassing); if you
really do need subclassing, often you want to refactor your classes into small ABCs and/or mixins.

It's also worth noting that access control doesn't provide any actual security against malicious subclasses
or consumers. (Except in Java; see below.) In ObjC, they can just ask the runtime to inspect your ivars
and change them through pointers. In C++, they can't do that-but everyone using your class has to be
able to see all of your members, even if they're private, as part of the header, and if they really want
to force your class to do something it wouldn't normally do by changing its private members, there's
nothing stopping them from reinterpret_cast<>ing their way to any part of that structure.

At any rate, in Python, even if you wanted to control access this way, you can't do it.

Some people teach that _x is Python's equivalent of protected, and __x its equivalent of private, but
that's very misleading.

The single underscore has only a conventional meaning: don't count on this being part of the useful
and/or stable interface. Many introspection tools (e.g., tab completion in the interactive interface)
will skip over underscore-prefixed names by default, but nothing stops a consumer from writing spam._eggs
to access the value.

The double underscore mangles the name-inside your own methods, the attribute is named __x, but from
anywhere else, it's named _MyClass__x. But this is not there to add any more protection-after all,
_MyClass__x will still show up in dir(my_instance), and someone can still write my_instance._MyClass__x
= 42. What it's there for is to prevent subclasses from accidentally shadowing your attributes
or methods. (This is primarily important when the base classes and subclasses are implemented
independently-you wouldn't want to add a new _spam attribute to your library and accidentally break
any app that subclasses your library and adds a _spam attribute.)
Security
Java was designed to allow components that don't trust each other to run securely. That means that in
some cases, access control does actually provide security. (Of course if you're just going to hide your
x behind a public set_x method, that isn't adding anything...) That's great for Java, but it's irrelevant
to Python, or any language without a secure class loader, etc.
Generic attributes
As far as I know, this one is really only relevant to C++ , because most other languages' generics
were designed around offering most of the useful features of C++ templates without all of the mess,
while C++'s templates were designed before anyone knew what they wanted to do with generics.

There are many cases where it's hard to specify a type for an attribute in a class template. C++ has
much more limited type inference for classes and objects (before C++11, there was none at all) than for
functions and types. Also, a class or class template can have methods that are themselves templates,
but there are no "object templates", so you have to simulate them with either traits classes or function
templates-that is, templated getters and setters. And there are also cases where it's hard to specify
a constant or initializer value for an attribute, so again you have to simulate them with either traits
classes or function templates.

Needless to say, none of these applies at all in duck-typed Python.
Libraries and tools
In some languages, there are libraries for reflection or serialization, observer-notification frameworks,
code-generating wizards for UIs or network protocols, tools like IDEs and refactoring assistants, etc.,
that expect you to use getters and setters. This is particularly true in Java, and to a lesser extent C#
and ObjC. Obviously you don't want to fight against these tools.

The tools and libraries for Python are, of course, designed around the idea that your attributes are
attributes, not hidden behind getters and setters. But if you're, say, using PyObjC to write Python
code that's bound to a NIB both at runtime and in InterfaceBuilder, you have to do things the way
InterfaceBuilder wants you to.
Breakpoints
In some debuggers, it's impossible to place a watchpoint on a variable, or at least much harder or much
less efficient than placing a breakpoint on a setter. If you expect this to be a problem, and you need
to be able to debug code in the field without editing it, you might want to hide some attributes behind
@property for easier debugging. But this doesn't come up very often.
Other languages
So, what if you're a Python programmer and you have to write some code in Java or D? Just as you shouldn't
make your Python code look like Java, you shouldn't make your Java code look like Python. This means
you'll probably want a lot more getters and setters than you're used to.

In Java, C#, D, etc. many of the same motivations (both good and bad) for getters and setters apply the
same as in C++. In some cases, some of the motivations don't apply (e.g., C# has properties, just like
Python; Java generics don't work like C++ templates). So there are a few cases where there are additional
reasons for getters and setters.

But, more importantly, Java (and, to a lesser extent, C#, ObjC, etc.) has a much stronger culture than
C++ of idiomatically requiring getters and setters even when there's no objectively good reason. There
are wizards that generate them for you, linters that warn if you don't use them, IDEs that expect them
to exist, coworkers or customers that complain... And the fact that it's idiomatic is in itself a good
reason to follow the idiom, even if there's no objective basis for it.


---
https://www.python-course.eu/python3_properties.php

Organized Robbery
   George Bernard Shaw once said "Property is organized robbery." This is true in a very positive sense
   in Python as well: A property in Python "robs" the necessity to need getters and setters for
   attributes and to make it possible to start with public attributes instead of having everything
   private!

Sayings about Property
   This is not Python related: Thieves respect property. They merely wish the property to become their
   property that they may more perfectly respect it. "Property has its duties as well as its rights.",
   Thomas Drummond (1797-1840)

Cute Wabbit
   A little girl goes into a pet show and asks for a wabbit. The shop keeper looks down at her, smiles
   and says:
   "Would you like a lovely fluffy little white rabbit, or a cutesy wootesly little brown rabbit?"
   "Actually", says the little girl, "I don't think my python would notice."
   (Nick Leaton, Wed, 04 Dec 1996)

Quote of the Day:
   "Invariably, you'll find that if the language is any good, your users are going to take it to places
   where you never thought it would be taken." (Guido van Rossum)

Data Protection Declaration

Properties vs. Getters and Setters
  Properties
   Venitian Masks: Properties are like Masks Getters and setters are used in many object oriented
   programming languages to ensure the principle of data encapsulation. They are known as mutator
   methods as well. Data encapsulation - as we have learnt in our [70]introduction on Object Oriented
   Programming of our tutorial - is seen as the bundling of data with the methods that operate on these
   data. These methods are of course the getter for retrieving the data and the setter for changing the
   data. According to this principle, the attributes of a class are made private to hide and protect
   them from other code.
   Unfortunately, it is widespread belief that a proper Python class should encapsulate private
   attributes by using getters and setters. As soon as one of these programmers introduces a new
   attribute, he or she will make it a private variable and creates "automatically" a getter and a
   setter for this attributes. Such programmers may even use an editor or an IDE, which automatically
   create getters and setters for all private attributes. These tools even warn the programmer if she or
   he uses a public attribute! Java programmers will wrinkle their brows, screw up their noses, or even
   scream with horror when they read the following: The Pythonic way to introduce attributes is to make
   them public.
   We will explain this later. First, we demonstrate in the following example, how we can design a class
   in a Javaesque way with getters and setters to encapsulate the private attribute "self.__x":
class P:

    def __init__(self,x):
        self.__x = x

    def get_x(self):
        return self.__x

    def set_x(self, x):
        self.__x = x

   We can see in the following demo session how to work with this class and the methods:
>>> from mutators import P
>>> p1 = P(42)
>>> p2 = P(4711)
>>> p1.get_x()
42
>>> p1.set_x(47)
>>> p1.set_x(p1.get_x()+p2.get_x())
>>> p1.get_x()
4758
>>>

   What do you think about the expression "p1.set_x(p1.get_x()+p2.get_x())"? It's ugly, isn't it? It's a
   lot easier to write an expression like the following, if we had a public attribute x:
p1.x = p1.x + p2.x

   Such an assignment is easier to write and above all easier to read than the Javaesque expression.
   Let's rewrite the class P in a Pythonic way. No getter, no setter and instead of the private
   attribute "self.__x" we use a public one:
class P:

    def __init__(self,x):
        self.x = x

   Beautiful, isn't it? Just three lines of code, if we don't count the blank line!
>>> from p import P
>>> p1 = P(42)
>>> p2 = P(4711)
>>> p1.x
42
>>> p1.x = 47
>>> p1.x = p1.x + p2.x
>>> p1.x
4758
>>>

   "But, but, but, but, but ... ", we can hear them howling and screaming, "But there is NO data
   ENCAPSULATION!"
   Yes, in this case there is no data encapsulation. We don't need it in this case. The only thing get_x
   and set_x in our starting example did was "getting the data through" without doing anything, no
   checks nothing.
   But what happens if we want to change the implementation in the future. This is a serious argument.
   Let's assume we want to change the implementation like this: The attribute x can have values between
   0 and 1000. If a value larger than 1000 is assigned, x should be set to 1000. Correspondingly, x
   should be set to 0, if the value is less than 0.
   It is easy to change our first P class to cover this problem. We change the set_x method accordingly:
class P:

    def __init__(self,x):
        self.set_x(x)

    def get_x(self):
        return self.__x

    def set_x(self, x):
        if x < 0:
            self.__x = 0
        elif x > 1000:
            self.__x = 1000
        else:
            self.__x = x

   The following Python session shows that it works the way we want it to work:
>>> from mutators import P
>>> p1 = P(1001)
>>> p1.get_x()
1000
>>> p2 = P(15)
>>> p2.get_x()
15
>>> p3 = P(-1)
>>> p3.get_x()
0

   But there is a catch: Let's assume we have designed our class with the public attribute and no
   methods. People have already used it a lot and they have written code like this:
from p import P
p1 = P(42)
p1.x = 1001

   Our new class means breaking the interface. The attribute x is not available anymore. That's why in
   Java e.g. people are recommended to use only private attributes with getters and setters, so that
   they can change the implementation without having to change the interface.
   But Python offers a solution to this problem. The solution is called properties!
   The class with a property looks like this:
class P:

    def __init__(self,x):
        self.x = x

    @property
    def x(self):
        return self.__x

    @x.setter
    def x(self, x):
        if x < 0:
            self.__x = 0
        elif x > 1000:
            self.__x = 1000
        else:
            self.__x = x

   A method which is used for getting a value is decorated with "@property", i.e. we put this line
   directly in front of the header. The method which has to function as the setter is decorated with
   "@x.setter". If the function had been called "f", we would have to decorate it with "@f.setter".
   Two things are noteworthy: We just put the code line "self.x = x" in the __init__ method and the
   property method x is used to check the limits of the values. The second interesting thing is that we
   wrote "two" methods with the same name and a different number of parameters "def x(self)" and "def
   x(self,x)". We have learned in a previous chapter of our course that this is not possible. It works
   here due to the decorating:
>>> from p import P
>>> p1 = P(1001)
>>> p1.x
1000
>>> p1.x = -12
>>> p1.x
0
>>>

   Alternatively, we could have used a different syntax without decorators to define the property. As
   you can see, the code is definitely less elegant and we have to make sure that we use the getter
   function in the __init__ method again:
class P:

    def __init__(self,x):
        self.set_x(x)

    def get_x(self):
        return self.__x

    def set_x(self, x):
        if x < 0:
            self.__x = 0
        elif x > 1000:
            self.__x = 1000
        else:
            self.__x = x

    x = property(get_x, set_x)

   There is still another problem in the most recent version. We have now two ways to access or change
   the value of x: Either by using "p1.x = 42" or by "p1.set_x(42)". This way we are violating one of
   the fundamentals of Python: "There should be one-- and preferably only one --obvious way to do it."
   (see [71]Zen of Python)
   We can easily fix this problem by turing the getter and the setter method into private methods, which
   can't be accessed anymore by the users of our class P:
class P:

    def __init__(self,x):
        self.__set_x(x)

    def __get_x(self):
        return self.__x

    def __set_x(self, x):
        if x < 0:
            self.__x = 0
        elif x > 1000:
            self.__x = 1000
        else:
            self.__x = x

    x = property(__get_x, __set_x)

   Robot with heart and feelings
   Even though we fixed this problem by using a private getter and setter, the version with the
   decorator "@property" is the Pythonic way to do it!
   From what we have written so far, and what can be seen in other books and tutorials as well, we could
   easily get the impression that there is a one-to-one connection between properties (or mutator
   methods) and the attributes, i.e. that each attribute has or should have its own property (or
   getter-setter-pair) and the other way around. Even in other object oriented languages than Python,
   it's usually not a good idea to implement a class like that. The main reason is that many attributes
   are only internally needed and creating interfaces for the user of the class increases unnecessarily
   the usability of the class. The possible user of a class shouldn't be "drowned" with umpteen - of
   mainly unnecessary - methods or properties!
   The following example shows a class, which has internal attributes, which can't be accessed from
   outside. These are the private attributes self.__potential_physical and self.__potential_psychic.
   Furthermore we show that a property can be deduced from the values of more than one attribute. The
   property "condition" of our example returns the condition of the robot in a descriptive string. The
   condition depends on the sum of the values of the psychic and the physical conditions of the robot.
class Robot:

    def __init__(self, name, build_year, lk = 0.5, lp = 0.5 ):
        self.name = name
        self.build_year = build_year
        self.__potential_physical = lk
        self.__potential_psychic = lp

    @property
    def condition(self):
        s = self.__potential_physical + self.__potential_psychic
        if s <= -1:
           return "I feel miserable!"
        elif s <= 0:
           return "I feel bad!"
        elif s <= 0.5:
           return "Could be worse!"
        elif s <= 1:
           return "Seems to be okay!"
        else:
           return "Great!"

if __name__ == "__main__":
    x = Robot("Marvin", 1979, 0.2, 0.4 )
    y = Robot("Caliban", 1993, -0.4, 0.3)
    print(x.condition)
    print(y.condition)

  Public instead of Private Attributes

   Let's summarize the usage of private and public attributes, getters and setters and properties: Let's
   assume that we are designing a new class and we pondering about an instance or class attribute
   "OurAtt", which we need for the design of our class. We have to observe the following issues:
     * Will the value of "OurAtt" be needed by the possible users of our class?
     * If not, we can or should make it a private attribute.
     * If it has to be accessed, we make it accessible as a public attribute
     * We will define it as a private attribute with the corresponding property, if and only if we have
       to do some checks or transformation of the data. (As an example, you can have a look again at our
       class P, where the attribute has to be in the interval between 0 and 1000, which is ensured by
       the property "x")
     * Alternatively, you could use a getter and a setter, but using a property is the Pythonic way to
       deal with it!

   Let's assume we have defined "OurAtt" as a public attribute. Our class has been successfully used by
   other users for quite a while. Now comes the point which frightens some traditional OOPistas out of
   the wits: Imagine "OurAtt" has been used a an integer. Now, our class has to ensure that "OurAtt" has
   to be a value between 0 and 1000? Without property, this is really a horrible scenario! Due to
   properties it's easy: We create a property version of "OurAtt".

class OurClass:

    def __init__(self, a):
        self.OurAtt = a


x = OurClass(10)
print(x.OurAtt)

   'green arrow' meaning 'is turned into'
class OurClass:

    def __init__(self, a):
        self.OurAtt = a

    @property
    def OurAtt(self):
        return self.__OurAtt

    @OurAtt.setter
    def OurAtt(self, val):
        if val < 0:
            self.__OurAtt = 0
        elif val > 1000:
            self.__OurAtt = 1000
        else:
            self.__OurAtt = val


x = OurClass(10)
print(x.OurAtt)

   This is great, isn't it: You can start with the simplest implementation imaginable, and you are free
   to later migrate to a property version without having to change the interface! So properties are not
   just a replacement for getters and setter!
   Something else you might have already noticed: For the users of a class, properties are syntactically
   identical to ordinary attributes.

   
---
