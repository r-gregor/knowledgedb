filename: jv_packages_arragement_01-multif_20180706.txt
https://docs.oracle.com/javase/tutorial/java/package/packages.html

Creating and Using Packages

   To make types easier to find and use, to avoid naming conflicts, and to control access, programmers
   bundle groups of related types into packages.
     ________________________________________________________________________________________________

   Definition: A package is a grouping of related types providing access protection and name space
   management. Note that types refers to classes, interfaces, enumerations, and annotation types.
   Enumerations and annotation types are special kinds of classes and interfaces, respectively, so types
   are often referred to in this lesson simply as classes and interfaces.
     ________________________________________________________________________________________________

   The types that are part of the Java platform are members of various packages that bundle classes by
   function: fundamental classes are in java.lang, classes for reading and writing (input and output)
   are in java.io, and so on. You can put your types in packages too.

   Suppose you write a group of classes that represent graphic objects, such as circles, rectangles,
   lines, and points. You also write an interface, Draggable, that classes implement if they can be
   dragged with the mouse.
//in the Draggable.java file
public interface Draggable {
    ...
}

//in the Graphic.java file
public abstract class Graphic {
    ...
}

//in the Circle.java file
public class Circle extends Graphic
    implements Draggable {
    . . .
}

//in the Rectangle.java file
public class Rectangle extends Graphic
    implements Draggable {
    . . .
}

//in the Point.java file
public class Point extends Graphic
    implements Draggable {
    . . .
}

//in the Line.java file
public class Line extends Graphic
    implements Draggable {
    . . .
}

   You should bundle these classes and the interface in a package for several reasons, including the
   following:
     * You and other programmers can easily determine that these types are related.
     * You and other programmers know where to find types that can provide graphics-related functions.
     * The names of your types won't conflict with the type names in other packages because the package
       creates a new namespace.
     * You can allow types within the package to have unrestricted access to one another yet still
       restrict access for types outside the package.


---
https://docs.oracle.com/javase/tutorial/java/package/createpkgs.html

Creating a Package

   To create a package, you choose a name for the package (naming conventions are discussed in the next
   section) and put a package statement with that name at the top of every source file that contains the
   types (classes, interfaces, enumerations, and annotation types) that you want to include in the
   package.

   The package statement (for example, package graphics;) must be the first line in the source file.
   There can be only one package statement in each source file, and it applies to all types in the file.
     ________________________________________________________________________________________________

   Note: If you put multiple types in a single source file, only one can be public, and it must have the
   same name as the source file. For example, you can define public class Circle in the file
   Circle.java, define public interface Draggable in the file Draggable.java, define public enum Day in
   the file Day.java, and so forth.
   You can include non-public types in the same file as a public type (this is strongly discouraged,
   unless the non-public types are small and closely related to the public type), but only the public
   type will be accessible from outside of the package. All the top-level, non-public types will be
   package private.
     ________________________________________________________________________________________________

   If you put the graphics interface and classes listed in the preceding section in a package called
   graphics, you would need six source files, like this:
//in the Draggable.java file
package graphics;
public interface Draggable {
    . . .
}

//in the Graphic.java file
package graphics;
public abstract class Graphic {
    . . .
}

//in the Circle.java file
package graphics;
public class Circle extends Graphic
    implements Draggable {
    . . .
}

//in the Rectangle.java file
package graphics;
public class Rectangle extends Graphic
    implements Draggable {
    . . .
}

//in the Point.java file
package graphics;
public class Point extends Graphic
    implements Draggable {
    . . .
}

//in the Line.java file
package graphics;
public class Line extends Graphic
    implements Draggable {
    . . .
}

   If you do not use a package statement, your type ends up in an unnamed package. Generally speaking,
   an unnamed package is only for small or temporary applications or when you are just beginning the
   development process. Otherwise, classes and interfaces belong in named packages.


---
https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html

Naming a Package

   With programmers worldwide writing classes and interfaces using the Java programming language, it is
   likely that many programmers will use the same name for different types. In fact, the previous
   example does just that: It defines a Rectangle class when there is already a Rectangle class in the
   java.awt package. Still, the compiler allows both classes to have the same name if they are in
   different packages. The fully qualified name of each Rectangle class includes the package name. That
   is, the fully qualified name of the Rectangle class in the graphics package is graphics.Rectangle,
   and the fully qualified name of the Rectangle class in the java.awt package is java.awt.Rectangle.

   This works well unless two independent programmers use the same name for their packages. What
   prevents this problem? Convention.

Naming Conventions
   Package names are written in all lower case to avoid conflict with the names of classes or
   interfaces.

   Companies use their reversed Internet domain name to begin their package names—for example,
   com.example.mypackage for a package named mypackage created by a programmer at example.com.

   Name collisions that occur within a single company need to be handled by convention within that
   company, perhaps by including the region or the project name after the company name (for example,
   com.example.region.mypackage).

   Packages in the Java language itself begin with java. or javax.

   In some cases, the internet domain name may not be a valid package name. This can occur if the domain
   name contains a hyphen or other special character, if the package name begins with a digit or other
   character that is illegal to use as the beginning of a Java name, or if the package name contains a
   reserved Java keyword, such as "int". In this event, the suggested convention is to add an
   underscore. For example:

   CAPTION: Legalizing Package Names

   Domain Name                      Package Name Prefix
   hyphenated-name.example.org      org.example.hyphenated_name
   example.int                      int_.example
   123name.example.com              com.example._123name


---
https://docs.oracle.com/javase/tutorial/java/package/usepkgs.html

Using Package Members

   The types that comprise a package are known as the package members.

   To use a public package member from outside its package, you must do one of the following:
     * Refer to the member by its fully qualified name
     * Import the package member
     * Import the member's entire package

   Each is appropriate for different situations, as explained in the sections that follow.

Referring to a Package Member by Its Qualified Name
   So far, most of the examples in this tutorial have referred to types by their simple names, such as
   Rectangle and StackOfInts. You can use a package member's simple name if the code you are writing is
   in the same package as that member or if that member has been imported.

   However, if you are trying to use a member from a different package and that package has not been
   imported, you must use the member's fully qualified name, which includes the package name. Here is
   the fully qualified name for the Rectangle class declared in the graphics package in the previous
   example.
graphics.Rectangle

   You could use this qualified name to create an instance of graphics.Rectangle:
graphics.Rectangle myRect = new graphics.Rectangle();

   Qualified names are all right for infrequent use. When a name is used repetitively, however, typing
   the name repeatedly becomes tedious and the code becomes difficult to read. As an alternative, you
   can import the member or its package and then use its simple name.

Importing a Package Member
   To import a specific member into the current file, put an import statement at the beginning of the
   file before any type definitions but after the package statement, if there is one. Here's how you
   would import the Rectangle class from the graphics package created in the previous section.
import graphics.Rectangle;

   Now you can refer to the Rectangle class by its simple name.
Rectangle myRectangle = new Rectangle();

   This approach works well if you use just a few members from the graphics package. But if you use many
   types from a package, you should import the entire package.

Importing an Entire Package

   To import all the types contained in a particular package, use the import statement with the asterisk
   (*) wildcard character.
import graphics.*;

   Now you can refer to any class or interface in the graphics package by its simple name.
Circle myCircle = new Circle();
Rectangle myRectangle = new Rectangle();

   The asterisk in the import statement can be used only to specify all the classes within a package, as
   shown here. It cannot be used to match a subset of the classes in a package. For example, the
   following does not match all the classes in the graphics package that begin with A.
// does not work
import graphics.A*;

   Instead, it generates a compiler error. With the import statement, you generally import only a single
   package member or an entire package.
     ________________________________________________________________________________________________

   Note: Another, less common form of import allows you to import the public nested classes of an
   enclosing class. For example, if the graphics.Rectangle class contained useful nested classes, such
   as Rectangle.DoubleWide and Rectangle.Square, you could import Rectangle and its nested classes by
   using the following two statements.
import graphics.Rectangle;
import graphics.Rectangle.*;

   Be aware that the second import statement will not import Rectangle.
   Another less common form of import, the static import statement, will be discussed at the end of this
   section.
     ________________________________________________________________________________________________

   For convenience, the Java compiler automatically imports two entire packages for each source file:
   (1) the java.lang package and (2) the current package (the package for the current file).

Apparent Hierarchies of Packages
   At first, packages appear to be hierarchical, but they are not. For example, the Java API includes a
   java.awt package, a java.awt.color package, a java.awt.font package, and many others that begin with
   java.awt. However, the java.awt.color package, the java.awt.font package, and other java.awt.xxxx
   packages are not included in the java.awt package. The prefix java.awt (the Java Abstract Window
   Toolkit) is used for a number of related packages to make the relationship evident, but not to show
   inclusion.

   Importing java.awt.* imports all of the types in the java.awt package, but it does not import
   java.awt.color, java.awt.font, or any other java.awt.xxxx packages. If you plan to use the classes
   and other types in java.awt.color as well as those in java.awt, you must import both packages with
   all their files:
import java.awt.*;
import java.awt.color.*;

Name Ambiguities
   If a member in one package shares its name with a member in another package and both packages are
   imported, you must refer to each member by its qualified name. For example, the graphics package
   defined a class named Rectangle. The java.awt package also contains a Rectangle class. If both
   graphics and java.awt have been imported, the following is ambiguous.
Rectangle rect;

   In such a situation, you have to use the member's fully qualified name to indicate exactly which
   Rectangle class you want. For example,
graphics.Rectangle rect;

The Static Import Statement

   There are situations where you need frequent access to static final fields (constants) and static
   methods from one or two classes. Prefixing the name of these classes over and over can result in
   cluttered code. The static import statement gives you a way to import the constants and static
   methods that you want to use so that you do not need to prefix the name of their class.

   The java.lang.Math class defines the PI constant and many static methods, including methods for
   calculating sines, cosines, tangents, square roots, maxima, minima, exponents, and many more. For
   example,
public static final double PI
    = 3.141592653589793;
public static double cos(double a)
{
    ...
}

   Ordinarily, to use these objects from another class, you prefix the class name, as follows.
double r = Math.cos(Math.PI * theta);

   You can use the static import statement to import the static members of java.lang.Math so that you
   don't need to prefix the class name, Math. The static members of Math can be imported either
   individually:
import static java.lang.Math.PI;

   or as a group:
import static java.lang.Math.*;

   Once they have been imported, the static members can be used without qualification. For example, the
   previous code snippet would become:
double r = cos(PI * theta);

   Obviously, you can write your own classes that contain constants and static methods that you use
   frequently, and then use the static import statement. For example,
import static mypackage.MyConstants.*;
     ________________________________________________________________________________________________

   Note: Use static import very sparingly. Overusing static import can result in code that is difficult
   to read and maintain, because readers of the code won't know which class defines a particular static
   object. Used properly, static import makes code more readable by removing class name repetition.


---
https://docs.oracle.com/javase/tutorial/java/package/managingfiles.html

Managing Source and Class Files

   Many implementations of the Java platform rely on hierarchical file systems to manage source and
   class files, although The Java Language Specification does not require this. The strategy is as
   follows.

   Put the source code for a class, interface, enumeration, or annotation type in a text file whose name
   is the simple name of the type and whose extension is .java. For example:
//in the Rectangle.java file
package graphics;
public class Rectangle {
   ...
}

   Then, put the source file in a directory whose name reflects the name of the package to which the
   type belongs:
.....\graphics\Rectangle.java

   The qualified name of the package member and the path name to the file are parallel, assuming the
   Microsoft Windows file name separator backslash (for UNIX, use the forward slash).
     * class name – graphics.Rectangle
     * pathname to file – graphics\Rectangle.java

   As you should recall, by convention a company uses its reversed Internet domain name for its package
   names. The Example company, whose Internet domain name is example.com, would precede all its package
   names with com.example. Each component of the package name corresponds to a subdirectory. So, if the
   Example company had a com.example.graphics package that contained a Rectangle.java source file, it
   would be contained in a series of subdirectories like this:
....\com\example\graphics\Rectangle.java

   When you compile a source file, the compiler creates a different output file for each type defined in
   it. The base name of the output file is the name of the type, and its extension is .class. For
   example, if the source file is like this
//in the Rectangle.java file
package com.example.graphics;
public class Rectangle {
      . . .
}

class Helper{
      . . .
}

   then the compiled files will be located at:
<path to the parent directory of the output files>\com\example\graphics\Rectangle.class
<path to the parent directory of the output files>\com\example\graphics\Helper.class

   Like the .java source files, the compiled .class files should be in a series of directories that
   reflect the package name. However, the path to the .class files does not have to be the same as the
   path to the .java source files. You can arrange your source and class directories separately, as:
<path_one>\sources\com\example\graphics\Rectangle.java

<path_two>\classes\com\example\graphics\Rectangle.class

   By doing this, you can give the classes directory to other programmers without revealing your
   sources. You also need to manage source and class files in this manner so that the compiler and the
   Java Virtual Machine (JVM) can find all the types your program uses.

   The full path to the classes directory, <path_two>\classes, is called the class path, and is set with
   the CLASSPATH system variable. Both the compiler and the JVM construct the path to your .class files
   by adding the package name to the class path. For example, if
<path_two>\classes

   is your class path, and the package name is
com.example.graphics,

   then the compiler and JVM look for .class files in
<path_two>\classes\com\example\graphics.

   A class path may include several paths, separated by a semicolon (Windows) or colon (UNIX). By
   default, the compiler and the JVM search the current directory and the JAR file containing the Java
   platform classes so that these directories are automatically in your class path.

Setting the CLASSPATH System Variable

   To display the current CLASSPATH variable, use these commands in Windows and UNIX (Bourne shell):
In Windows:   C:\> set CLASSPATH
In UNIX:      % echo $CLASSPATH

   To delete the current contents of the CLASSPATH variable, use these commands:
In Windows:   C:\> set CLASSPATH=
In UNIX:      % unset CLASSPATH; export CLASSPATH

   To set the CLASSPATH variable, use these commands (for example):
In Windows:   C:\> set CLASSPATH=C:\users\george\java\classes
In UNIX:      % CLASSPATH=/home/george/java/classes; export CLASSPATH


---
https://docs.oracle.com/javase/tutorial/java/package/summary-package.html

Summary of Creating and Using Packages

   To create a package for a type, put a package statement as the first statement in the source file
   that contains the type (class, interface, enumeration, or annotation type).

   To use a public type that's in a different package, you have three choices: (1) use the fully
   qualified name of the type, (2) import the type, or (3) import the entire package of which the type
   is a member.

   The path names for a package's source and class files mirror the name of the package.

   You might have to set your CLASSPATH so that the compiler and the JVM can find the .class files for
   your types.


---
https://www.protechtraining.com/content/java_fundamentals_tutorial-packaging

Java Fundamentals Tutorial: Packaging

7. Packaging
     * Packaging Java Code
     * Using Packaged Java Libraries

7.1. Why is Packaging Needed?
     * Packaging protects against name collisions.
          + With thousands of Java libraries available, it’s inevitable that class and interface names
            will be duplicated.
          + Packages allow you to use two different classes or interfaces with the same name.
     * Packages hide implementation that spans multiple classes (multi-class encapsulation).
          + A set of classes might need access to each other, but still be hidden from the outside
            world.
          + Java packages support access levels other than public and private to support information
            sharing and class visibility.
     * Packages help organize source code.
          + Having all source files in the same directory becomes hard to manage as the projects grow.
          + Packages allow you to group together related classes and interfaces into common directories.

   Note
   In addition to classes and interfaces, a Java package can contain definitions of enumerations and
   annotations. These Java constructs are discussed later in this class.

7.2. Packages in Java
     * A Java package name consists of a set of name components separated by periods (.).
          + Each name component must be a valid Java identifier.
          + A component name must not start with an upper-case letter.

            Tip
            Best practice is for each name component to be all lower-case.
     * The package name corresponds to a directory structure on disk where the classes are stored.
          + For example, the class and interface files for org.xml.sax are located in the directory
            org/xml/sax, relative to the directory where Java looks for classes (we’ll discuss this
            later in this module).
     * To add a class or interface to a package:
          + Add package myPackageName; as the first Java statement of the source file
          + In your development directory, store the source file in a directory structure corresponding
            to your package name.

   Tip
   Java does not require you to store your .java source files in in package-based directories, but it is
   a common convention. However, once the source files are compiled, the generated .class files are (and
   must be) stored in the package-based directories.

   It’s also common to have separate, parallel directory hierarchies for your .java and .class files
   reflecting the package structure. Having your source files separate from your class files is
   convenient for maintaining the source code in a source code control system without having to
   explicitly filter out the generated class files. Having the class files in their own independent
   directory hierarchy is also useful for generating JAR files, as discussed later in this module.

   Most modern IDEs can create and manage your source and class file directory hierarchies automatically
   for you.
   [Caution]
   Caution

   If you don’t explicitly specify a package, your classes and interfaces end up in an unnamed packaged,
   also known as the default package. Best practice is not to use the default package for any production
   code.

7.3. Sub-Packages in Java
     * You can construct hierarchical package names, for example org.xml.sax and org.xml.sax.helpers.
          + However, Java treats these as two independent packages, one with class files in org/xml/sax
            and the other with class files in org/xml/helpers.
          + The “information sharing” features of Java packages do not apply across these independent
            packages.
          + Still, hierarchical package names are useful for grouping together related sets of classes.

7.4. Package Naming Conventions
     * To prevent package name collisions, the convention is for organizations to use their reversed
       Internet domain names to begin their package names.
          + For example, com.marakana
          + If the Internet domain name contains an invalid character, such as a hyphen, the convention
            is to replace the invalid character with an underscore. For example, com.avia_training
          + If a domain name component starts with a digit or consists of a reserved Java keyword, the
            convention is to add an underscore to the component name.
     * Organizations often create sub-packages to reflect business units, product lines, etc.
          + For example, com.marakana.android
     * Package names starting with java. and javax. are reserved for Java libraries.

   Java does not do any explicit protection of package namespaces. This means that it is possible for an
   organization ABC to create a class in package com.xyz even though the domain xyz.com belongs to an
   organization called XYZ. However in practice organizations do not abuse each other’s namespaces.

7.5. Using Package Members: Qualified Names
     * The fully-qualified name for a class or interface is the package name followed by the
       class/interface name, separated by a period (.).
          + For example, com.marakana.utils.MyClass
     * Code outside the package can reference public classes and interfaces of a package using their
       fully-qualified names.
     * Code within the package can reference classes and interfaces of the package by their simple
       names, without package qualification.
     * To execute a Java application whose class is contained within a package, you must use its
       fully-qualified name.
          + For example, to run ShapeDemo.main() in the package shape you must invoke it as:
java shape.ShapeDemo

7.6. Importing Package Members
     * Instead of using fully-qualified names for classes and interfaces, you can import the package
       member.
          + To import a specific member from a package, include an import statement specifying the
            fully-qualified name of that member. For example:
import com.marakana.utils.MyClass;
            You can then use the simple (unqualified) name of the member throughout the rest of the
            source file.
          + You can import all of the members of a package by importing the package with an asterisk (*)
            wildcard. For example:
import com.marakana.utils.*;
            You can then use the simple (unqualified) name of all the package members throughout the
            rest of the source file.

            [Important]
            Important
            Using the wildcard import does not import any sub-packages or their members.
     * The import statements must appear after any package statement and before all class/interface
       definitions in your file.

   Note
   The java.lang package is imported automatically into all source files.

   In case there are two or more classes with the same name but defined in different imported (or
   assumed) packages, then those classes must be referenced by their fully-qualified-class-name (FQCN).

   For example, you could define:
com.mycompany.calc.AdditionOperation,

   but someone else could implement:
com.othercompany.calculator.AdditionOperation.

   If you wanted to use both addition operations from a class defined in com.mycompany.calc package,
   then doing
import com.othercompany.calculator.AdditionOperation;

   would make AdditionOperation ambiguous. Instead of importing it, you would reference it by its FQCN.

   Caution
   Even though importing an entire package using the asterisk (*) notation is convenient, it is not
   generally recommended — especially when multiple packages are imported. It makes it harder to track
   down the classes if you do not know exactly which package they come from. Modern IDEs help with
   resolving classes (as well as with organizing imports), but you should not assume that everyone will
   always have an IDE handy.

7.7. Static Imports
     * Prior to Java 5, you always had to access static fields and methods qualified by their class
       name.
          + For example:
double c= Math.PI * Math.pow(r, 2.0);
     * Java 5 introduced import static to import static fields and methods.
          + For example:
import static java.lang.Math.PI;    // A single field
import static java.lang.Math.*;     // All static fields and methods
          + Once imported, you can use them as if they were defined locally:
double c= PI * pow(r, 2.0);

7.8. Access Modifiers and Packages

     * The [41]the last module introduced the concept of the public and private access modifiers that
       control access to fields, methods, constructors, classes, and interfaces.
          + There are two additional access levels:

   Access Modifier          Description
   public                   Accessible from any class
   protected                Accessible from all classes in the same package or any child classes regardless of
                            the package
   default (no modifier)    Accessible only from the classes in the same package (also known as friendly)
   private                  Accessible only from within the same class (or any nested classes)

7.9. The Class Path
     * The class path is the path that the Java runtime environment searches for classes and other
       resource files.
     * By default, Java looks for classes in only the present working directory (.).
     * To access classes at runtime outside the present working directory, there are three options:
          + Set an environmental variable named CLASSPATH with a colon-separated list of class
            directories, JAR files, and/or Zip files. (This should be a semicolon-separated list on
            Windows.)
          + Use use the -classpath option (-cp is an alias) with java and javac to override the class
            path with a colon/semicolon-separated list of class directories, JAR files, and/or Zip
            files.
          + Copy classes to $JAVA_HOME/lib/ext/ (this is typically used only for Java extensions).

   Important
   The class path should include only the root directory of a package directory hierarchy, not the
   individual package directories.

   For example, to run calc.CalculatorDemo located in /home/me/classes/calc/CalculatorDemo.class, you
   could do:
cd /home/me/classes
java calc.CalculatorDemo

   or (from any directory):
export CLASSPATH=/home/me/classes
java calc.CalculatorDemo

   or (from any directory):
java -classpath /home/me/classes calc.CalculatorDemo

   or (from any directory):
cp -r /home/me/classes/calc $JAVA_HOME/lib/ext/.
java calc.CalculatorDemo

   It is important to notice the distinction between class path locations and package directories.
   Package-based directories should never be included within the class path and vice-versa.

   This means that these would not work:
java -classpath /home/me/classes/calc CalculatorDemo
java -classpath /home/me classes.calc.CalculatorDemo

7.10. Java Archive (JAR) Files
     * A Java Archive (JAR) file packages multiple classes in a single compressed file.
          + Based on the ZIP file format
          + Easier and more efficient management of binaries
          + Also known as Java library (.jar extension)
          + Must preserve package directory structure
     * A JAR file can include additional meta-data in a manifest file at the pathname
       META-INF/MANIFEST.MF.
          + The manifest is a text file containing name: value formatted entries.
          + For example, you can make an executable JAR by including a Main-Class entry whose value is
            the fully-qualified name of a class containing a main() method. You could then execute the
            JAR as:
java -jar <file>.jar

   JAR files internally must look like package directories. For example, a class
   com.myco.calc.CalculatorDemo would be stored within calculator.jar file just like it would be stored
   on disk: com/myco/calc/CalculatorDemo.class.

   JAR files are referenced in the CLASSPATH by their actual name, not by the name of the directory in
   which they are contained.

   To run com.myco.calc.CalculatorDemo you would do:
java -classpath calculator.jar com.myco.calc.CalculatorDemo

   To make calculator.jar executable:
    1. Create a file: META-INF/MANIFEST.MF
    2. Add a line:
Main-Class: com.myco.calc.CalculatorDemo
    3. Include META-INF/MANIFEST.MF in calculator.jar
    4. Run with
java -jar calculator.jar

7.11. The jar Command-Line Tool Examples

     * Create a JAR file
cd classes; jar -cvf shape.jar shape
jar -cvf shape.jar -C classes shape
     * View the contents of a JAR file
jar -tvf shape.jar
     * Extract the contents of JAR file
jar -xvf shape.jar
jar -xvf shape.jar META-INF/MANIFEST.MF
     * Update the JAR file (e.g., add to the manifest)
jar -uvmf MainClass.txt shape.jar

   You will find that the jar command has a usage similar to the Unix tar command:
Usage: jar {ctxui}[vfm0Me] [jar-file] [manifest-file] [entry-point] [-C dir] files ...
Options:
    -c  create new archive
    -t  list table of contents for archive
    -x  extract named (or all) files from archive
    -u  update existing archive
    -v  generate verbose output on standard output
    -f  specify archive file name
    -m  include manifest information from specified manifest file
    -e  specify application entry point for stand-alone application
        bundled into an executable jar file
    -0  store only; use no ZIP compression
    -M  do not create a manifest file for the entries
    -i  generate index information for the specified jar files
    -C  change to the specified directory and include the following file
If any file is a directory then it is processed recursively.
The manifest file name, the archive file name and the entry point name are
specified in the same order as the 'm', 'f' and 'e' flags.

Example 1: to archive two class files into an archive called classes.jar:
       jar cvf classes.jar Foo.class Bar.class
Example 2: use an existing manifest file 'mymanifest' and archive all the
           files in the foo/ directory into 'classes.jar':
       jar cvfm classes.jar mymanifest -C foo/ .

   Note
   You can use any utility with support for ZIP files (e.g. WinZip) to create, view, extract, and manage
   your JAR files.


---
http://www.dmc.fmph.uniba.sk/public_html/doc/Java/ch16.htm

Packages and Interfaces

   Packages and interfaces are two capabilities that allow you greater control and flexibility in
   designing sets of interrelated classes. Packages allow you to combine groups of classes and control
   which of those classes are available to the outside world; interfaces provide a way of grouping
   abstract method definitions and sharing them among classes that may not necessarily acquire those
   methods through inheritance.

   Today you'll learn how to design with, use, and create your own packages and interfaces. Specific
   topics you'll learn about today include
     * A discussion of designing classes versus coding classes and how to approach each
     * What packages are and why they are useful for class design
     * Using other people's packages in your own classes
     * Creating your own packages
     * What interfaces buy you in terms of code reuse and design
     * Designing and working with interfaces

Programming in the Large and Programming in the Small
   When you examine a new language feature, you should ask yourself two questions:
     * How can I use it to better organize the methods and classes of my Java program?
     * How can I use it while writing the actual Java code?

   The first is often called programming in the large, and the second, programming in the small. Bill
   Joy, a founder of Sun Microsystems, likes to say that Java feels like C when programming in the small
   and like Smalltalk when programming in the large. What he means by that is that Java is familiar and
   powerful like any C-like language while you're coding individual lines, but has the extensibility and
   expressive power of a pure object-oriented language like Smalltalk while you're designing.

   The separation of "designing" from "coding" was one of the most fundamental advances in programming
   in the past few decades, and object-oriented languages such as Java implement a strong form of this
   separation. The first part of this separation has already been described on previous days: When you
   develop a Java program, first you design the classes and decide on the relationships between these
   classes, and then you implement the Java code needed for each of the methods in your design. If you
   are careful enough with both these processes, you can change your mind about aspects of the design
   without affecting anything but small, local pieces of your Java code, and you can change the
   implementation of any method without affecting the rest of the design.

   As you begin to explore more advanced Java programming, however, you'll find that this simple model
   becomes too limiting. Today you'll explore these limitations, for programming in the large and in the
   small, to motivate the need for packages and interfaces. Let's start with packages.

What Are Packages?
   Packages, as mentioned a number of times in this book so far, are a way of organizing groups of
   classes. A package contains any number of classes that are related in purpose, in scope, or by
   inheritance.

   Why bother with packages? If your programs are small and use a limited number of classes, you may
   find that you don't need to explore packages at all. But the more Java programming you do, the more
   classes you'll find you have. And although those classes may be individually well designed, reusable,
   encapsulated, and with specific interfaces to other classes, you may find the need for a bigger
   organizational entity that allows you to group your packages.

   Packages are useful for several broad reasons:
     * They allow you to organize your classes into units. Just as you have folders or directories on
       your hard disk to organize your files and applications, packages allow you to organize your
       classes into groups so that you only use what you need for each program.
     * They reduce problems with conflicts in names. As the number of Java classes grows, so does the
       likelihood that you'll use the same class name as someone else, opening up the possibility of
       naming clashes and errors if you try to integrate groups of classes into a single program.
       Packages allow you to "hide" classes so that conflicts can be avoided.
     * They allow you to protect classes, variables, and methods in larger ways than on a class-by-class
       basis, as you learned yesterday. You'll learn more about protections with packages later today.
     * They can be used to identify your classes. For example, if you implemented a set of classes to
       perform some purpose, you could name a package of those classes with a unique identifier that
       identifies you or your organization.

   Although a package is most typically a collection of classes, packages can also contain other
   packages, forming yet another level of organization somewhat analogous to the inheritance hierarchy.
   Each "level" usually represents a smaller, more specific grouping of classes. The Java class library
   itself is organized along these lines. The top level is called java; the next level includes names
   such as io, net, util, and awt. The last of these has an even lower level, which includes the package
   image.

Note
     By convention, the first level of the hierarchy specifies the (globally unique) name to identify
     the author or owner of those packages. For example, Sun Microsystems's classes, which are not part
     of the standard Java environment, all begin with the prefix sun. Classes that Netscape includes
     with its implementation are contained in the netscape package. The standard package, java, is an
     exception to this rule because it is so fundamental and because it might someday be implemented by
     multiple companies.

     I'll tell you more about package-naming conventions later when you create your own packages.

Using Packages
   You've been using packages all along in this book. Every time you use the import command, and every
   time you refer to a class by its full package name (java.awt.Color, for example), you've used
   packages. Let's go over the specifics of how to use classes from other packages in your own programs
   to make sure you've got it and to go into greater depth than we have in previous lessons.

   To use a class contained in a package, you can use one of three mechanisms:
     * If the class you want to use is in the package java.lang (for example, System or Date), you can
       simply use the class name to refer to that class. The java.lang classes are automatically
       available to you in all your programs.
     * If the class you want to use is in some other package, you can refer to that class by its full
       name, including any package names (for example, java.awt.Font).
     * For classes that you use frequently from other packages, you can import individual classes or a
       whole package of classes. After a class or a package has been imported, you can refer to that
       class by its class name.

   What about your own classes in your own programs that don't belong to any package? The rule is that
   if you don't specifically define your classes to belong to a package, they're put into an unnamed
   default package. You can refer to those classes simply by class name from anywhere in your code.

  Full Package and Class Names
   To refer to a class in some other package, you can use its full name: the class name preceded by any
   package names. You do not have to import the class or the package to use it this way:

java.awt.Font f = new java.awt.Font()

   For classes that you use only once or twice in your program, using the full name makes the most
   sense. If, however, you use that class multiple times, or if the package name is really long with
   lots of subpackages, you'll want to import that class instead to save yourself some typing.

  The import Command
   To import classes from a package, use the import command, as you've used throughout the examples in
   this book. You can either import an individual class, like this:

import java.util.Vector;

   or you can import an entire package of classes, using an asterisk (*) to replace the individual class
   names:

import java.awt.*


Note
     Actually, to be technically correct, this command doesn't import all the classes in a package-it
     only imports the classes that have been declared public, and even then only imports those classes
     that the code itself refers to. You'll learn more on this in the section titled "Packages and
     Class Protection."

   Note that the asterisk (*) in this example is not like the one you might use at a command prompt to
   specify the contents of a directory or to indicate multiple files. For example, if you ask to list
   the contents of the directory classes/java/awt/*, that list includes all the .class files and
   subdirectories, such as image and peer. Writing import java.awt.* imports all the public classes in
   that package, but does not import subpackages such as image and peer. To import all the classes in a
   complex package hierarchy, you must explicitly import each level of the hierarchy by hand. Also, you
   cannot indicate partial class names (for example, L* to import all the classes that begin with L).
   It's all the classes in a package or a single class.

   The import statements in your class definition go at the top of the file, before any class
   definitions (but after the package definition, as you'll see in the next section).

   So should you take the time to import classes individually or just import them as a group? It depends
   on how specific you want to be. Importing a group of classes does not slow down your program or make
   it any larger; only the classes you actually use in your code are loaded as they are needed. But
   importing a package does make it a little more confusing for readers of your code to figure out where
   your classes are coming from. Using individual imports or importing packages is mostly a question of
   your own coding style.

Technical Note
     Java's import command is not at all similar to the #include command in C-like languages, although
     they accomplish similar functions. The C preprocessor takes the contents of all the included files
     (and, in turn, the files they include, and so on) and stuffs them in at the spot where the
     #include was. The result is an enormous hunk of code that has far more lines than the original
     program did. Java's import behaves more like a linker; it tells the Java compiler and interpreter
     where (in which files) to find classes, variables, method names, and method definitions. It
     doesn't bring anything into the current Java program.

  Name Conflicts
   After you have imported a class or a package of classes, you can usually refer to a class name simply
   by its name, without the package identifier. I say "usually" because there's one case where you may
   have to be more explicit: when there are multiple classes with the same name from different packages.

   Here's an example. Let's say you import the classes from two packages from two different programmers
   (Joe and Eleanor):

import joesclasses.*;
import eleanorsclasses.*;

   Inside Joe's package is a class called Name. Unfortunately, inside Eleanor's package there is also a
   class called Name that has an entirely different meaning and implementation. You would wonder whose
   version of Name would end up getting used if you referred to the Name class in your own program like
   this:

Name myName = new Name("Susan");

   The answer is neither; the Java compiler will complain about a naming conflict and refuse to compile
   your program. In this case, despite the fact that you imported both classes, you still have to refer
   to the appropriate Name class by full package name:

joesclasses.Name myName = new joesclasses.Name("Susan");

  A Note About CLASSPATH and Where Classes Are Located
   Before I go on to explain how to create your own packages of classes, I'd like to make a note about
   how Java finds packages and classes when it's compiling and running your classes.

   For Java to be able to use a class, it has to be able to find it on the file system. Otherwise,
   you'll get an error that the class does not exist. Java uses two things to find classes: the package
   name itself and the directories listed in your CLASSPATH variable.

   First, the package names. Package names map to directory names on the file system, so the class
   java.applet.Applet will actually be found in the applet directory, which in turn will be inside the
   java directory (java/applet/Applet.class, in other words).

   Java looks for those directories, in turn, inside the directories listed in your CLASSPATH variable.
   If you remember back to [28]Day 1, "An Introduction to Java Programming," when you installed the JDK,
   you had to set up a CLASSPATH variable to point to the various places where your Java classes live.
   CLASSPATH usually points to the java/lib directory in your JDK release, a class directory in your
   development environment if you have one, perhaps some browser-specific classes, and to the current
   directory. When Java looks for a class you've referenced in your source, it looks for the package and
   class name in each of those directories and returns an error if it can't find the class file. Most
   "cannot load class" errors result because of missed CLASSPATH variables.

Note
     If you're using the Macintosh version of the JDK, you're probably wondering what I'm talking
     about. The Mac JDK doesn't use a CLASSPATH variable; it knows enough to be able to find the
     default classes and those contained in the current directory. However, if you do a lot of Java
     development, you may end up with classes and packages in other directories. The Java compiler
     contains a Preferences dialog box that lets you add directories to Java's search path.

Creating Your Own Packages
   Creating your own packages is a difficult, complex process, involving many lines of code, long hours
   late at night with lots of coffee, and the ritual sacrifice of many goats. Just kidding. To create a
   package of classes, you have three basic steps to follow, which I'll explain in the following
   sections.

  Pick a Package Name
   The first step is to decide what the name of your package is going to be. The name you choose for
   your package depends on how you are going to be using those classes. Perhaps your package will be
   named after you, or perhaps after the part of the Java system you're working on (like graphics or
   hardware_interfaces). If you're intending your package to be distributed to the Net at large, or as
   part of a commercial product, you'll want to use a package name (or set of package names) that
   uniquely identifies you or your organization or both.

   One convention for naming packages that has been recommended by Sun is to use your Internet domain
   name with the elements reversed. So, for example, if Sun were following its own recommendation, its
   packages would be referred to using the name com.sun.java rather than just java. If your Internet
   domain name is fooblitzky.eng.nonsense.edu, your package name might be edu.nonsense.eng.fooblitzky
   (and you might add another package name onto the end of that to refer to the product or to you,
   specifically).

   The idea is to make sure your package name is unique. Although packages can hide conflicting class
   names, the protection stops there. There's no way to make sure your package won't conflict with
   someone else's package if you both use the same package name.

   By convention, package names tend to begin with a lowercase letter to distinguish them from class
   names. Thus, for example, in the full name of the built-in String class, java.lang.String, it's
   easier to separate the package name from the class name visually. This convention helps reduce name
   conflicts.

  Create the Directory Structure
   Step two in creating packages is to create a directory structure on your disk that matches the
   package name. If your package has just one name (mypackage), you'll only have to create a directory
   for that one name. If the package name has several parts, however, you'll have to create directories
   within directories. For the package name edu.nonsense.eng.fooblitzky, you'll need to create an edu
   directory and then create a nonsense directory inside edu, an eng directory inside nonsense, and a
   fooblitzky directory inside eng. Your classes and source files can then go inside the fooblitzky
   directory.

  Use package to Add Your Class to a Package
   The final step to putting your class inside packages is to add the package command to your source
   files. The package command says "this class goes inside this package," and is used like this:

package myclasses;
package edu.nonsense.eng.fooblitzky;
package java.awt;

   The single package command, if any, must be the first line of code in your source file, after any
   comments or blank lines and before any import commands.

   As mentioned before, if your class doesn't have a package command in it, that class is contained in
   the default package and can be used by any other class. But once you start using packages, you should
   make sure all your classes belong to some package to reduce the chance of confusion about where your
   classes belong.

  Packages and Class Protection
   Yesterday you learned all about the four Ps of protection and how they apply (primarily) to methods
   and variables and their relationship to other classes. When referring to classes and their
   relationship to other classes in other packages, you only have two Ps to worry about: package and
   public.

   By default, classes have package protection, which means that the class is available to all the other
   classes in the same package but is not visible or available outside that package-not even to
   subpackages. It cannot be imported or referred to by name; classes with package protection are hidden
   inside the package in which they are contained.

   Package protection comes about when you define a class as you have throughout this book, like this:

class TheHiddenClass extends AnotherHiddenClass {
...
}

   To allow a class to be visible and importable outside your package, you'll want to give it public
   protection by adding the public modifier to its definition:

public class TheVisibleClass {
...
}

   Classes declared as public can be imported by other classes outside the package.

   Note that when you use an import statement with an asterisk, you import only the public classes
   inside that package. Hidden classes remain hidden and can be used only by the other classes in that
   package.

   Why would you want to hide a class inside a package? For the same reason you want to hide variables
   and methods inside a class: so you can have utility classes and behavior that are useful only to your
   implementation, or so you can limit the interface of your program to minimize the effect of larger
   changes. As you design your classes, you'll want to take the whole package into consideration and
   decide which classes will be declared public and which will be hidden.

   Listing 16.1 shows two classes that illustrate this point. The first is a public class that
   implements a linked list; the second is a private node of that list.
     ________________________________________________________________________________________________

     Listing 16.1. The public class LinkedList.

 1: package  collections;
 2:
 3: public class  LinkedList {
 4:     private Node  root;
 5:
 6:     public  void  add(Object o) {
 7:         root = new Node(o, root);
 8:     }
 9:     . . .
10: }
11:
12: class  Node {   // not public
13:     private Object  contents;
14:     private Node    next;
15:
16:     Node(Object o, Node n) {
17:         contents = o;
18:         next     = n;
19:     }
20:     . . .
21: }
     ________________________________________________________________________________________________

Note
     Notice here that I'm including two class definitions in one file. I mentioned this briefly on
     [29]Day 13, "Creating User Interfaces with the awt," and it bears mentioning here as well: You can
     include as many class definitions per file as you want, but only one of them can be declared
     public, and that filename must have the same name as the one public class. When Java compiles the
     file, it'll create separate .class files for each class definition inside the file. In reality, I
     find the one-to-one correspondence of class definition to file much more easily maintained because
     I don't have to go searching around for the definition of a class.

   The public LinkedList class provides a set of useful public methods (such as add()) to any other
   classes that might want to use them. These other classes don't need to know about any support classes
   LinkedList needs to get its job done. Node, which is one of those support classes, is therefore
   declared without a public modifier and will not appear as part of the public interface to the
   collections package.

Note
     Just because Node isn't public doesn't mean LinkedList won't have access to it once it's been
     imported into some other class. Think of protections not as hiding classes entirely, but more as
     checking the permissions of a given class to use other classes, variables, and methods. When you
     import and use LinkedList, the Node class will also be loaded into the system, but only instances
     of LinkedList will have permission to use it.

   One of the great powers of hidden classes is that even if you use them to introduce a great deal of
   complexity into the implementation of some public class, all the complexity is hidden when that class
   is imported or used. Thus, creating a good package consists of defining a small, clean set of public
   classes and methods for other classes to use, and then implementing them by using any number of
   hidden (package) support classes. You'll see another use for hidden classes later today.

What Are Interfaces?
   Interfaces, like the abstract classes and methods you saw yesterday, provide templates of behavior
   that other classes are expected to implement. Interfaces, however, provide far more functionality to
   Java and to class and object design than do simple abstract classes and methods. The rest of this
   lesson explores interfaces: what they are, why they're crucial to getting the most out of the Java
   language for your own classes, and how to use and implement them.

  The Problem of Single Inheritance
   When you first begin to design object-oriented programs, the concept of the class hierarchy can seem
   almost miraculous. Within that single tree you can express a hierarchy of different types of objects,
   many simple to moderately complex relationships between objects and processes in the world, and any
   number of points along the axis from abstract/general to concrete/specific. The strict hierarchy of
   classes appears, at first glance, to be simple, elegant, and easy to use.

   After some deeper thought or more complex design experience, however, you may discover that the pure
   simplicity of the class hierarchy is restrictive, particularly when you have some behavior that needs
   to be used by classes in different branches of the same tree.

   Let's look at a few examples that will make the problems clearer. Way back on [30]Day 2,
   "Object-Oriented Programming and Java," when you first learned about class hierarchies, we discussed
   the Vehicle hierarchy, as shown in Figure 16.1.

   [31]Figure 16.1 : The Vechicle hierarchy.

   Now let's add to that hierarchy and create the classes BritishCar and BritishMotorcycle underneath
   Car and Motorcycle, respectively. The behavior that makes a car or motorcycle British (which might
   include methods for leakOil() or electricalSystemFailure()) is common to both these classes, but
   because they are in very different parts of the class hierarchy, you can't create a common superclass
   for both of them. And you can't put the British behavior further up in the hierarchy because that
   behavior isn't common to all motorcycles and cars. Other than physically copying the behavior between
   the two classes (which breaks the object-oriented programming [OOP] rules of code reuse and shared
   behavior), how can you create a hierarchy like this?

   Let's look at an even thornier example. Say you have a biological hierarchy with Animal at the top,
   and the classes Mammal and Bird underneath. Things that define a mammal include bearing live young
   and having fur. Behavior or features of birds include having a beak and laying eggs. So far, so good,
   right? So how do you go about creating a class for the platypus, which has fur, has a beak, and lays
   eggs? You'd need to combine behavior from two classes to form the Platypus class. And, because
   classes can have only one immediate superclass in Java, this sort of problem simply cannot be solved
   elegantly.

   Other OOP languages include the concept of multiple inheritance, which solves this problem. With
   multiple inheritance, a class can inherit from more than one superclass and get behavior and
   attributes from all its superclasses at once. Using multiple inheritance, you could simply factor the
   common behavior of BritishCar and BritishMotorcycle into a single class (BritishThing) and then
   create new classes that inherit from both their primary superclass and the British class.

   The problem with multiple inheritance is that it makes a programming language far more complex to
   learn, to use, and to implement. Questions of method invocation and how the class hierarchy is
   organized become far more complicated with multiple inheritance, and more open to confusion and
   ambiguity. And because one of the goals for Java was that it be simple, multiple inheritance was
   rejected in favor of the simpler single inheritance.

   So how do you solve the problem of needing common behavior that doesn't fit into the strict class
   hierarchy? Java, borrowing from Objective-C, has another hierarchy altogether separate from the main
   class hierarchy, a hierarchy of mixable behavior classes. Then, when you create a new class, that
   class has only one primary superclass, but it can pick and choose different common behaviors from the
   other hierarchy.

   This other hierarchy is the interface hierarchy. A Java interface is a collection of abstract
   behavior that can be mixed into any class to add to that class behavior that is not supplied by its
   superclasses. Specifically, a Java interface contains nothing but abstract method definitions and
   constants-no instance variables and no method implementations.

   Interfaces are implemented and used throughout the Java class library whenever a behavior is expected
   to be implemented by a number of disparate classes. The Java class hierarchy, for example, defines
   and uses the interfaces java.lang.Runnable, java.util.Enumeration, java.util.Observable,
   java.awt.image.ImageConsumer, and java.awt.image.ImageProducer. Some of these interfaces you've seen
   before; others you'll see later in this book. Still others may be useful to you in your own programs,
   so be sure to examine the API to see what's available to you.

  Abstract Design and Concrete Implementation
   Throughout this book you've gotten a taste of the difference between design and implementation in
   object-oriented programming, where the design of a thing is its abstract representation and its
   implementation is the concrete counterpart of the design. You saw this with methods, where a method's
   signature defines how it's used, but the method implementation can occur anywhere in the class
   hierarchy. You saw this with abstract classes, where the class's design provides a template for
   behavior, but that behavior isn't implemented until further down in the hierarchy.

   This distinction between the design and the implementation of a class or a method is a crucial part
   of object-oriented programming theory. Thinking in terms of design when you organize your classes
   allows you to get the big picture without being bogged down in implementation details. And having the
   overall design already defined when you actually start implementing allows you to concentrate on
   those details solely for the class you're working on. This programming version of "think globally,
   act locally" provides a powerful way of thinking about how your classes and your programs and your
   overall designs are organized and how they interrelate.

   An interface is made up of a set of method signatures with no implementations, making it the
   embodiment of pure design. By mixing an interface in with your class, you're encompassing that design
   into your implementation. That design can then be safely included anywhere in the class hierarchy
   because there are no class-specific details of how an interface behaves-nothing to override, nothing
   to keep track of, just the name and arguments for a method.

   What about abstract classes? Don't abstract classes provide this same behavior? Yes and no. Abstract
   classes and the abstract methods inside them do provide a separation of design and implementation,
   allowing you to factor common behavior into an abstract superclass. But abstract classes can, and
   often do, contain some concrete data (such as instance variables), and you can have an abstract
   superclass with both abstract and regular methods, thereby confusing the distinction.

   Even a pure abstract class with only abstract methods isn't as powerful as an interface. An abstract
   class is simply another class; it inherits from some other class and has its place in the hierarchy.
   Abstract classes cannot be shared across different parts of the class hierarchy the way interfaces
   can, nor can they be mixed into other classes that need their behavior. To attain the sort of
   flexibility of shared behavior across the class hierarchy, you need an interface.

   You can think of the difference between the design and the implementation of any Java class as the
   difference between the interface hierarchy and the design hierarchy. The singly inherited class
   hierarchy contains the implementations where the relationships between classes and behavior are
   rigidly defined. The multiply inherited mixable interface hierarchy, however, contains the design and
   can be freely used anywhere it's needed in the implementation. This is a powerful way of thinking
   about the organization of your program, and although it takes a little getting used to, it's also a
   highly recommended one.

  Interfaces and Classes
   Classes and interfaces, despite their different definitions, have an awful lot in common. Interfaces,
   like classes, are declared in source files, one interface to a file. Like classes, they also are
   compiled using the Java compiler into .class files. And, in most cases, anywhere you can use a class
   (as a data type for a variable, as the result of a cast, and so on), you can also use an interface.

   Almost everywhere that this book has a class name in any of its examples or discussions, you can
   substitute an interface name. Java programmers often say "class" when they actually mean "class or
   interface." Interfaces complement and extend the power of classes, and the two can be treated almost
   exactly the same. One of the few differences between them is that an interface cannot be
   instantiated: new can only create an instance of a class.

Implementing and Using Interfaces
   Now that you've grasped what interfaces are and why they're powerful (the "programming in the large"
   part), let's move on to actual bits of code ("programming in the small"). There are two things you
   can do with interfaces: use them in your own classes and define your own. Let's start with the
   former.

  The implements Keyword
   To use an interface, you include the implements keyword as part of your class definition. You did
   this back on [32]Day 11, "More Animation, Images, and Sound," when you learned about threads and
   included the Runnable interface in your applet definition:

// java.applet.Applet is the superclass
public class Neko extends java.applet.Applet
    implements Runnable {  // but it also has Runnable behavior
...
}

   Because interfaces provide nothing but abstract method definitions, you then have to implement those
   methods in your own classes, using the same method signatures from the interface. Note that once you
   include an interface, you have to implement all the methods in that interface-you can't pick and
   choose the methods you need. By implementing an interface you're telling users of your class that you
   support all of that interface. (Note that this is another difference between interfaces and abstract
   classes-subclasses of the latter can pick which methods to implement or override and can ignore
   others.)

   After your class implements an interface, subclasses of your class will inherit those new methods
   (and can override or overload them) just as if your superclass had actually defined them. If your
   class inherits from a superclass that implements a given interface, you don't have to include the
   implements keyword in your own class definition.

   Let's examine one simple example-creating the new class Orange. Suppose you already have a good
   implementation of the class Fruit and an interface, Fruitlike, that represents what Fruits are
   expected to be able to do. You want an orange to be a fruit, but you also want it to be a spherical
   object that can be tossed, rotated, and so on. Here's how to express it all (don't worry about the
   definitions of these interfaces for now; you'll learn more about them later today):

interface  Fruitlike {
    void  decay();
    void  squish();
    . . .
}

class  Fruit implements Fruitlike {
    private Color  myColor;
    private int    daysTilIRot;
    . . .
}

interface  Spherelike {
    void  toss();
    void  rotate();
    . . .
}

class  Orange extends Fruit implements Spherelike {
    . . .  // toss()ing may squish() me (unique to me)
}

   Note that the class Orange doesn't have to say implements Fruitlike because, by extending Fruit, it
   already has! One of the nice things about this structure is that you can change your mind about what
   class Orange extends (if a really great Sphere class is suddenly implemented, for example), yet class
   Orange will still understand the same two interfaces:

class  Sphere implements Spherelike {   // extends Object
    private float  radius;
    . . .
}

class  Orange extends Sphere implements Fruitlike {
    . . .     // users of Orange never need know about the change!
}

  Implementing Multiple Interfaces

   Unlike the singly inherited class hierarchy, you can include as many interfaces as you need in your
   own classes, and your class will implement the combined behavior of all the included interfaces. To
   include multiple interfaces in a class, just separate their names with commas:

public class Neko extends java.applet.Applet
    implements Runnable, Eatable, Sortable, Observable {
...
}

   Note that complications may arise from implementing multiple interfaces-what happens if two different
   interfaces both define the same method? There are three ways to solve this:
     * If the methods in each of the interfaces have identical signatures, you implement one method in
       your class and that definition satisfies both interfaces.
     * If the methods have different parameter lists, it is a simple case of method overloading; you
       implement both method signatures, and each definition satisfies its respective interface
       definition.
     * If the methods have the same parameter lists but differ in return type, you cannot create a
       method that satisfies both (remember, method overloading is triggered by parameter lists, not by
       return type). In this case, trying to compile a class that implements both interfaces will
       produce a compiler error. Running across this problem suggests that your interfaces have some
       design flaws that might need re-examining.

  Other Uses of Interfaces
   Remember that almost everywhere that you can use a class, you can use an interface instead. So, for
   example, you can declare a variable to be of an interface type:

Runnable aRunnableObject = new MyAnimationClass()

   When a variable is declared to be of an interface type, it simply means that any object the variable
   refers to is expected to have implemented that interface-that is, it is expected to understand all
   the methods that interface specifies. It assumes that a promise made between the designer of the
   interface and its eventual implementors has been kept. In this case, because aRunnableObject contains
   an object of the type Runnable, the assumption is that you can call aRunnableObject.run().

   The important thing to realize here is that although aRunnableObject is expected to be able to have
   the run() method, you could write this code long before any classes that qualify are actually
   implemented (or even created!). In traditional object-oriented programming, you are forced to create
   a class with "stub" implementations (empty methods, or methods that print silly messages) to get the
   same effect.

   You can also cast objects to an interface, just as you can cast objects to other classes. So, for
   example, let's go back to that definition of the Orange class, which implemented both the Fruitlike
   interface (through its superclass, Fruit) and the Spherelike interface. Here we'll cast instances of
   Orange to both classes and interfaces:

Orange      anOrange    = new Orange();
Fruit       aFruit      = (Fruit)anOrange;
Fruitlike   aFruitlike  = (Fruitlike)anOrange;
Spherelike  aSpherelike = (Spherelike)anOrange;


aFruit.decay();          // fruits decay
aFruitlike.squish();     //  and squish

aFruitlike.toss();       // things that are fruitlike do not toss
aSpherelike.toss();      // but things that are spherelike do

anOrange.decay();        // oranges can do it all
anOrange.squish();
anOrange.toss();
anOrange.rotate();

   Declarations and casts are used in this example to restrict an orange's behavior to acting more like
   a mere fruit or sphere.

   Finally, note that although interfaces are usually used to mix in behavior to other classes (method
   signatures), interfaces can also be used to mix in generally useful constants. So, for example, if an
   interface defined a set of constants, and then multiple classes used those constants, the values of
   those constants could be globally changed without having to modify multiple classes. This is yet
   another example of where the use of interfaces to separate design from implementation can make your
   code more general and more easily maintainable.

Creating and Extending Interfaces
   After using interfaces for a while, the next step is to define your own interfaces. Interfaces look a
   lot like classes; they are declared in much the same way and can be arranged into a hierarchy, but
   there are rules for declaring interfaces that must be followed.

  New Interfaces
   To create a new interface, you declare it like this:

public interface Growable {
...
}

   This is, effectively, the same as a class definition, with the word interface replacing the word
   class. Inside the interface definition you have methods and constants. The method definitions inside
   the interface are public and abstract methods; you can either declare them explicitly as such, or
   they will be turned into public and abstract methods if you do not include those modifiers. You
   cannot declare a method inside an interface to be either private or protected. So, for example,
   here's a Growable interface with one method explicitly declared public and abstract (growIt()) and
   one implicitly declared as such (growItBigger()).

public interface Growable {
    public abstract void growIt(); //explicity public and abstract
    void growItBigger();          // effectively public and abstract
}

   Note that, as with abstract methods in classes, methods inside interfaces do not have bodies.
   Remember, an interface is pure design; there is no implementation involved.

   In addition to methods, interfaces can also have variables, but those variables must be declared
   public, static, and final (making them constant). As with methods, you can explicitly define a
   variable to be public, static, and final, or it will be implicitly defined as such if you don't use
   those modifiers. Here's that same Growable definition with two new variables:

public interface Growable {
    public static final int increment = 10;
    long maxnum = 1000000;  // becomes public static and final

    public abstract void growIt(); //explicitly public and abstract
    void growItBigger();          // effectively public and abstract
}

   Interfaces must have either public or package protection, just like classes. Note, however, that
   interfaces without the public modifier do not automatically convert their methods to public and
   abstract nor their constants to public. A non-public interface also has non-public methods and
   constants that can be used only by classes and other interfaces in the same package.

   Interfaces, like classes, can belong to a package by adding a package statement to the first line of
   the class file. Interfaces can also import other interfaces and classes from other packages, just as
   classes can.

  Methods Inside Interfaces
   One trick to note about methods inside interfaces: Those methods are supposed to be abstract and
   apply to any kind of class, but how can you define parameters to those methods? You don't know what
   class will be using them!

   The answer lies in the fact that you use an interface name anywhere a class name can be used, as you
   learned earlier. By defining your method parameters to be interface types, you can create generic
   parameters that apply to any class that might use this interface.

   So, for example, take the interface Fruitlike, which defines methods (with no arguments) for decay()
   and squish(). There might also be a method for germinateSeeds(), which has one argument: the fruit
   itself. Of what type is that argument going to be? It can't be simply Fruit, because there may be a
   class that's Fruitlike (that is, implements the Fruitlike interface) without actually being a fruit.
   The solution is to declare the argument as simply Fruitlike in the interface:

public interface Fruitlike {
    public abstract germinate(Fruitlike self) {
       ...
    }
}

   Then, in an actual implementation for this method in a class, you can take the generic Fruitlike
   argument and cast it to the appropriate object:

public class Orange extends Fruit {

    public germinate(Fruitlike self) {
       Orange theOrange = (Orange)self;
       ...
    }
}

  Extending Interfaces

   As with classes, interfaces can be organized into a hierarchy. When one interface inherits from
   another interface, that "subinterface" acquires all the method definitions and constants that its
   "superinterface" defined. To extend an interface, you use the extends keyword just as you do in a
   class definition:

public interface Fruitlike extends Foodlike {
...
}

   Note that, unlike classes, the interface hierarchy has no equivalent of the Object class; this
   hierarchy is not rooted at any one point. Interfaces can either exist entirely on their own or
   inherit from another interface.

   Note also that, unlike the class hierarchy, the inheritance hierarchy is multiply inherited. So, for
   example, a single interface can extend as many classes as it needs to (separated by commas in the
   extends part of the definition), and the new interface will contain a combination of all its parent's
   methods and constants. Here's an interface definition for an interface called BusyInterface that
   inherits from a whole lot of other interfaces:

public interface BusyInterface extends Runnable, Growable, Fruitlike, Observable {
...}

   In multiply inherited interfaces, the rules for managing method name conflicts are the same as for
   classes that use multiple interfaces; methods that differ only in return type will result in a
   compiler error.

  An Example: Enumerating Linked Lists

   To finish up today's lesson, here's an example that uses packages, package protection, and defines a
   class that implements the Enumeration interface (part of the java.util package). Listing 16.2 shows
   the code.
     ________________________________________________________________________________________________

     Listing 16.2. Packages, classes, and interfaces.

 1: package  collections;
 2:
 3: public class  LinkedList {
 4:       private Node  root;
 5:
 6:       . . .
 7:       public Enumeration  enumerate() {
 8:           return new LinkedListEnumerator(root);
 9:     }
10: }
11:
12: class  Node {
13:     private Object  contents;
14:     private Node    next;
15:
16:     . . .
17:     public  Object  contents() {
18:         return contents;
19:     }
20:
21:     public  Node    next() {
22:         return next;
23:     }
24: }
25:
26: class  LinkedListEnumerator implements Enumeration {
27:     private Node  currentNode;
28:
29:      LinkedListEnumerator(Node  root) {
30:         currentNode = root;
31:     }
32:
33:     public boolean  hasMoreElements() {
34:         return currentNode != null;
35:     }
36:
37:     public Object   nextElement() {
38:        Object  anObject = currentNode.contents();
39:
40:         currentNode = currentNode.next();
41:        return  anObject;
42:    }
43: }
     ________________________________________________________________________________________________

   Here is a typical use of the enumerator:

collections.LinkedList aLinkedList = createLinkedList();
java.util.Enumeration e = aLinkedList.enumerate();

while (e.hasMoreElements()) {
    Object  anObject = e.nextElement();
    // do something useful with anObject
}

   Notice that, although you are using the Enumeration e as though you know what it is, you actually do
   not. In fact, it is an instance of a hidden class (LinkedListEnumerator) that you cannot see or use
   directly. By using a combination of packages and interfaces, the LinkedList class has managed to
   provide a transparent public interface to some of its most important behavior (via the already
   defined interface java.util.Enumeration) while still encapsulating (hiding) its two implementation
   (support) classes.

   Handing out an object like this is sometimes called vending. Often the "vendor" gives out an object
   that a receiver can't create itself but that it knows how to use. By giving it back to the vendor,
   the receiver can prove it has a certain capability, authenticate itself, or do any number of useful
   tasks-all without knowing much about the vended object. This is a powerful metaphor that can be
   applied in a broad range of situations.

Summary
   Today you have learned how packages can be used to collect and categorize classes into meaningful
   groups. Packages are arranged in a hierarchy, which not only better organizes your programs but
   allows you and the millions of Java programmers out on the Net to name and share their projects
   uniquely with one another.

   You have also learned how to use packages, both your own and the many preexisting ones in the Java
   class library.

   You then discovered how to declare and use interfaces, a powerful mechanism for extending the
   traditional single inheritance of Java's classes and for separating design inheritance from
   implementation inheritance in your programs. Interfaces are often used to call common (shared)
   methods when the exact class involved is not known. You'll see further uses of interfaces tomorrow
   and the day after.

   Finally, you learned that packages and interfaces can be combined to provide useful abstractions,
   such as LinkedList, that appear simple yet are actually hiding almost all their (complex)
   implementation from their users. This is a powerful technique.


---
http://www.javapractices.com/topic/TopicAction.do?Id=205

   Package by feature, not layer

   The first question in building an application is "How do I divide it up into packages?". For typical
   business applications, there seems to be two ways of answering this question.

  Package By Feature
   Package-by-feature uses packages to reflect the feature set. It tries to place all items related to a
   single feature (and only that feature) into a single directory/package. This results in packages with
   high cohesion and high modularity, and with minimal coupling between packages. Items that work
   closely together are placed next to each other. They aren't spread out all over the application. It's
   also interesting to note that, in some cases, deleting a feature can reduce to a single operation -
   deleting a directory. (Deletion operations might be thought of as a good test for maximum modularity:
   an item has maximum modularity only if it can be deleted in a single operation.)

   In package-by-feature, the package names correspond to important, high-level aspects of the problem
   domain. For example, a drug prescription application might have these packages:
     * com.app.doctor
     * com.app.drug
     * com.app.patient
     * com.app.presription
     * com.app.report
     * com.app.security
     * com.app.webmaster
     * com.app.util
     * and so on...

   Each package usually contains only the items related to that particular feature, and no other
   feature. For example, the com.app.doctor package might contain these items:
     * DoctorAction.java - an action or controller object
     * Doctor.java - a Model Object
     * DoctorDAO.java - Data Access Object
     * database items (SQL statements)
     * user interface items (perhaps a JSP, in the case of a web app)

   It's important to note that a package can contain not just Java code, but other files as well.
   Indeed, in order for package-by-feature to really work as desired, all items related to a given
   feature - from user interface, to Java code, to database items - must be placed in a single directory
   dedicated to that feature (and only that feature).

   In some cases, a feature/package will not be used by any other feature in the application. If that's
   the case, it may be removed simply by deleting the directory. If it is indeed used by some other
   feature, then its removal will not be as simple as a single delete operation.

   That is, the package-by-feature idea does not imply that one package can never use items belonging to
   other packages. Rather, package-by-feature aggressively prefers package-private as the default scope,
   and only increases the scope of an item to public only when needed.

  Package By Layer
   The competing package-by-layer style is different. In package-by-layer, the highest level packages
   reflect the various application "layers", instead of features, as in:
     * com.app.action
     * com.app.model
     * com.app.dao
     * com.app.util

   Here, each feature has its implementation spread out over multiple directories, over what might be
   loosely called "implementation categories". Each directory contains items that usually aren't closely
   related to each other. This results in packages with low cohesion and low modularity, with high
   coupling between packages. As a result, editing a feature involves editing files across different
   directories. In addition, deleting a feature can almost never be performed in a single operation.

  Recommendation: Use Package By Feature
   For typical business applications, the package-by-feature style seems to be the superior of the two:

   Higher Modularity
   As mentioned above, only package-by-feature has packages with high cohesion, high modularity, and low
   coupling between packages.

   Easier Code Navigation
   Maintenance programmers need to do a lot less searching for items, since all items needed for a given
   task are usually in the same directory. Some tools that encourage package-by-layer use package naming
   conventions to ease the problem of tedious code navigation. However, package-by-feature transcends
   the need for such conventions in the first place, by greatly reducing the need to navigate between
   directories.

   Higher Level of Abstraction
   Staying at a high level of abstraction is one of programming's guiding principles of lasting value.
   It makes it easier to think about a problem, and emphasizes fundamental services over implementation
   details. As a direct benefit of being at a high level of abstraction, the application becomes more
   self-documenting: the overall size of the application is communicated by the number of packages, and
   the basic features are communicated by the package names. The fundamental flaw with package-by-layer
   style, on the other hand, is that it puts implementation details ahead of high level abstractions -
   which is backwards.

   Separates Both Features and Layers
   The package-by-feature style still honors the idea of separating layers, but that separation is
   implemented using separate classes. The package-by-layer style, on the other hand, implements that
   separation using both separate classes and separate packages, which doesn't seem necessary or
   desirable.

   Minimizes Scope
   Minimizing scope is another guiding principle of lasting value. Here, package-by-feature allows some
   classes to decrease their scope from public to package-private. This is a significant change, and
   will help to [2]minimize ripple effects. The package-by-layer style, on the other hand, effectively
   abandons package-private scope, and forces you to implement nearly all items as public. This is a
   fundamental flaw, since it doesn't allow you to minimize ripple effects by keeping secrets.

   Better Growth Style
   In the package-by-feature style, the number of classes within each package remains limited to the
   items related to a specific feature. If a package becomes too large, it may be refactored in a
   natural way into two or more packages. The package-by-layer style, on the other hand, is monolithic.
   As an application grows in size, the number of packages remains roughly the same, while the number of
   classes in each package will increase without bound.

   If you still need further convincing, consider the following.

   Directory Structure Is Fundamental To Your Code

   "As any designer will tell you, it is the first steps in a design process which count for most. The
   first few strokes, which create the form, carry within them the destiny of the rest." - Christopher
   Alexander

   (Christopher Alexander is an architect. Without having worked as programmer, he has influenced many
   people who think a lot about programming. His early book A Pattern Language was the original
   inspiration for the Design Patterns movement. He has thought long and hard about how to build
   beautiful things, and these reflections seem to largely apply to software construction as well.)

   In a CBC radio interview, Alexander recounted the following story (paraphrased here): "I was working
   with one of my students. He was having a very difficult time building something. He just didn't know
   how to proceed at all. So I sat with him, and I said this: Listen, start out by figuring out what the
   most important thing is. Get that straight first. Get that straight in your mind. Take your time.
   Don't be too hasty. Think about it for a while. When you feel that you have found it, when there is
   no doubt in your mind that it is indeed the most important thing, then go ahead and make that most
   important thing. When you have made that most important thing, ask yourself if you can make it more
   beautiful. Cut the bullshit, just get it straight in your head, if you can make it better or not.
   When that's done, and you feel you cannot make it any better, then find the next most important
   thing."

   What are the first strokes in an application, which create its overall form? It is the directory
   structure. The directory structure is the very first thing encountered by a programmer when browsing
   source code. Everything flows from it. Everything depends on it. It is clearly one of the most
   important aspects of your source code.

   Consider the different reactions of a programmer when encountering different directory structures.
   For the package-by-feature style, the thoughts of the application programmer might be like this:
     * "I see. This lists all the top-level features of the app in one go. Nice."
     * "Let's see. I wonder where this item is located....Oh, here it is. And everything else I am going
       to need is right here too, all in the same spot. Excellent."

   For the package-by-layer style, however, the thoughts of the application programmer might be more
   like this:
     * "These directories tell me nothing. How many features in this app? Beats me. It looks exactly the
       same as all the others. No difference at all. Great. Here we go again..."
     * "Hmm. I wonder where this item is located....I guess its parts are all over the app, spread
       around in all these directories. Do I really have all the items I need? I guess we'll find out
       later."
     * "I wonder if that naming convention is still being followed. If not, I will have to look it up in
       that other directory."
     * "Wow, would you look at the size of this single directory...sheesh."

   Package-By-Layer in Other Domains is Ineffective

   By analogy, one can see that the package-by-layer style leads to poor results. For example, imagine a
   car. At the highest level, a car's 'implementation' is divided this way (package-by-feature) :
     * safety
     * engine
     * steering
     * fuel system
     * and so on...

   Now imagine a car whose 'implementation' under the hood is first divided up according to these lower
   level categories (package-by-layer) :
     * electrical
     * mechanical
     * hydraulic

   In the case of a transmission problem, for example, you might need to tinker around in these three
   compartments. This would mean moving from one part of the car to another completely different one.
   While in these various compartments, you could 'see' items having absolutely nothing to do with
   problem you are trying to solve. They would simply be in the way, always and everywhere distracting
   you from the real task at hand. Wouldn't it make more sense if there was a single place having
   exactly what you need, and nothing else?

   As a second example, consider a large bureacracy divided up into various departments
   (package-by-feature):
     * front office
     * back office
     * accounting
     * personnel
     * mail room

   If a package-by-layer style was used, the primary division would be something like :
     * executives
     * managers
     * employees

   Now imagine the bureacracy being divided physically according to these three categories. Each manager
   is located, for example, with all the other managers, and not with the employees working for them.
   Would that be effective? No, it wouldn't.

   So why should software be any different? It seems that package-by-layer is just a bad habit waiting
   to be broken.

   The example applications that come with WEB4J uses the package-by-feature style.


---
https://kinbiko.com/java/feature-oriented-architecture/

Java: Feature-oriented package structures and the default access modifier
February 18, 2018

   In Java we have 4 access modifiers that can be applied to methods and fields of a class. In
   descending order of visibility, they are:
public    String publicModifier    = "Anyone can access me";
protected String protectedModifier = "Only accessible to classes in the same package as me, and my subclasses";
          String defaultModifier   = "Only accessible to classes in the same package as me";
private   String privateModifier   = "Only accessible within this class";

   This article is a love letter to the third in this list of modifiers, the one-who-shall-not-be-named.
   It’s usually referred to the ‘default’ or ‘package-private’ access modifier.

Be aware of ingrained rules you don’t fully understand
   When I first started learning Java, I read that you should never use the default access modifier.
   This was because it wasn’t obvious if you had thought about the desired visibility of your method or
   field, or if you were being lazy or had just forgotten.

     Use private wherever you can, protected if you need access to it in your subclasses, and public if
     you need it from the outside.

   I didn’t question this decree at the time.

   Soon enough, I started feeling uncomfortable seeing methods and fields without modifiers, and always
   applied the appropriate modifier whenever I found one, according to the rule above.

   I later started using [3]IntelliJ full time. IntelliJ has a feature where it can infer the required
   access modifier by looking at all the compiled code in its context, and see where the class member is
   used. This feature is handy for seeing when something could be private/protected, but I noticed that
   by default it also checks if its visibility can be reduced to package-private. Surely that’s a
   feature everyone disables. I know I did.

Prefer feature-oriented architectures over layer-oriented architectures.

   I have grown to dislike this (very common) layer-oriented layout of packages:
src/main/java/com/companyname/productname/
  controller/
    StuffController.java
    ThingController.java
  converter/
    StuffConverter.java
    ThingConverter.java
  dao/
    StuffDao.java
    ThingDao.java
  model/
    Stuff.java
    Thing.java
  service/
    StuffService.java
    ThingService.java
  util/
    StuffHelper.java
    ThingHelper.java

   This layer-oriented format is so common that it even appears in [4]Spring’s documentation, and 95%+
   of the projects I see use this format for web applications. This diminishes the integrity of the
   architecture, implements the wrong kind of seperation of concerns, and leads to code that’s harder to
   maintain and split apart. A much cleaner approach is to organise your code by feature:
src/main/java/com/companyname/productname/
  stuff/
    StuffController.java
    StuffConverter.java
    StuffDao.java
    Stuff.java
    StuffService.java
    StuffHelper.java
  thing/
    ThingController.java
    ThingConverter.java
    ThingDao.java
    Thing.java
    ThingService.java
    ThingHelper.java

   This approach gives you a clearer view of your architecture as it emphasises features over design
   patterns. More importantly, the coupling between features is necessarily more obvious. Any non-Stuff
   related dependencies inside any of the Stuff classes are declared in the imports. I recommend [5]this
   article if you are interested in learning more about the perils of layer oriented architectures.

Rethinking best practices
   Allow me to diverge for a second and bring up a point I learned from the JavaScript (no relation)
   community. Ever since I first started learning about React, I’ve been plagued by this notion of
   [6]rethinking best practices and if it applies to other best practices I’m currently following. If
   you squint you can see how React is a prime example of a technology that embodies the
   feature-oriented architecture in that it combines HTML and JavaScript (and often CSS as well) in a
   single component. In other words, it associates your view logic (JS) with your template (HTML/CSS) —
   exactly because they are conceptually related (highly cohesive). However, React components are not
   necessarily related to each other (loosely coupled).

   [7]diagram of conventional frontend architecture and the modern react architecture

Rethinking Java best practices
   Back to the default access modifier. I believe that the default access modifier was designed with
   exactly the feature-oriented package structure in mind. Say that you have a StuffController and
   StuffService that looks something like the following:
package com.companyname.productname.controller;

import com.companyname.productname.converter.StuffConverter;
import com.companyname.productname.model.Stuff;
import com.companyname.productname.service.StuffService;
import java.util.Set;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class StuffController {

    private final StuffConverter converter;
    private final StuffService service;

    @Autowired
    public StuffController(final StuffService service,
                           final StuffConverter converter) {
        this.converter = converter;
        this.service = service;
    }

    @GetMapping("/names")
    public List<String> getAllNames() {
        final Set<Stuff> stuff = service.findAllTheStuff();
        return converter.extractAllNames(stuff);
    }

}
     ________________________________________________________________________________________________

package com.companyname.productname.service;

import com.companyname.productname.dao.StuffDao;
import com.companyname.productname.model.Stuff;
import java.util.Set;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class StuffService {

    private final StuffDao dao;

    @Autowired
    public StuffService(final StuffDao dao) {
        this.dao = dao;
    }

    public Set<Stuff> findAllTheStuff() {
        //Other logic...

        return dao.getAllStuff();
    }
}

   If we switch to the feature-oriented package structure and use the default access modifier the way it
   was intended, we get terser code. Notice how all the redundant imports went away.
package com.companyname.productname.stuff;

import java.util.Set;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class StuffController {

    private final StuffConverter converter;
    private final StuffService service;

    @Autowired
    StuffController(final StuffService service,
                    final StuffConverter converter) {
        this.converter = converter;
        this.service = service;
    }

    @GetMapping("/names")
    public List<String> getAllNames() {
        final Set<Stuff> stuff = service.findAllTheStuff();
        return converter.extractAllNames(stuff);
    }

}
     ________________________________________________________________________________________________

package com.companyname.productname.stuff;

import java.util.Set;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
class StuffService {

    private final StuffDao dao;

    @Autowired
    StuffService(final StuffDao dao) {
        this.dao = dao;
    }

    Set<Stuff> findAllTheStuff() {
        //Other logic...

        return dao.getAllStuff();
    }
}

   You may have noticed that I still keep public in a couple of places where it’s not strictly
   necessary. I firmly believe that code should express its own intent. I tend to prefer code
   readability over code minimalism; two concepts that are related, but different. In the case of the
   controller class I use public to show that this class is in fact accessed from outside the package.
   Similarly, the public @GetMapping annotated method is accessed from outside the package as well.

   When adjusting to this new mindset of loving the default modifier, the lack of a modifier on the
   findAllTheStuff() method may feel uncomfortable at first. I used the following mantra to guide my
   intuition until I got comfortable with the access modifier nudity:

     By default, we want this functionality to remain within the feature.

   Anything else is one of:
     * Explicitly made available to any class (public).
     * Explicitly made available to subclasses (protected).
     * Explicitly restricted to only this class (private).

   Notice how the imports are now only classes that are unrelated to this feature. Take advantage of
   this symbiosis between the default access modifier and not having to explicitly import classes from
   the same package. How often do you check the imports when you’re writing code or doing a code review?
   Chances are they’re entirely ignored. I claim that imports are crucial in understanding the coupling
   between units. Imports within the feature do nothing but hide excessive coupling in a forest of
   boilerplate code.

   Case in point: A developer [9]skilled in the Spring Framework might have noticed the @Autowired
   annotation from the imports alone, which is redundant in both of these classes.

   In high-quality code I would expect that the quantity of methods increase as the access modifier gets
   more restrictive. Perhaps the default modifier would have been more intuitive had the absense of a
   modifier meant private rather than package-private. It certainly would have shaved many a character
   from my classes. This is what I believe is the design flaw behind the default access modifier, rather
   than its existence in the first place. Hindsight is 20/20 I guess.

Conclusion
   In today’s world of microservices and cloud architecture a common pattern for managing large systems
   is extracting sprout microservices (read more about this topic in [10]my article in my company’s
   blog). This is a trivial exercise when the architecture of your service is oriented around features
   rather than layers.

   The default access modifier in Java does have a purpose, and it’s one of feature encapsulation. It’s
   such a shame that its use has become misunderstood and frowned upon.

PS:
   I started writing this article before Java 9 came out but I have to say, I’m really excited about
   Java 9. It comes with a module system that adds additional encapsulation at a package level. For
   example, in Java 8 and earlier you could override the implementation of package-private methods in
   any third party library by placing your class in the library’s package and inheriting. This is no
   longer possible. I expect that once this new module system has gained some traction we’ll start
   seeing some new patterns around organising our code. I’m hoping developers become more conscious of
   their package structure. Although, I’m not holding my breath on that one.


---
https://guides.codepath.com/android/Organizing-your-Source-Files

Organizing your Source Files

Overview
   Android applications should always be neatly organized with a clear folder structure that makes your
   code easy to read. In addition, proper naming conventions for code and classes are important to
   ensure your code is clean and maintainable.

Naming Conventions
   Be sure to check out the [15]Ribot Code and Style Guidelines for a more extensive breakdown of
   suggested style and naming guidelines.

For Java Code
   The following naming and casing conventions are important for your Java code:
   Type         Example                 Description
   Variable     incomeTaxRate           All variables should be camel case      
   Constant     DAYS_IN_WEEK            All constants should be all uppercase   
   Method       convertToEuroDollars    All methods should be camel case        
   Parameter    depositAmount           All parameter names should be camel case

For Android Classes
   Android classes should be named with a particular convention that makes their purpose clear in the
   name. For example all activities should end with Activity as in MoviesActivity. The following are the
   most important naming conventions:
   
   Name                 Convention                  Inherits
   Activity             CreateTodoItemActivity      AppCompatActivity, Activity
   List Adapter         TodoItemsAdapter            BaseAdapter, ArrayAdapter
   Database Helper      TodoItemsDbHelper           SQLiteOpenHelper
   Network Client       TodoItemsClient             N/A
   Fragment             TodoItemDetailFragment      Fragment
   Service              FetchTodoItemService        Service, IntentService

   Use your best judgement for other types of files. The goal is for any Android-specific classes to be
   identifiable by the suffix.

Android Folder Structure
   There are several best practices for organizing your app's package structure.

Organize packages by category
   The way to do this is to group things together by their category. Each component goes to the
   corresponding package:
     * com.example.myapp.activities - Contains all activities
     * com.example.myapp.adapters - Contains all custom adapters
     * com.example.myapp.models - Contains all our data models
     * com.example.myapp.network - Contains all networking code
     * com.example.myapp.fragments - Contains all fragments
     * com.example.myapp.utils - Contains all helpers supporting code.
     * com.example.myapp.interfaces - Contains all interfaces

   Keeping these folders in each app means that code is logically organized and scanning the code is a
   pleasant experience. You can see a slight variation on this structure as suggested by [22]Futurice on
   their best-practices repo.

Organize packages by application features
   Alternatively, we can package-by-feature rather than layers. This approach uses packages to
   reflect the feature set. Consider the following package structure [24]as outlined in this post:
     * com.example.myapp.service.* - Is a subpackage for all background related service packages/classes
     * com.example.myapp.ui.* - Is a subpackage for all UI-related packages/classes
     * com.example.myapp.ui.mainscreen - Contains classes related to some app's Main Screen
     * com.example.myapp.ui.detailsscreen - Contains classes related to some app's Item Details Screen

   This feature allows you to place DetailsActivity, DetailsFragment, DetailsListAdapter,
   DetailsItemModel in one package, which provides comfortable navigation when you're working on "item
   details" feature.

   DetailsListAdapter and DetailsItemModel classes and/or their properties can be made package-private,
   and thus not exposed outside of the package. Within the package you may access their properties
   directly without generating tons of boilerplate "setter" methods.

   This can make object creation really simple and intuitive, while objects remain immutable outside the
   package.

Organizing Resources
   Resources should be split up into the following key files and folders:
   Name             Path                        Description
   XML Layouts      res/layout/                 This is where we put our XML layout files.
   XML Menus        res/menu/                   This is where we put our AppBar menu actions.
   Drawables        res/drawable                This is where we put images and XML drawables.
   Colors           res/values/colors.xml       This is where we put color definitions.
   Dimensions       res/values/dimens.xml       This is where we put dimension values.
   Strings          res/values/strings.xml      This is where we put strings.
   Styles           res/values/styles.xml       This is where we put style values.

   See the full list of resources here and note the following:
     * Don't hardcode color hex values in the layout. Instead of hardcoding these values, be sure to
       move all colors into res/values/colors.xml and reference the colors in layouts with
       @color/royal_blue.
     * Don't hardcode margin / padding dimensions in the layout. Instead of hardcoding these values, be
       sure to move all dimension values into res/values/dimens.xml and reference these in layouts
       with @dimen/item_padding_left.
     * To support multiple devices, we can then use the [30]alternative resources system to provide
       different colors, strings, dimens, styles, etc based on the device type, screen size, API version
       and much more.

   Be sure to start properly organizing your resources early on in the development of an application. Be
   sure to check out the [31]Ribot Code and Style Guidelines for a more extensive breakdown of suggested
   style and naming guidelines.

Organizing Resources into Subfolders
   Often there are questions about organizing not just the source files but also better organizing the
   application resources. In a modern app, there are often hundreds of different layout files,
   drawables, styles, etc and by default these are all grouped together in a flat list within a single
   subdirectory (i.e res/layout). For now, keep the layout resource files in the same directory.

   Refer to stackoverflow post for a discussion of explored options. The main problem is that if you
   try to use the nested resource layout approach, the current logic for the Android Studio's Gradle
   plug-in will not update the resource files after they have changed for nested resource sets. The
   current implementation attempts to check the resource directories using startsWith(), so a directory
   structure that is nested (i.e. src/main/res/layout/layouts and src/main/res/layout/layouts_category2)
   will choose src/main/res/layout/layouts consistently and never actually update the changes. A result,
   you will you have to rebuild/clean the project each time whenever making layout file changes.

Conclusion
   It is up to you to decide which of the aforementioned approaches suits your project best.

   However, in general Java programming, packaging apps by feature is considered preferable and
   makes a lot of sense.

---
   