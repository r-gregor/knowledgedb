filename: jv_builder-pattern-multif_20200525.txt
https://medium.com/@sergio.igwt/the-builder-pattern-in-java-2c03fc6ccd16

The Builder pattern in Java - yet another Builder Pattern article?

   Yet another "Builder pattern article"? Not quite so. At least half of the explanations and tutorials
   on the design patters, and the Builder pattern itself, do not cover the underlying problem that this
   or that pattern is aiming to solve. As a self-taught programmer I am always trying to understand
   first why I'm doing something, rather than how, and nowadays people are more focused on how's rather
   than why's, which often leads to misunderstanding the core problem and as a consequence - incorrect
   solution.

The problem
   In OOP more often than not we have classes holding some data that we are setting and later accessing.
   Creating instances of such classes might be a bit of a pain sometimes. Let's consider the following
   Pizza class:
public class Pizza {
    private String pizzaSize;
    private int cheeseCount;
    private int pepperoniCount;
    private int hamCount;
    
    // constructor, getters, setters
}

   A very simple class at first glance, but there are a few caveats, for example three int fields coming
   one after the other, or the number of the fields (Although at this point this might not look like a
   big issue, but it will be soon enough.)

   Any of our pizzas will have a size, however when it comes to the toppings, some or all can be
   present, or none at all, therefore some of the properties of our class are optional and some are
   mandatory.

Constructor overloading pattern.
   Creating the class like new Pizza("small", 1, 0, 0) every time I want to simply get a pizza object
   with cheese and nothing else does not sound like a good idea to me. And here comes the first common
   solution - constructor overloading.
   
public class Pizza {
    private String pizzaSize; // mandatory
    private int cheeseCount; // optional
    private int pepperoniCount; // optional
    private int hamCount; // optional
    
    public Pizza(String pizzaSize) {
        this(pizzaSize, 0, 0, 0);
    }
    
    public Pizza(String pizzaSize, int cheeseCount) {
        this(pizzaSize, cheeseCount, 0, 0);
    }
    
    public Pizza(String pizzaSize, int cheeseCount, int pepperoniCount) {
        this(pizzaSize, cheeseCount, pepperoniCount, 0);
    }
    
    public Pizza(String pizzaSize, int cheeseCount, int pepperoniCount, int hamCount) {
        this.pizzaSize = pizzaSize;
        this.cheeseCount = cheeseCount;
        this.pepperoniCount = pepperoniCount;
        this.hamCount = hamCount;
    }
    
    // getters
}

   This however solves the problem only partially. We can't, for example, create a pizza with cheese and
   ham, but without pepperoni like this: new Pizza("small", 1, 1) as the third argument of the
   constructor is pepperoni. With this method we need to use the constructor containing the least number
   of arguments and all arguments that we need: new Pizza("small, 1, 0, 1).

   If the number of our parameters grows so does the umber of overridden constructors:
public class Pizza {
    private String pizzaSize; // mandatory
    private String crust; // mandatory
    private int cheeseCount; // optional
    private int pepperoniCount; // optional
    private int hamCount; // optional
    private int mushroomsCount; // optional
    
    public Pizza(String pizzaSize, String crust) {
        this(pizzaSize, crust, 0, 0, 0, 0);
    }
    
    public Pizza(String pizzaSize, String crust, int cheeseCount) {
        this(pizzaSize, crust, cheeseCount, 0, 0, 0);
    }
    
    public Pizza(String pizzaSize, String crust, int cheeseCount, int pepperoniCount) {
        this(pizzaSize, crust, cheeseCount, pepperoniCount, 0, 0);
    }
    
    public Pizza(String pizzaSize, String crust, int cheeseCount, int pepperoniCount, int hamCount) {
        this(pizzaSize, crust, cheeseCount, pepperoniCount, hamCount, 0);
    }
    
    public Pizza(String pizzaSize, String crust, int cheeseCount, int pepperoniCount, int hamCount, \
    int mushroomsCount) {
        this.pizzaSize = pizzaSize;
        this.crust = crust;
        this.cheeseCount = cheeseCount;
        this.pepperoniCount = pepperoniCount;
        this.hamCount = hamCount;
        this.mushroomsCount = mushroomsCount;
    }
    
    // getters
}

   And if someone switches the parameters order in the constructor?
public Pizza(String pizzaSize, String crust, int hamCount, int mushroomsCount, int cheeseCount, \
int pepperoniCount) {
    this.pizzaSize = pizzaSize;
    this.crust = crust;
    this.cheeseCount = cheeseCount;
    this.pepperoniCount = pepperoniCount;
    this.hamCount = hamCount;
    this.mushroomsCount = mushroomsCount;
}

   Then our small pizza with thin crust, 1 cheese and 1 pepperoni: new Pizza("small", "thin", 1, 1)
   might become a small pizza with thin crust, 1 ham and 1 mushrooms and our first line of defense - the
   compiler won't give us any warnings at all.

   All in all, overriding constructors pattern (or as it is usually referred to "telescoping constructor
   pattern") works, but it is hard to maintain if the class changes and we introduce new parameters, the
   number of constructors will grow as well, so it doesn't scale very well. The readability suffers a
   lot, and often you're just sitting there wondering what are all those values represent that are being
   passed to the constructor when the object is instantiated.

JavaBeans pattern
   Another common solution is JavaBeans. First we call a parameterless constructor of the class, and
   then set the properties we need with the public setters:
Pizza pizza = new Pizza();
pizza.setPizzaSize("small");
pizza.setCrust("thin");
pizza.setMushroomsCount(1);
pizza.setCheeseCount(1);
// do something with pizza

   This solution has none of the disadvantages of the telescoping constructor pattern. It's easy to
   scale the class, easier to instantiate, albeit a bit wordier, it's more readable and more flexible.

   The pattern however has serious disadvantages of its own. The construction of the class is split into
   multiple calls, therefore the instance may be in a partially constructed / invalid state:
Pizza pizza = new Pizza();
pizza.setPizzaSize("medium");
pizza.setCheeseCount(1);
pizza.deliver(); 
// we didn't set the crust, which will probably thrown an NPE somewhere down the call

   Another big disadvantage is that the JavaBeans pattern does not enforce immutability.

The solution - Builder pattern
   The Builder pattern is one of the creational design patterns in OOP, in other words, it is used
   to create and configure objects. Builders are a commonly used technique for eliminating multiple
   constructor overrides and provides a more flexible solution to creating complex objects and is often
   accompanied by a fluent interface pattern.

   Let's add a Builder to our Pizza class:
public class Pizza {
    private String pizzaSize;
    private String crust;
    private int cheeseCount;
    private int pepperoniCount;
    private int hamCount;
    private int mushroomsCount;
    
    public static class Builder {
        private String pizzaSize; // mandatory
        private String crust; // mandatory
        private int cheeseCount = 0; // optional
        private int pepperoniCount = 0; // optional
        private int hamCount = 0; // optional
        private int mushroomsCount = 0; // optional
        
        // We set these in the constructor because we want to enforce the client setting these
        // as they are mandatory
        public Builder(String pizzaSize, String crust) {
            this.pizzaSize = pizzaSize;
            this.crust = crust;
        }
        
        public Builder cheeseCount(int cheeseCount) {
            this.cheeseCount = cheeseCount;
            return this;
        }
        
        public Builder pepperoniCount(int pepperoniCount) {
            this.pepperoniCount = pepperoniCount;
            return this;
        }
        
        public Builder hamCount(int hamCount) {
            this.hamCount = hamCount;
            return this;
        }
        
        public Builder mushroomsCount(int mushroomsCount) {
            this.mushroomsCount = mushroomsCount;
            return this;
        }
        
        public Pizza build() {
            return new Pizza(this);
        }
        
    }
    
    private Pizza(Builder builder) {
        this.pizzaSize = builder.pizzaSize;
        this.crust = builder.crust;
        this.cheeseCount = builder.cheeseCount;
        this.pepperoniCount = builder.pepperoniCount;
        this.hamCount = builder.hamCount;
        this.mushroomsCount = builder.mushroomsCount;
    }
    
    // getters
}

   We made our Pizza constructor a private one so that our class can't be instantiated directly, at the
   same time we added a static Builder class with a constructor that has our mandatory parameters
   pizzaSize and crust, methods setting optional parameters, and finally a build() method that will
   return a new instance of Pizza class. The setter methods return the Builder itself thus giving us a
   fluent interface with method chaining.
Pizza pizza = new Pizza.Builder("large", "thin")
    .cheeseCount(1)
    .pepperoniCount(1)
    .build();

   The resulting Pizza object is immutable as compared to the above JavaBeans one. It is much easier to
   write and, more important, to read this code. Just like with the constructor, we can check the passed
   parameters for any violations, most often inside the build() method or the setter method themselves,
   and throw IllegalStateException if any violations are present prior to creating an instance of the
   class.

   Though the Builder pattern does have disadvantages some minor disadvantages. First of all, you need
   to create a Builder object prior to creating the object of the class itself. This could potentially
   be a problem in some performance-critical cases.

   The class becomes a bit more verbose and I wouldn't generally use a builder if the class only has 2-3
   parameters and is unlikely to change in the future. In other cases I prefer to have builders over
   regular constructors.

   Overall, the Builder pattern is a very commonly used technique for creating objects and is a good
   choice to use when classes have constructors with multiple parameters (especially optional ones) and
   are likely to change in the future. The code becomes much easier to write and read as compared to
   overridden constructors, and the class scales just as well as JavaBeans but is much safer.



---
https://medium.com/@ajinkyabadve/builder-design-patterns-in-java-1ffb12648850

Builder Design Patterns in Java

   While Considering the builder pattern you need to look weather the object is having

Complex constructor.
   Multiple constructor having combinations of multiple parameter with nested objects
Large number of parameters.

   having large number of field parameter is also the key point to consider.
   
Immutability.
   You can force the immutability to the object once you are done with creation of object.

   Builder pattern is a creational design pattern it means its solves problem related to object
   creation.Best example would be an AlertDialog class from AOSP, StringBuilder, DocumentBuilder best
   to see how the compex object can be created.

   It typically solve problem in object oriented programming i.e determining what constructor to use.
   Often we write many constructor and it is really hard to manage them. The multiple constructor with
   combination of multiple parameters variation is called the telescoping constructor.

     Builder pattern is used to create instance of very complex object having telescoping constructor
     in easiest way.

   Constructors in Java are used to create object and can take parameters required to create object.
   Lets see an example and learn how to implement builder pattern. Consider a pojo of Person below.
public class Person {
    private String firstName;
    private String middleName;
    private String lastName;
    private int age;
    
    public Person(String firstName, String middleName, String lastName, int age) {
        this.firstName = firstName;
        this.middleName = middleName;
        this.lastName = lastName;
        this.age = age;
    }
    
    public Person(String firstName, String lastName, int age) {
        this(firstName, null, lastName, age);
    }
    
    public Person(String firstName, int age) {
        this(firstName, null, age);
    }
    
    public String getFirstName() {
        return firstName;
    }
    
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }
    
    public String getMiddleName() {
        return middleName;
    }
    
    public void setMiddleName(String middleName) {
        this.middleName = middleName;
    }
    
    public String getLastName() {
        return lastName;
    }
    
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
    
    public int getAge() {
        return age;
    }
    
    public void setAge(int age) {
        this.age = age;
    }
}

   Things are simple if there are only 4 fields but, lets say if you want to add more fields to the pojo
   then it becomes hectic to maintain complex pojo plus the order of the minimum fields to required to
   create the object. Also it can leads to bugs in code base.

Convert to Builder Pattern
   Let's now add some extra fields fathersName, mothersName, height, weight to the pojo and convert it
   to the Builder pattern. Create static anonymous inner class named Builder to the pojo, why static
   because we want to return/use current object. Add same fields to it from pojo. Also add the empty
   constructor and setter of each filed with return type of Builder class. And last but not least add
   method build which will return the new Person object instance.
public class Person {
    private String firstName;
    private String middleName;
    ....
    
    public Person(String firstName, String middleName, String lastName, int age, String fathersName, \
    String mothersName, double height, double weight) {
        this.firstName = firstName;
        this.middleName = middleName;
    ....
    }
    
    public static class Builder {
        private String firstName;
        private String middleName;
        private String lastName;
        private int age;
        private String fathersName;
        private String mothersName;
        private double height;
        private double weight;
        
        public Builder(){}
        
        public Builder setFirstName(String firstName) {
            this.firstName = firstName;
            return this;
        }
        
        public Builder setMiddleName(String middleName) {
            this.middleName = middleName;
            return this;
        }
        public Builder setLastName(String lastName) {
            this.lastName = lastName;
            return this;
        }
        ...
        public Person build() {
            return new Person(firstName, middleName, lastName, age, fathersName, mothersName, height, weight);
        }
    }

   The resulting builder create code:
Person person = new Person.Builder()
        .setAge(5)
        .setFirstName("Bob")
        .setHeight(6)
        .setAge(19)
        .build();

Pros
   1) Code is more maintainable if number of fields required to create object is more than 4 or 5.

   2) Object Creation code less error-prone as user will know what they are passing because of explicit
   method call.

   3) Builder pattern increase robustness, as only fully constructed object will be available to client.

   4) You can force immutability to the object once its created.

Cons
   1) Builder pattern is verbose and requires code duplication as Builder needs to copy all fields from
   Original or Item class.



---
https://howtodoinjava.com/design-patterns/creational/builder-pattern-in-java/

Builder Design Pattern in Java

   The builder pattern, as name implies, is an alternative way to construct complex objects. This
   should be used only when you want to build different immutable objects using same object building
   process.

   Before starting the discussion, I want to make it clear that the builder pattern which I am going to
   discuss in this post, is slightly different from what is mentioned in GangOfFour "Design Patterns"
   book. The book says:
   The builder pattern is a design pattern that allows for the step-by-step creation of complex objects
   using the correct sequence of actions. The construction is controlled by a director object that only
   needs to know the type of object it is to create.

   I really find it hard making use of above example in real life programming and applications. Above
   process is very much similar (not exactly) to Abstract factory pattern, where you find a factory
   (or builder) for a specific type of object, and then factory gives you a concrete instance of that
   object. The only big difference between this builder pattern and abstract factory pattern is that,
   builder provides you more control over the object creation process and that's it. Apart from it,
   there are no major differences.
   In one sentence, abstract factory pattern is the answer to "WHAT" and the builder pattern to "HOW".

   For me, a builder pattern is more like fluent interface. A fluent interface is normally
   implemented by using method cascading (or method chaining).

   Now from here, I will start discussing builder pattern the way I find it useful specially in
   practical cases. And I hope to convince you guys as well.

Definition of Builder Pattern
   Let's start by a giving a definition to builder pattern:

     Builder pattern aims to "Separate the construction of a complex object from its representation so
     that the same construction process can create different representations."

Where we need Builder Pattern
   We already know the benefits of immutability and immutable instances in application. If you have
   any question over it, the please let me remind you of String class in java. And as I already said,
   builder pattern helps us in creating immutable classes with large set of state attributes.

   Let's discuss a common problem in our application. In any user management module, primary entity is
   User, let's say. Ideally and practically as well, once a user object is fully created, you will not
   want to change it's state. It simply does not make sense, right? Now, let's assume, our User object
   has following 5 attributes i.e. firstName, lastName, age, phone and address.

   In normal practice, if you want to make a immutable User class, then you must pass all five
   information as parameters to constructor. It will look like this:
public User (String firstName, String lastName, int age, String phone, String address){
    this.firstName = firstName;
    this.lastName = lastName;
    this.age = age;
    this.phone = phone;
    this.address = address;
}

   Very good. Now what if only firstName and lastName are mandatory and rest 3 fields are optional.
   Problem !! We need more constructors.
public User (String firstName, String lastName, int age, String phone){ ...     }
public User (String firstName, String lastName, String phone, String address){ ...      }
public User (String firstName, String lastName, int age){ ...   }
public User (String firstName, String lastName){ ...    }

   We will need some more like above. Still can manage? Now let's introduce our sixth attribute i.e.
   salary. Now it is problem.

   One way it to create more constructors, and another is to loose the immutability and introduce setter
   methods. You choose any of both options, you loose something, right?

   Here, builder pattern will help you to consume additional attributes while retaining the immutability
   of Use class.

A sample implementation using Builder Pattern
   Below is the coded solution of problem we discussed above. This uses a additional class UserBuilder
   which helps us in building desired User object with all mandatory attributes and combination of
   optional attributes, without loosing the immutability.
public class User {
    //All final attributes
    private final String firstName; // required
    private final String lastName; // required
    private final int age; // optional
    private final String phone; // optional
    private final String address; // optional

    private User(UserBuilder builder) {
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.age = builder.age;
        this.phone = builder.phone;
        this.address = builder.address;
    }

    //All getter, and NO setter to provde immutability
    public String getFirstName() {
        return firstName;
    }
    public String getLastName() {
        return lastName;
    }
    public int getAge() {
        return age;
    }
    public String getPhone() {
        return phone;
    }
    public String getAddress() {
        return address;
    }

    @Override
    public String toString() {
        return "User: "+this.firstName+", "+this.lastName+", "+this.age+", "+this.phone+", "+this.address;
    }

    public static class UserBuilder
    {
        private final String firstName;
        private final String lastName;
        private int age;
        private String phone;
        private String address;

        public UserBuilder(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
        }
        public UserBuilder age(int age) {
            this.age = age;
            return this;
        }
        public UserBuilder phone(String phone) {
            this.phone = phone;
            return this;
        }
        public UserBuilder address(String address) {
            this.address = address;
            return this;
        }
        
        //Return the finally constrcuted User object
        public User build() {
            User user =  new User(this);
            validateUserObject(user);
            return user;
        }
        private void validateUserObject(User user) {
            //Do some basic validations to check
            //if user object does not break any assumption of system
        }
    }
}

   And below is the way, we will use the UserBuilder in our code:
public static void main(String[] args) {
    User user1 = new User.UserBuilder("Lokesh", "Gupta")
    .age(30)
    .phone("1234567")
    .address("Fake address 1234")
    .build();

    System.out.println(user1);

    User user2 = new User.UserBuilder("Jack", "Reacher")
    .age(40)
    .phone("5655")
    //no address
    .build();

    System.out.println(user2);

    User user3 = new User.UserBuilder("Super", "Man")
    //No age
    //No phone
    //no address
    .build();

    System.out.println(user3);
}

Output:

User: Lokesh, Gupta, 30, 1234567, Fake address 1234
User: Jack, Reacher, 40, 5655, null
User: Super, Man, 0, null, null

   Please note that above created user object does not have any setter method, so it's state can not be
   changed once it has been built. This provides the desired immutability.

   Sometimes developers may forget to add support for a new attribute to the builder when they add that
   attribute to the User class. To minimize this, we should enclose the builders inside the class (as in
   above example) that they build so that it's more obvious to the developer that there is a relevant
   builder that needs to be updated too.

     Sometimes I think there should be a Destroyer pattern (opposite to builder) which should tear down
     certain attributes from a complex object in systematic manner. What do you think?

Existing implementations in JDK
   All implementations of java.lang.Appendable are infact good example of use of Builder pattern in
   java. e.g.

   java.lang.StringBuilder#append() [Unsynchronized class]

   java.lang.StringBuffer#append() [Synchronized class]

   java.nio.ByteBuffer#put() (also on CharBuffer, ShortBuffer, IntBuffer, LongBuffer, FloatBuffer
   and DoubleBuffer)

   Another use can be found in javax.swing.GroupLayout.Group#addComponent().

   Look how similar these implementations look like what we discussed above.
StringBuilder builder = new StringBuilder("Temp");
String data = builder.append(1)
        .append(true)
        .append("friend")
        .toString();
        
System.out.println(data);
Output:
Temp1truefriend

Benefits and Advantages of Builder Pattern
   Undoubtedly, the number of lines of code increase at least to double in builder pattern, but the
   effort pays off in terms of design flexibility and much more readable code. The parameters to the
   constructor are reduced and are provided in highly readable method calls.

   Builder pattern also helps minimizing the number of parameters in constructor and thus there is no
   need to pass in null for optional parameters to the constructor. It really attracts me.

   Another advantage is that Object is always instantiated in a complete state rather than sitting in an
   incomplete state until the developer calls (if ever calls) the appropriate "setter" method to set
   additional fields.

   And finally I can build immutable objects without much complex logic in object building process.

Costs and Disadvantages of Builder Pattern
   Though Builder pattern reduces some line of code by eliminating the need of setter methods, still in
   double up total lines by introducing the Builder object. Furthermore, although client code is more
   readable, the client code is also more verbose. Though for me, readability weighs more than lines of
   code.

   That's only disadvantage I can think of.


---
https://dzone.com/articles/design-patterns-the-builder-pattern

Design Patterns: The Builder Pattern

This look at the builder pattern takes complexity, verbosity, and clarity into consideration when
implementing this classic Gang of Four design.

   I've been meaning to write a series of articles on design patterns for quite a while. Patterns are
   incredibly valuable components in a developer's toolbox - they address common problems that have
   accepted, effective solutions. In addition, they contribute to a shared vocabulary amongst
   developers.

   This series assumes an understanding of object-oriented programming (OOP). I will, however, try to
   keep the examples as simple and accessible as possible, favoring practical implementations over
   obscure examples. If you're looking for an authoritative, academic text on patterns, this is what you
   want: Design Patterns: Elements of Reusable Object-Oriented Software.

   We'll start with the Builder pattern (one of my favorites). The Builder pattern is a creational
   pattern - in other words, it's used to create and configure objects. I particularly like the example
   that Joshua Bloch uses in Effective Java.

The Problem
   For this example, we'll pretend that we're part of a Java team working on a piece of software for a
   bank. Among other things, we'll need a way to represent bank accounts. Our first pass looks like this
   (note that using double for actual monetary values is a bad idea).
public class BankAccount {

    private long accountNumber;
    private String owner;
    private double balance;

    public BankAccount(long accountNumber, String owner, double balance) {
        this.accountNumber = accountNumber;
        this.owner = owner;
        this.balance = balance;
    }

    //Getters and setters omitted for brevity.
}


   This is reasonably straightforward - we can use it as follows.
BankAccount account = new BankAccount(123L, "Bart", 100.00);

   Unfortunately, solutions rarely stay simple. A new requirement arrives that says that we should keep
   track of the monthly interest rate applicable to each account, the date on which it was opened, and,
   optionally, the branch at which it was opened. It sounds easy enough, so we come up with version 2.0
   of the BankAccount class.
public class BankAccount {

    private long accountNumber;
    private String owner;
    private String branch;
    private double balance;
    private double interestRate;

    public BankAccount(long accountNumber, String owner, String branch, double balance, double interestRate) {
        this.accountNumber = accountNumber;
        this.owner = owner;
        this.branch = branch;
        this.balance = balance;
        this.interestRate = interestRate;
   }

    //Getters and setters omitted for brevity.
}


   Thanks to our new and improved account handling process, we get some new clients.
BankAccount account = new BankAccount(456L, "Marge", "Springfield", 100.00, 2.5);
BankAccount anotherAccount = new BankAccount(789L, "Homer", null, 2.5, 100.00);  //Oops!

   Our compiler, which should be our safety net, thinks that this code is fine. The practical
   implication, however, is that Homer's money will double every month. (If anyone knows of an account
   with returns like this, please let me know!) Can you figure out why? Hint: pay close attention to the
   order of the parameters passed to the constructor.

   If we have multiple consecutive arguments of the same type, it's easy to accidentally swap them
   around. Since the compiler doesn't pick it up as an error, it can manifest as an issue somewhere down
   the line at runtime - and that can turn into a tricky debugging exercise. In addition, adding more
   constructor parameters results in code that becomes harder to read . If we had 10 different
   parameters, it would become very difficult to identify what's what in the constructor at a single
   glance. To make it worse, some of those values might be optional, which means that we'll need to
   create a bunch of overloaded constructors to deal with all possible combinations, or we'll have to
   pass nulls to our constructor (ugly!).

   You might be thinking that we can mitigate the issue by calling a no-arg constructor and then setting
   up the account via setter methods instead. However, that leaves us open to another issue - what
   happens if a developer forgets to call a particular setter method? We could end up with an object
   that is only partially initialized, and again, the compiler wouldn't see any problems with it.

   Thus, there are two specific problems that we need to solve:
     * Too many constructor arguments.
     * Incorrect object state.

   This is where the Builder pattern comes into play.

The Pattern
   The Builder pattern allows us to write readable, understandable code to set up complex objects. It is
   often implemented with a fluent interface, which you may have seen in tools like Apache
   Camel or Hamcrest. The builder will contain all of the fields that exist on the BankAccount class
   itself. We will configure all of the fields that we want on the builder, and then we'll use the
   builder to create accounts. At the same time, we'll remove the public constructor from
   the BankAccount class and replace it with a private constructor so that accounts can only be created
   via the builder.

   For our example, we'll put the builder within the BankAccount class. It looks like this.
public class BankAccount {

    public static class Builder {

        private long accountNumber; //This is important, so we'll pass it to the constructor.
        private String owner;
        private String branch;
        private double balance;
        private double interestRate;

        public Builder(long accountNumber) {
            this.accountNumber = accountNumber;
        }

        public Builder withOwner(String owner){
            this.owner = owner;

            return this;  //By returning the builder each time, we can create a fluent interface.
        }

        public Builder atBranch(String branch){
            this.branch = branch;

            return this;
        }

        public Builder openingBalance(double balance){
            this.balance = balance;

            return this;
        }

        public Builder atRate(double interestRate){
            this.interestRate = interestRate;

            return this;
        }

        public BankAccount build(){
            //Here we create the actual bank account object, which is always in a fully initialised state when
            // it's returned.
            BankAccount account = new BankAccount();  // Since the builder is in the BankAccount class, we can
                                                      // invoke its private constructor.
            account.accountNumber = this.accountNumber;
            account.owner = this.owner;
            account.branch = this.branch;
            account.balance = this.balance;
            account.interestRate = this.interestRate;

            return account;
        }
    }

    //Fields omitted for brevity.
    private BankAccount() {
        //Constructor is now private.
    }

    //Getters and setters omitted for brevity.

}

   We can now create new accounts as follows.
BankAccount account = new BankAccount.Builder(1234L)
            .withOwner("Marge")
            .atBranch("Springfield")
            .openingBalance(100)
            .atRate(2.5)
            .build();

BankAccount anotherAccount = new BankAccount.Builder(4567L)
            .withOwner("Homer")
            .atBranch("Springfield")
            .openingBalance(100)
            .atRate(2.5)
            .build();

   Is this code more verbose? Yes. Is it clearer? Yes. Is it better? Since a large chunk of our time is
   spent reading code rather than writing it, I'm pretty sure it is, yes.

Summary
   We worked through an example where code started out simple, and then grew in complexity. We then used
   the Builder pattern to address the issues that we uncovered.

   If you find yourself in a situation where you keep on adding new parameters to a constructor,
   resulting in code that becomes error-prone and hard to read, perhaps it's a good time to take a step
   back and consider refactoring your code to use a Builder.


---
https://www.vogella.com/tutorials/DesignPatternBuilder/article.html

Implementing the builder pattern in Java 8 - Tutorial

1. The builder pattern

1.1. Definition
   The builder pattern provides a build object which is used to construct a complex object called the
   product. It encapsulates the logic of constructing the different pieces of the product.

1.2. Example
   Typically the builder pattern is implemented by an class which has several methods to configure the
   product. These methods typically return the builder object. This allows to use the builder via a
   fluent API, e.g, by calling methods directly after each other. Once the product is completely
   configured a build() method is called to construct the object.

   Assume you have a data model like the following.
package com.vogella.model.task;

import java.util.Date;

public class Task {
    private final long id;
    private String summary = "";
    private String description = "";
    private boolean done = false;
    private Date dueDate;

    public Task(long id) {
        this.id = id;
    }

    public Task(long id, String summary, String description, boolean done,
            Date dueDate) {
        this.id = id;
        this.summary = summary;
        this.description = description;
        this.done = done;
        this.dueDate = dueDate;

    }

    public long getId() {
        return id;
    }

    public String getSummary() {
        return summary;
    }

    public void setSummary(String summary) {
        this.summary = summary;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public boolean isDone() {
        return done;
    }

    public void setDone(boolean done) {
        this.done = done;
    }

    public Date getDueDate() {
        return new Date(dueDate.getTime());
    }

    public void setDueDate(Date dueDate) {
        this.dueDate = new Date(dueDate.getTime());
    }
}

   Your builder would looks like the following.
package com.vogella.model.task;

import java.util.Date;

public class TaskBuilder {

    private final long id;
    private String summary = "";
    private String description = "";
    private boolean done = false;
    private Date dueDate;

    public TaskBuilder(long id, String summary, String description, boolean done,
            Date dueDate) {
        this.id = id;
        this.summary = summary;
        this.description = description;
        this.done = done;
        this.dueDate = dueDate;
    }


    public TaskBuilder setSummary(String summary) {
        this.summary = summary;
        return this;
    }

    public TaskBuilder setDescription(String description) {
        this.description = description;
        return this;
    }

    public TaskBuilder setDone(boolean done) {
        this.done = done;
        return this;
    }

    public TaskBuilder setDueDate(Date dueDate) {
        this.dueDate = new Date(dueDate.getTime());
        return this;
    }
    public Task build() {
        return new Task(id,summary, description,done, dueDate);
    }
}

   And here is how you can use it.
package com.vogella.model.task;

public class MainTest {

    public static void main(String[] args) {
        Task task = new TaskBuilder(5).setDescription("Hello").setSummary("Test").build();
        System.out.println(task);
    }

}

1.3. Evaluation
   The builder pattern simplifies the creation of objects. It also simplifies the code as your do not
   have to call a complex constructor or call several setter methods on the created object.

   The builder pattern can be used to create an immutable class.


---
https://www.geeksforgeeks.org/builder-pattern-in-java/

Builder Pattern in java

   Method Chaining: In java, Method Chaining is used to invoke multiple methods on the same object which
   occurs as a single statement. Method-chaining is implemented by a series of methods that return the
   this reference for a class instance.

   Implementation: As return values of methods in a chain is this reference, this implementation
   allows us to invoke methods in chain by having the next method invocation on the return value of the
   previous method in the chain.

<code>
   // Java code to demonstrate method chaining
final class Student {

    // instance fields
    private int id;
    private String name;
    private String address;

    // Setter Methods
    // Note that all setters method
    // return this reference
    public Student setId(int id) { 
        this.id = id;
        return this;
    }

    public Student setName(String name) {
        this.name = name;
        return this;
    }

    public Student setAddress(String address) {
        this.address = address;
        return this;
    }

    @Override
    public String toString() {
        return "id = " + this.id + ", name = " + this.name +
                               ", address = " + this.address;
    }
}

// Driver class
public class MethodChainingDemo {
    public static void main(String args[]) {
        Student student1 = new Student();
        Student student2 = new Student();

        student1.setId(1).setName("Ram").setAddress("Noida");
        student2.setId(2).setName("Shyam").setAddress("Delhi");

        System.out.println(student1);
        System.out.println(student2);
    }
}
</code>

   Output:
id = 1, name = Ram, address = Noida
id = 2, name = Shyam, address = Delhi

   Need of Builder Pattern : Method chaining is a useful design pattern but however if accessed
   concurrently, a thread may observe some fields to contain inconsistent values. Although all setter
   methods in above example are atomic, but calls in the method chaining can lead to inconsistent object
   state when the object is modified concurrently. The below example can lead us to a Student instance
   in an inconsistent state, for example, a student with name Ram and address Delhi.
   
<code>
// Java code to demonstrate need of Builder Pattern

// Server Side Code
final class Student {

    // instance fields
    private int id;
    private String name;
    private String address;
    
    // Setter Methods
    // Note that all setters method
    // return this reference
    public Student setId(int id) {
        this.id = id;
        return this;
    }
    
    public Student setName(String name) {
        this.name = name;
        return this;
    }
    
    public Student setAddress(String address) {
        this.address = address;
        return this;
    }
    
    @Override
    public String toString() {
        return "id = " + this.id + ", name = " + this.name +
                            ", address = " + this.address;
    }
}

// Client Side Code
class StudentReceiver {

    private final Student student = new Student();

    public StudentReceiver() {

        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                student.setId(1).setName("Ram").setAddress("Noida");
            }
        });

        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                student.setId(2).setName("Shyam").setAddress("Delhi");
            }
        });

        t1.start();
        t2.start();
    }

    public Student getStudent() {
        return student;
    }
}

// Driver class
public class BuilderNeedDemo {
    public static void main(String args[]) {
        StudentReceiver sr = new StudentReceiver();
        System.out.println(sr.getStudent());
    }
}
</code>

   Output may be:
id = 2, name = Shyam, address = Noida

   Another inconsistent output may be
id = 0, name = null, address = null

   Note : Try running main method statements in loop(i.e. multiple requests to server simultaneously).

   To solve this problem, there is Builder pattern to ensure the thread-safety and atomicity of object
   creation.

   Implementation : In Builder pattern, we have a inner static class named Builder inside our
   Server class with instance fields for that class and also have a factory method to return an new
   instance of Builder class on every invocation. The setter methods will now return Builder class
   reference. We will also have a build method to return instances of Server side class, i.e. outer
   class.

<code>
// Java code to demonstrate Builder Pattern

// Server Side Code
final class Student {

    // final instance fields
    private final int id;
    private final String name;
    private final String address;

    public Student(Builder builder) {
        this.id = builder.id;
        this.name = builder.name;
        this.address = builder.address;
    }

    // Static class Builder
    public static class Builder {

        /// instance fields
        private int id;
        private String name;
        private String address;

        public static Builder newInstance() {
            return new Builder();
        }

        private Builder() {}

        // Setter methods
        public Builder setId(int id) {
            this.id = id;
            return this;
        }
        
        public Builder setName(String name) {
            this.name = name;
            return this;
        }
        
        public Builder setAddress(String address) {
            this.address = address;
            return this;
        }

        // build method to deal with outer class
        // to return outer instance
        public Student build() {
            return new Student(this);
        }
    }

    @Override
    public String toString()
    {
        return "id = " + this.id + ", name = " + this.name +
                               ", address = " + this.address;
    }
}

// Client Side Code
class StudentReceiver {

    // volatile student instance to ensure visibility
    // of shared reference to immutable objects
    private volatile Student student;

    public StudentReceiver() {

        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                student = Student.Builder.newInstance()
                              .setId(1)
                              .setName("Ram")
                              .setAddress("Noida")
                              .build();
            }
        });

        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                student = Student.Builder.newInstance()
                              .setId(2)
                              .setName("Shyam")
                              .setAddress("Delhi")
                              .build();
            }
        });

        t1.start();
        t2.start();
    }

    public Student getStudent() {
        return student;
    }
}

// Driver class
public class BuilderDemo {
    public static void main(String args[]) {
        StudentReceiver sr = new StudentReceiver();
        System.out.println(sr.getStudent());
    }
}
</code>

   Output is guaranteed to be one of below:
id = 1, name = Ram, address = Noida

   OR
id = 2, name = Shyam, address = Delhi

   The Builder.newInstance() factory method can also be called with any required arguments to obtain a
   Builder instance by overloading it. The object of Student class is constructed with the invocation of
   the build() method.
   The above implementation of Builder pattern makes the Student class immutable and consequently
   thread-safe.

   Also note that the student field in client side code cannot be declared final because it is
   assigned a new immutable object. But it be declared volatile to ensure visibility of shared
   reference to immutable objects. Also private members of Builder class maintain encapsulation.

   Please have a look at append method of StringBuilder class in java.lang package to
   understand implementations of Builder pattern more.

   
---
