filename: jv_javafx_intro_20200403.txt
http://zetcode.com/gui/javafx/

JavaFX tutorial
   This is a JavaFX tutorial. The JavaFX tutorial is suited for beginners and intermediate Java
   developers. After reading this tutorial, you will be able to develop non-trivial JavaFX applications.

Table of contents

     * Introduction
     * First programs
     * Layout panes
     * JavaFX controls
     * JavaFX controls II
     * Events
     * Effects
     * Animation
     * Canvas
     * Charts

JavaFX
   JavaFX is a software platform for developing and delivering rich internet applications (RIAs) that
   can run across a wide variety of devices. JavaFX is the next generation GUI toolkit for the Java
   platform.

Related tutorials
   The [http://zetcode.com/tutorials/javaswingtutorial/]Java Swing tutorial covers Swing.
   The [http://zetcode.com/ebooks/advancedjavaswing/]Advanced Java Swing e-book covers advanced Java Swing
   topics. The [http://zetcode.com/tutorials/javagamestutorial/]Java 2D games tutorial and
   the [http://zetcode.com/gfx/java2d/]Java 2D tutorial further enhance your knowledge of the graphics
   programming in Java. The [http://zetcode.com/lang/java/]Java tutorial teaches the basics of Java language.


---

http://zetcode.com/gui/javafx/intro/

Introduction to JavaFX (part 1)

About JavaFX
   JavaFX is a software platform for developing and delivering rich internet applications (RIAs) that
   can run across a wide variety of devices. JavaFX is the next generation GUI toolkit for the Java
   platform. It is fully integrated with recent versions of Java SE Runtime Environment (JRE) and the
   Java Development Kit (JDK).

   JavaFX has the following main parts:
     * Prism
     * Glass windowing toolkit
     * Media engine
     * Web engine

   Prism is a high-performance graphics engine for 2D and 3D graphics. Glass windowing toolkit is a
   platform-dependent layer that connects JavaFX to the native operating system. It provides native
   operating system services, like managing windows, events, timers, and surfaces. Media engine provides
   tools to create media applications that enable media playback in the desktop window or within a web
   page on supported platforms. Web engine is a web browser engine that supports HTML5, CSS, JavaScript,
   DOM, and SVG.
   Note: Since Java 11, JavaFX is not a part of the Java SE distribution. JavaFX SDK has to be
   downloaded separately.

Anatomy of a JavaFX application
   Application is the main class of a JavaFX program. Each JavaFX program must extend the Application
   class. Its start() method is the main entry point of the application; it is the first method to be
   called after the system is ready. The main() method is not required in JavaFX applications; it can be
   used as a fallback when the application cannot be launched in certain situations.

   A JavaFX application consists of a Stage and a Scene. Stage is the top-level container, the main
   window of the application. (For applications embedded in a web browser, it is the main rectangular
   area.) Scene is the container for the visual content of the Stage. The Scene's content is organized
   in a Scene graph. The two terms reflect the shift from desktop applications to more generic rich
   internet applications.

Scene graph
   Scene graph is a hierarchical tree of nodes that represents all of the visual elements of the
   application's user interface. A single element in a scene graph is called a node. Each node is a
   branch node or a leaf node. Branch nodes can contain other nodes - their children. Leaf nodes do not
   contain other nodes. The first node in the tree is called the root node; a root node does not have a
   parent.

   Concrete implementations of nodes include graphics primitives, controls, layout managers, images, or
   media. It is possible to manipulate the scene by modifying node properties. This way we can animate
   the nodes, apply effects, do transformations, or change their opacity.

Building JavaFX applicaions
   To build a JavaFX application, we need the javafx-controls dependency and the javafx-maven-plugin
   plugin.
   pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.zetcode</groupId>
    <artifactId>FirstEx</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-controls</artifactId>
            <version>13</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.openjfx</groupId>
                <artifactId>javafx-maven-plugin</artifactId>
                <version>0.0.3</version>
                <configuration>
                    <mainClass>com.zetcode.FirstEx</mainClass>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>

   This is a sample Maven POM file.
<configuration>
    <mainClass>com.zetcode.FirstEx</mainClass>
</configuration>

   We need to provide the path to the main application class.
$ mvn javafx:run

   We run the example with the mnv javafx:run command.

JavaFX first example

   In this section, we go through a simple JavaFX application.
   com/zetcode/FirstEx.java

<code>
package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.layout.StackPane;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.stage.Stage;

public class FirstEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new StackPane();

        var scene = new Scene(root, 300, 250);

        var lbl = new Label("Simple JavaFX application.");
        lbl.setFont(Font.font("Serif", FontWeight.NORMAL, 20));
        root.getChildren().add(lbl);

        stage.setTitle("Simple application");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
</code>


   The example shows a text in the middle of the application's window.
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.layout.StackPane;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.stage.Stage;

   The essential JavaFX classes, collections, and properties reside in the javafx package.
public class FirstEx extends Application {

   Application is the main class of a JavaFX program.
@Override
public void start(Stage stage) {

    initUI(stage);
}

   The Application's start() method is overridden. The start() method is the main entry point to the
   JavaFX program. It receives a Stage as its only parameter. (Stage is the main application window or
   area.) The user interface is built in the initUI() method.
var root = new StackPane();

   StackPane is a container used for organizing nodes. It uses a simple layout manager that places its
   content nodes in a back-to-front single stack. In our case, we only want to center a single node.
var scene = new Scene(root, 300, 250);

   Scene is the container for all content in a scene graph. It takes a root node as its first parameter.
   The StackPane is a root node in this scene graph. The next two parameters specify the width and the
   height of the scene.
var lbl = new Label("Simple JavaFX application.");
lbl.setFont(Font.font("Serif", FontWeight.NORMAL, 20));

   A Label control is created and its font is set with the setFont() method. Label is a non-editable
   text control.
root.getChildren().add(lbl);

   The label control is added to the StackPane. The getChildren() method returns the list of children of
   a pane.
stage.setTitle("Simple application");

   The setTitle() method of a Stage sets a title for the main window.
stage.setScene(scene);

   The scene is added to the stage with the setScene() method.
stage.show();

   The show() method shows the window on the screen.
public static void main(String[] args) {
    launch(args);
}

   The traditional main() method is not needed. It is only used as a fallback for situations in which
   JavaFX launching is not working.
   First JavaFX application Figure: First JavaFX application

Swing and SWT
   Swing is Java's first major GUI toolkit. It is a robust and flexible GUI library. Swing is popular in
   enterprise applications. One of the incentives to create JavaFX was that it was difficult to adapt
   Swing to new trends in user interfaces. Therefore, it was decided to create JavaFX as a completely
   new toolkit.

   Standard widget toolkit (SWT) is a third-party GUI library for Java. SWT uses native GUI APIs like
   Windows API or GTK+ to create its widgets via the Java Native Interface (JNI). SWT is not part of the
   JDK. It is available as an external dependency. SWT was initially developed by the IBM corporation.
   Now it is an open source project maintained by the Eclipse community.


---
http://zetcode.com/gui/javafx/firstprograms/

JavaFX first programs  (part 2)

JavaFX Quit button
   In the following example, we have a Button control. When we click on the button, the application
   terminates. When a button is pressed and released, an ActionEvent is sent.
   com/zetcode/QuitButtonEx.java

<code>
package com.zetcode;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class QuitButtonEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var btn = new Button();
        btn.setText("Quit");
        btn.setOnAction((ActionEvent event) -> {
            Platform.exit();
        });

        var root = new HBox();
        root.setPadding(new Insets(25));
        root.getChildren().add(btn);

        var scene = new Scene(root, 280, 200);

        stage.setTitle("Quit button");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
</code>

   Button control is placed in the upper-left corner of the window. An event handler is added to the
   button.
var btn = new Button();
btn.setText("Quit");

   A Button control is instantiated. The setText() methods sets the button's label.
btn.setOnAction((ActionEvent event) -> {
    Platform.exit();
});

   The setOnAction() method sets the button's action, which is invoked whenever the button is fired. The
   above code creates an anonymous event handler. The Platform.exit() terminates the application.
var root = new HBox();
root.setPadding(new Insets(25));

   HBox is a pane that lays out its children in a single horizontal row. The setPadding() method creates
   a padding around the content of the pane. (The default padding is Insets.EMPTY.) This way there is
   some space between the button and the edges of the window borders.
root.getChildren().add(btn);

   The button is added to the HBox pane.
   Quit button Figure: Quit button

JavaFX tooltip
   Any node can show a tooltip. Tooltip is a common UI element which is typically used for showing
   additional information about a node in the scene graph. It is shown when we hover a mouse pointer
   over a node.
   com/zetcode/TooltipEx.java

<code>
package com.zetcode;

import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class TooltipEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new HBox();
        root.setPadding(new Insets(20));

        var btn = new Button("Button");
        var tooltip = new Tooltip("Button control");
        Tooltip.install(btn, tooltip);

        root.getChildren().add(btn);

        var scene = new Scene(root, 300, 250);

        stage.setTitle("Tooltip");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
</code>

   In the example, we set a tooltip to a button control.
var btn = new Button("Button");

   A Button control is instantiated.
var tooltip = new Tooltip("Button control");
Tooltip.install(btn, tooltip);

   A Tooltip is created and set to the button with the Tooltip's install() method.
   Tooltip Figure: Tooltip

JavaFX mnemonics
   Mnemonics are shortcut keys that activate a control that supports mnemonics. For instance, they can
   be used with labels, buttons, or menu items.

   The mnemonic is created by adding the _ character to the control's label. It causes the next
   character to be the mnemonic. The character is combined with the mouseless modifier, usually Alt. The
   chosen character is underlined, but it may be emphasized in a platform specific manner. On some
   platforms, the character is only underlined after pressing the mouseless modifier.
   com/zetcode/MnemonicEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class MnemonicEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new HBox();
        root.setPadding(new Insets(20));

        var btn = new Button("_Button");
        btn.setOnAction((ActionEvent event) -> {
            System.out.println("Button fired");
        });

        root.getChildren().add(btn);

        var scene = new Scene(root, 300, 250);

        stage.setTitle("Mnemonic");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
</code>

   We set a mnemonic for a button control. It can be activated with the Alt+B keyboard shortcut.
var btn = new Button("_Button");

   In the button's label, the _ character precedes the B character; therefore, the B character is
   underlined and is included in the keyboard shortcut.
btn.setOnAction((ActionEvent event) -> {
    System.out.println("Button fired");
});

   When the button is fired, it sends a message to the console.

   At this moment, there are three ways to activate the button: a left mouse button click, the Alt+B
   shortcut, and the Space key (provided the button has the focus).

JavaFX styling a control
   Controls in JavaFX can be styled with CSS.
   src/resources/style.css
#root {-fx-background-color: linear-gradient(gray, darkgray); }
#text {-fx-fill:linear-gradient(orange, orangered); }

   This CSS file creates a style for the root node and for a Text node.
   com/zetcode/StylingTextEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.layout.HBox;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class StylingTextEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new HBox();
        root.setPadding(new Insets(20));

        var text = new Text("ZetCode");
        text.setFont(Font.font("Serif", FontWeight.BOLD, 76));

        text.setId("text");
        root.setId("root");

        root.getChildren().addAll(text);

        var scene = new Scene(root);
        // ORIGINAL - not working!
        // scene.getStylesheets().add("style.css");
        
        // works if style.scc in same dir as class file!
        
        // Solution:
        // mkdir ./resources and move style .css into it:
        scene.getStylesheets().addAll(this.getClass().getResource("/resources/style.css").toExternalForm());

        stage.setTitle("Styling text");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
</code>

   The example creates a background gradient colour for the root node and a linear gradient fill for the
   Text control.
var text = new Text("ZetCode");
text.setFont(Font.font("Serif", FontWeight.BOLD, 76));

   A Text control is created. A larger bold Serif font is set to the control.
text.setId("text");
root.setId("root");

   The nodes are identified by their IDs, which are set with the setId() method.
scene.getStylesheets().add("style.css");

   The stylesheet is added to the Scene.
   Styled Text control Figure: Styled Text control


---
http://zetcode.com/gui/javafx/layoutpanes/

JavaFX layout panes  (part 3)

   This part of the JavaFX tutorial covers layout management of nodes. We mention these layout panes:
   FlowPane, HBox, BorderPane, AnchorPane, GridPane, and MigPane. In addition, we show how to position
   nodes in absolute coordinates with the Pane.

   Layout panes are containers which are used for flexible and dynamic arrangements of UI controls
   within a scene graph of a JavaFX application. As a window is resized, the layout pane automatically
   repositions and resizes the nodes it contains.

   JavaFX has the following built-in layout panes:
     * FlowPane - lays out its children in a flow that wraps at the flowpane's boundary.
     * HBox - arranges its content nodes horizontally in a single row.
     * VBox - arranges its content nodes vertically in a single column.
     * AnchorPane - anchor nodes to the top, bottom, left side, or center of the pane.
     * BorderPane - lays out its content nodes in the top, bottom, right, left, or center region.
     * StackPane - places its content nodes in a back-to-front single stack.
     * TilePane - places its content nodes in uniformly sized layout cells or tiles.
     * GridPane - places its content nodes in a grid of rows and columns.

   To create a more complex layout, it is possible to nest different containers within a JavaFX
   application. Except for the GridPane, built-in layout managers are very basic and are not suited for
   more complex applications. More complicated layouts should use either the GridPane or the third-party
   MigPane.

Absolute layout
   The Pane node can be used to position nodes in absolute coordinates. Complex layouts should be always
   created using layout managers; absolute layout is used in specific situations (for instance,
   positioning charts or images).
   AbsoluteLayoutEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;

/**
 * ZetCode JavaFX tutorial
 *
 * This program positions three shapes
 * using absolute coordinates.
 *
 * Author: Jan Bodnar
 * Website: zetcode.com
 * Last modified: June 2015
 */

public class AbsoluteLayoutEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        Pane root = new Pane();

        Rectangle rect = new Rectangle(25, 25, 50, 50);
        rect.setFill(Color.CADETBLUE);

        Line line = new Line(90, 40, 230, 40);
        line.setStroke(Color.BLACK);

        Circle circle = new Circle(130, 130, 30);
        circle.setFill(Color.CHOCOLATE);

        root.getChildren().addAll(rect, line, circle);

        Scene scene = new Scene(root, 250, 220, Color.WHITESMOKE);

        stage.setTitle("Absolute layout");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
</code>

   This examples shows three shapes: a rectangle, a line, and a circle. The shapes are positioned using
   absolute coordinates.
Pane root = new Pane();

   A Pane node is instantiated. To position nodes in absolute coordinates, we use the Pane node.
Rectangle rect = new Rectangle(25, 25, 50, 50);

   A Rectangle shape is created. The first two parameters are the x and y coordinates, the following two
   are the width and height of the rectangle. The top-left rectangle starts at x=25 and y=25 of its
   parent node.
Line line = new Line(90, 40, 230, 40);
line.setStroke(Color.BLACK);

Circle circle = new Circle(130, 130, 30);
circle.setFill(Color.CHOCOLATE);

   The Line and Circle shapes take absolute coordinate values in their constructors. The colour of the
   line is changed with the setStroke() method, and the colour of the circle interior is changed with
   the setFill() method.
root.getChildren().addAll(rect, line, circle);

   All the three shapes are added to the root node.
   Absolute positioning Figure: Absolute positioning

FlowPane
   FlowPane positions nodes in a row or a column, where the nodes are wrapped when they all cannot be
   shown. The default orientation of a flow pane is horizontal. FlowPane has a very limited usage.
   FlowPaneEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.geometry.Orientation;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.FlowPane;
import javafx.stage.Stage;

/**
 * ZetCode JavaFX tutorial
 *
 * This program uses a FlowPane to position
 * twenty buttons.
 *
 * Author: Jan Bodnar
 * Website: zetcode.com
 * Last modified: June 2015
 */

public class FlowPaneEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        FlowPane root = new FlowPane(Orientation.HORIZONTAL, 5, 5);
        root.setPadding(new Insets(5));

        for (int i=1; i<=20; i++) {
            root.getChildren().add(new Button(String.valueOf(i)));
        }

        Scene scene = new Scene(root, 300, 250);

        stage.setTitle("FlowPane");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   In the example, we place twenty buttons in the FlowPane. The buttons are wrapped into other row(s) if
   they cannot be shown all in a single row.
FlowPane root = new FlowPane(Orientation.HORIZONTAL, 5, 5);

   A horizontal FlowPane is created. The second and third parameters specify the horizontal and the
   vertical gap between nodes in the pane.
root.setPadding(new Insets(5));

   The setPadding() method sets some space around the pane.
for (int i=1; i<=20; i++) {
    root.getChildren().add(new Button(String.valueOf(i)));
}

   Twenty buttons are added to the flow pane. The buttons show integer values.
   FlowPane Figure: FlowPane

HBox
   HBox lays out its children in a single horizontal row. This pane is used in cooperation with other
   layout managers to create layouts. It is suited for doing basic layouts.
   RowOfButtonsEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

/**
 * ZetCode JavaFX tutorial
 *
 * This program shows four buttons in
 * a right-aligned, horizontal row with a HBox.
 *
 * Author: Jan Bodnar
 * Website: zetcode.com
 * Last modified: June 2015
 */

public class RowOfButtonsEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        HBox root = new HBox(5);
        root.setPadding(new Insets(10));
        root.setAlignment(Pos.BASELINE_RIGHT);

        Button prevBtn = new Button("Previous");
        Button nextBtn = new Button("Next");
        Button cancBtn = new Button("Cancel");
        Button helpBtn = new Button("Help");

        root.getChildren().addAll(prevBtn, nextBtn, cancBtn, helpBtn);

        Scene scene = new Scene(root);
        stage.setTitle("Row of buttons");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example shows four buttons in a single row. The row is right-aligned. There is some space between
   the buttons.
HBox root = new HBox(5);

   A HBox pane is created with some spacing.
root.setPadding(new Insets(10));

   We create some padding around the HBox
root.setAlignment(Pos.BASELINE_RIGHT);

   The setAlignment() method alignes the nodes to the right.
root.getChildren().addAll(prevBtn, nextBtn, cancBtn, helpBtn);

   The buttons are added to the container.
   A row of buttons created with a HBox Figure: A row of buttons created with a HBox

BorderPane
   BorderPane lays out children in top, left, right, bottom, and center positions. It can be used to
   create the classic looking application layouts.
   BorderPaneEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.layout.BorderPane;
import javafx.stage.Stage;

/**
 * ZetCode JavaFX tutorial
 *
 * This program places five labels into
 * the BorderPane's five areas.
 *
 * Author: Jan Bodnar
 * Website: zetcode.com
 * Last modified: June 2015
 */

class MyLabel extends Label {

    public MyLabel(String text) {
        super(text);

        setAlignment(Pos.BASELINE_CENTER);
    }
}

public class BorderPaneEx extends Application {

    private BorderPane root;
    private final int SIZE = 60;

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        root = new BorderPane();

        root.setTop(getTopLabel());
        root.setBottom(getBottomLabel());
        root.setLeft(getLeftLabel());
        root.setRight(getRightLabel());
        root.setCenter(getCenterLabel());

        Scene scene = new Scene(root, 350, 300);

        stage.setTitle("BorderPane");
        stage.setScene(scene);
        stage.show();
    }

    private Label getTopLabel() {

        Label lbl = new MyLabel("Top");
        lbl.setPrefHeight(SIZE);
        lbl.prefWidthProperty().bind(root.widthProperty());
        lbl.setStyle("-fx-border-style: dotted; -fx-border-width: 0 0 1 0;"
                + "-fx-border-color: gray; -fx-font-weight: bold");

        return lbl;
    }

    private Label getBottomLabel() {

        Label lbl = new MyLabel("Bottom");
        lbl.setPrefHeight(SIZE);
        lbl.prefWidthProperty().bind(root.widthProperty());
        lbl.setStyle("-fx-border-style: dotted; -fx-border-width: 1 0 0 0;"
                + "-fx-border-color: gray; -fx-font-weight: bold");

        return lbl;
    }

    private Label getLeftLabel() {

        Label lbl = new MyLabel("Left");
        lbl.setPrefWidth(SIZE);
        lbl.prefHeightProperty().bind(root.heightProperty().subtract(2*SIZE));
        lbl.setStyle("-fx-border-style: dotted; -fx-border-width: 0 1 0 0;"
                + "-fx-border-color: gray; -fx-font-weight: bold");

        return lbl;
    }


    private Label getRightLabel() {

        Label lbl = new MyLabel("Right");
        lbl.setPrefWidth(SIZE);
        lbl.prefHeightProperty().bind(root.heightProperty().subtract(2*SIZE));
        lbl.setStyle("-fx-border-style: dotted; -fx-border-width: 0 0 0 1;"
                + "-fx-border-color: gray; -fx-font-weight: bold");

        return lbl;
    }

    private Label getCenterLabel() {

        Label lbl = new MyLabel("Center");
        lbl.setStyle("-fx-font-weight: bold");
        lbl.prefHeightProperty().bind(root.heightProperty().subtract(2*SIZE));
        lbl.prefWidthProperty().bind(root.widthProperty().subtract(2*SIZE));

        return lbl;
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example places five labels into five BorderPane's areas.
root.setTop(getTopLabel());
root.setBottom(getBottomLabel());
root.setLeft(getLeftLabel());
root.setRight(getRightLabel());
root.setCenter(getCenterLabel());

   The nodes are positioned using the setTop(), setBottom(), setLeft(), setRight(), and setCenter()
   methods.
Label lbl = new MyLabel("Top");
lbl.setPrefHeight(SIZE);

   Here we increase the preferred height of the top label with the setPrefHeight() method. The preferred
   height is the height in which the label is initially shown.
lbl.prefWidthProperty().bind(root.widthProperty());

   BorderPane honours the preferred size of its children. In case of a label, it is a size big enough to
   show its text. We bind the preferred width property of the label to the corresponding property of the
   pane. This way the label is enlarged from the left to the right of the pane.
lbl.setStyle("-fx-border-style: dotted; -fx-border-width: 0 0 1 0;"
        + "-fx-border-color: gray; -fx-font-weight: bold");

   We change the style of the label in order to see its boundaries clearly.
   BorderPane Figure: BorderPane

AnchorPane
   AnchorPane anchors the edges of child nodes to an offset from the anchor pane's edges. If the anchor
   pane has a border or padding set, the offsets will be measured from the inside edge of those insets.
   AnchorPane is a simple layout pane which must be used with other layout panes to create meaningful
   layouts.
   CornerButtonsEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

/**
 * ZetCode JavaFX tutorial
 *
 * This program shows two buttons in the
 * bottom-right corner of the window. It uses
 * an AnchorPane and an HBox.
 *
 * Author: Jan Bodnar
 * Website: zetcode.com
 * Last modified: June 2015
 */

public class CornerButtonsEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        AnchorPane root = new AnchorPane();

        Button okBtn = new Button("OK");
        Button closeBtn = new Button("Close");
        HBox hbox = new HBox(5, okBtn, closeBtn);

        root.getChildren().addAll(hbox);

        AnchorPane.setRightAnchor(hbox, 10d);
        AnchorPane.setBottomAnchor(hbox, 10d);

        Scene scene = new Scene(root, 300, 200);

        stage.setTitle("Corner buttons");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example uses an AnchorPane and a HBox to position two buttons into the bottom-right corner of the
   window.
AnchorPane root = new AnchorPane();

   The AnchorPane is the root node of the scene graph.
Button okBtn = new Button("OK");
Button closeBtn = new Button("Close");
HBox hbox = new HBox(5, okBtn, closeBtn);

   The two buttons are placed in a HBox. We use a constructor where we directly put the button objects.
root.getChildren().addAll(hbox);

   The hbox is added to the anchor pane.
AnchorPane.setRightAnchor(hbox, 10d);

   The setRightAnchor() method anchors the hbox to the right edge of the pane. The second parameters
   gives some offset from the edge.
AnchorPane.setBottomAnchor(hbox, 10d);

   The setBottomAnchor() method anchors the hbox to the bottom edge of the pane.
   Corner buttons Figure: Corner buttons

GridPane
   GridPane places its nodes into a grid of rows and columns. Nodes may span multiple rows or columns.
   GridPane is the most flexible built-in layout pane.

   The setGridLinesVisible() enables to show the lines of the layout grid, which allows us to visually
   debug the layout.
   NewFolderEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ListView;
import javafx.scene.control.TextField;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.RowConstraints;
import javafx.stage.Stage;

/**
 * ZetCode JavaFX tutorial
 *
 * This program creates a NewFolder layout with
 * a GridPane.
 *
 * Author: Jan Bodnar
 * Website: zetcode.com
 * Last modified: June 2015
 */

public class NewFolderEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        GridPane root = new GridPane();
        root.setHgap(8);
        root.setVgap(8);
        root.setPadding(new Insets(5));

        ColumnConstraints cons1 = new ColumnConstraints();
        cons1.setHgrow(Priority.NEVER);
        root.getColumnConstraints().add(cons1);

        ColumnConstraints cons2 = new ColumnConstraints();
        cons2.setHgrow(Priority.ALWAYS);

        root.getColumnConstraints().addAll(cons1, cons2);

        RowConstraints rcons1 = new RowConstraints();
        rcons1.setVgrow(Priority.NEVER);

        RowConstraints rcons2 = new RowConstraints();
        rcons2.setVgrow(Priority.ALWAYS);

        root.getRowConstraints().addAll(rcons1, rcons2);

        Label lbl = new Label("Name:");
        TextField field = new TextField();
        ListView view = new ListView();
        Button okBtn = new Button("OK");
        Button closeBtn = new Button("Close");

        GridPane.setHalignment(okBtn, HPos.RIGHT);

        root.add(lbl, 0, 0);
        root.add(field, 1, 0, 3, 1);
        root.add(view, 0, 1, 4, 2);
        root.add(okBtn, 2, 3);
        root.add(closeBtn, 3, 3);

        Scene scene = new Scene(root, 280, 300);

        stage.setTitle("New folder");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The layout of this example consists of a label, text field, list view, and two buttons.
GridPane root = new GridPane();

   An instance of the GridPane is created.
root.setHgap(8);
root.setVgap(8);

   These two methods create horizontal and vertical gaps between the nodes.
ColumnConstraints cons1 = new ColumnConstraints();
cons1.setHgrow(Priority.NEVER);
root.getColumnConstraints().add(cons1);

ColumnConstraints cons2 = new ColumnConstraints();
cons2.setHgrow(Priority.ALWAYS);

root.getColumnConstraints().addAll(cons1, cons2);

   In the layout, we need to make the second column growable. By default, the grid pane shows its
   children in their preferred sizes and does not enlarge them when the window is enlarged. We create
   column constraints, where we set the horizontal grow priority to Priority.ALWAYS for the second
   column. (There is not a specific method to do this.) In the end, this makes the text field and the
   list view controls grow in the horizontal direction as the window is enlarged.
RowConstraints rcons1 = new RowConstraints();
rcons1.setVgrow(Priority.NEVER);

RowConstraints rcons2 = new RowConstraints();
rcons2.setVgrow(Priority.ALWAYS);

root.getRowConstraints().addAll(rcons1, rcons2);

   In a similar fashion, we make the second row growable. By making the second column and row growable,
   the list view grows in both directions, taking the bulk of the client area.
Label lbl = new Label("Name:");
TextField field = new TextField();
ListView view = new ListView();
Button okBtn = new Button("OK");
Button closeBtn = new Button("Close");

   The five controls are created.
GridPane.setHalignment(okBtn, HPos.RIGHT);

   The setHalignment() method makes the okBtn right-aligned.
root.add(lbl, 0, 0);

   The label control is added to the grid. The first two parameters of the add() method are the column
   and the row index. The indexes start from zero.
root.add(field, 1, 0, 3, 1);

   The overloaded add() method specifies also the column and row span. The text field goes to the second
   column and first row. It spans three columns and one row.
   New folder Figure: New folder

MigPane
   MigPane is a very powerful third-party layout manager. It uses the MigLayout manager, which is
   available for Swing, SWT, and JavaFX. It is highly recommended to consider this manager.
   MigPane JARs Figure: MigPane JARs

   To use the MigPane, it is necessary to include the JARs to the project libraries. The JARs for
   sources and javadoc are optional.

   MigPane uses string constraints to do the layout. There are four kinds of constraints: general
   constraints, column constraints, row constraints, and control constrains. There are several layout
   modes in MigPane. The grid mode is the default one and is the most flexible of the available modes.
   MigLayoutWindowsEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Control;
import javafx.scene.control.Label;
import javafx.scene.control.ListView;
import javafx.stage.Stage;
import org.tbee.javafx.scene.layout.MigPane;

/**
 * ZetCode JavaFX tutorial
 *
 * This program creates a Windows layout with
 * a MigPane.
 *
 * Author: Jan Bodnar
 * Website: zetcode.com
 * Last modified: June 2015
 */

public class MigLayoutWindowsEx extends Application {

    MigPane root;

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        root = new MigPane("", "[grow][]", "[][][grow][]");
        Scene scene = new Scene(root);

        Label lbl = new Label("Windows");
        Button actBtn = new Button("Activate");
        Button closeBtn = new Button("Close");
        Button okBtn = new Button("OK");
        Button helpBtn = new Button("Help");
        ListView listView = new ListView();

        createLayout(lbl, listView, actBtn, closeBtn, helpBtn, okBtn);

        stage.setTitle("Windows");
        stage.setScene(scene);
        stage.show();
    }

    private void createLayout(Control...arg) {

        root.add(arg[0], "wrap");
        root.add(arg[1], "w 200, h 200, span 2 2, grow");
        root.add(arg[2], "wrap");
        root.add(arg[3], "top, wrap");
        root.add(arg[4]);
        root.add(arg[5], "skip");
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example uses six controls, four buttons, a label, and a list view.
root = new MigPane("", "[grow][]", "[][][grow][]");

   The three strings of the MigPane constructor specify the general, column, and row constraints. The
   [grow][] constraint specifies that there are two columns and the first one is growable. Likewise, the
   [][][grow][] constraint tells the MigPane that there are four rows and the third one is growable. If
   we put the debug constraint into the general constraints, we can visually debug the layout.
createLayout(lbl, listView, actBtn, closeBtn, helpBtn, okBtn);

   The creation of the layout is delegated to the createLayout() method.
root.add(arg[0], "wrap");

   The label control goes into the first row and first column. It is possible (but not necessary) to
   explicitly specify the cell indexes. The wrap constraint starts a new row.
root.add(arg[1], "w 200, h 200, span 2 2, grow");

   The w and h constrains specify the initial width and height of the list view control. It is a best
   practice that only the layout manager sets the size of its components. In other words, calling
   methods line setMinSize() directly on controls is a poor practice. The span constraint makes the
   control span two columns and two rows. Finally, the grow constraint makes the control grow in both
   directions when the window is resized.
root.add(arg[2], "wrap");

   The third control is the Activate button. It goes next to the list view. After placing this control,
   we start a new row.
root.add(arg[3], "top, wrap");

   The Close button goes next to the list view and below the Activate button. The top constraint aligns
   the button to the top of its cell.
root.add(arg[4]);

   We made the list view span two rows. After placing the previous buttons into two separate rows, the
   next button goes automatically below the list view.
root.add(arg[5], "skip");

   The last button skips one column. So it is placed in the third column and fourth row.
   Windows layout created with a MigPane Figure: Windows layout created with a MigPane


---
http://zetcode.com/gui/javafx/controls/

Basic JavaFX controls (part 4)

   Controls are basic building blocks of an application. A Control is a node in the scene graph which
   can be manipulated by a user. It supports common user interactions in a manner which is consistent
   and predictable for the user. JavaFX has a wide range of built-in controls. In this chapter, we cover
   five controls: Label, CheckBox, ChoiceBox, Slider, and ProgressBar. The ImageView and TextField
   controls are briefly mentioned too.

JavaFX Label
   Label is a non-editable text control. A label may use an ellipsis or truncation to size the string to
   fit.
   com/zetcode/LabelEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class LabelEx extends Application {

    String lyrics = "It's way too late to think of\n"
            + "Someone I would call now\n"
            + "And neon signs got tired\n"
            + "Red eye flights help the stars out\n"
            + "I'm safe in a corner\n"
            + "Just hours before me\n"
            + "\n"
            + "I'm waking with the roaches\n"
            + "The world has surrendered\n"
            + "I'm dating ancient ghosts\n"
            + "The ones I made friends with\n"
            + "The comfort of fireflies\n"
            + "Long gone before daylight\n"
            + "\n"
            + "And if I had one wishful field tonight\n"
            + "I'd ask for the sun to never rise\n"
            + "If God leant his voice for me to speak\n"
            + "I'd say go to bed, world\n"
            + "\n"
            + "I've always been too late\n"
            + "To see what's before me\n"
            + "And I know nothing sweeter than\n"
            + "Champaign from last New Years\n"
            + "Sweet music in my ears\n"
            + "And a night full of no fears\n"
            + "\n"
            + "But if I had one wishful field tonight\n"
            + "I'd ask for the sun to never rise\n"
            + "If God passed a mic to me to speak\n"
            + "I'd say stay in bed, world\n"
            + "Sleep in peace";

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new HBox();
        root.setPadding(new Insets(10));

        var lbl = new Label(lyrics);
        root.getChildren().add(lbl);

        var scene = new Scene(root);

        stage.setTitle("No sleep");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example shows lyrics of a song from Cardigans.
String lyrics = "It's way too late to think of\n"
        + "Someone I would call now\n"
        + "And neon signs got tired\n"
        + "Red eye flights help the stars out\n"
...

   The string consists of multiple lines of text.
var root = new HBox();
root.setPadding(new Insets(10));

   The label control is placed into a HBox. We put some padding around the box.
var lbl = new Label(lyrics);

   A Label control is created. It takes the string as its sole parameter.
root.getChildren().add(lbl);

   The label is added to the container.

The labelFor property
   The labelFor property specifies a node to which keyboard focus is sent if a mnemonic is pressed.
   com/zetcode/LabelForEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;

public class LabelForEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new GridPane();
        root.setVgap(10);
        root.setHgap(5);
        root.setPadding(new Insets(10));

        var lbl1 = new Label("_Name:");
        var lbl2 = new Label("_Address:");
        var lbl3 = new Label("_Occupation:");

        var field1 = new TextField();
        var field2 = new TextField();
        var field3 = new TextField();

        lbl1.setLabelFor(field1);
        lbl1.setMnemonicParsing(true);
        lbl2.setLabelFor(field2);
        lbl2.setMnemonicParsing(true);
        lbl3.setLabelFor(field3);
        lbl3.setMnemonicParsing(true);

        root.add(lbl1, 0, 0);
        root.add(field1, 2, 0);
        root.add(lbl2, 0, 1);
        root.add(field2, 2, 1);
        root.add(lbl3, 0, 2);
        root.add(field3, 2, 2);

        GridPane.setHalignment(lbl1, HPos.RIGHT);
        GridPane.setHalignment(lbl2, HPos.RIGHT);
        GridPane.setHalignment(lbl3, HPos.RIGHT);

        var scene = new Scene(root);

        stage.setTitle("TextField");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {

        launch(args);
    }
}

</code>

   The example uses the labelFor property and a mnemonic to transfer focus to the specified text field.
var root = new GridPane();
root.setVgap(10);
root.setHgap(5);
root.setPadding(new Insets(10));

   Our application is a typical form-based program. The GridPane is well suited for this. We set some
   space around the controls and between them.
var lbl1 = new Label("_Name:");
var lbl2 = new Label("_Address:");
var lbl3 = new Label("_Occupation:");

   Three Labels are created. The underscore character precedes the mnemonic key.
var field1 = new TextField();
var field2 = new TextField();
var field3 = new TextField();

   TextField is a control for editing single line of unformatted text. Each text field is placed next to
   one label control.
lbl1.setLabelFor(field1);

   The setLabelFor() sets a target node to which the focus is transferred when the mnemonic is pressed.
lbl1.setMnemonicParsing(true);

   Mnemonics are not set for labels by default. We must enable them with the setMnemonicParsing()
   method.
   The labelFor property Figure: The labelFor property

   Under some platforms, it is neccesary to press the mouseless modifier (usually Alt) for the
   underlines to be shown. In the figure, the focus was transferred to the middle text field by pressing
   Alt+A.

JavaFX CheckBox
   CheckBox is a tri-state selection control box showing a checkmark or tick mark when checked. The
   control has two states by default: checked and unchecked. The setAllowIndeterminate() enables the
   third state: indeterminate.
   com/zetcode/CheckBoxEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.CheckBox;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class CheckBoxEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new HBox();
        root.setPadding(new Insets(10, 0, 0, 10));

        var cbox = new CheckBox("Show title");
        cbox.setSelected(true);

        cbox.setOnAction((ActionEvent event) -> {
            if (cbox.isSelected()) {
                stage.setTitle("CheckBox");
            } else {
                stage.setTitle("");
            }
        });

        root.getChildren().add(cbox);

        var scene = new Scene(root, 300, 200);

        stage.setTitle("CheckBox");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example shows or hides the title of the window depending whether the check box is selected.
var cbox = new CheckBox("Show title");

   A CheckBox control is created. The specified text is its label.
cbox.setSelected(true);

   Since the title of the window is visible by default, we check the control with the setSelected()
   method.
cbox.setOnAction((ActionEvent event) -> {
    if (cbox.isSelected()) {
        stage.setTitle("CheckBox");
    } else {
        stage.setTitle("");
    }
});

   With the setOnAction() method, we set the check box's action, which is invoked when the check box is
   fired. We determine its state with the isSelected() method. Depending on the current state, we show
   or hide the window title with the setTitle() method.
   CheckBox Figure: CheckBox

   Note the blue rectangle around the text of the check box. It indicates that this control has keyboard
   focus. It is possible to select and deselect the check box with the Space key.

JavaFX Slider
   Slider is a control that lets the user graphically select a value by sliding a knob within a bounded
   interval. The slider can optionally show tick marks and labels indicating different slider position
   values.
   com/zetcode/SliderEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Slider;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class SliderEx extends Application {

    private ImageView iview;
    private Image muteImg;
    private Image minImg;
    private Image maxImg;
    private Image medImg;

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new HBox(10);
        root.setAlignment(Pos.CENTER);
        root.setPadding(new Insets(15));

        loadImages();

        iview = new ImageView(muteImg);

        var slider = new Slider(0, 100, 0);
        slider.valueProperty().addListener(new MyChangeListener());

        var scene = new Scene(root);

        root.getChildren().addAll(slider, iview);

        stage.setTitle("Slider");
        stage.setScene(scene);
        stage.show();
    }

    private void loadImages() {

        muteImg = new Image("file:mute.png");
        minImg = new Image("file:min.png");
        maxImg = new Image("file:max.png");
        medImg = new Image("file:med.png");
    }

    private class MyChangeListener implements ChangeListener<Number> {

        @Override
        public void changed(ObservableValue<? extends Number> observable,
                Number oldValue, Number newValue) {

            double value = newValue.doubleValue();

            if (value == 0) {
                iview.setImage(muteImg);
            } else if (value > 0 && value <= 30) {
                iview.setImage(minImg);
            } else if (value > 30 && value < 80) {
                iview.setImage(medImg);
            } else {
                iview.setImage(maxImg);
            }
        }
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   In the code example, we show a Slider and an ImageView control. By dragging the knob of the slider,
   we change the image on the label control.
root.setAlignment(Pos.CENTER);

   The slider and the image view are centered in the row.
iview = new ImageView(muteImg);

   ImageView displays images loaded with the Image class.
var slider = new Slider(0, 100, 0);

   A Slider control is created with the specified minimum, maximum, and current values.
slider.valueProperty().addListener(new MyChangeListener());

   A listener is added to the value changes of the slider.
double value = newValue.doubleValue();

if (value == 0) {
    iview.setImage(muteImg);
} else if (value > 0 && value <= 30) {
    iview.setImage(minImg);
} else if (value > 30 && value < 80) {
    iview.setImage(medImg);
} else {
    iview.setImage(maxImg);
}

   Based on the current value of the slider, we set an appropriate image to the image view.
private void loadImages() {

    muteImg = new Image("file:mute.png");
    minImg = new Image("file:min.png");
    maxImg = new Image("file:max.png");
    medImg = new Image("file:med.png");
}

   The loadImages() method loads images from the disk.
   Slider Figure: Slider

JavaFX ChoiceBox
   ChoiceBox is used for presenting the user with a small set of predefined choices. When the user
   clicks on the box, a list of choices is shown. Only one option can be selected at a time. When this
   list is not showing, the currently selected choice is shown. ChoiceBox item selection is handled by a
   SelectionModel.
   com/zetcode/ChoiceBoxEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.collections.FXCollections;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.ChoiceBox;
import javafx.scene.control.Label;
import javafx.scene.control.SingleSelectionModel;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class ChoiceBoxEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new VBox(35);
        root.setPadding(new Insets(10));

        var lbl = new Label();

        var chbox = new ChoiceBox<>(FXCollections.observableArrayList(
                "Ubuntu", "Redhat", "Arch", "Debian", "Mint"));

        SingleSelectionModel<String> model = chbox.getSelectionModel();
        model.selectedItemProperty().addListener((observableValue, s, t1) -> lbl.setText(t1));

        root.getChildren().addAll(chbox, lbl);

        var scene = new Scene(root, 300, 250);

        stage.setTitle("ChoiceBox");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   In our example, we have a choice box and a label. The choice box contains a list of strings denoting
   names of Linux distributions. The selected item from the choice box is displayed in the label.
var lbl = new Label();

   This Label shows the currently selected item from the choice box.
var chbox = new ChoiceBox<>(FXCollections.observableArrayList(
        "Ubuntu", "Redhat", "Arch", "Debian", "Mint"));

   A ChoiceBox is created. It takes an observable array list as a parameter.
SingleSelectionModel<String> model = chbox.getSelectionModel();
model.selectedItemProperty().addListener((observableValue, s, t1) -> lbl.setText(t1));

   To implement a listener, we need to get the selection model with the getSelectionModel() method. The
   model contains the observable selectedItem property. Inside the handler method, we get the selected
   value and set it to the label.
   ChoiceBox Figure: ChoiceBox

JavaFX ProgressBar
   ProgressBar is a control that indicates the processing of a particular task with a completion bar.
   com/zetcode/ProgressBarEx.java

<code>
// package com.zetcode;

import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ProgressBar;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;
import javafx.util.Duration;

public class ProgressBarEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new HBox(15);
        root.setAlignment(Pos.CENTER);
        root.setPadding(new Insets(10));

        var pbar = new ProgressBar(0);
        pbar.setPrefWidth(150);

        var frame1 = new KeyFrame(Duration.ZERO,
                new KeyValue(pbar.progressProperty(), 0));

        var frame2 = new KeyFrame(Duration.seconds(3),
                new KeyValue(pbar.progressProperty(), 1));

        var task = new Timeline(frame1, frame2);

        var btn = new Button("Start");
        btn.setOnAction((ActionEvent actionEvent) -> task.playFromStart());

        root.getChildren().addAll(pbar, btn);

        var scene = new Scene(root);

        stage.setTitle("ProgressBar");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example consists of a progress bar and a button. The button starts the progressbar that is
   animated for a few seconds.
var pbar = new ProgressBar(0);

   The constructor creates a new ProgressBar with the given progress value.
var frame1 = new KeyFrame(Duration.ZERO,
        new KeyValue(pbar.progressProperty(), 0));

var frame2 = new KeyFrame(Duration.seconds(3),
        new KeyValue(pbar.progressProperty(), 1));

var task = new Timeline(frame1, frame2);

   This code creates a simple animation task. The animation consists of two frames. The animated
   properties are defined as KeyValues.
var btn = new Button("Start");
btn.setOnAction((ActionEvent actionEvent) -> task.playFromStart());

   When fired, the button invokes the playFromStart() method, which plays the animation from initial
   position in forward direction.
   ProgressBar Figure: ProgressBar


---
http://zetcode.com/gui/javafx/controlsII/

Basic JavaFX controls II (part 5)

   In this chapter, we continue covering basic JavaFX controls. We present a DatePicker, a MenuBar, a
   ColorPicker, a RadioButton, and a TabPane control.

JavaFX DatePicker
   DatePicker is a control for choosing a date.
   com/zetcode/DatePickerEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.DatePicker;
import javafx.scene.control.Label;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class DatePickerEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new VBox(15);
        root.setPadding(new Insets(10));

        var lbl = new Label("...");

        var datePicker = new DatePicker();

        datePicker.setOnAction(e -> {

            var date = datePicker.getValue();
            lbl.setText(date.toString());
        });

        root.getChildren().addAll(datePicker, lbl);

        var scene = new Scene(root, 350, 200);

        stage.setTitle("Date picker");
        stage.setScene(scene);
        stage.show();
    }


    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example uses a DatePicker control to select and display a date. The date is shown in a label
   control.
var datePicker = new DatePicker();

   The instance of a DatePicker control is created.
datePicker.setOnAction(e -> {

    var date = datePicker.getValue();
    lbl.setText(date.toString());
});

   The getValue() method returns the selected date as a LocalDate. The chosen date is set to the label
   control with its setText() method.
   DatePicker Figure: DatePicker

JavaFX MenuBar
   MenuBar consists of Menu objects, which hold MenuItem objects - the commands of the application. It
   is traditionally placed at the top of the application window.
   com/zetcode/MenuBarEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuBar;
import javafx.scene.control.MenuItem;
import javafx.scene.control.SeparatorMenuItem;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class MenuBarEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new HBox();

        var mbar = new MenuBar();
        mbar.prefWidthProperty().bind(stage.widthProperty());

        var handler = new MyMenuHandler();

        var fileMenu = new Menu("File");
        mbar.getMenus().add(fileMenu);

        var nmi = new MenuItem("New");
        nmi.setOnAction(handler);
        fileMenu.getItems().add(nmi);

        var omi = new MenuItem("Open");
        omi.setOnAction(handler);
        fileMenu.getItems().add(omi);

        var smi = new MenuItem("Save");
        smi.setOnAction(handler);
        fileMenu.getItems().add(smi);

        fileMenu.getItems().add(new SeparatorMenuItem());

        var emi = new MenuItem("Exit");
        emi.setOnAction((ActionEvent event) -> Platform.exit());

        fileMenu.getItems().add(emi);

        root.getChildren().add(mbar);

        var scene = new Scene(root, 300, 250);

        stage.setTitle("MenuBar");
        stage.setScene(scene);
        stage.show();
    }

    // ORIGINAL is wrong!
    // private class MyMenuHandler implements EventHandler {
    private class MyMenuHandler implements EventHandler<ActionEvent> {

        // @Override
        public void handle(ActionEvent event) {

            doShowMessageDialog(event);
        }

        private void doShowMessageDialog(ActionEvent event) {

            var mi = (MenuItem) event.getSource();
            String item = mi.getText();

            var alert = new Alert(AlertType.INFORMATION);
            alert.setTitle("Information dialog");
            alert.setHeaderText("Menu item selection information");
            alert.setContentText(item + " menu item selected");

            alert.showAndWait();
        }
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example contains one menu in the menubar. The menu holds four menu items and one separator.
var mbar = new MenuBar();
mbar.prefWidthProperty().bind(stage.widthProperty());

   MenuBar control is created. Inside a horizontal box, it is large enough to show its single menu. By
   binding it to the stage's widthProperty, the menubar is stretched from left to right.
var handler = new MyMenuHandler();

   A menu handler is created. It is shared by three menu items.
var fileMenu = new Menu("File");
mbar.getMenus().add(fileMenu);

   The File Menu is created and added to the menubar.
var nmi = new MenuItem("New");
nmi.setOnAction(handler);
fileMenu.getItems().add(nmi);

   The New MenuItem is created and added to the File menu. The handler to the menu item is set with the
   setOnAction() method.
fileMenu.getItems().add(new SeparatorMenuItem());

   SeparatorMenuItem is a horizontal separator which is used to visually separate related menu items.
emi.setOnAction((ActionEvent event) -> Platform.exit());

   The Exit menu item terminates the application with the Platform.exit() method call.
private class MyMenuHandler implements EventHandler<ActionEvent> {

    @Override
    public void handle(ActionEvent event) {

        doShowMessageDialog(event);
    }
...
}

   The EventHandler's handle() method is invoked when the menu item with this handler is selected. The
   method invokes the doShowMessageDialog() method, which shows a message dialog.
private void doShowMessageDialog(ActionEvent event) {

    var mi = (MenuItem) event.getSource();
    String item = mi.getText();

    var alert = new Alert(AlertType.INFORMATION);
    alert.setTitle("Information dialog");
    alert.setHeaderText("Menu item selection information");
    alert.setContentText(item + " menu item selected");

    alert.showAndWait();
}

   The doShowMessageDialog() method creates an information dialog with the Alert control. From the event
   source we determine the name of the menu item, which is used to create the content text.
   MenuBar Figure: MenuBar

JavaFX ColorPicker
   ColorPicker is a built-in dialog for choosing a colour value. It allows the user to select a colour
   from either a standard palette of colours or to define a custom colour.
   com/zetcode/ColorPickerEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.ColorPicker;
import javafx.scene.layout.HBox;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class ColorPickerEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new HBox(25);
        root.setAlignment(Pos.BASELINE_CENTER);
        root.setPadding(new Insets(10));

        var txt = new Text("ZetCode");

        var font = Font.font(20);
        txt.setFont(font);

        var cp = new ColorPicker();
        cp.setOnAction((ActionEvent event) -> txt.setFill(cp.getValue()));

        root.getChildren().addAll(cp, txt);

        var scene = new Scene(root, 300, 250);

        stage.setTitle("ColorPicker");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   In the example, we have a ColorPicker and a Text control. The selected colour from the colour picker
   is used to set the foreground colour of the text control.
var txt = new Text("ZetCode");

var font = Font.font(20);
txt.setFont(font);

   A Text control is created. We enlarge its font for better visibility.
var cp = new ColorPicker();
cp.setOnAction((ActionEvent event) -> txt.setFill(cp.getValue()));

   A ColorPicker is created and an event handler is set. The currently selected colour is retrieved with
   the ColorPicker's getValue() method. The foreground colour of the text control is changed using the
   setFill() method.
   ColorPicker Figure: ColorPicker

JavaFX RadioButton
   RadioButton is usually used to create mutually exclusive series of items. Only one RadioButton can be
   selected when placed in a ToggleGroup. When a RadioButton is selected an ActionEvent is sent.
   com/zetcode/RadioButtonEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.RadioButton;
import javafx.scene.control.Toggle;
import javafx.scene.control.ToggleGroup;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class RadioButtonEx extends Application {

    private final double BORDER = 10d;
    private Label lbl2;

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new AnchorPane();

        var vbox = new VBox(10);
        vbox.setPadding(new Insets(10));

        var lbl1 = new Label("Difficulty");

        lbl2 = new Label("");
        lbl2.setStyle("-fx-background-color:wheat; -fx-padding: 0 0 0 5");
        lbl2.prefWidthProperty().bind(stage.widthProperty().subtract(2 * BORDER));

        var tg = new ToggleGroup();
        tg.selectedToggleProperty().addListener(new MyToggleListener());

        var rb1 = new RadioButton("Easy");
        rb1.setToggleGroup(tg);
        rb1.setSelected(true);

        var rb2 = new RadioButton("Medium");
        rb2.setToggleGroup(tg);

        var rb3 = new RadioButton("Hard");
        rb3.setToggleGroup(tg);

        vbox.getChildren().addAll(lbl1, rb1, rb2, rb3);
        root.getChildren().addAll(vbox, lbl2);

        AnchorPane.setTopAnchor(vbox, BORDER);
        AnchorPane.setBottomAnchor(lbl2, BORDER);
        AnchorPane.setLeftAnchor(lbl2, BORDER);

        var scene = new Scene(root, 300, 250);

        stage.setTitle("RadioButton");
        stage.setScene(scene);
        stage.show();
    }

    private class MyToggleListener implements ChangeListener<Toggle> {

        @Override
        public void changed(ObservableValue<? extends Toggle> observable,
                            Toggle oldValue, Toggle newValue) {

            var rb = (RadioButton) newValue;
            String txt = rb.getText();
            lbl2.setText(txt);
        }
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example has three radio buttons. By placing them in a toggle group, only one of them can be
   selected at a time.
var lbl1 = new Label("Difficulty");

   This label gives description to the radio buttons.
lbl2 = new Label("");
lbl2.setStyle("-fx-background-color:wheat; -fx-padding: 0 0 0 5");
lbl2.prefWidthProperty().bind(stage.widthProperty().subtract(2*BORDER));

   This label shows the text label of the currently selected radio button. Its style is customized with
   the setStyle() method. The label is enlarged to take to width of the stage minus the specified
   border.
var tg =  new ToggleGroup();
tg.selectedToggleProperty().addListener(new MyToggleListener());

   A ToggleGroup is created and a listener is added to its selectedToggleProperty.
var rb1 = new RadioButton("Easy");

   A RadioButton control is created.
rb1.setToggleGroup(tg);

   The setToggleGroup() method sets the radio button to the toggle group.
rb1.setSelected(true);

   The setSelected() selects the radio button.
private class MyToggleListener implements ChangeListener<Toggle> {

    @Override
    public void changed(ObservableValue<? extends Toggle> observable,
            Toggle oldValue, Toggle newValue) {

        var rb = (RadioButton) newValue;
        String txt = rb.getText();
        lbl2.setText(txt);
    }
}

   Inside the listener object, we get the radio button's text label with the getText() method and set it
   to the label using the setText() method.
   RadioButton Figure: RadioButton

JavaFX TabPane
   TabPane is a control that allows switching between a group of Tabs. Only one tab is visible at a
   time. Tabs in a TabPane can be positioned at any of the four side of the window. The default side is
   the top side.
   com/zetcode/TabPaneEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;

public class TabPaneEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new StackPane();
        var tabPane = new TabPane();

        var tab1 = new Tab();
        tab1.setText("Rectangle");
        tab1.setContent(new Rectangle(100, 100, Color.LIGHTSTEELBLUE));

        var tab2 = new Tab();
        tab2.setText("Line");
        tab2.setContent(new Line(0, 0, 100, 100));

        var tab3 = new Tab();
        tab3.setText("Circle");
        tab3.setContent(new Circle(0, 0, 50));

        tabPane.getSelectionModel().select(1);
        tabPane.getTabs().addAll(tab1, tab2, tab3);

        root.getChildren().add(tabPane);

        var scene = new Scene(root, 300, 250);

        stage.setTitle("TabPane");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example contains a TabPane control with three tabs. Each tab contains a geometric shape. The
   second tab is selected when the application starts.
var tabPane = new TabPane();

   A TabPane control is created.
var tab1 = new Tab();
tab1.setText("Rectangle");
tab1.setContent(new Rectangle(100, 100, Color.LIGHTSTEELBLUE));

   A Tab is created. Its text label is set with the setText() method. The content is set with the
   setContent() method.
tabPane.getSelectionModel().select(1);

   The TabPane's selection model handles the selection of tabs. The model's select() method selects the
   second tab.
tabPane.getTabs().addAll(tab1, tab2, tab3);

   The tabs are inserted into the tab pane. The internal list of tabs is retrieved with the getTabs()
   method.
   TabPane Figure: TabPane


---
http://zetcode.com/gui/javafx/events/

JavaFX events (part 6)

   GUI applications are event-driven. An application reacts to different event types which are generated
   during its lifetime. Events are generated by a user (a mouse click), an application (a timer), or the
   system (a clock).

   An event is a notification about a change. It encapsulates the state changes in the event source.
   Registered event filters and event handlers within the application receive the event and provide a
   response.

   Every event in JavaFX has three properties:
     * Event source
     * Event target
     * Event type

   Event source is the object whose state changes; it generates events. Event target is the destination
   of the an event. Event type provides additional classification to events of the same Event class.

   Event source object delegates the task of handling an event to the event handler. When the event
   occurs, the event source creates an event object and sends it to each registered handler.

JavaFX Event handler
   EventHandler handles events of a specific class or type. The event handler is set to the event
   source. It has a handle() method, where we put the code that is invoked in reaction to the generated
   event.
   com/zetcode/EventHandlerEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.Scene;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.MenuItem;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class EventHandlerEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new HBox();

        var conMenu = new ContextMenu();
        var noopMi = new MenuItem("No op");
        var exitMi = new MenuItem("Exit");

        conMenu.getItems().addAll(noopMi, exitMi);

        exitMi.setOnAction(event -> Platform.exit());

        root.setOnMousePressed(event -> {
            if (event.isSecondaryButtonDown()) {
                conMenu.show(root, event.getScreenX(),
                        event.getScreenY());
            }
        });

        var scene = new Scene(root, 300, 250);

        stage.setTitle("EventHandler");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example uses two EventHandlers for two different Events.
var conMenu = new ContextMenu();

   ContextMenu is a popup control containing an list of menu items.
var noop = new MenuItem("No op");
var exit = new MenuItem("Exit");
var.getItems().addAll(noop, exit);

   Two MenuItems are created and added to the context menu.
exitMi.setOnAction(event -> Platform.exit());

   With the setOnAction() method, we set an event handler for an ActionEvent. The EventHandler's
   handle() method exits the application with the Platform.exit() method.
root.setOnMousePressed(event -> {
    if (event.isSecondaryButtonDown()) {
        conMenu.show(root, event.getScreenX(),
                event.getScreenY());
    }
});

   With the setOnMousePressed() method, we set an event handler for a MouseEvent. When we click the
   secondary mouse button (usually the right one), the context menu is shown on the screen; it is
   displayed below the x and y coordinates of the mouse click.

JavaFX Event properties
   The following program explores the properties of a MouseEvent. It is an event that occurs due to the
   user interacting with a mouse.
   com/zetcode/EventSourceEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;

public class EventSourceEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new Pane();

        var rect = new Rectangle(30, 30, 80, 80);
        rect.setOnMouseClicked(e -> {

            System.out.println(e.getSource());
            System.out.println(e.getTarget());
            System.out.println(e.getEventType());
            System.out.format("x:%f, y:%f%n", e.getSceneX(), e.getSceneY());
            System.out.format("x:%f, y:%f%n", e.getScreenX(), e.getScreenY());
        });

        root.getChildren().addAll(rect);

        var scene = new Scene(root, 300, 250);

        stage.setTitle("Event properties");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   In the example, we have a rectangle shape. We add an event handler to the mouse clicked event type.
rect.setOnMouseClicked(e -> {
...
});

   The setOnMouseClicked() adds an event handler to the mouse clicked event types. The handler is an
   anonymous inner class.
System.out.println(e.getSource());
System.out.println(e.getTarget());
System.out.println(e.getEventType());

   These three are the generic properties, available for all events. The getSource() method returns an
   object on which the event initially occurred. The getTarget() method returns the event target of this
   event. In our case, the event source and the event target is the same - the rectangle. The
   getEventType() method returns the event type of the MouseEvent. In our case it returns the
   MOUSE_CLICKED value.
System.out.format("x:%f, y:%f%n", e.getSceneX(), e.getSceneY());
System.out.format("x:%f, y:%f%n", e.getScreenX(), e.getScreenY());

   These four properties are specific to this event. We print the x and y coordinates of a mouse click,
   relative to the scene and to the screen.

JavaFX Generic handler
   In the next example, we create a generic event handler that listens for all kinds of events.
   com/zetcode/GenericHandlerEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;

public class GenericHandlerEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new StackPane();

        var btn = new Button("Button");
        btn.addEventHandler(EventType.ROOT, new GenericHandler());

        root.getChildren().add(btn);

        var scene = new Scene(root, 300, 250);

        stage.setTitle("Generic handler");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }

    private class GenericHandler implements EventHandler<Event> {

        @Override
        public void handle(Event event) {

            System.out.println(event.getEventType());
        }
    }
}

</code>

   This example has one button control. A generic handler is plugged to the button.
var btn = new Button("Button");
btn.addEventHandler(EventType.ROOT, new GenericHandler());

   The addEventHandler() method registers an event handler to the button node for the specified event
   type. The EventType.ROOT stands for all event types.
private class GenericHandler implements EventHandler<Event> {

    @Override
    public void handle(Event event) {

        System.out.println(event.getEventType());
    }
}

   The handler prints the event type to the console in its handle() method.

JavaFX Multiple sources

   It is possible to add a single event handler to multiple sources. The source of the event can be
   determined with the getSource() method.
   com/zetcode/MultipleSourcesEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class MultipleSourcesEx extends Application {

    private Label lbl;

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new AnchorPane();

        var vbox = new VBox(5);

        var btn1 = new Button("Close");
        var btn2 = new Button("Open");
        var btn3 = new Button("Find");
        var btn4 = new Button("Save");

        var mbh = new MyButtonHandler();

        btn1.setOnAction(mbh);
        btn2.setOnAction(mbh);
        btn3.setOnAction(mbh);
        btn4.setOnAction(mbh);

        vbox.getChildren().addAll(btn1, btn2, btn3, btn4);

        lbl = new Label("Ready");

        AnchorPane.setTopAnchor(vbox, 10d);
        AnchorPane.setLeftAnchor(vbox, 10d);
        AnchorPane.setBottomAnchor(lbl, 10d);
        AnchorPane.setLeftAnchor(lbl, 10d);

        root.getChildren().addAll(vbox, lbl);

        var scene = new Scene(root, 350, 200);

        stage.setTitle("Multiple sources");
        stage.setScene(scene);
        stage.show();
    }

    private class MyButtonHandler implements EventHandler {

        @Override
        public void handle(ActionEvent event) {

            var btn = (Button) event.getSource();
            lbl.setText(String.format("Button %s fired", btn.getText()));
        }
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example has four buttons and a label. One event handler is added to all four buttons. The name of
   the fired button is displayed in the label.
var btn1 = new Button("Close");
var btn2 = new Button("Open");
var btn3 = new Button("Find");
var btn4 = new Button("Save");

   These four buttons will share a single event handler.
var mbh = new MyButtonHandler();

   An instance of a MyButtonHandler is created. It is implemented as a inner named class.
btn1.setOnAction(mbh);
btn2.setOnAction(mbh);
btn3.setOnAction(mbh);
btn4.setOnAction(mbh);

   The handler is added to four different buttons with the setOnAction() method.
private class MyButtonHandler implements EventHandler<ActionEvent> {

    @Override
    public void handle(ActionEvent event) {

        var btn = (Button) event.getSource();
        lbl.setText(String.format("Button %s fired", btn.getText()));
    }
}

   Inside the handle() method of the MyButtonHandler, we determine the source of the event and build a
   message using the source's text label. The message is set to the label control with its setText()
   method.
   Multiple sources Figure: Multiple sources

The java.util.Timer
   The java.util.Timer schedules tasks for future execution in a background thread. TimerTask is a task
   that can be scheduled for one-time or repeated execution by a timer.
   com/zetcode/TimerEx.java

<code>
// package com.zetcode;

import java.util.Timer;
import java.util.TimerTask;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.scene.control.Button;
import javafx.scene.control.Spinner;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class TimerEx extends Application {

    int delay = 0;

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new HBox(10);
        root.setPadding(new Insets(10));

        var timer = new Timer();

        var spinner = new Spinner<>(1, 60, 5);
        spinner.setPrefWidth(80);

        var btn = new Button("Show message");
        btn.setOnAction(event -> {

            delay = (int) spinner.getValue();
            timer.schedule(new MyTimerTask(), delay*1000);
        });

        root.getChildren().addAll(btn, spinner);

        stage.setOnCloseRequest(event -> timer.cancel());

        var scene = new Scene(root);

        stage.setTitle("Timer");
        stage.setScene(scene);
        stage.show();
    }

    private class MyTimerTask extends TimerTask {

        @Override
        public void run() {

            Platform.runLater(() -> {

                var alert = new Alert(Alert.AlertType.INFORMATION);
                alert.setTitle("Information dialog");
                alert.setHeaderText("Time elapsed information");

                String contxt;

                if (delay == 1) {
                    contxt = "1 second has elapsed";
                } else {
                    contxt = String.format("%d seconds have elapsed",
                            delay);
                }

                alert.setContentText(contxt);
                alert.showAndWait();
            });
        }
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example has two controls: a button and a spinner. The button starts a timer, which shows a
   message dialog after a delay. The delay is chosen by the spinner control.
var timer = new Timer();

   An instance of the Timer is created.
var spinner = new Spinner<>(1, 60, 5);

   The Spinner control is used to choose the amount of the delay. Its parameters are the minimum,
   maximum, and current values. The values are in milliseconds.
btn.setOnAction(event -> {

    delay = (int) spinner.getValue();
    timer.schedule(new MyTimerTask(), delay*1000);
});

   In the button's event handler, we get the spinner's current value with the getValue() method and
   schedule the task with the timer's schedule() method.
stage.setOnCloseRequest(event -> timer.cancel());

   We cancel the timer when the application is terminated with the timer's cancel() method.
private class MyTimerTask extends TimerTask {

    @Override
    public void run() {

        Platform.runLater(() -> {

            var alert = new Alert(Alert.AlertType.INFORMATION);
            alert.setTitle("Information dialog");
            alert.setHeaderText("Time elapsed information");

            String contxt;

            if (delay == 1) {
                contxt = "1 second has elapsed";
            } else {
                contxt = String.format("%d seconds have elapsed",
                        delay);
            }

            alert.setContentText(contxt);
            alert.showAndWait();
        });
    }
}

   The runLater() method executes the task on the JavaFX Application Thread. We show a message dialog
   informing about the elapsed time.
   Time elapsed Figure: Time elapsed

JavaFX Moving a window
   The following example shows the position of the application window on the screen.
   com/zetcode/MovingWindowEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class MovingWindowEx extends Application {

    int x = 0;
    int y = 0;
    Label lbl_x;
    Label lbl_y;

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new VBox(10);
        root.setPadding(new Insets(10));

        var txt1 = String.format("x: %d", x);
        lbl_x = new Label(txt1);

        var txt2 = String.format("y: %d", y);
        lbl_y = new Label(txt2);

        root.getChildren().addAll(lbl_x, lbl_y);

        stage.xProperty().addListener(new ChangeListener<>() {

            @Override
            public void changed(ObservableValue<? extends Number> observable,
                                Number oldValue, Number newValue) {

                doChange(newValue);
            }

            private void doChange(Number newValue) {

                x = newValue.intValue();
                updateXLabel();
            }

        });

        stage.yProperty().addListener(new ChangeListener<>() {

            @Override
            public void changed(ObservableValue<? extends Number> observable,
                                Number oldValue, Number newValue) {

                doChange(newValue);
            }

            private void doChange(Number newValue) {

                y = newValue.intValue();
                updateYLabel();
            }

        });

        var scene = new Scene(root, 300, 250);

        stage.setTitle("Moving window");
        stage.setScene(scene);
        stage.show();
    }

    private void updateXLabel() {

        var txt = String.format("x: %d", x);
        lbl_x.setText(txt);
    }

    private void updateYLabel() {

        var txt = String.format("y: %d", y);
        lbl_y.setText(txt);
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example shows the current window coordinates in two label controls. To get the window position,
   we listen for changes of the xProperty and yProperty of the stage.
var txt1 = String.format("x: %d", x);
lbl_x = new Label(txt1);

var txt2 = String.format("y: %d", y);
lbl_y = new Label(txt2);

   These two labels show the x and y coordinates of the top-left corner of the application window.
stage.xProperty().addListener(new ChangeListener<Number>() {

    @Override
    public void changed(ObservableValue<? extends Number> observable,
            Number oldValue, Number newValue) {

        doChange(newValue);
    }

    private void doChange(Number newValue) {

        x = newValue.intValue();
        updateXLabel();
    }

});

   The xProperty stores the horizontal location of the stage on the screen. We add a ChangeListener to
   listen for changes of the property. Each time the property is modified, we retrieve the new value and
   update the label.
private void updateYLabel() {

    var txt = String.format("y: %d", y);
    lbl_y.setText(txt);
}

   A label is updated with the setText() method.
   Moving a window Figure: Moving a window


---
http://zetcode.com/gui/javafx/effects/

JavaFX effects (part 7)

   JavaFX contains the javafx.scene.effect package, which has a set or classes that perform various
   visual effects. In this chapter, we create a DropShadow, a Reflection, a Lighting, a GaussianBlur, a
   SepiaTone, and a PerspectiveTransform effect. We also show how to combine multiple effects.
   [INS: :INS]

   Effects are applied to the node's effectProperty with the setEffect() method.

JavaFX DropShadow
   DropShadow is a high-level effect that renders a shadow behind the content with the specified colour,
   radius, and offset.
   com/zetcode/DropShadowEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.effect.DropShadow;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;

public class DropShadowEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new StackPane();

        var rect = new Rectangle(0, 0, 100, 100);
        rect.setFill(Color.GREENYELLOW);

        var ds = new DropShadow(15, Color.DARKGREEN);

        rect.setEffect(ds);

        root.getChildren().add(rect);

        var scene = new Scene(root, 250, 200, Color.WHITESMOKE);

        stage.setTitle("DropShadow");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example creates a shadow around a rectangle.
var rect = new Rectangle(0, 0, 100, 100);
rect.setFill(Color.GREENYELLOW);

   A greenyellow rectangle shape is constructed.
var ds = new DropShadow(15, Color.DARKGREEN);

   A DropShadow effect is created. The constructor accepts the radius and the colour.
rect.setEffect(ds);

   The effect is applied with the setEffect() method.
   DropShadow Figure: DropShadow

JavaFX Reflection
   Reflection is an effect that renders a reflected version of the input below the actual input content.
   com/zetcode/ReflectionEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.effect.Reflection;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class ReflectionEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new StackPane();

        var text = new Text();
        text.setText("ZetCode");
        text.setFill(Color.STEELBLUE);
        text.setFont(Font.font("Serif", FontWeight.BOLD, 60));

        var ref = new Reflection();
        text.setEffect(ref);

        root.getChildren().add(text);

        var scene = new Scene(root, 300, 250, Color.WHITESMOKE);

        stage.setTitle("Reflection");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example applies a Reflection effect on a Text node.
var text = new Text();
text.setText("ZetCode");
text.setFill(Color.STEELBLUE);
text.setFont(Font.font("Serif", FontWeight.BOLD, 60));

   A Text control is created. Its paint is steelblue. The font is made bold and enlarged.
var ref = new Reflection();
text.setEffect(ref);

   A default Reflection is created and applied on the text control.
   Reflection Figure: Reflection

JavaFX Lighting
   Lighting simulates a light source shining on the given content, which can be used to give flat
   objects a more realistic, three-dimensional appearance. The setAzimuth() method of the Light source
   sets the azimuth - the direction angle for the light source.
   com/zetcode/LightingEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Slider;
import javafx.scene.effect.Light;
import javafx.scene.effect.Lighting;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class LightingEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new VBox(30);
        root.setPadding(new Insets(10));

        var azimuth = new SimpleDoubleProperty(0);

        Light.Distant light = new Light.Distant();
        light.setAzimuth(0);

        var lighting = new Lighting(light);
        lighting.setSurfaceScale(5.0);

        var text = new Text();
        text.setText("ZetCode");
        text.setFill(Color.LIGHTSKYBLUE);
        text.setFont(Font.font(null, FontWeight.BOLD, 60));

        var slider = new Slider(1, 360, 0);
        azimuth.bind(slider.valueProperty());

        slider.valueProperty().addListener(event -> {

            light.setAzimuth(azimuth.get());
            lighting.setLight(light);
            text.setEffect(lighting);
        });

        text.setEffect(lighting);

        root.getChildren().addAll(slider, text);

        var scene = new Scene(root, 300, 250, Color.WHITESMOKE);

        stage.setTitle("Lighting");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example applies a Lighting effect on a Text control. The azimuth of the light is controlled by a
   Slider.
Light.Distant light = new Light.Distant();
light.setAzimuth(0);

   A Light source is created.
var lighting = new Lighting(light);

   This line creates a new instance of a Lighting with the specified light.
var text = new Text();
text.setText("ZetCode");
text.setFill(Color.LIGHTSKYBLUE);
text.setFont(Font.font(null, FontWeight.BOLD, 60));

   This is the Text control on which the Lighting effect is set.
var slider = new Slider(1, 360, 0);
azimuth.bind(slider.valueProperty());

slider.valueProperty().addListener(event -> {
    light.setAzimuth(azimuth.get());
    lighting.setLight(light);
    text.setEffect(lighting);
});

   The Slider control manages the azimuth of the light source.
   Lighting Figure: Lighting

JavaFX GaussianBlur
   GaussianBlur is a blur effect using a Gaussian convolution kernel with a configurable radius.
   com/zetcode/GaussianBlurEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Slider;
import javafx.scene.effect.GaussianBlur;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class GaussianBlurEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new VBox(30);
        root.setPadding(new Insets(10));

        var radius = new SimpleDoubleProperty(0);

        var blurredText = new Text("Inception");
        blurredText.setFont(Font.font(38));

        var slider = new Slider(1, 20, 1);
        radius.bind(slider.valueProperty());

        slider.valueProperty().addListener(event -> {
            blurredText.setEffect(new GaussianBlur(radius.get()));
        });

        root.getChildren().addAll(slider, blurredText);

        var scene = new Scene(root, 300, 250, Color.WHITESMOKE);

        stage.setTitle("Blur effect");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example applies a GaussianBlur effect on a Text control. The radius of the blur is controlled by
   a Slider.
var blurredText = new Text("Inception");
blurredText.setFont(Font.font(38));

   The blur effect will be applied on this text control.
var slider = new Slider(1, 20, 1);
radius.bind(slider.valueProperty());

slider.valueProperty().addListener(event -> {
    blurredText.setEffect(new GaussianBlur(radius.get()));
});

   The Slider control manages the radius property of the GaussianBlur effect.
   GaussianBlur Figure: GaussianBlur

JavaFX SepiaTone
   SepiaTone is a filter that produces a sepia tone effect, similar to antique photographs.
   com/zetcode/SepiaToneEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.beans.binding.Bindings;
import javafx.scene.CacheHint;
import javafx.scene.Scene;
import javafx.scene.effect.Effect;
import javafx.scene.effect.SepiaTone;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class SepiaToneEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new StackPane();
        var image = new Image("file:src/main/resources/mushroom.png");
        var iw = new ImageView(image);

        var sepia = new SepiaTone();
        iw.effectProperty().bind(
                Bindings.when(iw.hoverProperty())
                        .then((Effect) sepia)
                        .otherwise((Effect) null)
        );

        iw.setCache(true);
        iw.setCacheHint(CacheHint.SPEED);

        root.getChildren().add(iw);

        var scene = new Scene(root);

        stage.setTitle("SepiaTone");
        scene.setFill(Color.WHITESMOKE);
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example applies a SepiaTone effect on an Image when a mouse pointer is over the image.
var image = new Image("file:src/main/resources/mushroom.png");
var iw = new ImageView(image);

   We load an Image from the disk and create an ImageView control.
var sepia = new SepiaTone();
iw.effectProperty().bind(
        Bindings.when(iw.hoverProperty())
                .then((Effect) sepia)
                .otherwise((Effect) null)
);

   The SepiaTone effect is set when the mouse pointer is located over the bounds of the ImageView
   control.
iw.setCache(true);
iw.setCacheHint(CacheHint.SPEED);

   For performance reasons, the node rendering is cached.

JavaFX PerspectiveTransform
   PerspectiveTransform provides a non-affine transformation of the input content. It is usually used to
   create a three-dimensional effect on a two-dimensional content.
   com/zetcode/PerspectiveEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.effect.PerspectiveTransform;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;

public class PerspectiveEx extends Application {

    private final int SIZE = 50;

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new StackPane();

        var board = new Pane();

        for (int row = 0; row < 8; row++) {
            for (int col = 0; col < 8; col++) {

                var r = new Rectangle(col * SIZE, row*SIZE,
                        SIZE, SIZE);

                if ((col+row) % 2 == 0) {
                    r.setFill(Color.WHITE);
                } else {
                    r.setFill(Color.BLACK);
                }

                board.getChildren().add(r);
            }
        }

        var e = new PerspectiveTransform();
        e.setUlx(30);     // Upper-left point
        e.setUly(170);
        e.setUrx(370);    // Upper-right point
        e.setUry(170);
        e.setLlx(0);      // Lower-left point
        e.setLly(300);
        e.setLrx(400);    // Lower-right point
        e.setLry(300);
        board.setEffect(e);

        root.getChildren().add(board);

        var scene = new Scene(root, Color.WHITESMOKE);

        stage.setTitle("ChessBoard");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example forms a chessboard with the PerspectiveTransform effect.
for (int row = 0; row < 8; row++) {
    for (int col = 0; col < 8; col++) {

        var r = new Rectangle(col * SIZE, row*SIZE,
                SIZE, SIZE);

        if ((col+row) % 2 == 0) {
            r.setFill(Color.WHITE);
        } else {
            r.setFill(Color.BLACK);
        }

        board.getChildren().add(r);
    }
}

   This code produces 64 rectangles. The rectangles have black and white colours.
var e = new PerspectiveTransform();
e.setUlx(30);     // Upper-left point
e.setUly(170);
e.setUrx(370);    // Upper-right point
e.setUry(170);
e.setLlx(0);      // Lower-left point
e.setLly(300);
e.setLrx(400);    // Lower-right point
e.setLry(300);
board.setEffect(e);

   A PerspectiveTransform is instantiated and applied on the node. We provide x and y coordinates of
   four corner points. These points form a rectangle into which the effect is rendered.
   Chessboard Figure: Chessboard

JavaFX Combining effects
   It is possible to combine effects. The setEffect() method replaces an effect if there is one already
   set. To combine multiple effects, we use the Effect's setInput() method.
   com/zetcode/CombiningEffectsEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.effect.Light;
import javafx.scene.effect.Lighting;
import javafx.scene.effect.Reflection;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class CombiningEffectsEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new StackPane();

        Light.Distant light = new Light.Distant();
        light.setAzimuth(50);

        var lighting = new Lighting();
        lighting.setLight(light);
        lighting.setSurfaceScale(5);

        var text = new Text();
        text.setText("ZetCode");
        text.setFill(Color.CADETBLUE);
        text.setFont(Font.font(null, FontWeight.BOLD, 60));

        var ref = new Reflection();
        ref.setInput(lighting);
        text.setEffect(ref);

        root.getChildren().add(text);

        var scene = new Scene(root, 300, 250, Color.WHITESMOKE);

        stage.setTitle("Combining effects");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example program combines a Reflection effect with a Lighting effect on a Text node.
Light.Distant light = new Light.Distant();
light.setAzimuth(50);

var lighting = new Lighting();
lighting.setLight(light);
lighting.setSurfaceScale(5.0);

   These lines create a Lighting effect.
var text = new Text();
text.setText("ZetCode");
text.setFill(Color.CADETBLUE);
text.setFont(Font.font(null, FontWeight.BOLD, 60));

   A Text control is created. The font is enlarged and bold face. The colour of the text is cadetblue.
var ref = new Reflection();
ref.setInput(lighting);

   A Reflection effect is constructed. It is combined with the lighting effect using the setInput()
   method.
text.setEffect(ref);

   The final combination of effects is applied on the node with the setEffect() method.
   Combining effects Figure: Combining effects


---
http://zetcode.com/gui/javafx/animation/

JavaFX animation (part 8)

   In this chapter, we work with animation in JavaFX. We create animations using AnimationTimer,
   Transition, and Timeline.

   Animation is a rapid succession of images which make an illusion of movement. Animation is not
   restricted to movement, however. Changing the background of a node over time is considered an
   animation too.

   JavaFX provides three basic tools to create animation:
     * AnimationTimer
     * Transition
     * Timeline

   AnimationTimer is the most simple tool to create animation. It is a basic timer; its handle() method
   is called in every frame of the animation. Transition is a basic high-level framework to define
   animation. The animation is controlled with the frac value of the interpolate() method. Timeline is
   the most complex tool for doing high-level animations. Timeline animation is defined with KeyFrames,
   which outline target values of a node at a specified point in time for a set of variables that are
   interpolated along a Timeline. The animated properties are defined with KeyValues.

Animation class
   Animation is the basic class in JavaFX to define high-level animation. Both Transition and Timeline
   extend Animation. An animation is started with play() or playFromStart() methods and ended with the
   stop() method. An animation can be paused by calling the pause() method, and the next play() call
   resumes the animation from where it was paused. The rate property defines the direction and speed at
   which the animation is expected to be played. The delay property specifies the amount of initial
   delay of the animation. An animation can run in cycles; the number of cycles is defined in the
   cycleCount property, and the cycleDuration indicates the duration of a cycle. An animation can be
   reversed on alternating cycles with the autoReverseProperty.

JavaFX AnimationTimer
   AnimationTimer allows to create a timer that is called in each frame while it is active. It is an
   abstract class; therefore, we need to create a custom class which extends it. Its handle() method,
   which is called in every frame, must be overridden. The AnimationTimer's start() method starts the
   timer and the stop() method stops it.
   com/zetcode/AnimationTimerEx.java

<code>
// package com.zetcode;

import javafx.animation.AnimationTimer;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.layout.StackPane;
import javafx.scene.text.Font;
import javafx.stage.Stage;

public class AnimationTimerEx extends Application {

    private double opacity = 1;
    private Label lbl;

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new StackPane();

        lbl = new Label("JavaFX");
        lbl.setFont(Font.font(48));
        root.getChildren().add(lbl);

        AnimationTimer timer = new MyTimer();
        timer.start();

        var scene = new Scene(root, 300, 250);

        stage.setTitle("AnimationTimer");
        stage.setScene(scene);
        stage.show();
    }

    private class MyTimer extends AnimationTimer {

        @Override
        public void handle(long now) {

            doHandle();
        }

        private void doHandle() {

            opacity -= 0.01;
            lbl.opacityProperty().set(opacity);

            if (opacity <= 0) {

                stop();
                System.out.println("Animation stopped");
            }
        }
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example uses the AnimationTimer to create a fade out effect on a node.
lbl = new Label("JavaFX");
lbl.setFont(Font.font(48));
root.getChildren().add(lbl);

   Our animation changes the property of this Label control.
AnimationTimer timer = new MyTimer();
timer.start();

   An AnimationTimer is created and its start() method is called.
private class MyTimer extends AnimationTimer {

    @Override
    public void handle(long now) {

        doHandle();
    }
...
}

   We create a concrete subclass of the AnimationTimer and override its handle() method.
private void doHandle() {

    opacity -= 0.01;
    lbl.opacityProperty().set(opacity);

    if (opacity <= 0) {

        stop();
        System.out.println("Animation stopped");
    }
}

   In the doHandle() method, we decrease the opacity variable and update the opacityProperty. If the
   opacity reaches its minimum value, the timer is stopped with its stop() method.

JavaFX FadeTransition
   Transition animation is best suited for a planned animation. Transition has concrete classes that can
   be used to create various animations that can be executed in parallel or sequentially; for instance
   FadeTransition, PathTransition, RotateTransition, or ScaleTransition.

   FadeTransition creates a fade effect animation that spans its duration. This is done by updating the
   opacity variable of the node at regular interval.
   com/zetcode/FadeTransitionEx.java

<code>
// package com.zetcode;

import javafx.animation.Animation;
import javafx.animation.FadeTransition;
import javafx.application.Application;
import javafx.event.EventHandler;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.input.MouseEvent;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;
import javafx.util.Duration;

public class FadeTransitionEx extends Application {

    private FadeTransition ft;
    private Rectangle rect;

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new Group();

        rect = new Rectangle(20, 20, 150, 150);
        rect.setOnMouseClicked(new RectClickHandler());

        ft = new FadeTransition(Duration.millis(5000), rect);
        ft.setFromValue(1.0);
        ft.setToValue(0.0);

        root.getChildren().add(rect);

        var scene = new Scene(root, 300, 250);

        stage.setTitle("Fading transition");
        stage.setScene(scene);
        stage.show();
    }

    private class RectClickHandler implements EventHandler<MouseEvent> {

        @Override
        public void handle(MouseEvent event) {

            doHandle();
        }

        private void doHandle() {

            double opa = rect.getOpacity();

            if ((int) opa == 0) {
                return;
            }

            Animation.Status as = ft.getStatus();

            if (as == Animation.Status.RUNNING) {
                return;
            }

            if (as == Animation.Status.STOPPED) {
                ft.play();
            }
        }
    }

    public static void main(String[] args) {
        Application.launch(args);
    }
}

</code>

   This example uses FadeTransition to create a fade out effect on a rectangle. The animation is started
   after a mouse click inside the area of the rectangle.
rect = new Rectangle(20, 20, 150, 150);
rect.setOnMouseClicked(new RectClickHandler());

   A mouse clicked handler is set to the rectangle.
ft = new FadeTransition(Duration.millis(5000), rect);

   A FadeTransition is created. Its first parameter is the duration of the transition. The second
   parameter is the node whose opacity parameter is updated.
ft.setFromValue(1.0);
ft.setToValue(0.0);

   The setFromValue() sets the start value of the opacity, and the setToValue() sets the ending opacity
   value.
double opa = rect.getOpacity();

   The current opacity value is determined with the getOpacity() method.
if (opa.intValue() == 0) {
    return;
}

   After the rectangle fades out, we dismiss the mouse click.
Animation.Status as = ft.getStatus();

if (as == Animation.Status.RUNNING) {
    return;
}

if (as == Animation.Status.STOPPED) {
    ft.play();
}

   The getStatus() method determines the transition's status. If the status is Animation.Status.STOPPED,
   we start the transition with the play() method.

PathTransition
   PathTransition creates an animation along a path. The translation along the path is done by updating
   the translateX and translateY variables of the node. Note that we must use a node that supports
   absolute positioning of elements.
   com/zetcode/PathTransitionEx.java

<code>
// package com.zetcode;

import javafx.animation.PathTransition;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.CubicCurveTo;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.Path;
import javafx.stage.Stage;
import javafx.util.Duration;

public class PathTransitionEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new Pane();

        var path = new Path();
        path.getElements().add(new MoveTo(20, 120));
        path.getElements().add(new CubicCurveTo(180, 60, 250, 340, 420, 240));

        var circle = new Circle(20, 120, 10);
        circle.setFill(Color.CADETBLUE);

        var ptr = new PathTransition();

        ptr.setDuration(Duration.seconds(6));
        ptr.setDelay(Duration.seconds(2));
        ptr.setPath(path);
        ptr.setNode(circle);
        ptr.setCycleCount(2);
        ptr.setAutoReverse(true);
        ptr.play();

        root.getChildren().addAll(path, circle);

        var scene = new Scene(root, 450, 300);

        stage.setTitle("PathTransition");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example uses a PathTransition to move a circle along a path. The animation starts after an
   initial delay of 2 seconds. It consists of two cycles. The animation is reveresed; that is, the
   circle goes from the starting point to the ending point and then it returns back.
var root = new Pane();

   We use the Pane as our root node. It supports absolute positioning that is needed for animation.
var path = new Path();
path.getElements().add(new MoveTo(20, 120));
path.getElements().add(new CubicCurveTo(180, 60, 250, 340, 420, 240));

   Here we define the Path along which the animated object will be moving.
var circle = new Circle(20, 120, 10);
circle.setFill(Color.CADETBLUE);

   This circle is the moving object in our animation.
var ptr = new PathTransition();

   A PathTransition object is created.
ptr.setDuration(Duration.seconds(6));

   The setDuration() method sets the duration of the animation.
ptr.setDelay(Duration.seconds(2));

   The setDelay() method sets the initial delay of the animation.
ptr.setPath(path);
ptr.setNode(circle);

   The setPath() method sets the path, and the setNode() sets the target node of the animation.
ptr.setCycleCount(2);

   Our animation has two cycles. The number of cycles is set with the setCycleCount() method.
ptr.setAutoReverse(true);

   With the setAutoReverse() method, we reverse the direction of the animation. The circle moves back to
   the starting position.
ptr.play();

   Finally, the play() method starts the plays the animation.
   PathTransition Figure: PathTransition

ParallelTransition

   ParallelTransition plays a list of Animations in parallel.
   com/zetcode/ParallelTransitionEx.java

<code>
// package com.zetcode;

import javafx.animation.FillTransition;
import javafx.animation.ParallelTransition;
import javafx.animation.RotateTransition;
import javafx.animation.ScaleTransition;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;
import javafx.util.Duration;


public class ParallelTransitionEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new Pane();

        var rect = new Rectangle(50, 50, 30, 30);
        rect.setArcHeight(10);
        rect.setArcWidth(10);
        rect.setFill(Color.CADETBLUE);

        var rottr = new RotateTransition(Duration.millis(2000), rect);
        rottr.setByAngle(180);
        rottr.setCycleCount(2);
        rottr.setAutoReverse(true);

        var sctr = new ScaleTransition(Duration.millis(2000), rect);
        sctr.setByX(2);
        sctr.setByY(2);
        sctr.setCycleCount(2);
        sctr.setAutoReverse(true);

        var fltr = new FillTransition(Duration.millis(2000), rect,
                Color.CADETBLUE, Color.STEELBLUE);
        fltr.setCycleCount(2);
        fltr.setAutoReverse(true);

        root.getChildren().add(rect);

        var ptr = new ParallelTransition();
        ptr.getChildren().addAll(rottr, sctr, fltr);

        ptr.play();

        Scene scene = new Scene(root, 300, 250);

        stage.setTitle("ParallelTransition");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example plays three transitions in parallel. There is a rectangle object that is rotated, scaled,
   and its background colour changes.
var rottr = new RotateTransition(Duration.millis(2000), rect);
rottr.setByAngle(180);
rottr.setCycleCount(2);
rottr.setAutoReverse(true);

   The RotateTransition rotates the rectangle by the specified angle. The rotation happens in two cycles
   and is reversed.
var sctr = new ScaleTransition(Duration.millis(2000), rect);
sctr.setByX(2);
sctr.setByY(2);

   The ScaleTransition scales the rectangle up and down by the factor of 2.
var fltr = new FillTransition(Duration.millis(2000), rect,
    Color.CADETBLUE, Color.STEELBLUE);

   The FillTransition changes the filling colour of the rectangle from one colour value to another.
var ptr = new ParallelTransition();
ptr.getChildren().addAll(rottr, sctr, fltr);

ptr.play();

   The three types of transitions are placed in the ParallelTransition, which plays them in parallel,
   that is, at the same time.

SequentialTransition

   SequentialTransition plays a list of Animations in a sequential order.
   com/zetcode/SequentialTransitionEx.java

<code>
// package com.zetcode;

import javafx.animation.FillTransition;
import javafx.animation.RotateTransition;
import javafx.animation.ScaleTransition;
import javafx.animation.SequentialTransition;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;
import javafx.util.Duration;


public class SequentialTransitionEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new Pane();

        var rect = new Rectangle(50, 50, 30, 30);
        rect.setArcHeight(10);
        rect.setArcWidth(10);
        rect.setFill(Color.CADETBLUE);

        var rottr = new RotateTransition(Duration.millis(2000), rect);
        rottr.setByAngle(180);
        rottr.setCycleCount(2);
        rottr.setAutoReverse(true);

        var sctr = new ScaleTransition(Duration.millis(2000), rect);
        sctr.setByX(2);
        sctr.setByY(2);
        sctr.setCycleCount(2);
        sctr.setAutoReverse(true);

        var fltr = new FillTransition(Duration.millis(2000), rect,
                Color.CADETBLUE, Color.STEELBLUE);
        fltr.setCycleCount(2);
        fltr.setAutoReverse(true);

        root.getChildren().add(rect);

        var str = new SequentialTransition();
        str.getChildren().addAll(rottr, sctr, fltr);

        str.play();

        var scene = new Scene(root, 300, 250);

        stage.setTitle("SequentialTransition");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example plays three transitions in a sequential order - one after another.
var str = new SequentialTransition();
str.getChildren().addAll(rottr, sctr, fltr);

str.play();

   The three transitions are added to the SequentialTransition.

Timeline
   Timeline is the most involved tool to create animation in JavaFX. The animation is defined with
   KeyFrames which contain the properties of nodes that change. These properties are encapsulated in
   KeyValues. The Timeline interpolates the changes of the properties.
   com/zetcode/TimelineEx.java

<code>
// package com.zetcode;

import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.effect.Lighting;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;
import javafx.util.Duration;


public class TimelineEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new Pane();

        var rect = new Rectangle(20, 20, 60, 60);
        rect.setEffect(new Lighting());
        rect.setFill(Color.CADETBLUE);

        var tl = new Timeline();

        tl.setCycleCount(2);
        tl.setAutoReverse(true);

        var kv = new KeyValue(rect.translateXProperty(), 200);
        var kf = new KeyFrame(Duration.millis(2000), kv);
        tl.getKeyFrames().addAll(kf);

        tl.play();

        root.getChildren().addAll(rect);

        var scene = new Scene(root, 350, 250);

        stage.setTitle("Timeline");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example animates a rectangle with a Timeline.
var rect = new Rectangle(20, 20, 60, 60);
rect.setEffect(new Lighting());
rect.setFill(Color.CADETBLUE);

   This rectangle is the moving object in the animation.
var tl = new Timeline();

   A Timeline object is created.
tl.setCycleCount(2);
tl.setAutoReverse(true);

   The animation consists of two cycles and is reversed. The rectangle moves forth and back.
var kv = new KeyValue(rect.translateXProperty(), 200);

   The KeyValue contains the translateX property that changes over time to 200.
var kf = new KeyFrame(Duration.millis(2000), kv);

   A KeyFrame is instantiated. The first parameter is its duration, the second is the KeyValue. The
   animation lasts 2 seconds, during which its translateX property changes to 200.
tl.getKeyFrames().addAll(kf);

   The key frame is added to the list of frames.

Sequential Timeline animation
   We do not define all the key frames in a timeline. We define some frames and the remaining ones are
   interpolated. Key frames provide target values at a specified point in time for a set of variables
   interpolated in a timeline. In order to execute key frames sequentially, we utilize the
   SequentialTransition class.
   com/zetcode/SequentialTimelineEx.java

<code>
// package com.zetcode;

import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.SequentialTransition;
import javafx.animation.Timeline;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.stage.Stage;
import javafx.util.Duration;

public class SequentialTimelineEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new Pane();

        var c = new Circle(50, 100, 10);
        c.setFill(Color.CADETBLUE);

        var kv1 = new KeyValue(c.scaleXProperty(), 4);
        var kv2 = new KeyValue(c.scaleYProperty(), 4);
        var kf1 = new KeyFrame(Duration.millis(3000), kv1, kv2);

        var scale = new Timeline();
        scale.getKeyFrames().add(kf1);

        var kv3 = new KeyValue(c.centerXProperty(), 250);
        var kf2 = new KeyFrame(Duration.millis(5000), kv3);

        var move = new Timeline();
        move.getKeyFrames().add(kf2);

        var kv4 = new KeyValue(c.scaleXProperty(), 1);
        var kv5 = new KeyValue(c.scaleYProperty(), 1);
        var kf3 = new KeyFrame(Duration.millis(3000), kv4, kv5);

        var scale2 = new Timeline();
        scale2.getKeyFrames().add(kf3);

        var seqtr = new SequentialTransition(scale, move, scale2);
        seqtr.play();

        root.getChildren().add(c);

        var scene = new Scene(root, 300, 250);

        stage.setTitle("Sequential Timeline animation");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example creates a sequential timeline animation. The animation consists of three Timelines that
   are executed sequentially with a SequentialTransition.
var c = new Circle(50, 100, 10);
c.setFill(Color.CADETBLUE);

   The moving object in this animation is a Circle.
var kv1 = new KeyValue(c.scaleXProperty(), 4);
var kv2 = new KeyValue(c.scaleYProperty(), 4);
var kf1 = new KeyFrame(Duration.millis(3000), kv1, kv2);

var scale = new Timeline();
scale.getKeyFrames().add(kf1);

   This is the first Timeline. It scales up the circle over the time of three seconds.
var kv3 = new KeyValue(c.centerXProperty(), 250);
var kf2 = new KeyFrame(Duration.millis(5000), kv3);

var move = new Timeline();
move.getKeyFrames().add(kf2);

   The second Timeline moves the circle forward. This part of the animation lasts five seconds.
var kv4 = new KeyValue(c.scaleXProperty(), 1);
var kv5 = new KeyValue(c.scaleYProperty(), 1);
var kf3 = new KeyFrame(Duration.millis(3000), kv4, kv5);

var scale2 = new Timeline();
scale2.getKeyFrames().add(kf3);

   The third Timeline scales down the circle.
var seqtr = new SequentialTransition(scale, move, scale2);
seqtr.play();

   The three timelines are placed in a SequentialTransition. The timelines are played sequentially, one
   after another.


---
http://zetcode.com/gui/javafx/canvas/

JavaFX Canvas  (part 9)

   Canvas is an image that can be drawn on using a set of graphics commands provided by a
   GraphicsContext. It is a high-level tool for doing painting.

   GraphicsContext is used to issue draw calls to a Canvas using a buffer.

JavaFX simple lines

   In the first example, we draw simple lines. A line is a basic graphics primitive. Two coordinates are
   needed to form a line.
   com/zetcode/SimpleLinesEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class SimpleLinesEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new Pane();

        var canvas = new Canvas(300, 300);
        var gc = canvas.getGraphicsContext2D();
        drawLines(gc);

        root.getChildren().add(canvas);

        var scene = new Scene(root, 300, 250, Color.WHITESMOKE);

        stage.setTitle("Lines");
        stage.setScene(scene);
        stage.show();
    }

    private void drawLines(GraphicsContext gc) {

        gc.beginPath();
        gc.moveTo(30.5, 30.5);
        gc.lineTo(150.5, 30.5);
        gc.lineTo(150.5, 150.5);
        gc.lineTo(30.5, 30.5);
        gc.stroke();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example draws three lines which form a rectangle.
var canvas = new Canvas(300, 300);

   A Canvas is constructed with a width and height that specifies the size of the image into which the
   canvas drawing commands are rendered. All drawing operations are clipped to the bounds of that image.
var gc = canvas.getGraphicsContext2D();

   The getGraphicsContext2D() returns a GraphicsContext associated with the canvas.
drawLines(gc);

   The drawing is delegated to the drawLines() method.
gc.beginPath();

   A line primitive is represented as a path element. The beginPath() method starts a new path.
gc.moveTo(30.5, 30.5);

   The moveTo() method moves the starting point of the current path to the specified coordinate.
gc.lineTo(150.5, 30.5);
gc.lineTo(150.5, 150.5);
gc.lineTo(30.5, 30.5);

   The lineTo() methods add line segments to the current path.
gc.stroke();

   The stroke() method strokes the path with the current stroke paint.
   Lines Figure: Lines

JavaFX stroke and fill

   A stroke is used to draw outlines of shapes. A fill is used to paint interiors of shapes.
   com/zetcode/StrokeFillEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class StrokeFillEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new Pane();

        var canvas = new Canvas(300, 300);
        var gc = canvas.getGraphicsContext2D();
        doDrawing(gc);

        root.getChildren().add(canvas);

        var scene = new Scene(root, 300, 250, Color.WHITESMOKE);

        stage.setTitle("Stroke and fill");
        stage.setScene(scene);
        stage.show();
    }

    private void doDrawing(GraphicsContext gc) {

        gc.setStroke(Color.FORESTGREEN.brighter());
        gc.setLineWidth(5);
        gc.strokeOval(30, 30, 80, 80);
        gc.setFill(Color.FORESTGREEN);
        gc.fillOval(130, 30, 80, 80);
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example draws an outline of a circle and fills an interior of a circle.
gc.setStroke(Color.FORESTGREEN.brighter());

   The setStroke() method sets the current stroke paint attribute. The default colour is black. The
   attribute is used by the stroke methods of the GraphicsContext.
gc.setLineWidth(5);

   The setLineWidth() sets the current line width.
gc.strokeOval(130, 30, 80, 80);

   The strokeOval() method strokes an oval using the current stroke paint.
gc.setFill(Color.FORESTGREEN);

   The setFill() method sets the current fill paint attribute. The default colour is black. The
   attribute is used by the fill methods of the GraphicsContext.
gc.fillOval(30, 30, 80, 80);

   The fillOval() fills an oval using the current fill paint.
   Stroke and fill Figure: Stroke and fill

JavaFX colours

   The Color class is used to work with colours in JavaFX. There are many predefined colours. Custom
   colour values can be created using the RGB or HSB colour model.
   com/zetcode/ColoursEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;


public class ColoursEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new Pane();

        var canvas = new Canvas(300, 300);
        var gc = canvas.getGraphicsContext2D();
        drawShapes(gc);

        root.getChildren().add(canvas);

        Scene scene = new Scene(root, 280, 200, Color.WHITESMOKE);

        stage.setTitle("Colours");
        stage.setScene(scene);
        stage.show();
    }

    private void drawShapes(GraphicsContext gc) {

        gc.setFill(Color.CADETBLUE);
        gc.fillOval(30, 30, 50, 50);

        gc.setFill(Color.DARKRED);
        gc.fillOval(110, 30, 50, 50);

        gc.setFill(Color.STEELBLUE);
        gc.fillOval(190, 30, 50, 50);

        gc.setFill(Color.BURLYWOOD);
        gc.fillOval(30, 110, 50, 50);

        gc.setFill(Color.LIGHTSEAGREEN);
        gc.fillOval(110, 110, 50, 50);

        gc.setFill(Color.CHOCOLATE);
        gc.fillOval(190, 110, 50, 50);
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example draws six circles using predefined colour values.
gc.setFill(Color.CADETBLUE);

   A predefined Color.CADETBLUE colour is set to be the current fill.
gc.fillOval(30, 30, 50, 50);

   An interior of a circle object is filled with the current fill attribute.
   Colours Figure: Colours

JavaFx gradients
   In computer graphics, a gradient is a smooth blending of shades from light to dark or from one colour
   to another. In drawing and paint programs, gradients are used to create colourful backgrounds and
   special effects as well as to simulate lights and shadows. There are two types of gradients: linear
   gradients and radial gradients.

Linear gradient
   A linear gradient is a smooth blending of colours along a line. It is defined by the LinearGradient
   class.
   com/zetcode/LinearGradientEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.paint.CycleMethod;
import javafx.scene.paint.LinearGradient;
import javafx.scene.paint.Stop;
import javafx.stage.Stage;

public class LinearGradientEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new Pane();

        var canvas = new Canvas(300, 300);
        var gc = canvas.getGraphicsContext2D();
        doDrawing(gc);

        root.getChildren().add(canvas);

        var scene = new Scene(root, 300, 250, Color.WHITESMOKE);

        stage.setTitle("Linear gradient");
        stage.setScene(scene);
        stage.show();
    }

    private void doDrawing(GraphicsContext gc) {

        var stops1 = new Stop[] { new Stop(0.2, Color.BLACK),
                new Stop(0.5, Color.RED), new Stop(0.8, Color.BLACK)};

        var lg1 = new LinearGradient(0, 0, 1, 0, true,
                CycleMethod.NO_CYCLE, stops1);

        gc.setFill(lg1);
        gc.fillRect(50, 30, 200, 180);
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   In the example, we fill a rectangular shape with a linear gradient.
var stops1 = new Stop[] { new Stop(0.2, Color.BLACK),
    new Stop(0.5, Color.RED), new Stop(0.8, Color.BLACK)};

   We define stop points for the gradient. They specify how to distribute the colors along the gradient.
var lg1 = new LinearGradient(0, 0, 1, 0, true,
        CycleMethod.NO_CYCLE, stops1);

   The first four parameters specify the line along which the gradient is painted. The fifth parameter
   is the proportional parameter, which sets whether the coordinates are proportional to the shape which
   this gradient fills. The sixth parameter sets the cycle method of the gradient. The last parameter
   takes the stop points.
   LinearGradient Figure: LinearGradient

Radial gradient
   A radial gradient is a smooth blending of colours or shades of colours between a circle and a focal
   point. A radial gradient is defined by the RadialGradient class.
   com/zetcode/RadialGradientEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.paint.CycleMethod;
import javafx.scene.paint.RadialGradient;
import javafx.scene.paint.Stop;
import javafx.stage.Stage;

public class RadialGradientEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new Pane();

        var canvas = new Canvas(300, 300);
        var gc = canvas.getGraphicsContext2D();
        doDrawing(gc);

        root.getChildren().add(canvas);

        var scene = new Scene(root, 300, 250, Color.WHITESMOKE);

        stage.setTitle("Radial gradient");
        stage.setScene(scene);
        stage.show();
    }

    private void doDrawing(GraphicsContext gc) {

        var stops1 = new Stop[] { new Stop(0, Color.RED),
                new Stop(1, Color.BLACK)};

        var lg1 = new RadialGradient(0, 0, 0.5, 0.5, 0.8, true,
                CycleMethod.NO_CYCLE, stops1);

        gc.setFill(lg1);
        gc.fillOval(30, 30, 150, 150);
    }


    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example fills a circle with a radial gradient.
var stops1 = new Stop[] { new Stop(0, Color.RED),
    new Stop(1, Color.BLACK)};

   We define stop values for the gradient.
var lg1 = new RadialGradient(0, 0, 0.5, 0.5, 0.8, true,
        CycleMethod.NO_CYCLE, stops1);

   A radial gradient is created. The first two parameters are the focus angle and focus distance. The
   next two parameters are the x and y coordinates of the center point of the gradient's circle. The
   fifth parameter is the radius of the circle defining the extents of the color gradient.
   RadialGradient Figure: RadialGradient

JavaFX shapes
   Rectangles, ovals, arcs are basic geometric shapes. The GraphicsContext contains methods for drawing
   outlines and interiors of these shapes.
   com/zetcode/ShapesEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.ArcType;
import javafx.stage.Stage;

public class ShapesEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new Pane();

        var canvas = new Canvas(320, 300);
        var gc = canvas.getGraphicsContext2D();
        drawShapes(gc);

        root.getChildren().add(canvas);

        var scene = new Scene(root, 300, 200, Color.WHITESMOKE);

        stage.setTitle("Shapes");
        stage.setScene(scene);
        stage.show();
    }

    private void drawShapes(GraphicsContext gc) {

        gc.setFill(Color.GRAY);

        gc.fillOval(30, 30, 50, 50);
        gc.fillOval(110, 30, 80, 50);
        gc.fillRect(220, 30, 50, 50);
        gc.fillRoundRect(30, 120, 50, 50, 20, 20);
        gc.fillArc(110, 120, 60, 60, 45, 180, ArcType.OPEN);
        gc.fillPolygon(new double[]{220, 270, 220},
                new double[]{120, 170, 170}, 3);
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example paints six different shapes using the graphics context's fill methods.
gc.setFill(Color.GRAY);

   The shapes are painted in gray colour.
gc.fillOval(30, 30, 50, 50);
gc.fillOval(110, 30, 80, 50);

   The fillOval() method paints a circle and an ellipse. The first two parameters are the x and y
   coordinates. The third and the fourth parameter are the width and height of the oval.
gc.fillRect(220, 30, 50, 50);

   The fillRect() fills a rectangle using the current fill paint.
gc.fillRoundRect(30, 120, 50, 50, 20, 20);

   The fillRoundRect() paints a rectangle, whose corners are rounded. The last two parameters of the
   method are the arc width and arc height of the rectangle corners.
gc.fillArc(110, 120, 60, 60, 45, 180, ArcType.OPEN);

   The fillArc() method fills an arc using the current fill paint. The last three parameters are the
   starting angle, the angular extend, and the closure type.
gc.fillPolygon(new double[]{220, 270, 220},
        new double[]{120, 170, 170}, 3);

   The fillPolygon() method fills a polygon with the given points using the currently set fill paint. In
   our case, it paints a right-angled triangle. The first parameter is an array containing the x
   coordinates of the polygon points, the second parameter is an array containing the y coordinates of
   the polygon points. The last parameter is the number of points that form a polygon.
   Colurs Figure: Colours

JavaFX star shape
   More complex shapes can be drawn with the strokePolygon() and fillPolygon() methods. The next example
   draws a Star shape.
   com/zetcode/StarShapeEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class StarShapeEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new Pane();

        var canvas = new Canvas(300, 300);
        var gc = canvas.getGraphicsContext2D();
        drawStarShape(gc);

        root.getChildren().add(canvas);

        var scene = new Scene(root, 300, 250, Color.WHITESMOKE);

        stage.setTitle("Star");
        stage.setScene(scene);
        stage.show();
    }

    private void drawStarShape(GraphicsContext gc) {

        double[] xpoints = {10, 85, 110, 135, 210, 160,
                170, 110, 50, 60};
        double[] ypoints = {85, 75, 10, 75, 85, 125,
                190, 150, 190, 125};

        gc.strokePolygon(xpoints, ypoints, xpoints.length);
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example draws an outline of a Star shape. The shape consists of ten coordinates.
double[] xpoints = {10, 85, 110, 135, 210, 160,
        170, 110, 50, 60};
double[] ypoints = {85, 75, 10, 75, 85, 125,
        190, 150, 190, 125};

   These are the x and y coordinates of the shape.
gc.strokePolygon(xpoints, ypoints, xpoints.length);

   The shape is drawn with the strokePolygon() method.
   Star shape Figure: Star shape

JavaFX transparent rectangles
   Transparency is the quality of being able to see through a material. In computer graphics, we can
   achieve transparency effects using alpha compositing. Alpha compositing is the process of combining
   an image with a background to create the appearance of partial transparency.
   com/zetcode/TransparentRectanglesEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class TransparentRectanglesEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new Pane();

        var canvas = new Canvas(600, 300);
        var gc = canvas.getGraphicsContext2D();
        drawRectangles(gc);

        root.getChildren().add(canvas);

        var scene = new Scene(root, 600, 100, Color.WHITESMOKE);

        stage.setTitle("Transparent rectangles");
        stage.setScene(scene);
        stage.show();
    }

    private void drawRectangles(GraphicsContext gc) {

        for (int i = 1; i <= 10; i++) {

            float alpha = i * 0.1f;

            gc.setFill(Color.FORESTGREEN);
            gc.setGlobalAlpha(alpha);
            gc.fillRect(50 * i, 20, 40, 40);
        }
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example paints ten rectangles with different levels of transparency.
float alpha = i * 0.1f;

   An alpha value is computed in each of the for cycles.
gc.setGlobalAlpha(alpha);

   The setGlobalAlpha() method sets the global alpha of the current state.
   Transparent rectangles Figure: Transparent rectangles


---
http://zetcode.com/gui/javafx/charts/

JavaFX Charts (part 10)

   In this part of the JavaFX tutorial, we work with charts. In JavaFX, it is possible to build charts
   by adding just a few lines of code.

   In the following examples, we create a line chart, an area chart, a scatter chart, a bar chart, and a
   pie chart.

JavaFX LineChart

   A line chart is a basic type of chart which displays information as a series of data points connected
   by straight line segments. A line chart in JavaFX is created with the javafx.scene.chart.LineChart.
   com/zetcode/LineChartEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.chart.LineChart;
import javafx.scene.chart.NumberAxis;
import javafx.scene.chart.XYChart;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;


public class LineChartEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new HBox();

        var scene = new Scene(root, 450, 330);

        var xAxis = new NumberAxis();
        xAxis.setLabel("Age");

        var yAxis = new NumberAxis();
        yAxis.setLabel("Salary (EUR)");

        var lineChart = new LineChart<>(xAxis, yAxis);
        lineChart.setTitle("Average salary per age");

        var data = new XYChart.Series<Number, Number>();
        data.setName("2016");

        data.getData().add(new XYChart.Data<>(18, 567));
        data.getData().add(new XYChart.Data<>(20, 612));
        data.getData().add(new XYChart.Data<>(25, 800));
        data.getData().add(new XYChart.Data<>(30, 980));
        data.getData().add(new XYChart.Data<>(40, 1410));
        data.getData().add(new XYChart.Data<>(50, 2350));

        lineChart.getData().add(data);

        root.getChildren().add(lineChart);

        stage.setTitle("LineChart");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   In the example, we have a line chart showing average salary per age.
var xAxis = new NumberAxis();
xAxis.setLabel("Age");

var yAxis = new NumberAxis();
yAxis.setLabel("Salary (EUR)");

   Two axes are created with the NumberAxis. The setLabel() method sets a description for the axis.
var lineChart = new LineChart<>(xAxis, yAxis);
lineChart.setTitle("Average salary per age");

   LineChart creates a line chart. The setTitle() method sets a title for the chart.
var data = new XYChart.Series<Number, Number>();
data.setName("2016");

   A XYChart.Series provides data series for the chart. A data series is a list of data points. Each
   data point contains an x value and a y value. The setName() method gives a series a name. (There may
   be multiple of series in one chart.)
data.getData().add(new XYChart.Data<>(18, 567));
data.getData().add(new XYChart.Data<>(20, 612));
...

   We add data to the data series. XYChart.Data is a single data item with data for 2 axis charts.
lineChart.getData().add(data);

   The data is inserted into the chart.
   LineChart Figure: LineChart

JavaFX AreaChart
   An area chart displays graphically quantitative data that change over time.
   com/zetcode/AreaChartEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.chart.AreaChart;
import javafx.scene.chart.CategoryAxis;
import javafx.scene.chart.NumberAxis;
import javafx.scene.chart.XYChart;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;


public class AreaChartEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new HBox();
        var scene = new Scene(root, 490, 350);

        var xAxis = new CategoryAxis();
        xAxis.setLabel("Time");

        var yAxis = new NumberAxis();
        yAxis.setLabel("Thousand bbl/d");

        var areaChart = new AreaChart<>(xAxis, yAxis);
        areaChart.setTitle("Oil consumption");

        var data = new XYChart.Series<String, Number>();

        data.getData().add(new XYChart.Data<>("2004", 82502));
        data.getData().add(new XYChart.Data<>("2005", 84026));
        data.getData().add(new XYChart.Data<>("2006", 85007));
        data.getData().add(new XYChart.Data<>("2007", 86216));
        data.getData().add(new XYChart.Data<>("2008", 85559));
        data.getData().add(new XYChart.Data<>("2009", 84491));
        data.getData().add(new XYChart.Data<>("2010", 87672));
        data.getData().add(new XYChart.Data<>("2011", 88575));
        data.getData().add(new XYChart.Data<>("2012", 89837));
        data.getData().add(new XYChart.Data<>("2013", 90701));

        areaChart.getData().add(data);
        areaChart.setLegendVisible(false);

        root.getChildren().add(areaChart);

        stage.setTitle("AreaChart");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example shows an area chart showing world crude oil consumption by year.
var areaChart = new AreaChart<>(xAxis, yAxis);
areaChart.setTitle("Oil consumption");

   An area chart is created with the AreaChart.
var xAxis = new CategoryAxis();
xAxis.setLabel("Time");

   CategoryAxis works on string categories. We display year strings on this axis.
   AreaChart Figure: AreaChart

JavaFX ScatterChart

   A scatter chart is a set of points plotted on a horizontal and vertical axes.
   com/zetcode/ScatterChartEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.chart.CategoryAxis;
import javafx.scene.chart.NumberAxis;
import javafx.scene.chart.ScatterChart;
import javafx.scene.chart.XYChart;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;


public class ScatterChartEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new HBox();

        var xAxis = new CategoryAxis();
        var yAxis = new NumberAxis("USD/kg", 30, 50, 2);

        var scatterChart = new ScatterChart<>(xAxis, yAxis);

        var data = new XYChart.Series<String, Number>();

        data.getData().add(new XYChart.Data<>("Mar 14", 43));
        data.getData().add(new XYChart.Data<>("Nov 14", 38.5));
        data.getData().add(new XYChart.Data<>("Jan 15", 41.8));
        data.getData().add(new XYChart.Data<>("Mar 15", 37));
        data.getData().add(new XYChart.Data<>("Dec 15", 33.7));
        data.getData().add(new XYChart.Data<>("Feb 16", 39.8));

        scatterChart.getData().add(data);
        scatterChart.setLegendVisible(false);

        var scene = new Scene(root, 450, 330);
        root.getChildren().add(scatterChart);

        stage.setTitle("Gold price");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   In the example, we use the ScatterChart to display gold prices.
var xAxis = new CategoryAxis();

   The x axis is a CategoryAxis used to display dates.
var yAxis = new NumberAxis("USD/kg", 30, 50, 2);

   The y axis is a NumberAxis used to display gold prices. The parameters of the constructor are: axis
   label, lower bound, upper bound, and tick unit.
var data = new XYChart.Series<String, Number>();

data.getData().add(new XYChart.Data<>("Mar 14", 43));
...

   A series of data is created with XYChart.Series and its data items with XYChart.Data.
   ScatterChart Figure: ScatterChart

JavaFX BarChart
   A bar chart presents grouped data with rectangular bars with lengths proportional to the values that
   they represent. The bars can be plotted vertically or horizontally.
   com/zetcode/BarChartEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.chart.BarChart;
import javafx.scene.chart.CategoryAxis;
import javafx.scene.chart.NumberAxis;
import javafx.scene.chart.XYChart;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;


public class BarChartEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new HBox();

        var scene = new Scene(root, 480, 330);
        var xAxis = new CategoryAxis();

        var yAxis = new NumberAxis();
        yAxis.setLabel("Gold medals");

        var barChart = new BarChart<>(xAxis, yAxis);
        barChart.setTitle("Olympic gold medals in London");

        var data = new XYChart.Series<String, Number>();

        data.getData().add(new XYChart.Data<>("USA", 46));
        data.getData().add(new XYChart.Data<>("China", 38));
        data.getData().add(new XYChart.Data<>("UK", 29));
        data.getData().add(new XYChart.Data<>("Russia", 22));
        data.getData().add(new XYChart.Data<>("South Korea", 13));
        data.getData().add(new XYChart.Data<>("Germany", 11));

        barChart.getData().add(data);
        barChart.setLegendVisible(false);

        root.getChildren().add(barChart);

        stage.setTitle("BarChart");
        stage.setScene(scene);
        stage.show();

    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   In the example, we use a bar chart to show the number of Olympic gold medals per country in London
   2012.
var barChart = new BarChart(xAxis, yAxis);

   A bar chart is created with BarChart.
   AreaChart Figure: AreaChart

JavaFX PieChart

   A pie chart is a circular chart which is divided into slices to illustrate numerical proportion.
   com/zetcode/PieChartEx.java

<code>
// package com.zetcode;

import javafx.application.Application;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.Scene;
import javafx.scene.chart.PieChart;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;


public class PieChartEx extends Application {

    @Override
    public void start(Stage stage) {

        initUI(stage);
    }

    private void initUI(Stage stage) {

        var root = new HBox();

        var scene = new Scene(root, 450, 330);

        ObservableList<PieChart.Data> pieChartData
                = FXCollections.observableArrayList(
                new PieChart.Data("Apache", 52),
                new PieChart.Data("Nginx", 31),
                new PieChart.Data("IIS", 12),
                new PieChart.Data("LiteSpeed", 2),
                new PieChart.Data("Google server", 1),
                new PieChart.Data("Others", 2));

        var pieChart = new PieChart(pieChartData);
        pieChart.setTitle("Web servers market share (2016)");

        root.getChildren().add(pieChart);

        stage.setTitle("PieChart");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

</code>

   The example uses a pie chart to show the market share of web servers.
ObservableList<PieChart.Data> pieChartData
        = FXCollections.observableArrayList(
                new PieChart.Data("Apache", 52),
                new PieChart.Data("Nginx", 31),
                new PieChart.Data("IIS", 12),
                new PieChart.Data("LiteSpeed", 2),
                new PieChart.Data("Google server", 1),
                new PieChart.Data("Others", 2));

   Pie chart data items are created with the PieChart.Data.
var pieChart = new PieChart(pieChartData);

   A pie chart is created with the PieChart class.
   PieChart Figure: PieChart

   In this chapter, we have created a LineChart, an AreaChart, a ScatterChart, a BarChart, and a PieChart in
   JavaFX. [http://zetcode.com/java/jfreechart]JFreechart tutorial shows how to create charts in a popular
   JFreechart library.
   

---
