filename: jv_factory-vs-factory-method-vs-abstract-factory-multif_20210927.txt
https://stackoverflow.com/questions/13029261/design-patterns-factory-vs-factory-method-vs-abstract-factory

Design Patterns: Factory vs Factory method vs Abstract Factory

   I was reading design patterns from a website

   There I read about Factory, Factory method and Abstract factory but they are so confusing, am not
   clear on the definition. According to definitions

	 Factory - Creates objects without exposing the instantiation logic to the client and Refers to the
	 newly created object through a common interface. Is a simplified version of Factory Method

	 Factory Method - Defines an interface for creating objects, but let subclasses to decide which
	 class to instantiate and Refers to the newly created object through a common interface.

	 Abstract Factory - Offers the interface for creating a family of related objects, without
	 explicitly specifying their classes.

   I also looked the other stackoverflow threads regarding Abstract Factory vs Factory Method but the
   UML diagrams drawn there make my understanding even worse.

   Can anyone please tell me
	1. How are these three patterns different from each other?
	2. When to use which?
	3. And also if possible, any java examples related to these patterns?

***
	 * 7
	   While I was looking for answers to roughly the same question as the O.P., I found this article:
	   From No Factory to Factory Method. It provides the insight by following the evolution of a
	   sample project (factory method mentioned in the title is one of the evolutionary steps).
	 * I stumbled over this after reading the following article, which describes the problem quite well:
	   "Codeproject- Factory methode vs. abstract factory.

***
   All three Factory types do the same thing: They are a "smart constructor".

   Let's say you want to be able to create two kinds of Fruit: Apple and Orange.

Factory
   Factory is "fixed", in that you have just one implementation with no subclassing. In this case, you
   will have a class like this:
class FruitFactory {

	public Apple makeApple() {
		//Code for creating an Apple here.
	}

	public Orange makeOrange() {
		//Code for creating an orange here.
	}
}

   Use case: Constructing an Apple or an Orange is a bit too complex to handle in the constructor for
   either.

Factory Method
   Factory method is generally used when you have some generic processing in a class, but want to vary
   which kind of fruit you actually use. So:
abstract class FruitPicker {
	protected abstract Fruit makeFruit();
	public void pickFruit() {
		private final Fruitf=makeFruit(); //The fruit we will work on ...
		<blablabla>
	}
}

   ...then you can reuse the common functionality in FruitPicker.pickFruit() by implementing a factory
   method in subclasses:
class OrangePicker extends FruitPicker {
	@Override
	protected Fruit makeFruit() {
		return new Orange();
	}
}

Abstract Factory
   Abstract factory is normally used for things like dependency injection/strategy, when you want to be
   able to create a whole family of objects that need to be of "the same kind", and have some common
   base classes. Here's a vaguely fruit-related example. The use case here is that we want to make sure
   that we don't accidentally use an OrangePicker on an Apple. As long as we get our Fruit and Picker
   from the same factory, they will match.
interface PlantFactory {
	Plant makePlant();
	Picker makePicker();
}

public class AppleFactory implements PlantFactory {
	Plant makePlant() {
		return new Apple();
	}

	Picker makePicker() {
		returni new ApplePicker();
	}
}

public class OrangeFactory implements PlantFactory {
	Plant makePlant() {
		return new Orange();
	}

	Picker makePicker() {
		return new OrangePicker();
	}
}

***
	 * 12
	   +1 This is the answer that is most alike to my understanding of these patterns. Adding examples
	   of calling code (Client) would also help? Question that bothers me a lot is: can we say that
	   Abstract Factory Pattern is just Factory extended with Factory Method Pattern (if this is true,
	   I'm clear on this topic)?
	 * 14
	   This is the example I've spent years looking for.
	 * 1
	   @AndrÃ©Andrade How to invoke the Factory Method ? A small code samle pls :) That will clear my
	   doubt on its usage

***
	1. How are these three patterns different from each other?
   Factory: Creates objects without exposing the instantiation logic to the client.

   Factory Method: Define an interface for creating an object, but let the subclasses decide which class
   to instantiate. The Factory method lets a class defer instantiation to subclasses

   Abstract Factory: Provides an interface for creating families of related or dependent objects without
   specifying their concrete classes.

   AbstractFactory pattern uses composition to delegate responsibility of creating object to another
   class while Factory method design pattern uses inheritance and relies on derived class or sub class
   to create object

	2. When to use which?
   Factory: Client just need a class and does not care about which concrete implementation it is
   getting.

   Factory Method: Client doesn't know what concrete classes it will be required to create at runtime,
   but just wants to get a class that will do the job.

   AbstactFactory: When your system has to create multiple families of products or you want to provide a
   library of products without exposing the implementation details.

   Abstract Factory classes are often implemented with Factory Method. Factory Methods are usually
   called within Template Methods.

	3. And also if possible, any java examples related to these patterns?
   Factory and FactoryMethod

   Intent:
   Define an interface for creating an object, but let sub classes decide which class to instantiate.
   Factory Method lets a class defer instantiation to sub classes.

   Product: It defines an interface of the objects the Factory method creates.

   ConcreteProduct: Implements Product interface

   Creator: Declares the Factory method

   ConcreateCreator: Implements the Factory method to return an instance of a ConcreteProduct

   Problem statement: Create a Factory of Games by using Factory Methods, which defines the game
   interface.

   Comparison with other creational patterns:
	1. Design start out using Factory Method (less complicated, more customizable, subclasses
	   proliferate) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, more
	   complex) as the designer discovers where more flexibility is needed
	2. Abstract Factory classes are often implemented with Factory Methods, but they can also be
	   implemented using Prototype

***
	 * For Factory Method, shouldn't it be define a superclass?

***
   Factory - Separate Factory class to create complex object.

   Ex: FruitFactory class to create object of Fruit
class FruitFactory {
	public static Fruit getFruit() {...}
}

   Factory Method - Instead of whole separate class for factory, just add one method in that class
   itself as a factory.

   Ex:
Calendar.getInstance() (Java's Calendar)

   Abstract Factory Method - Factory of Factory
   Ex: Lets say we want to build factory for computer parts. So there are several types of computers
   like Laptop, Desktop, Server.

   So for each compter type we need factory. So we create one highlevel factory of factories like below
ComputerTypeAbstractFactory.getComputerPartFactory(String computerType) ---> This will return PartFactory whic
h can be one of these ServerPartFactory, LaptopPartFactory, DesktopPartFactory.

   Now these 3 itself are again factories. (You will be dealing with PartFactory itself, but under the
   hood, there will be separate implementation based on what you provided in abstract factory)
  Interface-> PartFactory. getComputerPart(String s),
Implementations -> ServerPartFactory, LaptopPartFactory, DesktopPartFactory.

Usage:
new ComputerTypeAbstractFactory().getFactory("Laptop").getComputerPart("RAM")

***
	 * 1
	   The idea behind the ComputerFactory would be that you have a common creation interface
	   (getScreen(); getKeyboard(); getDiskdrive(); ...), not an interface per computer type as you
	   suggest. You can smell a design issue if you use the same word twice in the same statement:
	   LaptopFactory.getLaptopPart().
	 * No no no, don't go exactly on code itself. It was just an anology for understanding. If you want
	   exact example with interfaces, here it is. Objects: Interface -> ComputerPart, Implementation ->
	   RAM, HDD, Processor Factory: Interface-> PartFactory. getComputerPart(String s), Implementations
	   -> ServerPartFactory, LaptopPartFactory, DesktopPartFactory. Abstract Factory:
	   ComputerType.getPartFactory("String s") Usage: new
	   ComputerType().getFactory("Laptop").getComputerPart("RAM")
	 * 2
	   I have updated answer to take care of your concern. Actually abstract factory is nothing but
	   factoy of factory only. I gave earlier example just for reference (Assuming readers will take
	   care of interfaces while actual implementation). Still thanks for notifying. Its always good to
	   improve. :)
	 * No abstract Factory is not a factory of factory... It's an abstract class or an interface able to
	   create object that will be implemented/extended with different concrete factories. See the
	   accepted answer for code details. And please remove or edit your answer accordingly.
	 * 1
	   I like the explanation of factory method, which is concise enough to unveil why it is so named.
	   In this pattern, the factory is the method, NOT the class who is generally not a helper utility
	   grouping instantiation methods but meaningful on its own. Other more elaborate answers
	   unfortunately missed this point.

***
   Every design pattern strives to help ensure that written, working code is not touched. We all know
   that once we touch working code, there are defects in existing working flows, and a lot more testing
   needs to get done to ensure that we did not break anything.

   A factory pattern creates objects based on input criteria, thus ensuring that you dont need to write
   code like:
 if (this) {
	 create this kind of object
 } else {
	 that kind of object
 }

   A good example of this is a travel website. A travel website can only provide travel (flight, train,
   bus) or / and provide hotels or / and provide tourist attraction packages. Now, when a user selects
   next, the website needs to decide what objects it needs to create. Should it only create the travel
   or hotel object too.

   Now, if you envision adding another website to your portfolio, and you believe that the same core be
   used, for example, a carpooling website, which now searches for cab's and makes payments online, you
   can use a abstract factory at your core. This way you can just snap in one more factory of cabs and
   carpools.

   Both factories have nothing to do with each other, so it's a good design to keep them in different
   factories.

   Hope this is clear now. Study the website again keeping this example in mind, hopefully it will help.
   And I really hope I have represented the patterns correctly :).

***
   For this answer, I refer to the "Gang of Four" book.

   There are no "Factory" nor "Simple Factory" nor "Virtual Factory" definitions in the book. Usually
   when people are talking about "Factory" pattern they may be talking about something that creates a
   particular object of a class (but not the "builder" pattern); they may or may not refer to the
   "Factory Method" or "Abstract Factory" patterns. Anyone can implement "Factory" as he won't because
   it's not a formal term (bear in mind that some people\companies\communities can have their own
   vocabulary).

   The book only contains definitions for "Abstract Factory" and "Factory Method".

   Here are definitions from the book and a short explanation of why both can be so confusing. I omit
   code examples because you can find them in other answers:

   Factory Method (GOF): Define an interface for creating an object, but let subclasses decide which
   class to instantiate. Factory Method lets a class defer instantiation to subclasses.

   Abstract Factory (GOF): Provide an interface for creating families of related or dependent objects
   without specifying their concrete classes.

   Source of Confusion: Often, one can call a class that used in "Factory Method" pattern as "Factory".
   This class is abstract by definition. That's why it easy to call this class "Abstract Factory". But
   it's just the name of the class; you shouldn't confuse it with "Abstract Factory" pattern (class name
   != pattern name). The "Abstract Factory" pattern is different - it does not use an abstract class; it
   defines an interface (not necessarily a programming language interface) for creating parts of a
   bigger object or objects that are related to each other or must be created in a particular way.

***
   Based this images from Design Patterns in C#, 2nd Edition by Vaskaran Sarcar book:

	 1. Simple Factory Pattern
   Creates objects without exposing the instantiation logic to the client.
SimpleFactory simpleFactory = new SimpleFactory();
IAnimal dog = simpleFactory.CreateDog(); // Create dog
IAnimal tiger = simpleFactory.CreateTiger(); // Create tiger

	 2. Factory Method Pattern
   Defines an interface for creating objects, but let subclasses to decide which class to instantiate.
AnimalFactory dogFactory = new DogFactory();
IAnimal dog = dogFactory.CreateAnimal(); // Create dog

AnimalFactory tigerFactory = new TigerFactory();
IAnimal tiger = tigerFactory.CreateAnimal(); // Create tiger

	 3. Abstract Factory pattern (factory of factories)
   Abstract Factory offers the interface for creating a family of related objects, without explicitly
   specifying their classes
IAnimalFactory petAnimalFactory = FactoryProvider.GetAnimalFactory("pet");
IDog dog = petAnimalFactory.GetDog(); // Create pet dog
ITiger tiger = petAnimalFactory.GetTiger();  // Create pet tiger

IAnimalFactory wildAnimalFactory = FactoryProvider.GetAnimalFactory("wild");
IDog dog = wildAnimalFactory .GetDog(); // Create wild dog
ITiger tiger = wildAnimalFactory .GetTiger();  // Create wild tiger

***
AbstractProductA, A1 and A2 both implementing the AbstractProductA
AbstractProductB, B1 and B2 both implementing the AbstractProductB

interface Factory {
	AbstractProductA getProductA(); //Factory Method - generate A1/A2
}

   Using Factory Method, user can able to create A1 or A2 of AbstractProductA.
interface AbstractFactory {
	AbstractProductA getProductA(); //Factory Method
	AbstractProductB getProductB(); //Factory Method
}

   But Abstract Factory having more than 1 factory method ( ex: 2 factory methods), using those factory
   methods it will create the set of objects/ related objects. Using Abstract Factory, user can able to
   create A1, B1 objects of AbstractProductA, AbstractProductB

***
   Nobody has quoted the original book Design Patterns: Elements of Reusable Object-Oriented
   Software, which gives the answer in the first two paragraphs of the section "Discussion of Creational
   Patterns" (emphasis mine):

	 There are two common ways to parameterize a system by the classes of objects it creates. One way
	 is to subclass the class that creates the objects; this corresponds to using the Factory Method
	 (107) pattern. The main drawback of this approach is that it can require a new subclass just to
	 change the class of the product. Such changes can cascade. For example, when the product creator
	 is itself created by a factory method, then you have to override its creator as well.

	 The other way to parameterize a system relies more on object composition: Define an object that's
	 responsible for knowing the class of the product objects, and make it a parameter of the system.
	 This is a key aspect of the Abstract Factory (87), Builder (97), and Prototype (117) patterns. All
	 three involve creating a new "factory object" whose responsibility is to create product objects.
	 Abstract Factory has the factory object producing objects of several classes. Builder has the
	 factory object building a complex product incrementally using a correspondingly complex protocol.
	 Prototype has the factory object building a product by copying a prototype object. In this case,
	 the factory object and the prototype are the same object, because the prototype is responsible for
	 returning the product.



---
https://www.geeksforgeeks.org/factory-method-design-pattern-in-java

Factory method design pattern in Java
05 Nov, 2020

   It is a creational design pattern which talks about the creation of an object. The factory design
   pattern says that define an interface ( A java interface or an abstract class) and let the subclasses
   decide which object to instantiate. The factory method in the interface lets a class defer the
   instantiation to one or more concrete subclasses. Since this design patterns talk about instantiation
   of an object and so it comes under the category of creational design pattern. If we notice the name
   Factory method, that means there is a method which is a factory, and in general factories are
   involved with creational stuff and here with this an object is being created. It is one of the best
   ways to create an object where object creation logic is hidden to the client. Now Let's look at the
   implementation.

   Implementation:
   1. Define a factory method inside an interface.
   2. Let the subclass implements the above factory method and decide which object to create.
   In Java constructors are not polymorphic, but by allowing subclass to create an object, we are adding
   polymorphic behavior to the instantiation. In short, we are trying to achieve Pseudo polymorphism by
   letting the subclass to decide what to create, and so this Factory method is also called as

   Virtual constructor. Let's try to implement it with a real-time problem and some coding exercise.

   Problem Statement :
   Consider we want to implement a notification service through email, SMS, and push notification. Let's
   try to implement this with the help of factory method design pattern. First we will design a UML
   class diagram for this.

   In the above class diagram we have an interface called Notification, and three concrete classes are
   implementing Notification interface. A factory class NotificationFactory is created to get a
   Notification object. Let's jump into the coding now.

   Create Notification interface

public interface Notification {
	   void notifyUser();
}

   Note- Above interface could be created as an abstract class as well.
   Create all implementation classes
SMSNotification.java

public class SMSNotification implements Notification {
	@Override
	public void notifyUser() {
		//TODO Auto-generated method stub
		System.out.println("Sending an SMS notification");
	}
}


EmailNotification.java

public class EmailNotification implements Notification {

	@Override
	public void notifyUser() {
		//TODO Auto-generated method stub
		System.out.println("Sending an e-mail notification");
	}
}


PushNotification.java

public class PushNotification implements Notification {

	@Override
	public void notifyUser() {
		//TODO Auto-generated method stub
		System.out.println("Sending a push notification");
	}
}


   Create a factory class NotificationFactory.java to instantiate concrete class.

public class NotificationFactory {
	public Notification createNotification(String channel) {
		if (channel==null || channel.isEmpty())
			returnnull;
		if ("SMS".equals(channel)) {
			return new SMSNotification();
		}
		elseif ("EMAIL".equals(channel)) {
			return new EmailNotification();
		}
		elseif ("PUSH".equals(channel)) {
			return new PushNotification();
		}
		return null;
	}
}


   Now let's use factory class to create and get an object of concrete class by passing some
   information.

public class NotificationService {
	public static void main(String[]args) {
		NotificationFactory notificationFactory=new NotificationFactory();
		Notification notification=notificationFactory.createNotification("SMS");
		notification.notifyUser();
	}
}


Output : Sending an SMS notification

   Real-time examples
   This design pattern has been widely used in JDK, such as
   1. getInstance() method of java.util.Calendar, NumberFormat, and ResourceBundle uses factory method
   design pattern.
   2. All the wrapper classes like Integer, Boolean etc, in Java uses this pattern to evaluate the
   values using valueOf() method.
   3. java.nio.charset.Charset.forName(), java.sql.DriverManager#getConnection(),
   java.net.URL.openConnection(), java.lang.Class.newInstance(), java.lang.Class.forName() are some of
   ther example where factory method design pattern has been used.

   Conclusion
   So far we learned what is Factory method design pattern and how to implement it. I believe now we
   have a fair understanding of the advantage of this design mechanism.


---
https://www.journaldev.com/1392/factory-design-pattern-in-java

Design Pattern Tutorials
	 * 1. Java Design Patterns
	 * 2. Singleton
	 * 3. Factory
	 * 4. Abstract Factory
	 * 5. Builder
	 * 6. Prototype
	 * 7. Adapter
	 * 8. Composite
	 * 9. Proxy
	 * 10. Flyweight
	 * 11. Facade
	 * 12. Bridge
	 * 13. Decorator
	 * 14. Template Method
	 * 15. Mediator
	 * 16. Chain of Responsibility
	 * 17. Observer
	 * 18. Strategy
	 * 19. Command
	 * 20. State
	 * 21. Visitor
	 * 22. Interpreter
	 * 23. Iterator
	 * 24. Memento
	 * 25. Dependency Injection
	 * 26. Thread Safety in Java Singleton

   Welcome to the Factory Design Pattern in Java tutorial. Factory Pattern is one of the Creational
   Design pattern and it's widely used in JDK as well as frameworks like Spring and Struts.

Factory Design Pattern
   factory design pattern, factory design pattern in java, factory pattern, factory method pattern,
   factory pattern example factory design pattern, factory design pattern in java, factory pattern,
   factory method pattern, factory pattern example

   The factory design pattern is used when we have a superclass with multiple sub-classes and based on
   input, we need to return one of the sub-class. This pattern takes out the responsibility of the
   instantiation of a class from the client program to the factory class.

   Let's first learn how to implement a factory design pattern in java and then we will look into
   factory pattern advantages. We will see some of the factory design pattern usage in JDK. Note that
   this pattern is also known as Factory Method Design Pattern.

Factory Design Pattern Super Class
   Super class in factory design pattern can be an interface, abstract class or a normal java class.
   For our factory design pattern example, we have abstract super class with overridden toString()
   method for testing purpose.
<code>
package com.journaldev.design.model;

public abstract class Computer {
	public abstract String getRAM();
	public abstract String getHDD();
	public abstract String getCPU();

	@Override
	public String toString() {
		return "RAM= "+this.getRAM()+", HDD="+this.getHDD()+", CPU="+this.getCPU();
	}
}
</code>

Factory Design Pattern Sub Classes
   Let's say we have two sub-classes PC and Server with below implementation.
<code>
package com.journaldev.design.model;

public class PC extends Computer {

	private String ram;
	private String hdd;
	private String cpu;

	public PC(String ram, String hdd, String cpu) {
		this.ram=ram;
		this.hdd=hdd;
		this.cpu=cpu;
	}
	@Override
	public String getRAM() {
		return this.ram;
	}

	@Override
	public String getHDD() {
		return this.hdd;
	}

	@Override
	public String getCPU() {
		return this.cpu;
	}

}
</code>

   Notice that both the classes are extending Computer super class.
<code>
package com.journaldev.design.model;

public class Server extends Computer {

	private String ram;
	private String hdd;
	private String cpu;

	public Server(String ram, String hdd, String cpu) {
		this.ram=ram;
		this.hdd=hdd;
		this.cpu=cpu;
	}

	@Override
	public String getRAM() {
		return this.ram;
	}

	@Override
	public String getHDD() {
		return this.hdd;
	}

	@Override
	public String getCPU() {
		return this.cpu;
	}

}
</code>

Factory Class
   Now that we have super classes and sub-classes ready, we can write our factory class. Here is the
   basic implementation.
<code>
package com.journaldev.design.factory;

import com.journaldev.design.model.Computer;
import com.journaldev.design.model.PC;
import com.journaldev.design.model.Server;

public class ComputerFactory {

	public static Computer getComputer(String type, String ram, String hdd, String cpu) {
		if ("PC".equalsIgnoreCase(type)) return new PC(ram, hdd, cpu);
		else if ("Server".equalsIgnoreCase(type)) return new Server(ram, hdd, cpu);

		return null;
	}
}
</code>

   Some important points about Factory Design Pattern method are;
	1. We can keep Factory class Singleton or we can keep the method that returns the subclass as
	   static.
	2. Notice that based on the input parameter, different subclass is created and returned. getComputer
	   is the factory method.

   Here is a simple test client program that uses above factory design pattern implementation.
<code>
package com.journaldev.design.test;

import com.journaldev.design.factory.ComputerFactory;
import com.journaldev.design.model.Computer;

public class TestFactory {

	public static void main(String[] args) {
		Computer pc = ComputerFactory.getComputer("pc","2 GB","500 GB","2.4 GHz");
		Computer server = ComputerFactory.getComputer("server","16 GB","1 TB","2.9 GHz");
		System.out.println("Factory PC Config::"+pc);
		System.out.println("Factory Server Config::"+server);
	}

}
</code>

   Output of above program is:
Factory PC Config::RAM= 2 GB, HDD=500 GB, CPU=2.4 GHz
Factory Server Config::RAM= 16 GB, HDD=1 TB, CPU=2.9 GHz

Factory Design Pattern Advantages
	1. Factory design pattern provides approach to code for interface rather than implementation.
	2. Factory pattern removes the instantiation of actual implementation classes from client code.
	   Factory pattern makes our code more robust, less coupled and easy to extend. For example, we can
	   easily change PC class implementation because client program is unaware of this.
	3. Factory pattern provides abstraction between implementation and client classes through
	   inheritance.

Factory Design Pattern Examples in JDK
	1. java.util.Calendar, ResourceBundle and NumberFormat getInstance() methods uses Factory pattern.
	2. valueOf() method in wrapper classes like Boolean, Integer etc.

Factory Design Pattern YouTube Video Tutorial

   I recently uploaded a video on YouTube for Factory Design pattern, please check it out. Please like
   and share the video and subscribe to my YouTube channel.

   https://www.youtube.com/embed/J1QU_R4MQQc?feature=oembed



---
https://www.tutorialspoint.com/design_pattern/factory_pattern.htm

Design Pattern - Factory Pattern

   Factory pattern is one of the most used design patterns in Java. This type of design pattern comes
   under creational pattern as this pattern provides one of the best ways to create an object.

   In Factory pattern, we create object without exposing the creation logic to the client and refer to
   newly created object using a common interface.

Implementation
   We're going to create a Shape interface and concrete classes implementing the Shape interface. A
   factory class ShapeFactory is defined as a next step.

   FactoryPatternDemo, our demo class will use ShapeFactory to get a Shape object. It will pass
   information (CIRCLE / RECTANGLE / SQUARE) to ShapeFactory to get the type of object it needs.
   Factory Pattern UML Diagram

Step 1
   Create an interface.

   Shape.java
public interface Shape {
	void draw();
}

Step 2
   Create concrete classes implementing the same interface.

   Rectangle.java
public class Rectangle implements Shape {

	@Override
	public void draw() {
		System.out.println("InsideRectangle::draw()method.");
	}
}

   Square.java
public class Square implements Shape {

	@Override
	public void draw() {
		System.out.println("InsideSquare::draw()method.");
	}
}

   Circle.java
public class Circle implements Shape {

	@Override
	public void draw() {
		System.out.println("InsideCircle::draw()method.");
	}
}

Step 3

   Create a Factory to generate object of concrete class based on given information.

   ShapeFactory.java
public class ShapeFactory {

	//use getShape method to get object of type shape
	public Shape getShape(String shapeType) {
		if (shapeType==null) {
			return null;
		}
		if (shapeType.equalsIgnoreCase("CIRCLE")) {
			return new Circle();

		} elseif (shapeType.equalsIgnoreCase("RECTANGLE")) {
			return new Rectangle();

		} elseif (shapeType.equalsIgnoreCase("SQUARE")) {
			return new Square();
		}
		return null;
	}
}

Step 4
   Use the Factory to get object of concrete class by passing an information such as type.

   FactoryPatternDemo.java
public class FactoryPatternDemo {

	public static void main(String[]args){
		ShapeFactory shapeFactory=newShapeFactory();

		//get an object of Circle and call its draw method.
		Shape shape1=shapeFactory.getShape("CIRCLE");

		//call draw method of Circle
		shape1.draw();

		//get an object of Rectangle and call its draw method.
		Shape shape2=shapeFactory.getShape("RECTANGLE");

		//call draw method of Rectangle
		shape2.draw();

		//get an object of Square and call its draw method.
		Shape shape3=shapeFactory.getShape("SQUARE");

		//call draw method of square
		shape3.draw();
	}
}

Step 5
   Verify the output.

Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.



---
https://stackoverflow.com/questions/51863551/why-to-use-factory-method-pattern-instead-of-simple-factory/51868190

'Why to use Factory method pattern instead of Simple factory'

   Im trying to understand when to use Factory method pattern compared to Simple factory, I know how
   each implements but I don't exactly get the point of it.

   Let's assume I have client that provides string(name of the car) and based on that string, factory
   provides object.

   I know that method factory satisfies open/closed principle and if I had new car brand for example
   Mercedes, I would have to edit switch case and add new brand and that would be bad practice. But then
   with Factory method my factory can't decide on which object to make because there is no switch case.
   I guess I'm missing a point here. Maybe I should use factory method if I had diffrent logic/strategy
   on creating car object, maybe one that makes random car object and one that takes string and makes
   object based on that string.

   Also would It be a good practice if I used in Factory Method getCar() function and do some more logic
   there, like maybe car.tuneEngine() etc. before returning ready to use object?

   Simple factory
public class FordCar extends Car {

	public FordCar() {
		super("Ford", "Mondeo", 1.6);
		// TODO Auto-generated constructor stub
	}

	@Override
	public void move() {
		System.out.println("Ford moves");
	}
}

public class CarFactory {

	public Car getCar(String brand) {
		switch (brand) {
		case "ferrari":
			return new FerrariCar();
		case "ford":
			return new FordCar();
		default:
			return null;
		}
	}
}

public class Client {

	public static void main(String[] args) {
		//Simple factory
		CarFactory carFactory = new CarFactory();
		Car clientSimpleCar = carFactory.getCar("ford");
		clientSimpleCar.move();
	}
}

   Factory method pattern
public abstract class CarMethodFactory {

	public Car getCar() {
		Car car = createCar();
		return car;
	}

	public abstract Car createCar();
}

public class FordMethodFactory extends CarMethodFactory{

	@Override
	public Car createCar() {
		return new FordCar();
	}
}

public class Client {

	public static void main(String[] args) {
		CarMethodFactory carMethodFactory = new FordMethodFactory();
		Car clientMethodCar = carMethodFactory.getCar();
		clientMethodCar.move();
	}
}


***
	 * Possible duplicate of Design Patterns: Factory vs Factory method vs Abstract Factory
	 * 1
	   You have your patterns all wrong - first is indeed a factory, second is an Abstract Factory
	   pattern. By method factory, I assume you mean static method factory pattern - that is neither of
	   the above.
	 * @BoristheSpider How is the second one an abstract factory? Abstract factory is used for family of
	   objects. There is only one type of object in his example, which is Car. The factory method
	   pattern has abstract create function, which confuses most of the people to think it's abstract
	   factory pattern. So, his examples are on point.

***
   For learning purposes it might make sense to stay with the GoF definitions of Factory Method and
   Abstract Factory. GoF is a common point reference and discussion around the basic patterns. Its best
   to be wary of many of the "examples" found on several advertisement filled sites because some
   examples are at best misleading.

   Sticking with GoF there are 2 factory patterns Factory Method and Abstract Factory.

   Simple Factory is not a separate pattern, it is a special case of Factory Method. There is no mention
   of Simple Factory pattern as a named pattern in Gof. See below.

   Factory Method: This does NOT involve a Factory object. It involves Factory methods() as the name
   suggests.

   Example: Consider a base TextEditor class with subclasses for C#, PHP, JS, HTML etc. Each subclass
   needs its own SyntaxChecker object. The TextEditor base class has an abstract CreateSyntaxChecker()
   method and each subclass of TextEditor implements CreateSyntaxChecker() interface and returns the
   specific SyntaxChecker needed by the subclass. Consider pseudo code below for typical use.
Editor = new PHPTextEditor;  // instantiates PHP subclass of  TextEditor
_syntaxChecker = this->CreateSyntaxChecker();	  // The constructor of
PHPTextEditor invokes its over-ridden CreateSyntaxChecker() method, which returns
the correct PHP SyntaxChecker object.

   This complies with GoF Intent of Factory Method. "Define an interface for creating an object, but let
   subclasses decide which class to instantiate".

   "Simple Factory": is a variation of Factory Method. In this variation, using the text editor example,
   the TextEditor base class has an concrete (instead of abstract) method CreateSyntaxChecker(), which
   may or not be over-ridden in subclasses, and if not over-ridden, the base class implementation is
   used.

   Abstract Factory: The GoF Intent of Abstract Factory is to "provide an interface for creating
   families of related or dependent object, without speciifying their concrete classes". What this means
   in practice is creating an abstract Factory class, whose subclasses define how to create families of
   related objects.

   Example: Extending the TextEditor example, we realise that also need language specific Formatter, and
   Debug modules in addition to SyntaxChecker. (We could achieve this by multiple applications of
   Factory Method, but this involves editing several classes). Define an abstract Factory class with 3
   abstract methods CreateSyntaxChecker(), CreateDebugger(), CreateFormatter(). Then define subclass
   PHPFactory, JSFactory, HTMLFactory etc each of which provide implementations for the 3 methods and
   return the correct object instances.

   Consider pseudo code below for typical use.
Factory = new PHPFactory();
Editor = new PHPEditor(Factory);	// Constructor of PHPEditor will invoke the 3
Factory methods to instantiate the correct versions of the SyntaxChecker, Debugger
and Formatter objects.

   I strongly suggest refactoring your code to comply with the GoF "standard" as a starting point,
   especially when learning. Later feel free to adapt and adjust to suit your needs, when you are sure
   of what you are doing :-).

***
   Factory Method is preferred when inheritance is preferred, because that pattern is implemented
   through inheritance.

   Simple Factory is preferred only when tight coupling is acceptable, because that pattern couples the
   client to the factory implementation class.

   Abstract Factory is preferred when loose coupling is desired, which is almost always.

***
   You can replace switch with enum if you like and simple iteration over list of allowed enum will
   return your desired object. What i can see from the code is that the first one is using delegation,
   and the second one couples your client with the concrete factory. I would prefer the first one here.


---
https://howtodoinjava.com/design-patterns/creational/implementing-factory-design-pattern-in-java

Java Factory Pattern Explained
August 24, 2021

   What is the most usual method of creating an instance of a class in java? Most people will answer
   this question: "using new keyword". Well, it is considered old-fashioned now. Let's see how??

   If object creation code is spread in the whole application, and if you need to change the process of
   object creation then you need to go in each and every place to make necessary changes. After
   finishing this article, while writing your application, consider using the Java factory pattern.

   In my previous post, "Singleton design pattern in java", we discussed various ways to create an
   instance of a class such that there can not exist another instance of same class in same JVM.

   In this post, I will demonstrate another creational pattern, i.e. Factory pattern, for creating
   instances for your classes. Factory, as the name suggests, is a place to create some different
   products which are somehow similar in features yet divided into categories.

   In Java, factory pattern is used to create instances of different classes of the same type.
Table of Contents

1. When to implement factory pattern?
2. Factory Pattern Implementation
3. Advantages of factory pattern
4. Final notes

1. When to use factory pattern?
   Factory pattern introduces loose coupling between classes which is the most important principle one
   should consider and apply while designing the application architecture. Loose coupling can be
   introduced in application architecture by programming against abstract entities rather than concrete
   implementations. This not only makes our architecture more flexible but also less fragile.

   A picture is worth a thousand words. Let's see how a factory implementation will look like.

   Above class-diagram depicts a common scenario using an example of a car factory which is able to
   build 3 types of cars i.e. small, sedan and luxury. Building a car requires many steps from
   allocating accessories to final makeup. These steps can be written in programming as methods and
   should be called while creating an instance of a specific car type.

   If we are unfortunate then we will create instances of car types (e.g. SmallCar) in our application
   classes and thus we will expose the car building logic to the outside world and this is certainly not
   good. It also prevents us in making changes to car making process because the code is not
   centralized, and making changes in all composing classes seems not feasible.

2. Java Factory Pattern Example
   So far we have design the classes need to be designed for making a CarFactory. Let's create them now.

2.1. Object types
   CarType will hold the types of car and will provide car types to all other classes.
package designPatterns.creational.factory;

public enum CarType {
	SMALL, SEDAN, LUXURY
}

2.2. Object implementations
   Car is parent class of all car instances and it will also contain the common logic applicable in car
   making of all types.
package designPatterns.creational.factory;

public abstract class Car {
	public Car(CarType model) {
		this.model = model;
		arrangeParts();
	}

	private void arrangeParts() {
		// Do one time processing here
	}

	// Do subclass level processing in this method
	protected abstract void construct();

	private CarType model = null;

	public CarType getModel() {
		return model;
	}

	public void setModel(CarType model) {
		this.model = model;
	}
}

   LuxuryCar is concrete implementation of car type LUXURY.
package designPatterns.creational.factory;

public class LuxuryCar extends Car {

	LuxuryCar() {
		super(CarType.LUXURY);
		construct();
}

	@Override
	protected void construct() {
		System.out.println(&quot;Building luxury car&quot;);
		// add accessories
	}
}

   SmallCar is concrete implementation of car type SMALL.
package designPatterns.creational.factory;

public class SmallCar extends Car {

	SmallCar() {
		super(CarType.SMALL);
		construct();
	}

	@Override
	protected void construct() {
		System.out.println(&quot;Building small car&quot;);
		// add accessories
	}
}

   SedanCar is concrete implementation of car type SEDAN.
package designPatterns.creational.factory;

public class SedanCar extends Car {

	SedanCar() {
		super(CarType.SEDAN);
		construct();
	}

	@Override
	protected void construct() {
		System.out.println(&quot;Building sedan car&quot;);
		// add accessories
	}
}

2.3. Factory to create objects
   CarFactory.java is our main class implemented using factory pattern. It instantiates a car instance
   only after determining its type.
package designPatterns.creational.factory;

public class CarFactory {
	public static Car buildCar(CarType model) {
		Car car = null;
		switch (model) {
			case SMALL:
				car = new SmallCar();
				break;

			case SEDAN:
				car = new SedanCar();
				break;

			case LUXURY:
				car = new LuxuryCar();
				break;

			default:
				// throw some exception
				break;
		}
		return car;
	}
}

2.4. Test factory pattern
   In TestFactoryPattern, we will test our factory code. Lets run this class.
package designPatterns.creational.factory;

public class TestFactoryPattern {
	public static void main(String[] args) {
		System.out.println(CarFactory.buildCar(CarType.SMALL));
		System.out.println(CarFactory.buildCar(CarType.SEDAN));
		System.out.println(CarFactory.buildCar(CarType.LUXURY));
	}
}

   Program Output.
Building small car
designPatterns.creational.factory.SmallCar@7c230be4
Building sedan car
designPatterns.creational.factory.SedanCar@60e1e567
Building luxury car
designPatterns.creational.factory.LuxuryCar@e9bfee2

   As you can see, the factory is able to return any type of car instance it is requested for. It will
   help us in making any kind of changes in car making process without even touching the composing
   classes i.e. classes using CarFactory.

3. Benefits of factory pattern
   By now, you should be able to count the main advantages of using the factory pattern. Let's note
   down:
	1. The creation of an object precludes its reuse without significant duplication of code.
	2. The creation of an object requires access to information or resources that should not be
	   contained within the composing class.
	3. The lifetime management of the generated objects must be centralized to ensure a consistent
	   behavior within the application.

4. Final notes
   Factory pattern is most suitable where there is some complex object creation steps are involved. To
   ensure that these steps are centralized and not exposed to composing classes, factory pattern should
   be used. We can see many realtime examples of factory pattern in JDK itself e.g.
	 * java.sql.DriverManager#getConnection()
	 * java.net.URL#openConnection()
	 * java.lang.Class#newInstance()
	 * java.lang.Class#forName()

   I hope, I have included enough information in this Java factory pattern example to make this post
   informative.

   If you still have some doubt on abstract factory design pattern in Java, please leave a comment. I
   will be happy to discuss with you.




---

