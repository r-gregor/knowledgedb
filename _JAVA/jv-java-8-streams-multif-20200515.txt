filename: jv_java-8-streams-multif_20200515.txt
https://www.geeksforgeeks.org/stream-in-java/

Stream In Java

   Introduced in Java 8, the Stream API is used to process collections of objects. A stream is a
   sequence of objects that supports various methods which can be pipelined to produce the desired
   result.
   The features of Java stream are -
     * A stream is not a data structure instead it takes input from the Collections, Arrays or I/O
       channels.
     * Streams don't change the original data structure, they only provide the result as per the
       pipelined methods.
     * Each intermediate operation is lazily executed and returns a stream as a result, hence various
       intermediate operations can be pipelined. Terminal operations mark the end of the stream and
       return the result.

   Different Operations On Streams-
   Intermediate Operations:
    1. map: The map method is used to returns a stream consisting of the results of applying the given
       function to the elements of this stream.
       List number = Arrays.asList(2,3,4,5);
       List square = number.stream().map(x->x*x).collect(Collectors.toList());
    2. filter: The filter method is used to select elements as per the Predicate passed as argument.
       List names = Arrays.asList("Reflection","Collection","Stream");
       List result = names.stream().filter(s->s.startsWith("S")).collect(Collectors.toList());
    3. sorted: The sorted method is used to sort the stream.
       List names = Arrays.asList("Reflection","Collection","Stream");
       List result = names.stream().sorted().collect(Collectors.toList());

   Terminal Operations:
    1. collect: The collect method is used to return the result of the intermediate operations performed
       on the stream.
       List number = Arrays.asList(2,3,4,5,3);
       Set square = number.stream().map(x->x*x).collect(Collectors.toSet());
    2. forEach: The forEach method is used to iterate through every element of the stream.
       List number = Arrays.asList(2,3,4,5);
       number.stream().map(x->x*x).forEach(y->System.out.println(y));
    3. reduce: The reduce method is used to reduce the elements of a stream to a single value.
       The reduce method takes a BinaryOperator as a parameter.
       List number = Arrays.asList(2,3,4,5);
       int even = number.stream().filter(x->x%2==0).reduce(0,(ans,i)-> ans+i);
       Here ans variable is assigned 0 as the initial value and i is added to it .

   Program to demonstrate the use of Stream

<code>
//a simple program to demonstrate the use of stream in java
import java.util.*;
import java.util.stream.*;

class Demo
{
    public static void main(String args[])
    {

        // create a list of integers
        List<Integer> number = Arrays.asList(2,3,4,5);

        // demonstration of map method
        List<Integer> square = number.stream().map(x -> x*x).
            collect(Collectors.toList());
        System.out.println(square);

        // create a list of String
        List<String> names =
            Arrays.asList("Reflection","Collection","Stream");

        // demonstration of filter method
        List<String> result = names.stream().filter(s->s.startsWith("S")).
            collect(Collectors.toList());
        System.out.println(result);

        // demonstration of sorted method
        List<String> show =
            names.stream().sorted().collect(Collectors.toList());
        System.out.println(show);

        // create a list of integers
        List<Integer> numbers = Arrays.asList(2,3,4,5,2);

        // collect method returns a set
        Set<Integer> squareSet =
            numbers.stream().map(x->x*x).collect(Collectors.toSet());
        System.out.println(squareSet);

        // demonstration of forEach method
        number.stream().map(x->x*x).forEach(y->System.out.println(y));

        // demonstration of reduce method
        int even =
            number.stream().filter(x->x%2==0).reduce(0,(ans,i)-> ans+i);

        System.out.println(even);
    }
}
</code>


   Output:
[4, 9, 16, 25]
[Stream]
[Collection, Reflection, Stream]
[16, 4, 9, 25]
4
9
16
25
6

   Important Points/Observations:
    1. A stream consists of source followed by zero or more intermediate methods combined together
       (pipelined) and a terminal method to process the objects obtained from the source as per the
       methods described.
    2. Stream is used to compute elements as per the pipelined methods without altering the original
       value of the object.



---
https://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/

Java 8 Stream Tutorial
July 31, 2014

   This example-driven tutorial gives an in-depth overview about Java 8 streams. When I first read about
   the Stream API, I was confused about the name since it sounds similar to InputStream and OutputStream
   from Java I/O. But Java 8 streams are a completely different thing. Streams are Monads, thus
   playing a big part in bringing functional programming to Java:

     In functional programming, a monad is a structure that represents computations defined as
     sequences of steps. A type with a monad structure defines what it means to chain operations, or
     nest functions of that type together.

   This guide teaches you how to work with Java 8 streams and how to use the different kind of available
   stream operations. You'll learn about the processing order and how the ordering of stream operations
   affect runtime performance. The more powerful stream operations reduce, collect and flatMap are
   covered in detail. The tutorial ends with an in-depth look at parallel streams.

   If you're not yet familiar with Java 8 lambda expressions, functional interfaces and method
   references, you probably want to read my [**1]Java 8 Tutorial first before starting with this
   tutorial.

How streams work
   A stream represents a sequence of elements and supports different kind of operations to perform
   computations upon those elements:
List<String> myList =
    Arrays.asList("a1", "a2", "b1", "c2", "c1");

myList
    .stream()
    .filter(s -> s.startsWith("c"))
    .map(String::toUpperCase)
    .sorted()
    .forEach(System.out::println);

// C1
// C2

   Stream operations are either intermediate or terminal. Intermediate operations return a stream so we
   can chain multiple intermediate operations without using semicolons. Terminal operations are either
   void or return a non-stream result. In the above example filter, map and sorted are intermediate
   operations whereas forEach is a terminal operation. For a full list of all available stream
   operations see the Stream Javadoc. Such a chain of stream operations as seen in the example above
   is also known as operation pipeline.

   Most stream operations accept some kind of lambda expression parameter, a functional interface
   specifying the exact behavior of the operation. Most of those operations must be both non-interfering
   and stateless. What does that mean?

   A function is non-interfering when it does not modify the underlying data source of the stream,
   e.g. in the above example no lambda expression does modify myList by adding or removing elements from
   the collection.

   A function is stateless when the execution of the operation is deterministic, e.g. in the above
   example no lambda expression depends on any mutable variables or states from the outer scope which
   might change during execution.

Different kind of streams
   Streams can be created from various data sources, especially collections. Lists and Sets support new
   methods stream() and parallelStream() to either create a sequential or a parallel stream. Parallel
   streams are capable of operating on multiple threads and will be covered in a later section of this
   tutorial. We focus on sequential streams for now:
Arrays.asList("a1", "a2", "a3")
    .stream()
    .findFirst()
    .ifPresent(System.out::println);  // a1

   Calling the method stream() on a list of objects returns a regular object stream. But we don't have
   to create collections in order to work with streams as we see in the next code sample:
Stream.of("a1", "a2", "a3")
    .findFirst()
    .ifPresent(System.out::println);  // a1

   Just use Stream.of() to create a stream from a bunch of object references.

   Besides regular object streams Java 8 ships with special kinds of streams for working with the
   primitive data types int, long and double. As you might have guessed it's IntStream, LongStream and
   DoubleStream.

   IntStreams can replace the regular for-loop utilizing IntStream.range():
IntStream.range(1, 4)
    .forEach(System.out::println);

// 1
// 2
// 3

   All those primitive streams work just like regular object streams with the following differences:
   Primitive streams use specialized lambda expressions, e.g. IntFunction instead of Function or
   IntPredicate instead of Predicate. And primitive streams support the additional terminal aggregate
   operations sum() and average():
Arrays.stream(new int[] {1, 2, 3})
    .map(n -> 2 * n + 1)
    .average()
    .ifPresent(System.out::println);  // 5.0

   Sometimes it's useful to transform a regular object stream to a primitive stream or vice versa. For
   that purpose object streams support the special mapping operations mapToInt(), mapToLong() and
   mapToDouble:
Stream.of("a1", "a2", "a3")
    .map(s -> s.substring(1))
    .mapToInt(Integer::parseInt)
    .max()
    .ifPresent(System.out::println);  // 3

   Primitive streams can be transformed to object streams via mapToObj():
IntStream.range(1, 4)
    .mapToObj(i -> "a" + i)
    .forEach(System.out::println);

// a1
// a2
// a3

   Here's a combined example: the stream of doubles is first mapped to an int stream and than mapped to
   an object stream of strings:
Stream.of(1.0, 2.0, 3.0)
    .mapToInt(Double::intValue)
    .mapToObj(i -> "a" + i)
    .forEach(System.out::println);

// a1
// a2
// a3

Processing Order
   Now that we've learned how to create and work with different kinds of streams, let's dive deeper into
   how stream operations are processed under the hood.

   An important characteristic of intermediate operations is laziness. Look at this sample where a
   terminal operation is missing:
Stream.of("d2", "a2", "b1", "b3", "c")
    .filter(s -> {
        System.out.println("filter: " + s);
        return true;
    });

   When executing this code snippet, nothing is printed to the console. That is because intermediate
   operations will only be executed when a terminal operation is present.

   Let's extend the above example by the terminal operation forEach:
Stream.of("d2", "a2", "b1", "b3", "c")
    .filter(s -> {
        System.out.println("filter: " + s);
        return true;
    })
    .forEach(s -> System.out.println("forEach: " + s));

   Executing this code snippet results in the desired output on the console:
filter:  d2
forEach: d2
filter:  a2
forEach: a2
filter:  b1
forEach: b1
filter:  b3
forEach: b3
filter:  c
forEach: c

   The order of the result might be surprising. A naive approach would be to execute the operations
   horizontally one after another on all elements of the stream. But instead each element moves along
   the chain vertically. The first string "d2" passes filter then forEach, only then the second string
   "a2" is processed.

   This behavior can reduce the actual number of operations performed on each element, as we see in the
   next example:
Stream.of("d2", "a2", "b1", "b3", "c")
    .map(s -> {
        System.out.println("map: " + s);
        return s.toUpperCase();
    })
    .anyMatch(s -> {
        System.out.println("anyMatch: " + s);
        return s.startsWith("A");
    });

// map:      d2
// anyMatch: D2
// map:      a2
// anyMatch: A2

   The operation anyMatch returns true as soon as the predicate applies to the given input element. This
   is true for the second element passed "A2". Due to the vertical execution of the stream chain, map
   has only to be executed twice in this case. So instead of mapping all elements of the stream, map
   will be called as few as possible.

Why order matters
   The next example consists of two intermediate operations map and filter and the terminal operation
   forEach. Let's once again inspect how those operations are being executed:
Stream.of("d2", "a2", "b1", "b3", "c")
    .map(s -> {
        System.out.println("map: " + s);
        return s.toUpperCase();
    })
    .filter(s -> {
        System.out.println("filter: " + s);
        return s.startsWith("A");
    })
    .forEach(s -> System.out.println("forEach: " + s));

// map:     d2
// filter:  D2
// map:     a2
// filter:  A2
// forEach: A2
// map:     b1
// filter:  B1
// map:     b3
// filter:  B3
// map:     c
// filter:  C

   As you might have guessed both map and filter are called five times for every string in the
   underlying collection whereas forEach is only called once.

   We can greatly reduce the actual number of executions if we change the order of the operations,
   moving filter to the beginning of the chain:
Stream.of("d2", "a2", "b1", "b3", "c")
    .filter(s -> {
        System.out.println("filter: " + s);
        return s.startsWith("a");
    })
    .map(s -> {
        System.out.println("map: " + s);
        return s.toUpperCase();
    })
    .forEach(s -> System.out.println("forEach: " + s));

// filter:  d2
// filter:  a2
// map:     a2
// forEach: A2
// filter:  b1
// filter:  b3
// filter:  c

   Now, map is only called once so the operation pipeline performs much faster for larger numbers of
   input elements. Keep that in mind when composing complex method chains.

   Let's extend the above example by an additional operation, sorted:
Stream.of("d2", "a2", "b1", "b3", "c")
    .sorted((s1, s2) -> {
        System.out.printf("sort: %s; %s\n", s1, s2);
        return s1.compareTo(s2);
    })
    .filter(s -> {
        System.out.println("filter: " + s);
        return s.startsWith("a");
    })
    .map(s -> {
        System.out.println("map: " + s);
        return s.toUpperCase();
    })
    .forEach(s -> System.out.println("forEach: " + s));

   Sorting is a special kind of intermediate operation. It's a so called stateful operation since in
   order to sort a collection of elements you have to maintain state during ordering.

   Executing this example results in the following console output:
sort:    a2; d2
sort:    b1; a2
sort:    b1; d2
sort:    b1; a2
sort:    b3; b1
sort:    b3; d2
sort:    c; b3
sort:    c; d2
filter:  a2
map:     a2
forEach: A2
filter:  b1
filter:  b3
filter:  c
filter:  d2

   First, the sort operation is executed on the entire input collection. In other words sorted is
   executed horizontally. So in this case sorted is called eight times for multiple combinations on
   every element in the input collection.

   Once again we can optimize the performance by reordering the chain:
Stream.of("d2", "a2", "b1", "b3", "c")
    .filter(s -> {
        System.out.println("filter: " + s);
        return s.startsWith("a");
    })
    .sorted((s1, s2) -> {
        System.out.printf("sort: %s; %s\n", s1, s2);
        return s1.compareTo(s2);
    })
    .map(s -> {
        System.out.println("map: " + s);
        return s.toUpperCase();
    })
    .forEach(s -> System.out.println("forEach: " + s));

// filter:  d2
// filter:  a2
// filter:  b1
// filter:  b3
// filter:  c
// map:     a2
// forEach: A2

   In this example sorted is never been called because filter reduces the input collection to just one
   element. So the performance is greatly increased for larger input collections.

Reusing Streams
   Java 8 streams cannot be reused. As soon as you call any terminal operation the stream is closed:
Stream<String> stream =
    Stream.of("d2", "a2", "b1", "b3", "c")
        .filter(s -> s.startsWith("a"));

stream.anyMatch(s -> true);    // ok
stream.noneMatch(s -> true);   // exception

   Calling noneMatch after anyMatch on the same stream results in the following exception:
java.lang.IllegalStateException: stream has already been operated upon or closed
    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)
    at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:459)
    at com.winterbe.java8.Streams5.test7(Streams5.java:38)
    at com.winterbe.java8.Streams5.main(Streams5.java:28)

   To overcome this limitation we have to to create a new stream chain for every terminal operation we
   want to execute, e.g. we could create a stream supplier to construct a new stream with all
   intermediate operations already set up:
Supplier<Stream<String>> streamSupplier =
    () -> Stream.of("d2", "a2", "b1", "b3", "c")
            .filter(s -> s.startsWith("a"));

streamSupplier.get().anyMatch(s -> true);   // ok
streamSupplier.get().noneMatch(s -> true);  // ok

   Each call to get() constructs a new stream on which we are save to call the desired terminal
   operation.

Advanced Operations
   Streams support plenty of different operations. We've already learned about the most important
   operations like filter or map. I leave it up to you to discover all other available operations (see
   Stream Javadoc). Instead let's dive deeper into the more complex operations collect, flatMap and
   reduce.

   Most code samples from this section use the following list of persons for demonstration purposes:
class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return name;
    }
}

List<Person> persons =
    Arrays.asList(
        new Person("Max", 18),
        new Person("Peter", 23),
        new Person("Pamela", 23),
        new Person("David", 12));

Collect
   Collect is an extremely useful terminal operation to transform the elements of the stream into a
   different kind of result, e.g. a List, Set or Map. Collect accepts a Collector which consists of four
   different operations: a supplier, an accumulator, a combiner and a finisher. This sounds super
   complicated at first, but the good part is Java 8 supports various built-in collectors via the
   Collectors class. So for the most common operations you don't have to implement a collector yourself.

   Let's start with a very common usecase:
List<Person> filtered =
    persons
        .stream()
        .filter(p -> p.name.startsWith("P"))
        .collect(Collectors.toList());

System.out.println(filtered);    // [Peter, Pamela]

   As you can see it's very simple to construct a list from the elements of a stream. Need a set instead
   of list - just use Collectors.toSet().

   The next example groups all persons by age:
Map<Integer, List<Person>> personsByAge = persons
    .stream()
    .collect(Collectors.groupingBy(p -> p.age));

personsByAge
    .forEach((age, p) -> System.out.format("age %s: %s\n", age, p));

// age 18: [Max]
// age 23: [Peter, Pamela]
// age 12: [David]

   Collectors are extremely versatile. You can also create aggregations on the elements of the stream,
   e.g. determining the average age of all persons:
Double averageAge = persons
    .stream()
    .collect(Collectors.averagingInt(p -> p.age));

System.out.println(averageAge);     // 19.0

   If you're interested in more comprehensive statistics, the summarizing collectors return a special
   built-in summary statistics object. So we can simply determine min, max and arithmetic average age of
   the persons as well as the sum and count.
IntSummaryStatistics ageSummary =
    persons
        .stream()
        .collect(Collectors.summarizingInt(p -> p.age));

System.out.println(ageSummary);
// IntSummaryStatistics{count=4, sum=76, min=12, average=19.000000, max=23}

   The next example joins all persons into a single string:
String phrase = persons
    .stream()
    .filter(p -> p.age >= 18)
    .map(p -> p.name)
    .collect(Collectors.joining(" and ", "In Germany ", " are of legal age."));

System.out.println(phrase);
// In Germany Max and Peter and Pamela are of legal age.

   The join collector accepts a delimiter as well as an optional prefix and suffix.

   In order to transform the stream elements into a map, we have to specify how both the keys and the
   values should be mapped. Keep in mind that the mapped keys must be unique, otherwise an
   IllegalStateException is thrown. You can optionally pass a merge function as an additional parameter
   to bypass the exception:
Map<Integer, String> map = persons
    .stream()
    .collect(Collectors.toMap(
        p -> p.age,
        p -> p.name,
        (name1, name2) -> name1 + ";" + name2));

System.out.println(map);
// {18=Max, 23=Peter;Pamela, 12=David}

   Now that we know some of the most powerful built-in collectors, let's try to build our own special
   collector. We want to transform all persons of the stream into a single string consisting of all
   names in upper letters separated by the | pipe character. In order to achieve this we create a new
   collector via Collector.of(). We have to pass the four ingredients of a collector: a supplier, an
   accumulator, a combiner and a finisher.
Collector<Person, StringJoiner, String> personNameCollector =
    Collector.of(
        () -> new StringJoiner(" | "),          // supplier
        (j, p) -> j.add(p.name.toUpperCase()),  // accumulator
        (j1, j2) -> j1.merge(j2),               // combiner
        StringJoiner::toString);                // finisher

String names = persons
    .stream()
    .collect(personNameCollector);

System.out.println(names);  // MAX | PETER | PAMELA | DAVID

   Since strings in Java are immutable, we need a helper class like StringJoiner to let the collector
   construct our string. The supplier initially constructs such a StringJoiner with the appropriate
   delimiter. The accumulator is used to add each persons upper-cased name to the StringJoiner. The
   combiner knows how to merge two StringJoiners into one. In the last step the finisher constructs the
   desired String from the StringJoiner.

FlatMap
   We've already learned how to transform the objects of a stream into another type of objects by
   utilizing the map operation. Map is kinda limited because every object can only be mapped to exactly
   one other object. But what if we want to transform one object into multiple others or none at all?
   This is where flatMap comes to the rescue.

   FlatMap transforms each element of the stream into a stream of other objects. So each object will be
   transformed into zero, one or multiple other objects backed by streams. The contents of those streams
   will then be placed into the returned stream of the flatMap operation.

   Before we see flatMap in action we need an appropriate type hierarchy:
class Foo {
    String name;
    List<Bar> bars = new ArrayList<>();

    Foo(String name) {
        this.name = name;
    }
}

class Bar {
    String name;

    Bar(String name) {
        this.name = name;
    }
}

   Next, we utilize our knowledge about streams to instantiate a couple of objects:
List<Foo> foos = new ArrayList<>();

// create foos
IntStream
    .range(1, 4)
    .forEach(i -> foos.add(new Foo("Foo" + i)));

// create bars
foos.forEach(f ->
    IntStream
        .range(1, 4)
        .forEach(i -> f.bars.add(new Bar("Bar" + i + " <- " + f.name))));

   Now we have a list of three foos each consisting of three bars.

   FlatMap accepts a function which has to return a stream of objects. So in order to resolve the bar
   objects of each foo, we just pass the appropriate function:
foos.stream()
    .flatMap(f -> f.bars.stream())
    .forEach(b -> System.out.println(b.name));

// Bar1 <- Foo1
// Bar2 <- Foo1
// Bar3 <- Foo1
// Bar1 <- Foo2
// Bar2 <- Foo2
// Bar3 <- Foo2
// Bar1 <- Foo3
// Bar2 <- Foo3
// Bar3 <- Foo3

   As you can see, we've successfully transformed the stream of three foo objects into a stream of nine
   bar objects.

   Finally, the above code example can be simplified into a single pipeline of stream operations:
IntStream.range(1, 4)
    .mapToObj(i -> new Foo("Foo" + i))
    .peek(f -> IntStream.range(1, 4)
        .mapToObj(i -> new Bar("Bar" + i + " <- " f.name))
        .forEach(f.bars::add))
    .flatMap(f -> f.bars.stream())
    .forEach(b -> System.out.println(b.name));

   FlatMap is also available for the Optional class introduced in Java 8. Optionals flatMap operation
   returns an optional object of another type. So it can be utilized to prevent nasty null checks.

   Think of a highly hierarchical structure like this:
class Outer {
    Nested nested;
}

class Nested {
    Inner inner;
}

class Inner {
    String foo;
}

   In order to resolve the inner string foo of an outer instance you have to add multiple null checks to
   prevent possible NullPointerExceptions:
Outer outer = new Outer();
if (outer != null && outer.nested != null && outer.nested.inner != null) {
    System.out.println(outer.nested.inner.foo);
}

   The same behavior can be obtained by utilizing optionals flatMap operation:
Optional.of(new Outer())
    .flatMap(o -> Optional.ofNullable(o.nested))
    .flatMap(n -> Optional.ofNullable(n.inner))
    .flatMap(i -> Optional.ofNullable(i.foo))
    .ifPresent(System.out::println);

   Each call to flatMap returns an Optional wrapping the desired object if present or null if absent.

Reduce
   The reduction operation combines all elements of the stream into a single result. Java 8 supports
   three different kind of reduce methods. The first one reduces a stream of elements to exactly one
   element of the stream. Let's see how we can use this method to determine the oldest person:
persons
    .stream()
    .reduce((p1, p2) -> p1.age > p2.age ? p1 : p2)
    .ifPresent(System.out::println);    // Pamela

   The reduce method accepts a BinaryOperator accumulator function. That's actually a BiFunction where
   both operands share the same type, in that case Person. BiFunctions are like Function but accept two
   arguments. The example function compares both persons ages in order to return the person with the
   maximum age.

   The second reduce method accepts both an identity value and a BinaryOperator accumulator. This method
   can be utilized to construct a new Person with the aggregated names and ages from all other persons
   in the stream:
Person result =
    persons
        .stream()
        .reduce(new Person("", 0), (p1, p2) -> {
            p1.age += p2.age;
            p1.name += p2.name;
            return p1;
        });

System.out.format("name=%s; age=%s", result.name, result.age);
// name=MaxPeterPamelaDavid; age=76

   The third reduce method accepts three parameters: an identity value, a BiFunction accumulator and a
   combiner function of type BinaryOperator. Since the identity values type is not restricted to the
   Person type, we can utilize this reduction to determine the sum of ages from all persons:
Integer ageSum = persons
    .stream()
    .reduce(0, (sum, p) -> sum += p.age, (sum1, sum2) -> sum1 + sum2);

System.out.println(ageSum);  // 76

   As you can see the result is 76, but what's happening exactly under the hood? Let's extend the above
   code by some debug output:
Integer ageSum = persons
    .stream()
    .reduce(0,
        (sum, p) -> {
            System.out.format("accumulator: sum=%s; person=%s\n", sum, p);
            return sum += p.age;
        },
        (sum1, sum2) -> {
            System.out.format("combiner: sum1=%s; sum2=%s\n", sum1, sum2);
            return sum1 + sum2;
        });

// accumulator: sum=0; person=Max
// accumulator: sum=18; person=Peter
// accumulator: sum=41; person=Pamela
// accumulator: sum=64; person=David

   As you can see the accumulator function does all the work. It first get called with the initial
   identity value 0 and the first person Max. In the next three steps sum continually increases by the
   age of the last steps person up to a total age of 76.

   Wait wat? The combiner never gets called? Executing the same stream in parallel will lift the secret:
Integer ageSum = persons
    .parallelStream()
    .reduce(0,
        (sum, p) -> {
            System.out.format("accumulator: sum=%s; person=%s\n", sum, p);
            return sum += p.age;
        },
        (sum1, sum2) -> {
            System.out.format("combiner: sum1=%s; sum2=%s\n", sum1, sum2);
            return sum1 + sum2;
        });

// accumulator: sum=0; person=Pamela
// accumulator: sum=0; person=David
// accumulator: sum=0; person=Max
// accumulator: sum=0; person=Peter
// combiner: sum1=18; sum2=23
// combiner: sum1=23; sum2=12
// combiner: sum1=41; sum2=35

   Executing this stream in parallel results in an entirely different execution behavior. Now the
   combiner is actually called. Since the accumulator is called in parallel, the combiner is needed to
   sum up the separate accumulated values.

   Let's dive deeper into parallel streams in the next chapter.

Parallel Streams
   Streams can be executed in parallel to increase runtime performance on large amount of input
   elements. Parallel streams use a common ForkJoinPool available via the static
   ForkJoinPool.commonPool() method. The size of the underlying thread-pool uses up to five threads -
   depending on the amount of available physical CPU cores:
ForkJoinPool commonPool = ForkJoinPool.commonPool();
System.out.println(commonPool.getParallelism());    // 3

   On my machine the common pool is initialized with a parallelism of 3 per default. This value can be
   decreased or increased by setting the following JVM parameter:
-Djava.util.concurrent.ForkJoinPool.common.parallelism=5

   Collections support the method parallelStream() to create a parallel stream of elements.
   Alternatively you can call the intermediate method parallel() on a given stream to convert a
   sequential stream to a parallel counterpart.

   In order to understate the parallel execution behavior of a parallel stream the next example prints
   information about the current thread to sout:
Arrays.asList("a1", "a2", "b1", "c2", "c1")
    .parallelStream()
    .filter(s -> {
        System.out.format("filter: %s [%s]\n",
            s, Thread.currentThread().getName());
        return true;
    })
    .map(s -> {
        System.out.format("map: %s [%s]\n",
            s, Thread.currentThread().getName());
        return s.toUpperCase();
    })
    .forEach(s -> System.out.format("forEach: %s [%s]\n",
        s, Thread.currentThread().getName()));

   By investigating the debug output we should get a better understanding which threads are actually
   used to execute the stream operations:
filter:  b1 [main]
filter:  a2 [ForkJoinPool.commonPool-worker-1]
map:     a2 [ForkJoinPool.commonPool-worker-1]
filter:  c2 [ForkJoinPool.commonPool-worker-3]
map:     c2 [ForkJoinPool.commonPool-worker-3]
filter:  c1 [ForkJoinPool.commonPool-worker-2]
map:     c1 [ForkJoinPool.commonPool-worker-2]
forEach: C2 [ForkJoinPool.commonPool-worker-3]
forEach: A2 [ForkJoinPool.commonPool-worker-1]
map:     b1 [main]
forEach: B1 [main]
filter:  a1 [ForkJoinPool.commonPool-worker-3]
map:     a1 [ForkJoinPool.commonPool-worker-3]
forEach: A1 [ForkJoinPool.commonPool-worker-3]
forEach: C1 [ForkJoinPool.commonPool-worker-2]

   As you can see the parallel stream utilizes all available threads from the common ForkJoinPool for
   executing the stream operations. The output may differ in consecutive runs because the behavior which
   particular thread is actually used is non-deterministic.

   Let's extend the example by an additional stream operation, sort:
Arrays.asList("a1", "a2", "b1", "c2", "c1")
    .parallelStream()
    .filter(s -> {
        System.out.format("filter: %s [%s]\n",
            s, Thread.currentThread().getName());
        return true;
    })
    .map(s -> {
        System.out.format("map: %s [%s]\n",
            s, Thread.currentThread().getName());
        return s.toUpperCase();
    })
    .sorted((s1, s2) -> {
        System.out.format("sort: %s <> %s [%s]\n",
            s1, s2, Thread.currentThread().getName());
        return s1.compareTo(s2);
    })
    .forEach(s -> System.out.format("forEach: %s [%s]\n",
        s, Thread.currentThread().getName()));

   The result may look strange at first:
filter:  c2 [ForkJoinPool.commonPool-worker-3]
filter:  c1 [ForkJoinPool.commonPool-worker-2]
map:     c1 [ForkJoinPool.commonPool-worker-2]
filter:  a2 [ForkJoinPool.commonPool-worker-1]
map:     a2 [ForkJoinPool.commonPool-worker-1]
filter:  b1 [main]
map:     b1 [main]
filter:  a1 [ForkJoinPool.commonPool-worker-2]
map:     a1 [ForkJoinPool.commonPool-worker-2]
map:     c2 [ForkJoinPool.commonPool-worker-3]
sort:    A2 <> A1 [main]
sort:    B1 <> A2 [main]
sort:    C2 <> B1 [main]
sort:    C1 <> C2 [main]
sort:    C1 <> B1 [main]
sort:    C1 <> C2 [main]
forEach: A1 [ForkJoinPool.commonPool-worker-1]
forEach: C2 [ForkJoinPool.commonPool-worker-3]
forEach: B1 [main]
forEach: A2 [ForkJoinPool.commonPool-worker-2]
forEach: C1 [ForkJoinPool.commonPool-worker-1]

   It seems that sort is executed sequentially on the main thread only. Actually, sort on a parallel
   stream uses the new Java 8 method Arrays.parallelSort() under the hood. As stated in Javadoc this
   method decides on the length of the array if sorting will be performed sequentially or in parallel:

     If the length of the specified array is less than the minimum granularity, then it is sorted using
     the appropriate Arrays.sort method.

   Coming back to the reduce example from the last section. We already found out that the combiner
   function is only called in parallel but not in sequential streams. Let's see which threads are
   actually involved:
List<Person> persons = Arrays.asList(
    new Person("Max", 18),
    new Person("Peter", 23),
    new Person("Pamela", 23),
    new Person("David", 12));

persons
    .parallelStream()
    .reduce(0,
        (sum, p) -> {
            System.out.format("accumulator: sum=%s; person=%s [%s]\n",
                sum, p, Thread.currentThread().getName());
            return sum += p.age;
        },
        (sum1, sum2) -> {
            System.out.format("combiner: sum1=%s; sum2=%s [%s]\n",
                sum1, sum2, Thread.currentThread().getName());
            return sum1 + sum2;
        });

   The console output reveals that both the accumulator and the combiner functions are executed in
   parallel on all available threads:
accumulator: sum=0; person=Pamela; [main]
accumulator: sum=0; person=Max;    [ForkJoinPool.commonPool-worker-3]
accumulator: sum=0; person=David;  [ForkJoinPool.commonPool-worker-2]
accumulator: sum=0; person=Peter;  [ForkJoinPool.commonPool-worker-1]
combiner:    sum1=18; sum2=23;     [ForkJoinPool.commonPool-worker-1]
combiner:    sum1=23; sum2=12;     [ForkJoinPool.commonPool-worker-2]
combiner:    sum1=41; sum2=35;     [ForkJoinPool.commonPool-worker-2]

   In summary, it can be stated that parallel streams can bring be a nice performance boost to streams
   with a large amount of input elements. But keep in mind that some parallel stream operations like
   reduce and collect need additional computations (combine operations) which isn't needed when executed
   sequentially.

   Furthermore we've learned that all parallel stream operations share the same JVM-wide common
   ForkJoinPool. So you probably want to avoid implementing slow blocking stream operations since that
   could potentially slow down other parts of your application which rely heavily on parallel streams.

That's it
   My programming guide to Java 8 streams ends here. If you're interested in learning more about Java 8
   streams, I recommend to you the Stream Javadoc package documentation. If you want to learn more
   about the underlying mechanisms, you probably want to read Martin Fowlers article about
   Collection Pipelines.

   If you're interested in JavaScript as well, you may want to have a look at Stream.js - a
   JavaScript implementation of the Java 8 Streams API. You may also wanna read my Java 8 Tutorial
   and my Java 8 Nashorn Tutorial.


---
[**1]
https://winterbe.com/posts/2014/03/16/java-8-tutorial/

Java 8 Tutorial
March 16, 2014

   Welcome to my introduction to Java 8. This tutorial guides you step by step through all new
   language features. Backed by short and simple code samples you'll learn how to use default interface
   methods, lambda expressions, method references and repeatable annotations. At the end of the article
   you'll be familiar with the most recent API changes like streams, functional interfaces, map
   extensions and the new Date API.

Default Methods for Interfaces
   Java 8 enables us to add non-abstract method implementations to interfaces by utilizing the default
   keyword. This feature is also known as Extension Methods. Here is our first example:
interface Formula {
    double calculate(int a);

    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}

   Besides the abstract method calculate the interface Formula also defines the default method sqrt.
   Concrete classes only have to implement the abstract method calculate. The default method sqrt can be
   used out of the box.
Formula formula = new Formula() {
    @Override
    public double calculate(int a) {
        return sqrt(a * 100);
    }
};

formula.calculate(100);     // 100.0
formula.sqrt(16);           // 4.0

   The formula is implemented as an anonymous object. The code is quite verbose: 6 lines of code for
   such a simple calucation of sqrt(a * 100). As we'll see in the next section, there's a much nicer way
   of implementing single method objects in Java 8.

Lambda expressions
   Let's start with a simple example of how to sort a list of strings in prior versions of Java:
List<String> names = Arrays.asList("peter", "anna", "mike", "xenia");

Collections.sort(names, new Comparator<String>() {
    @Override
    public int compare(String a, String b) {
        return b.compareTo(a);
    }
});

   The static utility method Collections.sort accepts a list and a comparator in order to sort the
   elements of the given list. You often find yourself creating anonymous comparators and pass them to
   the sort method.

   Instead of creating anonymous objects all day long, Java 8 comes with a much shorter syntax, lambda
   expressions:
Collections.sort(names, (String a, String b) -> {
    return b.compareTo(a);
});

   As you can see the code is much shorter and easier to read. But it gets even shorter:
Collections.sort(names, (String a, String b) -> b.compareTo(a));

   For one line method bodies you can skip both the braces {} and the return keyword. But it gets even
   more shorter:
Collections.sort(names, (a, b) -> b.compareTo(a));

   The java compiler is aware of the parameter types so you can skip them as well. Let's dive deeper
   into how lambda expressions can be used in the wild.

Functional Interfaces
   How does lambda expressions fit into Javas type system? Each lambda corresponds to a given type,
   specified by an interface. A so called functional interface must contain exactly one abstract method
   declaration. Each lambda expression of that type will be matched to this abstract method. Since
   default methods are not abstract you're free to add default methods to your functional interface.

   We can use arbitrary interfaces as lambda expressions as long as the interface only contains one
   abstract method. To ensure that your interface meet the requirements, you should add the
   @FunctionalInterface annotation. The compiler is aware of this annotation and throws a compiler error
   as soon as you try to add a second abstract method declaration to the interface.

   Example:
@FunctionalInterface
interface Converter<F, T> {
    T convert(F from);
}

Converter<String, Integer> converter = (from) -> Integer.valueOf(from);
Integer converted = converter.convert("123");
System.out.println(converted);    // 123

   Keep in mind that the code is also valid if the @FunctionalInterface annotation would be ommited.

Method and Constructor References
   The above example code can be further simplified by utilizing static method references:
Converter<String, Integer> converter = Integer::valueOf;
Integer converted = converter.convert("123");
System.out.println(converted);   // 123

   Java 8 enables you to pass references of methods or constructors via the :: keyword. The above
   example shows how to reference a static method. But we can also reference object methods:
class Something {
    String startsWith(String s) {
        return String.valueOf(s.charAt(0));
    }
}

Something something = new Something();
Converter<String, String> converter = something::startsWith;
String converted = converter.convert("Java");
System.out.println(converted);    // "J"

   Let's see how the :: keyword works for constructors. First we define an example bean with different
   constructors:
class Person {
    String firstName;
    String lastName;

    Person() {}

    Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}

   Next we specify a person factory interface to be used for creating new persons:
interface PersonFactory<P extends Person> {
    P create(String firstName, String lastName);
}

   Instead of implementing the factory manually, we glue everything together via constructor references:
PersonFactory<Person> personFactory = Person::new;
Person person = personFactory.create("Peter", "Parker");

   We create a reference to the Person constructor via Person::new. The Java compiler automatically
   chooses the right constructor by matching the signature of PersonFactory.create.

Lambda Scopes
   Accessing outer scope variables from lambda expressions is very similar to anonymous objects. You can
   access final variables from the local outer scope as well as instance fields and static variables.

Accessing local variables
   We can read final local variables from the outer scope of lambda expressions:
final int num = 1;
Converter<Integer, String> stringConverter =
        (from) -> String.valueOf(from + num);

stringConverter.convert(2);     // 3

   But different to anonymous objects the variable num does not have to be declared final. This code is
   also valid:
int num = 1;
Converter<Integer, String> stringConverter =
        (from) -> String.valueOf(from + num);

stringConverter.convert(2);     // 3

   However num must be implicitly final for the code to compile. The following code does not compile:
int num = 1;
Converter<Integer, String> stringConverter =
        (from) -> String.valueOf(from + num);
num = 3;

   Writing to num from within the lambda expression is also prohibited.

Accessing fields and static variables
   In constrast to local variables we have both read and write access to instance fields and static
   variables from within lambda expressions. This behaviour is well known from anonymous objects.
class Lambda4 {
    static int outerStaticNum;
    int outerNum;

    void testScopes() {
        Converter<Integer, String> stringConverter1 = (from) -> {
            outerNum = 23;
            return String.valueOf(from);
        };

        Converter<Integer, String> stringConverter2 = (from) -> {
            outerStaticNum = 72;
            return String.valueOf(from);
        };
    }
}

Accessing Default Interface Methods
   Remember the formula example from the first section? Interface Formula defines a default method sqrt
   which can be accessed from each formula instance including anonymous objects. This does not work with
   lambda expressions.

   Default methods cannot be accessed from within lambda expressions. The following code does not
   compile:
Formula formula = (a) -> sqrt( a * 100);

Built-in Functional Interfaces
   The JDK 1.8 API contains many built-in functional interfaces. Some of them are well known from older
   versions of Java like Comparator or Runnable. Those existing interfaces are extended to enable Lambda
   support via the @FunctionalInterface annotation.

   But the Java 8 API is also full of new functional interfaces to make your life easier. Some of those
   new interfaces are well known from the Google Guava library. Even if you're familiar with this
   library you should keep a close eye on how those interfaces are extended by some useful method
   extensions.

Predicates
   Predicates are boolean-valued functions of one argument. The interface contains various default
   methods for composing predicates to complex logical terms (and, or, negate)
Predicate<String> predicate = (s) -> s.length() > 0;

predicate.test("foo");              // true
predicate.negate().test("foo");     // false

Predicate<Boolean> nonNull = Objects::nonNull;
Predicate<Boolean> isNull = Objects::isNull;

Predicate<String> isEmpty = String::isEmpty;
Predicate<String> isNotEmpty = isEmpty.negate();

Functions
   Functions accept one argument and produce a result. Default methods can be used to chain multiple
   functions together (compose, andThen).
Function<String, Integer> toInteger = Integer::valueOf;
Function<String, String> backToString = toInteger.andThen(String::valueOf);

backToString.apply("123");     // "123"

Suppliers
   Suppliers produce a result of a given generic type. Unlike Functions, Suppliers don't accept
   arguments.
Supplier<Person> personSupplier = Person::new;
personSupplier.get();   // new Person

Consumers
   Consumers represents operations to be performed on a single input argument.
Consumer<Person> greeter = (p) -> System.out.println("Hello, " + p.firstName);
greeter.accept(new Person("Luke", "Skywalker"));

Comparators
   Comparators are well known from older versions of Java. Java 8 adds various default methods to the
   interface.
Comparator<Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);

Person p1 = new Person("John", "Doe");
Person p2 = new Person("Alice", "Wonderland");

comparator.compare(p1, p2);             // > 0
comparator.reversed().compare(p1, p2);  // < 0

Optionals
   Optionals are not functional interfaces, instead it's a nifty utility to prevent
   NullPointerException. It's an important concept for the next section, so let's have a quick look at
   how Optionals work.

   Optional is a simple container for a value which may be null or non-null. Think of a method which may
   return a non-null result but sometimes return nothing. Instead of returning null you return an
   Optional in Java 8.
Optional<String> optional = Optional.of("bam");

optional.isPresent();           // true
optional.get();                 // "bam"
optional.orElse("fallback");    // "bam"

optional.ifPresent((s) -> System.out.println(s.charAt(0)));     // "b"

Streams
   A java.util.Stream represents a sequence of elements on which one or more operations can be
   performed. Stream operations are either intermediate or terminal. While terminal operations return a
   result of a certain type, intermediate operations return the stream itself so you can chain multiple
   method calls in a row. Streams are created on a source, e.g. a java.util.Collection like lists or
   sets (maps are not supported). Stream operations can either be executed sequential or parallel.

   Let's first look how sequential streams work. First we create a sample source in form of a list of
   strings:
List<String> stringCollection = new ArrayList<>();
stringCollection.add("ddd2");
stringCollection.add("aaa2");
stringCollection.add("bbb1");
stringCollection.add("aaa1");
stringCollection.add("bbb3");
stringCollection.add("ccc");
stringCollection.add("bbb2");
stringCollection.add("ddd1");

   Collections in Java 8 are extended so you can simply create streams either by calling
   Collection.stream() or Collection.parallelStream(). The following sections explain the most common
   stream operations.

Filter
   Filter accepts a predicate to filter all elements of the stream. This operation is intermediate which
   enables us to call another stream operation (forEach) on the result. ForEach accepts a consumer to be
   executed for each element in the filtered stream. ForEach is a terminal operation. It's void, so we
   cannot call another stream operation.
stringCollection
    .stream()
    .filter((s) -> s.startsWith("a"))
    .forEach(System.out::println);

// "aaa2", "aaa1"

Sorted
   Sorted is an intermediate operation which returns a sorted view of the stream. The elements are
   sorted in natural order unless you pass a custom Comparator.
stringCollection
    .stream()
    .sorted()
    .filter((s) -> s.startsWith("a"))
    .forEach(System.out::println);

// "aaa1", "aaa2"

   Keep in mind that sorted does only create a sorted view of the stream without manipulating the
   ordering of the backed collection. The ordering of stringCollection is untouched:
System.out.println(stringCollection);
// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1

Map
   The intermediate operation map converts each element into another object via the given function. The
   following example converts each string into an upper-cased string. But you can also use map to
   transform each object into another type. The generic type of the resulting stream depends on the
   generic type of the function you pass to map.
stringCollection
    .stream()
    .map(String::toUpperCase)
    .sorted((a, b) -> b.compareTo(a))
    .forEach(System.out::println);

// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"

Match
   Various matching operations can be used to check whether a certain predicate matches the stream. All
   of those operations are terminal and return a boolean result.
boolean anyStartsWithA =
    stringCollection
        .stream()
        .anyMatch((s) -> s.startsWith("a"));

System.out.println(anyStartsWithA);      // true

boolean allStartsWithA =
    stringCollection
        .stream()
        .allMatch((s) -> s.startsWith("a"));

System.out.println(allStartsWithA);      // false

boolean noneStartsWithZ =
    stringCollection
        .stream()
        .noneMatch((s) -> s.startsWith("z"));

System.out.println(noneStartsWithZ);      // true

Count
   Count is a terminal operation returning the number of elements in the stream as a long.
long startsWithB =
    stringCollection
        .stream()
        .filter((s) -> s.startsWith("b"))
        .count();

System.out.println(startsWithB);    // 3

Reduce
   This terminal operation performs a reduction on the elements of the stream with the given function.
   The result is an Optional holding the reduced value.
Optional<String> reduced =
    stringCollection
        .stream()
        .sorted()
        .reduce((s1, s2) -> s1 + "#" + s2);

reduced.ifPresent(System.out::println);
// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"

Parallel Streams
   As mentioned above streams can be either sequential or parallel. Operations on sequential streams are
   performed on a single thread while operations on parallel streams are performed concurrent on
   multiple threads.

   The following example demonstrates how easy it is to increase the performance by using parallel
   streams.

   First we create a large list of unique elements:
int max = 1000000;
List<String> values = new ArrayList<>(max);
for (int i = 0; i < max; i++) {
    UUID uuid = UUID.randomUUID();
    values.add(uuid.toString());
}

   Now we measure the time it takes to sort a stream of this collection.

Sequential Sort
long t0 = System.nanoTime();

long count = values.stream().sorted().count();
System.out.println(count);

long t1 = System.nanoTime();

long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);
System.out.println(String.format("sequential sort took: %d ms", millis));

// sequential sort took: 899 ms

Parallel Sort
long t0 = System.nanoTime();

long count = values.parallelStream().sorted().count();
System.out.println(count);

long t1 = System.nanoTime();

long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);
System.out.println(String.format("parallel sort took: %d ms", millis));

// parallel sort took: 472 ms

   As you can see both code snippets are almost identical but the parallel sort is roughly 50% faster.
   All you have to do is change stream() to parallelStream().

Map
   As already mentioned maps don't support streams. Instead maps now support various new and useful
   methods for doing common tasks.
Map<Integer, String> map = new HashMap<>();

for (int i = 0; i < 10; i++) {
    map.putIfAbsent(i, "val" + i);
}

map.forEach((id, val) -> System.out.println(val));

   The above code should be self-explaining: putIfAbsent prevents us from writing additional if null
   checks; forEach accepts a consumer to perform operations for each value of the map.

   This example shows how to compute code on the map by utilizing functions:
map.computeIfPresent(3, (num, val) -> val + num);
map.get(3);             // val33

map.computeIfPresent(9, (num, val) -> null);
map.containsKey(9);     // false

map.computeIfAbsent(23, num -> "val" + num);
map.containsKey(23);    // true

map.computeIfAbsent(3, num -> "bam");
map.get(3);             // val33

   Next, we learn how to remove entries for a a given key, only if it's currently mapped to a given
   value:
map.remove(3, "val3");
map.get(3);             // val33

map.remove(3, "val33");
map.get(3);             // null

   Another helpful method:
map.getOrDefault(42, "not found");  // not found

   Merging entries of a map is quite easy:
map.merge(9, "val9", (value, newValue) -> value.concat(newValue));
map.get(9);             // val9

map.merge(9, "concat", (value, newValue) -> value.concat(newValue));
map.get(9);             // val9concat

   Merge either put the key/value into the map if no entry for the key exists, or the merging function
   will be called to change the existing value.

   UPDATE - I'm currently working on a JavaScript implementation of the Java 8 Streams API for the
   browser. If I've drawn your interest check out Stream.js on GitHub. Your Feedback is highly
   appreciated.

Date API
   Java 8 contains a brand new date and time API under the package java.time. The new Date API is
   comparable with the Joda-Time library, however it's not the same. The following examples
   cover the most important parts of this new API.

Clock
   Clock provides access to the current date and time. Clocks are aware of a timezone and may be used
   instead of System.currentTimeMillis() to retrieve the current milliseconds. Such an instantaneous
   point on the time-line is also represented by the class Instant. Instants can be used to create
   legacy java.util.Date objects.
Clock clock = Clock.systemDefaultZone();
long millis = clock.millis();

Instant instant = clock.instant();
Date legacyDate = Date.from(instant);   // legacy java.util.Date

Timezones
   Timezones are represented by a ZoneId. They can easily be accessed via static factory methods.
   Timezones define the offsets which are important to convert between instants and local dates and
   times.
System.out.println(ZoneId.getAvailableZoneIds());
// prints all available timezone ids

ZoneId zone1 = ZoneId.of("Europe/Berlin");
ZoneId zone2 = ZoneId.of("Brazil/East");
System.out.println(zone1.getRules());
System.out.println(zone2.getRules());

// ZoneRules[currentStandardOffset=+01:00]
// ZoneRules[currentStandardOffset=-03:00]

LocalTime
   LocalTime represents a time without a timezone, e.g. 10pm or 17:30:15. The following example creates
   two local times for the timezones defined above. Then we compare both times and calculate the
   difference in hours and minutes between both times.
LocalTime now1 = LocalTime.now(zone1);
LocalTime now2 = LocalTime.now(zone2);

System.out.println(now1.isBefore(now2));  // false

long hoursBetween = ChronoUnit.HOURS.between(now1, now2);
long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);

System.out.println(hoursBetween);       // -3
System.out.println(minutesBetween);     // -239

   LocalTime comes with various factory method to simplify the creation of new instances, including
   parsing of time strings.
LocalTime late = LocalTime.of(23, 59, 59);
System.out.println(late);       // 23:59:59

DateTimeFormatter germanFormatter =
    DateTimeFormatter
        .ofLocalizedTime(FormatStyle.SHORT)
        .withLocale(Locale.GERMAN);

LocalTime leetTime = LocalTime.parse("13:37", germanFormatter);
System.out.println(leetTime);   // 13:37

LocalDate
   LocalDate represents a distinct date, e.g. 2014-03-11. It's immutable and works exactly analog to
   LocalTime. The sample demonstrates how to calculate new dates by adding or substracting days, months
   or years. Keep in mind that each manipulation returns a new instance.
LocalDate today = LocalDate.now();
LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);
LocalDate yesterday = tomorrow.minusDays(2);

LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);
DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();
System.out.println(dayOfWeek);    // FRIDAY

   Parsing a LocalDate from a string is just as simple as parsing a LocalTime:
DateTimeFormatter germanFormatter =
    DateTimeFormatter
        .ofLocalizedDate(FormatStyle.MEDIUM)
        .withLocale(Locale.GERMAN);

LocalDate xmas = LocalDate.parse("24.12.2014", germanFormatter);
System.out.println(xmas);   // 2014-12-24

LocalDateTime
   LocalDateTime represents a date-time. It combines date and time as seen in the above sections into
   one instance. LocalDateTime is immutable and works similar to LocalTime and LocalDate. We can utilize
   methods for retrieving certain fields from a date-time:
LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);

DayOfWeek dayOfWeek = sylvester.getDayOfWeek();
System.out.println(dayOfWeek);      // WEDNESDAY

Month month = sylvester.getMonth();
System.out.println(month);          // DECEMBER

long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);
System.out.println(minuteOfDay);    // 1439

   With the additional information of a timezone it can be converted to an instant. Instants can easily
   be converted to legacy dates of type java.util.Date.
Instant instant = sylvester
        .atZone(ZoneId.systemDefault())
        .toInstant();

Date legacyDate = Date.from(instant);
System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014

   Formatting date-times works just like formatting dates or times. Instead of using pre-defined formats
   we can create formatters from custom patterns.
DateTimeFormatter formatter =
    DateTimeFormatter
        .ofPattern("MMM dd, yyyy - HH:mm");

LocalDateTime parsed = LocalDateTime.parse("Nov 03, 2014 - 07:13", formatter);
String string = formatter.format(parsed);
System.out.println(string);     // Nov 03, 2014 - 07:13

   Unlike java.text.NumberFormat the new DateTimeFormatter is immutable and thread-safe.

   For details on the pattern syntax read here.

Annotations
   Annotations in Java 8 are repeatable. Let's dive directly into an example to figure that out.

   First, we define a wrapper annotation which holds an array of the actual annotations:
@interface Hints {
    Hint[] value();
}

@Repeatable(Hints.class)
@interface Hint {
    String value();
}

   Java 8 enables us to use multiple annotations of the same type by declaring the annotation
   @Repeatable.

Variant 1: Using the container annotation (old school)

@Hints({@Hint("hint1"), @Hint("hint2")})
class Person {}

Variant 2: Using repeatable annotations (new school)

@Hint("hint1")
@Hint("hint2")
class Person {}

   Using variant 2 the java compiler implicitly sets up the @Hints annotation under the hood. That's
   important for reading annotation informations via reflection.
Hint hint = Person.class.getAnnotation(Hint.class);
System.out.println(hint);                   // null

Hints hints1 = Person.class.getAnnotation(Hints.class);
System.out.println(hints1.value().length);  // 2

Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);
System.out.println(hints2.length);          // 2

   Although we never declared the @Hints annotation on the Person class, it's still readable via
   getAnnotation(Hints.class). However, the more convenient method is getAnnotationsByType which grants
   direct access to all annotated @Hint annotations.

   Furthermore the usage of annotations in Java 8 is expanded to two new targets:
@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
@interface MyAnnotation {}

That's it
   My programming guide to Java 8 ends here. If you want to learn more about all the new classes and
   features of the JDK 8 API, just read my follow up article. It helps you figuring out all the new
   classes and hidden gems of JDK 8, like Arrays.parallelSort, StampedLock and CompletableFuture - just
   to name a few.



---
