https://www.codejava.net/coding/what-is-dependency-injection-with-java-code-example

What is Dependency Injection with Java Code Example
04 July 2019

   This Java tutorial will help you understand the key concepts of dependency injection, step
   by step through simple code example - easy to understand and follow.So, what is dependency
   injection?It's difficult to understand dependency injection in few sentences, so it's
   better to begin with some code example.Normally, a class depends on another class to do
   some work, for example:
public class ClientA {
        ServiceB service;

        public void doSomething() {
                String info = service.getInfo();
        }
}

   Here, class ClientA uses class ServiceB which is written as below, for example:
public class ServiceB {
        public String getInfo() {
                return "ServiceB's Info";
        }
}

   The class ClientA is said to be dependent on the class ServiceB, and ServiceB is called a
   dependency of ClientA. This kind of dependency is very trivial in programming. However,
   when the application's code gets bigger and more complex, the hard-coded dependency among
   classes introduces some drawbacks:
     * The code is inflexible - it's hard to maintain and extend as when a class permanently
       depends on another class, change to the depending class my require change to the
       dependent class. And it's impossible to change the depending class later without
       updating and re-compiling the code.
     * The code is hard for unit testing because when you want to test only the
       functionalities of a class, you have to test other depending classes as well.
     * The code is hard for reuse because the classes are tightly coupled.

   Therefore, dependency injection comes to address these drawbacks, making the code more
   flexible to changes, easy for unit testing and truly reusable. Then, how dependency
   injection works?First, interfaces are used to define the types of the classes so its
   implementation can be changed later. For example, with the above code - the interfaces
   Client and Service are introduced:
public interface Client {
        void doSomething();
}

public interface Service {
        String getInfo();
}


   Then the ServiceB class becomes an implementation of Service as below:
public class ServiceB implements Service {

        @Override
        public String getInfo() {
                return "ServiceB's Info";
        }
}

    Then it's possible to have different implementations of Service, for example ServiceC and
   ServiceD:
public class ServiceC implements Service {

        @Override
        public String getInfo() {
                return "ServiceC's Info";
        }
}

public class ServiceD implements Service {

        @Override
        public String getInfo() {
                return "ServiceD's Info";
        }
}

    And the class ClientA is now implementing the Client interface and it uses the Service
   interface instead of a concrete class - the actual Service's implementation is "injected"
   to this class via its constructor - constructor injection, as shown below:
public class ClientA implements Client {

        Service service;

        public ClientA(Service service) {
                this.service = service;
        }

        @Override
        public void doSomething() {

                String info = service.getInfo();

        }
}

    The class ClientA is now not depending on any specific implementations of Service. Instead
   of creating an instance of dependent class directly in ClientA, the dependency injection
   container or framework is now responsible for creating that instance and inject it to the
   class ClientA via its constructor. For example:
Service service = new ServiceB();
Client client = new ClientA(service);
client.doSomething();

   Here, an implementation of Service is ServiceB is created and passed to ClientA, which is
   not aware of the actual implementation it is using. ClientA only knows that the injected
   object is of type Service.Besides constructor injection, setter injection is used to pass
   the depending object to the dependent one. Add the following setter method in the ClientA
   class:
public void setService(Service service) {
        this.service = service;
}

   Then we can change to different Service's implementation e.g. ServiceC like this:
((ClientA) client).setService(new ServiceC());
client.doSomething();

    That's a Java code example about dependency injection. Note that we write the code to
   create and inject the dependencies manually. In practice, a dependency injection
   container/framework like Spring will do the wiring automatically. You just declare the
   dependency information via XML file or annotations in Java classes, and the framework
   manages the dependencies for you. 

Conclusion
   Dependency injection is a technique that allows
   the client code to be independent from the services it is relying on. The client does not
   control how objects of the services are created - it works with an implementation of the
   service through interface. This is somewhat in inverse to trivial programming so dependency
   injection is also called inversion of control.It makes the code more flexible, extensible,
   maintainable, testable and reusable - thus dependency injection is very popular in modern
   programming. In Java, dependency injection is supported since Java EE 6 - called CDI
   (Contexts and Dependency Injection). And the Spring framework is based on dependency
   injection, as well as other frameworks like Google Guice and Play.


---
https://codeflex.co/java-dependency-injection-simple-example/

Java Dependency Injection Simple Example

   Today we'll see a simple code that shows what actually Dependency Injection is.

   Imaging that you have Student class, and several different loggers for this class. Each
   logger prints messages in his own particular way. You want to be able to choose the Logger
   type for each Student on its instantiation without touching anything inside Student class
   implementation.

   Take a look at this code and I'm pretty sure you will get the main idea of Dependency
   Injection:
    public interface LoggerInterface {
        void WriteLog(String text);
    }

    public static class Student {
        public Student(LoggerInterface logger) {
            logger.WriteLog("New Student created");
        }
    }

    public static class LoggerOne implements LoggerInterface {
        public void WriteLog(String text) {
            System.out.println(text + " with LoggerOne");
        }
    }

    public static class LoggerTwo implements LoggerInterface {
        public void WriteLog(String text) {
            System.out.println("###################");
            System.out.println(text + " with LoggerTwo");
            System.out.println("###################");
        }
    }


Let's instantiate two Student objects with different logger:

public static void main(String[] args) {
        Student employee1 = new Student(new LoggerOne());
        Student employee2 = new Student(new LoggerTwo());
    }


Output:

   New Student created with LoggerOne
   ###################
   New Student created with LoggerTwo
   ###################


---
https://www.vogella.com/tutorials/DependencyInjection/article.html

Using dependency injection in Java - Introduction - Tutorial
01.09.2016

     Dependency injection (DI). This article describes the concept of dependency injection
     from a Java perspective.

     * 1. Dependency injection in Java
          + 1.1. What is dependency injection?
          + 1.2. Using annotations to describe class dependencies
          + 1.3. Where can objects be injected into a class according to JSR330?
          + 1.4. Order in which dependency injection is performed on a class
     * 2. Java and dependency injection frameworks
     * 3. Links and Literature
          + 3.1. Spring Links
     * 4. vogella training and consulting support
     * Appendix A: Copyright, License and Source code

1. Dependency injection in Java
1.1. What is dependency injection?
   Dependency injection is a concept valid for any programming language. The general concept
   behind dependency injection is called Inversion of Control. According to this concept a
   class should not configure its dependencies statically but should be configured from the
   outside.

   A Java class has a dependency on another class, if it uses an instance of this class. We
   call this a _class dependency. For example, a class which accesses a logger service has a
   dependency on this service class.

   Ideally Java classes should be as independent as possible from other Java classes. This
   increases the possibility of reusing these classes and to be able to test them
   independently from other classes.

   If the Java class creates an instance of another class via the new operator, it cannot be
   used (and tested) independently from this class and this is called a hard dependency. The
   following example shows a class which has no hard dependencies.
package com.vogella.tasks.ui.parts;

import java.util.logging.Logger;

public class MyClass {

    private Logger logger;

    public MyClass(Logger logger) {
        this.logger = logger;
        // write an info log message
        logger.info("This is a log message.")
    }
}

   Please note that this class is just a normal Java class, there is nothing special about it,
   except that it avoids direct object creation.

   A framework class, usually called the dependency container, could analyze the dependencies
   of this class. With this analysis it is able to create an instance of the class and inject
   the objects into the defined dependencies, via Java reflection.

   This way the Java class has no hard dependencies, which means it does not rely on an
   instance of a certain class. This allows you to testyour class in isolation, for example by
   using mock objects.

   Mock objects (mocks) are objects which behave similar as the real object. But these mocks
   are not programmed; they are configured to behave in a certain predefined way. Mock is an
   English word which means to mimic or to imitate.

   If dependency injection is used, a Java class can be tested in isolation.

1.2. Using annotations to describe class dependencies
   Different approaches exist to describe the dependencies of a class. The most common
   approach is to use Java annotations to describe the dependencies directly in the class.

   The standard Java annotations for describing the dependencies of a class are defined in the
   Java Specification Request 330 (JSR330). This specification describes the @Inject and
   @Named annotations.

   The following listing shows a class which uses annotations to describe its dependencies.
// import statements left out

public class MyPart {

    @Inject private Logger logger;

    // inject class for database access
    @Inject private DatabaseAccessClass dao;

    @Inject
    public void createControls(Composite parent) {
        logger.info("UI will start to build");
        Label label = new Label(parent, SWT.NONE);
        label.setText("Eclipse 4");
        Text text = new Text(parent, SWT.NONE);
        text.setText(dao.getNumber());
    }

}

   Please note that this class uses the new operator for the user interface components. This
   implies that this part of the code is nothing you plan to replace via your tests. In this
   case you made the decision to have a hard coupling to the corresponding user interface
   toolkit.

1.3. Where can objects be injected into a class according to JSR330?
   Dependency injection can be performed on:
     * the constructor of the class (construction injection)
     * a field (field injection)
     * the parameters of a method (method injection)

   It is possible to use dependency injection on static and on non-static fields and methods.
   Avoiding dependency injection on static fields and methods is a good practice, as it has
   the following restrictions and can be hard to debug.
     * Static fields will be injected after the first object of the class was created via DI,
       which means no access to the static field in the constructor
     * Static fields can not be marked as final, otherwise the compiler or the application
       complains at runtime about them
     * Static methods are called only once after the first instance of the class was created

1.4. Order in which dependency injection is performed on a class
   According to JSR330 the injection is done in the following order:
     * constructor injection
     * field injection
     * method injection

   The order in which the methods or fields annotated with @Inject are called is not defined
   by JSR330. You cannot assume that the methods or fields are called in the order of their
   declaration in the class.
   As fields and method parameters are injected after the constructor is called, you cannot
   use injected member variables in the constructor.

2. Java and dependency injection frameworks
   You can use dependency injection without any additional framework by providing classes with
   sufficient constructors or getter and setter methods.

   A dependency injection framework simplifies the initialization of the classes with the
   correct objects.

   Two popular dependency injection frameworks are Spring and Google Guice.

   The usage of the Spring framework for dependency injection is described in Dependency
   Injection with the Spring Framework - Tutorial.

   Also Eclipse 4 is using dependency injection.


---
https://www.journaldev.com/2394/java-dependency-injection-design-pattern-example-tutorial

Java Dependency Injection – DI Design Pattern Example Tutorial

   Java Dependency Injection design pattern allows us to remove the hard-coded
   dependencies and make our application loosely coupled, extendable and maintainable. We can
   implement dependency injection in java to move the dependency resolution from compile-time
   to runtime.

Java Dependency Injection
   Java Dependency injection seems hard to grasp with theory, so I would take a simple example
   and then we will see how to use dependency injection pattern to achieve loose coupling and
   extendability in the application.

   Let's say we have an application where we consume EmailService to send emails. Normally we
   would implement this like below.
package com.journaldev.java.legacy;

public class EmailService {

        public void sendEmail(String message, String receiver){
                //logic to send email
                System.out.println("Email sent to "+receiver+ " with Message="+message);
        }
}

   EmailService class holds the logic to send an email message to the recipient email address.
   Our application code will be like below.
package com.journaldev.java.legacy;

public class MyApplication {

        private EmailService email = new EmailService();

        public void processMessages(String msg, String rec){
                //do some msg validation, manipulation logic etc
                this.email.sendEmail(msg, rec);
        }
}

   Our client code that will use MyApplication class to send email messages will be like
   below.
package com.journaldev.java.legacy;

public class MyLegacyTest {

        public static void main(String[] args) {
                MyApplication app = new MyApplication();
                app.processMessages("Hi Pankaj", "pankaj@abc.com");
        }

}

   At first look, there seems nothing wrong with the above implementation. But above code
   logic has certain limitations.
     * MyApplication class is responsible to initialize the email service and then use it.
       This leads to hard-coded dependency. If we want to switch to some other advanced email
       service in the future, it will require code changes in MyApplication class. This makes
       our application hard to extend and if email service is used in multiple classes then
       that would be even harder.
     * If we want to extend our application to provide an additional messaging feature, such
       as SMS or Facebook message then we would need to write another application for that.
       This will involve code changes in application classes and in client classes too.
     * Testing the application will be very difficult since our application is directly
       creating the email service instance. There is no way we can mock these objects in our
       test classes.

   One can argue that we can remove the email service instance creation from MyApplication
   class by having a constructor that requires email service as an argument.
package com.journaldev.java.legacy;

public class MyApplication {

        private EmailService email = null;

        public MyApplication(EmailService svc){
                this.email=svc;
        }

        public void processMessages(String msg, String rec){
                //do some msg validation, manipulation logic etc
                this.email.sendEmail(msg, rec);
        }
}

   But in this case, we are asking client applications or test classes to initializing the
   email service that is not a good design decision.

   Now let's see how we can apply java dependency injection pattern to solve all the problems
   with the above implementation. Dependency Injection in java requires at least the
   following:
    1. Service components should be designed with base class or interface. It's better to
       prefer interfaces or abstract classes that would define contract for the services.
    2. Consumer classes should be written in terms of service interface.
    3. Injector classes that will initialize the services and then the consumer classes.

Java Dependency Injection – Service Components
   For our case, we can have MessageService that will declare the contract for service
   implementations.
package com.journaldev.java.dependencyinjection.service;

public interface MessageService {

        void sendMessage(String msg, String rec);
}

   Now let's say we have Email and SMS services that implement the above interfaces.
package com.journaldev.java.dependencyinjection.service;

public class EmailServiceImpl implements MessageService {

        @Override
        public void sendMessage(String msg, String rec) {
                //logic to send email
                System.out.println("Email sent to "+rec+ " with Message="+msg);
        }

}

package com.journaldev.java.dependencyinjection.service;

public class SMSServiceImpl implements MessageService {

        @Override
        public void sendMessage(String msg, String rec) {
                //logic to send SMS
                System.out.println("SMS sent to "+rec+ " with Message="+msg);
        }

}

   Our dependency injection java services are ready and now we can write our consumer class.

Java Dependency Injection – Service Consumer
   We are not required to have base interfaces for consumer classes but I will have a Consumer
   interface declaring contract for consumer classes.
package com.journaldev.java.dependencyinjection.consumer;

public interface Consumer {

        void processMessages(String msg, String rec);
}

   My consumer class implementation is like below.
package com.journaldev.java.dependencyinjection.consumer;

import com.journaldev.java.dependencyinjection.service.MessageService;

public class MyDIApplication implements Consumer{

        private MessageService service;

        public MyDIApplication(MessageService svc){
                this.service=svc;
        }

        @Override
        public void processMessages(String msg, String rec){
                //do some msg validation, manipulation logic etc
                this.service.sendMessage(msg, rec);
        }

}

   Notice that our application class is just using the service. It does not initialize the
   service that leads to better "separation of concerns". Also use of service interface allows
   us to easily test the application by mocking the MessageService and bind the services at
   runtime rather than compile time.

   Now we are ready to write java dependency injector classes that will initialize the service
   and also consumer classes.

Java Dependency Injection – Injectors Classes
   Let's have an interface MessageServiceInjector with method declaration that returns the
   Consumer class.
package com.journaldev.java.dependencyinjection.injector;

import com.journaldev.java.dependencyinjection.consumer.Consumer;

public interface MessageServiceInjector {

        public Consumer getConsumer();
}

   Now for every service, we will have to create injector classes like below.
package com.journaldev.java.dependencyinjection.injector;

import com.journaldev.java.dependencyinjection.consumer.Consumer;
import com.journaldev.java.dependencyinjection.consumer.MyDIApplication;
import com.journaldev.java.dependencyinjection.service.EmailServiceImpl;

public class EmailServiceInjector implements MessageServiceInjector {

        @Override
        public Consumer getConsumer() {
                return new MyDIApplication(new EmailServiceImpl());
        }

}

package com.journaldev.java.dependencyinjection.injector;

import com.journaldev.java.dependencyinjection.consumer.Consumer;
import com.journaldev.java.dependencyinjection.consumer.MyDIApplication;
import com.journaldev.java.dependencyinjection.service.SMSServiceImpl;

public class SMSServiceInjector implements MessageServiceInjector {

        @Override
        public Consumer getConsumer() {
                return new MyDIApplication(new SMSServiceImpl());
        }

}

   Now let's see how our client applications will use the application with a simple program.
package com.journaldev.java.dependencyinjection.test;

import com.journaldev.java.dependencyinjection.consumer.Consumer;
import com.journaldev.java.dependencyinjection.injector.EmailServiceInjector;
import com.journaldev.java.dependencyinjection.injector.MessageServiceInjector;
import com.journaldev.java.dependencyinjection.injector.SMSServiceInjector;

public class MyMessageDITest {

        public static void main(String[] args) {
                String msg = "Hi Pankaj";
                String email = "pankaj@abc.com";
                String phone = "4088888888";
                MessageServiceInjector injector = null;
                Consumer app = null;

                //Send email
                injector = new EmailServiceInjector();
                app = injector.getConsumer();
                app.processMessages(msg, email);

                //Send SMS
                injector = new SMSServiceInjector();
                app = injector.getConsumer();
                app.processMessages(msg, phone);
        }

}

   As you can see that our application classes are responsible only for using the service.
   Service classes are created in injectors. Also if we have to further extend our application
   to allow facebook messaging, we will have to write Service classes and injector classes
   only.

   So dependency injection implementation solved the problem with hard-coded dependency and
   helped us in making our application flexible and easy to extend. Now let's see how easily
   we can test our application class by mocking the injector and service classes.

Java Dependency Injection – JUnit Test Case with Mock Injector and Service
package com.journaldev.java.dependencyinjection.test;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import com.journaldev.java.dependencyinjection.consumer.Consumer;
import com.journaldev.java.dependencyinjection.consumer.MyDIApplication;
import com.journaldev.java.dependencyinjection.injector.MessageServiceInjector;
import com.journaldev.java.dependencyinjection.service.MessageService;

public class MyDIApplicationJUnitTest {

        private MessageServiceInjector injector;
        @Before
        public void setUp(){
                //mock the injector with anonymous class
                injector = new MessageServiceInjector() {

                        @Override
                        public Consumer getConsumer() {
                                //mock the message service
                                return new MyDIApplication(new MessageService() {

                                        @Override
                                        public void sendMessage(String msg, String rec) {
                                                System.out.println("Mock Message Service implementat
ion");

                                        }
                                });
                        }
                };
        }

        @Test
        public void test() {
                Consumer consumer = injector.getConsumer();
                consumer.processMessages("Hi Pankaj", "pankaj@abc.com");
        }

        @After
        public void tear(){
                injector = null;
        }

}

   As you can see that I am using anonymous classes to mock the injector and service
   classes and I can easily test my application methods. I am using JUnit 4 for the above test
   class, so make sure it's in your project build path if you are running above test class.

   We have used constructors to inject the dependencies in the application classes, another
   way is to use a setter method to inject dependencies in application classes. For setter
   method dependency injection, our application class will be implemented like below.
package com.journaldev.java.dependencyinjection.consumer;

import com.journaldev.java.dependencyinjection.service.MessageService;

public class MyDIApplication implements Consumer{

        private MessageService service;

        public MyDIApplication(){}

        //setter dependency injection
        public void setService(MessageService service) {
                this.service = service;
        }

        @Override
        public void processMessages(String msg, String rec){
                //do some msg validation, manipulation logic etc
                this.service.sendMessage(msg, rec);
        }

}

package com.journaldev.java.dependencyinjection.injector;

import com.journaldev.java.dependencyinjection.consumer.Consumer;
import com.journaldev.java.dependencyinjection.consumer.MyDIApplication;
import com.journaldev.java.dependencyinjection.service.EmailServiceImpl;

public class EmailServiceInjector implements MessageServiceInjector {

        @Override
        public Consumer getConsumer() {
                MyDIApplication app = new MyDIApplication();
                app.setService(new EmailServiceImpl());
                return app;
        }

}

   One of the best example of setter dependency injection is Struts2 Servlet API Aware
   interfaces.

   Whether to use Constructor based dependency injection or setter based is a design decision
   and depends on your requirements. For example, if my application can't work at all without
   the service class then I would prefer constructor based DI or else I would go for setter
   method based DI to use it only when it's really needed.

   Dependency Injection in Java is a way to achieve Inversion of control (IoC) in our
   application by moving objects binding from compile time to runtime. We can achieve IoC
   through Factory Pattern, Template Method Design Pattern, Strategy Pattern and
   Service Locator pattern too.

   Spring Dependency Injection, Google Guice and Java EE CDI frameworks facilitate the
   process of dependency injection through use of Java Reflection API and java
   annotations. All we need is to annotate the field, constructor or setter method and
   configure them in configuration xml files or classes.

Benefits of Java Dependency Injection
   Some of the benefits of using Dependency Injection in Java are:
     * Separation of Concerns
     * Boilerplate Code reduction in application classes because all work to initialize
       dependencies is handled by the injector component
     * Configurable components makes application easily extendable
     * Unit testing is easy with mock objects

Disadvantages of Java Dependency Injection
   Java Dependency injection has some disadvantages too:
     * If overused, it can lead to maintenance issues because the effect of changes are known
       at runtime.
     * Dependency injection in java hides the service class dependencies that can lead to
       runtime errors that would have been caught at compile time.


---
https://www.baeldung.com/java-ee-cdi

An Introduction to CDI (Contexts and Dependency Injection) in Java

1. Overview
   CDI (Contexts and Dependency Injection) is a standard dependency injection framework
   included in Java EE 6 and higher.

   It allows us to manage the lifecycle of stateful components via domain-specific lifecycle
   contexts and inject components (services) into client objects in a type-safe way.

   In this tutorial, we'll take an in-depth look at CDI's most relevant features and implement
   different approaches for injecting dependencies in client classes.

2. DYDI (Do-it-Yourself Dependency Injection)
   In a nutshell, it's possible to implement DI without resorting to any framework at all.

   This approach is popularly known as DYDI (Do-it-Yourself Dependency Injection).

   With DYDI, we keep application code isolated from object creation by passing the required
   dependencies into the client classes through plain old factories/builders.

   Here's how a basic DYDI implementation might look like:
public interface TextService {
    String doSomethingWithText(String text);
    String doSomethingElseWithText(String text);
}
public class SpecializedTextService implements TextService { ... }
public class TextClass {
    private TextService textService;

    // constructor
}
public class TextClassFactory {

    public TextClass getTextClass() {
        return new TextClass(new SpecializedTextService();
    }
}

   Of course, DYDI is suitable for some relatively simple use cases.

   If our sample application grew in size and complexity, implementing a larger network of
   interconnected objects, we would end up polluting it with tons of object graph factories.

   This would require a lot of boilerplate code just for creating object graphs. This is not a
   fully-scalable solution.

   Can we do DI any better? Of course, we can. Here's exactly where CDI comes into the
   picture.

3. A Simple Example
   CDI turns DI into a no-brainer process, boiled down to just decorating the service classes
   with a few simple annotations, and defining the corresponding injection points in the
   client classes.

   To showcase how CDI implements DI at the most basic level, let's suppose that we want to
   develop a simple image file editing application. Capable of opening, editing, writing,
   saving an image file and so on.

  3.1. The "beans.xml" File

   First, we must place a "beans.xml" file in the "src/main/resources/META-INF/" folder. Even
   if this file doesn't contain any specific DI directives at all, it's required for getting
   CDI up and running:
<beans xmlns="http://java.sun.com/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
  http://java.sun.com/xml/ns/javaee/beans_1_0.xsd">
</beans>

  3.2. The Service Classes
   Next, let's create the service classes that perform the file mentioned above operations on
   GIF, JPG and PNG files:
public interface ImageFileEditor {
    String openFile(String fileName);
    String editFile(String fileName);
    String writeFile(String fileName);
    String saveFile(String fileName);
}
public class GifFileEditor implements ImageFileEditor {

    @Override
    public String openFile(String fileName) {
        return "Opening GIF file " + fileName;
    }

    @Override
    public String editFile(String fileName) {
      return "Editing GIF file " + fileName;
    }

    @Override
    public String writeFile(String fileName) {
        return "Writing GIF file " + fileName;
    }

    @Override
    public String saveFile(String fileName) {
        return "Saving GIF file " + fileName;
    }
}
public class JpgFileEditor implements ImageFileEditor {
    // JPG-specific implementations for openFile() / editFile() / writeFile() / saveFile()
    ...
}
public class PngFileEditor implements ImageFileEditor {
    // PNG-specific implementations for openFile() / editFile() / writeFile() / saveFile()
    ...
}

  3.3. The Client Class
   Finally, let's implement a client class that takes an ImageFileEditor implementation in the
   constructor, and let's define an injection point with the @Inject annotation:
public class ImageFileProcessor {

    private ImageFileEditor imageFileEditor;

    @Inject
    public ImageFileProcessor(ImageFileEditor imageFileEditor) {
        this.imageFileEditor = imageFileEditor;
    }
}

   Simply put, the @Inject annotation is CDI's actual workhorse. It allows us to define
   injection points in the client classes.

   In this case, @Inject instructs CDI to inject an ImageFileEditor implementation in the
   constructor.

   Furthermore, it's also possible to inject a service by using the @Inject annotation in
   fields (field injection) and setters (setter injection). We'll look at these options later.

  3.4. Building the ImageFileProcessor Object Graph with Weld

   Of course, we need to make sure that CDI will inject the right ImageFileEditor
   implementation into the ImageFileProcessor class constructor.

   To do so, first, we should get an instance of the class.

   As we won't rely on any Java EE application server for using CDI, we'll do this with
   Weld, the CDI reference implementation in Java SE:
public static void main(String[] args) {
    Weld weld = new Weld();
    WeldContainer container = weld.initialize();
    ImageFileProcessor imageFileProcessor = container.select(ImageFileProcessor.class).get();

    System.out.println(imageFileProcessor.openFile("file1.png"));

    container.shutdown();
}

   Here, we're creating a WeldContainer object, then getting an ImageFileProcessor object, and
   finally calling its openFile() method.

   As expected, if we run the application, CDI will complain loudly by throwing a
   DeploymentException:
Unsatisfied dependencies for type ImageFileEditor with qualifiers @Default at injection point...

   We're getting this exception because CDI doesn't know what ImageFileEditor implementation
   to inject into the ImageFileProcessor constructor.

   In CDI's terminology, this is known as an ambiguous injection exception.

  3.5. The @Default and @Alternative Annotations

   Solving this ambiguity is easy. CDI, by default, annotates all the implementations of an
   interface with the @Default annotation.

   So, we should explicitly tell it which implementation should be injected into the client
   class:
@Alternative
public class GifFileEditor implements ImageFileEditor { ... }
@Alternative
public class JpgFileEditor implements ImageFileEditor { ... }

public class PngFileEditor implements ImageFileEditor { ... }

   In this case, we've annotated GifFileEditor and JpgFileEditor with the @Alternative
   annotation, so CDI now knows that PngFileEditor (annotated by default with the @Default
   annotation) is the implementation that we want to inject.

   If we rerun the application, this time it'll be executed as expected:
Opening PNG file file1.png

   Furthermore, annotating PngFileEditor with the @Default annotation and keeping the other
   implementations as alternatives will produce the same above result.

   This shows, in a nutshell, how we can very easily swap the run-time injection of
   implementations by simply switching the @Alternative annotations in the service classes.

4. Field Injection
   CDI supports both field and setter injection out of the box.

   Here's how to perform field injection (the rules for qualifying services with the @Default
   and @Alternative annotations remain the same):

@Inject
private final ImageFileEditor imageFileEditor;

5. Setter Injection
   Similarly, here's how to do setter injection:
@Inject
public void setImageFileEditor(ImageFileEditor imageFileEditor) { ... }

6. The @Named Annotation
   So far, we've learned how to define injection points in client classes and inject services
   with the @Inject, @Default , and @Alternative annotations, which cover most of the use
   cases.

   Nevertheless, CDI also allows us to perform service injection with the @Named annotation.

   This method provides a more semantic way of injecting services, by binding a meaningful
   name to an implementation:
@Named("GifFileEditor")
public class GifFileEditor implements ImageFileEditor { ... }

@Named("JpgFileEditor")
public class JpgFileEditor implements ImageFileEditor { ... }

@Named("PngFileEditor")
public class PngFileEditor implements ImageFileEditor { ... }

   Now, we should refactor the injection point in the ImageFileProcessor class to match a
   named implementation:
@Inject
public ImageFileProcessor(@Named("PngFileEditor") ImageFileEditor imageFileEditor) { ... }

   It's also possible to perform field and setter injection with named implementations, which
   looks very similar to using the @Default and @Alternative annotations:
@Inject
private final @Named("PngFileEditor") ImageFileEditor imageFileEditor;

@Inject
public void setImageFileEditor(@Named("PngFileEditor") ImageFileEditor imageFileEditor) { ... }

7. The @Produces Annotation
   Sometimes, a service requires some configuration to be fully-initialized before it gets
   injected to handle additional dependencies.

   CDI provides support for these situations, through the @Produces annotation.

   @Produces allows us to implement factory classes, whose responsibility is the creation of
   fully-initialized services.

   To understand how the @Produces annotation works, let's refactor the ImageFileProcessor
   class, so it can take an additional TimeLogger service in the constructor.

   The service will be used for logging the time at which a certain image file operation is
   performed:

@Inject
public ImageFileProcessor(ImageFileEditor imageFileEditor, TimeLogger timeLogger) { ... }

public String openFile(String fileName) {
    return imageFileEditor.openFile(fileName) + " at: " + timeLogger.getTime();
}

// additional image file methods

   In this case, the TimeLogger class takes two additional services, SimpleDateFormat and
   Calendar:
public class TimeLogger {

    private SimpleDateFormat dateFormat;
    private Calendar calendar;

    // constructors

    public String getTime() {
        return dateFormat.format(calendar.getTime());
    }
}

   How do we tell CDI where to look at for getting a fully-initialized TimeLogger object?

   We just create a TimeLogger factory class and annotate its factory method with the
   @Produces annotation:
public class TimeLoggerFactory {

    @Produces
    public TimeLogger getTimeLogger() {
        return new TimeLogger(new SimpleDateFormat("HH:mm"), Calendar.getInstance());
    }
}

   Whenever we get an ImageFileProcessor instance, CDI will scan the TimeLoggerFactory class,
   then call the getTimeLogger() method (as it's annotated with the @Produces annotation), and
   finally inject the Time Logger service.

   If we run the refactored sample application with Weld, it'll output the following:
Opening PNG file file1.png at: 17:46

8. Custom Qualifiers
   CDI supports the use of custom qualifiers for qualifying dependencies and solving ambiguous
   injection points.

   Custom qualifiers are a very powerful feature. They not only bind a semantic name to a
   service, but they bind injection metadata too. Metadata such as the RetentionPolicy and
   the legal annotation targets (ElementType).

   Let's see how to use custom qualifiers in our application:
@Qualifier
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.TYPE, ElementType.PARAMETER})
public @interface GifFileEditorQualifier {}

@Qualifier
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.TYPE, ElementType.PARAMETER})
public @interface JpgFileEditorQualifier {}

@Qualifier
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.TYPE, ElementType.PARAMETER})
public @interface PngFileEditorQualifier {}

   Now, let's bind the custom qualifiers to the ImageFileEditor implementations:
@GifFileEditorQualifier
public class GifFileEditor implements ImageFileEditor { ... }

@JpgFileEditorQualifier
public class JpgFileEditor implements ImageFileEditor { ... }
@PngFileEditorQualifier
public class PngFileEditor implements ImageFileEditor { ... }

   Lastly, let's refactor the injection point in the ImageFileProcessor class:
@Inject
public ImageFileProcessor(@PngFileEditorQualifier ImageFileEditor imageFileEditor, TimeLogger timeLo
gger) { ... }

   If we run our application once again, it should generate the same output shown above.

   Custom qualifiers provide a neat semantic approach for binding names and annotation
   metadata to implementations.

   In addition, custom qualifiers allow us to define more restrictive type-safe injection
   points (outperforming the functionality of the @Default and @Alternative annotations).

   If only a subtype is qualified in a type hierarchy, then CDI will only inject the subtype,
   not the base type.

9. Conclusion
   Unquestionably, CDI makes dependency injection a no-brainer, the cost of the extra
   annotations is very little effort for the gain of organized dependency injection.

   There are times when DYDI does still have its place over CDI. Like when developing fairly
   simple applications that only contain simple object graphs.

   As always, all the code samples shown in this article are available over on GitHub.


---
https://www.baeldung.com/java-constructors-vs-static-factory-methods

Java Constructors vs Static Factory Methods
September 11, 2019

1. Overview
   Java constructors are the default mechanism for getting fully-initialized class instances.
   After all, they provide all the infrastructure required for injecting dependencies, either
   manually or automatically.

   Even so, in a few specific use cases, it's preferable to resort to static factory methods
   for achieving the same result.

   In this tutorial, we'll be highlighting the pros and cons of using static factory methods
   vs plain old Java constructors.

2. Advantages of Static Factory Methods over Constructors
   In an object-oriented language like Java, what could be wrong with constructors? Overall,
   nothing. Even so, the famous Joshua Block's Effective Java Item 1 clearly states:

     "Consider static factory methods instead of constructors"

   While this isn't a silver bullet, here are the most compelling reasons that sustain this
   approach:
    1. Constructors don't have meaningful names, so they are always restricted to the standard
       naming convention imposed by the language. Static factory methods can have meaningful
       names, hence explicitly conveying what they do
    2. Static factory methods can return the same type that implements the method(s), a
       subtype, and also primitives, so they offer a more flexible range of returning types
    3. Static factory methods can encapsulate all the logic required for pre-constructing
       fully initialized instances, so they can be used for moving this additional logic out
       of constructors. This prevents constructors from performing further tasks, others
       than just initializing fields
    4. Static factory methods can be controlled-instanced methods, with the Singleton
       pattern being the most glaring example of this feature

3. Static Factory Methods in the JDK
   There are plenty of examples of static factory methods in the JDK that showcase many of the
   advantages outlined above. Let's explore some of them.

  3.1. The String Class
   Because of the well-known String interning, it's very unlikely we'll use the String
   class constructor to create a new String object. Even so, this is perfectly legal:
String value = new String("Baeldung");

   In this case, the constructor will create a new String object, which is the expected
   behavior.

   Alternatively, if we want to create a new String object using a static factory method, we
   can use some of the following implementations of the valueOf() method:

String value1 = String.valueOf(1);
String value2 = String.valueOf(1.0L);
String value3 = String.valueOf(true);
String value4 = String.valueOf('a');

   There are several overloaded implementations of valueOf(). Each one will return a new
   String object, depending on the type of the argument passed to the method (e.g. int, long,
   boolean, char, and so forth).

   The name expresses pretty clearly what the method does. It also sticks to a
   well-established standard in the Java ecosystem for naming static factory methods.

  3.2. The Optional Class
   Another neat example of static factory methods in the JDK is the Optional class. This
   class implements a few factory methods with pretty meaningful names, including empty(),
   of(), and ofNullable():
Optional<String> value1 = Optional.empty();
Optional<String> value2 = Optional.of("Baeldung");
Optional<String> value3 = Optional.ofNullable(null);

  3.3. The Collections Class
   Quite possibly the most representative example of static factory methods in the JDK is the
   Collections class. This is a non-instantiable class that implements only static
   methods.

   Many of these are factory methods that also return collections, after applying to the
   supplied collection some type of algorithm.

   Here are some typical examples of the class' factory methods:
Collection syncedCollection = Collections.synchronizedCollection(originalCollection);
Set syncedSet = Collections.synchronizedSet(new HashSet());
List<Integer> unmodifiableList = Collections.unmodifiableList(originalList);
Map<String, Integer> unmodifiableMap = Collections.unmodifiableMap(originalMap);

   The number of static factory methods in the JDK is really extensive, so we'll keep the list
   of examples short for brevity's sake.

   Nevertheless, the above examples should give us a clear idea of how ubiquitous static
   factory methods are in Java.

4. Custom Static Factory Methods
   Of course, we can implement our own static factory methods. But when is it really worth
   doing so, instead of creating class instances via plain constructors?

   Let's see a simple example.

   Let's consider this naive User class:
public class User {

    private final String name;
    private final String email;
    private final String country;

    public User(String name, String email, String country) {
        this.name = name;
        this.email = email;
        this.country = country;
    }

    // standard getters / toString
}

   In this case, there're no visible warnings to indicate that a static factory method could
   be better than the standard constructor.

   What if we want that all the User instances get a default value for the country field?

   If we initialize the field with a default value, we'd have to refactor the constructor too,
   hence making the design more rigid.

   We can use a static factory method instead:
public static User createWithDefaultCountry(String name, String email) {
    return new User(name, email, "Argentina");
}

   Here's how we'd get a User instance with a default value assigned to the country field:
User user = User.createWithDefaultCountry("John", "john@domain.com");

5. Moving Logic Out of Constructors
   Our User class could quickly rot into a flawed design if we decide to implement features
   that would require adding further logic to the constructor (alarm bells should be sounding
   off by this time).

   Let's suppose that we want to provide the class with the ability for logging the time at
   which every User object is created.

   If we just put this logic into the constructor, we'd be breaking the Single
   Responsibility Principle. We would end up with a monolithic constructor that does a lot
   more than initialize fields.

   We can keep our design clean with a static factory method:
public class User {

    private static final Logger LOGGER = Logger.getLogger(User.class.getName());
    private final String name;
    private final String email;
    private final String country;

    // standard constructors / getters

    public static User createWithLoggedInstantiationTime(
      String name, String email, String country) {
        setLoggerProperties();
        LOGGER.log(Level.INFO, "Creating User instance at : {0}", LocalTime.now());
        return new User(name, email, country);
    }

    private static void setLoggerProperties() {
        ConsoleHandler handler = new ConsoleHandler();
        handler.setLevel(Level.INFO);
        handler.setFormatter(new SimpleFormatter());
        LOGGER.addHandler(handler);
    }
}

   Here's how we'd create our improved User instance:
User user
  = User.createWithLoggedInstantiationTime("John", "john@domain.com", "Argentina");

6. Instance-Controlled Instantiation
   As shown above, we can encapsulate chunks of logic into static factory methods before
   returning fully-initialized User objects. And we can do this without polluting the
   constructor with the responsibility of performing multiple, unrelated tasks.

   For instance, suppose we want to make our User class a Singleton. We can achieve this by
   implementing an instance-controlled static factory method:
public class User {

    private static volatile User instance = null;

    // other fields / standard constructors / getters

    public static User getSingletonInstance(String name, String email, String country) {
        if (instance == null) {
            synchronized (User.class) {
                if (instance == null) {
                    instance = new User(name, email, country);
                }
            }
        }
        return instance;
    }
}

   The implementation of the getSingletonInstance() method is thread-safe, with a small
   performance penalty, due to the synchronized block.

   In this case, we used lazy initialization to demonstrate the implementation of an
   instance-controlled static factory method.

   It's worth mentioning, however, that the best way to implement a Singleton is with a Java
   enum type, as it's both serialization-safe and thread-safe. For the full details on how to
   implement Singletons using different approaches, please check this article.

   As expected, getting a User object with this method looks very similar to the previous
   examples:

User user = User.getSingletonInstance("John", "john@domain.com", "Argentina");

7. Conclusion
   In this article, we explored a few use cases where static factory methods can be a better
   alternative to using plain Java constructors.

   Moreover, this refactoring pattern is so tightly rooted to a typical workflow that most
   IDEs will do it for us.

   Of course, Apache NetBeans, IntelliJ IDEA, and Eclipse will perform the
   refactoring in slightly different ways, so please make sure first to check your IDE
   documentation.

   As with many other refactoring patterns, we should use static factory methods with due
   caution, and only when it's worth the trade-off between producing more flexible and clean
   designs and the cost of having to implement additional methods.

   As usual, all the code samples shown in this article are available over on GitHub.


---
https://dzone.com/articles/constructors-or-static-factory-methods

Constructors or Static Factory Methods?

When it comes to instantiating objects, which is better: Constructors or static factory methods?
We take a look at one opinion.

   I believe Joshua Bloch said it first in his very good book "Effective Java": static
   factory methods are the preferred way to instantiate objects compared with constructors. I
   disagree. Not only because I believe that static methods are pure evil, but mostly because
   in this particular case they pretend to be good and make us think that we have to love
   them.

   Let's analyze the reasoning and see why it's wrong, from an object-oriented point of view.

   This is a class with one primary and two secondary constructors:
class Color {
    private final int hex;
    Color(String rgb) {
        this(Integer.parseInt(rgb, 16));
    }
    Color(int red, int green, int blue) {
        this(red << 16 + green << 8 + blue);
    }
    Color(int h) {
        this.hex = h;
    }
}

   This is a similar class with three static factory methods:
class Color {
    private final int hex;
    static Color makeFromRGB(String rgb) {
        return new Color(Integer.parseInt(rgb, 16));
    }
    static Color makeFromPalette(int red, int green, int blue) {
        return new Color(red << 16 + green << 8 + blue);
    }
    static Color makeFromHex(int h) {
        return new Color(h);
    }
    private Color(int h) {
        return new Color(h);
    }
}

   Which one do you like better?
   According to Joshua Bloch, there are three basic advantages to using static factory methods
   instead of constructors (there are actually four, but the fourth one is not applicable to
   Java anymore):
     * They have names.
     * They can cache.
     * They can subtype.

   I believe that all three make perfect sense ... if the design is wrong. They are good
   excuses for workarounds. Let's take them one by one.

They Have Names
   This is how you make a red tomato color object with a constructor:
Color tomato = new Color(255, 99, 71);

   This is how you do it with a static factory method:
Color tomato = Color.makeFromPalette(255, 99, 71);

   It seems that makeFromPalette() is semantically richer than just new Color(), right? Well,
   yes. Who knows what those three numbers mean if we just pass them to the constructor. But
   the word "palette" helps us figure everything out immediately.

   True.

   However, the right solution would be to use polymorphism and encapsulation, to decompose
   the problem into a few semantically rich classes:
interface Color {}
class HexColor implements Color {
    private final int hex;
    HexColor(int h) {
        this.hex = h;
    }
}
class RGBColor implements Color {
    private final Color origin;
    RGBColor(int red, int green, int blue) {
        this.origin = new HexColor(
            red << 16 + green << 8 + blue
        );
    }
}

   Now, we use the right constructor of the right class:
Color tomato = new RGBColor(255, 99, 71);

   See, Joshua?

They Can Cache
   Let's say I need a red tomato color in multiple places in the application:
Color tomato = new Color(255, 99, 71);
// ... sometime later
Color red = new Color(255, 99, 71);

   Two objects will be created, which is obviously inefficient, since they are identical. It
   would be better to keep the first instance somewhere in memory and return it when the
   second call arrives. Static factory methods make it possible to solve this very problem:
Color tomato = Color.makeFromPalette(255, 99, 71);
// ... sometime later
Color red = Color.makeFromPalette(255, 99, 71);

   Then somewhere inside the Color we keep a private static Map with all the objects already
   instantiated:
class Color {
    private static final Map < Integer, Color > CACHE =
        new HashMap < > ();
    private final int hex;
    static Color makeFromPalette(int red, int green, int blue) {
        final int hex = red << 16 + green << 8 + blue;
        return Color.CACHE.computeIfAbsent(
            hex, h - > new Color(h)
        );
    }
    private Color(int h) {
        return new Color(h);
    }
}

   It is very effective performance-wise. With a small object like our Color the problem may
   not be so obvious, but when objects are bigger, their instantiation and garbage collection
   may waste a lot of time.

   True.

   However, there is an object-oriented way to solve this problem. We just introduce a new
   class Palette, which becomes a store of colors:
class Palette {
    private final Map < Integer, Color > colors =
        new HashMap < > ();
    Color take(int red, int green, int blue) {
        final int hex = red << 16 + green << 8 + blue;
        return this.computerIfAbsent(
            hex, h - > new Color(h)
        );
    }
}

   Now, we make an instance of Palette once and ask it to return a color to us every time we
   need it:
Color tomato = palette.take(255, 99, 71);
// Later we will get the same instance:
Color red = palette.take(255, 99, 71);

   See, Joshua, no static methods, no static attributes.

They Can Subtype
   Let's say our class Color has a method lighter(), which is supposed to shift the color to
   the next available lighter one:
class Color {
    protected final int hex;
    Color(int h) {
        this.hex = h;
    }
    public Color lighter() {
        return new Color(hex + 0x111);
    }
}

   However, sometimes it's more desirable to pick the next lighter color through a set of
   available Pantone colors:
class PantoneColor extends Color {
    private final PantoneName pantone;
    PantoneColor(String name) {
        this(new PantoneName(name));
    }
    PantoneColor(PantoneName name) {
        this.pantone = name;
    }
    @Override
    public Color lighter() {
        return new PantoneColor(this.pantone.up());
    }
}

   Then, we create a static factory method, which will decide which Color implementation is
   the most suitable for us:
class Color {
    private final String code;
    static Color make(int h) {
        if (h == 0xBF1932) {
            return new PantoneColor("19-1664 TPX");
        }
        return new RGBColor(h);
    }
}

   If the true red color is requested, we return an instance of PantoneColor. In all other
   cases it's just a standard RGBColor. The decision is made by the static factory method.
   This is how we will call it:
Color color = Color.make(0xBF1932);

   It would not be possible to do the same "forking" with a constructor, since it can only
   return the class it is declared in. A static method has all the necessary freedom to return
   any subtype of Color.

   True.

   However, in an object-oriented world we can and must do it all differently. First, we would
   make Color an interface:
interface Color {
    Color lighter();
}

   Next, we would move this decision making process to its own class Colors, just like we did
   in the previous example:
class Colors {
    Color make(int h) {
        if (h == 0xBF1932) {
            return new PantoneColor("19-1664-TPX");
        }
        return new RGBColor(h);
    }
}

   And we would use an instance of class Colors instead of a static faсtory method inside
   Color:
colors.make(0xBF1932);

   However, this is still not really an object-oriented way of thinking, because we're taking
   the decision-making away from the object it belongs to. Either through a static factory
   method make() or a new class Colors-it doesn't really matter how-we tear our objects into
   two pieces. The first piece is the object itself and the second one is the decision making
   algorithm that stays somewhere else.

   A much more object-oriented design would be to put the logic into an object of class
   PantoneColor which would decorate the original RGBColor:
class PantoneColor {
    private final Color origin;
    PantoneColor(Color color) {
        this.origin = color;
    }
    @Override
    public Color lighter() {
        final Color next;
        if (this.origin.hex() == 0xBF1932) {
            next = new RGBColor(0xD12631);
        } else {
            next = this.origin.lighter();
        }
        return new PantoneColor(next);
    }
)

   Then, we make an instance of RGBColor and decorate it with PantoneColor:
Color red = new PantoneColor(
    new RGBColor(0xBF1932)
);

   We ask red to return a lighter color and it returns the one from the Pantone palette, not
   the one that is merely lighter in RGB coordinates:
Color lighter = red.lighter(); // 0xD12631

   Of course, this example is rather primitive and needs further improvement if we really
   want it to be applicable to all Pantone colors, but I hope you get the idea. The logic must
   stay inside the class, not somewhere outside, not in static factory methods or even in some
   other supplementary class. I'm talking about the logic that belongs to this particular
   class, of course. If it's something related to the management of class instances, then
   there can be containers and stores, just like in the previous example above.

   To summarize, I would strongly recommend you never use static methods, especially when they
   are going to replace object constructors. Giving birth to an object through its constructor
   is the most "sacred" moment in any object-oriented software, don't miss the beauty of
   it.


---
