filename: jv_dependency_injection_02-multif_20201006.txt
https://www.freecodecamp.org/news/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f/

A quick intro to Dependency Injection: what it is, and when to use it
18 October 2018

Introduction
     In software engineering, dependency injection is a technique whereby one object (or static
     method) supplies the dependencies of another object. A dependency is an object that can be used (a
     service).

   That's the Wikipedia definition but still, but it's not particularly easy to understand. So let's
   understand it better.

   Before understanding what it means in programming, let's first see what it means in general as it
   will help us understand the concept better.

   Dependency or dependent means relying on something for support. Like if I say we are relying too much
   on mobile phones than it means we are dependent on them.

   So before getting to dependency injections, first let's understand what a dependency in
   programming means.

   When class A uses some functionality of class B, then its said that class A has a dependency of class B.

   In Java, before we can use methods of other classes, we first need to create the object of that class
   (i.e. class A needs to create an instance of class B).

   So, transferring the task of creating the object to someone else and directly using the dependency is
   called dependency injection.

Why should I use dependency injection?
   Let's say we have a car class which contains various objects such as wheels, engine, etc.

   Here the car class is responsible for creating all the dependency objects. Now, what if we decide to
   ditch MRFWheels in the future and want to use Yokohama Wheels?

   We will need to recreate the car object with a new Yokohama dependency. But when using dependency
   injection (DI), we can change the Wheels at runtime (because dependencies can be injected at runtime
   rather than at compile time).

   You can think of DI as the middleman in our code who does all the work of creating the preferred
   wheels object and providing it to the Car class.

   It makes our Car class independent from creating the objects of Wheels, Battery, etc.

There are basically three types of dependency injection:
    1. constructor injection: the dependencies are provided through a class constructor.
    2. setter injection: the client exposes a setter method that the injector uses to inject the
       dependency.
    3. interface injection: the dependency provides an injector method that will inject the dependency
       into any client passed to it. Clients must implement an interface that exposes a setter method
       that accepts the dependency.

   So now its the dependency injection's responsibility to:
    1. Create the objects
    2. Know which classes require those objects
    3. And provide them all those objects

   If there is any change in objects, then DI looks into it and it should not concern the class using
   those objects. This way if the objects change in the future, then its DI's responsibility to provide
   the appropriate objects to the class.

Inversion of control -the concept behind DI
   This states that a class should not configure its dependencies statically but should be configured by
   some other class from outside.

   It is the fifth principle of S.O.L.I.D - the five basic principles of object-oriented programming and
   design by Uncle Bob - which states that a class should depend on abstraction and not upon
   concretions (in simple terms, hard-coded).

   According to the principles, a class should concentrate on fulfilling its responsibilities and not on
   creating objects that it requires to fulfill those responsibilities. And that's where dependency
   injection comes into play: it provides the class with the required objects.

   Note: If you want to learn about SOLID principles by Uncle Bob then you can head to this link.

Benefits of using DI
    1. Helps in Unit testing.
    2. Boiler plate code is reduced, as initializing of dependencies is done by the injector component.
    3. Extending the application becomes easier.
    4. Helps to enable loose coupling, which is important in application programming.

Disadvantages of DI
    1. It's a bit complex to learn, and if overused can lead to management issues and other problems.
    2. Many compile time errors are pushed to run-time.
    3. Dependency injection frameworks are implemented with reflection or dynamic programming. This can
       hinder use of IDE automation, such as "find references", "show call hierarchy" and safe
       refactoring.

   You can implement dependency injection on your own (Pure Vanilla) or use third-party libraries or
   frameworks.

Libraries and Frameworks that implement DI
     * Spring (Java)
     * Google Guice (Java)
     * Dagger (Java and Android)
     * Castle Windsor (.NET)
     * Unity(.NET)

   To learn more about dependency injection, you can check out the below resources:
   * Java Dependency Injection - DI Design Pattern Example Tutorial - JournalDev
   * Using dependency injection in Java - Introduction - Tutorial - Vogella
   * Inversion of Control Containers and the Dependency Injection pattern - Martin Fowler


---
https://dzone.com/articles/dependency-injection-an-introd

Spring Dependency Injection - An Introductory Tutorial
Nov. 11, 08

   This article discusses dependency injection in a tutorial format. It covers some of the newer
   features of Spring DI such as annotations, improved XML configuration and more.

Dependency Injection
   Dependency Injection (DI) refers to the process of supplying an external dependency to a software
   component. DI can help make your code architecturally pure. It aids in design by interface as well as
   test-driven development by providing a consistent way to inject dependencies. For example, a data
   access object (DAO) may depend on a database connection. Instead of looking up the database
   connection with JNDI, you could inject it.
   One way to think about a DI container like Spring is to think of JNDI turned inside out. Instead of
   an object looking up other objects that it needs to get its job done (dependencies), a DI container
   injects those dependent objects. This is the so-called Hollywood Principle, "Don't call us" (lookup
   objects), "we'll call you" (inject objects).
   If you have worked with CRC cards you can think of a dependency as a collaborator, i.e., an object
   that another object needs to perform its role.
   Let's say that you have an automated teller machine (ATM) and it needs the ability to talk to a bank.
   It uses what it calls a transport object to do this. In this example, a transport object handles the
   low-level communication to the bank.
   This example could be represented by either of the  two interfaces as follows:
   AutomatedTellerMachine interface
package com.arcmind.springquickstart;

import java.math.BigDecimal;

public interface AutomatedTellerMachine {
    void deposit(BigDecimal bd);
    void withdraw(BigDecimal bd);
}


   ATMTransport interface
package com.arcmind.springquickstart;

public interface ATMTransport {
    void communicateWithBank(byte [] datapacket);
}

   Now the AutomatedTellerMachine needs a transport to perform its intent, namely withdraw money and
   deposit money. To carry out these tasks, the AutomatedTellerMachine may depend on many objects and
   collaborates with its dependencies to complete the work.
   An implementation of the AutomatedTellerMachine may look like this:

   AutomatedTellerMachine implementation:
package com.arcmind.springquickstart;

import java.math.BigDecimal;

public class AutomatedTellerMachineImpl implements AutomatedTellerMachine{

    private ATMTransport transport;

    public void deposit(BigDecimal bd) {
      ...
        transport.communicateWithBank(...);
    }

    public void withdraw(BigDecimal bd) {
      ...
        transport.communicateWithBank(...);
    }

    public void setTransport(ATMTransport transport) {
        this.transport = transport;
    }
}

   The AutomatedTellerMachineImpl does not know or care how the transport withdraws and deposits money
   from the bank. This level of indirection allows us to replace the transport with different
   implementations such as in the following example:
   Three example transports: SoapAtmTransport, StandardAtmTransport and SimulationAtmTransport
package com.arcmind.springquickstart;

public class SoapAtmTransport implements ATMTransport {

    public void communicateWithBank(byte[] datapacket) {
       ...
    }

}

package com.arcmind.springquickstart;

public class StandardAtmTransport implements ATMTransport {

    public void communicateWithBank(byte[] datapacket) {
      ...
    }
}


package com.arcmind.springquickstart;

public class SimulationAtmTransport implements ATMTransport {

    public void communicateWithBank(byte[] datapacket) {
        ...
    }
}

   Notice the possible implementations of the ATMTransport interface. The AutomatedTellerMachineImpl
   does not know or care which transport it uses. Also, for testing and developing, instead of talking
   to a real bank, notice that you can use the SimulationAtmTransport.

   The concept of DI transcends Spring. Thus, you can accomplish DI without Spring as follows:

   DI without Spring

package com.arcmind.springquickstart;

import java.math.BigDecimal;

public class AtmMain {

    public void main (String[] args) {
        AutomatedTellerMachine atm = new AutomatedTellerMachineImpl();
        ATMTransport transport = new SoapAtmTransport();
        /* Inject the transport. */
        ((AutomatedTellerMachineImpl)atm).setTransport(transport);

        atm.withdraw(new BigDecimal("10.00"));

        atm.deposit(new BigDecimal("100.00"));
    }
}


   Then injecting a different transport is a mere matter of calling a different setter method as
   follows:

   Injecting a different dependency
    ATMTransport transport = new SimulationAtmTransport();
    ((AutomatedTellerMachineImpl)atm).setTransport(transport);

   To use Spring to inject a dependency you could do the following:

   Using Spring to manage dependencies
package com.arcmind.springquickstart;

import java.math.BigDecimal;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AtmMain {

    public static void main (String[] args) {
        ApplicationContext appContext = new ClassPathXmlApplicationContext("classpath:./spring/applicationContext.xml");
        AutomatedTellerMachine atm = (AutomatedTellerMachine) appContext.getBean("atm");
        atm.withdraw(new BigDecimal("10.00"));
        atm.deposit(new BigDecimal("100.00"));
    }
}

   /spring/applicationContext.xml file
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

    <bean id="atmTransport" class="com.arcmind.springquickstart.SoapAtmTransport" />

    <bean id="atm" class="com.arcmind.springquickstart.AutomatedTellerMachineImpl">
        <property name="transport" ref="atmTransport" />
    </bean>
</beans>


   Figure 1 illustrates how Spring injects the dependency using property setter method injection.

   [img_assist|nid=5868|title=|desc=|link=none|align=undefined|width=720|height=540]

   The application context is the central interface to the Spring DI container. In the application
   context, you declare two beans, atmTransport and atm, with a bean tag. Then you use the property tag
   to inject the atmTransport bean into the transport property. This effectively calls the setter method
   of the AutomatedTellerMachineImpl transport property (setTransport(...)).

   The major capabilities that the application context provides include (taken from API docs):
     * Bean factory methods for accessing application components
     * The ability to load file resources in a generic fashion
     * The ability to resolve messages, supporting internationalization

   The focus of this article is bean factory methods and DI.

Using constructor instead of setter
   Another option when using Spring is to use constructor arguments instead of setter methods to inject
   dependencies. This keeps things more pure from an object-oriented design standpoint as an object has
   to be created with all of its collaborators (a.k.a. dependencies) it needs to fulfill its role.
   Using constructors, injection is much like using setter methods as follows:
   Application context for constructor injection
 <bean id="standardTransport" class="com.arcmind.springquickstart.StandardAtmTransport"/>

    <bean id="atm" class="com.arcmind.springquickstart.AutomatedTellerMachineImpl">
        <constructor-arg ref="standardTransport" />
    </bean>


   Notice the use of the constructor-arg tag. This implies that the constructor takes transport as a
   single argument.
   Adding a constructor to AutomatedTellerMachineImpl
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {

    private ATMTransport transport;

    public AutomatedTellerMachineImpl (ATMTransport transport) {
        this.transport = transport;
    }

   The above example should keep the object purists in your group happy. However, the setter injection
   style makes test-driven development a bit easier. In practice, the setter method approach is used
   more often.
   Figure 2 illustrates how the constructor injection occurs.

   [img_assist|nid=5869|title=|desc=|link=none|align=undefined|width=720|height=540]

   If you have many constructors in the same class with a variable number of arguments, Spring will try
   to pick the best fit. However, you can give Spring some hints as follows:
   Application context for constructor injection with a hint for Spring
    <bean id="atm" class="com.arcmind.springquickstart.AutomatedTellerMachineImpl">
        <constructor-arg index="0" ref="standardTransport" />
    </bean>

   Under some circumstances, you can even specify the type attribute that you want Spring to use to
   resolve the constructor argument in cases when there are more than one possible constructor match.
   Most times, you don't have to specify index or type. Your mileage may vary.

Spring and Annotation driven DI
   Seam, and Guice pioneered the use of DI using annotation instead of XML. Spring also added this
   support and in typical Spring fashion, it does this in a flexible non-invasive manner.
   Let's start off with a simple example. Let's say that you misconfigured the
   AutomatedTellerMachineImpl and forgot to inject a dependency as follows:
   Opps forgot to inject the transport
    <bean id="atmTransport" class="com.arcmind.springquickstart.SoapAtmTransport" />


    <bean id="atm" class="com.arcmind.springquickstart.AutomatedTellerMachineImpl">
    </bean>

   You might get an error like this:
   Typical error from misconfiguring a bean

     Exception in thread "main" java.lang.NullPointerException
             at com.arcmind.springquickstart.AutomatedTellerMachineImpl.withdraw(AutomatedTellerMachineImpl.java:25)
             at com.arcmind.springquickstart.AtmMain.main(AtmMain.java:14)

   In a deployed application, this error could be quite cryptic. If you used the @Required annotation,
   you could ask Spring to scan the beans and look for missing dependencies as follows:
   AutomatedTellerMachineImpl using @Required on the setter method of the transport property
import org.springframework.beans.factory.annotation.Required;

public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {

    private ATMTransport transport;

    @Required
    public void setTransport(ATMTransport transport) {
        this.transport = transport;
    }


   Now, when you run this after forgetting to configure a transport, you would get this message:

     Caused by: org.springframework.beans.factory.BeanInitializationException: Property 'transport' is
     required for bean 'atm'

   This is clearer and makes it easier to develop and debug applications. To enable this dependency
   checking feature, you must use context:component-scan or the context:annotation-config tags. This is
   discussed in more detail later. Here is the last example using context:annotation-config:

   Application context file using annotation-config tag
<?xml version="1.0" encoding="UTF-8"?>
<beans
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd">

    <context:annotation-config/>

    <bean id="atmTransport" class="com.arcmind.springquickstart.SoapAtmTransport" />


    <bean id="atm" class="com.arcmind.springquickstart.AutomatedTellerMachineImpl">
        <property name="transport" ref="atmTransport"/>
    </bean>
</beans>

Using @Autowire to define a default transport
   You may want to define a default transport for an AutomatedTellerMachine. You could do this with the
   @Autowire and @Qualifier annotations as follows:
   Using @Autowire and @Qualifier annotations to do DI
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class AutomatedTellerMachineImpl implements AutomatedTellerMachine{

    @Autowired (required=true)
    @Qualifier ("standardTransport")
    private ATMTransport transport;

    When using Spring annotations for DI, you do not need to have setter methods (or special
   constructors) any longer. Spring can inject directly into private fields or you have the option of
   annotating the setter methods instead. The applicationContext for this example looks like this:
   Many transports configured in applicationContext, no injection specified in XML
<?xml version="1.0" encoding="UTF-8"?>
<beans
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd">

    <context:annotation-config/>

    <bean id="soapTransport" class="com.arcmind.springquickstart.SoapAtmTransport" />
    <bean id="standardTransport" class="com.arcmind.springquickstart.StandardAtmTransport" />
    <bean id="simulationTransport" class="com.arcmind.springquickstart.SimulationAtmTransport" />


    <bean id="atm" class="com.arcmind.springquickstart.AutomatedTellerMachineImpl"/>
</beans>

   Notice that no transport for injection is specified in this file. The annotations specify which
   transport gets injected by default. Figure 3 illustrates injection using this technique.

   [img_assist|nid=5870|title=|desc=|link=none|align=undefined|width=720|height=540]

   You could override which bean gets set by using standard Spring injection. In this way, you have a
   default (standardTransport) that can be overridden. Here is an example of overriding with another
   transport when you have a setter method for transport.

   Overriding the annotation in the application context file
    <bean id="soapTransport" class="com.arcmind.springquickstart.SoapAtmTransport" />
    <bean id="standardTransport" class="com.arcmind.springquickstart.StandardAtmTransport" />
    <bean id="simulationTransport" class="com.arcmind.springquickstart.SimulationAtmTransport" />


    <bean id="atm" class="com.arcmind.springquickstart.AutomatedTellerMachineImpl">
        <property name="transport" ref="simulationTransport"/>
    </bean>

   The XML DI injection takes precedence over the annotation. Therefore, the annotation is the
   "reasonable default", but the application context file has the final word.


Avoiding hard-wiring beans directly to other beans with @Qualifier and qualifier tag
   For an extra level of indirection, you can add a qualifier to a bean in the configuration file and
   then specify which type of transport is needed in the AutomatedTellerMachineImpl as follows:
   Using @Qualifier for an extra level of indirection
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine{

    @Autowired (required=true)
    @Qualifier ("default")
    private ATMTransport transport;

   Using qualifier tag in applicationContext.xml
    <bean id="soapTransport" class="com.arcmind.springquickstart.SoapAtmTransport" />
    <bean id="standardTransport" class="com.arcmind.springquickstart.StandardAtmTransport">
        <qualifier value="default"/>
        <!-- NOTE ADDED THIS QUALIFIER that marks this as default -->
    </bean>
    <bean id="simulationTransport" class="com.arcmind.springquickstart.SimulationAtmTransport" />

    <bean id="atm" class="com.arcmind.springquickstart.AutomatedTellerMachineImpl"/>

   With this extra level of indirection, you are not hard-wiring beans directly to other beans, and if
   you decide that you should use a new default transport object you don't have to rewire every
   dependent bean.
   Figure 4 illustrates injection using this technique.

   [img_assist|nid=5871|title=|desc=|link=none|align=undefined|width=720|height=540]

Avoiding XML hell with component-scan tag and @Service, @Component, @Repository annotations
   Imagine an application with hundreds of managed objects and the size of the XML configuration
   file(s). You can manage objects with Spring without putting them in the applicationContext files by
   marking them with @Service, @Component, or @Repository, and telling Spring where to find the objects.
   Spring will next scan the classpath looking for these beans and then automatically manage their
   dependencies.
   To perform this feat, you must configure a context:component-scan tag passing the packages you would
   like Spring to scan as follows:
   Using component-scan tag in applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd">

    <context:component-scan base-package="com.arcmind.springquickstart"/>
</beans>

   Then you mark your beans with the @Service, @Component, or @Repository as follows:
   AutomatedTellerMachine class using @Service
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

@Service ("atm")
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {

    @Autowired (required=true)
    @Qualifier ("default")
    private ATMTransport transport;

   Three transports using @Component
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component("standardTransport")
@Qualifier("default")
public class StandardAtmTransport implements ATMTransport {

    public void communicateWithBank(byte[] datapacket) {
        ...
    }

}

@Component("soapTransport")
public class SoapAtmTransport implements ATMTransport {

    public void communicateWithBank(byte[] datapacket) {
        ...
    }

}

@Component("simulationTransport")
public class SimulationAtmTransport implements ATMTransport {

    public void communicateWithBank(byte[] datapacket) {
        ...
    }

}

   Notice that there is a @Qualifier annotation used in the StandardAtmTransport to denote it as the
   default transport for this application. For new projects, it makes sense to use annotations for
   objects that don't often change their dependencies. Avoiding XML and using annotation is the new
   trend in DI; some say it is a best practice. Figure 5 illustrates injection using this technique.

   [img_assist|nid=5872|title=|desc=|link=none|align=undefined|width=720|height=540]

Configuring objects
   In addition to injecting dependencies, Spring allows you to configure objects with primitive and
   basic types. Let's say that the SoapAtmTransport sometimes has to work in areas where the connection
   is not so great, so you decide to add a retries property to the SoapAtmTransport as follows:

   SoapAtmTransport with retries
public class SoapAtmTransport implements ATMTransport {

    private int retries=3;

    public SoapAtmTransport() {
    }

    public SoapAtmTransport(int retries) {
        this.retries = retries;
    }

    public void setRetries(int retries) {
        this.retries = retries;
    }

    public void communicateWithBank(byte[] datapacket) {
        System.out.printf("SOAP Transport retries %d: %s \n", retries, new String(datapacket));
    }
}

   Notice that you can pass the retries to the constructor or call the setter method with the number or
   retries as follows:
   Injecting the number of retries with the setter method
    <bean id="soapTransport" class="com.arcmind.springquickstart.SoapAtmTransport">
        <property name="retries" value="5"/>
    </bean>

   Injecting the number of retires with a constructor arg
    <bean id="soapTransport" class="com.arcmind.springquickstart.SoapAtmTransport">
        <constructor-arg value="6"/>
    </bean>


   Figure 6 illustrates configuring retries using setter method injection.

   [img_assist|nid=5873|title=|desc=|link=none|align=undefined|width=720|height=540]

   Figure 7 illustrates configuring retries using constructor arguments.

   [img_assist|nid=5874|title=|desc=|link=none|align=undefined|width=720|height=540]
   
   Since this type of configuration is so common, Spring has a shortcut to simplify property value
   injection as follows:
   Using p namespace in an applicationContext.xml file
<?xml version="1.0" encoding="UTF-8"?>
<beans
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd">

    <bean id="soapTransport" class="com.arcmind.springquickstart.SoapAtmTransport" p:retries="7"/>

    <bean id="atm" class="com.arcmind.springquickstart.AutomatedTellerMachineImpl">
        <constructor-arg index="0" ref="soapTransport" />
    </bean>
</beans>

   Notice the use of p:retries="7" is much less verbose than the previous example that used the property
   tag to set the value. If you are using the Spring IDE plugin for Eclipse, you will get code
   completion for the p:property-name-syntax. Figure 8 illustrates configuring retries using the
   shortcut notation added in Spring 2.x.

   [img_assist|nid=5875|title=|desc=|link=none|align=undefined|width=720|height=540]

   Spring allows you to configure all primitive types (int, byte, long, etc.), as well as wrapper
   objects (Integer, Byte, Long, etc.), and many basic types (String, URL, Class, File, etc.).

Using property place holder configurer
   Let's say for each installation of an ATM, the installer may need to configure the number of retries.
   You probably don't want the installer messing with your XML file for your application context because
   it is too much like code and too many things could go wrong. Instead, perhaps you could just edit a
   properties file. The properties file could have properties for each of the things that may vary for a
   given installation of an AutomatedTellerMachineImpl.

   atm.properties Properties file

     transport.retries=8

   applicationContext.xml using property-placeholder tag
<?xml version="1.0" encoding="UTF-8"?>
<beans
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd">

    <context:property-placeholder location="classpath:atm.properties"   />

    <bean id="soapTransport" class="com.arcmind.springquickstart.SoapAtmTransport" p:retries="${transport.retries}"/>

    <bean id="atm" class="com.arcmind.springquickstart.AutomatedTellerMachineImpl">
        <constructor-arg index="0" ref="soapTransport" />
    </bean>
</beans>

   Notice the property-placeholder loads the atm.properties file from the classpath. Then you use the
   transport.retries defined in the atm.properties file as follows: p:retries="${transport.retries}".
   Figure 9 illustrates using the property placeholder configurer.

   [img_assist|nid=5876|title=|desc=|link=none|align=undefined|width=720|height=540]

   You could load properties file from the file system using file: instead of classpath: in the location
   as follows:
   Loading the properties file from the file system with the property-placeholder
    <context:property-placeholder location="file:./src/main/resources/atm.properties"   />


    <bean id="soapTransport" class="com.arcmind.springquickstart.SoapAtmTransport" p:retries="${transport.retries}"/>

    <bean id="atm" class="com.arcmind.springquickstart.AutomatedTellerMachineImpl">
        <constructor-arg index="0" ref="soapTransport" />
    </bean>

Scopes and lifecycle
   Spring supports the concepts of scopes. If you are familiar with JSP and Servlets, you may recall
   that they have request, session and application scopes. Objects put into request scope stay around
   for the duration of one request. Objects put into session scope stay around the entire user session
   (unless destroyed manually) while objects put into application scope stay around as long as the web
   application is running.

   Spring scope support is very similar that of JSP and Servlets. Spring supports the following scopes:
   prototype, singleton, request, session and more. Plus you can configure you own scope handlers.
   Outside of a web application, Spring mainly supports two scopes out of the box: prototype and
   singleton. A singleton-scoped object is the default. It means that the object will stay around as
   long as the application context does (typically, very similar to application scope in a web
   application). A prototype scope means that every time that you ask for an object, Spring will create
   a new one. For example:

   Two atms configured with different scopes
    <bean id="atm" class="com.arcmind.springquickstart.AutomatedTellerMachineImpl" scope="singleton">
        <constructor-arg index="0" ref="soapTransport" />
    </bean>

    <bean id="atmP" class="com.arcmind.springquickstart.AutomatedTellerMachineImpl" scope="prototype">
        <constructor-arg index="0" ref="soapTransport" />
    </bean>


   If you looked up the atm twice, you would get the same object because it is in singleton scope;
   however, every time you looked up atmP, you would get a different object because it is in prototype
   scope. This is demonstrated by the following example:

   Example demonstrating prototype vs. singleton
        AutomatedTellerMachine atm1 = (AutomatedTellerMachine) appContext.getBean("atm");
        AutomatedTellerMachine atm2 = (AutomatedTellerMachine) appContext.getBean("atm");
        assert atm1 == atm2; //First assert

        AutomatedTellerMachine atmP1 = (AutomatedTellerMachine) appContext.getBean("atmP");
        AutomatedTellerMachine atmP2 = (AutomatedTellerMachine) appContext.getBean("atmP");
        assert atmP1 != atmP2; //Second assert

Life cycle methods
   Often times, you need an object to initialize itself after you have set all of the dependencies.
   Spring allows you to specify specify an init method as follows:

   Specifying an init method with Spring (applicationContext.xml)
    <bean id="atm" class="com.arcmind.springquickstart.AutomatedTellerMachineImpl" scope="singleton" init-method="init">
        <constructor-arg index="0" ref="soapTransport" />
    </bean>

    <bean id="atmP" class="com.arcmind.springquickstart.AutomatedTellerMachineImpl" scope="prototype" init-method="init">
        <constructor-arg index="0" ref="soapTransport" />
    </bean>

   Notice the use of the init-method attribute in the bean tag. The name of the method does not have to
   be init.
   Here is the init method defined in Java. (There are also a few more methods for the transport to add
   to the flavor of the of the example and a shutdown method which the article will discuss in a
   moment).

   Init Method and Shutdown method in Java
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine{

    public void init () {
        System.out.println("INIT");
        transport.connect();
    }

    public void shutdown () {
        System.out.println("SHUTDOWN");
        transport.close();
    }


   The atm bean's init method gets called right after your first load the application context (you can
   change this by setting the lazy-init attribute to "true"). The prototype atmP bean's init method gets
   called every time you look it up in the application context.
   You can also specify a clean up method using the attribute destroy-method as follows:
   Using destroy-method attribute
    <bean id="atm" class="com.arcmind.springquickstart.AutomatedTellerMachineImpl" scope="singleton"
        init-method="init" destroy-method="shutdown">
        <constructor-arg index="0" ref="soapTransport" />
    </bean>

    <bean id="atmP" class="com.arcmind.springquickstart.AutomatedTellerMachineImpl" scope="prototype"
        init-method="init" destroy-method="shutdown">
        <constructor-arg index="0" ref="soapTransport" />
    </bean>

   The destroy method would never get called by Spring on atmP because it does not manage the life cycle
   of prototype beans after creation. The destroy method on atm would only get called if someone
   gracefully closed the application context which Spring does for some application contexts (this is
   beyond the scope of this introductory tutorial). Figure 10 illustrates using lifecycle methods.

[img_assist|nid=5877|title=|desc=|link=none|align=undefined|width=720|height=540]

Conclusion
   DI can help make your code architecturally pure. It aids in using a design-by-interface approach as
   well as test-driven development by providing a consistent way to inject dependencies. You don't need
   Spring to use DI. You could use DI with plain old Java. However, Spring provides a very nice,
   powerful DI container.
   There are other DI containers and frameworks out there such as Plexus, Pico container, JBoss
   microcontainer, and, more recently, Guice. And, other frameworks allow DI like JSF, Seam and more.
   But, Spring is the de facto industry standard way to do DI.

   What we did not cover is also interesting. We did not cover autowiring using by type or by name or
   constructor autowiring as these are features that developers just don't use in a production
   environments. A future tutorial titled, "DI details", will cover this as well as many other topics
   related to Spring DI like bean definitions, using lists, maps and sets, FactoryBeans,
   ApplicationContextAware, and, yes, autowiring.
   The next item in this tutorial series will be AOP. Followed by Spring DAO and JPA support.


---
https://www.vojtechruzicka.com/field-dependency-injection-considered-harmful/

Field Dependency Injection Considered Harmful
Jun 21, 2018

field injection
   Field injection is a very popular practice in Dependency Injection frameworks, such as Spring. It
   has, however, several serious trade-offs and should generally be avoided.

Injection Types
   There are three main ways to inject your dependencies into your class. Constructor, Setter (Method)
   and Field injection. Let's quickly compare the code of the same dependencies injected by all the
   approaches.

Constructor
private DependencyA dependencyA;
private DependencyB dependencyB;
private DependencyC dependencyC;

@Autowired
public DI(DependencyA dependencyA, DependencyB dependencyB, DependencyC dependencyC) {
    this.dependencyA = dependencyA;
    this.dependencyB = dependencyB;
    this.dependencyC = dependencyC;
}

Setter
private DependencyA dependencyA;
private DependencyB dependencyB;
private DependencyC dependencyC;

@Autowired
public void setDependencyA(DependencyA dependencyA) {
    this.dependencyA = dependencyA;
}

@Autowired
public void setDependencyB(DependencyB dependencyB) {
    this.dependencyB = dependencyB;
}

@Autowired
public void setDependencyC(DependencyC dependencyC) {
    this.dependencyC = dependencyC;
}

Field
@Autowired
private DependencyA dependencyA;

@Autowired
private DependencyB dependencyB;

@Autowired
private DependencyC dependencyC;

What is wrong?
   As you can see, the Field variant looks very nice. It is very short, concise, there is no boilerplate
   code. The code is easy to read and navigate. Your class can just focus on the important and is not
   polluted by DI boilerplate. You just put the @Autowired annotation above the fields and that's it. No
   special constructors or setters just for DI container to provide your dependencies. Java is very
   verbose as is, so every opportunity to make your code shorter is welcome, right?

Single Responsibility Principle Violation
   It is very easy to add new dependencies. Maybe too easy. There is no problem in adding six, ten or
   even dozen dependencies. When you are using constructors for DI, after a certain point, the number of
   constructor params becomes too high and it is immediately obvious that something is wrong. Having too
   many dependencies usually means that the class has too many responsibilities. That may be a violation
   of Single Responsibility Principle and separation of concerns and is a good indicator, that the class
   requires further inspection and possible refactoring. There is no such red flag when injecting
   directly into fields as this approach can scale indefinitely.

Dependency Hiding
   Using DI container means that the class is no longer responsible for managing its own
   dependencies. Responsibility for obtaining the dependencies is extracted from the class. Someone
   other is now responsible for providing the dependencies - DI container or manually assigning them in
   tests. When the class is no longer responsible for obtaining its dependencies, it should clearly
   communicate them using public interface - methods or constructors. This way it is clear what the
   class requires and also whether it is optional (setters) or mandatory (constructors).

DI Container Coupling
   One of the core ideas of the DI frameworks is that the managed class should have no dependency on the
   DI container used. In other words, it should be just a plain POJO, which can be instantiated
   independently, provided you pass it all the required dependencies. This way you can instantiate it in
   a unit test without starting the DI container and test it separately (with a container that would be
   more of integration test). If there is no container coupling, you can use the class either as managed
   or non-managed or even switch to a new DI framework.

   However, when injecting directly into fields, you provide no direct way of instantiating the class
   with all its required dependencies. That means:
     * There is a way (by calling the default constructor) to create an object using new in a state when
       it lacks some of its mandatory collaborators and usage will result in the NullPointerException.
     * Such a class cannot be reused outside DI containers (tests, other modules) as there is no way
       except reflection to provide it with its required dependencies.

Immutability
   Unlike constructor, field injection cannot be used to assign dependencies to final fields effectively
   rendering your objects mutable.

Constructor vs Setter Injection
   So the Field injection may not be the way to go. What's left? Setters and Constructors. Which one
   should be used?

Setters
   Setters should be used to inject optional dependencies. The class should be able to function when
   they are not provided. The dependencies can be changed anytime after the object is instantiated. That
   may on may not be an advantage depending on the circumstances. Sometimes it is desirable to have an
   immutable object. Sometimes it is good to change the object's collaborators at runtime - such as JMX
   managed MBeans.

   The official recommendation from Spring 3.x documentation encourages the use of setters over
   constructors:

     The Spring team generally advocates setter injection, because large numbers of constructor
     arguments can get unwieldy, especially when properties are optional. Setter methods also make
     objects of that class amenable to reconfiguration or re-injection later. Management through
     JMX MBeans is a compelling use case.

     Some purists favor constructor-based injection. Supplying all object dependencies means that the
     object is always returned to client (calling) code in a totally initialized state. The
     disadvantage is that the object becomes less amenable to reconfiguration and re-injection.

Constructors
   Constructor injection is good for mandatory dependencies. Those, which are required for the object to
   function properly. By supplying those in the constructor, you can be sure that the object is ready to
   be used the moment it is constructed. Fields assigned in the constructor can also be final, allowing
   the object to be either completely immutable or at least protect its required fields.

   One consequence of using a constructor to provide dependencies is that circular dependency between
   two objects constructed in such way is no longer possible (unlike with setter injection). That is
   actually a good thing rather than limitation as circular dependencies should be avoided and are
   usually a sign of a bad design. This way such a practice is prevented.

   Another advantage is that if using spring 4.3+, you can completely decouple your class from DI
   frameworks. The reason is that Spring now supports implicit constructor injection for one
   constructor scenarios. That means you no longer need DI annotations in your classes. Of course, you
   could achieve the same with explicitly configuring DI in your spring configs for given class, this
   just makes this whole lot easier.

   As of Spring 4.x, the official recommendation from Spring documentation changes and setter
   injection is no longer encouraged over constructor:

     The Spring team generally advocates constructor injection as it enables one to implement
     application components as immutable objects and to ensure that required dependencies are not null.
     Furthermore, constructor-injected components are always returned to client (calling) code in a
     fully initialized state. As a side note, a large number of constructor arguments is a bad code
     smell, implying that the class likely has too many responsibilities and should be refactored to
     better address proper separation of concerns.

     Setter injection should primarily only be used for optional dependencies that can be assigned
     reasonable default values within the class. Otherwise, not-null checks must be performed
     everywhere the code uses the dependency. One benefit of setter injection is that setter methods
     make objects of that class amenable to reconfiguration or re-injection later.

UPDATE: IntelliJ IDEA support
   Since this article was published, IDEA introduced some sweet support for detecting and easily fixing
   Field Injection. It can automatically remove the @Autowired annotation from the field and instead
   create a constructor with @Autowired dependency, effectively replacing field injection with
   constructor injection.

   IntelliJ IDEA field injection fix

Conclusion
   Field injection should be mostly avoided. As a replacement, you should use either constructors or
   methods to inject your dependencies. Both have its advantages and disadvantages and the usage depends
   on the situation. However, as those approaches can be mixed, it is not an either-or choice and you
   can combine both setter and constructor injection in one class. Constructors are more suitable for
   mandatory dependencies and when aiming for immutability. Setters are better for optional
   dependencies.


---
https://dotnettutorials.net/lesson/setter-dependency-injection-design-pattern-csharp/

Property and Method Dependency Injection in C#

   In this article, I am going to discuss how to implement Property and Method Dependency Injection in
   C# with examples. Please read our previous article before proceeding to this article where we
   discussed Constructor Dependency Injection in C# with an example. We are also going to work with
   the same example that we created in our previous article. As part of this article, we are going to
   discuss the following pointers in detail.
    1. What is Property Dependency Injection in C#?
    2. Example using Property Dependency Injection.
    3. When to use Property Injection over Constructor Injection and vice versa?
    4. What is Method Dependency Injection in C#?
    5. Example using Method Dependency Injection.
    6. What are the advantages of using Dependency Injection?

What is Property Dependency Injection in C#?

   In Property Dependency Injection, we need to supply the dependency object through a public property
   of the client class. Let us see an example to understand how we can implement the Property or you can
   say setter dependency injection in C#.

   Modify the EmployeeBL class as shown below
namespace DependencyInjectionExample
{
    public class EmployeeBL
    {
        private IEmployeeDAL employeeDAL;

        public IEmployeeDAL employeeDataObject
        {
            set
            {
                this.employeeDAL = value;
            }
            get
            {
                if (employeeDataObject == null)
                {
                    throw new Exception("Employee is not initialized");
                }
                else
                {
                    return employeeDAL;
                }
            }
        }

        public List<Employee> GetAllEmployees()
        {
            return employeeDAL.SelectAllEmployees();
        }
    }
}

   As you can see in the above example, we are injecting the dependency object through a public property
   of the EmployeeBL class. As we are setting the object through the setter property, we can call this
   as Setter Dependency Injection in C#. Here we need to use the property EmployeeDataObject in order to
   access the instance of IEmployeeDAL.

Change the Main method of Program class as shown below to inject the object through a property

namespace DependencyInjectionExample
{
    class Program
    {
        static void Main(string[] args)
        {
            EmployeeBL employeeBL = new EmployeeBL();
            employeeBL.employeeDataObject = new EmployeeDAL();

            List<Employee> ListEmployee = employeeBL.GetAllEmployees();
            foreach(Employee emp in ListEmployee)
            {
                Console.WriteLine("ID = {0}, Name = {1}, Department = {2}", emp.ID, emp.Name, emp.Department);
            }
            Console.ReadKey();
        }
    }
}

   Now run the application and you will see the output as expected as shown below.
   
Output:
    ID = 1, Name = Pranaya, Department = IT
    ID = 2, Name = Kumar, Department = HR
    ID = 3, Name = Rout, Department = Payroll

        
   The Property or Setter Dependency Injection in C# does not require the constructor to be changed.
   Here the dependency objects are going to be passed through the public properties of the client class.
   We need to use the Setter or Property Dependency Injection when we want to create the dependency
   object as late as possible or we can say when it is required.

When to use Property Dependency Injection over Constructor Injection and vice versa?
   The Constructor Dependency Injection in C# is the standard for dependency injection. It ensures that
   all the dependency objects are initialized before we are going to invoke any methods or properties of
   the dependency object, as a result, it avoids the null reference exceptions.

   The Setter/Property Dependency Injection in C# is rarely used in real-time applications. For example,
   if I have a class that has several methods but those methods do not depend on any other objects. Now
   I need to create a new method within the same class but that new method now depends on another
   object. If we use the constructor dependency injection here, then we need to change all the existing
   constructor calls where we created this class object. This can be a very difficult task if the
   project is a big one. Hence, in such scenarios, the Setter or Property Dependency Injection can be a
   good choice.

What is Method Dependency Injection in C#?
   In Method Dependency Injection, we need to supply the dependency object through a public method of
   the client class. Let us see an example to understand how we can implement the Method dependency
   injection in C#.

   Modify the EmployeeBL class as shown below
namespace DependencyInjectionExample
{
    public class EmployeeBL
    {
        public IEmployeeDAL employeeDAL;

        public List<Employee> GetAllEmployees(IEmployeeDAL _employeeDAL)
        {
            employeeDAL = _employeeDAL;
            return employeeDAL.SelectAllEmployees();
        }
    }
}

   Modify the Main method of Program class as shown below
namespace DependencyInjectionExample
{
    class Program
    {
        static void Main(string[] args)
        {
            //Create object of EmployeeBL class
            EmployeeBL employeeBL = new EmployeeBL();

            //Call to GetAllEmployees method with proper object.
            List<Employee> ListEmployee = employeeBL.GetAllEmployees(new EmployeeDAL());

            foreach (Employee emp in ListEmployee)
            {
                Console.WriteLine("ID = {0}, Name = {1}, Department = {2}", emp.ID, emp.Name, emp.Department);
            }
            Console.ReadKey();
        }
    }
}

   Now run the application and see the output as expected as shown below

Output:
    ID = 1, Name = Pranaya, Department = IT
    ID = 2, Name = Kumar, Department = HR
    ID = 3, Name = Rout, Department = Payroll

   Setter Dependency Injection Design Pattern in C#

   Note: We need to use the Method Dependency Injection in C# when the entire class does not depend on
   the dependency object but a single method of that class depends on the dependency object.

What are the advantages of using Dependency Injection in C#?
    1. The Dependency Injection Design Pattern allows us to develop loosely coupled software components.
    2. Using Dependency Injection, it is very easy to swap with a different implementation of a
       component, as long as the new component implements the interface type.

Dependency Injection Container:
   There are a lot of Dependency Injection Containers are available in the market which implements the
   dependency injection design pattern. Some of the commonly used Dependency Injection Containers are as
   follows.
    1. Unity
    2. Castle Windsor
    3. StructureMap
    4. Spring.NET

   In the next article, I am going to discuss how to implement Dependency Injection in ASP.NET MVC
   using the Unity Container. Here, in this article, I try to explain the Property and Method Dependency
   Injection in C# steps by step with an example. I hope you enjoy this article.


---
http://coders-kitchen.com/2015/01/05/dependency-injection-field-vs-constructor-vs-method/

Dependency Injection - Field vs Constructor vs Method
January 5, 2015

   Hi,

   today I would like to discuss in short different ways of injecting dependencies into your classes.

   In general you have the following three options for injection
     * directly into fields/attributes
     * via explicit setter methods
     * via explicit constructor parameters

Field injection
   This type of injection instruments some kind of reflection mechanism for injecting the required
   dependencies into the class.

   While this injection type has the benefit, that it removes clutter code like setter methods or
   constructor parameters, it has the drawback that these dependencies are invisible. If you look at the
   class from the outside, you will only see the public methods and may be the constructor.

   Even if this gives you a very clear idea what services a class provides, it has, in my opinion, this
   major drawback:

   When writing tests for this particular class you have to inspect the class to see what are the
   required dependencies and must use either invoke the DI framework, even for simple tests, or use a
   kind of reflection mechanism to inject the dependencies (mocked / stubbed / real).

   To make it even worse, the number of incoming dependencies is hidden within the class. Of course you
   can use tools (JDepend, etc. pp.) that tells you the number and direction of dependencies, or have a
   file that specifies the injection, but you must rely on this kind of tooling or inspect the class.

   Another drawback I observed is, that the chance for creating a class that has multiple
   responsibilities is higher than compared to the situation when using Setter or Constructor Injection.
   It's like

     Oh let's use this fancy annotation to inject the service we need here ... Few days / hours later:
     It's so difficult to test this beast

Setter Injection
   Setter injection instruments setter methods, one per dependency, that are used by the DI framework to
   inject the dependencies.

   It's a variant that makes the dependencies explicit and  gives you a clear overview of the
   dependencies of the particular class.

   During testing it has the benefit that you mustn't use the DI framework or reflection mechanisms but
   can directly set the dependencies.

   The drawback of this approach is: You can construct a class that is in a state where it can't work.
   This is because you can't distinguish from the outside if a dependency is required or optional.

Constructor Injection
   Constructor injection instruments the constructor of a class, which used by the DI framework to
   inject the dependencies. It is the other variant that makes dependencies explicit.

   In opposite to the Setter Injection it prevents you to create a class in irregular state. (Of course
   you can pass null, but this is than a kind of cheating, isn't it?)  So I would say, that this is the
   most strict variant:

   Each dependency is mandatory

   The benefits of this injection type are
    1. you have to read exactly one method, the constructor, to figure out what are the dependencies of
       this class.
    2. you create an immutable class which makes caching and so easier

   The drawback here is, again, you can't distinguish between optional and required dependencies. The
   constructor enforces that all fields are set.

   The last variant I would like to discuss is

Mixing Setter and Constructor Injection
   This variant, I personally prefer, mixes the Setter and Constructor Injection.

   This gives you
     * the ability to distinguish between mandatory dependencies and optional on a contractual level
     * states clearly what the dependencies of a specific class are
     * enables you easily to check if a class has to much responsibilities
     * a properly configured class after construction

   Testing with this kind of injection is, similar to the pure approaches, fairly simple. You don't need
   the DI framework and can easily pass mocked / stubbed / real implementations into your class under
   test.

What to use / prefer?

   This answer depends heavily on your framework / team rule / language.

   But I would strongly recommend to go for one of  the explicit injection variants, because they enable
   you to write pure unit tests without using the dependency injection framework.


---
https://stackoverflow.com/questions/30061268/dependency-injection-for-java-8-default-interface-methods

Dependency injection for java 8 default interface methods

   I have an interface that defines a setter/getter using java 8 default methods, but I am getting an
   error when attempting to wire it up in Spring. I really want to avoid using abstract class and I
   don't want to duplicate the code. Here is what I am doing:
public interface MyProcessor {
    public static final WeakHashMap<Function1D, Integer> paramMap = new WeakHashMap<>();
    
    default void setParam(int param) {
        paramMap.put(this, param);
    }
    
    default int getParam() {
        return paramMap.get(this);
    }
    
    default double doSomthingWithParam(double x) {
        return doSomething() * getParam();
    }
    
    double doSomething();
 }


public class MyProcessorImp extends SomeClass implements MyProcessor {
    double doSomething() {....}
 }

  <bean class="....MyProcessorImp"> <property name="param" value="3"/></bean>

   Bean property 'param' is not writable or has an invalid setter method.

***
       Why do you want to avoid using an abstract class? Inheriting implementation is exactly what
       abstract classes are for. Also, did you really mean for paramMap to be static? Note that this
       means there is only one paramMap which is shared between all instances of all classes that
       implement the interface. - Jesper May 5 '15 at 20:40
     * yes, i did mean for it to be static, its the only way it can work. i had a feeling a response to
       my question would be a question such as that, i don't want to get into the programming model now,
       but just take it as a valid reason, and read up on java 8 default methods, ask yourself why it
       was added as new architectural feature, and then you might understand my reason for it.
       - Saul May 6 '15 at 13:10
     * The main reason that default methods were added in Java 8 is to make it possible to add methods
       to interfaces without breaking backward compatibility - not as a replacement for abstract
       classes. - Jesper May 6 '15 at 18:41
     * 2
       good. so now you might have an idea why I need to do this. Actually, you should note that while
       you believe that this is the main reason, in actuality, this is a symptom of an model that does
       not work well. I'd like to think of the change as less of a hack for backwards compatibility that
       you imply but more of an architectural change to allow for a richer programing model, which
       in-turn addresses the issue that Java was unable to deal with before. Either way, I'm really
       looking for ideas to have this specific setup working, not for socratic debates about its usage.
       - Saul May 6 '15 at 20:54
     * In my case there is no place for abstract class until Java supports multiple-inheritance
       subclassing. I have classes such as XxxSupport, and want to mix-in their getters and setters into
       existing classes. - Askar Kalykov Jul 10 '15 at 6:55

***
   In my own projects, I get the implementor to supply me with the dependency supplied by spring's DI
   container.

   Reworking the code above, this would look like this:
public interface MyProcessor {

    // get the implementor to get the hash map
    WeakHashMap<Function1D, Integer> getParamMap();
    
    default double doSomthingWithParam(double x) {
        return doSomething() * getParam();
    }
    
    // uses the implementor's getParamMap() to get params
    default int getParam() {
        return getParamMap().get(this);
    }
    
    double doSomething();
}

public class MyProcessorImp extends SomeClass implements MyProcessor {

    final WeakHashMap<Function1D, Integer> paramMap = new WeakHashMap<>();
    
    void setParam(int param) {
        paramMap.put(this, param);
    }
    
    @Override WeakHashMap<Function1D, Integer> getParamMap() {
        return paramMap;
    }
    
    @Override double doSomething() {
        // elided
    }
}


---
https://softwareengineering.stackexchange.com/questions/163175/difference-between-spring-setter-and-interface-injection


Difference between spring setter and interface injection?

   I know how constructor and setter injection works in spring.

   Normally I use interfaces instead of classes to inject beans using setter and I consider it as
   interface injection, but in case of constructor we also use interfaces (I am confused). In following
   example I use JobProcessor interface instead of JobProcessorImpl class.
public class JobScheduler {
    // JobProcessor interface
    private JobProcessor jobProcessor;
    
    // Dependecy injection
    public void setJobProcessor(JobProcessor jobProcessor){
        this.jobProcessor = jobProcessor;
    }
}

   I tried to find a solution by googling but there are different opinions by writers. Even some people
   says that spring doesn't support interface injection in their blogs/statements.

   Can someone help me by example?

***
   In interface injection, the setter method is provided by an interface that is implemented by the bean
   in which we are going to inject the dependency.

   Example:
package some.package;
public class Car implements EngineMountable {
    private Engine engine;
    
    @Override //dependency injection
    public void mount(Engine engine){
        this.engine = engine;
    }
}

public interface EngineMountable {
    void mount(Engine engine);
}

   The same is working for me in spring by applying the following configuration:
<bean name="car" class="some.package.Car">
    <property name="mount" ref="engineObject" />
</bean>

   In some sites people says that spring does not supports interface injection, but for me the above
   example works in spring. As per me : spring supports interface injection.

***
     * 2
       I don't see the difference between this and "setter injection", other than that the "setter"
       method is specified in an interface here. Fundamentally, the two are basically identical. Am I
       wrong? Could you clarify the answer by contrasting this with "setter injection"? - Jez Apr 3
       '14 at 9:38
     * @Satish Could you give me complete Example for this? - sunleo Sep 22 '14 at 17:35
     * 5
       I disagree with this answer. According to Fowler's definition, a container using Interface
       Injection uses the declared interfaces of a class to identify what needs to be injected into it,
       thus avoiding a need to configure each concrete class, and rather just configuring the interface
       (which could be implemented by many classes). In your example, you provide configuration for the
       concrete class, and if you added another implementation of EngineMountable would need to add
       extra configuration for that, too. - Jules Jan 20 '15 at 10:00
     * Spring does not support interface injection as per their docs springbyexample.org/examples/...
       - jawath Mar 3 at 11:02


---
