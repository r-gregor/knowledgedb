filename: jv_configuration-files-multif_20180705.txt
https://crunchify.com/java-properties-file-how-to-read-config-properties-values-in-java/

Java Properties File: How to Read config.properties Values in Java?

.properties is a file extension for files mainly used in Java related technologies to store the configurable
parameters of an application. They can also be used for storing strings for Internationalization and
localization; these are known as Property Resource Bundles.

Each parameter is stored as a pair of strings, one storing the name of the parameter (called the key/map), and
the other storing the value.

Below is a sample Java program which demonstrate you how to retrieve/read config.properties values in Java.
For update follow this tutorial.

Another must read: Read config.properties value using Spring “singleton” Scope in your Java Enterprise
Application

We will create 3 files:
CrunchifyReadConfigMain.java
CrunchifyGetPropertyValues.java
config.properties file

Main Class (CrunchifyReadConfigMain.java) which will call getPropValues() method from
class CrunchifyGetPropertyValues.java.

Let’s get started:

Step-1: Create config.properties file.
Create Folder “resources” under Java Resources folder if your project doesn’t have it.
create config.properties file with below value.
How to read config.properties in Java - Crunchify Tips

/Java Resources/resources/config.properties file content:
config.properties content

#Crunchify Properties
user=Crunchify
company1=Google
company2=eBay
company3=Yahoo

Step-2
Create file CrunchifyReadConfigMain.java

<code>
CrunchifyReadConfigMain.javaJava
package crunchify.com.tutorial;
 
import java.io.IOException;
 
/**
 * @author Crunchify.com
 * 
 */
 
public class CrunchifyReadConfigMain {
 
    public static void main(String[] args) throws IOException {
        CrunchifyGetPropertyValues properties = new CrunchifyGetPropertyValues();
        properties.getPropValues();
    }
}
</code>

Step-3
Create file CrunchifyGetPropertyValues.java

<code>
CrunchifyGetPropertyValues.javaJava
package crunchify.com.tutorial;
 
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.Date;
import java.util.Properties;
 
/**
 * @author Crunchify.com
 * 
 */
 
public class CrunchifyGetPropertyValues {
    String result = "";
    InputStream inputStream;
 
    public String getPropValues() throws IOException {
 
        try {
            Properties prop = new Properties();
            String propFileName = "config.properties";
 
            inputStream = getClass().getClassLoader().getResourceAsStream(propFileName);
 
            if (inputStream != null) {
                prop.load(inputStream);
            } else {
                throw new FileNotFoundException("property file '" + propFileName + "' not found in the classpath");
            }
 
            Date time = new Date(System.currentTimeMillis());
 
            // get the property value and print it out
            String user = prop.getProperty("user");
            String company1 = prop.getProperty("company1");
            String company2 = prop.getProperty("company2");
            String company3 = prop.getProperty("company3");
 
            result = "Company List = " + company1 + ", " + company2 + ", " + company3;
            System.out.println(result + "\nProgram Ran on " + time + " by user=" + user);
        } catch (Exception e) {
            System.out.println("Exception: " + e);
        } finally {
            inputStream.close();
        }
        return result;
    }
}
</code>

Step-4
Run CrunchifyReadConfigMain and checkout result.

Output
Company List = Google, eBay, Yahoo
Program Ran on Mon May 13 21:54:55 PDT 2013 by user=Crunchify


---
https://www.mkyong.com/java/java-properties-file-examples/

Java Properties file examples

   Normally, Java properties file is used to store project configuration data or settings. In this
   tutorial, we will show you how to read and write to/from a properties file.

1. Write to properties file
   Set the property value, and write it into a properties file named config.properties.
   App.java

<code>   
package com.mkyong.properties;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Properties;

public class App {
  public static void main(String[] args) {

        Properties prop = new Properties();
        OutputStream output = null;

        try {

                output = new FileOutputStream("config.properties");

                // set the properties value
                prop.setProperty("database", "localhost");
                prop.setProperty("dbuser", "mkyong");
                prop.setProperty("dbpassword", "password");

                // save properties to project root folder
                prop.store(output, null);

        } catch (IOException io) {
                io.printStackTrace();
        } finally {
                if (output != null) {
                        try {
                                output.close();
                        } catch (IOException e) {
                                e.printStackTrace();
                        }
                }

        }
  }
}
</code>

   Output
   config.properties
#Fri Jan 17 22:37:45 MYT 2014
dbpassword=password
database=localhost
dbuser=mkyong

   P.S If file path is not specified, then this properties file will be stored in your project root
   folder.

2. Load a properties file
   Load a properties file from the file system and retrieved the property value.
   App.java

<code>   
package com.mkyong.properties;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

public class App {
  public static void main(String[] args) {

        Properties prop = new Properties();
        InputStream input = null;

        try {

                input = new FileInputStream("config.properties");

                // load a properties file
                prop.load(input);

                // get the property value and print it out
                System.out.println(prop.getProperty("database"));
                System.out.println(prop.getProperty("dbuser"));
                System.out.println(prop.getProperty("dbpassword"));

        } catch (IOException ex) {
                ex.printStackTrace();
        } finally {
                if (input != null) {
                        try {
                                input.close();
                        } catch (IOException e) {
                                e.printStackTrace();
                        }
                }
        }

  }
}
</code>

   Output
localhost
mkyong
password

3. Load a properties file from classpath
   Load a properties file config.properties from project classpath, and retrieved the property value.

   P.S Assume properties file “config.properties” is in your project classpath root folder.
   App.java
   
<code>   
package com.mkyong.properties;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

public class App {

  public static void main( String[] args ){

        Properties prop = new Properties();
        InputStream input = null;

        try {

                String filename = "config.properties";
                input = App3.class.getClassLoader().getResourceAsStream(filename);
                if(input==null){
                    System.out.println("Sorry, unable to find " + filename);
                    return;
                }

                //load a properties file from class path, inside static method
                prop.load(input);

                //get the property value and print it out
                System.out.println(prop.getProperty("database"));
                System.out.println(prop.getProperty("dbuser"));
                System.out.println(prop.getProperty("dbpassword"));

        } catch (IOException ex) {
                ex.printStackTrace();
        } finally{
                if(input!=null){
                        try {
                                input.close();
                        } catch (IOException e) {
                                e.printStackTrace();
                        }
                }
        }

    }
}
</code>

   Output
localhost
mkyong
password

   For non-static method, use this :
prop.load(getClass().getClassLoader().getResourceAsStream("config.properties"));

4. Prints everything from a properties file
   Load a properties file config.properties from project classpath, and get the keys and values.
   App.java
   
<code>   
package com.mkyong.properties;

import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Properties;

public class App {

  public static void main(String[] args) {
        App app = new App();
        app.printThemAll();
  }

  private void printThemAll() {

        Properties prop = new Properties();
        InputStream input = null;

        try {

                String filename = "config.properties";
                input = getClass().getClassLoader().getResourceAsStream(filename);
                if (input == null) {
                        System.out.println("Sorry, unable to find " + filename);
                        return;
                }

                prop.load(input);

                Enumeration<?> e = prop.propertyNames();
                while (e.hasMoreElements()) {
                        String key = (String) e.nextElement();
                        String value = prop.getProperty(key);
                        System.out.println("Key : " + key + ", Value : " + value);
                }

        } catch (IOException ex) {
                ex.printStackTrace();
        } finally {
                if (input != null) {
                        try {
                                input.close();
                        } catch (IOException e) {
                                e.printStackTrace();
                        }
                }
        }

  }

}
</code>

   Output
Key : dbpassword, Value : password
Key : database, Value : localhost
Key : dbuser, Value : mkyong


---
http://www.labbookpages.co.uk/software/java/javaConfig.html

Java Configuration File API

   This is a simple Java Configuration file API. It provides methods for reading key-value pairs from a
   file. The main benefit over using Java's standard Properties class is support for nested array
   configuration values. This implementation is inspired by, but somewhat more basic than [36]libconfig,
   a very useful C/C++ Configuration File Library.
     * Configuration File Format and Retrieving Values
     * System Properties
     * Config API
     ________________________________________________________________________________________________

Configuration File Format and Retrieving Values
   The configuration file is formatted in key-value pairs. The key is separated from the value using an
   equals sign and the value is terminated using a semicolon. Comments can be included using a hash
   character. Below is an example.
key = value; # A Comment

   The code below shows how a new Config object is instantiated. It will load the configuration
   information from the file data.cfg.
try {
   Config config = new Config("data.cfg");
}
catch (ConfigException e) {
   System.err.println(e);
}

Primitive Type Values
   Although configuration values are stored as strings a set of utility functions are available in the
   Config class for converting values to primitive types. Below is an example configuration.
num1 = 5;
num2 = 12.6;

   These values can be retrieved using the following methods.
int num1 = config.getInt("num1");
float num2 = config.getFloat("num2");

   There are similar methods for types long and double, these are getLong and getDouble respectively.

Boolean Type Values
   Boolean configuration values are also supported. The supported value strings for true are 'true'
   (case insensitive) and '1'. The supported value strings for false are 'false' (case insensitive) and
   '0'. Below are some examples. The getBoolean method is used to retrieve a boolean value.
# These are all true
bool1 = true;
bool2 = True;
bool3 = 1;

# These are all false
bool1 = false;
bool2 = FALSE;
bool3 = 0;

Strings Values
   Although configuration values are already stored as strings, the getString method allows more complex
   string formatting to be used within the configuration file. Strings are enclosed in double quotes.
   Strings can be split into sections which may spread over multiple lines. Special characters can be
   included using escape codes, these are \n, \r and \t. A double quote can be included using a \" and a
   slash using \\. Below is an example.
test = "This is a string split over "
       "multiple lines\nThis is the real second line, this is \"quoted\"";

   This configuration value can be retrieved and output using the following code.
String test = config.getString("test");
System.out.println(test);

   The output looks like this. The two string sections are combined and the escaped new-line and
   double-quote characters are inserted as an actual characters.
This is a string split over multiple lines
This is the real second line, this is "quoted"

Providing Default Values
   When retrieving a configuration value, it is possible to specify a default value in case the
   key-value pair has not been specified in the configuration file. For example, given the method below,
   if the configuration file contains the key foo then that value will be returned, otherwise the
   specified default value, 24 will be returned.
int num = config.getInt("foo", 24);

Arrays
   The configuration file format supports nested array values. The elements of the array can be of mixed
   type. Arrays are enclosed in brackets and their elements are separated with commas. Below is a simple
   configuration example.
foo = ("Sam", 33),
      ("Bob", 23),
      ("Will", 45);

   The code below parses the whole array. The first step is to use the getElement method to retrieve the
   full, unaltered configuration value. Arrays are broken apart using the splitArray method. Nested
   arrays are split one level at a time. Having split the top level into a string array, each entry is
   subsequently split and the resulting parts are parsed into their expected types.

   As array elements are not retrieved using a key, once retrieved using splitArray they are converted
   to their expected type using the parse... methods rather that the get... methods.
// Get the full configuration value for key 'foo'
String array = config.getElement("foo");

// Split the top level array
String[] entries = config.splitArray(array);

// Iterate through each sub-array string
for (String entry : entries)
{
   // Split the sub array into the two parts
   String[] parts = config.splitArray(entry);

   // Parse the parts into their proper types
   String name = config.parseString(parts[0]);
   int age = config.parseInt(parts[1]);

   // Output the values
   System.out.printf("%s is %d years old\n", name, age);
}

   The output is shown below.
Sam is 33 years old
Bob is 23 years old
Will is 45 years old

   Below is a more complex array value. The displayTree method can be used to output an array in a tree
   layout to stdout.
bar = (a, ("str" "ing", b), ((c,d), d));

(a, ("str" "ing", b), ((c,d), d))  Depth:1, Index:0, Parents:0, Length:3
 ├─ a ............................ Depth:2, Index:0, Parents:3, Length:1
 │
 ├─ "str" "ing", b ............... Depth:2, Index:1, Parents:3, Length:2
 │   ├─ "str" "ing" .............. Depth:3, Index:0, Parents:2, Length:1
 │   └─ b ........................ Depth:3, Index:1, Parents:2, Length:1
 │
 └─ (c,d), d ..................... Depth:2, Index:2, Parents:3, Length:2
     │
     ├─ c,d ...................... Depth:3, Index:0, Parents:2, Length:2
     │   ├─ c .................... Depth:4, Index:0, Parents:2, Length:1
     │   └─ d .................... Depth:4, Index:1, Parents:2, Length:1
     │
     └─ d ........................ Depth:3, Index:1, Parents:2, Length:1
     ________________________________________________________________________________________________

System Properties
   It is possible to override configuration values using system properties. This is makes it possible to
   override a value in a configuration file from the java invocation. Below is an example configuration
   file and a simple class that reads it.
   File: data.cfg
foo = 14.703;

   File: Test.java
public class Test
{
   public static void main(String[] args)
   {
      try
      {
         Config config = new Config("data.cfg", true, true);
         System.out.println(config.getDouble("foo"));
      }
      catch (ConfigException e)
      {
         System.err.println(e);
      }
   }
}

   Below is shown the configuration value with key 'foo' when a system property of the same name is
   unset and set when Java is started.
> java Test
14.703
> java -Dfoo=9.456 Test
Override: foo = 9.456
9.456
     ________________________________________________________________________________________________

Config API

Config Constructors
   Config(String filename) throws ConfigException

   Constructs a new Config object based on the configuration file with the specified filename.
   Config(String filename, boolean useSysProperties, boolean showOverrides) throws ConfigException

   Constructs a new Config object based on the configuration file with the specified filename. The
   useSysProperties argument can be used to enable overriding configuration file values with system
   property values. If the showOverrides argument is true, when a system property overrides a
   configuration file value, a message is printed to stdout.

String Retrieval Methods
   String getElement(String key)

   Returns the configuration value specified by the key string argument. This method should be used when
   retrieving array values. If the configuration value is a string, then getString should be used so the
   value is properly parsed. If the key is not found, null is returned.
   String parseString(String val) throws ConfigException

   Parses a configuration value of type string. This method combines separate double-quoted string
   sections and converts escaped characters into their proper encoded value. This method should be used
   when retrieving strings from within an array.
   String getString(String key, String def) throws ConfigException

   This method returns the configuration value linked to the specified key. If the key is not found, the
   default value specified by def is returned.
   String getString(String key) throws ConfigException

   This method returns the configuration value linked to the specified key. If the key is not found, a
   ConfigException is thrown.

Boolean Retrieval Methods
   static boolean parseBoolean(String val) throws ConfigException

   Parses a configuration value of type boolean. This method should be used when retrieving strings from
   within an array.
   boolean getBoolean(String key, boolean def) throws ConfigException

   Returns the configuration value linked to the specified key. The value is converted to a boolean
   type. If the conversion fails a ConfigException is thrown. If the key is not found, the default value
   specified by def is returned.
   boolean getBoolean(String key) throws ConfigException

   Returns the configuration value linked to the specified key. The value is converted to a boolean
   type. If the conversion fails a ConfigException is thrown. If the key is not found, null is returned.

Long Retrieval Methods
   static long parseLong(String val) throws ConfigException

   Same as boolean version, but for long type.
   long getLong(String key, int def) throws ConfigException

   Same as boolean version, but for long type.
   long getLong(String key) throws ConfigException

   Same as boolean version, but for long type.

Integer Retrieval Methods
   static int parseInt(String val) throws ConfigException

   Same as boolean version, but for int type.
   int getInt(String key, int def) throws ConfigException

   Same as boolean version, but for int type.
   int getInt(String key) throws ConfigException

   Same as boolean version, but for int type.

Float Retrieval Methods
   static float parseFloat(String val) throws ConfigException

   Same as boolean version, but for float type.
   float getFloat(String key, float def) throws ConfigException

   Same as boolean version, but for float type.
   float getFloat(String key) throws ConfigException

   Same as boolean version, but for float type.

Double Retrieval Methods
   static double parseDouble(String val) throws ConfigException

   Same as boolean version, but for double type.
   double getDouble(String key, double def) throws ConfigException

   Same as boolean version, but for double type.
   double getDouble(String key) throws ConfigException

   Same as boolean version, but for double type.

Array Retrieval Methods
   static String[] splitArray(String str) throws ConfigException

   This is the main method for working width arrays, it should be used in conjunction with the
   getElement method. Given a configuration value it will split it into sub strings leaving nested
   arrays intact. Each level of array needs to be split individually using this method.

Configuration Display Methods
   void display(PrintStream out)

   A helper method that outputs all the loaded configuration data.
   static void displayTree(String str, boolean details) throws ConfigException

   A helper method that outputs an array configuration value in a tree format. Set the details argument
   for extra info.


---
http://microfork.com/reading-configuration-files-in-java-nproperty/

Reading configuration files in Java. nProperty.

   Many developers using configuration files (*.ini, *.prop, *.conf, etc.) in their applications. Java
   has standard class [25]Properties, that provides ability to load and parse any configuration file.
   When amount of configuration files is large, reading and writing configuration files becomes very
   tiresome and routine work: create Properties object, convert each configuration to necessary format
   and write object field.

   nProperty (Annotated Property) library is designed to simplify this process, halving configuration
   loader code.

   Table of Contents
     * 1 Reading primitive and standard types
     * 2 Deserialization into arrays and collections
     * 3 Deserialization into user types
     * 4 Access level modifiers
     * 5 All members initialization
     * 6 Default values
     * 7 Names overriding
     * 8 Working with non-static members
     * 9 Using of class methods
     * 10 Events handling
     * 11 Using streams and file descriptors
     * 12 Additional Features
          + 12.1 Using prefixes
          + 12.2 Parametrization
          + 12.3 Configuration file generation
     * 13 XML support
     * 14 Notes
     * 15 License
     * 16 Links

   Below are two examples to show how loaders code becomes lesser with using of nProperty. First example
   using standard Properties loader, second uses nProperty.

   Both examples uses same configuration file:
   Apache
   
   SOME_INT_VALUE = 2
   SOME_DOUBLE_VALUE = 1.2
   SOME_STRING_VALUE = foo
   SOME_INT_ARRAY = 1;2;3

   Example #1:

   package samples;
   import java.io.File;
   import java.io.FileInputStream;
   import java.io.IOException;
   import java.util.Properties;
   public class Example1
   {
       private static int SOME_INT_VALUE = 1;
       private static String SOME_STRING_VALUE;
       private static int[] SOME_INT_ARRAY;
       private static double SOME_DOUBLE_VALUE;
       public Example1() throws IOException
       {
           Properties props = new Properties();
           props.load(new FileInputStream(new File("config/example.ini")));
           SOME_INT_VALUE = Integer.valueOf(props.getProperty("SOME_INT_VALUE", "1"));
           SOME_STRING_VALUE = props.getProperty("SOME_STRING_VALUE");
           SOME_DOUBLE_VALUE = Double.valueOf(props.getProperty("SOME_DOUBLE_VALUE", "1.0"));
           // Let's assume property contains list of values concatenated within ";"
           String[] parts = props.getProperty("SOME_INT_ARRAY").split(";");
           SOME_INT_ARRAY = new int[parts.length];
           for (int i = 0; i < parts.length; ++i)
           {
               SOME_INT_ARRAY[i] = Integer.valueOf(parts[i]);
           }
       }
       public static void main(String[] args) throws IOException
       {
           new Example1();
       }
   }

   Example #2:

   package samples;
   import jfork.nproperty.Cfg;
   import jfork.nproperty.ConfigParser;
   import java.io.IOException;
   import java.lang.reflect.InvocationTargetException;
   @Cfg
   public class Example2
   {
       private static int SOME_INT_VALUE = 1;
       private static String SOME_STRING_VALUE;
       private static int[] SOME_INT_ARRAY;
       private static double SOME_DOUBLE_VALUE;
       public Example2() throws NoSuchMethodException, InstantiationException, IllegalAccessException,
   IOException, InvocationTargetException
       {
           ConfigParser.parse(Example2.class, "config/example.ini");
       }
       public static void main(String[] args) throws InvocationTargetException, NoSuchMethodException,
   InstantiationException, IOException, IllegalAccessException
       {
           new Example2();
       }
   }

   Perhaps, these nice examples shows that code can be reduced more than twice in ideal circumstances :)
   These examples does not take a look around non-property fields and few another nuances. But let's go
   through it point by point.

Reading primitive and standard types
   In second example above you can seen @Cfg annotation. This is the reason of code reducing. nProperty
   library based on annotations, which can be applied to classes, fields and methods.

   To read properties that are primitive types it is enough to mark each class field by @Cfg annotation:

   package samples;
   import jfork.nproperty.Cfg;
   public class Example3
   {
       @Cfg
       private static int SOME_INT_VALUE;
       @Cfg
       private static short SOME_SHORT_VALUE;
       @Cfg
       private static long SOME_LONG_VALUE;
       @Cfg
       private static Double SOME_DOUBLE_VALUE;
       /* ... */
   }

   nProperty supports rich set of primitive and standard types:
     * Integer/int;
     * Short/short;
     * Double/double;
     * Long/long;
     * Boolean/boolean;
     * String;
     * Character/char;
     * Byte/byte;
     * AtomicInteger, AtomicLong, AtomicBoolean;
     * BigInteger, BigDecimal.

   All this types can be used in example above.

Deserialization into arrays and collections
   Beside standard types reading into arrays is possible. There is one important condition - array type
   should be one of standard types:

   package samples;
   import jfork.nproperty.Cfg;
   import java.math.BigInteger;
   /*
       Assume configuration file contains:
           SOME_INT_ARRAY = 1--2--3
           SOME_SHORT_ARRAY = 3>2<1
           SOME_BIGINTEGER_ARRAY = 1;2;3
   */
   public class Example5
   {
       @Cfg(splitter = "--")
       private static int[] SOME_INT_ARRAY;
       @Cfg(splitter = "[><]")
       private static short[] SOME_SHORT_ARRAY;
       @Cfg
       private static BigInteger[] SOME_BIGINTEGER_ARRAY;
   }

   In this case library will take a sense about array initialization.

   Take a look on SOME_INT_ARRAY and SOME_SHORT_ARRAY field annotations. By default nProperty uses ";"
   symbol as string separator. But it can be easily re-defined by setting splitter annotation property.
   And separator can be fully-qualified regular expression.

   Beside arrays deserialization into collection also possible, namely - into lists. There is one
   important condition - collection should be initiated before parsing started. This is because
   different implementations of collections may be used (ArrayList, LinkedList, etc.):

   package samples;
   import jfork.nproperty.Cfg;
   import java.math.BigInteger;
   import java.util.ArrayList;
   import java.util.LinkedList;
   import java.util.List;
   public class Example6
   {
       @Cfg
       private static List<Integer> SOME_ARRAYLIST_COLLECTION = new ArrayList<>();
       @Cfg
       private static List<Integer> SOME_LINKEDLIST_COLLECTION = new LinkedList<>();
   }

   Otherwise collections follows all rules of arrays.

Deserialization into user types
   As additional function, library can work with custom user classes. Existing constructor
   MyClass(String) is primarily required. In other cases exception will be thrown. Constructor
   visibility level does not matters, he can be public, protected, or private:

   package samples;
   import jfork.nproperty.Cfg;
   import java.util.ArrayList;
   import java.util.LinkedList;
   import java.util.List;
   import java.util.logging.Logger;
   public class Example8
   {
       private static class T
       {
           private final String value;
           private T(String value)
           {
               this.value = value;
           }
           public String getValue() { return value; }
       }
       @Cfg
       private static T CUSTOM_CLASS_VALUE;
   }

   As you see visibility level of constructor in example above is private. Configuration file property
   value will be written to field "value" of class T as result of this example.

   It is obvious that standard Java class can be used as user-type classes. For example, it is possible
   to initialize java.io.File objects by loading file paths from configuration file:

   package samples;
   import jfork.nproperty.Cfg;
   public class Example8
   {
       @Cfg
       private static File MY_FILE_PATH;
   }

   So, in this example MY_FILE_PATH variable will refer to object initialized with File(String) ctor.

Access level modifiers
   For nProperty library it is not matters what are access level modifiers of field, method or
   constructor - library works with Reflections mechanism and manages visibility by its own. Of course,
   this injection will not affect another application parts, with which library does not work.

All members initialization
   In past examples each field was annotated with @Cfg annotation. So, that necesity can produce very
   much @Cfg annotations in file. To avoid routine work nProperty allows annotate whole class instead of
   each field. When annotating class with @Cfg annotation, all fields of class becomes potential
   property fields:

   package samples;
   import jfork.nproperty.Cfg;
   import java.util.ArrayList;
   import java.util.LinkedList;
   import java.util.List;
   import java.util.logging.Logger;
   @Cfg
   public class Example7
   {
       /* All fields will be used by nProperty */
       private static int SOME_INT_VALUE = 1;
       private static String SOME_STRING_VALUE;
       private static int[] SOME_INT_ARRAY;
       private static double SOME_DOUBLE_VALUE;
       private static List<Integer> SOME_ARRAYLIST_COLLECTION = new ArrayList<>();
       private static List<Integer> SOME_LINKEDLIST_COLLECTION = new LinkedList<>();
       @Cfg(ignore = true)
       private final static Logger log = Logger.getAnonymousLogger();
   }

   Take a look at log field from example above. This field annotated by @Cfg annotation with ignore
   property enabled. This property means that annotated field will not be used by library during
   configuration reading, and just will be skipped. This property should be used only when annotating
   whole class, as in example above.

Default values
   The grace feature of the library is that if property was not met in configuration file, field value
   will be never changed by nProperty. This allows to use default values right in field declaration:

   package samples;
   import jfork.nproperty.Cfg;
   /* Configuration file does not contain WRONG_PROPERTY key */
   @Cfg
   public class Example9
   {
       private int WRONG_PROPERTY = 9000;
       private int SOME_INT_VALUE;
   }

   In this case WRONG_PROPERTY will contain 9000 value even after parsing configuration file.

Names overriding
   In cases when field name does not equals configuration property name, its name can be overrided:

   package samples;
   import jfork.nproperty.Cfg;
   public class Example10
   {
       @Cfg("SOME_INT_VALUE")
       private int myIntValue;
   }

   Of course, if it is possible to save equivalence between field names and property names, then it is
   better choice - this allows avoid annotating each field.

Working with non-static members
   Library can work with classes and with class instances. This can be defined by different calls of
   ConfigParser.parse() method:

   package samples;
   import jfork.nproperty.Cfg;
   import jfork.nproperty.ConfigParser;
   import java.io.IOException;
   import java.lang.reflect.InvocationTargetException;
   @Cfg
   public class Example11
   {
       private static int SOME_SHORT_VALUE;
       private int SOME_INT_VALUE;
       public static void main(String[] args) throws NoSuchMethodException, InstantiationException,
   IllegalAccessException, IOException, InvocationTargetException
       {
           ConfigParser.parse(Example11.class, "config/example.ini"); // Here SOME_INT_VALUE variable
   will not be used
           ConfigParser.parse(new Example11(), "config/example.ini");
       }
   }

   As you can see in example above, two different calls of same method was used. After
   ConfigParser.parse(Example11.class, "config/example.ini") line SOME_INT_VALUE will be zero, and this
   fact does not depends on configuration file - this field is not static and cannot be used without
   class instance.

   After second call ConfigParser.parse(new Example11(), "config/example.ini") SOME_INT_VALUE will be
   filled with value from configuration file.

   This feature should be used with accuracy. You can loose configuration value when using non-static
   field in static context.

Using of class methods
   Let assume that during reading some property from file, its value should be checked or, for example,
   deserialized in unusual way. That task can be done by three ways:
    1. check value after library will analyze file;
    2. create custom user type as value wrapper with constructor (as was shown above);
    3. exclude class field and redirect property to method.

   Most easy and correct way is #3. nProperty library allows to work not only with field, but with
   methods:

   package samples;
   import jfork.nproperty.Cfg;
   import java.util.ArrayList;
   import java.util.List;
   public class Example12
   {
       private static List<Integer> VALUE_CHECK = new ArrayList<>();
       @Cfg("SOME_INT_ARRAY")
       private void checkIntArray(String value)
       {
           String[] values = value.split("--");
           for (String val : values)
           {
               try
               {
                   /* let's limit value by [0,100] */
                   VALUE_CHECK.add(Math.max(0, Math.min(100, Integer.parseInt(val))));
               }
               catch (Exception ignored) {}
           }
       }
   }

   Here's checkIntArray(String) method and property value SOME_INT_ARRAY from configuration file will be
   passed to its first parameter. It is very convenient way when standard library solutions are out. You
   may put any code you want in handler method.

   However, it is important, that library does not uses splitter mechanism when working with methods,
   i.e. at now it is impossible to organize automatic array deserialization within methods.

   But type conversions still supported if first method parameter is differs from String.

   As with class fields, if methods name is equals to property name in configuration file, setting up
   property name is unnecessary.

Events handling
   nProperty library allows to handle some useful events during reading configuration files. To use
   event handling class should implement IPropertyListener interface and all its abstract methods. Event
   handling is possible only when library works with class instances (real objects, not static classes).
   Supported events:
     * onStart(String path) - called before loading configuration file;
     * onPropertyMiss(String name) - called when some property was not found in configuration file, but
       was marked in annotated class with @Cfg;
     * onDone(String path) - called when configuration parsing ends;
     * onInvalidPropertyCast(String name, String value) - called in circumstances of property type
       casing failure, when property was successfully read from file, but was unable to cast to type
       specified in associated field.

   package samples;
   import jfork.nproperty.Cfg;
   import jfork.nproperty.ConfigParser;
   import jfork.nproperty.IPropertyListener;
   import java.io.IOException;
   import java.lang.reflect.InvocationTargetException;
   
   @Cfg
   public class Example13 implements IPropertyListener {
               public int SOME_INT_VALUE;
               public int SOME_MISSED_VALUE;
               public int SOME_INT_ARRAY;
               @Override
           public void onStart(String path) {
           }
           
           @Override
           public void onPropertyMiss(String name) {
           }
           
           @Override
           public void onDone(String path) {
           }
           
           @Override
           public void onInvalidPropertyCast(String name, String value) {
           }
           
           public static void main(String[] args) throws NoSuchMethodException, InstantiationException,
       IllegalAccessException, IOException, InvocationTargetException {
               ConfigParser.parse(new Example13(), "config/example.ini");
           }
    }

   In example above all four events will be called. Event onPropertyMiss will be called for
   SOME_MISSED_VALUE property, which is not in configuration file. Event onInvlidPropertyCast will be
   called for SOME_INT_ARRAY field which type is int.

Using streams and file descriptors
   Library can receive not only file names as pointers to configuration resources. Also java.io.File and
   streams (inherited from java.io.InputStream) passing is allowed:

   package samples;
   import jfork.nproperty.Cfg;
   import jfork.nproperty.ConfigParser;
   import jfork.nproperty.IPropertyListener;
   import java.io.File;
   import java.io.FileInputStream;
   import java.io.IOException;
   import java.lang.reflect.InvocationTargetException;
   @Cfg
   public class Example14 {
       public int SOME_INT_VALUE;
       public int SOME_MISSED_VALUE;
       public int SOME_INT_ARRAY;
       public static void main(String[] args) throws NoSuchMethodException, InstantiationException,
   IllegalAccessException, IOException, InvocationTargetException {
           ConfigParser.parse(new Example14(), "config/example.ini");
           ConfigParser.parse(new Example14(), new File("config", "example.ini"));
           ConfigParser.parse(new Example14(), new FileInputStream("config/example.ini"), "config/example.ini");
        }
    }

   As you can see when working with streams the library required additionally to set up configuration
   name, because it is not possible to retrieve resource name from low-level FileInputStream object.
   Configuration name is not important part of call - it is used only for displaying information
   (including events).

   So, data can be retrieved not only from file system, but from any data source that is working with
   Java standards. Ability to work with streams allows to use library on Android:
   Java

   @Cfg
   public class ConfigGeneral extends PropertyListenerImpl {
        public static String SERVER_IP;
        public static int SERVER_PORT;
        private ConfigGeneral() {
            String path = "config/network/general.ini";
            try {
                InputStream input = getApplicationContext().getResources().getAssets().open(path);
                ConfigParser.parse(this, input, path);
            }
           catch(Exception e) {
               Log.e(TAG, "Failed to Load " + path + " File.", e);
            }
        }
       public static void loadConfig() {
           new ConfigGeneral();
        }
    }

Additional Features

Using prefixes
   Sometimes in configuration files prefixes are used as logical separators of configuration options.
   For example, like this:
   Apache

   # Prefixes example
   db.driver = mysql
   db.user = user
   db.pswd = pswd
   db.host = 127.0.0.1
   db.port = 90

   nProperty provides ability to set up prefix value for each class or object field to avoid setting up
   prefixes per each property field:

   @Cfg(prefix = "db.")
   public class Example16 {
       private static String user;
       private static String pswd;
       private static String host;
       private static int port;
       public static void main(String[] args) throws NoSuchMethodException, InstantiationException,
   IllegalAccessException, IOException, InvocationTargetException {
           ConfigParser.parse(Example16.class, "config/example.ini");
        }
    }

   Prefix parameter of @Cfg class annotation defines prefix for each field: user, pswd, host, port. To
   override prefix value, prefix parameter should be set for specified field.

Parametrization
   In some circumstances configuration property parametrization is needed. For example, file system root
   path can be stored in separated property and then used in other properties to specify file full path.

   Parameter is any notation: ${some_name}, where some_name - configuration file property name which
   value should be placed instead of parameter.

   Notation ${} is not a parameter, however, it is special sequence of symbols which will be replaced
   with "$" sign.

   Let's see at example of setting up SQL Link based on parameters we have:
   Apache

   # Prefixes example
   db.driver = mysql
   db.user = user
   db.pswd = pswd
   db.host = 127.0.0.1
   db.port = 90
   # Parameters example
   db.sqlink = ${db.driver}://${db.user}@${db.host}:${db.port}
   db.pswd2 = abc${}def
   db.magic1 = 9
   db.magic2 = 42
   db.magics = ${db.magic1},${db.magic2},39

   And corresponding loader class:

   @Cfg(prefix = "db.")
   public class Example17 {
       private static String user;
       private static String pswd;
       private static String host;
       private static int port;
       @Cfg(parametrize = true)
       private static String sqlink;
       @Cfg(parametrize = true)
       private static String pswd2;
       @Cfg(parametrize = true, splitter = ",")
       private static int[] magics;
       public static void main(String[] args) throws NoSuchMethodException, InstantiationException, {
           ConfigParser.parse(Example17.class, "config/example.ini");
        }
    }

   There was "parameterize" parameter enabled for sqlink class field. Field db.sqlink will be:
   "mysql://user@127.0.0.1:90" and it will be written to class field sqlink.

   It is important to note that before v1.3.1 replacing values are taken directly from configuration
   file. So, next notation:
   Apache

   prop1 = foo
   prop2 = ${prop1}bar
   prop3 = ${prop2}

   will produce "${prop1}bar" value in property prop3. It means that nProperty had no support for
   circular parametrization. To get "foobar" value next changes should be applied in this example:
   Apache

   prop1 = foo
   prop2 = ${prop1}bar
   prop3 = ${prop1}bar

   But from version 1.3.1 recursive parametrization support presented. So, from v1.3.1 prop3's propery
   value from previous example will be "foobar".

Configuration file generation
   Ability to create configuration files based on Java-classes was added to nProperty. This ability can
   be used to automatically generate configuration files, changing configuration and store changes.
   Feature of nProperty storage is that nProperty does not sort property fields like
   java.util.Properties.

   To store current class or class instance state to file, ConfigParser.store(...) method should be
   called. This method has few implementations:

   // Class
   ConfigParser.store(MyClass.class, "config/stored.ini");
   // Dynamic object
   ConfigParser.store(myObject, "config/stored.ini");
   // Using java.io.File wrapper
   ConfigParser.store(object, new File("config/stored.ini"));
   // Using IO stream
   ConfigParser.store(object, new FileOutputStream(new File("config/stored.ini")));
   // Using java.io.Writer with ability to change encoding
   Writer writer = new OutputStreamWriter(new FileOutputStream("config/stored.ini"), "cp1251");

   All fields marked with @Cfg annotation will be putted to file. Property values will be same as
   current field values in class or object. Default values are also used.

XML support
   From version 1.4 nProperty supports loading from and storing to XML files. Like the Java standard,
   XML files should meet DTD requirements:
   XHTML

   <?xml version="1.0" encoding="UTF-8"?>
       <!-- DTD for properties -->
       <!ELEMENT properties ( comment?, entry* ) >
       <!ATTLIST properties version CDATA #FIXED "1.0">
       <!ELEMENT comment (#PCDATA) >
       <!ELEMENT entry (#PCDATA) >
       <!ATTLIST entry key CDATA #REQUIRED>

   Same DTD used in java.util.Properties class. Loading and storing properties from XML doesn't differs
   from loading or storing properties in ini-format. Absolutely same API added for working with XML:
   Java

   // Loading from XML
   ConfigParser.parseXml(object, "config/base.xml");
   // Store to XML
   ConfigParser.storeXml(StaticXmlStoreTest.class, writer);

   XML API have just "...Xml(...)" postfix.

   And as benefit, like in ini-files, nProperty saves key ordering when storing to XML files.

Notes
   According to JVM limitations and non stability of algorithm technical implementation, the library
   cannot work with final fields.

   
---
http://www.java2s.com/Code/Java/Development-Class/ReadaconfigurationfileusingjavautilProperties.htm

Read a configuration file using java.util.Properties

app.config file:
app.name=Properties Sample Code
app.version=1.0

<code>
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.Properties;

public class Main {
  public static void main(String[] args) throws Exception {
    Properties prop = new Properties();
    String fileName = "app.config";
    InputStream is = new FileInputStream(fileName);

    prop.load(is);

    System.out.println(prop.getProperty("app.name"));
    System.out.println(prop.getProperty("app.version"));

    System.out.println(prop.getProperty("app.vendor", "Java"));
  }
}
</code>


---
https://www.opencodez.com/java/read-config-file-in-java.htm

How to Read Config File in Java – with actual Class example provided

In my last post I mentioned “Config Class” couple of times. Here you will see actual class and its usage. The
class is very simple. We just need to provide proper path to config file we going to use.
 
The Config

<code>
import java.util.*;
import java.util.Properties;
 
public class Config {
    Properties configFile;
    public Config() {
        configFile = new java.util.Properties();
        try {
            configFile.load(this.getClass().getClassLoader().
            getResourceAsStream("myapp/config.cfg"));
        } catch(Exception eta) {
            eta.printStackTrace();
        }
    }
 
    public String getProperty(String key) {
        String value = this.configFile.getProperty(key);
        return value;
    }
}
</code>

You can get any property/settings from config with method ‘getProperty’

Here is my config file

#This is comment
mDbUser = myuser
mDbHost = myserver
mDbPwds = mypwd
mDbName = mydb

Usage:

cfg = new Config();
dbname   = cfg.getProperty("mDbUser");

Hope you find this useful..


---
