filename: jv_programming-with-lambda-expressions-multif_20200514.txt
https://www.javaworld.com/article/2092260/java-programming-with-lambda-expressions.html

Functional programming in Java
Java programming with lambda expressions

A mathematical example demonstrates the power of lambda expressions in Java
     In the technical keynote address for JavaOne 2013, Mark Reinhold, chief architect for the Java
     Platform Group at Oracle, described lambda expressions as the single largest upgrade to the Java
     programming model ever. While there are many applications for lambda expressions, this article
     focuses on a specific example that occurs frequently in mathematical applications; namely, the
     need to pass a function to an algorithm.

   As a gray-haired geek, I have programmed in numerous languages over the years, and I have programmed
   extensively in Java since version 1.1. When I started working with computers, almost no one had a
   degree in computer science. Computer professionals came mostly from other disciplines such as
   electrical engineering, physics, business, and mathematics. In my own former life I was a
   mathematician, and so it should come as no surprise that my initial view of a computer was that of a
   giant programmable calculator. I've broadened my view of computers considerably over the years, but I
   still welcome the opportunity to work on applications that involve some aspect of mathematics.

   Many applications in mathematics require that a function be passed as a parameter to an algorithm.
   Examples from college algebra and basic calculus include solving an equation or computing the
   integral of a function. For over 15 years Java has been my programming language of choice for most
   applications, but it was the first language that I used on a frequent basis that did not allow me to
   pass a function (technically a pointer or reference to a function) as a parameter in a simple,
   straightforward manner. That shortcoming is about to change with the upcoming release of Java 8.

   The power of lambda expressions extends well beyond a single use case, but studying various
   implementations of the same example should leave you with a solid sense of how lambdas will benefit
   your Java programs. In this article I will use a common example to help describe the problem, then
   provide solutions written in C++, Java before lambda expressions, and Java with lambda expressions.
   Note that a strong background in mathematics is not required to understand and appreciate the major
   points of this article.

Learning about lambdas
   Lambda expressions, also known as closures, function literals, or simply lambdas, describe a set of
   features defined in Java Specification Request (JSR) 335. Less formal/more readable introductions
   to lambda expressions are provided in a section of the latest version of the
   [**1][http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html]Java Tutorial and in
   a couple of articles by Brian Goetz, "State of the lambda" and "State of the lambda:
   Libraries edition." These resources describe the syntax of lambda expressions and provide examples of
   use cases where lambda expressions are applicable. For more about lambda expressions in Java 8, watch
   Mark Reinhold's technical keynote address for JavaOne 2013.

Lambda expressions in a mathematical example
   The example used throughout this article is Simpson's Rule from basic calculus. Simpson's Rule,
   or more specifically Composite Simpson's Rule, is a numerical integration technique to approximate a
   definite integral. Don't worry if you are unfamiliar with the concept of a definite integral; what
   you really need to understand is that Simpson's Rule is an algorithm that computes a real number
   based on four parameters:
     * A function that we want to integrate.
     * Two real numbers a and b that represent the endpoints of an interval [a,b] on the real number
       line. (Note that the function referred to above should be continuous on this interval.)
     * An even integer n that specifies a number of subintervals. In implementing Simpson's Rule we
       divide the interval [a,b] into n subintervals.

   To simplify the presentation, let's focus on the programming interface and not on the implementation
   details. (Truthfully, I hope that this approach will let us bypass arguments about the best or most
   efficient way to implement Simpson's Rule, which is not the focus of this article.) We will use type
   double for parameters a and b, and we will use type int for parameter n. The function to be
   integrated will take a single parameter of type double and a return a value of type double.

Function parameters in C++
   To provide a basis for comparison, let's start with a C++ specification. When passing a function as a
   parameter in C++, I usually prefer to specify the signature of the function parameter using a
   typedef. Listing 1 shows a C++ header file named simpson.h that specifies both the typedef for the
   function parameter and the programming interface for a C++ function named integrate. The function
   body for integrate is contained in a C++ source code file named simpson.cpp (not shown) and
   provides the implementation for Simpson's Rule.

Listing 1. C++ header file for Simpson's Rule
#if !defined(SIMPSON_H)
#define SIMPSON_H
#include <stdexcept>
using namespace std;
typedef double DoubleFunction(double x);
double integrate(DoubleFunction f, double a, double b, int n)
    throw(invalid_argument);
#endif

   Calling integrate is straightforward in C++. As a simple example, suppose that you wanted to use
   Simpson's Rule to approximate the integral of the sine function from 0 to π (PI) using 30
   subintervals. (Anyone who has completed Calculus I should be able to compute the answer exactly
   without the help of a calculator, making this a good test case for the integrate function.) Assuming
   that you had included the proper header files such as <cmath> and "simpson.h", you would be able to
   call function integrate as shown in Listing 2.

Listing 2. C++ call to function integrate
double result = integrate(sin, 0, M_PI, 30);

   That's all there is to it. In C++ you pass the sine function as easily as you pass the other three
   parameters.

Another example
   Instead of Simpson's Rule I could have just as easily used the Bisection Method (aka the
   Bisection Algorithm) for solving an equation of the form f(x) = 0. In fact, the source code for this
   article includes simple implementations of both Simpson's Rule and the Bisection Method.

Java without lambda expressions
   Now let's look at how Simpson's Rule might be specified in Java. Regardless of whether or not we are
   using lambda expressions, we use the Java interface shown in Listing 3 in place of the C++ typedef to
   specify the signature of the function parameter.

Listing 3. Java interface for the function parameter
public interface DoubleFunction
{
    public double f(double x);
}

   To implement Simpson's Rule in Java we create a class named Simpson that contains a method,
   integrate, with four parameters similar to what we did in C++. As with a lot of self-contained
   mathematical methods (see, for example, java.lang.Math), we will make integrate a static method.
   Method integrate is specified as follows:

Listing 4. Java signature for method integrate in class Simpson
public static double integrate(DoubleFunction df, double a, double b, int n)

   Everything that we've done thus far in Java is independent of whether or not we will use lambda
   expressions. The primary difference with lambda expressions is in how we pass parameters (more
   specifically, how we pass the function parameter) in a call to method integrate. First I'll
   illustrate how this would be done in versions of Java prior to version 8; i.e., without lambda
   expressions. As with the C++ example, assume that we want to approximate the integral of the sine
   function from 0 to π (PI) using 30 subintervals.

Using the Adapter pattern for the sine function
   In Java we have an implementation of the sine function available in java.lang.Math, but with versions
   of Java prior to Java 8, there is no simple, direct way to pass this sine function to the method
   integrate in class Simpson. One approach is to use the Adapter pattern. In this case we would
   write a simple adapter class that implements the DoubleFunction interface and adapts it to call the
   sine function, as shown in Listing 5.

Listing 5. Adapter class for method Math.sin
import com.softmoore.math.DoubleFunction;
public class DoubleFunctionSineAdapter implements DoubleFunction {
    public double f(double x) {
        return Math.sin(x);
    }
}

   Using this adapter class we can now call the integrate method of class Simpson as shown in Listing 6.

Listing 6. Using the adapter class to call method Simpson.integrate
DoubleFunctionSineAdapter sine = new DoubleFunctionSineAdapter();
double result = Simpson.integrate(sine, 0, Math.PI, 30);

   Let's stop a moment and compare what was required to make the call to integrate in C++ versus what
   was required in earlier versions of Java. With C++, we simply called integrate, passing in the four
   parameters. With Java, we had to create a new adapter class and then instantiate this class in order
   to make the call. If we wanted to integrate several functions, we would need to write an adapter
   class for each of them.

   We could shorten the code needed to call integrate slightly from two Java statements to one by
   creating the new instance of the adapter class within the call to integrate. Using an anonymous class
   rather than creating a separate adapter class would be another way to slightly reduce the overall
   effort, as shown in Listing 7.

Listing 7. Using an anonymous class to call method Simpson.integrate
DoubleFunction sineAdapter = new DoubleFunction() {
    public double f(double x) {
        return Math.sin(x);
    }
};
double result = Simpson.integrate(sineAdapter, 0, Math.PI, 30);

   Without lambda expressions, what you see in Listing 7 is about the least amount of code that you
   could write in Java to call the integrate method, but it is still much more cumbersome than what was
   required for C++. I am also not that happy with using anonymous classes, although I have used
   them a lot in the past. I dislike the syntax and have always considered it to be a clumsy but
   necessary hack in the Java language.

Java with lambda expressions and functional interfaces
   Now let's look at how we could use lambda expressions in Java 8 to simplify the call to integrate in
   Java. Because the interface DoubleFunction requires the implementation of only a single method it is
   a candidate for lambda expressions. If we know in advance that we are going to use lambda
   expressions, we can annotate the interface with @FunctionalInterface, a new annotation for Java 8
   that says we have a functional interface. Note that this annotation is not required, but it gives us
   an extra check that everything is consistent, similar to the @Override annotation in earlier versions
   of Java.

   The syntax of a lambda expression is an argument list enclosed in parentheses, an arrow token (->),
   and a function body. The body can be either a statement block (enclosed in braces) or a single
   expression. Listing 8 shows a lambda expression that implements the interface DoubleFunction and is
   then passed to method integrate.

Listing 8. Using a lambda expression to call method Simpson.integrate
DoubleFunction sine = (double x) -> Math.sin(x);
double result = Simpson.integrate(sine, 0, Math.PI, 30);

   Note that we did not have to write the adapter class or create an instance of an anonymous class.
   Also note that we could have written the above in a single statement by substituting the lambda
   expression itself, (double x) -> Math.sin(x), for the parameter sine in the second statement above,
   eliminating the first statement. Now we are getting much closer to the simple syntax that we had in
   C++. But wait! There's more!

   The name of the functional interface is not part of the lambda expression but can be inferred based
   on the context. The type double for the parameter of the lambda expression can also be inferred from
   the context. Finally, if there is only one parameter in the lambda expression, then we can omit the
   parentheses. Thus we can abbreviate the code to call method integrate to a single line of code, as
   shown in Listing 9.

Listing 9. An alternate format for lambda expression in call to Simpson.integrate
double result = Simpson.integrate(x -> Math.sin(x), 0, Math.PI, 30);

   But wait! There's even more!

Method references in Java 8
   Another related feature in Java 8 is something called a method reference, which allows us to refer to
   an existing method by name. Method references can be used in place of lambda expressions as long as
   they satisfy the requirements of the functional interface. As described in the resources, there are
   several different kinds of method references, each with a slightly different syntax. For static
   methods the syntax is Classname::methodName. Therefore, using a method reference, we can call the
   integrate method in Java as simply as we could in C++. Compare Java 8 call shown in Listing 10 below
   with original C++ call shown in Listing 2 above.

Listing 10. Using a method reference to call Simpson.integrate
double result = Simpson.integrate(Math::sin, 0, Math.PI, 30);

   Page 1 of 2
   
   As a final thought, although I prefer writing the interface DoubleFunction because I think that it makes
   the code easier to understand, even that interface can be eliminated. Java 8 has a new package,
   java.util.function, that contains a number of commonly used functional interfaces. Many are expressed using
   generics, but there are specializations for primitive types. I'll leave the use of one of these interfaces
   in place of DoubleFunction as the proverbial exercise for the reader. (For a hint, look closely at
   DoubleUnaryOperator in java.util.function. If you get stuck, see class Simpson2 in the source code provided
   with this article.)
   
In conclusion
Overall I have found it a pleasure to code in Java, and it has been my preferred programming language for more
than 15 years. There are (still) a few places where Java's syntax seems awkward, however. With the addition of
lambda expressions, Java 8 will correct one of them. Taken together, the major points of this article remind
me of Cay Horstmann's so-called March of Progress, a portion of which is copied below with his permission.

The March of Progress, by Cay Horstmann

1980: C
printf("%10.2f", x);

1988: C++
cout << setw(10) << setprecision(2) << showpoint << x;

1996: Java
java.text.NumberFormat formatter = java.text.NumberFormat.getNumberInstance();
formatter.setMinimumFractionDigits(2);
formatter.setMaximumFractionDigits(2);
String s = formatter.format(x);
for (int i = s.length(); i < 10; i++) System.out.print(' ');
System.out.print(s);

2004: Java
System.out.printf("%10.2f", x);



---
[**1]
https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html

Lambda Expressions
   One issue with anonymous classes is that if the implementation of your anonymous class is very
   simple, such as an interface that contains only one method, then the syntax of anonymous classes may
   seem unwieldy and unclear. In these cases, you're usually trying to pass functionality as an argument
   to another method, such as what action should be taken when someone clicks a button. Lambda
   expressions enable you to do this, to treat functionality as method argument, or code as data.

   The previous section, [**2][https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html]
   Anonymous Classes, shows you how to implement a base class without giving it a name. Although this is often
   more concise than a named class, for classes with only one method, even an anonymous class seems a bit
   excessive and cumbersome. Lambda expressions let you express instances of single-method classes more compactly.

Ideal Use Case for Lambda Expressions
   Suppose that you are creating a social networking application. You want to create a feature that
   enables an administrator to perform any kind of action, such as sending a message, on members of the
   social networking application that satisfy certain criteria. The following table describes this use
   case in detail:
   -----------------------------------------------------------------------------------------------------------
   Field                   Description
   -----------------------------------------------------------------------------------------------------------
   Name                    Perform action on selected members
   Primary Actor           Administrator
   Preconditions           Administrator is logged in to the system.
   Postconditions          Action is performed only on members that fit the specified criteria.
   -----------------------------------------------------------------------------------------------------------
   Main Success Scenario   1. Administrator specifies criteria of members on which to perform a certain action.
                           2. Administrator specifies an action to perform on those selected members.
                           3. Administrator selects the Submit button.
                           4. The system finds all members that match the specified criteria.
                           5. The system performs the specified action on all matching members.
   -----------------------------------------------------------------------------------------------------------
   Extensions              1a. Administrator has an option to preview those members who match the specified
                           criteria before he or she specifies the action to be performed or before selecting
                           the Submit button. Frequency of Occurrence Many times during the day.
   -----------------------------------------------------------------------------------------------------------
   Frequency of            Many times during the day.
   Occurrence 
   -----------------------------------------------------------------------------------------------------------
   
   Suppose that members of this social networking application are represented by the following
   Person class:
public class Person {

    public enum Sex {
        MALE, FEMALE
    }

    String name;
    LocalDate birthday;
    Sex gender;
    String emailAddress;

    public int getAge() {
        // ...
    }

    public void printPerson() {
        // ...
    }
}

   Suppose that the members of your social networking application are stored in a List<Person> instance.

   This section begins with a naive approach to this use case. It improves upon this approach with local
   and anonymous classes, and then finishes with an efficient and concise approach using lambda
   expressions. Find the code excerpts described in this section in the example RosterTest.

Approach 1: Create Methods That Search for Members That Match One Characteristic
   One simplistic approach is to create several methods; each method searches for members that match one
   characteristic, such as gender or age. The following method prints members that are older than a
   specified age:
public static void printPersonsOlderThan(List<Person> roster, int age) {
    for (Person p : roster) {
        if (p.getAge() >= age) {
            p.printPerson();
        }
    }
}

   Note: A List is an ordered Collection. A collection is an object that groups multiple
   elements into a single unit. Collections are used to store, retrieve, manipulate, and communicate
   aggregate data. For more information about collections, see the Collections trail.

   This approach can potentially make your application brittle, which is the likelihood of an
   application not working because of the introduction of updates (such as newer data types). Suppose
   that you upgrade your application and change the structure of the Person class such that it contains
   different member variables; perhaps the class records and measures ages with a different data type or
   algorithm. You would have to rewrite a lot of your API to accommodate this change. In addition, this
   approach is unnecessarily restrictive; what if you wanted to print members younger than a certain
   age, for example?

Approach 2: Create More Generalized Search Methods
   The following method is more generic than printPersonsOlderThan; it prints members within a specified
   range of ages:
public static void printPersonsWithinAgeRange(
    List<Person> roster, int low, int high) {
    for (Person p : roster) {
        if (low <= p.getAge() && p.getAge() < high) {
            p.printPerson();
        }
    }
}

   What if you want to print members of a specified sex, or a combination of a specified gender and age
   range? What if you decide to change the Person class and add other attributes such as relationship
   status or geographical location? Although this method is more generic than printPersonsOlderThan,
   trying to create a separate method for each possible search query can still lead to brittle code. You
   can instead separate the code that specifies the criteria for which you want to search in a different
   class.

Approach 3: Specify Search Criteria Code in a Local Class
   The following method prints members that match search criteria that you specify:
public static void printPersons(
    List<Person> roster, CheckPerson tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}

   This method checks each Person instance contained in the List parameter roster whether it satisfies
   the search criteria specified in the CheckPerson parameter tester by invoking the method tester.test.
   If the method tester.test returns a true value, then the method printPersons is invoked on the Person
   instance.

   To specify the search criteria, you implement the CheckPerson interface:
interface CheckPerson {
    boolean test(Person p);
}

   The following class implements the CheckPerson interface by specifying an implementation for the
   method test. This method filters members that are eligible for Selective Service in the United
   States: it returns a true value if its Person parameter is male and between the ages of 18 and 25:
class CheckPersonEligibleForSelectiveService implements CheckPerson {
    public boolean test(Person p) {
        return p.gender == Person.Sex.MALE &&
            p.getAge() >= 18 &&
            p.getAge() <= 25;
    }
}

   To use this class, you create a new instance of it and invoke the printPersons method:
printPersons(
    roster, new CheckPersonEligibleForSelectiveService());

   Although this approach is less brittle-you don't have to rewrite methods if you change the structure
   of the Person-you still have additional code: a new interface and a local class for each search you
   plan to perform in your application. Because CheckPersonEligibleForSelectiveService implements an
   interface, you can use an anonymous class instead of a local class and bypass the need to declare a
   new class for each search.

Approach 4: Specify Search Criteria Code in an Anonymous Class

   One of the arguments of the following invocation of the method printPersons is an anonymous class
   that filters members that are eligible for Selective Service in the United States: those who are male
   and between the ages of 18 and 25:
printPersons(
    roster,
    new CheckPerson() {
        public boolean test(Person p) {
            return p.getGender() == Person.Sex.MALE
                && p.getAge() >= 18
                && p.getAge() <= 25;
        }
    }
);

   This approach reduces the amount of code required because you don't have to create a new class for
   each search that you want to perform. However, the syntax of anonymous classes is bulky considering
   that the CheckPerson interface contains only one method. In this case, you can use a lambda
   expression instead of an anonymous class, as described in the next section.

Approach 5: Specify Search Criteria Code with a Lambda Expression
   The CheckPerson interface is a functional interface. A functional interface is any interface that
   contains only one abstract method. (A functional interface may contain one or more default
   methods or static methods.) Because a functional interface contains only one abstract method, you
   can omit the name of that method when you implement it. To do this, instead of using an anonymous
   class expression, you use a lambda expression, which is highlighted in the following method
   invocation:
printPersons(
    roster,
    (Person p) -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25
);

   See Syntax of Lambda Expressions for information about how to define lambda expressions.

   You can use a standard functional interface in place of the interface CheckPerson, which reduces even
   further the amount of code required.

Approach 6: Use Standard Functional Interfaces with Lambda Expressions
   Reconsider the CheckPerson interface:
interface CheckPerson {
    boolean test(Person p);
}

   This is a very simple interface. It's a functional interface because it contains only one abstract
   method. This method takes one parameter and returns a boolean value. The method is so simple that it
   might not be worth it to define one in your application. Consequently, the JDK defines several
   standard functional interfaces, which you can find in the package java.util.function.

   For example, you can use the Predicate<T> interface in place of CheckPerson. This interface contains
   the method boolean test(T t):
interface Predicate<T> {
    boolean test(T t);
}

   The interface Predicate<T> is an example of a generic interface. (For more information about
   generics, see the Generics (Updated) lesson.) Generic types (such as generic interfaces) specify
   one or more type parameters within angle brackets (<>). This interface contains only one type
   parameter, T. When you declare or instantiate a generic type with actual type arguments, you have a
   parameterized type. For example, the parameterized type Predicate<Person> is the following:
interface Predicate<Person> {
    boolean test(Person t);
}

   This parameterized type contains a method that has the same return type and parameters as
   CheckPerson.boolean test(Person p). Consequently, you can use Predicate<T> in place of CheckPerson as
   the following method demonstrates:
public static void printPersonsWithPredicate(
    List<Person> roster, Predicate<Person> tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}

   As a result, the following method invocation is the same as when you invoked printPersons in
   Approach 3: Specify Search Criteria Code in a Local Class to obtain members who are eligible for
   Selective Service:
printPersonsWithPredicate(
    roster,
    p -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25
);

   This is not the only possible place in this method to use a lambda expression. The following approach
   suggests other ways to use lambda expressions.

Approach 7: Use Lambda Expressions Throughout Your Application
   Reconsider the method printPersonsWithPredicate to see where else you could use lambda expressions:
public static void printPersonsWithPredicate(
    List<Person> roster, Predicate<Person> tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}

   This method checks each Person instance contained in the List parameter roster whether it satisfies
   the criteria specified in the Predicate parameter tester. If the Person instance does satisfy the
   criteria specified by tester, the method printPersron is invoked on the Person instance.

   Instead of invoking the method printPerson, you can specify a different action to perform on those
   Person instances that satisfy the criteria specified by tester. You can specify this action with a
   lambda expression. Suppose you want a lambda expression similar to printPerson, one that takes one
   argument (an object of type Person) and returns void. Remember, to use a lambda expression, you need
   to implement a functional interface. In this case, you need a functional interface that contains an
   abstract method that can take one argument of type Person and returns void. The Consumer<T> interface
   contains the method void accept(T t), which has these characteristics. The following method replaces
   the invocation p.printPerson() with an instance of Consumer<Person> that invokes the method accept:
public static void processPersons(
    List<Person> roster,
    Predicate<Person> tester,
    Consumer<Person> block) {
        for (Person p : roster) {
            if (tester.test(p)) {
                block.accept(p);
            }
        }
}

   As a result, the following method invocation is the same as when you invoked printPersons in
   Approach 3: Specify Search Criteria Code in a Local Class to obtain members who are eligible for
   Selective Service. The lambda expression used to print members is highlighted:
processPersons(
     roster,
     p -> p.getGender() == Person.Sex.MALE
         && p.getAge() >= 18
         && p.getAge() <= 25,
     p -> p.printPerson()
);

   What if you want to do more with your members' profiles than printing them out. Suppose that you want
   to validate the members' profiles or retrieve their contact information? In this case, you need a
   functional interface that contains an abstract method that returns a value. The Function<T,R>
   interface contains the method R apply(T t). The following method retrieves the data specified by the
   parameter mapper, and then performs an action on it specified by the parameter block:
public static void processPersonsWithFunction(
    List<Person> roster,
    Predicate<Person> tester,
    Function<Person, String> mapper,
    Consumer<String> block) {
    for (Person p : roster) {
        if (tester.test(p)) {
            String data = mapper.apply(p);
            block.accept(data);
        }
    }
}

   The following method retrieves the email address from each member contained in roster who is eligible
   for Selective Service and then prints it:
processPersonsWithFunction(
    roster,
    p -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25,
    p -> p.getEmailAddress(),
    email -> System.out.println(email)
);

Approach 8: Use Generics More Extensively
   Reconsider the method processPersonsWithFunction. The following is a generic version of it that
   accepts, as a parameter, a collection that contains elements of any data type:
public static <X, Y> void processElements(
    Iterable<X> source,
    Predicate<X> tester,
    Function <X, Y> mapper,
    Consumer<Y> block) {
    for (X p : source) {
        if (tester.test(p)) {
            Y data = mapper.apply(p);
            block.accept(data);
        }
    }
}

   To print the e-mail address of members who are eligible for Selective Service, invoke the
   processElements method as follows:
processElements(
    roster,
    p -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25,
    p -> p.getEmailAddress(),
    email -> System.out.println(email)
);

   This method invocation performs the following actions:
    1. Obtains a source of objects from the collection source. In this example, it obtains a source of
       Person objects from the collection roster. Notice that the collection roster, which is a
       collection of type List, is also an object of type Iterable.
    2. Filters objects that match the Predicate object tester. In this example, the Predicate object is
       a lambda expression that specifies which members would be eligible for Selective Service.
    3. Maps each filtered object to a value as specified by the Function object mapper. In this example,
       the Function object is a lambda expression that returns the e-mail address of a member.
    4. Performs an action on each mapped object as specified by the Consumer object block. In this
       example, the Consumer object is a lambda expression that prints a string, which is the e-mail
       address returned by the Function object.

   You can replace each of these actions with an aggregate operation.

Approach 9: Use Aggregate Operations That Accept Lambda Expressions as Parameters
   The following example uses aggregate operations to print the e-mail addresses of those members
   contained in the collection roster who are eligible for Selective Service:
roster
    .stream()
    .filter(
        p -> p.getGender() == Person.Sex.MALE
            && p.getAge() >= 18
            && p.getAge() <= 25)
    .map(p -> p.getEmailAddress())
    .forEach(email -> System.out.println(email));

   The following table maps each of the operations the method processElements performs with the
   corresponding aggregate operation:
   processElements Action Aggregate Operation
   Obtain a source of objects Stream<E> stream()
   Filter objects that match a Predicate object Stream<T> filter(Predicate<? super T> predicate)
   Map objects to another value as specified by a Function object <R> Stream<R> map(Function<? super T,?
   extends R> mapper)
   Perform an action as specified by a Consumer object void forEach(Consumer<? super T> action)

   The operations filter, map, and forEach are aggregate operations. Aggregate operations process
   elements from a stream, not directly from a collection (which is the reason why the first method
   invoked in this example is stream). A stream is a sequence of elements. Unlike a collection, it is
   not a data structure that stores elements. Instead, a stream carries values from a source, such as
   collection, through a pipeline. A pipeline is a sequence of stream operations, which in this example
   is filter- map-forEach. In addition, aggregate operations typically accept lambda expressions as
   parameters, enabling you to customize how they behave.

   For a more thorough discussion of aggregate operations, see the Aggregate Operations lesson.

Lambda Expressions in GUI Applications
   To process events in a graphical user interface (GUI) application, such as keyboard actions, mouse
   actions, and scroll actions, you typically create event handlers, which usually involves implementing
   a particular interface. Often, event handler interfaces are functional interfaces; they tend to have
   only one method.

   In the JavaFX example HelloWorld.java (discussed in the previous section Anonymous Classes),
   you can replace the highlighted anonymous class with a lambda expression in this statement:
        btn.setOnAction(new EventHandler<ActionEvent>() {

            @Override
            public void handle(ActionEvent event) {
                System.out.println("Hello World!");
            }
        });

   The method invocation btn.setOnAction specifies what happens when you select the button represented
   by the btn object. This method requires an object of type EventHandler<ActionEvent>. The
   EventHandler<ActionEvent> interface contains only one method, void handle(T event). This interface is
   a functional interface, so you could use the following highlighted lambda expression to replace it:
        btn.setOnAction(
          event -> System.out.println("Hello World!")
        );

Syntax of Lambda Expressions
   A lambda expression consists of the following:
     * A comma-separated list of formal parameters enclosed in parentheses. The CheckPerson.test method
       contains one parameter, p, which represents an instance of the Person class.
       Note: You can omit the data type of the parameters in a lambda expression. In addition, you can
       omit the parentheses if there is only one parameter. For example, the following lambda expression
       is also valid:
p -> p.getGender() == Person.Sex.MALE
    && p.getAge() >= 18
    && p.getAge() <= 25
     * The arrow token, ->
     * A body, which consists of a single expression or a statement block. This example uses the
       following expression:
p.getGender() == Person.Sex.MALE
    && p.getAge() >= 18
    && p.getAge() <= 25
       If you specify a single expression, then the Java runtime evaluates the expression and then
       returns its value. Alternatively, you can use a return statement:
p -> {
    return p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25;
}
       A return statement is not an expression; in a lambda expression, you must enclose statements in
       braces ({}). However, you do not have to enclose a void method invocation in braces. For example,
       the following is a valid lambda expression:
email -> System.out.println(email)

   Note that a lambda expression looks a lot like a method declaration; you can consider lambda
   expressions as anonymous methods-methods without a name.

   The following example, Calculator, is an example of lambda expressions that take more than one
   formal parameter:

public class Calculator {

    interface IntegerMath {
        int operation(int a, int b);
    }

    public int operateBinary(int a, int b, IntegerMath op) {
        return op.operation(a, b);
    }

    public static void main(String... args) {

        Calculator myApp = new Calculator();
        IntegerMath addition = (a, b) -> a + b;
        IntegerMath subtraction = (a, b) -> a - b;
        System.out.println("40 + 2 = " +
            myApp.operateBinary(40, 2, addition));
        System.out.println("20 - 10 = " +
            myApp.operateBinary(20, 10, subtraction));
    }
}


   The method operateBinary performs a mathematical operation on two integer operands. The operation
   itself is specified by an instance of IntegerMath. The example defines two operations with lambda
   expressions, addition and subtraction. The example prints the following:
40 + 2 = 42
20 - 10 = 10

Accessing Local Variables of the Enclosing Scope
   Like local and anonymous classes, lambda expressions can capture variables; they have the same
   access to local variables of the enclosing scope. However, unlike local and anonymous classes, lambda
   expressions do not have any shadowing issues (see Shadowing for more information). Lambda
   expressions are lexically scoped. This means that they do not inherit any names from a supertype or
   introduce a new level of scoping. Declarations in a lambda expression are interpreted just as they
   are in the enclosing environment. The following example, LambdaScopeTest, demonstrates this:

import java.util.function.Consumer;

public class LambdaScopeTest {

    public int x = 0;

    class FirstLevel {

        public int x = 1;

        void methodInFirstLevel(int x) {

            // The following statement causes the compiler to generate
            // the error "local variables referenced from a lambda expression
            // must be final or effectively final" in statement A:
            //
            // x = 99;

            Consumer<Integer> myConsumer = (y) ->
            {
                System.out.println("x = " + x); // Statement A
                System.out.println("y = " + y);
                System.out.println("this.x = " + this.x);
                System.out.println("LambdaScopeTest.this.x = " +
                    LambdaScopeTest.this.x);
            };

            myConsumer.accept(x);

        }
    }

    public static void main(String... args) {
        LambdaScopeTest st = new LambdaScopeTest();
        LambdaScopeTest.FirstLevel fl = st.new FirstLevel();
        fl.methodInFirstLevel(23);
    }
}

   This example generates the following output:
x = 23
y = 23
this.x = 1
LambdaScopeTest.this.x = 0

   If you substitute the parameter x in place of y in the declaration of the lambda expression
   myConsumer, then the compiler generates an error:
Consumer<Integer> myConsumer = (x) -> {
    // ...
}

   The compiler generates the error "variable x is already defined in method methodInFirstLevel(int)"
   because the lambda expression does not introduce a new level of scoping. Consequently, you can
   directly access fields, methods, and local variables of the enclosing scope. For example, the lambda
   expression directly accesses the parameter x of the method methodInFirstLevel. To access variables in
   the enclosing class, use the keyword this. In this example, this.x refers to the member variable
   FirstLevel.x.

   However, like local and anonymous classes, a lambda expression can only access local variables and
   parameters of the enclosing block that are final or effectively final. For example, suppose that you
   add the following assignment statement immediately after the methodInFirstLevel definition statement:
void methodInFirstLevel(int x) {
    x = 99;
    // ...
}

   Because of this assignment statement, the variable FirstLevel.x is not effectively final anymore. As
   a result, the Java compiler generates an error message similar to "local variables referenced from a
   lambda expression must be final or effectively final" where the lambda expression myConsumer tries to
   access the FirstLevel.x variable:
System.out.println("x = " + x);

Target Typing
   How do you determine the type of a lambda expression? Recall the lambda expression that selected
   members who are male and between the ages 18 and 25 years:
p -> p.getGender() == Person.Sex.MALE
    && p.getAge() >= 18
    && p.getAge() <= 25

   This lambda expression was used in the following two methods:
     * public static void printPersons(List<Person> roster, CheckPerson tester) in Approach 3:
       Specify Search Criteria Code in a Local Class
     * public void printPersonsWithPredicate(List<Person> roster, Predicate<Person> tester) in
       Approach 6: Use Standard Functional Interfaces with Lambda Expressions

   When the Java runtime invokes the method printPersons, it's expecting a data type of CheckPerson, so
   the lambda expression is of this type. However, when the Java runtime invokes the method
   printPersonsWithPredicate, it's expecting a data type of Predicate<Person>, so the lambda expression
   is of this type. The data type that these methods expect is called the target type. To determine the
   type of a lambda expression, the Java compiler uses the target type of the context or situation in
   which the lambda expression was found. It follows that you can only use lambda expressions in
   situations in which the Java compiler can determine a target type:
     * Variable declarations
     * Assignments
     * Return statements
     * Array initializers
     * Method or constructor arguments
     * Lambda expression bodies
     * Conditional expressions, ?:
     * Cast expressions

Target Types and Method Arguments
   For method arguments, the Java compiler determines the target type with two other language features:
   overload resolution and type argument inference.

   Consider the following two functional interfaces ( java.lang.Runnable and
   java.util.concurrent.Callable<V>):
public interface Runnable {
    void run();
}

public interface Callable<V> {
    V call();
}

   The method Runnable.run does not return a value, whereas Callable<V>.call does.

   Suppose that you have overloaded the method invoke as follows (see Defining Methods for more
   information about overloading methods):
void invoke(Runnable r) {
    r.run();
}

<T> T invoke(Callable<T> c) {
    return c.call();
}

   Which method will be invoked in the following statement?
String s = invoke(() -> "done");

   The method invoke(Callable<T>) will be invoked because that method returns a value; the method
   invoke(Runnable) does not. In this case, the type of the lambda expression () -> "done" is
   Callable<T>.

Serialization
   You can serialize a lambda expression if its target type and its captured arguments are
   serializable. However, like inner classes, the serialization of lambda expressions is strongly
   discouraged.


---
[**2]
https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html

Anonymous Classes
   Anonymous classes enable you to make your code more concise. They enable you to declare and
   instantiate a class at the same time. They are like local classes except that they do not have a
   name. Use them if you need to use a local class only once.

Declaring Anonymous Classes
   While local classes are class declarations, anonymous classes are expressions, which means that you
   define the class in another expression. The following example, HelloWorldAnonymousClasses, uses
   anonymous classes in the initialization statements of the local variables frenchGreeting and
   spanishGreeting, but uses a local class for the initialization of the variable englishGreeting:

public class HelloWorldAnonymousClasses {

    interface HelloWorld {
        public void greet();
        public void greetSomeone(String someone);
    }

    public void sayHello() {

        class EnglishGreeting implements HelloWorld {
            String name = "world";
            public void greet() {
                greetSomeone("world");
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println("Hello " + name);
            }
        }

        HelloWorld englishGreeting = new EnglishGreeting();

        HelloWorld frenchGreeting = new HelloWorld() {
            String name = "tout le monde";
            public void greet() {
                greetSomeone("tout le monde");
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println("Salut " + name);
            }
        };

        HelloWorld spanishGreeting = new HelloWorld() {
            String name = "mundo";
            public void greet() {
                greetSomeone("mundo");
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println("Hola, " + name);
            }
        };
        englishGreeting.greet();
        frenchGreeting.greetSomeone("Fred");
        spanishGreeting.greet();
    }

    public static void main(String... args) {
        HelloWorldAnonymousClasses myApp =
            new HelloWorldAnonymousClasses();
        myApp.sayHello();
    }
}

Syntax of Anonymous Classes
   As mentioned previously, an anonymous class is an expression. The syntax of an anonymous class
   expression is like the invocation of a constructor, except that there is a class definition contained
   in a block of code.

   Consider the instantiation of the frenchGreeting object:
        HelloWorld frenchGreeting = new HelloWorld() {
            String name = "tout le monde";
            public void greet() {
                greetSomeone("tout le monde");
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println("Salut " + name);
            }
        };

   The anonymous class expression consists of the following:
     * The new operator
     * The name of an interface to implement or a class to extend. In this example, the anonymous class
       is implementing the interface HelloWorld.
     * Parentheses that contain the arguments to a constructor, just like a normal class instance
       creation expression. Note: When you implement an interface, there is no constructor, so you use
       an empty pair of parentheses, as in this example.
     * A body, which is a class declaration body. More specifically, in the body, method declarations
       are allowed but statements are not.

   Because an anonymous class definition is an expression, it must be part of a statement. In this
   example, the anonymous class expression is part of the statement that instantiates the frenchGreeting
   object. (This explains why there is a semicolon after the closing brace.)

Accessing Local Variables of the Enclosing Scope, and Declaring and Accessing Members of the Anonymous
Class
   Like local classes, anonymous classes can capture variables; they have the same access to local
   variables of the enclosing scope:
     * An anonymous class has access to the members of its enclosing class.
     * An anonymous class cannot access local variables in its enclosing scope that are not declared as
       final or effectively final.
     * Like a nested class, a declaration of a type (such as a variable) in an anonymous class shadows
       any other declarations in the enclosing scope that have the same name. See Shadowing for more
       information.

   Anonymous classes also have the same restrictions as local classes with respect to their members:
     * You cannot declare static initializers or member interfaces in an anonymous class.
     * An anonymous class can have static members provided that they are constant variables.

   Note that you can declare the following in anonymous classes:
     * Fields
     * Extra methods (even if they do not implement any methods of the supertype)
     * Instance initializers
     * Local classes

   However, you cannot declare constructors in an anonymous class.

Examples of Anonymous Classes
   Anonymous classes are often used in graphical user interface (GUI) applications.

   Consider the JavaFX example HelloWorld.java (from the section Hello World, JavaFX Style from
   Getting Started with JavaFX). This sample creates a frame that contains a Say 'Hello World'
   button. The anonymous class expression is highlighted:
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;

public class HelloWorld extends Application {
    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        primaryStage.setTitle("Hello World!");
        Button btn = new Button();
        btn.setText("Say 'Hello World'");
        btn.setOnAction(new EventHandler<ActionEvent>() {

            @Override
            public void handle(ActionEvent event) {
                System.out.println("Hello World!");
            }
        });

        StackPane root = new StackPane();
        root.getChildren().add(btn);
        primaryStage.setScene(new Scene(root, 300, 250));
        primaryStage.show();
    }
}

   In this example, the method invocation btn.setOnAction specifies what happens when you select the Say
   'Hello World' button. This method requires an object of type EventHandler<ActionEvent>. The
   EventHandler<ActionEvent> interface contains only one method, handle. Instead of implementing this
   method with a new class, the example uses an anonymous class expression. Notice that this expression
   is the argument passed to the btn.setOnAction method.

   Because the EventHandler<ActionEvent> interface contains only one method, you can use a lambda
   expression instead of an anonymous class expression. See the section Lambda Expressions for more
   information.

   Anonymous classes are ideal for implementing an interface that contains two or more methods. The
   following JavaFX example is from the section Customization of UI Controls. The highlighted code
   creates a text field that only accepts numeric values. It redefines the default implementation of the
   TextField class with an anonymous class by overriding the replaceText and replaceSelection methods
   inherited from the TextInputControl class.
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class CustomTextFieldSample extends Application {

    final static Label label = new Label();

    @Override
    public void start(Stage stage) {
        Group root = new Group();
        Scene scene = new Scene(root, 300, 150);
        stage.setScene(scene);
        stage.setTitle("Text Field Sample");

        GridPane grid = new GridPane();
        grid.setPadding(new Insets(10, 10, 10, 10));
        grid.setVgap(5);
        grid.setHgap(5);

        scene.setRoot(grid);
        final Label dollar = new Label("$");
        GridPane.setConstraints(dollar, 0, 0);
        grid.getChildren().add(dollar);

        final TextField sum = new TextField() {
            @Override
            public void replaceText(int start, int end, String text) {
                if (!text.matches("[a-z, A-Z]")) {
                    super.replaceText(start, end, text);
                }
                label.setText("Enter a numeric value");
            }

            @Override
            public void replaceSelection(String text) {
                if (!text.matches("[a-z, A-Z]")) {
                    super.replaceSelection(text);
                }
            }
        };

        sum.setPromptText("Enter the total");
        sum.setPrefColumnCount(10);
        GridPane.setConstraints(sum, 1, 0);
        grid.getChildren().add(sum);

        Button submit = new Button("Submit");
        GridPane.setConstraints(submit, 2, 0);
        grid.getChildren().add(submit);

        submit.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                label.setText(null);
            }
        });

        GridPane.setConstraints(label, 0, 1);
        GridPane.setColumnSpan(label, 3);
        grid.getChildren().add(label);

        scene.setRoot(grid);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}


---
