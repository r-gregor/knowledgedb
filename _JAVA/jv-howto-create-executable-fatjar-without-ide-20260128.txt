filename: jv-howto-create-executable-fatjar-without-ide-20260128.txt
https://dzone.com/articles/java-8-how-to-create-executable-fatjar-without-ide

Create an Executable Fat JAR With Your Command Line
Oct. 28, 2016

Want to get an executable fat JAR file up and running with just your command line? See the groundwork you need
to lay and how to get it done.

This article is a unification of my blog posts reviewing the possibility of creating fat JARs (Java Archive
file) in Java without using any additional plugin, IDE, or any other tool -- just pure command line and Java.

In the world of build tools (Ant, Maven, or Gradle) it might not even seem useful to think about the command
line. The most famous IDEs (IntelliJ, Eclipse, or NetBeans) offer building tools and implementation
immediately. But let's say you only have the command line and no Internet access.

What will you do then?

Part 1: Compile ExecutableOne.jar ([https://github.com/mirage22/executable-one]GitHub)
The goal of this first part is to create an executable JAR file. Let's call it ExecutableOne.jar. Opening up
your comand line, let's start with creation of a simple project folder: executable-one. The example project
structure is following the [**1]Maven Standard Directory Layout structure.

./libs
./out
./README.md
./src
./src/main
./src/main/java
./src/main/java/com
./src/main/java/com/exec
./src/main/java/com/exec/one
./src/main/resources

As our intent is to create an executable JAR file, we have to create a main class. Let's do it in the package:
com.exec.one. The package can be found in the folder SRC/MAIN/JAVA of our sample project structure.

<code>
package com.exec.one;

public class Main {
	public static void main(String[] args){
		System.out.println("Main Class Start");
	}
}
</code>

Inside the folder SRC/MAIN/RESOURCES, we create the META-INF folder, and then inside, we place MANIFEST.FM
file there. Let's open the newly created MANIFEST.FM file and put in a basic description.

Manifest-Version: 1.0
Class-Path: .
Main-Class: com.exec.one.Main

Note: There will be the only one MANIFEST.FM file per JAR file.

The MANIFEST.FM file contains details on how the JAR file will be used. We're not going into deep details --
let's stay focused on the options we have defined.

  1 - Manifest-Version : manifest file version.

  2 - Class-Path: The application or extension class loader uses the value of this attribute to construct its
      internal search path. Originally, the class loader downloads and opens each element in its search path.
      For these purposes, a simple linear search algorithm has been used.

  3 - Main-Class: There is the name of the class that the launcher will load at the startup time.

Now, we create the JAR file without any *.jar library. The LIBS folder in our project structure is still
empty. To do so, we need to first compile the project by using javac. Meanwhile, we'll store the output in the
'out' folder. Let's go back to our command line and, inside the root of the project, type:
$> javac -cp ./src/main/java ./src/main/java/com/exec/one/*.java -d ./out/

The project has been compiled into the OUT directory. You can check it by using the ls command.  The second
step is to create an executable JAR file from the resources located inside the OUT directory. We go back to
the command line and execute the following command:
$> jar cvfm ExecutableOne.jar ./src/main/resources/META-INF/MANIFEST.MF -C ./out/ .

Let's briefly review/explain the JAR tool options we have used:

  * c:  indicates we want to create a new JAR file.
  * v:  generates verbose output to standard output.
  * f:  specifies the jarfile to be created.
  * m:  indicates the manifest file we use. The manifest file includes name-value pairs.
  * -C: indicates temporary changes to the directory. Classes are added from this directory to the JAR file.
        The dot indicates all classes (files).

For the final output, open the command line and type:
$> java -jar ./ExecutableOne.jar

standard output:
Main Class Start

Great job! Let's move to Part 2.

Part 2.: Compile ExecutableOne.jar With Additional Packages
The main goal of this section is to show how you how to compile an executable JAR file with additional
packages included. For such purposes, we've created MagicService. This service provides us with the
getMessage() method and prints the message to the standard output.

Let's open the command line and create a new folder, 'service', with file MagicService.java:
$> mkdir src/main/java/com/exec/one/service
$> vim src/main/java/com/exec/one/service/MagicService.java

The newly created MagicService can be used in the following example:

<code>
package com.exec.one.service;

public class MagicService {
private final String message;
	public MagicService(){
		this.message = "Magic Message";
	}
	public String getMessage(){
		return message;
	}
}
</code>

The MagicService is located in a different place in the package structure than the Main class. Now we go back
to the Main class and import the newly created MagicService. After the import and service instantiation, the
Main class will receive the access to the getMessage() method. The Main class will change in following manner.

<code>
package com.exec.one;

import com.exec.one.service.MagicService;

public class Main {
	public static void main(String[] args) {
		System.out.println("Main Class Start");
		MagicService service = new MagicService();
		System.out.println("MESSAGE : " + service.getMessage());
	}
}
</code>

Now we have reached the point where the code is ready to compile. Let's go back to the command line and go
into the root folder of the Executable-One project. The first step will be to compile/recompile the
Executable-One project into the OUT folder. For these purposes, we need to add the location of the newly
created class MagicService.java.

$> javac -cp ./src/main/java ./src/main/java/com/exec/one/*.java ./src/main/java/com/exec/one/**/*.java -d ./out/

The second step is to create an executable JAR file from the compiled classes. We don't need to make any
changes to the command because we have not changed the JAR file logic. It means that the MANIFEST.FM file
stays as it is, without any changes:

Manifest-Version: 1.0
Class-Path: .
Main-Class: com.exec.one.Main

Now we can again execute command similar to that of Part 1 in the root directory of the sample project:
$> jar cvfm ExecutableOne.jar ./src/main/resources/META-INF/MANIFEST.MF -C ./out/ .

By executing the created JAR file, we obtain the message printed into the standard output.

$> java -jar ExecutableOne.jar

output:
Main Class Start
MESSAGE : Magic Message

Congratulations! Great job, again !


---
[**1]
https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html

Introduction to the Standard Directory Layout

   Having a common directory layout allows users familiar with one Maven project to immediately feel at
   home in another Maven project. The advantages are analogous to adopting a site-wide look-and-feel.

   The next section documents the directory layout expected by Maven and the directory layout created by
   Maven. Try to conform to this structure as much as possible. However, if you can't, these settings
   can be overridden via the project descriptor.

   -------------------------------------------------------------------------------------------------
   Location               Description
   -------------------------------------------------------------------------------------------------
   src/main/java          Application/Library sources
   src/main/resources     Application/Library resources
   src/main/filters       Resource filter files
   src/main/webapp        Web application sources
   src/test/java          Test sources
   src/test/resources     Test resources
   src/test/filters       Test resource filter files
   src/it                 Integration Tests (primarily for plugins)
   src/assembly           Assembly descriptors
   src/site               Site
   LICENSE.txt            Project's license
   NOTICE.txt             Notices and attributions required by libraries that the project depends on
   README.txt             Project's readme
   -------------------------------------------------------------------------------------------------

   At the top level, files descriptive of the project: a pom.xml file. In addition, there are textual
   documents meant for the user to be able to read immediately on receiving the source: README.txt,
   LICENSE.txt, etc.

   There are just two subdirectories of this structure: src and target. The only other directories that
   would be expected here are metadata like CVS, .git or .svn, and any subprojects in a multiproject
   build (each of which would be laid out as above).

   The target directory is used to house all output of the build.

   The src directory contains all of the source material for building the project, its site and so on.
   It contains a subdirectory for each type: main for the main build artifact, test for the unit test
   code and resources, site and so on.

   Within artifact producing source directories (ie. main and test), there is one directory for the
   language java (under which the normal package hierarchy exists), and one for resources (the structure
   which is copied to the target classpath given the default resource definition).

   If there are other contributing sources to the artifact build, they would be under other
   subdirectories. For example src/main/antlr would contain Antlr grammar definition files.


---

