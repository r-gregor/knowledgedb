filename: jv_why-need-lambda-expressions-multif_20200518.txt
https://www.nagarro.com/en/blog/post/26/lambda-expressions-in-java-8-why-and-how-to-use-them

Lambda Expressions in Java 8: Why and How to Use Them

   lamba This is the third post in the 6-part series about the [12]top most interesting features of Java
   8 that make its adoption worthwhile for enterprises. In our last post, we discussed about
   [13]application performance improvement caused by a new strategy employed in JDK 8 for dealing with
   the HashMap collisions. In this post, we will discuss about the role of lambda expressions in Java 8
   in applying functional programming constructs in a pure Object-Oriented programming language.
   Using lambda expression, sequential and parallel execution can be achieved by passing behavior into
   methods. In the Java world, lambdas can be thought of as an anonymous method with a more compact
   syntax. Here compact means that it is not mandatory to specify access modifiers, return type and
   parameter types while defining the expression.

   Why Lambdas in Java
   There are various reasons for addition of lambda expression in Java platform but the most beneficial
   of them is that we can easily distribute processing of collection over multiple threads. Prior to
   Java 8, if the processing of elements in a collection had to be done in parallel, the client code was
   supposed to perform the necessary steps and not the collection. In Java 8, using lambda expression
   and Stream API we can pass processing logic of elements into methods provided by collections and now
   collection is responsible for parallel processing of elements and not the client.

   Also, parallel processing effectively utilizes multicore CPUs used nowadays.

   About Lambda Expression
   Syntax:
   (parameters) -> expression
   or
   (parameters) -> { statements; }

   Java 8 provide support for lambda expressions only with functional interfaces. Functional Interface
   is also a new feature introduced in Java 8. Any Interface with single abstract method is called
   Functional Interface. Since there is only one abstract method, there is no confusion in applying the
   lambda expression to that method.

   Benefits of Lambda Expression
   
   1. Fewer Lines of Code
   One of the benefits of using lambda expression is the reduced amount of code. See the example below.
   code1
     * We know that in Java lambda can be used only with functional interfaces. In the above example,
       Runnable is a functional interface, so we can easily apply lambda expression here
     * In this case, we are not passing any parameter in lambda expression because the run() method of
       the functional interface (Runnable) takes no argument.
     * Also, the syntax of the lambda expression says that we can omit curly braces ({}) in case of a
       single statement in the method body. In case of multiple statements, we should use curly braces
       as done in the above example.

   2. Sequential and Parallel Execution Support by passing behavior in methods
   Prior to Java 8, processing the elements of any collection could be done by obtaining an iterator
   from the collection and then iterating over the elements and then processing each element. If the
   requirement is to process the elements in parallel, it would be done by the client code. With the
   introduction of Stream API in Java 8, functions can be passed to collection methods and now it is the
   responsibility of collection to process the elements either in a sequential or parallel manner.
   code2

   3. Higher Efficiency (Utilizing Multicore CPU's)
   Using Stream API's and lambda expression we can achieve higher efficiency (parallel execution) in
   case of bulk operations on collections. Also, the lambda expressions can help in achieving internal
   iteration of collections rather than external iteration as shown in the above example. As nowadays we
   have CPUs with multicores, we can take advantage of these multicore CPU's by parallel processing of
   collections using lambda.

   Lambda Expression and Objects
   In Java, any lambda expression is an object as is an instance of a functional interface. We can
   assign a lambda expression to any variable and pass it like any other object. See the example below
   on how a lambda expression is assigned to a variable, and how it is invoked.
   code3

   Where you can use Lambda expressions
   Lambda expressions can be used anywhere in Java 8 where we have a target type. In Java, we have
   target type in the following contexts
     * Variable declarations and assignments
     * Return statements
     * Method or constructor arguments

   What do you think about this new feature in Java 8? Leave your thoughts in the comments section of
   this post. In our next post, we will discuss about the new date and time API in Java 8.



---
https://dzone.com/articles/why-we-need-lambda-expressions

Why We Need Lambda Expressions in Java - Part 1

   Lambda expressions are coming to Java 8 and together with Raoul-Gabriel Urma and Alan Mycroft I
   started writing a [37]book on this topic. Anyway apparently they are still encountering some
   resistance and not all Java developers are convinced of their usefulness. In particular they say that
   it could be a mistake to try to add some functional features to Java, because they fear that this
   could compromise its strong object oriented and imperative nature. The purpose of this article is to
   hopefully remove any further doubt and show clearly, with practical and straightforward examples, why
   it is not possible for a modern programming language to not support lambda expressions.

External vs. internal iteration
   Let's start with something very simple, a list of integers:
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);

   and a for cycle that iterates all the items in the list and prints them:
for (int number : numbers) {
    System.out.println(number);
}

   Straightforward as much as common: I don't remember a single day of my more than decennial working
   life as Java developer when I haven't write at least one cycle like this. Simple as much as ...
   completely wrong. It remembers me a lot how my 2 years old daughter Sofia puts away her toys after
   having played with them. It goes on more or less in this way:

   Me: "Sofia, let's put the toys away. Is there a toy on the ground"

   Sofia: "Yes, the ball"

   Me: "Ok, put the ball in the box. Is there something else?"

   Sofia: "Yes, there is my doll"

   Me: "Ok, put the doll in the box. Is there something else?"

   Sofia: "Yes, there is my book"

   Me: "Ok, put the book in the box. Is there something else?"

   Sofia: "No, nothing else"

   Me: "Fine, we are done"

   This is exactly what we do everyday with our Java collections, but unfortunately the biggest part of
   us is not 2 years old. We iterate the collection externally, explicitly pulling out and processing
   the items one by one. It would be far better for me if I could tell to Sofia just: "put inside the
   box all the toys that are on the ground". There are two other reasons, why an internal iteration is
   preferable: first Sofia could choose to take at the same time the doll with one hand and the ball
   with the other and second she could decide to take the objects closest to the box first and then the
   others. In the same way using an internal iteration the JIT compiler could optimize it processing the
   items in parallel or in a different order. These optimizations are impossible if we iterate the
   collection externally as we are used to do in Java and more in general with the imperative
   programming.

   So, why don't we iterate internally? I think this is only a bad mental habit caused by the lack of
   support of this pattern in the Java Collection Framework that in turn has been caused by the
   verbosity (creation of an anonymous inner class) that this implies in pre-8 Java. Something like
   this:
numbers.forEach(new Consumer<Integer>() {
    public void accept(Integer value) {
        System.out.println(value);
    }
});

   Actually both the forEach method and the Consumer interface have been added in Java 8, but you can
   already do something very similar in Java 5+ using libraries like [38]guava  or [39]lambdaj . However
   Java 8 lambda expressions allow to achieve the same result in a less verbose and more readable way:
numbers.forEach((Integer value) -> System.out.println(value));

   The lambda expression is made of two parts the one on the left of the arrow symbol (->) listing its
   parameters and the one on the right containing its body. In this case the compiler automatically
   figures out that the lambda expression has the same signature of the only non implemented method of
   the Consumer interface (that for this reason is called a functional interface) and treat the first as
   it was an instance of the second, even if the generated bytecode could potentially be different. The
   declaration of the types of the lambda expression arguments can be, in the biggest part of cases,
   inferred by the compiler and then omitted as it follows:
numbers.forEach(value -> System.out.println(value));

   But we can rewrite this last statement even more concisely using a method reference, another feature
   introduced in Java 8. More in details in Java 8 it is possible to reference both a static and an
   instance a method using the new :: operator as in:
numbers.forEach(System.out::println);

   In this way, with a process that in functional programming is known as eta expansion, the name of the
   method is "expanded" by the compiler in the method itself that, as we have already seen, has the same
   signature of the only abstract method of the Consumer functional interface and then can be in turn
   converted in an instance of it.

Passing behaviors, not only values
   What we have seen in the former example is the main and possibly the only reason why lambda
   expressions are so useful. Passing a lambda expression to another function allow us to pass not only
   values but also behaviors and this enable to dramatically raise the level of our abstraction and then
   project more generic, flexible and reusable API. Let's reenforce this with a further example:
   starting with the usual list of Integer
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);

   we are requested to write a method that sums all the Integers in the list as for instance:
public int sumAll(List<Integer> numbers) {
    int total = 0;
    for (int number : numbers) {
        total += number;
    }
    return total;
}

   The day after a manager comes to our cubicle and tells you that the business also requires to have a
   function that sums only the even number in the list. So what is the quickest thing we could do? Easy.
   Just copy and paste the former method and add to it the required filtering condition:
public int sumAllEven(List<Integer> numbers) {
    int total = 0;
    for (int number : numbers) {
        if (number % 2 == 0) {
            total += number;
        }
    }
    return total;
}

   Another day, another requirement: this time they need to sum the numbers in the list again but only
   if they are greater than 3. So what could we do? Well, we could again copy and paste the former
   method and just change that boolean condition ... but it feels so dirty, isn't it? Now, following the
   [40]"First Write, Second Copy, Third Refactor" principle it is time to wonder if there is a smarter
   and more generic way to do this. In this case implementing an higher-order function accepting
   together with the list also a Predicate (another functional interface added in Java 8) that defines
   how to filter the numbers in the list itself before to sum them up.
public int sumAll(List<Integer> numbers, Predicate<Integer> p) {
    int total = 0;
    for (int number : numbers) {
        if (p.test(number)) {
            total += number;
        }
    }
    return total;
}

   In other words we are passing to the method not only the data (the list of numbers) but also a
   behavior (the Predicate) defining how to use them. In this way we can satisfy all the 3 requirements
   with a single more generic and then more reusable method:
sumAll(numbers, n -> true);
sumAll(numbers, n -> n % 2 == 0);
sumAll(numbers, n -> n > 3);

   In the [**1]second part of this article  I will show other examples to demonstrate how lambda
   expressions can make our Java code more readable and concise.



---
[**1]
https://dzone.com/articles/why-we-need-lambda-expressions-0

Why We Need Lambda Expressions in Java - Part 2

   In the first part of this article I started explaining, with hopefully straightforward examples,
   how the introduction of lambda expressions can make Java a more concise, readable, powerful and, in a
   word, modern language. I also announced that together with Raoul-Gabriel Urma and Alan Mycroft I
   started writing a [38]book on this topic. In this second part I'll try to reenforce this idea with 2
   more equally practical examples, hoping to help to convince all the Java developers, especially the
   most experienced ones, that we can no longer wait before to have a more functional oriented Java.

Efficiency through laziness
   Another advantage of internal iteration of collections and more in general of functional programming
   is the lazy evaluation that it allows. Let me demonstrate this starting again from the same List of
   Integer I already used in the first part:
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);

   This time let's suppose we want to achieve something just a bit more convoluted like to take only the
   even numbers in the list, double them and finally print the first one bigger than 5:
for (int number : numbers) {
    if (number % 2 == 0) {
        int n2 = number * 2;
        if (n2 > 5) {
            System.out.println(n2);
            break;
        }
    }
}

   What is wrong with this solution should be clear: it does too much in a single, deeply nested and
   then difficult to read and maintain block of code. To fix this problem we can split the 3 operations
   performed by that code in 3 one-line methods each having a single well defined responsibility:
public boolean isEven(int number) {
    return number % 2 == 0;
}

public int doubleIt(int number) {
    return number * 2;
}

public boolean isGreaterThan5(int number) {
    return number > 5;
}

   and rewrite the former code using them:
List<Integer> l1 = new ArrayList<Integer>();
for (int n : numbers) {
    if (isEven(n)) l1.add(n);
}

List<Integer> l2 = new ArrayList<Integer>();
for (int n : l1) {
    l2.add(doubleIt(n));
}

List<Integer> l3 = new ArrayList<Integer>();
for (int n : l2) {
    if (isGreaterThan5(n)) l3.add(n);
}

System.out.println(l3.get(0));

   In practice I created a pipeline of list transformations where each stage uses one of the 3 methods
   operating on the single numbers. But is this code better than the former one? Probably no, and for
   two distinct reasons: the first and more obvious one is its verbosity, while the second is that it is
   computationally inefficient because it does more work than what is strictly necessary. To make more
   evident this second issue we can add a println in each of the 3 isEven, doubleIt and isGreaterThan5
   methods, obtaining the following output:
isEven: 1
isEven: 2
isEven: 3
isEven: 4
isEven: 5
isEven: 6
doubleIt: 2
doubleIt: 4
doubleIt: 6
isGreaterThan5: 4
isGreaterThan5: 8
isGreaterThan5: 12
8

   Here we can note that all the 6 numbers in the list get evaluated by our pipeline while the former
   nested for cycle evaluated only the first 4, being the 4th number the first that satisfies all the
   requested conditions.
   Streams can help a lot to fix both this problems. You can create a Stream from any Collection by
   invoking the new stream() method on it. However Streams differ from Collections in several ways:
     * No storage: Streams don't have storage for values; they carry values from a data structure
       through a pipeline of operations.
     * Functional in nature: an operation on a stream produces a result, but does not modify its
       underlying data source. A Collection can be used as a source for a stream.
     * Laziness-seeking: many stream operations, such as filtering, mapping, sorting, or duplicate
       removal can be implemented lazily, meaning we only need to examine as many elements from the
       stream as we need to find the desired answer.
     * Bounds optional: there are many problems that are sensible to express as infinite streams,
       letting clients consume values until they are satisfied. Collections don't let you do this, but
       streams do.

   Using a Stream we can solve the former problem with a single fluent statement:
System.out.println(
    numbers.stream()
            .filter(Lazy::isEven)
            .map(Lazy::doubleIt)
            .filter(Lazy::isGreaterThan5)
            .findFirst()
);

   that produces the following output.
isEven: 1
isEven: 2
doubleIt: 2
isGreaterThan5: 4
isEven: 3
isEven: 4
doubleIt: 4
isGreaterThan5: 8
IntOptional[8]

   Here we can note 2 things. First of all the laziness of the Stream allow us to don't waste CPU cycles
   and evaluate only the first 4 numbers in the List. In fact until, the second filter() invocation and
   before having called findFirst(), the Stream performs absolutely no operations because we haven't
   still asked a result to it. Second the findFirst() method doesn't return 8 but IntOptional[8]. An
   Optional is a wrapper of a value that can potentially doesn't exist at all. In other words in
   functional programming is common to use an Optional (the equivalent of Option in Scala or Maybe in
   Haskell) to model a value that couldn't be there instead of returning a null reference as we are
   traditionally used to do in Object Oriented Java. I already wrote [39]another article where I
   explained in more details how Optional works and pointed out some limitations of the current Java 8
   implementation suggesting an alternative one. In this particular case, since we are sure that there
   is a result, we can safely unwrap the Optional by invoking getAsInt() on it and obtain the result 8
   as expected.

The loan pattern
   To give one last example of how we can leverage functional programming in Java and in particular to
   show how we can achieve better encapsulation and avoid repetitions, let's suppose we have a Resource:
public class Resource {

    public Resource() {
        System.out.println("Opening resource");
    }

    public void operate() {
        System.out.println("Operating on resource");
    }

    public void dispose() {
        System.out.println("Disposing resource");
    }
}

   that we can create, do something on it and, after having used it, we have to dispose in order to
   avoid leaks (of memory, file descriptors, etc.)
Resource resource = new Resource();
resource.operate();
resource.dispose();

   What's wrong with this? Of course the fact that while operating on the resource we could get a
   RuntimeException so, in order to be sure that the dispose() method will be actually called, we have
   to put it in a finally block:
Resource resource = new Resource();
try {
    resource.operate();
} finally {
    resource.dispose();
}

   The problem here is that we will have to repeat this try/finally block again and again every time we
   use the Resource (something that clearly violates the DRY principle) and in case we will forget it in
   some point of our code we will run the risk of having a leak. To fix this issue I suggest to
   encapsulate this try/finally block in a static method of the Resource class and possibly to make its
   constructor private in order to oblige the clients of that class to use it only through that method:
public static void withResource(Consumer<Resource> consumer) {
    Resource resource = new Resource();
    try {
        consumer.accept(resource);
    } finally {
        resource.dispose();
    }
}

   The argument passed to this method is an instance of the Consumer functional interface that allows to
   consume the resource or, in other words, to perform some actions on it. In this way we can operate on
   the resource by just passing a lambda expression to that method:
withResource(resource -> resource.operate());

   It guarantees that the resource will be always disposed correctly avoiding any repetition. Also it
   should be now clearer where the name of this pattern comes from: the "lender" (the code holding the
   resource) manages the resources once the "lendee" (the lambda expression accessing it) has finished
   to use it.


---
https://www.programcreek.com/2014/01/why-lambda-java-8/

Why do we need Lambda in Java?

    +-------------------------------------------------------+
    |   Arrays.sort(dogArray, new Comparator<Dog>() {       |
    |       @Override                                       |
    |       public int compare(Dog o1, Dog o2) {            |
    |           return o1.getWeight() - O2.GERwEIGHT();     |
    |       }                                               |
    |   });                                                 |
    |                                                       |
    +-------------------------------------------------------+
                            |  |                            
                            |  |                            
                           _|  |_                           
                           \    /                           
                            \  /                            
                             \/                             
    +-----------------------------------------------------------------------+
    |                                                Lambda expression      |
    |                         +---------------------------------------+     |
    |   Arrays.sort(dogArray, |(m, n) -> m.getWeight() - n.getWeight()| );  |
    |                         +---------------------------------------+     |
    +-----------------------------------------------------------------------+

   A lambda expression is a block of code that can be passed around to execute. It is a common feature
   for some programming languages, such as Lisp, Python, Scala, etc. But before Java 8, we can not do
   the same in Java. If we want a block of code to be executed, we need to create an object and pass the
   object around, such as using [18]the strategy design pattern. From Java 8, lambda expressions enable
   us to treat functionality as method argument and pass a block of code around. Lambda expressions in
   Java 8 are very powerful and therefore very compelling. In this post, I will use a simple example to
   introduce functional programming in Java 8. This is a part of [19]the series of Java 8 lambdas.

   1. Sorting Before Java 8
   The following example shows how to use a comparator to sort an array of self-defined objects.

   This is the dog class that need to be sorted.
public class Dog {
        String name;
        int height;
        int weight;

        public Dog(String n, int s, int w) {
                this.name = n;
                this.height = s;
                this.weight = w;
        }

        public String toString() {
                return getName() + ": size=" + getHeight() + " weight=" + getWeight()
                                + " \n";
        }

        //setters and getters ...
}

   public class Dog { String name; int height; int weight; public Dog(String n, int s, int w) {
   this.name = n; this.height = s; this.weight = w; } public String toString() { return getName() + ":
   size=" + getHeight() + " weight=" + getWeight() + " \n"; } //setters and getters ... }

   To sort an array of dogs, we can use Arrays.sort(...). The second parameter is a comparator. So we
   need to defined a comparator. This is a typical example of [20]strategy pattern.
import java.util.Arrays;
import java.util.Comparator;
import java.util.stream.Stream;

public class ArraysSort {

        public static void main(String[] args) {
                Dog d1 = new Dog("Max", 2, 50);
                Dog d2 = new Dog("Rocky", 1, 30);
                Dog d3 = new Dog("Bear", 3, 40);

                Dog[] dogArray = { d1, d2, d3 };
                printDogs(dogArray);

                Arrays.sort(dogArray, new Comparator<Dog>() {
                        @Override
                        public int compare(Dog o1, Dog o2) {
                                return o1.getWeight() - o2.getWeight();
                        }
                });
                printDogs(dogArray);
        }

        public static void printDogs(Dog[] dogs) {
                System.out.println("--Dog List--");
                for (Dog d : dogs)
                        System.out.print(d);
                System.out.println();
        }
}

   import java.util.Arrays; import java.util.Comparator; import java.util.stream.Stream; public class
   ArraysSort { public static void main(String[] args) { Dog d1 = new Dog("Max", 2, 50); Dog d2 = new
   Dog("Rocky", 1, 30); Dog d3 = new Dog("Bear", 3, 40); Dog[] dogArray = { d1, d2, d3 };
   printDogs(dogArray); Arrays.sort(dogArray, new Comparator<Dog>() { @Override public int compare(Dog
   o1, Dog o2) { return o1.getWeight() - o2.getWeight(); } }); printDogs(dogArray); } public static void
   printDogs(Dog[] dogs) { System.out.println("--Dog List--"); for (Dog d : dogs) System.out.print(d);
   System.out.println(); } }

   2. Sorting with Java 8 Lambdas Expression
   In Java 8, we can do sorting in one simple line of code like this:
Arrays.sort(dogArray, (Dog m, Dog n) -> m.getWeight() - n.getWeight());
printDogs(dogArray);

   Arrays.sort(dogArray, (Dog m, Dog n) -> m.getWeight() - n.getWeight()); printDogs(dogArray);

   (Dog m, Dog n) -> Integer.compare(m.getWeight(), n.getWeight()) is a lambda expression. It is
   converted to an object of Comparator behind the scene. For now let's simply consider the lambda
   expression as a function. How lambda expressions are converted to objects of functional interfaces is
   a more complicated story.

   3. Syntax of Lambda Expression
   The syntax of a lambda expression consists of the following:
    1. A comma-separated list of formal parameters enclosed in parentheses. In this case, it is (Dog m,
       Dog n)
    2. The arrow token ->
    3. A body, which consists of a single expression or a statement block. In this case, it is one
       single expression - Integer.compare(m.getWeight(), n.getWeight())

   We can also write the lambda expression in [21]other different ways.

   4. Stream API
   When we motivate why functional programming is so powerful in Java 8, the Stream API should be
   emphasized. A stream in Java 8 is a sequence of elements supporting sequential and parallel aggregate
   operations. By using streams, we can simply pass a block of code to the stream and apply the function
   to each element in the stream.

   To sort the dog array above, we can also utilize the Stream API:
import java.util.stream.Stream;

public class Java8WhyLambda {
        public static void main(String[] args) {
                // create an array of dogs
                Dog d1 = new Dog("Max", 2, 50);
                Dog d2 = new Dog("Rocky", 1, 30);
                Dog d3 = new Dog("Bear", 3, 40);
                Dog[] dogArray = { d1, d2, d3 };

                // use stream to sort
                Stream<Dog> dogStream = Stream.of(dogArray);
                Stream<Dog> sortedDogStream = dogStream.sorted((Dog m, Dog n) -> Integer.compare(m.getHeight(), n.getHeight()));

                sortedDogStream.forEach(d -> System.out.print(d));
        }
}

   import java.util.stream.Stream; public class Java8WhyLambda { public static void main(String[] args)
   { // create an array of dogs Dog d1 = new Dog("Max", 2, 50); Dog d2 = new Dog("Rocky", 1, 30); Dog d3
   = new Dog("Bear", 3, 40); Dog[] dogArray = { d1, d2, d3 }; // use stream to sort Stream<Dog>
   dogStream = Stream.of(dogArray); Stream<Dog> sortedDogStream = dogStream.sorted((Dog m, Dog n) ->
   Integer.compare(m.getHeight(), n.getHeight())); sortedDogStream.forEach(d -> System.out.print(d)); }
   }


---
https://www.drdobbs.com/jvm/lambda-expressions-in-java-8/240166764

Lambda Expressions in Java 8 - page 1
March 25, 2014

   The single most important change in Java 8 enables faster, clearer coding and opens the door to
   functional programming. Here's how it works.

   Java was designed in the 1990s as an object-oriented programming language, when object-oriented
   programming was the principal paradigm for software development. Long before there was
   object-oriented programming, there were functional programming languages such as Lisp and Scheme, but
   their benefits were not much appreciated outside academic circles. Recently, functional programming
   has risen in importance because it is well suited for concurrent and event-driven (or "reactive")
   programming. That doesn't mean that object orientation is bad. Instead, the winning strategy is to
   blend object-oriented and functional programming. This makes sense even if you are not interested in
   concurrency. For example, collection libraries can be given powerful APIs if the language has a
   convenient syntax for functional expressions.

   The principal enhancement in Java 8 is the addition of functional programming constructs to its
   object-oriented roots. In this article, I demonstrate the basic syntax and examine how to use it
   several important contexts. The key points are:
     * A lambda expression is a block of code with parameters.
     * Use a lambda expression whenever you want a block of code executed at a later point in time.
     * Lambda expressions can be converted to functional interfaces.
     * Lambda expressions can access effectively final variables from the enclosing scope.
     * Method and constructor references refer to methods or constructors without invoking them.
     * You can now add default and static methods to interfaces that provide concrete implementations.
     * You must resolve any conflicts between default methods from multiple interfaces.

Why Lambdas?
   A lambda expression is a block of code that you can pass around so it can be executed later, just
   once or multiple times. Before getting into the syntax (or even the curious name), let's step back
   and see where you have used similar code blocks in Java all along.

   When you want to do work in a separate thread, you put the work into the run method of a Runnable,
   like this:

class Worker implements Runnable {
     public void run() {
        for (int i = 0; i < 1000; i++)
           doWork();
     }
     ...
  }

   Then, when you want to execute this code, you construct an instance of the Worker class. You can then
   submit the instance to a thread pool, or keep it simple and start a new thread:

Worker w = new Worker();
  new Thread(w).start();

   The key point is that the run method contains code that you want to execute in a separate thread.

   Consider sorting with a custom comparator. If you want to sort strings by length instead of the
   default dictionary order, you can pass a Comparator object to the sort method:

class LengthComparator implements Comparator<String> {
     public int compare(String first, String second) {
        return Integer.compare(first.length(), second.length());
     }
  }

Arrays.sort(strings, new LengthComparator());

   The sort method keeps calling the compare method, rearranging the elements if they are out of order,
   until the array is sorted. You give the sort method a snippet of code needed to compare elements, and
   that code is integrated into the rest of the sorting logic, which you'd probably not care to
   reimplement. Note that the call Integer.compare(x, y) returns zero if x and y are equal, a negative
   number if x < y, and a positive number if  x > y. This static method was added to Java 7. You
   shouldn't compute x - y to compare x and y because that computation can overflow for large operands
   of opposite sign.

   As another example for deferred execution, consider a button callback. You put the callback action
   into a method of a class implementing the listener interface, construct an instance, and register the
   instance with the button. That happens so often that many programmers use the "anonymous instance of
   anonymous class" syntax:

button.setOnAction(new EventHandler<ActionEvent>() {
     public void handle(ActionEvent event) {
        System.out.println("Thanks for clicking!");
     }
  });

   What matters is the code inside the handle method. That code is executed whenever the button is
   clicked.

   Since Java 8 positions JavaFX as the successor to the Swing GUI toolkit, I use JavaFX in these
   examples. (See [52]Eric Bruno's posts for more information on JavaFX. - Ed.) The details don't
   matter. In every user interface toolkit, be it Swing, JavaFX, or Android, you give a button some code
   that you want to run when the button is clicked.

   In all three examples, you saw the same approach. A block of code was passed to someone - a thread
   pool, a sort method, or a button. The code was called at some later time.

   Up to now, giving someone a block of code hasn't been easy in Java. You couldn't just pass code
   blocks around. Java is an object-oriented language, so you had to construct an object belonging to a
   class that has a method with the desired code.

   In other languages, it is possible to work with blocks of code directly. The Java designers have
   resisted adding this feature for a long time. After all, a great strength of Java is its simplicity
   and consistency. A language can become an unmaintainable mess if it includes every feature that
   yields marginally more-concise code. However, in those other languages, it isn't just easier to spawn
   a thread or to register a button-click handler; large swaths of their APIs are simpler, more
   consistent, and more powerful. In Java, one could have written similar APIs that take objects of
   classes implementing a particular function, but such APIs would be unpleasant to use.

   For some time now, the question was not whether to augment Java for functional programming, but how
   to do it. It took several years of experimentation before a design emerged that is a good fit for
   Java. In the next section, you will see how you can work with blocks of code in Java 8.

The Syntax of Lambda Expressions
   Consider the previous sorting example again. We pass code that checks whether one string is shorter
   than another. We compute

Integer.compare(first.length(), second.length())

   What are first and second? They are both strings! Java is a strongly typed language, and we must
   specify that as well:

(String first, String second)
     -> Integer.compare(first.length(), second.length())

   You have just seen your first lambda expression! Such an expression is simply a block of code,
   together with the specification of any variables that must be passed to the code.

   Why the name? Many years ago, before there were any computers, the logician Alonzo Church wanted to
   formalize what it means for a mathematical function to be effectively computable. (Curiously, there
   are functions that are known to exist, but nobody knows how to compute their values.) He used the
   Greek letter lambda (λ) to mark parameters. Had he known about the Java API, he would have written:

λfirst.λsecond.Integer.compare(first.length(), second.length())

   Why the letter λ? Did Church run out of other letters of the alphabet? Actually, the venerable
   Principia Mathematica used the ˆ accent to denote free variables, which inspired Church to use an
   uppercase lambda (Λ) for parameters. But in the end, he switched to the lowercase version. Ever
   since, an expression with parameter variables has been called a "lambda expression."


---
https://www.drdobbs.com/jvm/lambda-expressions-in-java-8/240166764?pgno=2

Lambda Expressions in Java 8 - page 2

   The single most important change in Java 8 enables faster, clearer coding and opens the door to
   functional programming. Here's how it works.

   You have just seen one form of lambda expressions in Java: parameters, the -> arrow, and an
   expression. If the code carries out a computation that doesn't fit in a single expression, write it
   exactly like you would have written a method: enclosed in {} and with explicit return statements. For
   example,

(String first, String second) -> {
     if (first.length() < second.length()) return -1;
     else if (first.length() > second.length()) return 1;
     else return 0;
  }

   If a lambda expression has no parameters, you still supply empty parentheses, just as with a
   parameterless method:

() -> { for (int i = 0; i < 1000; i++) doWork(); }

   If the parameter types of a lambda expression can be inferred, you can omit them. For example,

Comparator<String> comp
     = (first, second) // Same as (String first, String second)
        -> Integer.compare(first.length(), second.length());

   Here, the compiler can deduce that first and second must be strings because the lambda expression is
   assigned to a string comparator. (We will have a closer look at this assignment later.)

   If a method has a single parameter with inferred type, you can even omit the parentheses:

EventHandler<ActionEvent> listener = event ->
     System.out.println("Thanks for clicking!");
        // Instead of (event) -> or (ActionEvent event) ->

   You can add annotations or the final modifier to lambda parameters in the same way as for method
   parameters:

(final String name) -> ...
    (@NonNull String name) -> ...

   You never specify the result type of a lambda expression. It is always inferred from context. For
   example, the expression

(String first, String second) -> Integer.compare(first.length(), second.length())

   can be used in a context where a result of type int is expected.

   Note that it is illegal for a lambda expression to return a value in some branches but not in others.
   For example, (int x) -> { if (x >= 0) return 1; } is invalid.

Functional Interfaces
   As we discussed, there are many existing interfaces in Java that encapsulate blocks of code, such as
   Runnable or Comparator. Lambdas are backwards compatible with these interfaces.

   You can supply a lambda expression whenever an object of an interface with a single abstract method
   is expected. Such an interface is called a functional interface.

   You may wonder why a functional interface must have a single abstract method. Aren't all methods in
   an interface abstract? Actually, it has always been possible for an interface to redeclare methods
   from the Object class such as toString or clone, and these declarations do not make the methods
   abstract. (Some interfaces in the Java API redeclare Object methods in order to attach javadoc
   comments. Check out the Comparator API for an example.) More importantly, as you will see shortly, in
   Java 8, interfaces can declare non-abstract methods.

   To demonstrate the conversion to a functional interface, consider the Arrays.sort method. Its second
   parameter requires an instance of Comparator, an interface with a single method. Simply supply a
   lambda:

Arrays.sort(words,
     (first, second) -> Integer.compare(first.length(), second.length()));

   Behind the scenes, the Arrays.sort method receives an object of some class that implements
   Comparator<String>. Invoking the compare method on that object executes the body of the lambda
   expression. The management of these objects and classes is completely implementation dependent, and
   it can be much more efficient than using traditional inner classes. It is best to think of a lambda
   expression as a function, not an object, and to accept that it can be passed to a functional
   interface.

   This conversion to interfaces is what makes lambda expressions so compelling. The syntax is short and
   simple. Here is another example:

button.setOnAction(event ->
     System.out.println("Thanks for clicking!"));

   That's awfully easy to read.

   In fact, conversion to a functional interface is the only thing that you can do with a lambda
   expression in Java. In other programming languages that support function literals, you can declare
   function types such as (String, String) -> int, declare variables of those types, and use the
   variables to save function expressions. In Java, you can't even assign a lambda expression to a
   variable of type Object because Objectis not a functional interface. The Java designers decided to
   stick strictly with the familiar concept of interfaces instead of adding function types to the
   language.

   The Java API defines several generic functional interfaces in the java.util.function package. One of
   the interfaces, BiFunction<T, U, R>, describes functions with parameter types T and U and return type
   R. You can save our string comparison lambda in a variable of that type:

BiFunction<String, String, Integer> comp
     = (first, second) -> Integer.compare(first.length(), second.length());

   However, that does not help you with sorting. There is no Arrays.sort method that wants a BiFunction.
   If you have used a functional programming language before, you may find this curious. But for Java
   programmers, it's pretty natural. An interface such as Comparator has a specific purpose, not just a
   method with given parameter and return types. Java 8 retains this flavor. When you want to do
   something with lambda expressions, you still want to keep the purpose of the expression in mind, and
   have a specific functional interface for it.

   The interfaces in java.util.function are used in several Java 8 APIs, and you will likely see them
   elsewhere in the future. But keep in mind that you can equally well convert a lambda expression into
   a functional interface that is a part of whatever API you use today. Also, you can tag any functional
   interface with the @FunctionalInterface annotation. This has two advantages. The compiler checks that
   the annotated entity is an interface with a single abstract method. And the javadoc page includes a
   statement that your interface is a functional interface. You are not required to use the annotation.
   Any interface with a single abstract method is, by definition, a functional interface. But using the
   @FunctionalInterface annotation is a good idea.

   Finally, note that checked exceptions matter when a lambda is converted to an instance of a
   functional interface. If the body of a lambda expression can throw a checked exception, that
   exception needs to be declared in the abstract method of the target interface. For example, the
   following would be an error:

Runnable sleeper = () -> { System.out.println("Zzz"); Thread.sleep(1000); };
    // Error: Thread.sleep can throw a checkedInterruptedException

   Because the Runnable.run cannot throw any exception, this assignment is illegal. To fix the error,
   you have two choices. You can catch the exception in the body of the lambda expression. Or you can
   assign the lambda to an interface whose single abstract method can throw the exception. For example,
   the call method of the Callable interface can throw any exception. Therefore, you can assign the
   lambda to a Callable<Void> (if you add a statement return null).

Method References
   Sometimes, there is already a method that carries out exactly the action that you'd like to pass on
   to some other code. For example, suppose you simply want to print the event object whenever a button
   is clicked. Of course, you could call

button.setOnAction(event -> System.out.println(event));

   It would be nicer if you could just pass the println method to the setOnAction method. Here is how
   you do that:

button.setOnAction(System.out::println);

   The expression System.out::println is a method reference that is equivalent to the lambda expression
   x -> System.out.println(x).

   As another example, suppose you want to sort strings regardless of letter case. You can pass this
   method expression:

Arrays.sort(strings, String::compareToIgnoreCase)

   As you can see from these examples, the :: operator separates the method name from the name of an
   object or class. There are three principal cases:
     * object::instanceMethod
     * Class::staticMethod
     * Class::instanceMethod

   In the first two cases, the method reference is equivalent to a lambda expression that supplies the
   parameters of the method. As already mentioned, System.out::println is equivalent to x ->
   System.out.println(x). Similarly, Math::pow is equivalent to (x, y) -> Math.pow(x, y). In the third
   case, the first parameter becomes the target of the method. For example, String::compareToIgnoreCase
   is the same as (x, y) -> x.compareToIgnoreCase(y).

   When there are multiple overloaded methods with the same name, the compiler will try to find from the
   context which one you mean. For example, there are two versions of the Math.max method, one for
   integers and one for double values. Which one gets picked depends on the method parameters of the
   functional interface to which Math::max is converted. Just like lambda expressions, method references
   don't live in isolation. They are always turned into instances of functional interfaces.

   You can capture the this parameter in a method reference. For example, this::equals is the same as x
   -> this.equals(x). It is also valid to use super. The method expression super::instanceMethod uses
   this as the target and invokes the superclass version of the given method. Here is an artificial
   example that shows the mechanics:

class Greeter {
     public void greet() {
        System.out.println("Hello, world!");
     }
  }

  class ConcurrentGreeter extends Greeter {
     public void greet() {
        Thread t = new Thread(super::greet);
        t.start();
     }
  }

   When the thread starts, its Runnable is invoked, and super::greet is executed, calling the greet
   method of the superclass. (Note that in an inner class, you can capture the this reference of an
   enclosing class as EnclosingClass.this::method or EnclosingClass.super::method.)

Constructor References
   Constructor references are just like method references, except that the name of the method is new.
   For example, Button::new is a reference to a Button constructor. Which constructor? It depends on the
   context. Suppose you have a list of strings. Then, you can turn it into an array of buttons, by
   calling the constructor on each of the strings, with the following invocation:

List<String> labels = ...;
  Stream<Button> stream = labels.stream().map(Button::new);
  List<Button> buttons = stream.collect(Collectors.toList());

   Details of the stream, map, and collect methods are beyond the scope of this article. For now, what's
   important is that the map method calls the Button(String) constructor for each list element. There
   are multiple Buttonconstructors, but the compiler picks the one with a String parameter because it
   infers from the context that the constructor is called with a string.

   You can form constructor references with array types. For example, int[]::new is a constructor
   reference with one parameter: the length of the array. It is equivalent to the lambda expression x ->
   new int[x].

   Array constructor references are useful to overcome a limitation of Java. It is not possible to
   construct an array of a generic type T. The expression new T[n] is an error since it would be erased
   to new Object[n]. That is a problem for library authors. For example, suppose we want to have an
   array of buttons. The Stream interface has a toArray method that returns an Object array:

Object[] buttons = stream.toArray();

   But that is unsatisfactory. The user wants an array of buttons, not objects. The stream library
   solves that problem with constructor references. Pass Button[]::new to the toArray method:

Button[] buttons = stream.toArray(Button[]::new);

   The toArray method invokes this constructor to obtain an array of the correct type. Then it fills and
   returns the array.


---
https://www.drdobbs.com/jvm/lambda-expressions-in-java-8/240166764?pgno=3

Lambda Expressions in Java 8 - page 3

   The single most important change in Java 8 enables faster, clearer coding and opens the door to
   functional programming. Here's how it works.

Variable Scope

   Often, you want to be able to access variables from an enclosing method or class in a lambda
   expression. Consider this example:

public static void repeatMessage(String text, int count) {
     Runnable r = () -> {
        for (int i = 0; i < count; i++) {
           System.out.println(text);
           Thread.yield();
        }
     };
     new Thread(r).start();
  }

   Consider a call:

repeatMessage("Hello", 1000); // Prints Hello 1,000 times in a separate thread

   Now look at the variables count and text inside the lambda expression. Note that these variables are
   not defined in the lambda expression. Instead, these are parameter variables of the repeatMessage
   method.

   If you think about it, something not obvious is going on here. The code of the lambda expression may
   run long after the call to repeatMessagehas returned and the parameter variables are gone. How do the
   text and count variables stay around?

   To understand what is happening, we need to refine our understanding of a lambda expression. A lambda
   expression has three ingredients:
    1. A block of code
    2. Parameters
    3. Values for the free variables; that is, the variables that are not parameters and not defined
       inside the code

   In our example, the lambda expression has two free variables, text and count. The data structure
   representing the lambda expression must store the values for these variables, in our case, "Hello"
   and 1000. We say that these values have been captured by the lambda expression. (It's an
   implementation detail how that is done. For example, one can translate a lambda expression into an
   object with a single method, so that the values of the free variables are copied into instance
   variables of that object.)

   The technical term for a block of code together with the values of the free variables is a closure.
   If someone gloats that their language has closures, rest assured that Java has them as well. In Java,
   lambda expressions are closures. In fact, inner classes have been closures all along. Java 8 gives us
   closures with an attractive syntax.

   As you have seen, a lambda expression can capture the value of a variable in the enclosing scope. In
   Java, to ensure that the captured value is well defined, there is an important restriction. In a
   lambda expression, you can only reference variables whose value doesn't change. For example, the
   following is illegal:

public static void repeatMessage(String text, int count) {
     Runnable r = () -> {
        while (count > 0) {
           count--; // Error: Can't mutate captured variable
           System.out.println(text);
           Thread.yield();
        }
     };
     new Thread(r).start();
  }

   There is a reason for this restriction. Mutating variables in a lambda expression is not thread-safe.
   Consider a sequence of concurrent tasks, each updating a shared counter.

int matches = 0;
  for (Path p : files)
     new Thread(() -> { if (p has some property) matches++; }).start();
        // Illegal to mutate matches

   If this code were legal, it would be very, very bad. The increment matches++ is not atomic, and there
   is no way of knowing what would happen if multiple threads execute that increment concurrently.

   Inner classes can also capture values from an enclosing scope. Before Java 8, inner classes were
   allowed to access only final local variables. This rule has now been relaxed to match that for lambda
   expressions. An inner class can access any effectively final local variable; that is, any variable
   whose value does not change.

   Don't count on the compiler to catch all concurrent access errors. The prohibition against mutation
   holds only for local variables. If matchesis an instance or static variable of an enclosing class,
   then no error is reported, even though the result is just as undefined.

   Also, it's perfectly legal to mutate a shared object, even though it is unsound. For example,

List<Path> matches = new ArrayList<>();
  for (Path p : files)
     new Thread(() -> { if (p has some property) matches.add(p); }).start();
        // Legal to mutate matches, but unsafe

   Note that the variable matches is effectively final. (An effectively final variable is a variable
   that is never assigned a new value after it has been initialized.) In our case, matches always refers
   to the same ArrayList object. However, the object is mutated, and that is not thread-safe. If
   multiple threads call add, the result is unpredictable.

   There are safe mechanisms for counting and collecting values concurrently. You may want to use
   streams to collect values with certain properties. In other situations, you may want to use
   thread-safe counters and collections.

   As with inner classes, there is an escape hatch that lets a lambda expression update a counter in an
   enclosing local scope. Use an array of length 1, like this:

  int[] counter = new int[1];
    button.setOnAction(event -> counter[0]++);

   Of course, code like this is not thread-safe. For a button callback, that doesn't matter, but in
   general, you should think twice before using this trick.

   The body of a lambda expression has the same scope as a nested block. The same rules for name
   conflicts and shadowing apply. It is illegal to declare a parameter or a local variable in the lambda
   that has the same name as a local variable.

Path first = Paths.get("/usr/bin");
  Comparator<String> comp =
     (first, second) -> Integer.compare(first.length(), second.length());
     // Error: Variable first already defined

   Inside a method, you can't have two local variables with the same name. Therefore, you can't
   introduce such variables in a lambda expression either. When you use the this keyword in a lambda
   expression, you refer to the this parameter of the method that creates the lambda. For example,
   consider

public class Application() {
     public void doWork() {
        Runnable runner = () -> { ...; System.out.println(this.toString()); ... };
        ...
     }
  }

   The expression this.toString() calls the toString method of the Application object, not the Runnable
   instance. There is nothing special about the use of this in a lambda expression. The scope of the
   lambda expression is nested inside the doWork method, and this has the same meaning anywhere in that
   method.

Default Methods
   Many programming languages integrate function expressions with their collections library. This often
   leads to code that is shorter and easier to understand than the loop equivalent. For example,
   consider a loop:

for (int i = 0; i < list.size(); i++)
     System.out.println(list.get(i));

   There is a better way. The library designers can supply a forEach method that applies a function to
   each element. Then you can simply call

list.forEach(System.out::println);

   That's fine if the collections library has been designed from the ground up. But the Java collections
   library was designed many years ago, and there is a problem. If the Collection interface gets new
   methods, such as forEach, then every program that defines its own class implementing Collection will
   break until it, too, implements that method. That is simply unacceptable in Java.

   The Java designers decided to solve this problem once and for all by allowing interface methods with
   concrete implementations (called default methods). Those methods can be safely added to existing
   interfaces. In this section, we'll look at default methods in detail. In Java 8, the forEach method
   has been added to the Iterable interface, a superinterface of Collection, using the mechanism that I
   will describe here.

   Consider this interface:

interface Person {
     long getId();
     default String getName() { return "John Q. Public"; }
  }

   The interface has two methods: getId, which is an abstract method, and the default method getName. A
   concrete class that implements the Person interface must, of course, provide an implementation of
   getId, but it can choose to keep the implementation of getName or to override it.

   Default methods put an end to the classic pattern of providing an interface and an abstract class
   that implements most or all of its methods, such as Collection/AbstractCollection or
   WindowListener/WindowAdapter. Now, you can just implement the methods in the interface.

   What happens if the exact same method is defined as a default method in one interface and then again
   as a method of a superclass or another interface? Languages such as Scala and C++ have complex rules
   for resolving such ambiguities. Fortunately, the rules in Java are much simpler. They are:

    1. Superclasses win. If a superclass provides a concrete method, default methods with the same name
       and parameter types are simply ignored.
    2. Interfaces clash. If a super interface provides a default method, and another interface supplies
       a method with the same name and parameter types (default or not), then you must resolve the
       conflict by overriding that method.

   Let's look at the second rule. Consider another interface with a getName method:

interface Named {
     default String getName() { return getClass().getName() + "_" + hashCode(); }
  }

   What happens if you form a class that implements both of them?

class Student implements Person, Named {
     ...
  }

   The class inherits two inconsistent getName methods provided by the Person and Named interfaces.
   Rather than choosing one over the other, the Java compiler reports an error and leaves it up to the
   programmer to resolve the ambiguity. Simply provide a getName method in the Student class. In that
   method, you can choose one of the two conflicting methods, like this:

class Student implements Person, Named {
     public String getName() { returnPerson.super.getName(); }
     ...
  }

   Now assume that the Named interface does not provide a default implementation for getName:

interface Named {
     String getName();
  }

   Can the Student class inherit the default method from the Person interface? This might be reasonable,
   but the Java designers decided in favor of uniformity. It doesn't matter how two interfaces conflict.
   If at least one interface provides an implementation, the compiler reports an error, and the
   programmer must resolve the ambiguity.

   If neither interface provides a default for a shared method, then we are in the pre-Java 8 situation
   and there is no conflict. An implementing class has two choices: implement the method, or leave it
   unimplemented. In the latter case, the class is itself abstract.

   I just discussed name clashes between two interfaces. Now consider a class that extends a superclass
   and implements an interface, inheriting the same method from both. For example, suppose that Person
   is a class and Student is defined as:

class Student extends Person implements Named { ... }

   In that case, only the superclass method matters, and any default method from the interface is simply
   ignored. In our example, Student inherits the getName method from Person, and it doesn't make any
   difference whether the Named interface provides a default for getName or not. This is the "class
   wins" rule. The "class wins" rule ensures compatibility with Java 7. If you add default methods to an
   interface, it has no effect on code that worked before there were default methods. But be warned: You
   can never make a default method that redefines one of the methods in the Object class. For example,
   you can't define a default method for toString or equals, even though that might be attractive for
   interfaces such as List. As a consequence of the "classes win" rule, such a method could never win
   against Object.toString or Object.equals.

Static Methods in Interfaces
   As of Java 8, you are allowed to add static methods to interfaces. There was never a technical reason
   why this should be outlawed: It simply seemed to be against the spirit of interfaces as abstract
   specifications.

   Until now, it has been common to place static methods in companion classes. You find pairs of
   interfaces and utility classes such as Collection/Collections or Path/Paths in the standard library.

   Have a look at the Paths class. It has only a couple of factory methods. You can construct a path
   from a sequence of strings, such as Paths.get("jdk1.8.0", "jre", "bin"). In Java 8, you can add this
   method to the Path interface:

public interface Path {
     public static Path get(String first, String... more) {
        return FileSystems.getDefault().getPath(first, more);
     }
     ...
  }

   Then the Paths class is no longer necessary.

   When you look at the Collections class, you will find two kinds of methods. A method such as:

public static void shuffle(List<?> list)

   would work well as a default method of the List interface:

public default void shuffle()

   You could then simply call list.shuffle() on any list.

   For a factory method, that doesn't work because you don't have an object on which to invoke the
   method. That is where static interface methods come in. For example,

public static <T> List<T> nCopies(int n, T o)
     // Constructs a list of n instances of o

   could be a static method of the List interface. Then you would call List.nCopies(10, "Fred") instead
   of Collections.nCopies(10, "Fred") and it would be clear to the reader that the result is a List.

   It is unlikely that the Java collections library will be refactored in this way, but when you
   implement your own interfaces, there is no longer a reason to provide a separate companion class for
   utility methods.

   In Java 8, static methods have been added to quite a few interfaces. For example, the Comparator
   interface has a very useful static comparing method that accepts a "key extraction" function and
   yields a comparator that compares the extracted keys. To compare Person objects by name, use
   Comparator.comparing(Person::name).

Conclusion
   In this article, I compared strings by length with the lambda expression (first, second) ->
   Integer.compare(first.length(), second.length()). But with the static compare method, we can do much
   better and simply use Comparator.compare(String::length). This is a fitting way of closing this
   article because it demonstrates the power of working with functions. The compare method turns a
   function (the key extractor) into a more complex function (the key-based comparator). Such
   "higher-order functions" are discussed in more detail in [52]my book, as well as in various online
   resources for Java 8.


---
