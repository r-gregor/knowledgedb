filename: jv_working-with-hashcode-and-equals-multif_20210923.txt
https://dzone.com/articles/working-with-hashcode-and-equals-in-java

Working With hashcode() and equals()
Jan. 02, 18

Need to implement your own custom equality-checking mechanism? Here are some tips for when you need to
override hashcode() and equals().

   By default, the Java super class java.lang.Object provides two important methods for comparing
   objects: equals() and hashcode(). These methods become very useful when implementing interactions
   between several classes in large projects. In this article, we will talk about the relationship
   between these methods, their default implementations, and the circumstances that force developers to
   provide a custom implementation for each of them.

Method Definition and Default Implementation
	* equals(Object obj): a method provided by java.lang.Object that indicates whether some other
	  object passed as an argument is "equal to" the current instance. The default implementation
	  provided by the JDK is based on memory location - two objects are equal if and only if they are
	  stored in the same memory address.
	* hashcode(): a method provided by java.lang.Object that returns an integer representation of the
	  object memory address. By default, this method returns a random integer that is unique for each
	  instance. This integer might change between several executions of the application and won't stay
	  the same.

The Contract Between equals() and hashcode()
   The default implementation is not enough to satisfy business needs, especially if we're talking about
   a huge application that considers two objects as equal when some business fact happens. In some
   business scenarios, developers provide their own implementation in order to force their own equality
   mechanism regardless the memory addresses.

   As per the Java documentation, developers should override both methods in order to achieve a fully
   working equality mechanism - it's not enough to just implement the equals() method.

	 If two objects are equal according to the equals(Object) method, then calling the hashcode()
	 method on each of the two objects must produce the same integer result.

   In the following sections, we provide several examples that show the importance of overriding both
   methods and the drawbacks of overriding equals() without hashcode().

Practical Example
   We define a class called Student as the following:
<code>
package com.programmer.gate.beans;

public class Student {

	private int id;
	private String name;

	public Student(int id, String name) {
		this.name = name;
		this.id = id;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}
</code>

   For testing purposes, we define a main class HashcodeEquals that checks whether two instances of
   Student (who have the exact same attributes) are considered as equal.
public class HashcodeEquals {

	public static void main(String[] args) {
		Student alex1 = new Student(1, "Alex");
		Student alex2 = new Student(1, "Alex");

		System.out.println("alex1 hashcode = " + alex1.hashCode());
		System.out.println("alex2 hashcode = " + alex2.hashCode());
		System.out.println("Checking equality between alex1 and alex2 = " + alex1.equals(alex2));
	}
}

   Output:
alex1 hashcode = 1852704110
alex2 hashcode = 2032578917
Checking equality between alex1 and alex2 = false

   Although the two instances have exactly the same attribute values, they are stored in different
   memory locations. Hence, they are not considered equal as per the default implementation of
   equals(). The same applies for hashcode() - a random unique code is generated for each instance.

Overriding equals()
   For business purposes, we consider that two students are equal if they have the same ID, so we
   override the equals() method and provide our own implementation as the following:
@Override
public boolean equals(Object obj) {
	if (obj == null) return false;
	if (!(obj instanceof Student))
		return false;
	if (obj == this)
		return true;
	return this.getId() == ((Student) obj).getId();
}

   In the above implementation, we are saying that two students are equal if and only if they are stored
   in the same memory address OR they have the same ID. Now if we try to run HashcodeEquals, we will get
   the following output:
alex1 hashcode = 2032578917
alex2 hashcode = 1531485190
Checking equality between alex1 and alex2 = true

   As you noticed, overriding equals() with our custom business forces Java to consider the ID attribute
   when comparing two Student objects.

equals() With ArrayList
   A very popular usage of equals()  is defining an array list of Student and searching for a particular
   student inside it. So we modified our testing class in order the achieve this.
public class HashcodeEquals {

	public static void main(String[] args) {
		Student alex = new Student(1, "Alex");

		List < Student > studentsLst = new ArrayList < Student > ();
		studentsLst.add(alex);

		System.out.println("Arraylist size = " + studentsLst.size());
		System.out.println("Arraylist contains Alex = " + studentsLst.contains(new Student(1, "Alex")));
	}
}

   After running the above test, we get the following output:
Arraylist size = 1
Arraylist contains Alex = true

Overriding hashcode()
   Okay, so we override equals() and we get the expected behavior - even though the hash code of the two
   objects are different. So, what's the purpose of overriding hashcode()?

equals() With HashSet
   Let's consider a new test scenario. We want to store all the students in a HashSet, so we update
   HashcodeEquals as the following:
public class HashcodeEquals {

	public static void main(String[] args) {
		Student alex1 = new Student(1, "Alex");
		Student alex2 = new Student(1, "Alex");

		HashSet < Student > students = new HashSet < Student > ();
		students.add(alex1);
		students.add(alex2);

		System.out.println("HashSet size = " + students.size());
		System.out.println("HashSet contains Alex = " + students.contains(new Student(1, "Alex")));
	}
}

   If we run the above test, we get the following output:
HashSet size = 2
HashSet contains Alex = false

   WAIT!! We already override equals() and verify that alex1 and alex2 are equal, and we all know that
   HashSet stores unique objects, so why did it consider them as different objects ?

   HashSet stores its elements in memory buckets. Each bucket is linked to a particular hash code. When
   calling students.add(alex1), Java stores alex1 inside a bucket and links it to the value of
   alex1.hashcode(). Now any time an element with the same hash code is inserted into the set, it will
   just replace alex1. However, since alex2 has a different hash code, it will be stored in a separate
   bucket and will be considered a totally different object.

   Now when HashSet searches for an element inside it, it first generates the element's hash code and
   looks for a bucket which corresponds to this hash code.

   Here comes the importance of overriding hashcode(), so let's override it in Student and set it to be
   equal to the ID so that students who have the same ID are stored in the same bucket:
@Override
public int hashCode() {
	return id;
}

   Now if we try to run the same test, we get the following output:
HashSet size = 1
HashSet contains Alex = true

   See the magic of hashcode()! The two elements are now considered as equal and stored in the same
   memory bucket, so any time you call contains() and pass a student object holding the same hash code,
   the set will be able to find the element.

   The same is applied for HashMap, HashTable, or any data structure that uses a hashing mechanism for
   storing elements.

Conclusion
   In order to achieve a fully working custom equality mechanism, it is mandatory to override
   hashcode() each time you override equals(). Follow the tips below and you'll never have leaks in your
   custom equality mechanism:
	 * If two objects are equal, they MUST have the same hash code.
	 * If two objects have the same hash code, it doesn't mean that they are equal.
	 * Overriding equals() alone will make your business fail with hashing data structures like:
	   HashSet, HashMap, HashTable ... etc.
	 * Overriding hashcode() alone doesn't force Java to ignore memory addresses when comparing
	   two objects.



---
https://stackoverflow.com/questions/14648175/implementation-of-hashcode-for-custom-class-in-java

Implementation of Hashcode for custom class in Java [duplicate]

   I am supposed to implement hashcode and equals for Custom class Person. Person consists of

	 firstname

	 lastname

   I am supposed to implement equals and hashcode such that two people with firstname and lastname
   should return true for equals and should be accepted by Hashmap. I have implemented Person class like
   this:
<code>
public class Person {

	String firstname;
	String lastname;
	public Person(String firstname, String lastname) {
		this.firstname = firstname;
		this.lastname = lastname;
	}

	@Override
	public int hashCode() {
		// TODO Auto-generated method stub
		return firstname.hashCode()+lastname.hashCode();
	}

	@Override
	public boolean equals(Object obj) {
		// TODO Auto-generated method stub
	Person u=(Person) obj;

		return u.firstname.equals(firstname) && u.lastname.equals(lastname);
	}
}
</code>

   Is the implementation of Hashcode correct here? Even though I am getting the expected result,I want
   to know if this implementation is correct?

***
	   if either firstname or lastname is null your code will not work
	 * Also, equals method returns true only if firstname and lastname are equal and not null.
	 * In terms of hashCode, we will say if it's good or bad instead of correct or wrong. Good
	   hashCode() means there is less chance of conflict in a hashmap.

***
   There is a slight problem with your equals method because it will throw an exception if obj is null
   or not a Person, so you should add the following to the top of your equals:
if(obj==null || !(obj instanceof Person))
   return false;

***
	 * It is only person object only that can call this method right?
	 * 1
	   The argument to the method might not be a person. Imagine what happens if someone does new
	   Person().equals("My string");
	 * gotcha, many thanks!!, I should have thought of that.
	 * 2
	   (null instanceof Person) is always false, and (obj instanceof Person)==false is the same as !(obj
	   instanceof Person). Therefore your code can be simplified to: if (!(obj instanceof Person))
	   return false;
	 * @Tobias or simply return (obj instanceof Person && this.hashCode() == obj.hashCode());

***
	 Whenever a.equals(b), then a.hashCode() must be same as b.hashCode()

   This is the only rule that matters. There is no correct implementation of a hashCode besides this one
   rule. There are better and worse hash codes in terms of performance and hash collisions, but that's
   another topic altogether.

   Your code appears to be correct according to that rule, because if a.equals(b), then
   firstname.hashCode()+lastname.hashCode() should be the same value for both a and b.

***
   Your code is fine. String has an good hash algorithm and just adding hashes is the most efficient way
   for hashing multiple Strings in Java.

	 * 1
	   the fact that two Strings have good hash functions do not guarantee that sum of two hash values
	   are as well distributed (thinking bitwise)
	 * Well actually 2 Strings with 2 characters should in this way have an as good distribution as 1
	   string with 4 characters. Except for the case that the both Strings equal.

   hashCode() is correct in the sense that it will work (assuming that the strings firstname and
   lastname are not null) - i.e. the method will return an int. Whether it's a good solution or not is a
   much longer story, which I am sure you can check up on using the search field above ;)

   Here's an interesting question I've asked a while back regarding custom implementations of
   hashCode(): [***1]Using a larger prime as a multiplier when overriding hashCode()


---
[***1]
https://stackoverflow.com/questions/12076846/using-a-larger-prime-as-a-multiplier-when-overriding-hashcode

Using a larger prime as a multiplier when overriding hashCode()

   I have been reading about hashcode functions for the past couple of hours and have accumulated a
   couple of questions regarding use of prime numbers as multipliers in custom hashcode implementations.
   I would be grateful if I could get some insight regarding following questions:
	 * In a comment to @mattb's answer here, @hstoerr advocates for use of larger primes (such as
	   524287) instead of the common prime 31. My question is, given the following implementation of a
	   hashcode functions for a pair or elements:
@Override
public int hashCode() {
	final int prime = 31;
	int hash1 = (pg1 == null) ? 0 : pg1.hashCode();
	int hash2 = (pg2 == null) ? 0 : pg2.hashCode();
	return prime * (hash1 ^ hash2);
}

   doesn't this lead to an overflow on the returned int if prime is a large number?
	 * Assuming that the overflow is not a problem (JVM doing an automatic cast) is it better to do a
	   bitshift instead of a cast?
	 * I imagine the performance of the hashcode function vary significantly based on the complexity of
	   the hashcode. Does the size of the prime multiplier not effect the performance?
	 * Is it better/smarter/faster to use multiple primes in a custom hashcode function instead of a
	   single multiplier? If not, is there some other advantage? See the example below from @jinguy's
	   answer to a relevant question:
public int hashCode() {
	return a * 13 + b.hashCode() * 23 + (c? 31: 7);
}

   where a is an int, b is a String and c is boolean.
	 * How about something like long lhash = prime * (hash1 ^ hash2); then using (int)((lhash >> 32) ^
	   lhash)? That's something I saw on another question here SO, but it wasn't really explained why it
	   was a good idea to do it like that.

***
	 * It's probably better to post multiple questions separately, instead of grouped together as above.
	   This makes it easier to answer, and focused questions are more likely to be useful to others in
	   future Google searches. Kudos for citing references on your research, by the way.
	 * 2
	   @GargantuChet while I'd normally agree with your statement, I think these 4 question are actually
	   pretty closely related to one another. Asking a new question for every detail of the subject will
	   ultimately lead to overflooding of questions, I think. (Would be cool to see what the mods think
	   about it, though)

***
   There is an overflow, but not an exception.

   The danger doesn't come from losing accuracy, but losing range. Let's use a ridiculous example, where
   "prime" is a large power of 2, and 8-bit unsigned numbers for brevity. And assume that (hash1 ^
   hash2) is 255:
		"prime": 1000 0000
(hash1 ^ hash2): 1111 1111

   Showing the truncated digits in brackets, our result is:
		product: [0111 1111] 1000 0000

   But multiplying by 128 is the same as shifting left by 7 places. So we know that whatever the value
   of (hash1 ^ hash2), the least-significant places of the product will have seven zeros. So if (hash1 ^
   hash2) is odd (least significant bit = 1), then the result of multiplying by 128 will always be 128
   (after truncating the higher digits). And if (hash1 ^ hash2) is even (LSB is 0, then the product will
   always be zero.

   This extends to larger bit sizes. The general point is that if the lower bits of "prime" are zeros,
   you're doing a shift (or multiple shift + sum) operation that will give you zeros in the lower bits.
   And the range of the product of multiplication will suffer.

   But let's try making "prime" odd, so that the least significant bit will always be 1. Think about
   decomposing this into shift / add operations. The unshifted value of (hash1 ^ hash2) will always be
   one of the summands. The least significant bits that were shifted into guaranteed uselessness by an
   even "prime" multiplier will now be set based on, at minimum, the bits from the original (hash1 ^
   hash2) value.

   Now, let's consider a value of prime which is actually prime. If it's more than 2, then we know it's
   odd. So the lower bits haven't been shifted into uselessness. And by choosing a sufficiently large
   prime, you get better distribution across the range of output values than you'd get with a smaller
   prime.

   Try some exercises with 16-bit multiplication using 8443 (0010 0000 1111 1011) and 59 (0000 0000 0011
   1011). They're both prime, and the lower bits of 59 match the lower bits of 65531. For example, if
   hash1 and hash2 are both ASCII character values (0 .. 255), then all of the results of (hash1 ^
   hash2) * 59 will be <= 15045. This means that roughly 1/4 of the range of hash values (0..65535) for
   a 16-bit number go unused.

   But (hash1 ^ hash2) * 8443 is all over the map. It overflows if (hash1 ^ hash2) is as low as 8. It
   uses all 16 bits even for very small input numbers. There's much less clustering of hash values
   across the overall range, even if the input numbers are in a relatively small range.

	 Assuming that the overflow is not a problem (JVM doing an automatic cast) is it better to do a
	 bitshift instead of a cast?

   Most likely not. The JVM should translate into an efficient implementation on the host processor
   anyway. Integer multiplication should be implemented in hardware. And if not, the JVM is responsible
   for translating the operation into something reasonable for the CPU. It's very likely that the case
   of integer multiplication is highly optimized already. If integer multiplication is done more quickly
   on a given CPU as shift-and-add, the JVM should implement it that way. But it's less likely that the
   folks writing the JVM would care to watch for cases where multiple shift-and-add operations could
   have been combined into a single integer multiply.

	 I imagine the performance of the hashcode function vary significantly based on the complexity of
	 the hashcode. Does the size of the prime multiplier not effect the performance?

   No. The operations are the same when done in hardware regardless of the size, number of bits set,
   etc. It's probably a couple of clock cycles. It would vary depending on the specific CPU, but should
   be a constant-time operation regardless of the input values.

	 Is it better/smarter/faster to use multiple primes in a custom hashcode function instead of a
	 single multiplier? If not, is there some other advantage?

   Only if it reduces the possibility of collisions, and this depends on the numbers you're using. If
   your hash code depends on A and B and they're in the same range, you might consider using different
   primes or shifting one of the input values to reduce overlap between the bits. Since you're depending
   on their individual hash codes, and not their values directly, it's reasonable to assume that their
   hash codes provide good distribution, etc.

   One factor that comes to mind whether you want the hash code for (x, y) to be different from (y, x).
   If your hash function treats A and B in the same way, then hash(x, y) = hash(y, x). If that's what
   you want, then by all means use the same multiplier. It not, using a different multiplier would make
   sense.

	 How about something like long lhash = prime * (hash1 ^ hash2); then using (int)((lhash >> 32) ^
	 lhash)? That's something I saw on another question here SO, but it wasn't really explained why it
	 was a good idea to do it like that.

   Interesting question. In Java, longs are 64-bit and ints are 32-bit. So this generates a hash using
   twice as many bits as desired, and then derives the result from the high and low bits combined.

   If multiplying a number n by a prime p, and the lowermost k bits of n are all zeros, then the
   lowermost k bits of the product n * p will also be all zeros. This is fairly easy to see -- if you're
   multiplying, say, n = 0011 0000 and p = 0011 1011, then the product can be expressed as the sum of
   two shift operations. Or,
00110000 * p = 00100000 * p + 00010000 * p
			 = p << 5 + p << 4

   Taking p = 59 and using unsigned 8-bit ints and 16-bit longs, here are some examples.
 64: 0011 1011 * 0100 0000 = [ 0000 1110 ] 1100 0000 (192)
128: 0011 1011 * 1000 0000 = [ 0001 1101 ] 1000 0000 (128)
192: 0011 1011 * 1100 0000 = [ 0010 1100 ] 0100 0000 (64)

   By just dropping the high bits of the result, the range of the resulting hash value is limited when
   the low bits of the non-prime multiplicand are all zeros. Whether that's an issue in a specific
   context is, well, context-specific. But for a general hash function it's a good idea to avoid
   limiting the range of output values even when there are patterns in the input numbers. And in
   security applications, it's even more critical to avoid anything that would let someone make
   inferences about the original value based on patterns in the output. Just taking the low bits reveals
   the exact values of some of the original bits. If we make the assumption that the operation involved
   multiplying an input number with a large prime, then we know that the original number had as many
   zeros at the right as the hash output (because the prime's rightmost bit was 1).

   By XORing the high bits with the low bits, there's less consistency in the output. And more
   importantly, it's much harder to make guesses about the input values based on this information. Based
   on how XOR works, it could mean the original low bit was 0 and the high bit was 1, or the original
   low bit was 1 and the high bit was 0.
 64: 0011 1011 * 0100 0000 = 0000 1110 1100 0000 => 1100 1110 (206)
128: 0011 1011 * 1000 0000 = 0001 1101 1000 0000 => 1001 1101 (157)
192: 0011 1011 * 1100 0000 = 0010 1100 0100 0000 => 0110 1100 (204)

***
	 * +1: really nice and detailed answer, in particular the examples. Thanks for taking your time. as
	   for the bitshift question how about something like long lhash = prime * (hash1 ^ hash2); then
	   using (int)((lhash >> 32) ^ lhash)? That's something I saw on another question here SO, but it
	   wasn't really explained why it was a good idea to do it like that...
	 * @posdef, this was an interesting thought exercise and I'm wondering whether there are any gaps in
	   my response. I'm not asking you to accept my answer, just wondering if there's anything I've
	   overlooked since no answers have been accepted yet.
	 * to be honest I am not sure, I have been preparing for a conference when I asked this question and
	   now I am actually at that conference. So I wanted to go through you answer, once more in detail,
	   before I respond. It would be a pity to not give it a proper thought seeing that you have put so
	   much time and effort into writing up such a detail answer. :)
	 * @posdef No worries, as mentioned the thought process in itself was reward enough. I appreciate
	   the attention to detail, as should anyone who happens to come across this post in the future.
	   Enjoy the conference!
	 * so now that I have managed to go through this answer, and particularly the edit about the last
	   part, I have to say it has been very informative, somewhat enlightening even.. :) So to sum it
	   up, the last option of using more bits (from the long value) and XOR to itself is a good way to
	   go in distributing the values?

***
	 * Overflow is not a problem. Hashes are constrained to a narrow value set anyway.
	 * The first hash function you posted isn't very good. Doing return (prime * hash1) ^ hash2; `
	   instead would reduce the number of collisions in most cases.
	 * Multiplying by a single word int is generally very fast, and the difference between multiplying
	   by different numbers is negligible. Plus the execution time is dwarfed by everything else in the
	   function anyay
	 * Using different prime multipliers for each part may reduce the risk of collisions.

***
	 * 1
	   @posdef Its impossible to prove because there are always pathological case where it won't be
	   true.
	 * 2
	   Given that humans are involved you can say that pathological case will occur more often than you
	   might expect.
	 * 1
	   @PeterLawrey Thanks for putting a smile on my face; sitting at the office late it doesn't happen
	   often that I get a smile out of the blue. :)
	 * 1
	   An example, String.hashCode() will compute the hashCode once provided its has not been computed
	   before. i.e. if the hashCode is 0, it computes the hashCode. But what if the hashCode is 0, it
	   computes it repeatedly. Well empty string is 0, and the chances of any other being 0 is 4 billion
	   to one. But if you are a hacker you can construct a wide variety of strings, all with a hashCode
	   of 0 which can help you in your DOS attack. Some of them look like normal words.
	   stackoverflow.com/questions/2310498/...
	 * 1
	   @Antimony: Some useful properties are similar, but addition is much better in cases where things
	   where two values match are going to be more common than things where they don't. Computing X+X
	   for all int values will yield one collision for each. Computing X^X for all int values will yield
	   4,294,967,295 collisions for each.



---
https://www.sitepoint.com/how-to-implement-javas-hashcode-correctly/

How to Implement Java's hashCode Correctly
May 19, 2016

   At SitePoint we're always looking to expand the range of topics we cover. Lately, we've set our
   sights on exploring the world of Java. If you're a strong Java developer who wants to contribute to
   our coverage, get in touch with a few ideas for articles you'd like to write.

   So you've decided that identity isn't enough for you and wrote a nice equals implementation?
   Great! But now you have to implement hashCode as well.

   Let's see why and how to do it correctly.

Equality and Hash Code
   While equality makes sense from a general perspective, hash codes are much more technical. If we were
   being a little hard on them, we could say that they are just an implementation detail to improve
   performance.

   Most data structures use equals to check whether they contain an element. For example:
List<String> list = Arrays.asList("a", "b", "c");
boolean contains = list.contains("b");

   The variable contains is true because, while instances of "b" are not identical (again, ignoring
   String interning), they are equal.

   Comparing every element with the instance given to contains is wasteful, though, and a whole class of
   data structures uses a more performant approach. Instead of comparing the requested instance with
   each element they contain, they use a shortcut that reduces the number of potentially equal instances
   and then only compare those.

   This shortcut is the hash code, which can be seen as an object's equality boiled down to an integer
   value. Instances with the same hash code are not necessarily equal but equal instances have the same
   hash code. (Or should have, we will discuss this shortly.) Such data structures are often named after
   this technique, recognizable by the Hash in their name, with HashMap the most notable representative.

   This is how they generally work:
	 * When an element is added, its hash code is used to compute the index in an internal array (called
	   a bucket).
	 * If other, non-equal elements have the same hash code, they end up in the same bucket and must be
	   bundled together, e.g. by adding them to a list.
	 * When an instance is given to contains, its hash code is used to compute the bucket. Only elements
	   therein are compared to the instance.

   This way, very few, ideally no equals comparisons are required to implement contains.

   As equals, hashCode is defined on Object.

Thoughts on Hashing
   If hashCode is used as a shortcut to determine equality, then there is really only one thing we
   should care about: Equal objects should have the same hash code.

   This is also why, if we override equals, we must create a matching hashCode implementation! Otherwise
   things that are equal according to our implementation would likely not have the same hash code
   because they use Objectâ€˜s implementation.

The hashCode Contract

   Quoting the source:
	 The general contract of hashCode is:
	 * Whenever it is invoked on the same object more than once during an execution of a Java
	   application, the hashCode method must consistently return the same integer, provided no
	   information used in equals comparisons on the object is modified. This integer need not remain
	   consistent from one execution of an application to another execution of the same application.
	 * If two objects are equal according to the equals(Object) method, then calling the hashCode method
	   on each of the two objects must produce the same integer result.
	 * It is not required that if two objects are unequal according to the equals(Object) method, then
	   calling the hashCode method on each of the two objects must produce distinct integer results.
	   However, the programmer should be aware that producing distinct integer results for unequal
	   objects may improve the performance of hash tables.

   The first bullet mirrors the consistency property of equals and the second is the requirement we came
   up with above. The third states an important detail that we discuss will in a moment.

   math

Implementing hashCode
   A very easy implementation of Person.hashCode is the following:
@Override
public int hashCode() {
	return Objects.hash(firstName, lastName);
}

   The person's hash code is computed by computing the hash codes for the relevant fields and
   combining them. Both is left to Objectsâ€˜ utility function hash.

Selecting Fields
   But which fields are relevant? The requirements help answer this: If equal objects must have the same
   hash code, then hash code computation should not include any field that is not used for equality
   checks. (Otherwise two objects that only differ in those fields would be equal but have different
   hash codes.)

   So the set of fields used for hashing should be a subset of the fields used for equality. By default
   both will use the same fields but there are a couple of details to consider.

Consistency
   For one, there is the consistency requirement. It should be interpreted rather strictly. While it
   allows the hash code to change if some fields change (which is often unavoidable with mutable
   classes), hashing data structures are not prepared for this scenario.

   As we have seen above the hash code is used to determine an element's bucket. But if the
   hash-relevant fields change, the hash is not recomputed and the internal array is not updated.

   This means that a later query with an equal object or even with the very same instance fails! The
   data structure computes the current hash code, different from the one used to store the instance, and
   goes looking in the wrong bucket.

   Conclusion: Better not use mutable fields for hash code computation!

Performance
   Hash codes might end up being computed about as often as equals is called. This can very well happen
   in performance critical parts of the code so it makes sense to think about performance. And unlike
   equals there is a little more wiggle room to optimize it.

   Unless sophisticated algorithms are used or many, many fields are involved, the arithmetic cost of
   combining their hash codes is as negligible as it is unavoidable. But it should be considered whether
   all fields need to be included in the computation! Particularly collections should be viewed with
   suspicion. Lists and sets, for example, will compute the hash for each of their elements. Whether
   calling them is necessary should be considered on a case-by-case basis.

   If performance is critical, using Objects.hash might not be the best choice either because it
   requires the creation of an array for its varargs.

   But the general rule about optimization holds: Don't do it prematurely! Use a common hash code
   algorithm, maybe forego including the collections, and only optimize after profiling showed potential
   for improvement.

Collisions
   Going all-in on performance, what about this implementation?
@Override
public int hashCode() {
	return 0;
}

   It's fast, that's for sure. And equal objects will have the same hash code so we're good on
   that, too. As a bonus, no mutable fields are involved!

   But remember what we said about buckets? This way all instances will end up in the same! This will
   typically result in a linked list holding all the elements, which is terrible for performance. Each
   contains, for example, triggers a linear scan of the list.

   So what we want is as few items in the same bucket as possible! An algorithm that returns wildly
   varying hash codes, even for very similar objects, is a good start.

   How to get there partly depends on the selected fields. The more details we include in the
   computation, the more likely it is for the hash codes to differ. Note how this is completely opposite
   to our thoughts about performance. So, interestingly enough, using too many or too few fields can
   result in bad performance.

   The other part to preventing collisions is the algorithm that is used to actually compute the hash.

Computing The Hash
   The easiest way to compute a field's hash code is to just call `hashCode` on it. Combining them
   could be done manually. A common algorithm is to start with some arbitrary number and to repeatedly
   multiply it with another (often a small prime) before adding a field's hash:
int prime = 31;
int result = 1;
result = prime * result + ((firstName == null) ? 0 : firstName.hashCode());
result = prime * result + ((lastName == null) ? 0 : lastName.hashCode());
return result;

   This might result in overflows, which is not particularly problematic because they cause no
   exceptions in Java.

   Note that even great hashing algorithms might result in uncharacteristically frequent collisions if
   the input data has specific patterns. As a simple example assume we would compute the hash of points
   by adding their x and y-coordinates. May not sound too bad until we realize that we often deal with
   points on the line f(x) = -x, which means x + y == 0 for all of them. Collisions, galore!

   But again: Use a common algorithm and don't worry until profiling shows that something isn't
   right.

Summary
   We have seen that computing hash codes is something like compressing equality to an integer value:
   Equal objects must have the same hash code and for performance reasons it is best if as few non-equal
   objects as possible share the same hash.

   This means that hashCode must always be overridden if equals is.

   When implementing hashCode:
	 * Use a the same fields that are used in equals (or a subset thereof).
	 * Better not include mutable fields.
	 * Consider not calling hashCode on collections.
	 * Use a common algorithm unless patterns in input data counteract them.

   Remember that hashCode is about performance, so don't waste too much energy unless profiling
   indicates necessity.



---
https://javarevisited.blogspot.com/2011/10/override-hashcode-in-java-example.html

How to override hashcode in Java example - Tutorial

   Equals and hashcode methods are two primaries but yet one of the most important methods for java
   developers to be aware of. Java intends to provide equals and hashcode for every class to test
   equality and to provide a hash or digest based on the content of the class. The importance of
   hashcode increases when we use the object in different collection classes which works on hashing
   principle e.g. hashtable and hashmap. A well-written hashcode method can improve performance
   drastically by distributing objects uniformly and avoiding a collision.
   In this article, we will see how to correctly override the hashcode() method in java with a simple
   example.
   We will also examine the important aspects of hashcode contracts in java. This is in continuation of
   my earlier post on overriding the equals method in Java, if you haven't read it already I would
   suggest going through it.

General Contracts for hashCode() in Java
   1) If two objects are equal by the equals() method then their hashcode returned by the hashCode()
   method must be the same.
   2) Whenever the hashCode() method is invoked on the same object more than once within a single
   execution of the application, hashCode() must return the same integer provided no information or
   fields used in equals and hashcode is modified. This integer is not required to be the same during
   multiple executions of application though.
   3) If two objects are not equaled by the equals() method it is not required that their hashcode must
   be different. Though it's always good practice to return different hashCode for unequal object.
   Different hashCode for a distinct objects can improve the performance of hashmap or hashtable by
   reducing collision.
   To better understand concept of equals and hashcode and what happens if you don't override them
   properly I would recommend understanding of How HashMap works in Java

Overriding hashCode method in Java
   Override java hashcode example We will follow step by step approach for overriding hashCode
   method. This will enable us to understand the concept and process better.
   1) Take a prime hash e.g. 5, 7, 17 or 31 (prime number as hash, results in distinct hashcode for
   distinct object)
   2) Take another prime as multiplier different than hash is good.
   3) Compute hashcode for each member and add them into final hash. Repeat this for all members which
   participated in equals.
   4) Return hash
	 Here is an example of hashCode() method
	  @Override
	   public int hashCode() {
		int hash = 5;
		hash = 89  hash + (this.name != null ? this.name.hashCode() : 0);
		hash = 89  hash + (int) (this.id ^ (this.id >>> 32));
		hash = 89  hash + this.age;
		return hash;
	}

   It's always good to check null before calling hashCode() method on members or fields to avoid
   NullPointerException, if member is null than return zero. Different data types has different way to
   compute hashCode.Integer members are simplest we just add there value into hash, for other numeric
   data-type are converted into int and then added into hash. Joshua bloach has full tables on this. I
   mostly relied on IDE for this.

Better way to override equals and hashCode
   hashcode in Java example In my opinion, a better way to override both equals and hashcode methods
   should be left to IDE. I have seen Netbeans and Eclipse and found that both have excellent support of
   generating code for equals and hashcode and their implementations seem to follow all best practices
   and requirement e.g. null check, instanceof check, etc and also frees you to remember how to compute
   hashcode for different data-types.
   Let's see how we can override the hashcode method in Netbeans and Eclipse.

In Netbeans
   1) Write your Class.
   2) Right click + insert code + Generate equals() and hashCode().

In Eclipse
   1) Write to your Class.
   2) Go to Source Menu + Generate hashCode() and equals()

Things to remember while overriding hashcode in Java
   1. Whenever you override the equals method, hashcode should be overridden to be in compliance with
   equals hashcode contract.
   2. hashCode() is declared in Object class and return type of hashcode method is int and not long.
   3. For an immutable object, you can cache the hashcode once generated for improved performance.
   4. Test your hashcode method for equals hashcode compliance.
   5. If you don't override hashCode() method properly your Object may not function correctly on
   hash-based collection e.g. HashMap, Hashtable or HashSet.

A complete example of equals and hashCode
<code>
ublic class Stock {
	private String symbol;
	private String exchange;
	private long lotSize;
	private int tickSize;
	private boolean isRestricted;
	private Date settlementDate;
	private BigDecimal price;


	@Override
	public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result
						+ ((exchange == null) ? 0 : exchange.hashCode());
			result = prime * result + (isRestricted ? 1231 : 1237);
			result = prime * result + (int) (lotSize ^ (lotSize >>> 32));
			result = prime * result + ((price == null) ? 0 : price.hashCode());
			result = prime * result
						+ ((settlementDate == null) ? 0 : settlementDate.hashCode());
			result = prime * result + ((symbol == null) ? 0 : symbol.hashCode());
			result = prime * result + tickSize;
			return result;
	}
	@Override
	public boolean equals(Object obj) {
			if (this == obj) return true;
			if (obj == null || this.getClass() != obj.getClass()){
					return false;
			}
			Stock other = (Stock) obj;

   return
   this.tickSize == other.tickSize && this.lotSize == other.lotSize &&
   this.isRestricted == other.isRestricted &&
   (this.symbol == other.symbol|| (this.symbol != null && this.symbol.equals(other.symbol)))&&
   (this.exchange == other.exchange|| (this.exchange != null && this.exchange.equals(other.exchange)))
   &&
   (this.settlementDate == other.settlementDate|| (this.settlementDate != null &&
   this.settlementDate.equals(other.settlementDate))) &&
   (this.price == other.price|| (this.price != null && this.price.equals(other.price)));


	}
}
</code>

Writing equals and hashcode using Apache Commons EqualsBuilder and HashCodeBuilder
   EqualsBuilder and HashCodeBuilder from Apache commons are a much better way to override equals and
   hashcode method, at least much better than ugly equals, hashcode generated by Eclipse. I have written
   the same example by using HashCodebuilder and EqualsBuilder and now you can see how clear and concise
   they are.
<code>
	@Override
	public boolean equals(Object obj){
		if (obj instanceof Stock) {
			Stock other = (Stock) obj;
			EqualsBuilder builder = new EqualsBuilder();
			builder.append(this.symbol, other.symbol);
			builder.append(this.exchange, other.exchange);
			builder.append(this.lotSize, other.lotSize);
			builder.append(this.tickSize, other.tickSize);
			builder.append(this.isRestricted, other.isRestricted);
			builder.append(this.settlementDate, other.settlementDate);
			builder.append(this.price, other.price);
			return builder.isEquals();
		}
		return false;
	}

	@Override
	public int hashCode(){
		HashCodeBuilder builder = new HashCodeBuilder();
		builder.append(symbol);
		builder.append(exchange);
		builder.append(lotSize);
		builder.append(tickSize);
		builder.append(isRestricted);
		builder.append(settlementDate);
		builder.append(price);
		return builder.toHashCode();
	}

	public static void main(String args[]){
		Stock sony = new Stock("6758.T", "Tkyo Stock Exchange", 1000, 10, false, new Date(),
BigDecimal.valueOf(2200));
		Stock sony2 = new Stock("6758.T", "Tokyo Stock Exchange", 1000, 10, false, new Date(),
BigDecimal.valueOf(2200));
		System.out.println("Equals result: " + sony.equals(sony2));
		System.out.println("HashCode result: " + (sony.hashCode()== sony2.hashCode()));
	}
</code>

   The only thing to concern is that it adds a dependency on the apache-commons jar, most people use it
   but if you are not using then you need to include it for the writing equals and hashcode method.


---
https://howtodoinjava.com/java/basics/java-hashcode-equals-methods/

Java hashCode() and equals() - Contract, rules and best practices
October 22, 2020

   Learn about Java hashCode() and equals() methods, their default implementation and how to correctly
   override them. Also learn to implement these methods using Apache Commons package's utility classes
   HashCodeBuilder and EqualsBuilder.

	 hashCode() and equals() methods have been defined in Object class which is parent class
	 for java objects. For this reason, all java objects inherit a default implementation of these
	 methods.

1. Usage of hashCode() and equals() Methods
	1. equals(Object otherObject) - As method name suggests, is used to simply verify the equality of
	   two objects. It's default implementation simply check the object references of two objects to
	   verify their equality. By default, two objects are equal if and only if they are stored in the
	   same memory address.
	2. hashcode() - Returns a unique integer value for the object in runtime. By default, integer value
	   is mostly derived from memory address of the object in heap (but it's not mandatory always).
	   This hash code is used for determining the bucket location, when this object needs to be stored
	   in some HashTable like data structure.

1.1. Contract between hashCode() and equals()
   It is generally necessary to override the hashCode() method whenever equals() method is overridden,
   so as to maintain the general contract for the hashCode() method, which states that equal objects
   must have equal hash codes.
	 * Whenever it is invoked on the same object more than once during an execution of a Java
	   application, the hashCode method must consistently return the same integer, provided no
	   information used in equals comparisons on the object is modified.
	   This integer need not remain consistent from one execution of an application to another execution
	   of the same application.
	 * If two objects are equal according to the equals(Object) method, then calling the hashCode method
	   on each of the two objects must produce the same integer result.
	 * It is not required that if two objects are unequal according to the equals(java.lang.Object)
	   method, then calling the hashCode method on each of the two objects must produce distinct integer
	   results.
	   However, the programmer should be aware that producing distinct integer results for unequal
	   objects may improve the performance of hash tables.

2. Override the default behavior of hashCode() and equals()
   Everything works fine until you do not override any of these methods in your classes. But, sometimes
   the application needs to change the default behavior of some objects. Lets understand why we need to
   override equals and hashcode methods.

2.1. Default Behavior
   Lets take an example where your application has Employee object. Lets create a minimal possible
   structure of Employee class:
public class Employee {
	private Integer id;
	private String firstname;
	private String lastName;
	private String department;

	//Setters and Getters
}

   Above Employee class has some very basic attributes and their accessor methods. Now consider a simple
   situation where you need to compare two employee objects.
public class EqualsTest {
	public static void main(String[] args) {
		Employee e1 = new Employee();
		Employee e2 = new Employee();

		e1.setId(100);
		e2.setId(100);

		System.out.println(e1.equals(e2));	//false
	}
}

   No prize for guessing. Above method will print "false". But, is it really correct after knowing that
   both objects represent the same employee. In a real-time application, this should return true.

2.2. Should we override only equals() method?
   To achieve correct application behavior, we need to override equals() method as below:
public boolean equals(Object o) {
	if(o == null) {
		return false;
	}
	if (o == this) {
		return true;
	}
	if (getClass() != o.getClass()) {
		return false;
	}

	Employee e = (Employee) o;
	return (this.getId() == e.getId());
}

   Add this method to your Employee class, and EqualsTest will start returning "true".

   So are we done? Not yet. Lets test again above modified Employee class in different way.
import java.util.HashSet;
import java.util.Set;

public class EqualsTest {
	public static void main(String[] args) {
		Employee e1 = new Employee();
		Employee e2 = new Employee();

		e1.setId(100);
		e2.setId(100);

		//Prints 'true'
		System.out.println(e1.equals(e2));

		Set<Employee> employees = new HashSet<Employee>();
		employees.add(e1);
		employees.add(e2);

		System.out.println(employees);	//Prints two objects
	}
}

   Above class prints two objects in the second print statement. If both employee objects have been
   equal, in a Set which stores only unique objects, there must be only one instance inside HashSet,
   after all both objects refer to the same employee. What is it we are missing??

2.3. Override hashCode() method also
   We are missing the second important method hashCode(). As java docs say, if you override equals()
   method then you must override hashCode() method. So lets add another method in our Employee class.
@Override
public int hashCode() {
	final int PRIME = 31;
	int result = 1;
	result = PRIME * result + getId();
	return result;
}

   Once above method is added in Employee class, the second statement start printing only single object
   in second statement, and thus validating the true equality of e1 and e2.

3. EqualsBuilder and HashCodeBuilder utility classes
   Apache commons provide two excellent utility classes HashCodeBuilder and EqualsBuilder
   for generating hash code and equals methods. Below is its usage:
<code>
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
public class Employee {
	private Integer id;
	private String firstname;
	private String lastName;
	private String department;

	//Setters and Getters

	@Override
	public int hashCode() {
		final int PRIME = 31;
		return new HashCodeBuilder(getId()%2==0?getId()+1:getId(), PRIME).toHashCode();
	}

	@Override
	public boolean equals(Object o) {
	if (o == null)
		return false;

	if (o == this)
		return true;

	if (o.getClass() != getClass())
		return false;

	Employee e = (Employee) o;

	return new EqualsBuilder().
		append(getId(), e.getId()).
		isEquals();
	}
}
</code>

4. Generate hashCode() and equals() using Eclipse
   If you are using any code editor, then most editors also are capable of generating some good
   structure for you. For example, Eclipse IDE has option to generate a very good implementation of
   hashCode() and equals() for you.

	 Right click on java file -> Source -> Generate hashCode() and equals() ...

   Generate HashCode and Equals In Eclipse Generate hashCode() and equals() In Eclipse

5. Java hashCode() and equals() best practices
	1. Always use same attributes of an object to generate hashCode() and equals() both. As in our case,
	   we have used employee id.
	2. equals() must be consistent (if the objects are not modified, then it must keep returning the
	   same value).
	3. Whenever a.equals(b), then a.hashCode() must be same as b.hashCode().
	4. If you override one, then you should override the other.

6. Special Attention When Using in ORM
   If you're dealing with an ORM, make sure to always use getters, and never field references in
   hashCode() and equals(). This is for reason, in ORM, occasionally fields are lazy loaded and not
   available until called their getter methods.

   For example, In our Employee class if we use e1.id == e2.id. It is very much possible that id field
   is lazy loaded. So in this case, one might be zero or null, and thus resulting in incorrect behavior.

   But if uses e1.getId() == e2.getId(), we can be sure even if field is lazy loaded; calling getter
   will populate the field first.

   This is all i know about hashCode() and equals() methods. I hope, it will help someone somewhere.

   If you feel, I am missing something or wrong somewhere, please leave a comment. I will update this
   post again to help others.



---
https://mkyong.com/java/java-how-to-overrides-equals-and-hashcode/

Java - How to override equals and hashCode
March 24, 2016

1. POJO
   To compare two Java objects, we need to override both equals and hashCode (Good practice).
   User.java
<code>
public class User {
	private String name;
	private int age;
	private String passport;

		//getters and setters, constructor
}
</code>

<code>
	User user1 = new User("mkyong", 35, "111222333");
	User user2 = new User("mkyong", 35, "111222333");

	System.out.println(user1.equals(user2)); // false
</code>

2. Classic Way
   The 17 and 31 hash code idea is from the classic Java book - effective Java : item 9
   User.java
<code>
public class User {
	private String name;
	private int age;
	private String passport;

		//getters and setters, constructor

	@Override
	public boolean equals(Object o) {

		if (o == this) return true;
		if (!(o instanceof User)) {
			return false;
		}

		User user = (User) o;

		return user.name.equals(name) &&
				user.age == age &&
				user.passport.equals(passport);
	}

	//Idea from effective Java : Item 9
	@Override
	public int hashCode() {
		int result = 17;
		result = 31 * result + name.hashCode();
		result = 31 * result + age;
		result = 31 * result + passport.hashCode();
		return result;
	}

}
</code>

2. JDK 7
   For JDK 7 and above, you can use the new Objects class to generate the equals and hash code values.
   User.java
<code>
import java.util.Objects;

public class User {
	private String name;
	private int age;
	private String passport;

		//getters and setters, constructor

	@Override
	public boolean equals(Object o) {

		if (o == this) return true;
		if (!(o instanceof User)) {
			return false;
		}
		User user = (User) o;
		return age == user.age &&
				Objects.equals(name, user.name) &&
				Objects.equals(passport, user.passport);
	}

	@Override
	public int hashCode() {
		return Objects.hash(name, age, passport);
	}

}
</code>

3. Apache Commons Lang
   Alternatively, you can use the Apache Commons Lang EqualsBuilder and HashCodeBuilder function.
   User.java
<code>
import org.apache.commons.lang3.builder;

public class User {
	private String name;
	private int age;
	private String passport;

		//getters and setters, constructor

	 @Override
	public boolean equals(Object o) {

		if (o == this) return true;
		if (!(o instanceof User)) {
			return false;
		}

		User user = (User) o;

		return new EqualsBuilder()
				.append(age, user.age)
				.append(name, user.name)
				.append(passport, user.passport)
				.isEquals();
	}

	@Override
	public int hashCode() {
		return new HashCodeBuilder(17, 37)
				.append(name)
				.append(age)
				.append(passport)
				.toHashCode();
	}
}
</code>

4. Test again
   After overrides both equals and hashCode.
	User user1 = new User("mkyong", 35, "111222333");
	User user2 = new User("mkyong", 35, "111222333");

	System.out.println(user1.equals(user2)); // true



---
https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/langCon_apex_collections_maps_keys_userdefined.htm

Using Custom Types in Map Keys and Sets
You can add instances of your own Apex classes to maps and sets.

For maps, instances of your Apex classes can be added either as keys or values. If you add them as keys,
there are some special rules that your class must implement for the map to function correctly; that is, for the
key to fetch the right value. Similarly, if set elements are instances of your custom class, your class must
follow those same rules. 

Warning:
If the object in your map keys or set elements changes after being added to the collection, it won’t be found
anymore because of changed field values.

When using a custom type (your Apex class) for the map key or set elements, provide equals and hashCode methods
in your class. Apex uses these two methods to determine equality and uniqueness of keys for your objects.

Adding equals and hashCode Methods to Your Class
To ensure that map keys of your custom type are compared correctly and their uniqueness can be determined
consistently, provide an implementation of the following two methods in your class:

	The equals method with this signature:
<code>
public Boolean equals(Object obj) {
	// Your implementation
}
</code>

Keep in mind the following when implementing the equals method. Assuming x, y, and z are non-null instances of
your class, the equals method must be:

	Reflexive: x.equals(x)
	Symmetric: x.equals(y) should return true if and only if y.equals(x) returns true
	Transitive: if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true
	Consistent: multiple invocations of x.equals(y) consistently return true or consistently return false
	For any non-null reference value x, x.equals(null) should return false

The equals method in Apex is based on the equals method in Java.
The hashCode method with this signature:

<code>
public Integer hashCode() {
	// Your implementation
}
</code>

	Keep in mind the following when implementing the hashCode method.
	If the hashCode method is invoked on the same object more than once during execution of an Apex
	request, it must return the same value.

	If two objects are equal, based on the equals method, hashCode must return the same value.
	If two objects are unequal, based on the result of the equals method, it is not required that hashCode
	return distinct values.

	The hashCode method in Apex is based on the hashCode method in Java.

Another benefit of providing the equals method in your class is that it simplifies comparing your objects.
You will be able to use the == operator to compare objects, or the equals method. For example:

<code>
	// obj1 and obj2 are instances of MyClass
	if (obj1 == obj2) {
		// Do something
	}
	
	if (obj1.equals(obj2)) {
		// Do something
	}
</code>

Sample
This sample shows how to implement the equals and hashCode methods. The class that provides those methods is
listed first. It also contains a constructor that takes two Integers. The second example is a code snippet that
creates three objects of the class, two of which have the same values. Next, map entries are added using the
pair objects as keys. The sample verifies that the map has only two entries since the entry that was added last
has the same key as the first entry, and hence, overwrote it. The sample then uses the == operator, which works
as expected because the class implements equals. Also, some additional map operations are performed, like
checking whether the map contains certain keys, and writing all keys and values to the debug log. Finally, the
sample creates a set and adds the same objects to it. It verifies that the set size is two, since only two
objects out of the three are unique.

<code>
public class PairNumbers {
	Integer x,y;

	public PairNumbers(Integer a, Integer b) {
		x=a;
		y=b;
	}

	public Boolean equals(Object obj) {
		if (obj instanceof PairNumbers) {
			PairNumbers p = (PairNumbers)obj;
			return ((x==p.x) && (y==p.y));
		}
		return false;
	}

	public Integer hashCode() {
		return (31 * x) ^ y;
	}
}
</code>

This code snippet makes use of the PairNumbers class.

<code>
	Map<PairNumbers, String> m = new Map<PairNumbers, String>();
	PairNumbers p1 = new PairNumbers(1,2);
	PairNumbers p2 = new PairNumbers(3,4);
	// Duplicate key
	PairNumbers p3 = new PairNumbers(1,2);
	m.put(p1, 'first');
	m.put(p2, 'second');
	m.put(p3, 'third');
	
	// Map size is 2 because the entry with
	// the duplicate key overwrote the first entry.
	System.assertEquals(2, m.size());
	
	// Use the == operator
	if (p1 == p3) {
		System.debug('p1 and p3 are equal.');
	}
	
	// Perform some other operations
	System.assertEquals(true, m.containsKey(p1));
	System.assertEquals(true, m.containsKey(p2));
	System.assertEquals(false, m.containsKey(new PairNumbers(5,6)));
	
	for(PairNumbers pn : m.keySet()) {
		System.debug('Key: ' + pn);
	}
	
	List<String> mValues = m.values();
	System.debug('m.values: ' + mValues);
	
	// Create a set
	Set<PairNumbers> s1 = new Set<PairNumbers>();
	s1.add(p1);
	s1.add(p2);
	s1.add(p3);
	
	// Verify that we have only two elements
	// since the p3 is equal to p1.
	System.assertEquals(2, s1.size());
</code>


---

