filename: jv_uses-of-interface_multif_20180922.txt
https://www.quora.com/What-are-the-uses-of-interface-in-Java

Changing peoples' habits is sometimes harder than moving a mountain. The media industry realized this
pretty early, as their survival was at stake. Picture this:

At one time, audio cassettes were the only way to play media in our homes.
Slowly, video cassettes caught up, and now you could see what you heard.
Digital disruption introduced audio CDs and a little later, video CDs and DVDs.
After that, MP3 and MP4 formats, coupled with the internet and cloud computing, have almost put these
industries out of business.
What's common to all these events? Companies taking advantage of peoples' habits, i would say! Anyone
ranging from your grandparents to young kids in your neighborhood, would agree on how to use a media
player. It's simple, and has a few basic controls:
Play
Pause
Stop
Seek-Forward
Seek-Back

Now, don't you find these controls on every Cassette Player (audio/video), CD Player (audio/video/DVD),
and MP3/MP4 Player? Heck, even YouTube videos would have all these, in some form. In every wave, the
players realized that to break-out, they needed to bring-in consumers faster. The user-interface of media
players barely changed, because changing user habits takes time. This is an example of the underlying
principle of reuse.

Reuse is encouraged in software development for similar reasons, including:

Minimizing repeated effort
Reducing code bloat
Consistency of usage

The abstraction mechanisms of an OOP language like Java, allow us to form a mental image of a media
player, and translate it to a concept in code. A media player is a device that lets you enjoy media, and
gives you 5 operations to do it. A Java concept of a media player (maybe a software simulation of one)
can be defined using an interface:

public interface MediaPlayer {
	public void play();
	public void pause();
	public void stop();
	public void seekForward();
	public void seekBack();
}

An interface is much like a class, except:

It has no member variable definitions
It only has method declarations, no definitions
It cannot be instantiated, only implemented
A MediaPlayer is just a concept; it naturally cannot stream a movie from a DVD, or music in an MP3
file. We need implementation classes for that:

public class DVDPlayer implements MediaPlayer {
	public void play { //... }
	public void pause() { //... }
	public void stop(); { //... }
	public void seekForward(); { //... }
	public void seekBack(); { //... }
}

And also like this:

public class MP3Player implements MediaPlayer {
	public void play { //... }
	public void pause() { //... }
	public void stop(); { //... }
	public void seekForward(); { //... }
	public void seekBack(); { //... }
}

Every implementation class needs to redefine the methods declared in the interface. Want to use these
classes to create a media kiosk? Sure, be my guest! Polymorphism helps us switch seamlessly between
audio and video, across formats.

public class MediaRunner {

	public static void main(String[] args) {

	List<MediaPlayer> mediaPlayers = List.of(new DVDPlayer(), new MP3Player());
	for(MediaPlayer player: mediaPlayers) {
		player.play();
		player.seekBack();
		player,play();
		player.pause();
		player.seekForward();
		player.play();
		player.stop();
	}
	}
}

We hardly broke a sweat here! The key points to note are:

Thanks to Java's penchant for polymorphism, a List treats all MediaPlayer devices the same way
To appeal to old-timers, if we added a new AudioCassettePlayer() to mediaPlayers, the code for media
experience wouldn't change!
Do you now see the power of cooperation? An interface proposes a contract, for implementing classes
to follow. This ensures the 3 benefits of code reuse that we listed, reaches teams that collaborate to
develop software. And there's no need to change the coding habits of the consumer, MediaRunner !

---
I use them to describe how an object works with collaborators.

I have an example of a guess my number game (here [***]) where the keyboard and console are split out
from the game. The main game object talks only to a source of Guesses, and writes to a Display.

You can see just how little the game cares about how these Guesses come in. Typed. Spoken via Amazon
Alexa. A mobile app.

This massively simplifies how you can understand software.

When you read the game object, you can see that it asks for a guess. And that's all you need to know
to understand how the game works. You do not get distracted reading through details of how that gets done.

That's my reason: simplify reading and understanding the app, and how it is split up.

Things like Spring JPA use interfaces for runtime code generation. You define what query methods you
want on a database. When the app starts up, these method names get parsed, and some real code that will
query the database is generated.

That's actually doing the same thing, but with a bonus of writing less code.

[***]
https://www.viewfromthecodeface.com/portfolio/clean-code-hexagonal-architecture/

Creating Clean Code with Hexagonal Architecture

Have you ever worked with a truly tangled-up piece of code, mixing business logic with UI with database
with http calls? Depressing, isn't it. Fortunately, there is a better way ...

Building a Guess my Number game
I like to learn things with decent sized examples, so I'm going back in time to one of my earliest
programs, Guess my Number.

This is a simple text game, where the computer picks a secret number between 1 and 10. You have to guess
it, within five tries.

It's simple enough to code up quickly.

Better still for this example, it reads input from the keyboard, outputs to the console, and has a little
bit of logic tying the two together.

Perfect.

So - what can possibly be a problem with something so simple?

First design
So, ignoring Test Driven Development for a moment, let's go full on old-skool, and code this thing up.
Have a quick skim read, then we'll walk through it:

<code>
package com.viewfromthecodeface.procedural;

import java.util.Scanner;

public class GuessMyNumber {
	private final int numberToGuess;

	public GuessMyNumber(int numberToGuess) {
		this.numberToGuess = numberToGuess;
	}

	public void play() {
		displayIntroduction();
		boolean guessedCorrectly = givePlayerUpToFiveAttemptsToGuess();
		displayFinalResult(guessedCorrectly);
	}

	private boolean givePlayerUpToFiveAttemptsToGuess() {
		int attemptNumber = 1;
		boolean guessedCorrectly = false;

		while ( attemptNumber <= 5 && !guessedCorrectly){
			int latestGuess = readIntegerFromKeyboard(attemptNumber);

			if ( latestGuess == numberToGuess ){
				guessedCorrectly = true ;
			} else {
				display("Try again");
			}
			attemptNumber++;
		}

		return guessedCorrectly;
	}

	private void displayIntroduction() {
		display("I'm thinking of a number between 1 and 10.");
		display("Can you guess it, in five guesses?");
	}

	private void displayFinalResult(boolean guessedCorrectly) {
		if ( guessedCorrectly ) {
			display("You guessed it! Spooky. Or a good use of binary search...");
		} else {
			display("Bad luck. If there's nothing on Netflix, you could try again");
		}
	}

	private int readIntegerFromKeyboard(int attemptNumber) {
		display( String.format("Your Guess? (attempt %d) > ", attemptNumber));

		Scanner keyboard = new Scanner(System.in);
		return keyboard.nextInt();
	}

	private void display( String text ) {
		System.out.println(text);
	}
}
</code>


<code>
package com.viewfromthecodeface.procedural;

public class Main {

	public static void main(String[] commandLineArguments) {
		new GuessMyNumber(3).play();
	}
}
</code>

The main method is trivial. It creates a GuessMyNumber object, and supplies it with our secret number.

It then calls play() to run the game.
The code is short. It's reasonably clear and readable. And it works.
What's not to like?

What if we want to display to somewhere else?
A console based game has a retro hipster appeal to it.

But what if we wanted to display to a GUI? Or maybe a simple web page?
How could we do it?

We have to modify the code
To display to a GUI, we would have to rip out the innards of the display() method.
We would need it to write to a JTextArea - or something from JavaFX.
This would need main windows creating, and other modifications to the code.
It's not ideal.

We've built and manually tested this thing. Now we're going to invalidate that.

How do we test this thing?
Come to mention testing, it has been all manual.
How would you automate tests for this?
Well, the input must come from the keyboard. So you would need to drive that.
The output goes to the console. You would need to intercept that.
Whilst tools such as Mercury WinRunner will do this (and Selenium for Web Apps), testing through the
User Interface is no fun.

UI tests tend to be slow, and a bit 'flaky'. Sometimes, screen updates are missed, and tests fail
wrongly. 'False negatives' as they are known.

Fixing this so we can change and test easily
The big problem with changing the input and output sources is also the problem with testing.
If we could change the input and output sources easily, then we could write a unit test using stubs.
Stubs are simple Java objects that let us 'pretend' to be the real objects:
	We can simulate key strokes in Java, without messing around with the real keyboard
	We can simulate a console - and capture the program output as simple Java strings.
Using these ideas, we can write a fast, not-flaky Unit Test.

Unit tests and Dependency Inversion
Our program's real problem is that it depends on the System.scanner for input and System.out.println
for output.

Our code creates and uses the objects directly.
What if we turned that upside down?
What if we made the code so that it didn't depend on these objects, but instead, provide a way to plug
them in later?

This trick is called dependency inversion.

Second design - using Dependency Inversion
Have a look at this. More code - yes. But better.

Pay attention to:
	interface Guesses - the source of input
	interface Display - where we send text output
	how main() 'wires up' the input and output
	HexagonalGuessMyNumber constructor - look at those parameters

<code>
package com.viewfromthecodeface.hexagonal.adapters;

import com.viewfromthecodeface.hexagonal.domain.Display;

public class ConsoleDisplay implements Display {
	@Override
	public void show(String text) {
	System.out.print(text);
	}
}
</code>

<code>
package com.viewfromthecodeface.hexagonal.adapters;

import com.viewfromthecodeface.hexagonal.domain.Guesses;
import java.util.Scanner;

public class KeyboardGuesses implements Guesses {
	@Override
	public int latestGuess() {
	Scanner keyboard = new Scanner(System.in);
	return keyboard.nextInt();
	}
}
</code>

<code>
package com.viewfromthecodeface.hexagonal.domain;

public interface Display {
	void show(String text);
}
</code>

<code>
package com.viewfromthecodeface.hexagonal.domain;

public interface Guesses {
	int latestGuess();
}
</code>

<code>
package com.viewfromthecodeface.hexagonal.domain;

public class HexagonalGuessMyNumber {
	private final int numberToGuess;
	private Guesses guesses;
	private Display display;

	public HexagonalGuessMyNumber(int numberToGuess, final Guesses guesses, final Display display) {
		this.numberToGuess = numberToGuess;
		this.guesses = guesses;
		this.display = display;
	}

	public void play() {
		displayIntroduction();
		boolean guessedCorrectly = givePlayerUpToFiveAttemptsToGuess();
		displayFinalResult(guessedCorrectly);
	}

	private boolean givePlayerUpToFiveAttemptsToGuess() {
		int attemptNumber = 1;
		boolean guessedCorrectly = false;

		while ( attemptNumber <= 5 && !guessedCorrectly) {
			displayPrompt(attemptNumber);

			if ( guesses.latestGuess() == numberToGuess ){
				guessedCorrectly = true ;
			} else {
				display.show("Try again");
			}

			attemptNumber++;
		}

		return guessedCorrectly;
	}

	private void displayPrompt(int attemptNumber) {
		display.show(String.format("Your Guess? (attempt %d) >", attemptNumber));
	}

	private void displayIntroduction() {
		display.show("I'm thinking of a number between 1 and 10.");
		display.show("Can you guess it, in five guesses?");
	}

	private void displayFinalResult(boolean guessedCorrectly) {
		if ( guessedCorrectly ) {
			display.show("You guessed it! Spooky. Or a good use of binary search...");
		} else {
			display.show("Bad luck. If there's nothing on Netflix, you could try again");
		}
	}
}
</code>

<code>
package com.viewfromthecodeface.hexagonal;

import com.viewfromthecodeface.hexagonal.adapters.ConsoleDisplay;
import com.viewfromthecodeface.hexagonal.adapters.KeyboardGuesses;
import com.viewfromthecodeface.hexagonal.domain.Display;
import com.viewfromthecodeface.hexagonal.domain.Guesses;
import com.viewfromthecodeface.hexagonal.domain.HexagonalGuessMyNumber;

public class Game {
	public static void main ( String[] commandLineArguments ) {
		Display display = new ConsoleDisplay();
		Guesses guesses = new KeyboardGuesses();
		new HexagonalGuessMyNumber(3, guesses, display).play();
	}
}
</code>

In the above HexagonalGuessMyNumber class, the constructor takes our secret number still - but with
two new parameters.
These are our inverted dependencies.
The first one, Guesses, is an interface.
This is the contract defining the way we get input from the user.

But not how it is done.
This is left to the concrete implementing class KeyboardGuesses.
As you would expect, this contains the System.scanner code from our previous example. It is a simple
refactor.

Easy to create new input and output classes
The significance of this is that HexagonalGuessMyNumber knows nothing about where the guesses come from.
You could write many different implementing classes - WebGuesses, CsvFileGuesses and so on - provided
they implement the interface.
Significantly, for Unit Testing, we can write StubGuesses.
This is a simple Java class which allows us to define what simulated keyboard input to supply next. Then
we can assert against that.
Doing this takes the mechanical keyboard - and the human player - out of the equation.

Main chooses which one to use
The next key feature is our main() method.
We create the HexagonalGuessMyNumber object here.
We also create the precise Guesses and Display instances we want to use.
It is here that we can change our minds about where the game reads its guesses from, and where it sends
output to.
And the game object itself does not have to change. An application of the OpenClosed Principle (OCP).
Creating the objects here and passing them in is called Dependency Injection.

Injection - Inversion: Two sides of the same coin
You may have seen the terms Dependency Injection and Dependency Inversion used interchangeably.
This is not quite right.

You always see the two go together, but:
Dependency Inversion is the design decision to take dependencies out of a class
Dependency Injection is how we create those dependencies then pass them in
The three layers of this system
Let's consider the path that some text output takes:

The application's core logic (HexagonalGuessMyNumber) decides on what text to output
This is then transformed into a suitable form (ConsoleDisplay)
This touches the external environment (a Console Window)
If you consider the path of a number being entered at the keyboard, it's the same thing.

The external environment (physical keyboard) gets transformed (KeyboardGuesses) into something usable
by the core logic.
In general terms, we call these three layers

External environment
Adapters
Domain
Outside, the external environment lies outside our application.

It is the operating system calls, the file system, the display and networking technology, our SQL and
NoSQL databases.
Inside, we have our core application logic - the domain model.
This is technology free. It is all about the core rules that makes our application what it is.
To bridge the gap, we must adapt between the two: our adapter layer.
Each adapter contains code that is tightly coupled to the external environment. But it adapts it into a
domain-only form. KeyboardGuesses knows all about reading physical keyboards. But it then adapts it into
the domain interface Guesses. This uses only String - a technology-independent way to represent user input.

Abstracting the real world - Service Interfaces
It's worth noting that everything in the external environment that we need to access, we do via an
interface in the domain layer.
These service interfaces are designed to use only other domain classes/interfaces, and primitive types.
They never refer to any code or convention in the adapter and environment layers.
By doing this, we completely isolate our domain layer from anything outside it.
It's the complete opposite of top-down procedural designs.

So, why call it Hexagonal Architecture?
In our example above, we had two different kinds of dependency. One on an input source, and one on an
output source.

But in real apps, we have many more:
Database
HTTP web server
External Devices
Removable Media
Local Networks
If you draw a diagram with the domain objects in the middle, the external environment outside, and our
adapter layer in the middle you get concentric shapes.


---
https://dzone.com/articles/programming-when-use

When to Use Interfaces in Your Application

   There are several advantages in utilizing the features of Interfaces in general programming. As you
   may already know, interfaces define a set of functionality as a rule or a contract. When you
   implement an interface all of these functionality must be implemented in the concrete class.

   The ideas discussed here can be applied using any programming language that supports Interfaces. Java
   has been used in examples for simplicity.

   In general when one writes a simple program, one may not think about the need of using an Interface.
   But when you are building a larger system or a library which keeps evolving, it is a good idea to use
   Interface. A particular advantage of using interface in Java is that it allows multiple inheritance.

   The full power of Interface is utilized when dependency injection techniques is used to inject
   required implementation on run time. Using references to interfaces instead of their concrete
   implementation classes helps in minimizing [37]ripple effects, as the user of an interface reference
   doesn't have to worry about the changes in the underlying concrete implementation.

   To give an example consider our application has a layered architecture with Controller layer on top
   then Service layer, Repository layer and domain layer in that order. Here controller layer interacts
   with service layer and service layer interacts with repository layer. Each layer is aware of the
   services provided by the layer below it. We expose this information using Interface and hide the
   concrete implementation.

   Let us say we have a UserRegistrationService, which registers a new user in our system. Our
   requirement is to save the user information in a relational database and also in xml files. If we
   were not using interface, the UserRegistrationService may be implemented with two functions
   saveToXML() and saveToDatabase().

<code>
public class UserRegistrationService {
	public void saveToXML(UserInfo userInfo) {
	//save to xml using service exposed by Repository layer
	}
	public void saveToDatabase(UserInfo userInfo) {
	//save to db using service exposed by Repository layer
	}
}
</code>

   In this case, the UserRegistrationController should be aware of the concrete implementation of these
   two functions in UserRegistrationService to use them.

<code>
//Controller becomes complicated when additional features are required
public class UserRegistrationController {
	//Controller should be aware of the implementation when no Interface is used
	UserRegistrationService userRegistrationService = new UserRegistrationService();
	public void processRequest(UserInfo userInfo) {
	this.saveToXml(userInfo);
	}
	private void saveToXml(UserInfo userInfo) {
	userRegistrationService.saveToXml(userInfo);
	}
	private void saveToDatabase(UserInfo userInfo) {
	userRegistrationService.saveToDatabase();
	}
}
</code>

   If an additional functionality to save the information as JSON is required then you will have to add
   a new function saveToJson() in the Service class as well as make changes in the Controller. This adds
   lots of complication to maintenance of our huge application with hundreds of controllers and
   services.

   When using interface this becomes much simpler. We define our UserRegistrationService like this:

<code>
public interface UserRegistrationService {
	public void save();
}

   The controller layer is only aware of this interface, which has a save method.

   Let us say we have two implementations like the following:
public class UserRegistraionServiceXmlImpl implements UserRegistrationService {
	@Override
	public void save(UserInfo userInfo) {
	//save to xml using service exposed by Repository layer
	}
}
public class UserRegistraionServiceRelDbImpl implements UserRegistrationService {
	@Override
	public void save(UserInfo userInfo) {
	//save to relational db using service exposed by Repository layer
	}
}
</code>

   Here we can choose any of these two implementation on run time using dependency injection. One may
   use @Inject or @Resource annotation to mark an implementation is to be injected. If using [38]Spring,
   one may also use Xml bean definitions.

<code>
//Controller becomes much simpler when using Interfaces in the service layer
public class UserRegistrationController {
	@Resource(name = "userRegistrationServiceXmlImpl")
	UserRegistrationService userRegistrationService;
	public void processRequest(UserInfo userInfo) {
	userRegistrationService.save(userInfo);
	}
	public void setUserRegistrationService(UserRegistrationService userRegistrationService) {
	this.userRegistrationService = userRegistrationService;
	}
}
</code>

   Now when we need to add the additional functionality of saving to Json, we just add another
   implementation and select that implementation to be injected. (You may use an IOC{[39]Inversion Of
   Control} container like [40]Spring to achieve this seamlessly.)

<code>
public class UserRegistraionServiceJsonImpl implements UserRegistrationService {
	@Override
	public void save() {
	//save to json using service exposed by Repository layer
	}
}
</code>

   This highly reduces the software modification and extension cost. As changes in one layer does not
   effect other layer and new functionalities are made available to other layer immediately.

   Thus using interface gives you more power over extending and maintaining your application, utilize
   abstraction and implement good software development practices.
   This article was originally published to
   [41]http://tech.deepumohan.com/2013/01/when-to-use-interfaces-in-your.html

---
http://www.java67.com/2014/02/what-is-actual-use-of-interface-in-java.html

What is the Actual Use of interface in Java?

   An interface in Java has remained a complex topic for many beginners to understand. The first thing
   which puzzles many programmers is the fact that you cannot define any method inside interface, it a
   just declaration. By rule, all method inside interface must be abstract (Well, this rule is changing
   in Java 8 to allow lambda expressions, now interface can have one non-abstract method, also known as
   a default method). So, if you can't define anything, Why we need an interface?  what's the use of an
   interface, if we are anyway going to write a class and override them to provide behaviour, Can't we
   declare those methods inside the class itself without using interface etc. Well, if you are thinking
   in terms of behaviour then you are really missing the point of interface.
   I think one has to read [20]Effective Java, to understand best use of interface. Interface is great
   to declare Type, they promote code reusability, and they are the real driver of polymorphism in Java.
   Interface also allows [21]multiple inheritance in Java, which makes it possible for a class to become
   Canvas, as well as EventListener, which is used to draw graphics as well as to to process events.
   In this post, I will share few points, which will help you to understand what is the actual use of
   interface in Java. By the way, if you are confused between abstract class and interface, then you may
   want to read my previous post on [22]difference between interface and abstract class in Java.

Why we need Interface in Java
   There are several reasons, an application developer needs an interface, one of them is Java's feature
   to provide multiple inheritance at interface level. It allows you to write flexible code, which can
   adapt to handle future requirements. Some of the concrete reasons, why you need interface is :
   1) If you only implement methods in subclasses, the callers will not be able to call them via the
   interface (not common point where they are defined).

   2) Java 8 will introduce default implementation of methods inside the interface, but that should be
   used as exception rather than rule. Even Java designer used in that way, it was introduced to
   maintain backward compatibility along with supporting lambda expression. All evolution of Stream API
   was possible due to this change.

   3) Interfaces are a way to declare a contract for implementing classes to fulfil; it's the primary
   tool to create abstraction and decoupled designs between consumers and producers.

   4) Because of multiple inheritance, interface allows you to treat one thing differently. For example
   a class can be treated as Canvas during drawing and EventListener during event processing. Without
   interface, it's not possible for a class to behave like two different entity at two different
   situations. Here is an example of how interface supports multiple inheritance in Java

<code>
interface Canvas{
	public void paint(Graphics g);
}

interface EventListener{
	public boolean process(Event e);
}

pubic class Game implements Canvas, EventListener {

	@Override
	public void paint(Graphics g){
	g.drawLine(Color.RED);
}

	@Override
	public boolean process(Event e){
	KeyCode code =	e.getKeyPressed().getCode();
	}
}
</code>

   5) Interface are key of API design. In fact smaller interface like Comparable, Runnable, Callable
   makes core of Java API. Though great care is required while designing and publishing interface,
   because once published, you can not change interface without breaking up all your clients, i.e.
   classes which have implemented your interface. On extreme case, from Java 8 onwards, you can use
   default method to rescue, but as I said, it should be exception than rule.

   6)  "Programming to interface than implementation" is one of the [24]popular Object oriented design
   principle, and use of interface promotes this. A code written on interface is much more flexible than
   the one which is written on implementation.

   7) Use of interface allows you to supply a new implementation, which could be more robust, more
   performance in later stage of your development.
   In short main use of interface is to facilitate polymorphism. interface allows a class to behave like
   multiple types, which is not possible without multiple inheritance of class. It also ensures that you
   follow programming to interface than implementation pattern, which eventually adds lot of flexibility
   in your system.

---
http://tutorials.jenkov.com/java/interfaces.html
Last update: 2018-09-13

Java Interfaces

   Java includes a concept called interfaces. A Java interface is a bit like a class, except a Java
   interface can only contain method signatures and fields. An Java interface cannot contain an
   implementation of the methods, only the signature (name, parameters and exceptions) of the method.

   You can use interfaces in Java as a way to achieve polymorphism. I will get back to polymorphism
   later in this text.

Java Interface Example

   Here is a simple Java interface example:

<code>
public interface MyInterface {

	public String hello = "Hello";

	public void sayHello();
}
</code>

   As you can see, an interface is declared using the Java interface keyword. Just like with classes, a
   Java interface can be declared public or package scope (no access modifier).

   The interface example above contains one variable and one method. The variable can be accessed
   directly from the interface, like this:
System.out.println(MyInterface.hello);

   As you can see, accessing a variable from an interface is very similar to accessing a static variable
   in a class.

   The method, however, needs to be implemented by some class before you can access it. The next section
   will explain how that is done.

Implementing an Interface
   Before you can really use an interface, you must implement that interface in some Java class. Here is
   a class that implements the MyInterface interface shown above:
<code>
public class MyInterfaceImpl implements MyInterface {

	public void sayHello() {
	System.out.println(MyInterface.hello);
	}
}
</code>

   Notice the implements MyInterface part of the above class declaration. This signals to the Java
   compiler that the MyInterfaceImpl class implements the MyInterface interface.

   A class that implements an interface must implement all the methods declared in the interface. The
   methods must have the exact same signature (name + parameters) as declared in the interface. The
   class does not need to implement (declare) the variables of an interface. Only the methods.

Interface Instances
   Once a Java class implements an Java interface you can use an instance of that class as an instance
   of that interface. Here is an example:
<code>
MyInterface myInterface = new MyInterfaceImpl();

myInterface.sayHello();
</code>

   Notice how the variable is declared to be of the interface type MyInterface while the object created
   is of type MyInterfaceImpl. Java allows this because the class MyInterfaceImpl implements the
   MyInterface interface. You can then reference instances of the MyInterfaceImpl class as instances of
   the MyInterface interface.

   You cannot create instances of a Java interface by itself. You must always create an instance of some
   class that implements the interface, and reference that instance as an instance of the interface.

Implementing Multiple Interfaces
   A Java class can implement multiple Java interfaces. In that case the class must implement all the
   methods declared in all the interfaces implemented. Here is an example:
<code>
public class MyInterfaceImpl
	implements MyInterface, MyOtherInterface {

	public void sayHello() {
	System.out.println("Hello");
	}

	public void sayGoodbye() {
	System.out.println("Goodbye");
	}
}
</code>

   This class implements two interfaces called MyInterface and MyOtherInterface. You list the names of
   the interfaces to implement after the implements keyword, separated by a comma.

   If the interfaces are not located in the same packages as the implementing class, you will also need
   to import the interfaces. Java interfaces are imported using the import instruction just like Java
   classes. For instance:
<code>
import com.jenkov.package1.MyInterface;
import com.jenkov.package2.MyOtherInterface;

public class MyInterfaceImpl implements MyInterface, MyOtherInterface {
	...
}
</code>

   Here are the two Java interfaces implemented by the class above:
<code>
public interface MyInterface {

	public void sayHello();
}

public interface MyOtherInterface {

	public void sayGoodbye();
}
</code>
   As you can see, each interface contains one method. These methods are implemented by the class
   MyInterfaceImpl.

Overlapping Method Signatures
   If a Java class implements multiple Java interfaces, there is a risk that some of these interfaces
   may contain methods with the same signature (name + parameters). Since a Java class can only
   implement at method with a given signature once, this could potentially lead to some problems.

   The Java specification does not give any solution to this problem. It is up to you to decide what to
   do in that situation.

Which Java Types Can Implement Interfaces?

   The following Java types can implement interfaces:
	 * Java Class
	 * Java Abstract Class
	 * Java Nested Class
	 * Java Enum

Interface Variables
   A Java interface can contain both variables and constants. However, often it does not makes sense to
   place variables in an interface. In some cases it can make sense to define constants in an interface.
   Especially if those constants are to be used by the classes implementing the interface, e.g. in
   calculations, or as parameters to some of the methods in the interface. However, my advice to you is
   to avoid placing variables in Java interfaces if you can.

   All variables in an interface are public, even if you leave out the public keyword in the variable
   declaration.

Interface Methods
   A Java interface can contain one or more method declarations. As mentioned earlier, the interface
   cannot specify any implementation for these methods. It is up to the classes implementing the
   interface to specify an implementation.

   All methods in an interface are public, even if you leave out the public keyword in the method
   declaration.

Interface Default Methods
   Before Java 8 Java interfaces could not contain an implementation of the methods, but only contain
   the method signatures. However, this results in some problems when an API needs to add a method to
   one of its interfaces. If the API just adds the method to the desired interface, all classes that
   implements the interface must implement that new method. That is fine if all implementing classes are
   located within the API. But if some implementing classes are located in client code of the API (the
   code that uses the API), then that code breaks.

   Let me illustrate this with an example. Look at this interface and imagine that it is part of e.g. an
   open source API which many applications are using internally:
<code>
public interface ResourceLoader {

	Resource load(String resourcePath);

}
</code>

   Now imagine that a project uses this API and has implemented the ResourceLoader interface like this:
<code>
public class FileLoader implements ResourceLoader {

	public Resource load(String resourcePath) {
	// in here is the implementation +
	// a return statement.
	}
}
</code>

   If the developer of the API wants to add one more method to the ResourceLoader interface, then the
   FileLoader class will be broken when that project upgrades to the new version of the API.

   To alleviate this Java interface evolution problem, Java 8 has added the concept of interface default
   methods to Java interfaces. An interface default method can contain a default implementation of that
   method. Classes that implement the interface but which contain no implementation for the default
   interface will then automatically get the default method implementation.

   You mark a method in an interface as a default method using the default keyword. Here is an example
   of adding a default method to the ResourceLoader interface:
<code>
public interface ResourceLoader {

	Resource load(String resourcePath);

	default Resource load(Path resourcePath) {
	// provide default implementation to load
	// resource from a Path and return the content
	// in a Resource object.
	}

}
</code>

   This example adds the default method load(Path). The example leaves out the actual implementation
   (inside the method body) because this is not really interesting. What matters is how you declare the
   interface default method.

   A class can override the implementation of a default method simply by implementing that method
   explicitly, as is done normally when implementing a Java interface. Any implementation in a class
   takes precedence over interface default method implementations.

Interfaces and Inheritance
   It is possible for a Java interface to inherit from another Java interface, just like classes can
   inherit from other classes. You specify inheritance using the extends keyword. Here is a simple
   interface inheritance example:
<code>
public interface MySuperInterface {
	public void saiHello();
}

public interface MySubInterface extends MySuperInterface {
	public void sayGoodbye();
}
</code>

   The interface MySubInterface extends the interface MySuperInterface. That means, that the
   MySubInterface inherits all field and methods from MySuperInterface. That then means, that if a class
   implements MySubInterface, that class has to implement all methods defined in both MySubInterface and
   MySuperInterface.

   It is possible to define methods in a subinterface with the same signature (name + parameters) as
   methods defined in a superinterface, should you find that desirable in your design, somehow.

   Unlike classes, interfaces can actually inherit from multiple superinterfaces. You specify that by
   listing the names of all interfaces to inherit from, separated by comma. A class implementing an
   interface which inherits from multiple interfaces must implement all methods from the interface and
   its superinterfaces.

   Here is an example of a Java interface that inherits from multiple interfaces:
<code>
public interface MySubInterface extends
	SuperInterface1, SuperInterface2 {

	public void sayItAll();
}
</code>

   As when implementing multiple interfaces, there are no rules for how you handle the situation when
   multiple superinterfaces have methods with the same signature (name + parameters).

Inheritance and Default Methods
   Interface default methods add a bit complexity to the rules of interface inheritance. While it is
   normally possible for a class to implement multiple interfaces even if the interfaces contain methods
   with the same signature, this is not possible if one or more of these methods are default methods. In
   other words, if two interfaces contain the same method signature (name + parameters) and one of the
   interfaces declare this method as a default method, a class cannot automatically implement both
   interfaces.

   The situation is the same if an interface extends (inherits from) multiple interfaces, and one or
   more of these interfaces contain methods with the same signature, and one of the superinterfaces
   declare the overlapping method as a default method.

   In both of the above situations the Java compiler requires that the class implementing the
   interface(s) explicitly implements the method which causes the problem. That way there is no doubt
   about which implementation the class will have. The implementation in the class takes precedence over
   any default implementations.

Interfaces and Polymorphism
   Java interfaces are a way to achieve polymorphism. Polymorphism is a concept that takes some practice
   and thought to master. Basically, polymorphism means that an instance of an class (an object) can be
   used as if it were of different types. Here, a type means either a class or an interface.

   Look at this simple class diagram:

		+---------+				 +--------+
		| Vehicle |				 | Driver |
		+---------+				 +--------+
			|					 |
		+-------+-------+		 +-----------+-----------+
		|			|		 |				 |
	+---------+		+--------+	  +-----------+    +-------------+
	|	Car   |		| Truck  |	  | CarDriver |    | TruckDriver |
	+---------+		+--------+	  +-----------+    +-------------+

   Two parallel class hierarchies used in the same application.

   The classes above are all parts of a model representing different types of vehicles and drivers, with
   fields and methods. That is the responsibility of these classes - to model these entities from real
   life.

   Now imagine you needed to be able to store these objects in a database, and also serialize them to
   XML, JSON, or other formats. You want that implemented using a single method for each operation,
   available on each Car, Truck or Vehicle object. A store() method, a serializeToXML() method and a
   serializeToJSON() method.

   Please forget for a while, that implementing this functionality as methods directly on the objects
   may lead to a messy class hierarchy. Just imagine that this is how you want the operations
   implemented.

   Where in the above diagram would you put these three methods, so they are accessible on all classes?

   One way to solve this problem would be to create a common superclass for the Vehicle and Driver
   class, which has the storage and serialization methods. However, this would result in a conceptual
   mess. The class hierarchy would no longer model vehicles and drivers, but also be tied to the storage
   and serialization mechanisms used in your application.

   A better solution would be to create some interfaces with the storage and serialization methods on,
   and let the classes implement these interfaces. Here are examples of such interfaces:

<code>
public interface Storable {

	public void store();
}

public interface Serializable {
	public void serializeToXML(Writer writer);
	public void serializeToJSON(Writer writer);
}
</code>

   When each class implements these two interfaces and their methods, you can access the methods of
   these interfaces by casting the objects to instances of the interface types. You don't need to know
   exactly what class a given object is of, as long as you know what interface it implements. Here is an
   example:
<code>
Car car = new Car();

Storable storable = (Storable) car;
storable.store();

Serializable serializable = (Serializable) car;
serializable.serializeToXML (new FileWriter("car.xml"));
serializable.serializeToJSON(new FileWriter("car.json"));
</code>

   As you can probably imagine by now, interfaces provide a cleaner way of implementing cross cutting
   functionality in classes than inheritance.

Static Methods in Java Interfaces
   A Java interface can have static methods. Static methods in a Java interface must have
   implementation. Here is an example of a static method in a Java interface:
<code>
public interface MyInterface {

	public static void print(String text){
	System.out.print(text);
	}
}
</code>

   Calling a static method in an interface looks and works just like calling a static method in a class.
   Here is an example of calling the static print() method from the above MyInterface interface:
MyInterface.print("Hello static method!");

   Static methods in interfaces can be useful when you have some utility methods you would like to make
   available, which fit naturally into an interface related to the same responsibility. For instance, a
   Vehicle interface could have a printVehicle(Vehicle v) static method.

   Next: Java Interfaces vs. Abstract Classes
   
---   
https://javatutorial.net/java-interface-example

Java Interface Example
August 10, 2017

   In this tutorial I will show you how to create and work with Java Interfaces. As always I will
   demonstrate a practical example of a Java interface.

What is Java Interface?
   As many other Java concepts, Interfaces are derived from real-world scenarios with the main purpose
   to use an object by strict rules. For example, if you want to turn on the washing machine to wash
   your clothes you need to press the start button. This button is the interface between you and the
   electronics inside the washing machine. Java interfaces have same behaviour: they set strict rules on
   how to interact with objects. To find more about [20]Java objects read this tutorial.

   The Java interface represents a group of methods with empty bodies. Well, it is not mandatory to have
   a whole list of methods inside an interface - they can be 0 or more... but, no matter the number of
   methods, they all should be empty.

Create an Interface
   Using the example with the washing machine, lets create an Interface called WashingMachine with one
   method startButtonPressed()
<code>
public interface WashingMachine {
	public void startButtonPressed();
}
</code>

   That's all you need to define an interface. Note the usage of the keyword interface. The
   method startButtonPressed()has no body. It just ends with ; Of course you can also use methods with
   return types and parameters like: public int changeSpeed(int speed);

How to Implement an Interface
   Now we will create a class that implements our interface. To continue with the example we will create
   a washing machine of specific make that has the start button.
<code>
public class SamsungWashingMachine implements WashingMachine {

	@Override
	public void startButtonPressed() {
		System.out.println("The Samsung washing machine is now running.");
	}

}
</code>

   We use the implements keyword in the class declaration. We need to implement the startButtonPressed
   method (give it some functionality) or otherwise our class will not compile.

   Please note, you can implement more than one interface in one class you just need to separate the
   interface names with commas in the class declaration like this:
public class SamsungWashingMachine implements WashinMachine, Serializable, Comparable<WashinMachine> { ... }

Test your Interface
   Now lets create a small program to test our interface and the implementation
<code>
public class Test {
	public static void main(String[] args) {
		WashinMachine samsungWashinMachine = new SamsungWashingMachine();
		samsungWashinMachine.startButtonPressed();
	}
}
</code>
   and the output of the program will be:
The Samsung washing machine is now running.

Use Interfaces to Declare Specific Object Characteristics
   There is another common usage of interfaces in Java - to tell a object has specific use or
   characteristics.

   Lets give one more real-world example. You are a survival in the woods. You find different object and
   put them in your backpack for later use. When you rest you go through the found objects and eat the
   once that are eatable.

   First, lets define an interface called FoundObject with no methods at all. Those are all the objects
   we found in the woods:
<code>
public interface FoundObject {

}
</code>

   now we define a second interface called Eatable. We will use it just to denote if the object is
   eatable or not
<code>
public interface Eatable {
	public void eat();
}
</code>

   With the following three classes we will define the objects we find in the woods - apples,
   raspberries and stones
<code>
public class Apple implements FoundObject, Eatable {

	private String name;

	public Apple(String name) {
		this.name = name;
	}

	@Override
	public void eat() {
		System.out.println("Yummy! you eat some " + this.name);
	}

}

public class Raspberry implements FoundObject, Eatable {

	private String name;

	public Raspberry(String name) {
		this.name = name;
	}

	@Override
	public void eat() {
		System.out.println("Yummy! you eat some " + this.name);
	}

}

public class Stone implements FoundObject {

	private String name;

	public Stone(String name) {
		this.name = name;
	}

}
</code>

   Now lets write the survival program. We will collect found objects in our backpack (array) and try to
   eat them
<code>
public class WoodsSurvival {

	public static void main(String[] args) {
		// create an array of type FoundObject
		FoundObject backpack [] = new FoundObject[3];

		// create the objects we found in the woods
		FoundObject apple = new Apple("apple");
		FoundObject stone = new Stone("stone");
		FoundObject raspberry = new Raspberry("raspberry");

		// add the found objects to the backpack
		backpack[0] = apple;
		backpack[1] = stone;
		backpack[2] = raspberry;

		// iterate over the found objects
		for (int i=0; i<backpack.length; i++) {
			FoundObject currentObject = backpack[i];
			// check if object is eatable
			if (currentObject instanceof Eatable) {
				// cast the object to eatable and execute eat method
				((Eatable) currentObject).eat();
			}
		}

	}

}
</code>

   The output of the program is:
Yummy! you eat some apple
Yummy! you eat some raspberry

   The code explained
   First we create the interface FoundObject with the sole purpose to denote the objects of specific
   type, so we can put them in the same array. We create the Eatable interface to mark which objects can
   be eaten.

   When we create the three objects (apple, raspberry and stone) we put implements FoundObject in the
   class declaration for all of them, and the one we can eat also implement the Eatable interface.

   In WoodsSurvival class we first create an array of type FoundObject. The three object we create later
   are also of type FoundObject so we can put them in the same array.

   When we iterate the array we check if the current object is of type Eatable. We do this with the help
   of instanceof keyword. instanceof returns true if two objects are of the same type. In our case
   apples and raspberries will return true when checked with instanceof Eatable, because both implement
   the Eatable interface. To be able to execute the eat() method we need to explicitly typecast the
   object to Eatable first. We achieve this with following line of code:
((Eatable) currentObject).eat();

   We can not execute the eat method of a stone object, because it is not of type Eatable.

Disclaimer
   The code example above can be written in more fashionable way using abstract classes, Collections and
   inheritance. Some of those are more advanced topics and are explained in next tutorials. This is a
   beginner tutorial that intents to explain java interfaces only.

---
