filename: jv-convert-jar-file-to-executable-jar-file-multif-20260128.txt
https://www.quora.com/How-do-you-convert-a-JAR-file-to-an-executable-JAR-file

How do you convert a JAR file to an executable JAR file?

***
An executable JAR (fat/uber JAR or simply a JAR with a Main-Class) is a JAR file that the JVM can run directly
with java -jar myapp.jar. Converting a normal JAR into an executable one involves two possible goals: 1) make
the JAR runnable by specifying an entry point (Main-Class) and ensuring needed classes/resources are present,
or 2) package all dependencies into a single runnable JAR (fat/uber JAR). Steps for both:

1) Make a JAR runnable by setting Main-Class
- Identify the class that contains public static void main(String[] args).
- Create a manifest file (manifest.mf) containing at minimum:

Manifest-Version: 1.0
Main-Class: com.example.Main

(Ensure a trailing newline.)

Rebuild or update the JAR to include the manifest:
  Using jar tool to create a new JAR:
$> jar cfm app.jar manifest.mf -C classes/ .

To update an existing JAR's manifest:
$> jar umf manifest.mf existing.jar

Run it:
$> java -jar app.jar

Note: If your program depends on external libraries referenced via Class-Path in the manifest, those jars must
be present or you must create an uber JAR (next).

2) Produce a runnable fat/uber JAR (include dependencies)
- Using build tools (recommended)
- Maven (with maven-assembly-plugin or maven-shade-plugin)

Example (maven-shade): add plugin and configure wzxhzdk:0  to set Main-Class; then mvn package produces
shaded jar.

- Gradle (with the Shadow plugin or the application plugin)
  apply plugin: 'com.github.johnrengelman.shadow' then gradle shadowJar produces a fat jar and you can
  configure manifest { attributes 'Main-Class': 'com.example.Main' }. 

Using command-line tools (manual):
 - Unzip your JAR and all dependency JARs into a temporary directory, taking care to merge META-INF/services
   and avoid duplicate manifest collisions.

 - Recreate the JAR with a manifest that sets Main-Class:
   $> jar cfm myapp-fat.jar manifest.mf -C tmpdir .

 - Risks: class/resource conflicts, signature/META-INF issues.

 - Using launch4j / jpackage / native wrappers:
   Wrap the JAR as a native executable (Windows EXE, macOS app, native image). Tools: launch4j, jpackage
   (since JDK 14+), GraalVM native-image. These produce platform-specific executables rather than a runnable
   JAR.

3) Troubleshooting common issues
- NoMainManifestException: Manifest missing Main-Class or incorrect path. Verify fully qualified class name
  and manifest formatting (blank line at end).
- ClassNotFoundException: Dependencies missing. Use fat JAR or provide Class-Path entries plus external jars.
- Duplicate resources / service loader conflicts: Use build-tool transformers/mergers (maven-shade / shadow
  plugin) to merge service files and avoid duplicate META-INF content.
- Signed jars: Repackaging invalidates signatures; resign if needed.

4) Quick practical examples
- Minimal manual:
$> echo "Manifest-Version: 1.0\nMain-Class: com.example.Main" > manifest.mf
$> jar cfm app.jar manifest.mf -C classes/ .

5) Security & distribution notes
- Keep JVM version compatibility in mind (compile target vs runtime).
- Consider minimizing classpath and using modular jlink/jpackage for smaller distributables.
- For cross-platform native executables, evaluate jpackage or GraalVM native-image (requires code adaptation
  and testing).

Summary checklist
  - Confirm main class exists.
  - Add Main-Class to MANIFEST.MF.
  - Include dependencies either via Class-Path or build a fat JAR (recommended via Maven/Gradle plugins).
  - Repackage and run with java -jar app.jar or produce a native wrapper if desired.

***
That depends on how you got the JAR file. If you created it yourself, you can definitely create it in a way
that is executable. If you got it from somewhere else, that may be more challenging.

There are two elements required for a JAR file to be executable. First, it needs to have some class in it that
can play the role of a "main class" to be run when the JAR is run. That means, the class needs to have a
public, static, void method named main, which takes an array of strings as its argument.

<code>
package my.package;

public class MyMainClass {
	public static void main(String[] args) {
		System.out.println("My main class ran!");
	}
}
</code>

If you compile that class and put it in a jar, say "my.jar" this allows you to tell java to "run" the jar
file, as long as you specify the name of that class on the command line:
$> java -cp my.jar my.package.MyMainClass

The second half of the concept of an executable jar is that the jar file itself identifies the main class to
be run if you don't specify one on the command line. This is done by adding a line to the jar's manifest (a
file named MANIFEST.MF which exists at the top level of the jar archive). A minimal version of such a file
would look like this:

    Manifest-Version: 1.0
    Main-Class: my.package.MyMainClass

Once the jar file contains this information in its manifest, it is "executable", and you can run it by simply
saying:
$> java -jar my.jar

Often, a computer's windowing environment can be configured to launch executable jars that way by just
double-clicking on them, but the details of that depend on your operating system.

The jar command can also help you set up the manifest this way, to save you from worrying about getting the
details of the format, fields, spacing, and newlines correct. Assuming you've compiled all your Java classes
into the directory classes it would look like this:
$> jar cvfe my.jar my.package.MyMainClass classes

The "e" flag to jar tells it you are going to give it the main class name next, and it sets up a corresponding
manifest file when it creates the jar.

Now, as I mentioned at the beginning, if you are dealing with a jar you received from somewhere else, this is
trickier. You will have to look inside the jar archive and find the proper class that has a main method for
executing as a main class, and then edit the manifest file to add the Main-Class: entry to point to that
class.

It's even worse if there is no suitable main class; you will have to write one, compile it, add it into the
jar archive and then edit the manifest to point to it.

***
How do I make a JAR file executable in Linux?

There are two answers. They apply equally well to other operating systems. The first is that you set the file
permissions to make the file executable. Under Linux, you can do this with:
$> chmod +x foo.jar

Done. The file is executable.

The second answer is that the Linux kernel can't execute that file. Neither can the Windows kernel. You can
tell your GUI environment to associate jar files with Java and use the JVM to run them. That is, what will
actually be executed will be the java command, which the jar file as an argument. How to do that depends on
which desktop environment you're using.

And it doesn't work from the command line. But, I hear you objecting, I can make shell scripts, Perl scripts,
Python scripts, etc. executable. That's because there's a magic number that can appear at the beginning of an
executable file that tells the kernel to read the file as a text file and use the first line, minus the two
bytes of that magic number as a command to execute with the script as its input. That magic number is #!, or
the numeric equivalent of those two bytes in ASCII. That's why you'll see shell scripts, etc. starting with
#!/bin/sh. This works in the interpreted languages that use it because they use # as a comment character. From
the script's point of view, that first line is a comment.

Of course, a jar file is a tar file with some specific content. And tar files aren't intended to be
executable. There is no comment syntax because they are archives, which a structure to them rather than code
which has a much freer format. The best you can do is get your GUI desktop environment to run java when you
attempt to open a jar file.

***
An executable jar is one with main class mentioned in a manifest file.

From the command line, the executable jar can be executed like this:
$> java -jar ExecutableJarName.jar

To use it in a script file, you can just put the above command into an sh/bat file. like this:
$> echo 'java -jar ExecutableJarName.jar' > script. sh

After that you can execute your script like this:
$> sh script. sh

Note: The java command shown assumes that Java is there in your system path, and the jar is available in the
current folder. Else you may have to specify the full file path and name.


---
https://introcs.cs.princeton.edu/java/85application/jar/jar.html

Distributing your Application as an executable JAR file

   A JAR (Java ARchive) is a way of packaging together all of the resources associated with a program
   (class files, images, sounds, etc.). Putting your program in a JAR allows it to be distributed as a
   single executable file, saving space and simplifying the download process. The information in this
   tutorial applies to Java version 1.2 or higher. For more information about JAR files, follow Sun's
   tutorial. To learn about signing the JAR and Java Web Start.

   A simple example. Let's say we wanted to distribute the simple program Hello.java as a JAR. First,
   we create a text file named Hello.mf which contains:

Manifest-Version: 1.0
Main-Class: Hello

   Then, we create the archive by typing:
$> jar cmf Hello.mf Hello.jar Hello.class Hello.java

   and run it by typing:
$> java -jar Hello.jar

   The file Hello.jar can now be downloaded and executed.

   Creating an executable JAR file. Here is the general procedure for creating an executable JAR:
    1. Compile your java code, generating all of the program's class files.
    2. Create a manifest file containing the following 2 lines:

Manifest-Version: 1.0
Main-Class: name of class containing main

       The name of the file should end with the .mf suffix. It is important that the file ends with a
       blank line.

    3. To create the JAR, type the following command:
$> jar cmf manifest-file jar-file input-files

       The input-files must include any class files, images, sounds, etc. that your program uses.
       Optionally, you can include the program's .java files in the JAR. See below for adding
       directories ot the JAR.

    4. To view the contents of the JAR, type:
$> jar tf jar-file

    5. Execute the application from the command line by typing:
$> java -jar jar-file

       If the application is GUI-based, you can also launch it by double-clicking the JAR file.

   Accessing resources in a JAR. In general, the first step in accessing a JAR resource involves
   creating a URL. This might require modifying your program. For example, you can no longer use the
   following code fragment to read in an image that is stored in a file as follows

Image image = Toolkit.getDefaultToolkit().getImage(filename);

   Instead, create the URL object using

URL url = getClass.getResource(filename);
Image image = Toolkit.getDefaultToolkit().getImage(url);

   Or, if the code is in a static method of class X, then create the URL with

URL url = X.class.getResource(filename);

   Now, the resource can be accessed the same way, regardless of whether it is in a JAR or the current
   directory. See the method play(filename) in StdDraw.java for an example involving audio clips, and
   and the constructor In(String s) in In.java for an example involving text files.

   JAR Subdirectories. The JAR format also support storing files in a directory structure. Consider a
   program Sample.java, which uses the Turtle Graphics interface to display a collection of pictures
   stored in a subdirectory called images. Our working directory looks like:

+-- MyDirectory/
	+-- Sample.java
	+-- Turtle.java
	+-- Images/
		+-- image1.jpg
		+-- image2.jpg
		+-- image3.jpg
	+-- Sample.class
	+-- Turtle.class
	+-- Sample.mf

   The Manifest should read:

Manifest-Version: 1.0
Main-Class: Sample

   To create the JAR, type:
$> jar cmf Sample.mf Sample.jar Sample.class Turtle.class Sample.java Turtle.java images

   The contents listing appears as:

META-INF/
META-INF/MANIFEST.MF
Sample.class
Turtle.class
Sample.java
Turtle.java
images/
images/image1.gif
images/image2.gif
images/image3.gif

   Notice that the directory structure is still preserved (the META-INF directory is created to hold the
   manifest and other general information about the JAR).


---

