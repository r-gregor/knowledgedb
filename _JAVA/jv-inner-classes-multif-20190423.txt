filename: jv_inner-classes_multif_20190423.txt
https://www.geeksforgeeks.org/inner-class-java/

Inner class in java

   Inner class means one class which is a member of another class. There are basically four types of
   inner classes in java.

   1) Nested Inner class
   2) Method Local inner classes
   3) Anonymous inner classes
   4) Static nested classes

   Nested Inner class can access any private instance variable of outer class. Like any other instance
   variable, we can have access modifier private, protected, public and default modifier.
   Like class, interface can also be nested and can have access specifiers.

   Following example demonstrates a nested class.
   filter_none


<code>
class Outer {
    // Simple nested inner class
    class Inner {
        public void show() {
            System.out.println("In a nested class method");
        }
    }
}

class Main {
    public static void main(String[] args) {
        Outer.Inner in = new Outer().new Inner();
        in.show();
    }
}
</code>

   Output:
In a nested class method

   As a side note, we can't have static method in a nested inner class because an inner class is
   implicitly associated with an object of its outer class so it cannot define any static method for
   itself. For example the following program doesn't compile.

<code>
class Outer {
    void outerMethod() {
        System.out.println("inside outerMethod");
    }

    class Inner {
        public static void main(String[] args){
            System.out.println("inside inner class Method");
        }
    }
}
</code>

   Output:
Error illegal static declaration in inner class
Outer.Inner public static void main(String[] args)
modifier 'static' is only allowed in constant
variable declaration

   An interface can also be nested and nested interfaces have some interesting properties. We will be
   covering nested interfaces in the next post.

   Method Local inner classes
   Inner class can be declared within a method of an outer class. In the following example, Inner is an
   inner class in outerMethod().

<code>
class Outer {
    void outerMethod() {
        System.out.println("inside outerMethod");
        // Inner class is local to outerMethod()
        class Inner {
            void innerMethod() {
                System.out.println("inside innerMethod");
            }
        }
        Inner y = new Inner();
        y.innerMethod();
    }
}

class MethodDemo {
    public static void main(String[] args) {
        Outer x = new Outer();
        x.outerMethod();
    }
}
</code>

   Output
Inside outerMethod
Inside innerMethod

   Method Local inner classes can't use local variable of outer method until that local variable is not
   declared as final. For example, the following code generates compiler error (Note that x is not final
   in outerMethod() and innerMethod() tries to access it)

<code>
class Outer {
    void outerMethod() {
        int x = 98;
        System.out.println("inside outerMethod");
        class Inner {
            void innerMethod() {
                System.out.println("x= " + x);
            }
        }
        Inner y = new Inner();
        y.innerMethod();
    }
}

class MethodLocalVariableDemo {
     public static void main(String[] args) {
        Outer x=new Outer();
        x.outerMethod();
    }
}
</code>

   Output:
local variable x is accessed from within inner class;
needs to be declared final

   Note: Local inner class cannot access non-final local variable till JDK 1.7. Since JDK 1.8, it is
   possible to access the non-final local variable in method local inner class.

   But the following code compiles and runs fine (Note that x is final this time)

<code>
class Outer {
    void outerMethod() {
        final int x=98;
        System.out.println("inside outerMethod");
        class Inner {
            void innerMethod() {
                System.out.println("x = "+x);
            }
        }
        Inner y = new Inner();
        y.innerMethod();
    }
}

class MethodLocalVariableDemo {
    public static void main(String[] args){
        Outer x = new Outer();
        x.outerMethod();
    }
}
</code>

   Output:

Inside outerMethod
X = 98

   The main reason we need to declare a local variable as a final is that local variable lives on stack
   till method is on the stack but there might be a case the object of inner class still lives on the
   heap.

   Method local inner class can't be marked as private, protected, static and transient but can be
   marked as abstract and final, but not both at the same time.

   Static nested classes
   Static nested classes are not technically an inner class. They are like a static member of outer
   class.

<code>
class Outer {
    private static void outerMethod() {
        System.out.println("inside outerMethod");
    }

    // A static inner class
    static class Inner {
        public static void main(String[] args) {
            System.out.println("inside inner class Method");
            outerMethod();
        }
    }
}
</code>

   Output
inside inner class Method
inside outerMethod

   Anonymous inner classes
   Anonymous inner classes are declared without any name at all. They are created in two ways.
   a) As subclass of specified type

<code>
class Demo {
    void show() {
        System.out.println("i am in show method of super class");
    }
}

class Flavor1Demo {

    //  An anonymous class with Demo as base class
    static Demo d = new Demo() {
        void show() {
            super.show();
            System.out.println("i am in Flavor1Demo class");
        }
    };

    public static void main(String[] args){
         d.show();
    }
}
</code>

   Output
i am in show method of super class
i am in Flavor1Demo class

   In the above code, we have two class Demo and Flavor1Demo. Here demo act as super class and anonymous
   class acts as a subclass, both classes have a method show(). In anonymous class show() method is
   overridden.

   b) As implementer of the specified interface

<code>
class Flavor2Demo {

    // An anonymous class that implements Hello interface
    static Hello h = new Hello() {
        public void show() {
            System.out.println("i am in anonymous class");
        }
    };

    public static void main(String[] args) {
        h.show();
    }
}

interface Hello {
    void show();
}
</code>

   Output:
i am in anonymous class

   In above code we create an object of anonymous inner class but this anonymous inner class is an
   implementer of the interface Hello. Any anonymous inner class can implement only one interface at one
   time. It can either extend a class or implement interface at a time.


---
https://www.journaldev.com/996/java-inner-class

Java Inner Class

   Java inner class is defined inside the body of another class. Java inner class can be declared
   private, public, protected, or with default access whereas an outer class can have only public or
   default access.

   Java Nested classes are divided into two types.
    1. static nested class
       If the nested class is static, then it's called a static nested class. Static nested classes can
       access only static members of the outer class. A static nested class is the same as any other
       top-level class and is nested for only packaging convenience.
       A static class object can be created with the following statement:

OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();


    2. java inner class
       java inner class
       Any non-static nested class is known as inner class in java. Java inner class is associated with
       the object of the class and they can access all the variables and methods of the outer class.
       Since inner classes are associated with the instance, we can't have any static variables in them.
       The object of java inner class are part of the outer class object and to create an instance of
       the inner class, we first need to create an instance of outer class.
       Java inner class can be instantiated like this:

OuterClass outerObject = new OuterClass();
OuterClass.InnerClass innerObject = outerObject.new InnerClass();


   There are two special kinds of Java inner classes.
    1. local inner class
       If a class is defined in a method body, it's known as local inner class.
       Since the local inner class is not associated with Object, we can't use private, public or
       protected access modifiers with it. The only allowed modifiers are abstract or final.
       A local inner class can access all the members of the enclosing class and local final variables
       in the scope it's defined. Additionally, it can also access a non-final local variable of the
       method in which it is defined, but it cannot modify them. So if you try to print non-final local
       variable's value it will be allowed but if you try to change its value from inside method local
       inner class, you will get compile time Error.
       Local inner class can be defined as:

<code>
package com.journaldev.innerclasses;

public class MainClass {

    private String s_main_class;

    public void print() {
        String s_print_method = "";

        // local inner class inside the method
        class Logger {
            // able to access enclosing class variables
            String name = s_main_class;
            // able to access non-final method variables
            String name1 = s_print_method;

            public void foo() {
                String name1 = s_print_method;
                // Below code will throw compile time error:
                // Local variable s_print_method defined in an enclosing scope must be final
                // or effectively final
                // s_print_method= ":";
            }
        }
        // instantiate local inner class in the method to use
        Logger logger = new Logger();

    }
}

       We can define a local inner class inside any block too, such as static block, if-else block etc.
       However, in this case, the scope of the class will be very limited.

<code>
public class MainClass {

    static {
        class Foo {

        }

        Foo f = new Foo();
    }

    public void bar() {
        if(1 < 2) {
            class Test {

            }
            Test t1 = new Test();
        }
        // Below will throw error because of the scope of the class
        //Test t = new Test();
        //Foo f = new Foo();
    }
}

    2. anonymous inner class
       A local inner class without name is known as anonymous inner class. An anonymous class is defined
       and instantiated in a single statement.
       Anonymous inner class always extend a class or implement an interface. Since an anonymous class
       has no name, it is not possible to define a constructor for an anonymous class.
       Anonymous inner classes are accessible only at the point where it is defined.
       It's a bit hard to define how to create an anonymous inner class, we will see it's real-time
       usage in the test program below.

   Here is a java class showing how to define java inner class, static nested class, local inner class,
   and an anonymous inner class.

   OuterClass.java

<code>
package com.journaldev.nested;

import java.io.File;
import java.io.FilenameFilter;

public class OuterClass {

    private static String name = "OuterClass";
    private int i;
    protected int j;
    int k;
    public int l;

    //OuterClass constructor
    public OuterClass(int i, int j, int k, int l) {
        this.i = i;
        this.j = j;
        this.k = k;
        this.l = l;
    }

    public int getI() {
        return this.i;
    }

    //static nested class, can access OuterClass static variables/methods
    static class StaticNestedClass {
        private int a;
        protected int b;
        int c;
        public int d;

        public int getA() {
            return this.a;
        }

        public String getName() {
            return name;
        }
    }

    //inner class, non-static and can access all the variables/methods of the outer class
    class InnerClass {
        private int w;
        protected int x;
        int y;
        public int z;

        public int getW() {
            return this.w;
        }

        public void setValues() {
            this.w = i;
            this.x = j;
            this.y = k;
            this.z = l;
        }

        @Override
        public String toString() {
            return "w=" + w + ":x=" + x + ":y=" + y + ":z=" + z;
        }

        public String getName() {
            return name;
        }
    }

    //local inner class
    public void print(String initial) {
        //local inner class inside the method
        class Logger {
            String name;

            public Logger(String name) {
                this.name = name;
            }

            public void log(String str) {
                System.out.println(this.name + ": " + str);
            }
        }

        Logger logger = new Logger(initial);
        logger.log(name);
        logger.log("" + this.i);
        logger.log("" + this.j);
        logger.log("" + this.k);
        logger.log("" + this.l);
    }

    //anonymous inner class
    public String[] getFilesInDir(String dir, final String ext) {
        File file = new File(dir);
        //anonymous inner class implementing FilenameFilter interface
        String[] filesList = file.list(new FilenameFilter() {

            @Override
            public boolean accept(File dir, String name) {
                return name.endsWith(ext);
            }

        });
        return filesList;
    }
}
</code>

   Here is the test program showing how to instantiate and use the inner class in java.

   InnerClassTest.java

<code>
package com.journaldev.nested;

import java.util.Arrays;
//nested classes can be used in import for easy instantiation
import com.journaldev.nested.OuterClass.InnerClass;
import com.journaldev.nested.OuterClass.StaticNestedClass;

public class InnerClassTest {

    public static void main(String[] args) {
        OuterClass outer = new OuterClass(1,2,3,4);

        //static nested classes example
        StaticNestedClass staticNestedClass = new StaticNestedClass();
        StaticNestedClass staticNestedClass1 = new StaticNestedClass();

        System.out.println(staticNestedClass.getName());
        staticNestedClass.d=10;
        System.out.println(staticNestedClass.d);
        System.out.println(staticNestedClass1.d);

        //inner class example
        InnerClass innerClass = outer.new InnerClass();
        System.out.println(innerClass.getName());
        System.out.println(innerClass);
        innerClass.setValues();
        System.out.println(innerClass);

        //calling method using local inner class
        outer.print("Outer");

        //calling method using anonymous inner class
        System.out.println(Arrays.toString(outer.getFilesInDir("src/com/journaldev/nested", ".java")));

        System.out.println(Arrays.toString(outer.getFilesInDir("bin/com/journaldev/nested", ".class")));
    }

}
</code>

   Here is the output of the above java inner class example program:

OuterClass
10
0
OuterClass
w=0:x=0:y=0:z=0
w=1:x=2:y=3:z=4
Outer: OuterClass
Outer: 1
Outer: 2
Outer: 3
Outer: 4
[NestedClassTest.java, OuterClass.java]
[NestedClassTest.class, OuterClass$1.class, OuterClass$1Logger.class, OuterClass$InnerClass.class, OuterClass$
StaticNestedClass.class, OuterClass.class]

   Notice that when OuterClass is compiled, separate class files are created for the inner class, local
   inner class, and static nested class.

Benefits of Java Inner Class
    1. If a class is useful to only one class, it makes sense to keep it nested and together. It helps
       in the packaging of the classes.
    2. Java inner classes implements encapsulation. Note that inner classes can access outer class
       private members and at the same time we can hide inner class from outer world.
    3. Keeping the small class within top-level classes places the code closer to where it is used and
       makes the code more readable and maintainable.


---
https://www.programiz.com/java-programming/nested-inner-class

Java Nested and Inner Class

   In this article, you will learn to work with nested and inner classes in Java with the help of
   examples.

   In Java, you can define a class within another class. Such class is known as nested class.
class OuterClass {
    // ...
    class NestedClass {
        // ...
    }
}

   There are two types of nested classes you can create in Java.
     * Non-static nested class (inner class)
     * Static nested class

   Let's first look at non-static nested classes.

Non-Static Nested Class
   Non-static nested class is a class within another class, where the class has access to members of the
   enclosing class (outer class). It is commonly known as inner class.

   Since, inner class exists within the outer class (in order to instantiate an inner class, you must
   first instantiate the outer class).

   Here's example how you can declare Inner classes in Java.

Example 1: Inner class

class CPU {
    double price;
    class Processor {
        double cores;
        String manufacturer;
        double getCache() {
            return 4.3;
        }
    }
    protected class RAM {
        double memory;
        String manufacturer;
        double getClockSpeed() {
            return 5.5;
        }
    }
}

public class Main {
    public static void main(String[] args) {
        CPU cpu = new CPU();
        CPU.Processor processor = cpu.new Processor();
        CPU.RAM ram = cpu.new RAM();
        System.out.println("Processor Cache = " + processor.getCache());
        System.out.println("Ram Clock speed = " + ram.getClockSpeed());
    }
}

   When you run above program, the output will be:
Processor Cache = 4.3
Ram Clock speed = 5.5

   In above program, the class CPU encapsulates two inner classes i.e. Processor and RAM. Since, the
   class RAM is inner class you can declared it as protected.

   In the Main class, the instance of CPU is created at first. And in order to create the instance of
   Processor, the . (dot) operator is used.
CPU.Processor processor = cpu.new Processor();

Accessing Members of Outer Class within Inner Class
   Like we discussed, inner classes can access the members of the outer class. This is possible using
   Java this keyword.

Example 2: Accessing Members

public class Car {
    String carName;
    String carType;
    public Car(String name, String type) {
        this.carName = name;
        this.carType = type;
    }
    private String getCarName() {
        return this.carName;
    }

    class Engine {
        String engineType;
        void setEngine() {
            // Accessing carType property of Car
            if (Car.this.carType.equals("4WD")) {
                // Invoking method getCarName() of Car
                if (Car.this.getCarName().equals("Crysler")) {
                    this.engineType = "Bigger";
                } else {
                    this.engineType = "Smaller";
                }
            } else {
                this.engineType = "Bigger";
            }
        }
        String getEngineType(){
            return this.engineType;
        }
    }
}

public class CarMain {
    public static void main(String[] args) {
        Car car1 = new Car("Mazda", "8WD");
        Car.Engine engine = car1.new Engine();
        engine.setEngine();
        System.out.println("Engine Type for 8WD= " + engine.getEngineType());

        Car car2 = new Car("Crysler", "4WD");
        Car.Engine c2engine = car2.new Engine();
        c2engine.setEngine();
        System.out.println("Engine Type for 4WD = " + c2engine.getEngineType());
    }
}

   When you run above program, the output will be:
Engine Type for 8WD= Bigger
Engine Type for 4WD = Smaller

   In above program, inside the Engine inner class, we used this keyword to get access to the member
   variable carType of outer class Car as:
Car.this.carType.equals("4WD)

   This is possible even though the carType is a private member of Car class.

   You can also see, we've used Car.this to access members of Car. If you had only used this instead of
   Car.this, then it would only represent members inside the Engine class.

   Similarly, we've also invoked method getCarName() from Car using this keyword as:
Car.this.getCarName().equals("Crysler")

   Here, getCarName() method is a private method of Car.

Static Inner Class
   In Java, you can also define a nested class static. Such class is known as static nested class.
   However, they are not called static inner class.

   Unlike inner class, static nested class cannot access the member variables of the outer
   class because static nested class doesn't require you to create an instance of outer class. Hence, no
   reference of the outer class exists with OuterClass.this.

   So, you can create instance of static nested class directly like this:
OuterClass.InnerClass obj = new OuterClass.InnerClass();

Example 3: Static Inner Class

Public class MotherBoard {
    String model;
    public MotherBoard(String model) {
        this.model = model;
    }
    static class USB {
        int usb2 = 2;
        int usb3 = 1;
        int getTotalPorts() {
            return usb2 + usb3;
        }
    }
}

public class Main {
    public static void main(String[] args) {
        MotherBoard.USB usb = new MotherBoard.USB();
        System.out.println("Total Ports = " + usb.getTotalPorts());
    }
}

   When you run the above program, the output will be:
Total Ports = 3

   In the above program, we've declared static inner class USB using the keyword static.

   You can also see, in the Main class, we directly created an instance of USB from MotherBoard with the
   . (dot) operator without creating an instance of Motherboard first.
MotherBoard.USB usb = new MotherBoard.USB();

   Let's see what would happen, if you try to access the members of the outer class:

Example 4: Accessing members of Outer class inside Static Inner Class

public class MotherBoard {
    String model;
    public MotherBoard(String model) {
        this.model = model;
    }

    static class USB {
        int usb2 = 2;
        int usb3 = 1;
        int getTotalPorts() {
            if (MotherBoard.this.model.equals("MSI")) {
                return 4;
            } else {
                return usb2 + usb3;
            }
        }
    }
}

public class Main {
    public static void main(String[] args) {
        MotherBoard.USB usb = new MotherBoard.USB();
        System.out.println("Total Ports = " + usb.getTotalPorts());
    }
}

   When you run above program, you'll get an error:
error: non-static variable this cannot be referenced from a static context

   This is because, no reference of outer class Motherboard is stored in Motherboard.this.

Key Points to Remember
     * Java treats inner class as a regular member of a class. They are just like methods and variables
       declared inside a class.
     * Since, inner class are members of outer class, you can apply any access modifiers like private,
       protected to your inner class which is not possible in normal classes.
     * Since Nested class is a member of its enclosing class Outer, you can use . (dot) notation to
       access Nested class and its members.
     * Using nested class will make your code more readable and provide better encapsulation.
     * Non-static nested classes (inner classes) have access to other members of the outer/enclosing
       class, even if they are declared private.


---
https://www.programmerinterview.com/index.php/java-questions/when-to-use-inner-classes-in-java/

When should inner classes be used in Java?

   Inner classes were introduced in version 1.1 of Java. Ever since they were introduced they inspired a
   lot of different opinions among people – but we won't present any opinions here, just facts. Knowing
   when to use inner classes is very important, because using inner classes in the wrong situations can
   lead to code that's difficult to understand and maintain.

A class can be a member of another class, which is an inner class

   Inner classes allow you to define one class inside another class – which is why they are called
   "inner" classes. A class can have member classes, just like how classes can have member variables and
   methods. There are many different types of inner classes, but we won't get into the different types
   of inner classes since the purpose of this article is just to explain when and why you should use
   inner classes in Java.

   In object oriented programming you are probably aware of the fact that classes need to be specialized
   because it allows for greater reuse and flexibility. This is because a class only needs code that
   allows an object of that class to do whatever it needs to do, and no more.

   But, there are other situations when you actually need to write some code that seems like it belongs
   in it's very own class. But, at the same time, the code that you want to write needs to be intimately
   tied to some other class's code. So, the question is what to do in this situation? Well, this is
   where inner classes are very useful. Don't worry if you are confused – we have a simple example to
   help you understand why inner classes are necessary, and how they can help you.

An example of when inner classes are necessary
   Suppose you have a Java GUI (Graphical User Interface) class that acts as a chat client like Gchat or
   Facebook Chat. Think about what methods would need to be present in a class like that which
   represents a chat client – you will need a method that will read user input from the chat box,
   methods to actually send the user input to the server and to whoever the user is chatting with, even
   a method that detects that you are typing so that Gchat can display the "XZY is typing" text to your
   friends, etc.

Event handlers
   But, there is one key thing missing here. How exactly will those methods be called? Well, as an
   example, think about how Gchat works – you type in some text and when you are ready to send it to
   whoever you're chatting with, you press the "Enter" or "Return" key on your keyboard. So, the "Enter"
   key could be considered one event that triggers a call to one of the methods we mentioned earlier.
   And, if our chat client class wants to detect if someone is typing in a window, then clearly the
   event that would trigger the call is someone typing – so we would need some code to detect when
   someone is actually typing in a window in real time – basically when they are pressing a button
   inside their chat window.

   So, these events – like typing in a window and pressing the "RETURN" key – will also need some
   methods to detect when they occur, and those event handling methods can then call the appropriate
   chat client methods. For example, when the event handler method that handles the "RETURN" key button
   pressed event is called, then that method can call the method to send the user input to the server.

There are two types of methods needed in our example
   So, it should be clear that there will need to be two different types of methods that will drive your
   chat client application: 1. Chat client specific methods like those that will read user input from
   the chat box and send user input to the server. 2. Event handling methods that will respond to actual
   events that occur in the chat client window – like hitting the "RETURN" key, detecting consistent
   typing, etc.

   Because it's clear that there will need to be two different types of methods, then from an Object
   Oriented Design perspective, it seems like we should have two different classes: one class for the
   chat client specific methods and one class for the event handling methods. That does follow the
   normal object oriented design practices – because we are creating classes that specialize in what
   they do.

The problem with having two separate classes
   But, in this particular example, there is a problem with having two separate classes. And that
   problem is the fact that the event handling code is very much related/tied to the code that belongs
   to the chat client. This makes sense, as we talked about earlier with our GChat example; as soon as a
   user in GChat hits "RETURN" or "ENTER" on the keyboard that should trigger an event, which should
   then grab the text from the chat client window. And, the chat client window would be a particular
   instance (basically an object) of the chat client class. For example, if you are talking to your
   friend Bob in GChat, he will have one window in Gmail and you will have one window open in Gmail, and
   each window is an object of the chat client class. So there will be two separate objects of the chat
   client class – one for you and one for Bob.

   Now, if Bob types something and hits the RETURN key, the event handler code that responds to the
   RETURN key being pushed will need to be able to communicate with Bob's chat client class object so
   that it can grab the text from Bob's chat client class window, or the text field where that text is
   actually stored. The key here is thinking in terms of objects – an object of the chat client class is
   created for each person using GChat, so you will have your own object and Bob will have his own
   object. This means that the event handling code will need to access an chat client object's text
   field – which is a member of the class, and an instance variable. So, it should be clear that the
   event handling code needs access to the members of a chat client class object in order to be able to
   effectively help.

Why don't we just combine the event handling code with the chat client code?
   Combining the event handling methods with the chat client specific methods in one big class sounds
   like a good idea at first, but there is one big problem: If both the event handling code and the chat
   client code need to inherit some code from different classes then you are in trouble, because Java
   does not support [626]multiple inheritance – meaning that our one "big class" can not inherit from
   two different classes.

   This means that we want some sort of solution where the event handling code is in it's very own class
   – which would allow it to inherit from any class it needs, because it's not bundled together in one
   class with the chat client code as well. This is also better object oriented design. But, we also
   want the event handling class to have easy access to the chat client's member variables – even the
   private instance variables. One possible solution is to make everything in the chat client class
   public so that anyone can access it, including the event handling code. But, making everything public
   is a bad idea.

Inner classes to the rescue
   Now, this is why inner classes were created – for situations exactly like the one we described above.
   An instance of an inner class can access members of an instance of the outer class, because an inner
   class is just another member of the outer class. And, inner classes can even access the private
   members of the outer class – yes you did read that correctly!

Does an inner class violate encapsulation?
   No, an inner class does not violate encapsulation because of the fact that an inner class is authored
   by the same person who created the outer class – so having an inner class was an intentional design
   decision.

What about nested classes? Are nested classes the same thing as inner classes?

   You've probably heard the term nested class as well, and may be confused as to what the difference
   between an inner class and a nested class is – you can read about the difference here: [***1]Inner
   versus nested classes


---
[***1]
https://www.programmerinterview.com/index.php/java-questions/inner-vs-nested-classes/

What is the difference between an inner and nested class in Java? What about the difference between an
inner class and a static inner class?

   This tutorial is a bit complex, but we'll try to keep things as simple as possible.
   With that said, let's start off with definition and explanation of nested classes.

Nested classes can be either static or non-static
   Nested classes can be further classified into two different types of classes: non-static nested
   classes and static nested classes. Non-static nested classes are more formally known as inner
   classes. So, think of nested classes as a big container with 2 smaller boxes inside – 1 box is for
   static nested classes, and another box is for inner classes (also known as non-static nested
   classes).

Example of an inner class (aka non static nested class)

   Here's a simple example of an inner class – where InnerClass is the inner class:
class OuterClass {
    /*  some code here...*/

    class InnerClass  {  }

    /*  some code here...*/
}

   Note in the code above that InnerClass is literally declared inside the OuterClass class.

Inner classes are subsets of nested classes
   Remember that an inner class is a specific type of nested class that occurs when a nested class is
   non-static. And that is the "difference" between an inner class and a nested class – in other words,
   inner classes are subsets of nested classes. So, be careful, because the terms "inner class" and
   "nested class" are NOT interchangeable. You can say that an inner class is also a nested class, but
   you can NOT say that a nested class is also an inner class. This is because nested classes are part
   of the larger set that includes both inner classes and static nested classes.

What's so special about inner classes?
   So, what exactly is special about inner classes? Well, the main thing that you must remember about
   inner classes is that an instance of an inner class has access to all of the members of the outer
   class, even those that are marked "private". So, when an instance of the inner class is created,
   there are no issues with having the inner class access the instance variables of the outer class.

Inner class versus static inner classes
   Before we dive into the differences between inner classes and static inner classes, the most
   important thing you should know is that static inner classes is the wrong terminology – they should
   be called static nested classes instead.

Why you must use static "nested" classes instead of static "inner" classes
   There is no such thing as a static inner class, because the term "inner class" means that the inner
   class has access to the instance variables of the outer class.

An inner class is part of the "inner circle" of the outer class
   Think of an inner class as being part of the "inner circle" of the outer class – an inner class
   instance can access all the members of the outer class, even the ones declared private. But, if an
   inner class were also declared to be static it would be impossible to have access to all of the
   members of the outer class – think about why on your own before you read our answer. You should be
   able to come up with an answer on your own as long as you know what static means.

Inner classes have access even to non-static members of outer class
   The reason an inner class can't be static is because of the fact that it's impossible to access
   non-static variables and methods from within a static context. So, a static inner class would only
   have access to the static members of the outer class. And, by definition, an inner class should have
   access even to the non-static members of the outer class. So, instead of calling them static inner
   classes, we call them static nested classes, and remember that the reason is that 'inner' classes
   have a special relationship with the outer class. And to call it a static inner class would be a
   misuse of the terminology – so they are called static nested classes instead.

Example of a static nested class

   Here's a simple example of a static nested class:
class Outer {
    static class NestedStatic { }
}

   The correct way of thinking about the NestedStatic class in our example above is that it is a static
   member of the outer class. And because it is a static member, it means that it can be accessed
   without an instance of the Outer class.

How to instantiate a static nested class
   The syntax used to instantiate a static nested class is different depending on whether the nested
   static class is a member of the current class or if the static nested class is nested in some other
   class. Confused? Some examples will help clarify what we mean:

Instantiating a static nested class from a non-enclosing class
   Suppose we want to create an instance of a static nested class from another class. Here is some code
   where we do that – note that in the NonEnclosingClass class we instantiate the static class called
   Nested that is a member of the EnclosingClass class.

class EnclosingClass {
    static class Nested {
        void someMethod() {
            System.out.println("hello");
        }
    }
}

class NonEnclosingClass {
    public static void main(String[] args) {
        /*  instantiate the Nested class that is a static
            member of the EnclosingClass class:
        */

        EnclosingClass.Nested n = new EnclosingClass.Nested();

        n.someMethod();  //prints out "hello"
    }
}


Instantiating a static nested class from an enclosing class
   Here you can see an example of how to instantiate a static inner class that is already a part of the
   current class – note the more 'normal' syntax that you're probably used to seeing of "Nested n = new
   Nested();" versus "EnclosingClass.Nested n = new EnclosingClass.Nested();" which is what was used to
   instantiate a static class that's a member of a different class, as we showed in the example above.

class EnclosingClass {

    static class Nested {
        void anotherMethod() {
            System.out.println("hi again");
        }
    }

    public static void main(String[] args) {
        //access enclosed class:
        Nested n = new Nested();
        n.anotherMethod();  //prints out "hi again"
    }

}


Accessing non-static instance variables from a static nested class
   Now, let's see what happens if we try to access some non-static instance variables that belong to the
   Outer class from inside of the NestedStatic class:
class Outer {
    int instanceVar = 5;

    static class NestedStatic {
        public static void main(String[] args) {
            /*  instanceVar is a non-static variable
                belonging to the Outer class:
            */
            instanceVar = 10;
        }
    }
}

   The code above throws a compiler error saying "non-static variable instanceVar cannot be referenced
   from a static context". That error makes perfect sense because we are trying to access instanceVar,
   which is non-static, from the NestedStatic class, which is static. And, because of the fact that we
   can access the static NestedStatic class without an object of the Outer class, it makes sense that we
   should not be able to access an instance variable like instanceVar (which needs an object of the
   Outer class in order to be accessed since it's not static).


---
https://medium.com/the-java-report/how-java-10-changes-the-way-we-use-anonymous-inner-classes-b3735cf45593

How Java 10 changes the way we use Anonymous Inner Classes

   When a new feature is introduced to a programming language specification, language designers
   typically look out for conflicts with existing language features, breaking changes, bugs, & any
   situation that can lead to undefined or unintended behavior.

   Often enough, however, subtle changes in the new, practical ways we can now write code from version
   to version go without much notice. These changes are often the side-effects of a new addition to a
   programming language specification. These sorts of changes, are not, strictly speaking, new language
   features. However, they are subtle changes brought on by the advent of a feature or combination of
   features.

Anonymous Inner Classes
   In Java, inner classes are classes defined as a member of a class. They may take one of four forms
   (anonymous, static, method-local, or instance member).

   Anonymous inner classes are unnamed classes which provide an implementation of an existing class.
   Typically, this finds common practical use in event-driven programming for the handling of events.
   Usually, the anonymous inner class provides a concrete implementation for an abstract class, on the
   fly. This is, however, not required; Anonymous inner classes may be made from concrete classes.

   A detail I believe is often enough not fully grasped about anonymous inner classes is that the
   programmer is actually subclassing the original class. This subclass is given the name Class$X where
   Class represents the Outer class and X represents a number that represents the instantiation order of
   inner classes within that class. For example, AnonDemo$3 for the third inner class instantiated
   within AnonDemoand so on. You may not invoke these classes yourself, in the ordinary way, using the
   java launcher. Unlike the other forms of inner classes, an anonymous inner class is always implicitly
   a child class of it's reference type (with the exception of var, coming up soon).

   Let's look at an example.
/* AnonDemo.java */
class Anon { };
public class AnonDemo {
    public static void main (String[] args) {
        Anon anonInner = new Anon () {
            public String toString() { return "Overriden"; };
            public void doSomething() {
                 System.out.println("Blah");
            };
        };
        System.out.println(anonInner.toString());
        anonInner.doSomething(); // Won't compile!
    };
};

   In this example, we instantiated an anonymous inner class based on the concrete class Anon.
   Essentially, what we have done, is created an unnamed subclass of a concrete class. In java pre Java
   10, this meant that most of the times, anonymous inner classes were almost implicitly polymorphic. I
   say almost, because non-polymorphic code like this was of course legal.

   new Anon() { public void foo() { System.out.println("Woah"); } }.foo();

   However, if we wanted to assign the result of an anonymous inner class instantiation to a reference
   type, such an operation was inherently polymorphic. The simple reasons are because we are implicitly
   subclassing the class which we specified as the reference type for the anonymous inner class object &
   the object's most specific type (Class$X)is not available for us to type within our application code.

     A subclass object with a super class reference type does not have access to the subclass's members
     via the super class reference.

Polymorphism and Anonymous Inner Classes, The practical consequence
   Did you catch it in the code above? Because we are using a superclass reference to a subclass object,
   per the laws of polymorphism we can only refer to 1) methods defined by the superclass or 2)
   overriden, virtual methods in the subclass.

   So in the previous code snippet, a call on the anonymous inner class object to toString() would give
   us the overriden value of "Overridden" in our example, however, a call to doSomething() will cause
   compilation to fail. The reason?

   A subclass object with a super class reference type does not have access to the subclass's members
   via the super class reference. The only exception to this rule is if the subclass overrides a method
   of the super class. In this case, true to it's polymorphic nature, Java, through Dynamic Method
   Dispatch selects the subclass's version of the virtual method at runtime.

   In case you didn't already know, a virtual method is a method that is able to be overridden. In java,
   all non-final, non-private and non-static methods are virtual by default. I say by default as opposed
   to implicitly because various java virtual machines may perform optimizations which may change this
   fact.

What's Java 10 got to do with it all?
   A small detail called type inference. Notice the following example:
/* AnonDemo.java */
class Anon { };
public class AnonDemo {
    public static void main (String[] args) {
          var anonInner = new Anon() {
          public void hello() {
                   System.out.println("New method here, and you can
                   easily access me in Java 10!\n" +
                  "The class is:  " + this.getClass()
          );
          anonInner.hello(); // Works!!
    };
};

   It works, we can call hello()! The devil is in the details. To folks familiar with var you will
   already see what's happening here. By using the reserved type name var Java was able to deduce the
   exact type of the anonymous inner class. Consequently, we are no longer stuck with using a superclass
   reference to access the subclass object.

What did we do when we needed a subclass reference Pre Java 10?
   It is no secret that the inner class debates have been responsible for one too many flame wars in the
   distant, not-to-forgotten past. And if it is a secret, it's no question one of the world's worst
   hidden. Indubitably, there are many who are frowning at you for needing an exact reference to an
   anonymous inner class in the first place as the idea is to avoid adding any cruft to the class.
   Rather, they should be used to fulfill a contract on the fly, typically to facilitate for an
   operation logically linked to another class, such as is the common case with event handling. However,
   curiosity probably didn't actually kill the cat and I'm willing to bet most developers are curious.
   Perhaps, to the detriment of our sanity!

   With a bit of reflection magic, we can achieve a similar effect in Pre-Java 10 code as follows:
Anon anonInner2 = new Anon() {
   public void hello() { System.out.println("Woah! "); };
};
anonInner2.getClass().getMethod("hello").invoke(anonInner2);


---
