filename: jv_avoid-getters-and-setters-multif_20181015.txt
https://dev.to/scottshipp/avoid-getters-and-setters-whenever-possible-c8m

Avoid getters and setters whenever possible
Dec 8 '17

Don't generate getters and setters!
   Noooo!!! Don't click that generate getters and setters option!!!

   I like the rule: "Don't use accessors and mutators." Like any good rule, this one is meant to be
   broken. But when?

   First, let me be clear about what I am saying: adding getters and setters to OO classes should be the
   last resort after considering a series of better alternatives. I believe that a careful analysis
   yields the conclusion that getters and setters are harmful in the clear majority of cases.

  What is the harm?
   First let me point out that the "harm" I am talking about might not be any harm at all. The following
   is, in some cases, a perfectly reasonable class:

// Car1.java

public class Car1 {
  public Engine engine;
}

   Notice, though, that feeling of tightening in your stomach, the bristle of your hair, the tensing of
   the muscles that you may experience looking at something like that.

   Now, I want to point out that there's no meaningful functional difference between that class, a
   public class with a public class member, and the following class below, a public class with a private
   member that is exposed by getters and setters. In both classes, Car1.java and Car2.java, we get
   essentially the same result.

// Car2.java

public class Car2 {
  private Engine engine;

  public Engine getEngine() {
    return engine;
  }

  public void setEngine(Engine engine) {
    this.engine = engine;
  }
}

   To show this, I read and write the engine in either Car1.java or Car2.java:

// Car1 member read and write
Car1 car1 = new Car1();
logger.debug("Car1's engine is {}.", car1.engine);
car1.engine = new HemiEngine();

// Car2 member read and write
Car2 car2 = new Car2();
logger.debug("Car2's engine is {}.", car2.getEngine());
car2.setEngine(new HemiEngine());

   The point here is that anything I can do with Car2.java, I can do with Car1.java, and vice-versa.
   This is important because we've been taught to get squeamish when we see Car1.java. We see that
   public member sitting there and we say, not safe! Engine is not protected by anything! Anyone can do
   anything! Aaaaaaaaagggghhhhh!

   Yet for some reason we breathe a sigh of relief when we see Car2.java. Which--I'm sorry--I personally
   think is funny since there's literally the same (non-existent) protections around both of these
   things.

  What could go wrong?
   The following are some of the disadvantages of public getters and setters that directly expose a
   single private member, have the same name, and provide no other functionality.

    Getters and setters are a fake insurance policy of isolated change.

   One supposed advantage of getters and setters is that on the off-chance that the type of a class
   member needs to change, the change can be limited to inside the class by making the existing getter
   simply translate from the internal type to the previously-exposed type.

// Car2.java, engine changed to motor

public class Car2 {
  private Motor motor;

  public Engine getEngine() {
    return convertToEngine(motor);
  }

  public void setEngine(Engine engine) {
    this.motor = convertToMotor(engine);
  }
}

   My question is how often has the working programmer ever had to do that? I don't remember ever doing
   this in all my years of software. Not once have I been able to take advantage of the fake insurance
   policy that getters and setters provide.

   Also, this argument becomes an entirely moot point if the engine had never been exposed to begin with
   (let's say it was kept private or package-private). Just expose behavior, rather than state, and you
   never need to worry about flexibility in changing implementation.

   This realization that the private member should not have been exposed triggers another realization
   that this argument is tautological. Getters and setters expose the private member, and rest the case
   for their existence on the fact that the private member is exposed.

  Getters and setters expose implementation details.

   Let's say I give you only the following API to my Car object:

 _________________________________
| Car                             |
|---------------------------------|
| + getGasAmount(): Liters        |
| + setGasAmount(liters: Liters)  |
|_________________________________|

   If you assume that this is a gas-powered car that internally tracks gasoline in liters, then you are
   going to be right 99.999% of the time. That's really bad and this is why getters and setters expose
   implementation / violate encapsulation. Now this code is brittle and hard to change. What if we want
   a hydrogen-fuelled car? We have to throw out this whole Car class now. It would have been better just
   to have behavior methods like fillUp(Fuel fuel).

   Things like this are the reason why famous libraries have terrible legacy classes. Have you ever
   noticed how most languages have a Dictionary data structure but it's called Map in Java? Dictionary
   actually was an interface that was introduced in JDK 1.0, but it had problems and ultimately had to
   be replaced by Map.

  Getters and setters can actually be dangerous
   Let me tell you a story about a friend. OK? A friend I said!!!

   One day this friend came into work, and found that dozens of well-known web sites in countries around
   the world all had the header and navigation of the parent corporation's main web site (not their
   own), and were using British English. The operations team was frantically restarting hundreds of
   servers around the globe because for the first half-hour or so that these servers ran, things
   functioned normally. Then (bam!) all of a sudden something would happen that made the whole thing go
   sideways.

   The culprit was a setter method deep in the guts of a shared platform that all these different sites
   were using. A little piece of code that ran on a schedule happened to be updated recent to this
   fiasco that changed the underlying value that determined site headers and languages by calling this
   setter.

   If you only have a getter, things can be just as bad. In Java at least, returning a reference type
   from a getter provides that reference to the caller and now it can be manipulated by the caller in
   unexpected ways. Let me demonstrate.

public class Debts {
  private List<Debt> debts;

  public List<Debt> getDebts() {
    return debts;
  }
}

   OK, that seems reasonable. I need to be able to see a person's debts to give them a statement. Huh?
   What's that you say? You can add debts now? Shit! How did that happen!

Debts scottsDebts = DebtTracker.lookupDebts(scott);
List<Debt> debts = scottsDebts.getDebts();

// add the debt outside scotts debts, outside the debt tracker even
debts.add(new Debt(new BigDecimal(1000000)));

// prints a new entry with one million dollars
DebtTracker.lookupDebts(scott).printReport();

   Eek!

   One way to guard against this is to return a copy instead. Another way is to have an immutable
   member. The best way, though, is to not expose the member in any way at all and instead bring the
   behavior that manipulates the member inside the class. This achieves full isolation of the
   implementation and creates only one place to change.

  When getters make sense
   Wait a second! If there are so many disadvantages to accessors and mutators, why ever use them?

   I'm convinced that getters and setters which just return a class member almost never make sense. But
   you might write something close to getter/setter functionality as long as you are actually doing
   something in that method.

   Two examples:
     * In a setter, before updating the state in this object according to some input, we validate the
       input. The input validation is additional functionality.
     * The return type of a getter is an interface. We have therefore decoupled the implementation from
       the exposed interface.

   See, what I'm really advocating for here is a different stance and philosophy towards getters and
   setters. Rather than say never use accessors and mutators, I want to give you the list of options
   that I try to exhaust before using one:
     * My "default" is to start with a private final member, set only by the constructor. No getter or
       setter!
     * If another class absolutely needs to see this member, I think about why. I try to see if there is
       a behavior that I can expose instead, and create a method for that behavior.
     * If it's absolutely necessary for some reason, then I relax to package-private (in Java) and
       expose the member only to other classes in the same package, but no further.
     * OK, what about the data use case? Literally I might need to have an object to pass data across
       some kind of interface boundary (let's say to a file system, database, web service, or
       something). I still don't futz around with getters and setters. I create the class with all
       package-private members, and I think of and use it as just a bag of properties. I try to limit
       these into their own packages and layers at the boundaries of the application.
     * I would consider creating both a getter and a setter for the data use case in a public API, like
       let's say I am writing a library meant to be used as a dependency in a lot of other applications.
       But I would only consider it after exhausting all of these list items.

  Wisdom of the Masters
   A short postscript. Obviously, there's debate about getters and setters out there in the world. It's
   important to know there's clearly a camp of "masters" like Robert C. ("Uncle Bob") Martin who are
   proponents of avoiding getters and setters. In the book Clean Code, Martin wrote about this in
   chapter 6:

     Beans have private variables manipulated by getters and setters. The quasi-encapsulation of beans
     seems to make some OO purists feel better but usually provides no other benefit.

   Josh Bloch has a nuanced stance in Effective Java, Item 14 that is slightly in favor of getters and
   setters for public classes, and slightly against for others. He ends up basically saying that what he
   is really concerned about is mutability, a point I touched on above:

     In summary, public classes should never expose mutable fields. It is less harmful, though still
     questionable, for public classes to expose immutable fields. It is, however, sometimes desirable
     for package-private or private nested classes to expose fields, whether mutable or immutable.

    Further Reading
   Here's some helpful thoughts from smarter people than me.

   [**1]Tell, Don't Ask
   [**2]Why getter and setter methods are evil
   [**3]Accessors are evil


---
[**1]
https://pragprog.com/articles/tell-dont-ask

Tell, Don't Ask

   Alec Sharp, in the recent book Smalltalk by Example [SHARP], points up a very valuable lesson in
   few words:

     Procedural code gets information then makes decisions. Object-oriented code tells objects to do
     things.
     - Alec Sharp

   That is, you should endeavor to tell objects what you want them to do; do not ask them questions
   about their state, make a decision, and then tell them what to do.

   The problem is that, as the caller, you should not be making decisions based on the state of the
   called object that result in you then changing the state of the object. The logic you are
   implementing is probably the called object's responsibility, not yours. For you to make decisions
   outside the object violates its encapsulation.

   Sure, you may say, that's obvious. I'd never write code like that. Still, it's very easy to get
   lulled into examining some referenced object and then calling different methods based on the results.
   But that may not be the best way to go about doing it. Tell the object what you want. Let it figure
   out how to do it. Think declaratively instead of procedurally!

   It is easier to stay out of this trap if you start by designing classes based on their
   responsibilities, you can then progress naturally to specifying commands that the class may execute,
   as opposed to queries that inform you as to the state of the object.

Just the Data
   The main purpose of this exercise is to ensure a correct division of responsibility that places the
   right functionality in the right class without causing excess coupling to other classes.

   The biggest danger here is that by asking for data from an object, you are only getting data. You're
   not getting an object-not in the large sense. Even if the thing you received from a query is an
   object structurally (e.g., a String) it is no longer an object semantically. It no longer has any
   association with its owner object. Just because you got a string whose contents was "RED", you can't
   ask the string what that means. Is it the owners last name? The color of the car? The current
   condition of the tachometer? An object knows these things, data does not.

   The fundamental principle of Object Oriented programming is the unification of methods and data.
   Splitting this up inappropriately gets you right back to procedural programming.

Invariants aren't enough
   Every class has invariants-things that must always be true. Some languages (such as Eiffel)
   provide direct support for specifying and checking invariants. Most languages do not, but that only
   means that the invariants are not stated-they still exist. For instance, an iterator has the
   invariant that (using Java as an example):
hasMoreElements() == true
// implies that:

nextElement()
// will return a value

   In other words, if hasMoreElements() is true, then attempting to get the next element must succeed,
   or something is seriously broken. If you are running multi-threaded code without the proper
   synchronization (locking), it may well be that the above invariant doesn't hold: some other thread
   grabbed the last element before you did.

   The invariant doesn't hold; so something is wrong - you have a bug.

   According to Design by Contract, as long as your methods (queries and commands ) can be freely
   intermixed, and there is no way to violate the class invariant by doing so, then you are ok. But
   while you are maintaining the class invariant, you may have also dramatically increased the coupling
   between the caller and the callee depending on how much state you have exposed.

   For instance, suppose you have a container object C. You could expose iterators for the held objects
   in this container, as many of the JDK core routines do, or you could provide a method that would run
   some function over all members in the collections for you. In Java you might declare this as
   something like:
public   interface  Applyable {
          public   void  each(Object anObject);
 }
 ...
  public   class  SomeClass {
          void  apply(Applyable);
 }

// Called as:

SomeClass foo;
...
foo.apply( new  Applyable() {
         public   void  each(Object anObject) {
                 // do what you want to anObject
        }
});

   (Forgive the neologic barbarism of "Apply-able"; we've found it handy to name interfaces as
   "-able",
   but English isn't as cooperative as one would like).

   This is easier to code in languages with function pointers, and even easier in Perl or Smalltalk
   where such concepts are built in, but you should get the idea: "run this function over all contained
   items, I don't care how."

   You can achieve the same results both ways, either via an apply sort of method or via iterators. The
   choice really comes down to how much coupling you are willing to have: To minimize coupling, expose
   the minimum amount of state necessary. As shown here, apply exposes less state than exposing an
   iterator does.

Law of Demeter
   So we've decided to expose as little state as we need to in order to accomplish our goals. Great! Now
   within our class can we just starting sending commands and queries to any other object in the system
   will-nilly? Well, you could, but that would be a bad idea, according to the Law of Demeter. The Law
   of Demeter tries to restrict class interaction in order to minimize coupling among classes.

   What that means is that the more objects you talk to, the more you run the risk of getting broken
   when one of them changes. So not only do you want to say as little as possible, you don't want to
   talk to more objects than you need to either. In fact, according to the Law of Demeter for Methods,
   any method of an object should only call methods belonging to:
     * itself.
     * any parameters that were passed in to the method.
     * any objects it created.
     * any composite objects.

   Specifically missing from this list is methods belonging to objects that were returned from some
   other call. For example (we'll use Java syntax here):
SortedList thingy = someObject.getEmployeeList();
thingy.addElementWithKey(foo.getKey(), foo);

   This is what we are trying to prevent. (We also have an example of Asking instead of Telling in
   foo.getKey()). Direct access of a child like this extends coupling from the caller farther than it
   needs to be. The caller is depending on these facts:
     * someObject holds employees in a SortedList.
     * SortedList's add method is addElementWithKey()
     * foo's method to query its key is getKey()

   Instead, this should be:
someObject.addToThingy(foo);

   Now the caller is only depending on the fact that it can add a foo to thingy, which sounds high level
   enough to have been a responsibility, not too dependent on implementation.

   The disadvantage, of course, is that you end up writing many small wrapper methods that do very
   little but delegate container traversal and such. The cost tradeoff is between that inefficiency and
   higher class coupling.

   The higher the degree of coupling between classes, the higher the odds that any change you make will
   break something somewhere else. This tends to create fragile, brittle code.

   Depending on your application, the development and maintenance costs of high class coupling may
   easily swamp run-time inefficiencies in most cases.

Command/Query Separation
   Now back to to the ask vs. tell thing. To ask is a query, to tell is a command. I subscribe to the
   notion of maintaining these as separate methods. Why bother?
     * It helps to maintain the "Tell, Don't Ask" principle if you think in terms of commands that
       perform a very specific, well defined action.

     * It helps you to think about class invariants if your class is primarily command based. (If you
       are just tossing data out, you probably aren't thinking much in the way of invariants).

     * If you can assume that evaluation of a query is free of any side effects, then you can:
          + use queries from within a debugger without affecting the process under test.
          + create built-in, automatic regression tests.
          + evaluate class invariants, pre- and post-conditions.

   The last, of course, is why Eiffel requires only side-effect free methods to be called from within an
   Assertion. But even in C++ or Java, if you want to manually check the state of an object at some
   point in the code, you can do so with confidence if you know the queries you are calling will not
   cause anything else to change.


---
[**2]
https://www.javaworld.com/article/2073723/core-java/why-getter-and-setter-methods-are-evil.html

Why getter and setter methods are evil

   I didn't intend to start an "is evil" series, but several readers asked me to explain why I mentioned
   that you should avoid get/set methods in last month's column:
   "[https://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html]Why extends Is Evil."

   Though getter/setter methods are commonplace in Java, they are not particularly object oriented (OO).
   In fact, they can damage your code's maintainability. Moreover, the presence of numerous getter and
   setter methods is a red flag that the program isn't necessarily well designed from an OO perspective.

   This article explains why you shouldn't use getters and setters (and when you can use them) and
   suggests a design methodology that will help you break out of the getter/setter mentality.

On the nature of design
   Before I launch into another design-related column (with a provocative title, no less), I want to
   clarify a few things.

   I was flabbergasted by some reader comments that resulted from last month's column, "Why extends
   Is Evil" (see Talkback on the article's last page). Some people believed I argued that object
   orientation is bad simply because extends has problems, as if the two concepts are equivalent. That's
   certainly not what I thought I said, so let me clarify some meta-issues.

   This column and last month's article are about design. Design, by nature, is a series of trade-offs.
   Every choice has a good and bad side, and you make your choice in the context of overall criteria
   defined by necessity. Good and bad are not absolutes, however. A good decision in one context might
   be bad in another.

   If you don't understand both sides of an issue, you cannot make an intelligent choice; in fact, if
   you don't understand all the ramifications of your actions, you're not designing at all. You're
   stumbling in the dark. It's not an accident that every chapter in the Gang of Four's Design Patterns
   book includes a "Consequences" section that describes when and why using a pattern is inappropriate.
   [ Learn Java from beginning concepts to advanced design patterns in this comprehensive 12-part
   course! ]

   Stating that some language feature or common programming idiom (like accessors) has problems is not
   the same thing as saying you should never use them under any circumstances. And just because a
   feature or idiom is commonly used does not mean you should use it either. Uninformed programmers
   write many programs and simply being employed by Sun Microsystems or Microsoft does not magically
   improve someone's programming or design abilities. The Java packages contain a lot of great code. But
   there are also parts of that code I'm sure the authors are embarrassed to admit they wrote.

   By the same token, marketing or political incentives often push design idioms. Sometimes programmers
   make bad decisions, but companies want to promote what the technology can do, so they de-emphasize
   that the way in which you do it is less than ideal. They make the best of a bad situation.
   Consequently, you act irresponsibly when you adopt any programming practice simply because "that's
   the way you're supposed to do things." Many failed Enterprise JavaBeans (EJB) projects prove this
   principle. EJB-based technology is great technology when used appropriately, but can literally bring
   down a company if used inappropriately.

   My point is that you should not program blindly. You must understand the havoc a feature or idiom can
   wreak. In doing so, you're in a much better position to decide whether you should use that feature or
   idiom. Your choices should be both informed and pragmatic. The purpose of these articles is to help
   you approach your programming with open eyes.

Data abstraction
   A fundamental precept of OO systems is that an object should not expose any of its implementation
   details. This way, you can change the implementation without changing the code that uses the object.
   It follows then that in OO systems you should avoid getter and setter functions since they mostly
   provide access to implementation details.

   To see why, consider that there might be 1,000 calls to a getX() method in your program, and each
   call assumes that the return value is of a particular type. You might store getX()'s return value in
   a local variable, for example, and that variable type must match the return-value type. If you need
   to change the way the object is implemented in such a way that the type of X changes, you're in deep
   trouble.

   If X was an int, but now must be a long, you'll get 1,000 compile errors. If you incorrectly fix the
   problem by casting the return value to int, the code will compile cleanly, but it won't work. (The
   return value might be truncated.) You must modify the code surrounding each of those 1,000 calls to
   compensate for the change. I certainly don't want to do that much work.

   One basic principle of OO systems is data abstraction. You should completely hide the way in which an
   object implements a message handler from the rest of the program. That's one reason why all of your
   instance variables (a class's nonconstant fields) should be private.

   If you make an instance variable public, then you can't change the field as the class evolves over
   time because you would break the external code that uses the field. You don't want to search 1,000
   uses of a class simply because you change that class.

   This implementation hiding principle leads to a good acid test of an OO system's quality: Can you
   make massive changes to a class definition-even throw out the whole thing and replace it with a
   completely different implementation-without impacting any of the code that uses that class's objects?
   This sort of modularization is the central premise of object orientation and makes maintenance much
   easier. Without implementation hiding, there's little point in using other OO features.

   Getter and setter methods (also known as accessors) are dangerous for the same reason that public
   fields are dangerous: They provide external access to implementation details. What if you need to
   change the accessed field's type? You also have to change the accessor's return type. You use this
   return value in numerous places, so you must also change all of that code. I want to limit the
   effects of a change to a single class definition. I don't want them to ripple out into the entire
   program.

   Since accessors violate the encapsulation principle, you can reasonably argue that a system that
   heavily or inappropriately uses accessors simply isn't object oriented. If you go through a design
   process, as opposed to just coding, you'll find hardly any accessors in your program. The process is
   important. I have more to say on this issue at the end of the article.

   The lack of getter/setter methods doesn't mean that some data doesn't flow through the system.
   Nonetheless, it's best to minimize data movement as much as possible. My experience is that
   maintainability is inversely proportionate to the amount of data that moves between objects. Though
   you might not see how yet, you can actually eliminate most of this data movement.

   By designing carefully and focusing on what you must do rather than how you'll do it, you eliminate
   the vast majority of getter/setter methods in your program. Don't ask for the information you need to
   do the work; ask the object that has the information to do the work for you. Most accessors find
   their way into code because the designers weren't thinking about the dynamic model: the runtime
   objects and the messages they send to one another to do the work. They start (incorrectly) by
   designing a class hierarchy and then try to shoehorn those classes into the dynamic model. This
   approach never works. To build a static model, you need to discover the relationships between the
   classes, and these relationships exactly correspond to the message flow. An association exists
   between two classes only when objects of one class send messages to objects of the other. The static
   model's main purpose is to capture this association information as you model dynamically.

   Without a clearly defined dynamic model, you're only guessing how you will use a class's objects.
   Consequently, accessor methods often wind up in the model because you must provide as much access as
   possible since you can't predict whether or not you'll need it. This sort of design-by-guessing
   strategy is inefficient at best. You waste time writing useless methods (or adding unnecessary
   capabilities to the classes).

   Accessors also end up in designs by force of habit. When procedural programmers adopt Java, they tend
   to start by building familiar code. Procedural languages don't have classes, but they do have the C
   struct (think: class without methods). It seems natural, then, to mimic a struct by building class
   definitions with virtually no methods and nothing but public fields. These procedural programmers
   read somewhere that fields should be private, however, so they make the fields private and supply
   public accessor methods. But they have only complicated the public access. They certainly haven't
   made the system object oriented.

Draw thyself
   One ramification of full field encapsulation is in user interface (UI) construction. If you can't use
   accessors, you can't have a UI builder class call a getAttribute() method. Instead, classes have
   elements like drawYourself(...) methods.

   A getIdentity() method can also work, of course, provided it returns an object that implements the
   Identity interface. This interface must include a drawYourself() (or
   give-me-a-JComponent-that-represents-your-identity) method. Though getIdentity starts with "get,"
   it's not an accessor because it doesn't just return a field. It returns a complex object that has
   reasonable behavior. Even when I have an Identity object, I still have no idea how an identity is
   represented internally.

   Of course, a drawYourself() strategy means that I (gasp!) put UI code into the business logic.
   Consider what happens when the UI's requirements change. Let's say I want to represent the attribute
   in a completely different way. Today an "identity" is a name; tomorrow it's a name and ID number; the
   day after that it's a name, ID number, and picture. I limit the scope of these changes to one place
   in the code. If I have a give-me-a-JComponent-that-represents-your-identity class, then I've isolated
   the way identities are represented from the rest of the system.

   Bear in mind that I haven't actually put any UI code into the business logic. I've written the UI
   layer in terms of AWT (Abstract Window Toolkit) or Swing, which are both abstraction layers. The
   actual UI code is in the AWT/Swing implementation. That's the whole point of an abstraction layer-to
   isolate your business logic from a subsystem's mechanics. I can easily port to another graphical
   environment without changing the code, so the only problem is a little clutter. You can easily
   eliminate this clutter by moving all the UI code into an inner class (or by using the Fa√ßade design
   pattern).

JavaBeans
   You might object by saying, "But what about JavaBeans?" What about them? You can certainly build
   JavaBeans without getters and setters. The BeanCustomizer, BeanInfo, and BeanDescriptor classes all
   exist for exactly this purpose. The JavaBean spec designers threw the getter/setter idiom into the
   picture because they thought it would be an easy way to quickly make a bean-something you can do
   while you're learning how to do it right. Unfortunately, nobody did that.

   Accessors were created solely as a way to tag certain properties so a UI-builder program or
   equivalent could identify them. You aren't supposed to call these methods yourself. They exist for an
   automated tool to use. This tool uses the introspection APIs in the Class class to find the methods
   and extrapolate the existence of certain properties from the method names. In practice, this
   introspection-based idiom hasn't worked out. It's made the code vastly too complicated and
   procedural. Programmers who don't understand data abstraction actually call the accessors, and as a
   consequence, the code is less maintainable. For this reason, a metadata feature will be incorporated
   into Java 1.5 (due in mid 2004). So instead of:
private int property;
public int getProperty  (         ){ return property; }
public void setProperty (int value}{ property = value; }

   You'll be able to use something like:
private @property int property;

   The UI-construction tool or equivalent will use the introspection APIs to find the properties, rather
   than examine method names and infer a property's existence from a name. Therefore, no runtime
   accessor damages your code.

When is an accessor okay?
   First, as I discussed earlier, it's okay for a method to return an object in terms of an interface
   that the object implements because that interface isolates you from changes to the implementing
   class. This sort of method (that returns an interface reference) is not really a "getter" in the
   sense of a method that just provides access to a field. If you change the provider's internal
   implementation, you just change the returned object's definition to accommodate the changes. You
   still protect the external code that uses the object through its interface.

Next, I think of all OO systems as having a procedural boundary layer. The vast majority of OO programs
runs on procedural operating systems and talks to procedural databases. The interfaces to these external
procedural subsystems are generic by nature. Java Database Connectivity (JDBC) designers don't have a clue
about what you'll do with the database, so the class design must be unfocused and highly flexible. Normally,
unnecessary flexibility is bad, but in these boundary APIs, the extra flexibility is unavoidable. These
boundary-layer classes are loaded with accessor methods simply because the designers have no choice.

In fact, this not-knowing-how-it-will-be-used problem infuses all Java packages. It's difficult to
eliminate all the accessors if you can't predict how you will use the class's objects. Given this
constraint, Java's designers did a good job hiding as much implementation as they could. This is not to
say that the design decisions that went into JDBC and its ilk apply to your code. They don't. We do know
how we will use the classes, so you don't have to waste time building unnecessary flexibility.

A design strategy
So how do you design without getters and setters?

The OO design process centers on use cases: a user performs standalone tasks that have some useful
outcome. (Logging on is not a use case because it lacks a useful outcome in the problem domain. Drawing
a paycheck is a use case.) An OO system, then, implements the activities needed to play out the various
scenarios that comprise a use case. The runtime objects that play out the use case do so by sending
messages to one another. Not all messages are equal, however. You haven't accomplished much if you've
just built a procedural program that uses objects and classes.

In 1989, Kent Beck and Ward Cunningham taught classes on OO design, and they had problems getting people
to abandon the get/set mentality. They characterized the problem as follows:

The most difficult problem in teaching object-oriented programming is getting the learner to give up the
global knowledge of control that is possible with procedural programs, and rely on the local knowledge
of objects to accomplish their tasks. Novice designs are littered with regressions to global thinking:
gratuitous global variables, unnecessary pointers, and inappropriate reliance on the implementation of
other objects.
Cunningham developed a teaching methodology that nicely demonstrates the design process: the CRC (classes,
responsibilities, collaboration) card. The basic idea is to make a set of 4x6 index cards, laid out in
three sections:

Class: The name of a class of objects.
Responsibilities: What those objects can do. These responsibilities should focus on a single area of
expertise.
Collaborators: Other classes of objects that can talk to the current class of objects. This set should
be as small as possible.
The initial pass at the CRC card is just guesswork-things will change.

Beck and Cunningham then picked a use case and made a best guess at determining which objects would
be required to act out the use case. They typically started with two objects and added others as the
scenario played out. They selected people from the class to represent those objects and handed them a
copy of the associated CRC card. If they needed several objects of a given class, then several people
represented those objects.

The class then literally acted out the use case following these rules:

Perform the activities that comprise the use case by talking to one another.
You can only talk to your collaborators. If you must talk to someone else, you should talk to a collaborator
who can talk to the other person. If that isn't possible, add a collaborator to your CRC card.
You may not ask for the information you need to do something. Rather, you must ask the collaborator who
has the information to do the work. It's okay to pass to that collaborator information he needs to do
the work, but keep this interaction to a minimum.
If something needs to be done and nobody can do it, create a new class (and CRC card) or add a responsibility
to an existing class (and CRC card).
If a CRC card gets too full, you must create another class (CRC card) to handle some of the
responsibilities. Complexity is limited by what you can fit on a 4x6 index card.
A recording made of the entire conversation is the program's dynamic model. The finished set of CRC cards
is the program's static model. With many fits and starts, you can solve just about any problem this way.

The process I just described is the OO design process, albeit simplified for a classroom environment. Some
people design real programs this way using CRC cards. More often than not, however, designers develop
the dynamic and static models in Unified Modeling Language (UML). The point is that an OO system is
a conversation between objects. If you think about it for a moment, get/set methods just don't come up
when you have a conversation. By the same token, get/set methods won't appear in your code if you design
in this manner before you start coding.

Summing up
Let's pull everything together: You shouldn't use accessor methods (getters and setters) unless absolutely
necessary because these methods expose information about how a class is implemented and as a consequence
make your code harder to maintain. Sometimes get/set methods are unavoidable, but an experienced OO
designer could probably eliminate 99 percent of the accessors currently in your code without much difficulty.

Getter/setter methods often make their way in code because the coder was thinking procedurally. The best
way to break out of that procedural mindset is to think in terms of a conversation between objects that
have well-defined responsibilities. Cunningham's CRC card approach is a great way to get started.

Parts of this article are adapted from my forthcoming book, tentatively titled Holub on Patterns:
Learning Design Patterns by Looking at Code, to be published by Apress (www.apress.com) this fall.

Allen Holub has worked in the computer industry since 1979. He currently works as a consultant,
helping companies not squander money on software by providing advice to executives, training, and
design-and-programming services. He's authored eight books, including Taming Java Threads (Apress, 2000)
and Compiler Design in C (Pearson Higher Education, 1990), and teaches regularly for the University of
California Berkeley Extension. Find more information on his Website (http://www.holub.com).
Learn more about this topic

---
[**3]
http://wiki.c2.com/?AccessorsAreEvil

Accessors Are Evil
Are public accessors a CodeSmell?
For the uninitiated, accessors are methods that let you read and write the value of an instance variable
of an object.
They are also known as setters and getters.
For some, whenever a public accessor is found in a codebase, AlarmBells start to go off.
The Original Argument
Public accessors indicate that the data and the behavior of a class are not kept together.
This is seen as a an indication of higher coupling and lower coherence.
In Java, accessors force you to treat each variable as a separate entity and this leads to lots of code
with the only purpose of shuffling data back and forth.
In most cases, public accessors are just as smelly as direct public access to member variables.
If that is what you need, why don't you skip the accessors altogether?
They are not going to give you much protection.
As a guideline assume that whenever you add an accessor to an object, you did something wrong.
Ask your compiler (or tests) about who uses the accessor, and then determine whether this is a good use.
Typically, one can categorize most accessor uses into one of two situations.
    * A client of the object makes a decision based upon the state of the object.

    Ask yourself: Why can't the object itself make this decision?

    * A client of the class needs to move the data to some external medium.

    Examples include: Database, files, network transport and user interface.

So how to externalize data without violating encapsulation
This is very close to the question answered by the MementoPattern.
The memento pattern does not seem to apply to user interfaces or network traffic, although it could
probably be extended this way easily.
The general approach of my suggested solution makes the object responsible for driving the process.
A demonstration of idea using Java code follows:
  interface DataTarget {
    public void putData(String key, Object value);
  }


  interface DataSource {
    public Object getData(String key);
  }


  class ObjectToExternalize {
    public void externalizeTo(DataTarget? target) {
    target.putData("myFirstFieldName", myFirstField);
    target.putData("mySecondFieldName", mySecondField);
    target.putData("myThirdFieldName", myThirdField);
    }


    public void readFrom(DataSource source) {
    myFirstField = source.getData("myFirstFieldName");
    mySecondField = source.getData("mySeconFieldName");
    myThirdField = source.getData("myThirdFieldName");
    }
  }


  class DatabaseGateway implements DataTarget, DataSource {
    java.sql.ResultSet rowset;


    public void putData(String key, Object value) {
    rowset.updateObject(key, value);
    }


    public Object getData(String key) {
    rowset.getObject(key);
    }
  }


  class DatabaseMediator {
    public ObjectToExternalize doYourStuff() {
    ObjectToExternalize newObject = new ObjectToExternalize();
    DatabaseGateway data = new DatabaseGateway();
    // Initialize the gateway with a suitable rowset
    newObject.readFrom(data);


    newObject.doYourStuff();


    newObject.externalizeTo(data);


    // commit the update
    }
  }


  class Dialog implements DataSource, DataTarget? {
    // Maps from Strings to java.swing.JTextComponent or something similar
    java.util.Map fieldNamesToControls;


    public void putData(String key, Object value) {
    JTextComponent component = (JTextComponent)fieldNamesToControls.get(key);
    component.setText(value.toString());
    }


    public Object getData(String key) {
    JTextComponent component = (JTextComponent)fieldNamesToControls.get(key);
    return component.getText(key);
    }
  }

Some ideas for further exploration:
    * One interface DataExchange for both reading and writing. This is roughly equivalent to the
    MicrosoftFoundationClasses' idea of DataExchange
    * A field name mapper to handle the situation that the internally used field names are different
    from the external ones (see DecoratorPattern)
    * Specialized interfaces for situations where the semantic behaviour of the fields must be preserved
    * Use of an identity field to ease the mapping to a relational database
    * A spike to see whether the use of String-based keys has any performance impact.
    * A solution for translating from different Object classes to Strings.

-- JohannesBrodwall
Feedback
We use a similar architecture for getting the data from the model objects to the user interface in
our web application. It works well, although I'd like to generalize it, particularly in regards to
collections and other composite objects. Our current approach is a mistake and full of DuplicatedCode,
but the ReFactored solution that I'm thinking of seems like a reinvention of XML. I'm still toying with
these problems. -- MarkAddleman
Personally, I've never had a problem with Accessors, ever. For
a spin on this subject from a diametrically opposed opinion, see
http://web.archive.org/web/20040708065354/http://www.scs.carleton.ca/~deugo/95540/Notes/Foundation/foundation.html
or http://www.rolemodelsoftware.com/moreAboutUs/publications/articles/self-enc.php for a revised edition.
There's a good article on this subject in KentBecksGuideToBetterSmalltalk, "To accessor or not to
accessor". I don't think accessors are evil (yet), but seeing a class with 30 fields that do nothing
but read and write a privatized variables does have a slight stench about it. The attractiveness of this
idea is that it brings us closer to qwon. -- AaronSevivas
Is it just me, or does almost all demo code explaining JavaBeans (the non-Enterprise kind) fit this
description?
Usually that's the case, but half of JavaBeans is dynamic property scanning & access through
introspection... (the other half being pub/sub events). So the accessors in this case don't necessarily
stink since data-setting is the whole point to JavaBeans.
Generally I think this is a good rule of thumb to use except when your task is to (literally) extract
data, for a database or GUI. That's why frameworks like JavaBeans, ValueModel & AspectAdaptor (both
in VisualWorksSmalltalk), exist... they provide a data-access abstraction that tends to preserve
encapsulation. -- StuCharlton
 But are accessors really the best way to move bulk amounts of data around? -- JohannesBrodwall

Accessors are not evil, EvilIsEvil. Too many accessors is bad design, but too many people get confused
and decide that more than 0 must be too many. Can there be no middle path? -- JohnFarrell
  I am afraid I will have to go ahead and disagree with you, John.
  Even though I use the phrase to spark a discussion more than violent agreement,
  I must admit that there is more than a core of truth to it. I have yet
  to see an example of use of accessors that did not smell to some extent.
  I don't think it is realistic (or even valuable)
  to decide that more than 0 is forbidden. Sometimes you have to live with evil,
  but it is still evil. -- JohannesBrodwall (donning the extremist's cape)

Took me a little while to understand the opinion here. Seems fair to say that accessors are used where
state is moving between objects. The evilness of this fact depends upon the constraints involved.
Consider that any parameterized function, which might return a value, may be considered equivalent to
a setter or a getter, or both, from the point of view of the client. Getters/setters are not privileged
in any respect.
I tend to place functionality at the level of minimum explicit coupling. If a function only involves a
single object then the function should rest in its class. If the functionality involves two (or more)
disparate objects then placing the functionality in either object creates a dependency, so a third
object/context is appropriate. This might mean a 'getter/setter', or a direct access. Thus I would have
a Complex class and a ComplexOp class which defines the op's on Complex numbers etc. Not very OO I know,
but then I prefer my types to remain relatively stable.
For the examples above someone noted that they are 'reinventing XML', and that is a good point. When
two objects interact, if that interaction is to be more than an explicit coupling between two classes,
then an intermediate protocol is being established, with an intermediate message format. Not only are we
reinventing XML, but PUT/GET too. These are universals. It isn't a bad thing at all IMO. Take a look at a
paper by AlistairCockburn, The Interaction of Social Issues and Software Architectures (it's only in PDF)
at http://alistair.cockburn.us/crystal/articles/isiasa/ACM%20interaction%20of%20soc%20iss%20sw%20arch.pdf
He argues for both ways, and describes a time when accessors paid off. Roughly speaking, he writes:
    * Accessor methods are good, as they provide a constant interface should the data access technique
    change.
    * Accessor methods are bad, as they slow the software and add complexity to the object's interface.
    * Using accessor methods for every instance variable is good, making the code uniform, hence easier
    to read and modify (the Consistency principle).
    * Using accessor methods for every instance variable is bad, exposing more of an object's inside
    than may be desirable (the Abstraction principle).
    * They are controversial: some people swear by them, some swear at them.

Therefore, in the case he describes: Require "persistence accessor methods", getters and setters for the
persistent instance variables of persistent objects. They are property of the infrastructure, not the
domain designers, and may be regenerated at any time. Access to other instance variables is considered a
"local matter" to each design group.
Accessors are not evil because:
   1. logical properties - the get/set interface has nothing to do with your public members. By exposing
   public members you've locked your self into a set of attributes that may not even exist in later
   versions, yet the information at the class level has is not the same. It is encapsulation to present
   an interface for the class that is independent of the underlying implementation.

      For example, in a communication system the underlying data are stored in a serialized buffer
      for quick transmission. There are set accessors that write directly into the buffer. There is
      no corresponding attribute to publicly expose.

      Take for example a date attribute in a class. It's no business of a user how you store the
      date. By exposing a date object you've locked yourself in.

   2. validation - without a degree of indirection you can't insert your own validation layer. The date
   object, for example, can't know the domain validations associated with the class so the validations
   can't really be put in that date class.

   3. event propagation - if you have observers you need to say the object has changed. Nobody wants to
   know a contained date object has changed.

How much of this is a language issue? Some languages allow one to swap attributes with methods without
changing the interface (existing calling code). YagNi would dictate making attributes be attributes,
and only alter them if something more complicated is later needed. But, if a language requires you to
change the calling signature in order to "upgrade" to a method, then you may have to create a bunch of
accessors up front to avoid overhauling code upon attribute-to-method changes.
While AccessorsMutatorsViolateOop, they are more a sign of the weakness of the paradigm - or rather, of
the particular application of it - than a sign of bad design. They are to circumvent encapsulation while
staying within the letter of the law. They exist because OOP is not suited for some types of projects,
particularly those which are DataDriven on a very fine scale. Accessors and mutators are only a symptom;
the real misuse of tools is coming at a higher level.
Hrmm, while I try to practice avoiding value-laden words, the premise of this page is outright silly. There
are typically only two mechanisms for accessing an object's attributes (RubyLanguage only has one,
I'd be curious if there are more in odd languages) - 1) direct access to public member variables, and
2) using getters and setters. Suggesting that all instances of 2) smell requires accessing an object's
attributes would ideally only be done through 1). Which is laughable because this means that your object
cannot validate its attribute values (function setX(v) { if (v < 0) throw FooError; this.v = v; }),
cache transparently computed values (function getX() { if (this.x == null) loadXFromDisk(); return X;
}), refactor its innards and maintain a consistent interface (var X -> var square_of_X; function getX()
return this.X.sqrt(); }). And, there are instances where the object would not be able to guarantee a
consistent internal state--sometimes attributes must agree with each other (Example: RightTriangle has
three attributes--leg1_length, leg2_length, hypotenuse_length).
More generally, accessing public instance variables can be thought of as less-functional a specialization
of getters and setters with a unique interface. (Except in RubyLanguage, where it getters and setters
are enforced, but also made easy.)
What _does_ smell about accessors is a whole lot of monotonous code (function getX() { return this.X;
} function setX(X) { this.X = X; } function getY() { ...). ThePragmaticProgrammer recommends to use a
CodeGenerator in this case. (Except in Ruby, where it is built in :)
ThePragmaticProgrammer recommends always using getters and setters, because it is the more general
interface and will weather change. I agree.
-- JasonFelice
Er... transparent getters and setters, and even deleters, are easy to implement with PythonLanguage's
"properties". Ruby's not the only cool language out there in this respect. :-) -- ElizabethWiethoff
 "There are typically only two mechanisms for accessing an object's attributes ..."


Wrong. There's a third one: don't. And that's the point of this page. By the way, the title is a hyperbole
so take it with a grain a salt. Now, having received this clue, try to parse it again. Related pages
are TellDontAsk, LawOfDemeter (accessors invite LOD violations), LawOfDemeterRevisited. -- CostinCozianu
Don't!? I read that before, but did not believe that you were serious. I guess I'm confused, then. Given
the following scenarios, are they CodeSmell or just evidence of the hyperbole of the claim? If they are
CodeSmell, how else would you implement them?
    * The Point class in most GUI and text UI interfaces: You would simply not access the X and Y,
    neither by accessor nor by direct access.
    * Many class libraries have a "Complex" class. How would you write a program not accessing the real
    or imaginary parts?
    * ObjectRelationalMapping's row attributes. Construct replacement objects to serialize to the database
    whenever the user requests the update of some attribute? Flag the old one as deleted. (But you can't
    check whether the old one was deleted!)

Which gets me thinking - it suggests to me that perhaps for you this is CodeSmell because the object is
mutable, perhaps?
-- JasonFelice
The examples you provided are certainly evidence of the hyperbole in the title, and in addition they
are really structures (data), not quite objects - in the sense given in NygaardClassification. In order
for the real objects to work, you need all kinds of structs to pass data for the messages between the
objects - in languages like Java and Smalltalk that data has to be called an object too, quite confusing
perhaps. Whereas in ObjectiveCaml, for example, you may just pass data in place in form of tuples,
or declare a record type. Python Ruby and Perl are also quite good at handling plain data. In C++
you'd declare a struct. In Java and Smalltalk you have to declare a class, making them syntactically
indistinguishable from the real objects. For all I care, you can make such structs as classes with all
fields public.
Oh, and O/R mapping is evil too :)
There is a difference between objects that have "behaviour" and therefore have identity and change their
state over time, and values that have no identity and are identified only by their state. Behavioural
objects (aka ReferenceObjects or "entities" in DomainDrivenDesign terminology) interact with one another
in a TellDontAsk style (following the LawOfDemeter). ValueObjects are processed in a FunctionalProgramming
style; they have to be because ValueObjectsShouldBeImmutable. So behavioural objects should not expose
accessors while ValueObjects should *only* expose accessors (or transformers that return new objects).
Generalizing to accessors distorts the assessment. Setters and Getters are different breeds of dog.
A setter involves this-here-object modifying the state of that-there-object. This almost always creates
maintenance problems and is smelly in the extreme.
If fu needs data from bar because (and only because) bar is the authoritative source or an agent of the
authoritative source (users, databases and other outside things need agents), then bar needs to provide a
getter interface for fu to use. There are a half-dozen design patterns to choose from that let bar tell
any and all interested fus that new or changed data is available and to "come and get it". Since fu is
in control, and the coupling is kept to the minimum required for bar to provide its service, it doesn't
smell at all. This is the essence of MVC.
-- MarcThibault See also ShouldMemberVariablesBeAccessibleToDerivedClasses ForgetAboutWritingAccessors
Often accessors seem to be used to write procedural code using OO. A good article about this (not all
of which I agree with) is http://www.javaworld.com/javaworld/jw-07-1999/jw-07-toolbox.html. -- BenTilly
I can nullify this whole argument using a single counterexample. Imaging you have a class that represents
an image; a very typical case in OO UI design. As the image may contain transparent regions, it is
useful to have a background color. The background color is a private state of the image class, it is
needed internally to perform the "draw" operation, that draws the image on the screen (or somewhere
else). However, it makes perfectly sense to set the background color from external code and it makes
perfectly sense to ask the image class for the current set background color. I don't know how you would
solve this without using an accessor, nor do I see any reason for avoiding this accessor. As with most
"... are evil" arguments, people see some pattern being used incorrectly and immediately declare it to be
evil. Then they take some (narrow) examples, where it is really possible to avoid the pattern and take
that as a proof, that the pattern is unnecessary as a whole. But if you take those patterns to a wide
range of examples, you end up with examples where this pattern is unavoidable or where every attempt to
avoid this pattern blows up the code complexity by a factor of ten, and guess what, "excessive complex
code is evil", about ten times more evil than every anti-pattern I've came across so far. -- Mecki
The whole "... are evil" thing is hyperbole. It's also a bit cliche these days. It's basically not much
more than a "don't use accessors unless you clearly gain something by doing so."
References and Further Reading'
HexagonalArchitecture, LawOfDemeter, TellDontAsk, Article by AllenHolub in JavaWorld
(http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html), RobertMartin argues that sometimes,
you can just make the instance variables public (http://www.artima.com/weblogs/viewpost.jsp?thread=36312)
---
Refactoring
DecemberZeroFive RefactorMe Now before it becomes a ThreadMess: Highlight the main point, show its
counterpoint(s), moved references to the top, move discussion to separate page (to be deleted later),
rephrase discussion with BlackHat/WhiteHat etc.
CategoryEvil
Last edit November 17, 2014, See github about remodling.


---
https://softwareengineering.stackexchange.com/questions/284215/how-do-you-avoid-getters-and-setters

How do you avoid getters and setters?

   I'm having something of a hard time with designing classes in an oo way. I've read that objects
   expose their behavior, not their data; therefore, rather than using getter/setters to modify data,
   the methods of a given class should be "verbs" or actions operating on the object. For example, in an
   'Account' object, we would have the methods Withdraw() and Deposit() rather than setAmount() etc.
   See: Why getter and setter methods are evil.

***
   As stated in quite a few answers and comments, DTOs are appropriate and useful in some situations,
   especially in transferring data across boundaries (e.g. serializing to JSON to send through a web
   service). For the rest of this answer, I'll more or less ignore that and talk about domain classes,
   and how they can be designed to minimize (if not eliminate) getters and setters, and still be useful
   in a large project. I also won't talk about why remove getters or setters, or when to do so, because
   those are questions of their own.

   As an example, imagine that your project is a board game like Chess or Battleship. You might have
   various ways of representing this in a presentation layer (console app, web service, GUI,etc.), but
   you also have a core domain. One class you might have is Coordinate, representing a position on the
   board. The "evil" way to write it would be:
public class Coordinate
{
    public int X {get; set;}
    public int Y {get; set;}
}

   (I'm going to be writing code examples in C# rather than Java, for brevity and because I'm more
   familiar with it. Hopefully that's not a problem. The concepts are the same and the translation
   should be simple.)

Removing Setters: Immutability
   While public getters and setters are both potentially problematic, setters are the far more "evil" of
   the two. They're also usually the easier to eliminate. The process is a simple one- set the value
   from within the constructor. Any methods which previously mutated the object should instead return a
   new result. So:
public class Coordinate
{
    public int X {get; private set;}
    public int Y {get; private set;}

    public Coordinate(int x, int y)
    {
    X = x;
    Y = y;
    }
}

   Note that this doesn't protect against other methods in the class mutating X and Y. To be more
   strictly immutable, you could use readonly (final in Java). But either way- whether you make your
   properties truly immutable or just prevent direct public mutation through setters- it does the trick
   of removing your public setters. In the vast majority of situations, this works just fine.

Removing Getters, Part 1: Designing for Behavior
   The above is all well and good for setters, but in terms of getters, we actually shot ourselves in
   the foot before even starting. Our process was to think of what a coordinate is- the data it
   represents- and create a class around that. Instead, we should have started with what behavior we
   need from a coordinate. This process, by the way, is aided by TDD, where we only extract classes like
   this once we have a need for them, so we start with the desired behavior and work from there.

   So let's say that the first place you found yourself needing a Coordinate was for collision
   detection: you wanted to check if two pieces occupy the same space on the board. Here's the "evil"
   way (constructors omitted for brevity):
public class Piece
{
    public Coordinate Position {get; private set;}
}

public class Coordinate
{
    public int X {get; private set;}
    public int Y {get; private set;}
}

    //...And then, inside some class
    public bool DoPiecesCollide(Piece one, Piece two)
    {
    return one.X == two.X && one.Y == two.Y;
    }

   And here's the good way:
public class Piece
{
    private Coordinate _position;
    public bool CollidesWith(Piece other)
    {
    return _position.Equals(other._position);
    }
}

public class Coordinate
{
    private readonly int _x;
    private readonly int _y;
    public bool Equals(Coordinate other)
    {
    return _x == other._x && _y == other._y;
    }
}

   (IEquatable implementation abbreviated for simplicity). By designing for behavior rather than
   modelling data, we've managed to remove our getters.

   Note this is also relevant to your example. You may be using an ORM, or display customer information
   on a website or something, in which case some kind of Customer DTO would probably make sense. But
   just because your system includes customers and they are represented in the data model does not
   automatically mean you should have a Customer class in your domain. Maybe as you design for behavior,
   one will emerge, but if you want to avoid getters, don't create one pre-emptively.

Removing Getters, Part 2: External Behaviour
   So the above is a good start, but sooner or later you will probably run into a situation where you
   have behavior which is associated with a class, which in some way depends on the class's state, but
   which doesn't belong on the class. This sort of behavior is what typically lives in the service layer
   of your application.

   Taking our Coordinate example, eventually you'll want to represent your game to the user, and that
   might mean drawing to the screen. You might, for example, have a UI project which uses Vector2 to
   represent a point on the screen. But it would be inappropriate for the Coordinate class to take
   charge of converting from a coordinate to a point on the screen- that would be bringing all sorts of
   presentation concerns into your core domain. Unfortunately this type of situation is inherent in OO
   design.

   The first option, which is very commonly chosen, is just expose the damn getters and say to hell with
   it. This has the advantage of simplicity. But since we're talking about avoiding getters, let's say
   for argument's sake we reject this one and see what other options there are.

   A second option is to add some kind of .ToDTO() method on your class. This- or similar- may well be
   needed anyway, for example when you want to save the game you need to capture pretty much all of your
   state. But the difference between doing this for your services and just accessing the getter directly
   is more or less aesthetic. It still has just as much "evil" to it.

   A third option- which I've seen advocated by Zoran Horvat in a couple of Pluralsight videos- is
   to use a modified version of the visitor pattern. This is a pretty unusual use and variation of the
   pattern and I think people's mileage will vary massively on whether it's adding complexity for no
   real gain or whether it's a nice compromise for the situation. The idea is essentially to use the
   standard visitor pattern, but have the Visit methods take the state they need as parameters, instead
   of the class they're visiting. Examples can be found here.

   For our problem, a solution using this pattern would be:
public class Coordinate
{
    private readonly int _x;
    private readonly int _y;

    public T Transform<T>(IPositionTransformer<T> transformer)
    {
    return transformer.Transform(_x,_y);
    }
}

public interface IPositionTransformer<T>
{
    T Transform(int x, int y);
}

//This one lives in the presentation layer
public class CoordinateToVectorTransformer : IPositionTransformer<Vector2>
{
    private readonly float _tileWidth;
    private readonly float _tileHeight;
    private readonly Vector2 _topLeft;

    Vector2 Transform(int x, int y)
    {
    return _topLeft + new Vector2(_tileWidth*x + _tileHeight*y);
    }
}

   As you can probably tell, _x and _y aren't really encapsulated any more. We could extract them by
   creating an IPositionTransformer<Tuple<int,int>> which just returns them directly. Depending on
   taste, you may feel this makes the entire exercise pointless.

   However, with public getters, it's very easy to do things the wrong way, just pulling data out
   directly and using it in violation of Tell, Don't Ask. Whereas using this pattern it's actually
   simpler to do it the right way: when you want to create behaviour, you'll automatically start by
   creating a type associated with it. Violations of TDA will be very obviously smelly and probably
   require working around a simpler, better solution. In practice, these points make it much easier to
   do it the right, OO, way than the "evil" way that getters encourage.

   Finally, even if it isn't initially obvious, there may in fact be ways to expose enough of what you
   need as behavior to avoid needing to expose state. For example, using our previous version of
   Coordinate whose only public member is Equals() (in practice it would need a full IEquatable
   implementation), you could write the following class in your presentation layer:
public class CoordinateToVectorTransformer
{
    private Dictionary<Coordinate,Vector2> _coordinatePositions;

    public CoordinateToVectorTransformer(int boardWidth, int boardHeight)
    {
    for(int x=0; x<boardWidth; x++)
    {
        for(int y=0; y<boardWidth; y++)
        {
        _coordinatePositions[new Coordinate(x,y)] = GetPosition(x,y);
        }
    }
    }

    private static Vector2 GetPosition(int x, int y)
    {
    //Some implementation goes here...
    }

    public Vector2 Transform(Coordinate coordinate)
    {
    return _coordinatePositions[coordinate];
    }
}

   It turns out, perhaps surprisingly, that all the behavior we really needed from a coordinate to
   achieve our goal was equality checking! Of course, this solution is tailored to this problem, and
   makes assumptions about acceptable memory usage/performance. It's just an example that fits this
   particular problem domain, rather than a blueprint for a general solution.

   And again, opinions will vary on whether in practice this is needless complexity. In some cases, no
   such solution like this might exist, or it might be prohibitively weird or complex, in which case you
   can revert to the above three.

***
     * Beautifully answered! I would like to accept, but first some comments:1. I do think the toDTO()
       is great, bcuz ur not accessing the get/set, which allows u to change the fields given to DTO w/o
       breaking existing code. 2. Say Customer has enough behaviour to justify making it an entity, how
       would u access props to modify them, e.g. address/tel change etc. - IntelliData May 28 '15 at
       17:02
     * @IntelliData 1. When you say "change the fields", you mean change the class definition or mutate
       the data? The latter can just be avoided by removing public setters but leaving the getters, so
       the dto aspect is irrelevant. The former isn't really the (whole) reason that public getters are
       "evil". See programmers.stackexchange.com/questions/157526/... for example. - Ben Aaronson
       May 28 '15 at 17:58
     * @IntelliData 2. This is difficult to answer without knowing the behaviour. But probably, the
       answer is: you wouldn't. What behaviour could a Customer class have that requires being able to
       mutate its telephone number? Perhaps the customer's telephone number changes and I need to
       persist that change in the database, but none of that is the responsibility of a
       behaviour-providing domain object. That's a data-access concern, and would probably be handled
       with a DTO and, say, a repository. - Ben Aaronson May 28 '15 at 18:03
     * @IntelliData Keeping the Customer domain object's data relatively fresh (in sync with the db) is
       a matter of managing its lifecycle, which is also not its own responsibility, and would again
       probably end up living in a repository or a factory or an IOC container or whatever instantiates
       Customers. - Ben Aaronson May 28 '15 at 18:03
     * 2
       I really like the Design for Behavior concept. This informs the underlying "data structure" and
       helps avoid the all too common anemic, hard-to-use classes. plus one. - radarbob Jun 3 '15 at
       15:38

***
   The simplest way to avoid setters is to hand the values to the constructor method when you new up the
   object. This is also the usual pattern when you want to make an object immutable. That said, things
   are not always that clear in the real world.

   It is true that methods should be about behavior. However, some objects, like Customer, exist
   primarily to hold information. Those are the kinds of objects that benefit the most from getters and
   setters; were there no need at all for such methods, we would simply eliminate them altogether.

***
   It is perfectly fine to have an object which exposes data rather than behavior. We just call it a
   "data object". The pattern exists under names like Data Transfer Object or Value Object. If the
   purpose of the object is to hold data, then getters and setters are valid to access the data.

   So why would someone say "getter and setter methods are evil"? You will see this a lot - someone
   takes a guideline which is perfectly valid in a specific context and then remove the context in order
   to get a more hard-hitting headline. For example "favor composition over inheritance" is a fine
   principle, but soon enough someone is going to remove the context and write "Why extends is evil"
   (hey, same author, what a coincidence!) or "inheritance is evil and must be destroyed".

   If you look at the content of the article it actually have some valid points, it just stretches the
   point to make a click-baity headline. For example, the article states that implementation details
   should not be exposed. This is the principles of encapsulation and data hiding which are fundamental
   in OO. However, a getter method does not by definition expose implementation details. In the case of
   a Customer data object, the properties of Name, Address etc. are not implementation details but
   rather the whole purpose of the object and should be part of the public interface.

   Read the continuation of the article you link to, to see how he suggest actually setting
   properties like 'name' and 'salary' on a 'Employee'-object without the use of the evil setters. Turns
   out he uses a pattern with an 'Exporter' which is populated with methods called addName, addSalary
   which in turn sets fields of the same name... So in the end he ends up using exactly the setter
   pattern, just with a different naming convention.

   This is like thinking you avoid the pitfalls of singletons by renaming them therecanbeonlyonethings
   while keeping the same implementation.

***
   To transform the Customer-class from a data object, we can ask ourselves the following questions
   about the data fields:

   How do we want to use {data field}? Where is {data field} used? Can and should the use of {data
   field} be moved to the class?

   E.g.:
     * What is the purpose of Customer.Name?
       Possible answers, display the name in a login web page, use the name in mailings to the customer.
       Which leads to methods:
      + Customer.FillInTemplate(...)
      + Customer.IsApplicableForMailing(...)
     * What is the purpose of Customer.DOB?
       Validating the customer's age. Discounts on the customer's birthday. Mailings.
      + Customer.IsApplicableForProduct()
      + Customer.GetPersonalDiscount()
      + Customer.IsApplicableForMailing()

   Given the comments, the example object Customer - both as a data object and as "real" object with its
   own responsibilities - is too broad; i.e. it has too much properties/responsibilities. Which leads to
   either lots of components depending on Customer (by reading its properties) or to Customer depending
   on lots of components. Perhaps there exist different views of customer, perhaps each should have its
   own distinct class^1:
     * The customer in the context of Account and monetary transactions is probably only used to:
      + help humans identify that their money transfer goes to the correct person; and
      + group Accounts.
       This customer does not need fields like DOB, FavouriteColour, Tel, and perhaps not even Address.
     * The customer in the context of a user logging in to a banking website.
       Relevant fields are:
      + FavouriteColour, which might come in the form of personalised theming;
      + LanguagePreferences, and
      + GreetingName
       Instead of properties with getters and setters, these might be captured in a single method:
      + PersonaliseWebPage(Template page);
     * The customer in the context of marketing and and personalised mailing.
       Here not relying on the properties of a dataobject, but instead starting from the
       responsibilities of the object; e.g.:
      + IsCustomerInterestedInAction(); and
      + GetPersonalDiscounts().
       The fact that this customer object has a FavouriteColour property, and/or an Address property
       becomes irrelevant: perhaps the implementation uses these properties; but it might also use some
       machine learning techniques and use previous interactions with the customer to discover in which
       products the customer might be interested.
     ________________________________________________________________________________________________

   ^1. Of course, the Customer and Account classes were examples, and for a simple example or homework
   exercise, splitting this customer might be overkill, but with the example of splitting, I hope to
   demonstrate that the method of turning a data object into an object with responsibilities will work.

***
   TL;DR
     * Modeling for behavior is good.
     * Modeling for good(!) abstractions is better.
     * Sometimes data objects are required.
     ________________________________________________________________________________________________

   Behavior and Abstraction
   There are several reasons to avoid getters and setters. One is, as you noted, to avoid modeling data.
   This is actually the minor reason. The bigger reason is to provide abstraction.

   In your example with the bank account that is clear: A setBalance() method would be really bad
   because setting a balance is not what an account should be used for. The behavior of the account
   should abstract from its current balance as much as possible. It may take the balance into account
   when deciding whether to fail a withdrawal, it may give access to the current balance, but modifying
   interaction with a bank account should not require the user to calculate the new balance. That's what
   the account should do itself.

   Even a pair of deposit() and withdraw() methods is not ideal to model a bank account. A better way
   would be to provide only one transfer() method that takes another account and an amount as arguments.
   This would allow the account class to trivially ensure that you don't accidentally create/destroy
   money in your system, it would provide a very usable abstraction, and it would actually provide users
   with more insight because it would force the use of special accounts for earned/invested/lost money
   (see double-accounting). Of course, not every use of an account needs this level of abstraction,
   but it is definitely worth considering how much abstraction your classes can provide.

   Note that providing abstraction and hiding data internals is not always the same thing. Almost any
   application contains classes that are effectively just data. Tuples, dictionaries, and arrays are
   frequent examples. You don't want to hide the x-coordinate of a point from the user. There is very
   little abstraction that you can/should be doing with a point.
     ________________________________________________________________________________________________

   The Customer Class
   A customer is certainly an entity in your system that should try to provide useful abstractions. For
   instance, it should likely be associated with a shopping cart, and the combination of the cart and
   the customer should allow committing a purchase, which might kick off actions like sending him the
   requested products, charging him money (taking into account his selected payment method), etc.

   The catch is, that all the data that you mentioned is not only associated with a customer, all of
   that data is also mutable. The customer may move. They may change their credit card company. They may
   change their email-address and phone number. Heck, they may even change their name and/or sex! So, a
   full featured customer class indeed has to provide full modifying access to all these data items.

   Still, the setters can/should provide non-trivial services: They can ensure correct format of
   email-adresses, verification of postal adresses, etc. Likewise, the "getters" can provide high-level
   services like providing email-adresses in the Name <user@server.com> format using the name fields and
   the deposited email address, or provide a correctly formatted postal address, etc. Of course, what of
   this high level functionality makes sense depends heavily on your use-case. It might be complete
   overkill, or it might call for another class to do it right. The choice of abstraction level is not
   an easy one.

***
   Trying to expand on Kasper's answer, it's easiest to rant against and eliminate setters. In a rather
   vague, handwaving (and hopefully humorous) argument:

   When would Customer.Name ever change?

   Seldom. Maybe they got married. Or went into witness protection. But in that case you'd also want to
   check on and possibly change their residence, next of kin, and other information.

   When would DOB ever change?

   Only on initial creation, or on a data entry screwup. Or if they are a Domincan baseball player. :-)

   These fields should not be accessible with routine, normal setters. Maybe you have a
   Customer.initialEntry() method, or a Customer.screwedUpHaveToChange() method that requires special
   permissions. But don't have a public Customer.setDOB() method.

   Usually a Customer is read from a database, a REST API, some XML, whatever. Have a method
   Customer.readFromDB(), or, if you are stricter about SRP / separation of concerns, you'd have a
   separate builder, e.g. a CustomerPersister object with a read() method. Internally, they somehow set
   the fields (I prefer using package access or an inner class, YMMV). But again, avoid public setters.

   (Addendum as Question has changed somewhat...)

   Let's say that your application makes heavy use of relational databases. It would be foolish to have
   Customer.saveToMYSQL() or Customer.readFromMYSQL() methods. That creates undesireable coupling to a
   concrete, non-standard, and likely to change entity. For example, when you change the schema, or
   change to Postgress or Oracle.

   However, IMO, it's perfectly acceptable to couple Customer to an abstract standard, ResultSet. A
   separate helper object (I'll call it CustomerDBHelper, which is probably a subclass of
   AbstractMySQLHelper) knows about all the complex connections to your DB, knows the tricky
   optimization details, knows the tables, query, joins, etc... (or uses a ORM like Hibernate) to
   generate the ResultSet. Your object talks to the ResultSet, which is an abstract standard, unlikely
   to change. When you change the underlying database, or change the schema, Customer doesn't change,
   but the CustomerDBHelper does. If you are lucky, it's only AbstractMySQLHelper that changeswhich
   automatically makes the changes for Customer, Merchant, Shipping etc...

   This way you can (perhaps) avoid or lessen the need for getters and setters.

   And, the main point of the Holub article, compare and contrast the above to how it would be if you
   used getters and setters for everything and changed the database.

   Similarly, let's say you use a lot of XML. IMO, it's fine to couple your Customer to an abstract
   standard, such as a Python xml.etree.ElementTree or a Java org.w3c.dom.Element. Customer gets and
   sets itself from that. Again, you can (perhaps) lessen the need for getters and setters.

***
     * would you say it is advisable to use a Builder Pattern? - IntelliData May 19 '15 at 16:55
     * Builder is useful for making the construction of an object easier and more robust, and, if you
       wish, allowing the object to be immutable. However, it still (partially) exposes the fact that
       the underlying object has a DOB field, so it's not the bee-all end-all. - user949300 May 19
       '15 at 17:10

***
   The issue of having getters and setters can be a matter of the fact that a class may be used in the
   business logic in one way but you may also have helper classes to serialize / deserialize the data
   from a database or file or other persistent storage.

   Due to the fact there are many ways to store / retrieve your data and you want to decouple the data
   objects from the way they are stored, the encapsulation can be "compromised" by either making these
   members public, or making them accessible through getters and setters which is almost as bad as
   making them public.

   There are various ways around this. One way is to make the data available to a "friend". Although
   friendship is not inherited, this can be overcome by whatever serializer requesting the information
   from the friend, i.e. the base serializer "forwarding" the information.

   Your class could have a generic "fromMetadata" or "toMetadata" method. From-metadata constructs an
   object so may well be a constructor. If it is dynamically typed language, metadata is pretty standard
   to such a language and probably is the primary way to construct such objects.

   If your language is C++ specifically, one way around this is to have a public "struct" of data and
   then for your class to have an instance of this "struct" as a member and in fact all the data you are
   going to store / retrieve to be stored in it. You can then easily write "wrappers" to read/write your
   data in multiple formats.

   If your language is C# or Java which don't have "structs" then you can do similarly but your struct
   is now a secondary class. There is no real concept of "ownership" of the data or const-ness so if you
   give out an instance of the class containing your data and it's all public, whatever gets hold can
   modify it. You could "clone" it although this can be expensive. Alternatively you could make this
   class have private data but use accessors. That gives users of your class a roundabout way to get to
   the data but it isn't the direct interface with your class and is really a detail in storing the data
   of the class which is a use-case too.

***
   OOP is about encapsulating and hidding behavior inside objects. Objects are black boxes. This is a
   way to design thing. The asset is in many case one doesn't need to know the internal state of another
   component and is better to not have to know it. You can enforce that idea with mainly interfaces or
   inside an object with visibility and taking care only allowed verbs/action are available to caller.

   This work well for some kind of problem. For example in user interfaces to modelize individual UI
   component. When you interract with a text box you are only interrested in setting the text, getting
   it or listening to text change event. You are typically not interrested as to where the cursor is,
   the font used to draw the text or how the keyboard is used. Encapsulation provide a lot here.

   On the contrary when you call a network service, your provide an explicit input. There usually a
   grammar (like in JSON or XML) and all the option of calling the service have no reason to be hidden.
   The idea is that you can call the service the way you want and the data format is public and
   published.

   In this case, or many other (like access to a database) you really work with shared data. As such
   there no reason to hide it, on the contrary you want to make it available. There can be concern of
   read/write access or datacheck consistency but at this core, the core concept if this is public.

   For such design requirement where you want to avoid encapsulation and make things publics and in the
   clear, you want to avoid objects. What you really need are tuples, C structs or their equivalent, not
   objects.

   But it also happen in languages like Java, the only things you can modelize is objects or arrays of
   objects. Objects themselve can hold a few natives types (int, float...) but that's all. But objects
   can also behave like a simple struct with just public fields and that all.

   So if you modelize data you can be done with just public fields inside objects because you don't need
   more. You don't use encapsulation because you don't need it. This is done this way in many languages.
   In java, historically, a standard rose where with getter/setter you could at least have read/write
   control (by not adding setter for example) and that toolings and framework by using instrospection
   API would look for getter/setter methods and use it to autofill the content or display theses as
   modifiable fields in auto generated user interface.

   There also the argument you could add some logic/checking in the setter method.

   In reality there almost no justification for getter/setters as they are most often used to modelize
   pure data. Frameworks and developpers using your objects do expect the getter/setter do nothing more
   than setting/getting the fields anyway. You are effectively doing no more with getter/setter than
   what could be done with public fields.

   But that's old habits and olds habits are difficult to remove... You could even be threatened by your
   collegues or teacher if you don't put getters/setter blindly everywhere if they lack the background
   to better understand what they are and what they are not.

   You would likely need to change the language to get ride of all theses getters/setters boilerplate
   code. (Like C# or lisp). To me getters/setter are just another one billion dollar mistake...

***
   I think this question is prickly because you are worried about behavior methods for populating data
   but I don't see any indication of what behavior the Customer class of objects is intended to
   encapsulate.

   Don't confuse Customer as a class of objects with 'Customer' as a user/actor who performs
   different tasks using your software.

   When you say given a Customer class that keeps alot if information about the customer then as far as
   behavior goes it looks like your Customer class has little distinguishing it from a rock. A Rock can
   have a color, you could give it a name, you could have a field for storing its current address but we
   don't expect any sort of intelligent behavior from a rock.

   From the linked article about getters/setters being evil:

     The OO design process centers on use cases: a user performs standalone tasks that have some useful
     outcome. (Logging on is not a use case because it lacks a useful outcome in the problem domain.
     Drawing a paycheck is a use case.) An OO system, then, implements the activities needed to play
     out the various scenarios that comprise a use case.

   Without any behavior defined, referring to a rock as a Customer doesn't change the fact that it is
   just an object with some properties you'd like to track and it doesn't matter what tricks you want to
   play to get away from getters and setters. A rock doesn't care if it has a valid name and a rock
   wouldn't be expected to know whether an address is valid or not.

   Your order system could associate a Rock with a purchase order and as long as that Rock has an
   address defined then some part of the system can make sure an item gets delivered to a rock.

   In all of these cases the Rock is just a Data Object and will continue to be one until we define
   specific behaviors with useful outcomes instead of hypotheticals.
     ________________________________________________________________________________________________

   Try This:

   When you avoid overloading the word 'Customer' with 2 potentially different meanings it should make
   things easier to conceptualize.

   Does a Rock object place an Order or is that something that a human being does by clicking on UI
   elements to trigger actions in your system?

***
   I add my 2 cents here mentioning SQL-speaking objects approach.

   This approach is based on the notion of self-contained object. It has all resources it needs to
   implement its behavior. It doesn't need to be told how to do its job -- declarative request is
   enough. And an object definitely doesn't have to hold all its data as class properties. It really
   doesn't -- and shouldn't -- matter where they are got from.

   Talking about an aggregate, immutability is not an issue as well. Say, you have a sequence of
   states that aggregate can hold: Aggregate root as saga It's totally fine to implement each state
   as standalone object. Probably you could go even further: have a chat with your domain expert.
   Chances are that he or she doesn't see this aggregate as some unified entity. Probably each state has
   it's own meaning, deserving it's own object.

   Finally, I'd like to note that object finding process is very similar with system decomposition
   into subsystems. Both are based on behavior, not anything else.


---
https://dzone.com/articles/getter-setter-use-or-not-use-0

Getter Setter: To Use or Not to Use

   DZone's Guide to

Getter Setter: To Use or Not to Use

Java Getter Setter
   Why do we keep instance variables private? We don't want other classes to depend on them. Moreover,
   it gives the flexibility to change a variable's type or implementation on a whim or an impulse. Why,
   then do programmers automatically add getters and setters to their objects, exposing their private
   variables as if they were public?

Accessor methods
   Accessors (also known as getters and setters) are methods that let you read and write the value of an
   instance variable of an object.
public class AccessorExample {
  private String attribute;
  public String getAttribute() {
    return attribute;
  }
  public void setAttribute(String attribute) {
    this.attribute = attribute;
  }
}

Why Accessors?
   There are actually many good reasons to consider using accessors rather than directly exposing fields
   of a class

   Getter and Setters make APIs more stable. For instance, consider a field public in a class which is
   accessed by other classes. Later on, we want to add any extra logic while getting and setting the
   variable. This will impact the existing client that uses the API. So any changes to this public field
   will require a change to each class that refers it. On the contrary, with accessor methods, one can
   easily add some logic like cache some data or lazily initialization etc.

   Accessor method also allows us to fire a property changed event if the new value is different from
   the previous value.

   Another advantage of using setters to set values is that we can use the method to preserve an
   invariant or perform some special processing when setting values.

   All this will be seamless to the class that gets the value using accessor method.

Should I have Accessor Methods for all my fields?
   Fields can be declared public for package-private or private nested class. Exposing fields in these
   classes produces less visual clutter compare to accessor-method approach, both in the class
   definition and in the client code that uses it.

   If a class is package-private or is a private nested class, there is nothing inherently wrong with
   exposing its data fields-assuming they do an adequate job of describing the abstraction provided by
   the class.

   Such code is restricted to the package where the class is declared, while the client code is tied to
   class internal representation. We can change it without modifying any code outside that package.
   Moreover, in the case of a private nested class, the scope of the change is further restricted to the
   enclosing class.

   Another example of a design that uses public fields is JavaSpace entry objects. Ken Arnold described
   the process they went through to decide to make those fields public instead of private with get and
   set methods here

   Now, this sometimes makes people uncomfortable because they've been told not to have public fields;
   that public fields are bad. And often, people interpret those things religiously. But we're not a
   very religious bunch. Rules have reasons. And the reason for the private data rule doesn't apply in
   this particular case. It is a rare exception to the rule. I also tell people not to put public fields
   in their objects, but exceptions exist. This is an exception to the rule because it is simpler and
   safer to just say it is a field. We sat back and asked: Why is the rule thus? Does it apply? In this
   case, it doesn't.

Private fields + Public accessors == encapsulation

   Consider the example below
public class A {
  public int a;
}

   Usually, this is considered bad coding practice as it violates encapsulation. The alternate approach
   is
public class A {
  private int a;

  public void setA(int a) {
    this.a =a;
  }

  public int getA() {
    return this.a;
  }
}

   It is argued that this encapsulates the attribute. Now is this really encapsulation?

   The fact is, Getters/setters have nothing to do with encapsulation. Here the data isn't more hidden
   or encapsulated than it was in a public field. Other objects still have intimate knowledge of the
   internals of the class. Changes made to the class might ripple out and enforce changes in dependent
   classes. Getter and setter in this way are generally breaking encapsulation. A truly
   well-encapsulated class has no setters and preferably no getters either. Rather than asking a class
   for some data and then compute something with it, the class should be responsible for computing
   something with its data and then return the result.

   Consider an example below,
public class Screens {
  private Map screens = new HashMap();

  public Map getScreens() {
    return screens;
  }

  public void setScreens(Map screens) {
    this.screens = screens;
  }

  // remaining code here
}

   If we need to get a particular screen, we do code like below,
Screen s = (Screen)screens.get(screenId);

   There are things worth noticing here....

   The client needs to get an Object from the Map and casting it to the right type. Moreover, the worst
   is that any client of the Map has the power to clear it which may not be the case we usually want.

   An alternative implementation of the same logic is:
public class Screens {
  private Map screens = new HashMap();

  public Screen getById(String id) {
    return (Screen) screens.get(id);
  }

  // remaining code here
}

   Here the Map instance and the interface at the boundary (Map) are hidden.

Getters and Setters are highly Overused
   Creating private fields and then using the IDE to automatically generate getters and setters for all
   these fields is almost as bad as using public fields.

   One reason for the overuse is that in an IDE it's just now a matter of few clicks to create these
   accessors. The completely meaningless getter/setter code is at times longer than the real logic in a
   class and you will read these functions many times even if you don't want to.

   All fields should be kept private, but with setters only when they make sense which makes object
   Immutable. Adding an unnecessary getter reveals internal structure, which is an opportunity for
   increased coupling. To avoid this, every time before adding the accessor, we should analyze if we can
   encapsulate the behavior instead.

   Let's take another example,
public class Money {
  private double amount;
  public double getAmount() {
    return amount;
  }
  public void setAmount(double amount) {
    this.amount = amount;
  }

  //client
  Money pocketMoney = new Money();
  pocketMoney.setAmount(15d);
  double amount = pocketMoney.getAmount();  // we know its double
  pocketMoney.setAmount(amount + 10d);
}

   With the above logic, later on, if we assume that double is not a right type to use and should use
   BigDecimal instead, then the existing client that uses this class also breaks.

   Let's restructure the above example,
public class Money {
  private BigDecimal amount;
  public Money(String amount) {
    this.amount = new BigDecimal(amount);
  }
  public void add(Money toAdd) {
    amount = amount.add(toAdd.amount);
  }

  // client
  Money balance1 = new Money("10.0");
  Money balance2 = new Money("6.0");
  balance1.add(balance2);
}

   Now instead of asking for a value, the class has a responsibility to increase its own value. With
   this approach, the change request for any other datatype in future requires no change in the client
   code. Here not only the data is encapsulated but also the data which is stored, or even the fact that
   it exists at all.

Conclusions
   Use of accessors to restrict direct access to field variable is preferred over the use of public
   fields, however, making getters and setter for each and every field is overkill. It also depends on
   the situation, though, sometimes you just want a dumb data object. Accessors should be added to a
   field where they're really required. A class should expose larger behavior which happens to use its
   state, rather than a repository of state to be manipulated by other classes.


---
https://codurance.com/2018/03/20/getters-and-setters-considered-harmful/

Getters and Setters Considered Harmful

   Why getters and setters may be inimical to be good object-oriented design.

   Java programmers habitually pepper their classes with "getters" and "setters",
   and this
   practice is so ingrained that probably few ever question why they do so, or whether they should.
   Lately I have come think that it is better not to and I have begun avoiding it in the Java code that
   I write. In this blog post I will explain the reasons why. But first, a quick history lesson.

JavaBeans
   Getters and setters originated in the JavaBeans specification which came out originally in late
   1996, and was updated to version 1.01 in August 1997. The original idea was to enable the creation of
   objects that could be used like building blocks to compose applications out of. The idea went, a
   "user" might use some kind of builder tool to connect together and customize a set
   of JavaBeans
   components to act together as an application. For example, a button in an AWT application would be a
   bean (AWT was the precursor to the Java UI library Swing). Alternatively, some JavaBeans would be
   more like regular applications, which may then be composed together into compound documents, so a
   spreadsheet bean might be embedded inside a web page.

   An object is a JavaBean when it adheres to the following conventions:
    1. It must have a zero-argument constructor which cannot fail.
    2. It has properties which are accessed and mutated via 'getter' and 'setter'
    methods.
    3. For any property of a bean called Foo then the accessor method must be called getFoo. In the case
       of boolean properties, the getter may alternatively be called isFoo.
    4. The setter method for Foo must be called setFoo.
    5. A bean is not obliged to present both a getter and a setter for every property: a property with
       getter and no setter is read-only; a property with setter and no getter is write-only.

   The specification describes many different use cases, but it is clear from the above description that
   JavaBeans were conceived of as objects with behaviour, not mere bags of data. The idea has faded into
   obscurity, but while JavaBeans have been largely forgotten, the idiom of getter and setter methods in
   Java has persisted.

The Metaphor is Wrong
   The concept of "get" and "set" seems natural enough, but is it correct? The
   JavaBeans
   convention uses "get" to mean query, which is an operation without side effects, but in
   the real
   world getting is an action that does alter state: if I get a book off the shelf, the book is no
   longer on the shelf. You may object that this is mere pedantry, but I think this misconception
   encourages us to think wrongly about the way we write our objects to interact with each other. For
   example, if we had a Thermometer class then most Java devs would write code to read the temperature
   like this:
Temperature t = thermometer.getTemperature();

   Really though, is it the job of a thermometer to "get" the temperature? No! The job of a
   thermometer is to measure the temperature. Why do I labour this point? It is because "get"
   is an
   imperative statement: it is an instruction to the thermometer to do something. But we do not want to
   instruct the thermometer to do anything here; it is already doing its job (measuring the temperature)
   and we just want to know what its current reading is. The act of reading is done by us. Therefore the
   code is more natural when written this way:
Temperature t = thermometer.reading();

   I think this better places the responsibilities where they really belong. But do always please give
   thought to whether the accessor is needed at all, because...

Objects Are Not Data Structures
   The habit of writing classes with getters and setters has a subtle effect on the way we code. It
   naturalises the idea that we should reach into objects to get the data we need, process it, then
   update the objects with the results, rather than get the objects to perform the processing
   themselves. In other words, it encourages us to view objects as bags of data. We pull the data out
   through the getters and update them via the setters. The code that operates on the data, meanwhile,
   resides elsewhere.

   If our coding habits incline us towards treating objects as mere data structures, ORM frameworks
   positively enforce it. Worse still, if you're using Spring framework - and if you're
   a Java dev
   there's a good chance you are - by default it creates all your beans as singletons. (Confusingly,
   Spring beans have nothing to do with JavaBeans). So now you have a system composed of singleton
   objects, operating on data structures with no behaviour. If keeping your code and data separate
   sounds like a programming style you know, you're not wrong: we call it procedural programming.

   Consider whether this is a good thing. Java is, after all, supposed to be an object-oriented
   programming language. One of the great strengths of OO is that we can write classes of objects whose
   names and interactions reflect the problem domain. It enables us to write code that reads in terms of
   the problem being solved, without obscuring the big picture behind basic programming constructs and
   primitive data types. It helps us see the wood through the trees. We ought not to give this up.

What To Do Instead
   Wherever possible, stop writing get and set! Sometimes it will be appropriate, but definitely stop
   using your IDE's facility to generate getters and setters for you. This is just a convenient way to
   quickly do the wrong thing. If you need to expose an attribute on an object, simply name it after the
   attribute, but do also examine whether it's really necessary to expose it. Ask why you want to do
   this. Can the task be delegated to the object itself? For example, say I have a class representing a
   currency amount, and I wish to sum a bunch of transactions:
Amount total = new Amount(transactions.stream()
    .map(Transaction::getAmount)
    .mapToDouble(Amount::getValue)
    .sum());

   Instead of the getValue accessor why not give the Amount class an add() method and have it do the
   summing for me?
Amount total = transactions.stream()
    .map(Transaction::getAmount)
    .reduce(Amount.ZERO, Amount::add);

   This brings benefits - perhaps you raised an eyebrow at the idea of using a double to represent a
   currency amount. You'd be right, BigDecimal would be better. The second example makes this easier to
   fix because the internal representation is better encapsulated. We only need to change it in one
   place.

   Maybe you want to get at an object's data in order to test whether it is equal to something. In
   this case, consider implementing an equals() method on the object and have it test equality for you.
   If you're using Mockito to create spies, this avoids the need to use argument captors: instead you
   can create an object of equal value to serve as an example and pass it directly to the verify
   statement for comparison.

   There will be times when you must create accessors. For example, in order to persist data in a
   database you may need to access primitive representations of your data. Do you really have to follow
   the get/set naming convention though? If your answer is "that's the way it's done
   in Java," I
   encourage you to go back and read the JavaBeans specification. Are you really writing a JavaBean to
   use it in the way the specification describes? Are you using a framework or library that expects your
   objects to follow the convention?

   There will be fewer times when you must create mutators. Functional Programming is sweeping the
   industry like a craze right now, and the principle of immutable data is a good one. It should be
   applied to OO programs as well. If it is not necessary to change state, you should consider it
   necessary not to change state, so don't add a mutator method. When you write code that results in new
   state, wherever possible return new instances to represent the new state. For instance, the
   arithmetic methods on a BigDecimal instance do not alter its own value: they return new BigDecimal
   instances representing their results. We have enough memory and processing power nowadays to make
   programming this way feasible. And Spring framework does not require setter methods for dependency
   injection, it can inject via constructor arguments too. This approach is indeed the way the
   Spring documentation recommends.

   Certain technologies do require classes to follow the JavaBeans convention. If you're still writing
   JSP pages for your view layer, EL and JSTL expect response model objects to have getter methods.
   Libraries for serializing/deserializing objects to and from XML may require it. ORM frameworks may
   require it. When you are forced to write data structures for these reasons, I recommend you keep them
   hidden behind architectural boundaries. Don't let these data structures masquerading as objects
   leak into your domain.

Conclusion
   Speaking to programmers who work in other languages, I often hear them criticise Java. They say
   things like, "it's too wordy," or "there's too much boilerplate."
   Java certainly has its
   flaws, but when I enquire deeper into these criticisms I usually find they are aimed at certain
   practices rather than anything intrinsic to the language. Practices are not set in stone, they evolve
   over time and bad practices can be fixed. I think the indiscriminate use of get and set in Java is a
   bad practice and we will write better code if we give it up.


---
