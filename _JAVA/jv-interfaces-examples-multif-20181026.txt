filename: jv_interfaces_examples-multif_20181026.txt
https://javatutorial.net/java-interface-example

Java Interface Example
August 10, 2017

   In this tutorial I will show you how to create and work with Java Interfaces. As always I will
   demonstrate a practical example of a Java interface.

What is Java Interface?
   As many other Java concepts, Interfaces are derived from real-world scenarios with the main purpose
   to use an object by strict rules. For example, if you want to turn on the washing machine to wash
   your clothes you need to press the start button. This button is the interface between you and the
   electronics inside the washing machine. Java interfaces have same behaviour: they set strict rules on
   how to interact with objects. To find more about [20]Java objects read this tutorial.

   The Java interface represents a group of methods with empty bodies. Well, it is not mandatory to have
   a whole list of methods inside an interface - they can be 0 or more... but, no matter the number of
   methods, they all should be empty.

Create an Interface
   Using the example with the washing machine, lets create an Interface called WashingMachine with one
   method startButtonPressed()
public interface WashingMachine {
        public void startButtonPressed();
}

   That's all you need to define an interface. Note the usage of the keyword interface. The
   method startButtonPressed()has no body. It just ends with ; Of course you can also use methods with
   return types and parameters like: public int changeSpeed(int speed);

How to Implement an Interface
   Now we will create a class that implements our interface. To continue with the example we will create
   a washing machine of specific make that has the start button.
public class SamsungWashingMachine implements WashingMachine {

        @Override
        public void startButtonPressed() {
                System.out.println("The Samsung washing machine is now running.");
        }

}

   We use the implements keyword in the class declaration. We need to implement the startButtonPressed
   method (give it some functionality) or otherwise our class will not compile.

   Please note, you can implement more than one interface in one class you just need to separate the
   interface names with commas in the class declaration like this:
public class SamsungWashingMachine implements WashinMachine, Serializable, Comparable<WashinMachine> { ... }

Test your Interface

   Now lets create a small program to test our interface and the implementation
public class Test {
        public static void main(String[] args) {
                WashinMachine samsungWashinMachine = new SamsungWashingMachine();
                samsungWashinMachine.startButtonPressed();
        }
}

   and the output of the program will be :
The Samsung washing machine is now running.

Use Interfaces to Declare Specific Object Characteristics

   There is another common usage of interfaces in Java - to tell a object has specific use or
   characteristics.

   Lets give one more real-world example. You are a survival in the woods. You find different object and
   put them in your backpack for later use. When you rest you go through the found objects and eat the
   once that are eatable.

   First, lets define an interface called FoundObject with no methods at all. Those are all the objects
   we found in the woods:
public interface FoundObject {

}

   now we define a second interface called Eatable. We will use it just to denote if the object is
   eatable or not
public interface Eatable {
        public void eat();
}

   With the following three classes we will define the objects we find in the woods - apples,
   raspberries and stones
public class Apple implements FoundObject, Eatable {

        private String name;

        public Apple(String name) {
                this.name = name;
        }

        @Override
        public void eat() {
                System.out.println("Yummy! you eat some " + this.name);
        }

}
public class Raspberry implements FoundObject, Eatable {

        private String name;

        public Raspberry(String name) {
                this.name = name;
        }

        @Override
        public void eat() {
                System.out.println("Yummy! you eat some " + this.name);
        }

}
public class Stone implements FoundObject {

        private String name;

        public Stone(String name) {
                this.name = name;
        }

}


   Now lets write the survival program. We will collect found objects in our backpack (array) and try to
   eat them
public class WoodsSurvival {

        public static void main(String[] args) {
                // create an array of type FoundObject
                FoundObject backpack [] = new FoundObject[3];

                // create the objects we found in the woods
                FoundObject apple = new Apple("apple");
                FoundObject stone = new Stone("stone");
                FoundObject raspberry = new Raspberry("raspberry");

                // add the found objects to the backpack
                backpack[0] = apple;
                backpack[1] = stone;
                backpack[2] = raspberry;

                // iterate over the found objects
                for (int i=0; i<backpack.length; i++) {
                        FoundObject currentObject = backpack[i];
                        // check if object is eatable
                        if (currentObject instanceof Eatable) {
                                // cast the object to eatable and execute eat method
                                ((Eatable) currentObject).eat();
                        }
                }

        }

}

   The output of the program is:
Yummy! you eat some apple
Yummy! you eat some raspberry

   The code explained
   First we create the interface FoundObject with the sole purpose to denote the objects of specific
   type, so we can put them in the same array. We create the Eatable interface to mark which objects can
   be eaten.

   When we create the three objects (apple, raspberry and stone) we put implements FoundObject in the
   class declaration for all of them, and the one we can eat also implement the Eatable interface.

   In WoodsSurvival class we first create an array of type FoundObject. The three object we create later
   are also of type FoundObject so we can put them in the same array.

   When we iterate the array we check if the current object is of type Eatable. We do this with the help
   of instanceof keyford. instanceof returns true if two objects aro of the same type. In our case
   apples and raspberries will return true when checked with instanceof Eatable, because both implement
   the Eatable interface. To be able to execute the eat() method we need to explicitly typecast the
   object to Eatable first. We achieve this with following line of code:
((Eatable) currentObject).eat();

   We can not execute the eat method of a stone object, because it is not of type Eatable.

Disclaimer
   The code example above can be written in more fashionable way using abstract classes, Collections and
   inheritance. Some of those are more advanced topics and are explained in next tutorials. This is a
   beginner tutorial that intents to explain java interfaces only.


---
https://www.javahelps.com/2015/02/introduction-to-interface-with-java-8.html

Introduction to Interface (with Java 8 Features)

   Interfaces are used in Java to provide a template to developers and to avoid dead diamond problem in
   multiple inheritance. In an interface all the fields (variables) are by default public, static and
   final. For an example in the following code both the MIN_SIZE and MAX_SIZE are public, static and
   final constants.
interface Size {
    int MIN_SIZE = 1;
    public static final int MAX_SIZE = 10;
}

   For the complete project click on this [29]link.
   Up to Java 1.7 version, all the methods declared in interfaces are public and abstract by default.
   Since Java 1.8, an interface can have default methods and static methods as well. Therefore, the
   updated rule is:

     An interface can have default methods and static methods. Any other methods are implicitly public
     and abstract. All the fields declared in an interface are implicitly public, static and final
     constants.

interface Super {
    /**
     * An abstract method. By default it is public and abstract.
     */
    void print();

    /**
     * Default method, introduced in Java 8.
     */
    public default void doStuff() {
        System.out.println("Hello world");
    }

    /**
     * Static method in interface, introduced in Java 8.
     */
    public static void sayHello() {
        System.out.println("Hello");
    }
}

   For the complete project click on this [30]link.
   In the above code a sub class object is needed to access the abstract method print and the default
   method doStuff. The static method sayHello can be called directly using the interface name without
   any sub classes. Sub classes must override the abstract methods and optionally they can override the
   default methods as shown below. In the following code, sub class Base overrides the abstract method
   only.
class Base implements Super {
    /**
     * Override the abstract method.
     */
    @Override
    public void print() {
        System.out.println("Base");
    }
}

   Interfaces are used to provide a template which must be implemented by other entities later. A best
   real world example for interface is USB port. All the computers have USB ports, and by having a USB
   port they assure that any device which has a USB pin can connect to this port. Computer knows how to
   transfer data through the USB port but it never cares about the actual device. The implementation
   depends on the device which is connected to the port. In Java it can be simulated using interface as
   given below.
public class Computer {
    public static void main(String[] args) {
        Computer comp = new Computer();
    }

    public void connect(USB usb) {
        usb.send(new byte[] {1});   // Send some data
        byte[] data = usb.receive();    // Receive some data
        // do something here
    }
}

interface USB {
    void send(byte[] data);

    byte[] receive();
}

   Any class which wants to connect to this computer can simply implement the USB interface and provide
   the necessary implementation as shown below.
class Mouse implements USB {
    @Override
    public void send(byte[] data) {
        System.out.println("Connected");
    }

    @Override
    public byte[] receive() {
        return new byte[] {120, 87};
    }
}
public class Computer {
    public static void main(String[] args) {
        Computer comp = new Computer();
        Mouse mouse = new Mouse();
        comp.connect(mouse);
    }

    public void connect(USB usb) {
        usb.send(new byte[] {1});   // Send some data
        byte[] data = usb.receive();    // Receive some data
        // do something here
    }
}

interface USB {
    void send(byte[] data);

    byte[] receive();
}

   To have a better understanding, consider another problem. A DownloadManager library wants to pass the
   downloaded percentage to some other entities. Based on the requirements, the developers who use this
   library may display the downloaded percentage in a GUI progress bar or in a command window. In this
   case the DownloadManager library developer cannot determine the implementation of other developers,
   who use this library. Now the problem is: how to establish an agreement to pass the downloaded
   percentage to anyone interested? Following code is a model (Do not try to compile this code) which
   simulates this problem and solves it using an interface OnDownloadListener with a single method
   onDownload.
public class DownloadManager {
    private OnDownloadListener listener;

    public void setListener(OnDownloadListener listener) {
        this.listener = listener;
    }

    public void start() {
        boolean completed = false;
        double percent = 0.0;
        while (!completed) {
            // download the file
            // increase the completed percentage
            if (listener != null) {
                listener.onDownload(percent);
            }
        }
    }
}

interface OnDownloadListener {
    void onDownload(double percent);
}

   By providing an interface, the developer knows that all of its sub-classes have an implementation of
   onDownload method. Whenever the onDownload method is called with the current percentage value, other
   developers' own implementation will be executed. In this case, the DownloadManager library developer
   can develop his/her project without caring about the actual implementation which is going to be bound
   at the runtime.
   
   There is one more advantage of having interfaces in Java. Object Oriented Programming supports
   multiple inheritance; in other words a sub class can have more than one super class. In Java
   multiple class to class inheritance is prohibited to avoid dead diamond problem and Interface is used
   to implement the multiple inheritance. Look at the code which simulates a sample problem given in
   Wikipedia.
interface Animal {
    void eat();
}

interface Mammal extends Animal {
    void breastFeed();
}

interface WingedAnimal extends Animal {
    void flap();
}

/**
 * Multiple inheritance:
 * Bat implements both Mammal and WingedAnimal.
 */
class Bat implements Mammal, WingedAnimal {
    @Override
    public void eat() {
        System.out.println("Eating");
    }

    @Override
    public void breastFeed() {
        System.out.println("Feeding");
    }

    @Override
    public void flap() {
        System.out.println("Flying");
    }
}

   In this example Bat implements both Mammal and WingedAnimal interfaces. Therefore Bat can be sent to
   a method with a parameter Mammal and to another method with a parameter WingedAnimal parameter. In
   other words Bat IS-A Mammal as well as Bat IS-A WingedAnimal.
public class MultipleInheritance {
    public static void main(String[] args) {
        Bat bat = new Bat();
        doFly(bat);
        doFeed(bat);
    }

    public static void doFly(WingedAnimal ani) {
        ani.flap();
    }

    public static void doFeed(Mammal ani) {
        ani.breastFeed();
    }
}

Java 8 Features
   From Java 8, Interface supports default and static methods. Default methods are already covered in
   this article, so the static methods are highly focused in this tutorial. In Java utility classes
   must define all their methods as static methods and the constructor must be private to avoid
   instantiation of that class.  For example java.util.Arrays is an utility class where all the
   methods are static and the constructor is private. Utility class developers take some extra effort to
   avoid the instantiation of the utility class. From Java 8 there are no need for a utility class with
   private constructor; it can be simply replaced by an interface with static methods. Look at the
   example where a utility interface is provided to print any String arrays in a formatted manner.
public class PrintArray {
    public static void main(String[] args) {
        String[] arr = {"Java", "C++", "C", "Python", "PHP"};
        Printer.print(arr);
    }
}

interface Printer {
    public static void print(String[] array) {
        StringJoiner joiner = new StringJoiner(", ", "[", "]");
        for (String str : array) {
            joiner.add(str);
        }
        System.out.println(joiner.toString());
    }
}

   For the complete project click on this [35]link.

Do and Don't
   Whenever you need to provide a template, use the interface. Coding for interface is one of the best
   practice, so try to have an interface as the top most element in a class hierarchy. However you must
   be aware of what you are doing. Since Java 8 allows to have default and static methods in an
   interface, there is a high risk of polluting an interface by using default and static methods without
   any valid reasons. Always remember these two rules when you are going to use default or static
   methods in an interface.
   Rule #1:
   Do not use static methods in an interface until that method is a utility method.
   Rule #2:
   Do not use default methods until you really need to provide a default implementation for a method.
   Default methods are commonly useful in extending the functionality of an existing interface. Do not
   use default methods instead of ordinary instance methods because interfaces with default methods are
   open for dead diamond problem. If you really need to use both abstract and non-abstract instance
   methods use the abstract class not the interface.


---
https://medium.com/modernnerd-code/java-for-humans-abstract-classes-interfaces-aa4b2ee37418

Abstract Classes & Interface

   In the Class Inheritance chapter, we learned about forming a contract between classes, superclasses,
   and users. By creating subclasses that share a superclass, we can share fields and methods between
   them to decrease the amount of code we write, create a predictable interface for users, and employ
   polymorphism. In this chapter, we will learn how to make our contracts better through abstract
   classes and interfaces.

Why Abstract Classes & Interface are Important & Useful
   A regular class defines the fields, implements fully functioning methods and can be instantiated;
   such a class is referred to as a concrete class. That is the vast majority of classes you will write
   and use in your programming career. Abstract classes and interfaces cannot be instantiated, but they,
   too, define fields and methods - although they may not implement methods. They are best for forming a
   contract between a class, its subclasses, and users of its subclasses.

Abstract Class
   An abstract class is much like a regular class in that it can have fields and methods. What makes it
   special is its methods may or may not have bodies. That means an abstract class can have method
   signatures that are declared as abstract as well as full methods as usual.

   An abstract method is a method that has no body and requires subclasses of the abstract class its in
   to implement its body. This is useful when you have a method that you want all subclasses to have but
   you want to leave it up to the different subclasses to implement the method how they want. Further, a
   subclass of an abstract class must implement all of its abstract methods.

   Take the Human class's attack() instance method from the [9]Class Inheritance chapter for example. We
   want every subclass of the Human class to have a method of attacking another Human opponent, but we
   expect each subclass to have a different way of attacking. We should make our attack() method
   abstract instead of implementing it in the Human class as well as every subclass. That way, we won't
   be able to forget to implement it in every subclass and we will keep our code clean by not writing
   expectantly useless code in our superclass. There are a couple methods of the Human class that we
   should make abstract, but in order to do that, we must make the Human class an abstract class. To do
   that, we simply add the abstract keyword to the class's signature before the class keyword.
public abstract class Human {
   //add fields, methods, and abstract methods
}

   For methods that we expect to behave exactly the same across all our subclasses, we can write them
   out in full as usual. Methods such as getters and setters fit this bill. Further, we can still have
   our shared fields in our abstract class. Let's take a look at our new Human class as an upgrade from
   the Class Inheritance chapter:
public abstract class Human {
    protected String name;
    ...
    public Human(String name) {...}
    public abstract void attack(Human human);
    public abstract void defend();
    public abstract void jump();
    public abstract double heal();
    public String getName() {...}
    public double getHealth(){...}
    public long getExperience(){...}
    public void setAttackPower(int attackPower) {...}
    public long gainExperience(long experience){...}
    public double heal(double additionalHealth) {...}
    public double decreaseHealth(int opponentAttackPower) {...}
}

   In that code snippet, you can see that we have our Human class and its attack(), defend(), jump(),
   and heal() instance methods are abstract. This is because they are all functions that should be
   unique to each class that implements them; Taoist instances - magical characters - won't heal the
   same way as Warrior instances, so they should implement the heal() method differently. You've seen
   the rest of the class before, so those parts have been omitted.

     At this point, it is important to note that static methods cannot be abstract because in simplest
     terms, abstract means that a method implements no functionality and static means there is
     definitely functionality available in the method or field even without an instance of the class.
     Thus, having a static abstract method would be would be a logical contradiction which Java does
     not allow.

Interfaces
   An interface is a bit different than anything we've seen thus far. A Java interface is more like an
   abstract class than a regular class. An interface can only contain method signatures and static final
   fields. An interface is merely a contract between the interface and classes that implement it. Like
   with abstract classes, classes that implement an interface must implement its methods' bodies to
   provide functionality.

   Interfaces are best for creating a contract that will ensure that all classes that implement it
   behave similarly by abiding by the contract. This will allow users to safely expect parts of your
   program to behave similarly much like you would expect all characters in a fighting game to behave
   similarly. In our Conquer game from the Class Inheritance chapter, we expect all characters to be
   able to attack other characters, defend themselves from attacks, jump, and heal themselves among
   other functions. These functions are functions all characters can perform, not only Human instances:
public interface Character {
    Random randomGenerator = new Random();
    String getName();
    double getHealth();
    long getExperience();
    int getAttackPower();
    void setAttackPower(int attackPower);
    void defend();
    void jump();
    int heal();
    void attack(Character opponent);
    double decreaseHealth(int opponentAttackPower);
    long gainExperience(long experience);
}

   In the Character interface, numCharactersInGame field is implicitly static and all of the methods are
   implicitly public, so there's no need to include the static and public modifiers respectively.

     A top-level interface cannot be private. Also, all methods of an interface are intuitively public,
     so don't include any methods you think should be private or protected.

   Say we want to allow our Human characters to have Pet characters as their companions, we would expect
   that Pet instances can do things like attack, defend, jump, and heal but not other things that are
   unique to Human instances. Further, we may have many different types of pets; a user may want to have
   a dog, cat, or a bird as a pet. For that, we would have a Dog class, Cat class, and a Bird class.
   Each of those classes would, in turn, extend the Pet class which will define shared instance fields,
   implement shared methods, and declare the abstract methods that all subclasses must implement.

     From bottom to top, the hierarchy of concrete classes, abstract classes, and interface goes like
     so:

     concrete class → abstract class → interface.

     If a class extends a superclass - concrete or abstract - that implements an interface, you can
     declare the necessary methods from the interface in the superclass. Doing this will fulfill the
     subclass's duty to abide by the contract between it and the interface because your subclass will
     inherit the necessary methods of the contract from its superclass. Alternatively, the class can
     implement the interface methods on its own.

   Let's take a look at our abstract Pet class and our concrete Archer and Dog subclasses; we will make
   use of the Character interface and abstract Human class from earlier:
public abstract class Human implements Character{
    protected Pet pet;
    ...
    public Human(String name) {
        ...
        numCharacters++;
    }
    public void setPet(Pet pet) { this.pet = pet; }
    public Pet getPet() { return pet; }
    public abstract void attack(Character opponent);
    ...
}
public abstract class Pet implements Character{
    protected Human owner;
    ...
    public Pet(String name, Human owner) {
        this.name = name;
        this.owner = owner;
        gainExperience(1);
        numCharacters++;
    }
    public Human getOwner() { return owner; }
    public abstract void attack(Character opponent);
    ...
}
public class Archer extends Human {
    private int numArrows = 0;
    public Archer(String name) {
        super(name);
        findArrows();
    }
    private void findArrows() {
        System.out.println("Looking for arrows");
    }
    @Override
    public void attack(Character opponent) {...}
    @Override
    public void defend() {...}
    @Override
    public void jump() {...}
    @Override
    public int heal() { return 0; }
}
public class Dog extends Pet {
    public Dog(String name, Human owner) {
        super(name, owner);
    }
    public void bark() {
        System.out.println("Wolf Wolf!");
    }

    @Override
    public void attack(Character opponent) {...}
    @Override
    public void defend() {...}
    @Override
    public void jump() {...}
    @Override
    public int heal() { return 0; }
}

   Now we have a wonderful contract set up between subclasses, abstract superclasses, and an interface
   to rule them all. The Character interface defines the behavioral interface for all characters in the
   game. The Human abstract class implements the Character interface and defines behavior and fields for
   all human characters in the game. The Human class also implements some of the methods of the
   Character interface that are common for all Human characters. The Archer class is a concrete class
   that extends the Human class and is used to create archer characters in the game. Furthermore, the
   Archer class also implements the Character interface because its superclass, Human, does. Therefore,
   Archer instances are also Human instances and since Human instances are also instances of the
   Character interface, Archer instances are Character instances. Thus, Archer instances are archer and
   human characters. That gives us the following hierarchy, from bottom to top:

   Archer instance → Archer concrete class → Human abstract class → Character interface.

   The Dog concrete class and the Pet abstract class work similarly with our Character interface:

   Dog instance → Dog concrete class → Pet abstract class → Character interface.

   ----------------------------------------------
   Class    |    Human      Pet     Character
   ==============================================
   Archer   |    X          -       X
   ----------------------------------------------
   Dog      |    -          X       X
   ----------------------------------------------
   
   An Archer is a Human is a Character. A Dog is a Pet is a Character.

   An Archer is a Human is a Character. A Dog is a Pet is a Character. Therefore, both an Archer and a
   Dog are equally Character instances like all other Human and Pet instances would be if you create
   more classes that extend those abstract classes or implement the Character interface.

   You should be proud of yourself at this point. You now know everything you need to know about
   classes, interfaces, and contracts to get started building fun projects that employ polymorphism.
   Here's a starter program:
public class Main {
    public static void main(String[] args){
        Archer niceArcher = new Archer("Tom");
        Human modernArcher = new Archer("Stacy");
        Dog modernDog = new Dog("Hunter", modernArcher);
        Pet petDog = new Dog("Buddy", niceArcher);
        System.out.println("\nStart Game\n");
        modernArcher.attack(niceArcher);
        niceArcher.getPet().attack(modernArcher);
        modernArcher.attack(niceArcher.getPet());
        modernDog.attack(petDog.getOwner());
        petDog.attack(modernArcher.getPet());
    }
    /*Prints:
        Tom: Found 6 arrows ...
        Stacy: Found 4 arrows ...
        Stacy: I have a new pet. Hi Hunter!
        Hunter: Wolf Wolf!
        Tom: I have a new pet. Hi Buddy!
        Buddy: Wolf Wolf!

        Start Game

        Stacy: Attacking Tom with my arrows!
        Tom: I've been hit. My health now = 90.0
        Buddy: Biting Stacy
        Stacy: I've been hit. My health now = 99.0
        Stacy: Attacking Buddy with my arrows!
        Buddy: Wolf Wolf!
        Buddy: Health now = 90.0
        Hunter: Biting Tom
        Tom: I've been hit. My health now = 89.0
        Buddy: Biting Hunter
        Hunter: Wolf Wolf!
        Hunter: Health now = 99.0
     */
}

   Polymorphism is the ability for objects to take on many forms. Notice that the niceArcher is of type
   Human but is instantiated as a new Archer. That means that the niceArcher passes more than one is-a
   test because its both a Human and an Archer. Furthermore, notice that each object can attack all
   other objects. This is only possible because each object is also an instance of the Character
   interface, and the attack() instance method of Character takes another a Character instance as the
   single argument. With all of that, we can say that these objects are polymorphic.

   Remember that if you don't quite understand the importance of polymorphism yet, we will cover it in
   more depth soon. For now, take a look at the supporting code and make sure you understand it. Try to
   change it around and make your own contracts.


---
http://www.wideskills.com/java-tutorial/java-abstract-class-and-interface

Java Abstract Class and Interface:    Page 1 of 2

ABSTRACT CLASS IN JAVA
   Java Abstract classes are used to declare common characteristics of subclasses. An abstract class
   cannot be instantiated. It can only be used as a superclass for other classes that extend the
   abstract class. Abstract classes are declared with the abstract keyword. Abstract classes are used to
   provide a template or design for concrete subclasses down the inheritance tree.

   Like any other class, an abstract class can contain fields that describe the characteristics and
   methods that describe the actions that a class can perform. An abstract class can include methods
   that contain no implementation. These are called abstract methods. The abstract method declaration
   must then end with a semicolon rather than a block. If a class has any abstract methods, whether
   declared or inherited, the entire class must be declared abstract. Abstract methods are used to
   provide a template for the classes that inherit the abstract methods.

   Abstract classes cannot be instantiated; they must be subclassed, and actual implementations must be
   provided for the abstract methods. Any implementation specified can, of course, be overridden by
   additional subclasses. An object must have an implementation for all of its methods. You need to
   create a subclass that provides an implementation for the abstract method.

   A class abstract Vehicle might be specified as abstract to represent the general abstraction of a
   vehicle, as creating instances of the class would not be meaningful.
abstract class Vehicle {

        int numofGears;
        String color;
        abstract boolean hasDiskBrake();
        abstract int getNoofGears();
}

   Example of a shape class as an abstract class
abstract class Shape {

        public String color;
        public Shape() {
        }
        public void setColor(String c) {
                color = c;
        }
        public String getColor() {
                return color;
        }
        abstract public double area();
}

   We can also implement the generic shapes class as an abstract class so that we can draw lines,
   circles, triangles etc. All shapes have some common fields and methods, but each can, of course, add
   more fields and methods. The abstract class guarantees that each shape will have the same set of
   basic properties. We declare this class abstract because there is no such thing as a generic shape.
   There can only be concrete shapes such as squares, circles, triangles etc.
public class Point extends Shape {

        static int x, y;
        public Point() {
                x = 0;
                y = 0;
        }
        public double area() {
                return 0;
        }
        public double perimeter() {
                return 0;
        }
        public static void print() {
                System.out.println("point: " + x + "," + y);
        }
        public static void main(String args[]) {
                Point p = new Point();
                p.print();
        }
}

   Output

   point: 0, 0

   Notice that, in order to create a Point object, its class cannot be abstract. This means that all of
   the abstract methods of the Shape class must be implemented by the Point class.

   The subclass must define an implementation for every abstract method of the abstract superclass, or
   the subclass itself will also be abstract. Similarly other shape objects can be created using the
   generic Shape Abstract class.

   A big Disadvantage of using abstract classes is not able to use multiple inheritance. In the sense,
   when a class extends an abstract class, it can't extend any other class.

JAVA INTERFACE
   In Java, this multiple inheritance problem is solved with a powerful construct called interfaces.
   Interface can be used to define a generic template and then one or more abstract classes to define
   partial implementations of the interface. Interfaces just specify the method declaration (implicitly
   public and abstract) and can only contain fields (which are implicitly public static final).
   Interface definition begins with a keyword interface. An interface like that of an abstract class
   cannot be instantiated.

   Multiple Inheritance is allowed when extending interfaces i.e. one interface can extend none, one or
   more interfaces. Java does not support multiple inheritance, but it allows you to extend one class
   and implement many interfaces.

   If a class that implements an interface does not define all the methods of the interface, then it
   must be declared abstract and the method definitions must be provided by the subclass that extends
   the abstract class.

   Example 1: Below is an example of a Shape interface
interface Shape {

        public double area();
        public double volume();
}

   Below is a Point class that implements the Shape interface.
public class Point implements Shape {

        static int x, y;
        public Point() {
                x = 0;
                y = 0;
        }
        public double area() {
                return 0;
        }
        public double volume() {
                return 0;
        }
        public static void print() {
                System.out.println("point: " + x + "," + y);
        }
        public static void main(String args[]) {
                Point p = new Point();
                p.print();
        }
}

   Similarly, other shape objects can be created by interface programming by implementing generic Shape
   Interface.

   Example 2: Below is a java interfaces program showing the power of interface programming in java

   Listing below shows 2 interfaces and 4 classes one being an abstract class.
   Note: The method toString in class A1 is an overridden version of the method defined in the class
   namedObject. The classes B1 and C1 satisfy the interface contract. But since the class D1 does not
   define all the methods of the implemented interface I2, the class D1 is declared abstract.
   Also,
   i1.methodI2() produces a compilation error as the method is not declared in I1 or any of its super
   interfaces if present. Hence a downcast of interface reference I1 solves the problem as shown in the
   program. The same problem applies to i1.methodA1(), which is again resolved by a downcast.

   When we invoke the toString() method which is a method of an Object, there does not seem to be any
   problem as every interface or class extends Object and any class can override the default toString()
   to suit your application needs. ((C1)o1).methodI1() compiles successfully, but produces a
   ClassCastException at runtime. This is because B1 does not have any relationship with C1 except they
   are "siblings". You can't cast siblings into one another.

   When a given interface method is invoked on a given reference, the behavior that results will be
   appropriate to the class from which that particular object was instantiated. This is runtime
   polymorphism based on interfaces and overridden methods.
interface I1 {

        void methodI1(); // public static by default
}

interface I2 extends I1 {

        void methodI2(); // public static by default
}

class A1 {

        public String methodA1() {
                String strA1 = "I am in methodC1 of class A1";
                return strA1;
        }
        public String toString() {
                return "toString() method of class A1";
        }
}

class B1 extends A1 implements I2 {

        public void methodI1() {
                System.out.println("I am in methodI1 of class B1");
        }
        public void methodI2() {
                System.out.println("I am in methodI2 of class B1");
        }
}

class C1 implements I2 {

        public void methodI1() {
                System.out.println("I am in methodI1 of class C1");
        }
        public void methodI2() {
                System.out.println("I am in methodI2 of class C1");
        }
}

// Note that the class is declared as abstract as it does not
// satisfy the interface contract
abstract class D1 implements I2 {

        public void methodI1() {
        }
        // This class does not implement methodI2() hence declared abstract.
}

public class InterFaceEx {

        public static void main(String[] args) {
                I1 i1 = new B1();
                i1.methodI1(); // OK as methodI1 is present in B1
                // i1.methodI2(); Compilation error as methodI2 not present in I1
                // Casting to convert the type of the reference from type I1 to type I2
                ((I2) i1).methodI2();
                I2 i2 = new B1();
                i2.methodI1(); // OK
                i2.methodI2(); // OK
                // Does not Compile as methodA1() not present in interface reference I1
                // String var = i1.methodA1();
                // Hence I1 requires a cast to invoke methodA1
                String var2 = ((A1) i1).methodA1();
                System.out.println("var2 : " + var2);
                String var3 = ((B1) i1).methodA1();
                System.out.println("var3 : " + var3);
                String var4 = i1.toString();
                System.out.println("var4 : " + var4);
                String var5 = i2.toString();
                System.out.println("var5 : " + var5);
                I1 i3 = new C1();
                String var6 = i3.toString();
                System.out.println("var6 : " + var6); // It prints the Object toString() method
                Object o1 = new B1();
                // o1.methodI1(); does not compile as Object class does not define
                // methodI1()
                // To solve the probelm we need to downcast o1 reference. We can do it
                // in the following 4 ways
                ((I1) o1).methodI1(); // 1
                ((I2) o1).methodI1(); // 2
                ((B1) o1).methodI1(); // 3
                /*
                 *
                 * B1 does not have any relationship with C1 except they are "siblings".
                 *
                 * Well, you can't cast siblings into one another.
                 *
                 */
                // ((C1)o1).methodI1(); Produces a ClassCastException
        }
}

   Output

   I am in methodI1 of class B1
   I am in methodI2 of class B1
   I am in methodI1 of class B1
   I am in methodI2 of class B1
   var2 : I am in methodC1 of class A1
   var3 : I am in methodC1 of class A1
   var4 : toString() method of class A1
   var5 : toString() method of class A1
   var6 : C1@190d11
   I am in methodI1 of class B1
   I am in methodI1 of class B1
   I am in methodI1 of class B1


---
http://www.wideskills.com/java-tutorial/java-abstract-class-and-interface/p/0/1

Java Abstract Class and Interface:    Page 2 of 2

POLYMORPHISM
   Polymorphism means one name, many forms. There are 3 distinct forms of Java Polymorphism;
     * Method overloading (Compile time polymorphism)
     * Method overriding through inheritance (Run time polymorphism)
     * Method overriding through the Java interface (Run time polymorphism)Polymorphism allows a
       reference to denote objects of different types at different times during execution. A super type
       reference exhibits polymorphic behavior, since it can denote objects of its subtypes.

interface Shape {

        public double area();
        public double volume();
}

class Cube implements Shape {

        int x = 10;
        public double area( ) {

            return (6 * x * x);
        }

        public double volume() {
                return (x * x * x);
        }

}

class Circle implements Shape {

        int radius = 10;
        public double area() {
                return (Math.PI * radius * radius);
        }
        public double volume() {
                return 0;
        }
}

public class PolymorphismTest {

        public static void main(String args[]) {
                Shape[] s = { new Cube(), new Circle() };
                for (int i = 0; i &lt; s.length; i++) {
                        System.out.println("The area and volume of " + s[i].getClass()
                                        + " is " + s[i].area() + " , " + s[i].volume());
                }
        }
}

   Output

   The area and volume of class Cube is 600.0 , 1000.0
   The area and volume of class Circle is 314.1592653589793 , 0.0

   The methods area() and volume() are overridden in the implementing classes. The invocation of the
   both methods area and volume is determined based on run time polymorphism of the current object as
   shown in the output.

INTERFACE VS ABSTRACT CLASS
   Interface vs Abstract Class

   Taken from http://interview-questions-java.com/abstract-class-interface.htm

   1. Abstract class is a class which contain one or more abstract methods, which has to be implemented
   by sub classes. An abstract class can contain no abstract methods also i.e. abstract class may
   contain concrete methods. A Java Interface can contain only method declarations and public static
   final constants and doesn't contain their implementation. The classes which implement the Interface
   must provide the method definition for all the methods present.

   2. Abstract class definition begins with the keyword "abstract" keyword followed by Class definition.
   An Interface definition begins with the keyword "interface".

   3. Abstract classes are useful in a situation when some general methods should be implemented and
   specialization behavior should be implemented by subclasses. Interfaces are useful in a situation
   when all its properties need to be implemented by subclasses

   4. All variables in an Interface are by default - public static final while an abstract class can
   have instance variables.

   5. An interface is also used in situations when a class needs to extend an other class apart from the
   abstract class. In such situations its not possible to have multiple inheritance of classes. An
   interface on the other hand can be used when it is required to implement one or more interfaces.
   Abstract class does not support Multiple Inheritance whereas an Interface supports multiple
   Inheritance.

   6. An Interface can only have public members whereas an abstract class can contain private as well as
   protected members.

   7. A class implementing an interface must implement all of the methods defined in the interface,
   while a class extending an abstract class need not implement any of the methods defined in the
   abstract class.

   8. The problem with an interface is, if you want to add a new feature (method) in its contract, then
   you MUST implement those method in all of the classes which implement that interface. However, in the
   case of an abstract class, the method can be simply implemented in the abstract class and the same
   can be called by its subclass

   9. Interfaces are slow as it requires extra indirection to to find corresponding method in in the
   actual class. Abstract classes are fast

   10.Interfaces are often used to describe the peripheral abilities of a class, and not its central
   identity, E.g. an Automobile class might
   implement the Recyclable interface, which could apply to many otherwise totally unrelated objects.

   Note: There is no difference between a fully abstract class (all methods declared as abstract and all
   fields are public static final) and an interface.

   Note: If the various objects are all of-a-kind, and share a common state and behavior, then tend
   towards a common base class. If all they
   share is a set of method signatures, then tend towards an interface.

   Similarities:
   Neither Abstract classes nor Interface can be instantiated.


---
https://www.learnjavaonline.org/en/Interfaces

Interfaces

Tutorial
   Interfaces are class templates. Although not strictly required, they are part of the organizational
   structure of object-oriented programming. Interfaces define methods for classes by specifying the
   method name, the return type (or void) and the method arguments (by type and name). These method
   definitions are called signatures. Because this is a template, the method signatures contain no code.
   The code is entered into the implementation of an interface. Interfaces are used in the discipline of
   polymorphism.

   Note these two important points about interfaces:
     * If a class implements an interface, all of the interface's methods must appear in the class.
     * The implements keyword is used when creating a class that is modeled after an interface.

An analogy
   Think of cutting a duck decoy from a block of wood. First, a template is used to trace the pattern
   onto the wood. Then, when the wood is cut, it resembles the template. At this point, however, neither
   the template nor the wood have any of the fine details that one would expect from a finished decoy.
   The template was used to define basic characteristics, not precise details. After multiple
   duck-shaped pieces have been cut, each one can be carved and decorated uniquely. Yet, they all have
   the same basic size and shape.

   An interface is generally used as a template for multiple classes. These classes all share the
   methods defined in the interface. However, the implementation of the methods may vary from one class
   to another.

An example of an interface
   An interface named Animal might have method defintions for feed, groom and pet. The feeding, grooming
   and petting of animals can be as different as the animals themselves.
interface Animal {
    bool feed(bool timeToEat);
    void groom();
    void pet();
}

   A dog class, for instance, may be implemented in a somewhat predictable way.
class Dog implements Animal {
    bool feed(bool timeToEat) {
      // pour food into bowl
      return true;
    }
    void groom() {
      // brush well
    }
    void pet() {
      // pet cautiously
    }
}

   Other animal classes, may have specific needs.
class Giraffe implements Animal {
    bool feed(bool timeToEat) {
      // point to the trees
      return true;
    }
    void groom() {
      // get a ladder
      // brush well
    }
    void pet() {
      // get a ladder
      // pet cautiously
    }
}

class Tiger implements Animal {
    bool feed(bool timeToEat) {
      // toss raw meat into cage
      return true
    }
    void groom() {
      // tranquilize
      // brush well
    }
    void pet() {
      // DO NOT PET
    }
}

Exercise
   Create a gorilla class which implements the Animal interface.

Tutorial Code
interface Animal {
    bool feed(bool timeToEat);
    void groom();
    void pet();
}

Expected Output
   No visible output. However, the result should be a class, similar to the ones implemented above, for
   a gorilla that includes all of the interface methods.

Solution
class Gorilla implements Animal {
    bool feed(bool timeToEat) {
      // put gorilla food into cage
      return true;
    }
    void groom() {
      // lather, rinse, repeat
    }
    void pet() {
      // pet at your own risk
    }
}



---
https://www.tutorialride.com/core-java/packages-interfaces-in-java.htm

Packages & Interfaces in Java

Introduction  to Packages
   A package is a mechanism to group the similar type of classes, interfaces and sub-packages and
   provide access control.  It organizes classes into single unit.
   In Java already many predefined packages are available, used while programming.
   For example: java.lang, java.io, java.util etc.

Advantages of Packages
     * Packages provide code reusability, because a package has group of classes.
     * It helps in resolving naming collision when multiple packages have classes with the same name.
     * Package also provides the hiding of class facility. Thus other programs cannot use the classes
       from hidden package.
     * Access limitation can be applied with the help of packages.
     * One package can be defined in another package.

Types of Packages
   There are two types of packages available in Java.
   1. Built-in packages
   Built-in packages are already defined in java API. For example: java.util, java.io, java,lang,
   java.awt, java.applet, java.net, etc.
   2. User defined packages
   The package we create according to our need is called user defined package.

Creating a Package
   We can create our own package by creating our own classes and interfaces together. The package
   statement should be declared at the beginning of the program.
   Syntax:

   package <packagename>;
   class ClassName
   {
   ........
   ........
   }

Example: Creating a Package

   // Demo.java
   package p1;
   class Demo
   {
      public void m1()
      {
          System.out.println("Method m1..");
      }
   }
   How to compile?
   Syntax:  javac -d directory javafilename
   For Example: javac -d . Demo.java
   How to run?
   To run: java p1.Demo

Example: Program to create and use a user defined ackage in Java.

   // Vehicle.java
   package vehicles;
   interface Vehicle
   {
      public void run();
      public void speed();
   }
   //Bike.java
   package vehicles;
   public class Bike implements Vehicle
   {
       public void run()
      {
         System.out.println("Bike is running.");
      }
      public void speed()
      {
         System.out.println("Speed of Bike: 50 Km/h");
      }
      public static void main(String args[])
      {
         Bike bike = new Bike();
         bike.run();
         bike.speed();
      }
   }
   Compile:
   javac -d . Vehicle.java
   javac -d . Bike.java
   Run:
   java vehicles.Bike
   Output:
   Bike is running
   Speed of Bike: 50 Km/h

The "import" keyword
   The import keyword provides the access to other package classes and interfaces in current packages.
   "import" keyword is used to import built-in and user defined packages in java program.
   There are different 3 ways to access a package from other packages.
   1. Using full qualified name

Example
   class Demo extends java.util.Scanner
   {
       //statements
   }
   2. import only single class

Example
   import java.util.Scanner;
   class Demo
   {
         // statements
   }
   3. import all classes

Example
   import java.util.*;
   class Demo
   {
       // statements
   }

Interface
     * Interface is similar to a class, but it contains only abstract methods.
     * By default the variables declared in an interface are public, static and final.
     * Interface is a mechanism to achieve full abstraction.
     * An interface does not contain any constructor.

   Syntax:
   interface InterfaceName
   {
      public void method1();
      public void method2();
      <type> variableName = value;
   }

Example: Sample of an interface
   interface Employee
   {
      static final Id = 101;
      static final String name = "ABC";
      void show();
      void getSalary(double salary);
   }

Extending interfaces
   An interface has to extend another interface as it happens in class. It cannot implement another
   interface.

Example: Sample program for extending interfaces
   interface Base
   {
      public void display ();
   }
   interface Derive extends Base
   {
      public void show ();
   }

Implementing interfaces
     * A class implements an interface. After that, class can perform the specific behavior on an
       interface.
     * The implements keyword is used by class to implement an interface.

   Syntax:
   class ClassName implements interfacename
   {
      // body of class
   }
   Note: A class can implement more than one interface. Java can achieve multiple inheritances by using
   interface.

Example:  Sample program to implements interface in Java
   interface Results
   {
      final static float pi = 3.14f;
      float areaOf(float l, float b);
   }
   class Rectangle implements Results
   {
      public float areaOf(float l, float b)
      {
          return (l * b);
      }
   }
   class Square implements Results
   {
      public float areaOf(float l, float b)
      {
         return (l * l);
      }
   }
   class Circle implements Results
   {
      public float areaOf(float r, float b)
      {
         return (pi * r * r);
      }
   }
   public class InterfaceDemo
   {
      public static void main(String args[])
      {
         Rectangle rect = new Rectangle();
         Square square = new Square();
         Circle circle = new Circle();
         System.out.println("Area of Rectangle: "+rect.areaOf(20.3f, 28.7f));
         System.out.println("Are of square: "+square.areaOf(10.0f, 10.0f));
         System.out.println("Area of Circle: "+circle.areaOf(5.2f, 0));
      }
   }
   Output:
   Area of Rectangle: 582.61
   Are of square: 100.0
   Area of Circle: 84.905594

Example: Sample program to implements multiple inheritance
   interface Vehicle
   {
     void run();
   }
   interface Bike extends Vehicle
   {
     void stop();
   }
   public class Demo implements Bike
   {
     public void run()
     {
        System.out.println("Vehicle is running.");
     }
     public void stop()
     {
        System.out.println("Bike is stop.");
     }
     public static void main(String args[])
     {
        Demo obj = new Demo();
        obj.run();
        obj.stop();
     }
   }
   Output:
   Vehicle is running.
   Bike is stop.

Marker Interface
   An interface which does not contain any fields and methods is known as marker or tag interface. It is
   an empty interface.
   For example Serializable, EventListener, MouseListner, Remote, Cloneable etc.
   Example:
   package java.util;
   public interface EventListner
   {
   }
   
   Differences between Abstract class and Interface
   Abstract class Interface
   It cannot support multiple inheritances. Interface supports multiple inheritances.
   It contains both abstract and non abstract method. It contains only abstract method.
   Abstract class is the partially implemented class. Interface is fully unimplemented class.
   It can have main method and constructor. It cannot have main method and constructor.
   It can have static, non-static, final, non-final variables. It contains only static and final
   variable.


---
https://www.journaldev.com/1601/interface-in-java

Interface in Java

Interface in java is one of the core concept. Java Interface is core part of java programming language and
used a lot not only in JDK but also java design patterns. Most of the frameworks use java interface heavily.
Interface in java provide a way to achieve abstraction. Java interface is also used to define the contract
for the subclasses to implement.

For example, let's say we want to create a drawing consists of multiple shapes. Here we can create an
interface Shape and define all the methods that different types of Shape objects will implement. For
simplicity purpose, we can keep only two methods - draw() to draw the shape and getArea() that will
return the area of the shape.

Java Interface Example
Based on above requirements, our Shape interface will look like this.

Shape.java
package com.journaldev.design;

public interface Shape {

    //implicitly public, static and final
    public String LABLE="Shape";

    //interface methods are implicitly abstract and public
    void draw();

    double getArea();
}

Important Points about Interface in Java
interface is the code that is used to create an interface in java.

We can't instantiate an interface in java.
Interface provides absolute abstraction, in last post we learned about abstract classes in java to
provide abstraction but abstract classes can have method implementations but interface can't.
Interfaces can't have constructors because we can't instantiate them and interfaces can't have a
method with body.

By default any attribute of interface is public, static and final, so we don't need to provide access
modifiers to the attributes but if we do, compiler doesn't complain about it either.
By default interface methods are implicitly abstract and public, it makes total sense because the method
don't have body and so that subclasses can provide the method implementation.

An interface can't extend any class but it can extend another interface. public interface Shape extends
Cloneable{} is an example of an interface extending another interface. Actually java provides multiple
inheritance in interfaces, what is means is that an interface can extend multiple interfaces.
implements keyword is used by classes to implement an interface.

A class implementing an interface must provide implementation for all of its method unless it's an
abstract class. For example, we can implement above interface in abstract class like this:

ShapeAbs.java
package com.journaldev.design;

public abstract class ShapeAbs implements Shape {

    @Override
    public double getArea() {
        // TODO Auto-generated method stub
        return 0;
    }

}

We should always try to write programs in terms of interfaces rather than implementations so that we
know beforehand that implementation classes will always provide the implementation and in future if any
better implementation arrives, we can switch to that easily.
Java Interface Implementation Example
Now lets see some implementation of our Shape interface in java.

Circle.java
package com.journaldev.design;

public class Circle implements Shape {

    private double radius;

    public Circle(double r){
        this.radius = r;
    }

    @Override
    public void draw() {
        System.out.println("Drawing Circle");
    }

    @Override
    public double getArea(){
        return Math.PI*this.radius*this.radius;
    }

    public double getRadius(){
        return this.radius;
    }
}

Notice that Circle class has implemented all the methods defined in the interface and it has some of its own
methods also like getRadius(). The interface implementations can have multiple type of constructors. Lets
see another interface implementation for Shape interface.

Rectangle.java
package com.journaldev.design;

public class Rectangle implements Shape {

    private double width;
    private double height;

    public Rectangle(double w, double h){
        this.width=w;
        this.height=h;
    }
    @Override
    public void draw() {
        System.out.println("Drawing Rectangle");
    }

    @Override
    public double getArea() {
        return this.height*this.width;
    }

}

Notice the use of override annotation, learn about annotations in java and why we should always use
override annotation when overriding a method in java.

Here is a test program showing how to code in terms of interfaces and not implementations.

ShapeTest.java
package com.journaldev.design;

public class ShapeTest {

    public static void main(String[] args) {

        //programming for interfaces not implementation
        Shape shape = new Circle(10);

        shape.draw();
        System.out.println("Area="+shape.getArea());

        //switching from one implementation to another easily
        shape=new Rectangle(10,10);
        shape.draw();
        System.out.println("Area="+shape.getArea());
        }

}

Output of the above java interface example program is:
Drawing Circle
Area=314.1592653589793
Drawing Rectangle
Area=100.0

Java Interface Benefits
Interface provides a contract for all the implementation classes, so its good to code in terms of
interfaces because implementation classes can't remove the methods we are using.
Interfaces are good for starting point to define Type and create top level hierarchy in our code.
Since a java class can implements multiple interfaces, it's better to use interfaces as super class
in most of the cases.

Java Interface Disadvantages
Although interfaces provide a lot of advantages but it has some disadvantages too.
We need to chose interface methods very carefully at the time of designing our project because we
can't add of remove any methods from the interface at later point of time, it will lead compilation
error for all the implementation classes. Sometimes this leads to have a lot of interfaces extending
the base interface in our code that becomes hard to maintain.
If the implementation classes has its own methods, we can't use them directly in our code because the
type of Object is an interface that doesn't have those methods. For example, in above code we will
get compilation error for code shape.getRadius(). To overcome this, we can use typecasting and use the
method like this:
Circle c = (Circle) shape;
c.getRadius();
Although class typecasting has its own disadvantages.

Thats all I have for interface in java. Since we use java interface a lot, we should be aware of its
features. Make sure you use interfaces in designing the system and as a contract between the client and
the subclasses implementing the interfaces.
Update: Java 8 has changed the definition of interfaces with the introduction of default methods and
static methods implementation. For more details, please read Java 8 interface.

---
