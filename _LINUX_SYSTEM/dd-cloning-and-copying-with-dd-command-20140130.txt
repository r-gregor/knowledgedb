filename: dd_cloning-and-copying-with-dd-command_20140130.txt
http://askubuntu.com/questions/227924/sd-card-clone-using-dd-command

[38]SD card clone using dd command

   I am trying to clone SD card which may contain number of partitions, some of them Ubuntu
   cannot recognize. Generally, I want to clone the whole volume, not only some partition. So,
   I mount SD card and see in the Log viewer something like this:
kernel: [  262.025221]  sdc: sdc1 sdc2

alex@u120432:~$ ls /dev/sdc*
/dev/sdc  /dev/sdc1  /dev/sdc2

   Since I want to copy the whole disk, I execute:
dd if=/dev/sdc of=sdimage.img bs=4M

   File sdimage.img, 7.9 GB (7,944,011,776 bytes) is created (SD card is 8 GB). Now I mount
   another SD card and execute:
dd if=sdimage.img of=/dev/sdc bs=4M

   The problem is that the second dd command hangs on some stage, and never succeeds. After
   this, I cannot reboot or shut down computer, and need just to switch power off.

   Is this correct approach? Maybe there is another way to clone SD card?

   OS Ubuntu 12.04, 32 bit.
   [40]sd-card [41]clone
   [42]share|[43]improve this question
   asked Dec 11 '12 at 13:42
   [44]Alex Farber
   2842612

   Can you mount created img file and see if it is created correctly? –  [45]Milan Todorovic
   Dec 11 '12 at 14:40

   @MilanTodorovic - how can I do this? –  [46]Alex Farber Dec 11 '12 at 15:15

   If I remember correctly: mount -o loop sdimage.img /path/to/mount. Then check to see if you
   can browse img file correctly. –  [47]Milan Todorovic Dec 11 '12 at 15:17

   @MilanTodorovic: I tried sudo mount -o sdimage.img /dev/mydisk and got: mount: can't find
   /dev/mydisk in /etc/fstab or /etc/mtab Possibly I need to create some dev entry before. Can
   you post this as answer with some details? Thanks. –  [48]Alex Farber Dec 11 '12 at 15:22

   Try with sudo mount -o loop sdimage.img /dev/mydisk (you forgot loop after -o) –  [49]Milan
   Todorovic Dec 11 '12 at 15:26
   show 4 more comments

3 Answers

   [50]active [51]oldest [52]votes
   up vote 5 down vote accepted

   You should not be using dd on mounted devices. unmount all the partitions first, then your
   command should work.
   [53]share|[54]improve this answer
   answered Dec 13 '12 at 18:01
   [55]ubfan1
   1,7951412
   add comment
   up vote 3 down vote

   I am using dd tool to clone usb sticks with multiple partitions, here is my command:
sudo dd if=/dev/sdb of=/dev/sdc bs=4096 conv=notrunc,noerror

   notrunc - do not truncate the output file
   noerror - continue after read errors
   [56]share|[57]improve this answer
   answered Dec 11 '12 at 15:05
   [58]tommyk
   99531228

   Thanks, I will try this. –  [59]Alex Farber Dec 11 '12 at 15:17
   add comment
   up vote 1 down vote

   dd is fine, but I prefer cat /dev/sdc/ > ~/backup.iso If you want to put it on an SD card
   again, just run cat ~/backup.iso > /dev/sdc
   [60]share|[61]improve this answer
      [62]edited Dec 11 '12 at 21:25
   answered Dec 11 '12 at 14:36
   [63]Vreality
   488214

   Both SD are 8 GB. cat can be used to make SD image, but to make another SD I should use dd,
   right? –  [64]Alex Farber Dec 11 '12 at 15:17
   1
   Any explanation of downvote? If something is wrong in this answer, I want to know. –



---
http://mikelev.in/2010/09/cloning-an-sd-card-on-linux/

Cloning an SD Card on Linux

   by [79]Mike Levin on September 21, 2010

     Note: It has nothing to do with this article, but you can have [80]a Linux server for
     education running on your desktop in just a couple of minutes. It’s what my site is
     really becoming known for.

   Okay, its time to do the SD card cloning. This is full of nuances. First thing, be sure
   you’re on a Linux machine, because it is equipped with the dd command, which will do a raw
   copy of media, plowing right through partitions and such. Preferably, you should be on an
   Ubuntu box, due to its expansive device support and auto-mounting.

   Next, make sure you have as much room on your hard drive as the size media you’re using.
   This is an issue, because of the old recycled boxes and laptops we tend to use for these
   sorts of spare Linux boxes. The harddrive of the laptop I’m using is only 5 GB, so it is an
   issue. So if you’re cloning a 2GB SD card, you need AT LEAST 2GB free space available on
   the hard drive. You can confirm this with the simple “df” command. So just open a terminal
   window and type df, and you will see how much space you have available per partition on
   your system.

   While you’re at it, promote yourself to root (so long as you don’t plan on walking away
   from the box).

   sudo su

   Next, you need to identify the name of your sd card in the /dev directory. Its hard to do,
   and the little bit of detective work necessary to make it easy is simply to pop your sd
   card (and card reader) into a port, and then go to a terminal window and type:

   dmesg | tail

   What this does is it pipes your device messages into the tail command, showing you the last
   10 device messages you’ve received. One of them will be the one created by popping the SD
   card in, and will probably look something like:

   [  335.316290]  sd 3:0:0:0: [sdb] Attached SCSI removable disk

   This is your smoking gun. It’ll probably be the last entry. And this gives you the device
   name that you will use in the dd copy command.

   Now that your SD card s installed and you know that it is called /dev/sdb (or whatever),
   you can go ahead and copy the entire raw disk image to your hard drive. If you have 2 SD
   card readers, you can eliminate this step and go right from card to card. But I don’t, so
   here’s the copy-to-harddrive command.

   dd if=/dev/sdb of=~/sd-card.bin

   You might have to be root to do this, so you can sudo su and issue the above command, or
   optionally:

   sudo dd if=/dev/sdb of=/home/mike/sd-card.bin

   Just remember where you’re putting the file. It’s possible to open that folder through the
   GNOME desktop and do refreshes to see the size of the file grow. Mine went up to 1.8 GB
   before it finished, and took quite a long time.

   Put the new media into your SD card reader, and reverse the command. Of course be sure that
   your source and destination media are identical, right down to the manufacturer and the
   batch they came from, if at all possible. This is probably best accomplished by buying them
   all at once, or part of a multi-pack. This is a raw copy akin to a floppy disk or CD-ROM
   copy, and of course all floppy disks and CD-ROMs are basically laid out the same. But that
   is not true of SD cards that have many differences, so the more identical the source and
   destination media you use, the less grief you will cause yourself.

   dd if=/home/mike/sd-card.bin of=/dev/sda

   If this command seems ridiculously easy, it is. It’s just a long wait. And considering how
   easy it is, setting yourself up with an Ubuntu box just for this purpose is really the path
   of least resistance, compared to trying to do it on a PC with Norton Ghost or using some
   other paid software, or even setting up Cygwin on your PC. Just have a Linux box around for
   these types of things. It will help you immensely over time with the whole ShankServer
   thing.


   { 4 comments… read them below or [99]add one }

   max [100]May 17, 2011 at 2:26 PM
          Nice post, the complete site seems to be done with passion and love!! :D
          I need some help, is related with this post..
          I´m trying to make a copy of an SD card that had raw files, it´s from an embedded
          system without File system. Of course i can´t mount it, but i know it´s something
          like “/dev/mmcblk0″
          does it need to be mounted to make the copy?? when i do fisk -l does not list
          mmcblk0 because has no format..
          Thanks…
          Maximiliano… From Argentina

   [101]Staff [102]May 20, 2011 at 9:57 AM
          After surf more and more websites, spam, spoof without resolve, finally I have
          cloned my sdcard thank to your guide……
          Clear and direct to target!
          You are very expert!
          Compliment!
          If like, a Premim license of my software free for you… visit my website…. regards
          Staff

   Cipsiak [103]May 28, 2012 at 4:57 AM
          Very good advice!
          Big thanks!
          P.s.
          There just one typo:sudo dd if=dev/sdb of=/home/mike/sd-card.bin is missing a “/”
          before dev.

   Raaaaaymond [104]August 12, 2012 at 6:28 AM
          Hi Mike thank you for the tip, I really appreciate it. However I’d like to add
          something. I tried using your tip to copy the entire content of my 4gb MicroSD card
          onto a new 16gb MicroSD card. However after going through the process you kindly
          described above, the computer now thinks that my 16gb MicroSD card only has 4gb of
          space. So maybe this method you described is not suitable for cloning an SD card
          onto a bigger one?



---
http://www.x86linux.org/wiki/index.php/GNU/Linux_core_utility_-_dd_,_copy_files_with_specific_block_size_parameters

GNU/Linux core utility - dd , copy files with specific block size parameters

   From X86wiki
   Jump to: [5]navigation, [6]search

   Unix GNU/Linux dd low-level disk copy program

   Useful for:
     * Duplicating Master Boot Record's (MBR's)
     * Making copies of entire hard disks, partition or smaller media (floppies, thumb drives)

   Parameters: ibs,obs,bs: input block size, output block size, or block size for both input
   and output p-Code
dd bs=<block size> if=/dev/sda2 of=<output file>

   Default to copying from the beginning of input file if, but can 'skip=BLOCKS' from the
   input file before starting.

[[12]edit] Applied Examples

   Different utility programs report on hard disk and partition sizes in varying units.
   Harmonizing and understanding these is key to making efficient use of the dd program.

   Example: the fdisk and parted programs default to different size units when revealing the
   structure of hard disk devices.

[[13]edit] Handling Master Boot Records

   Master Boot Record Total Size (MBRTS)

   446 + 64 + 2 = 512 octets

446 octets - Self-Start Code
 64 octets - Partition Table
  2 octets - Signature

   dd if=<input file> of=<output file> bs=<block size (in octets)> count=<number of blocks>

   Note that in this context file is the generic nIX term for "anything". These can be
   /dev/sda's or /home/<user>/<filenames>.

   dd if=/dev/sda of=/mnt/media/Flash_4GB bs=512 count=1

   or, for a larger "scoop" of the first octets of the drive, up the count ...

   dd if=/dev/sda of=/mnt/media/Flash_4GB bs=512 count=8 // yields a 4GiB file

   ---restore partition image gunzip dd

[[14]edit] Cloning working Boot Partitions

     * Windows drives - FAT16, FAT32 and NTFS partitions - Duplicating MS-DOS & MS-Windows
       bootable partitions
     * Linux boot images, compressed images, /boot, etc.



---
http://man7.org/linux/man-pages/man1/dd.1.html

DD(1)                           User Commands                          DD(1)



NAME         [11]top

       dd - convert and copy a file



SYNOPSIS         [12]top

       dd [OPERAND]...
       dd OPTION



DESCRIPTION         [13]top

       Copy a file, converting and formatting according to the operands.

       bs=BYTES
              read and write up to BYTES bytes at a time

       cbs=BYTES
              convert BYTES bytes at a time

       conv=CONVS
              convert the file as per the comma separated symbol list

       count=N
              copy only N input blocks

       ibs=BYTES
              read up to BYTES bytes at a time (default: 512)

       if=FILE
              read from FILE instead of stdin

       iflag=FLAGS
              read as per the comma separated symbol list

       obs=BYTES
              write BYTES bytes at a time (default: 512)

       of=FILE
              write to FILE instead of stdout

       oflag=FLAGS
              write as per the comma separated symbol list

       seek=N skip N obs-sized blocks at start of output

       skip=N skip N ibs-sized blocks at start of input

       status=WHICH
              WHICH info to suppress outputting to stderr; 'noxfer'
              suppresses transfer stats, 'none' suppresses all

       N and BYTES may be followed by the following multiplicative suffixes:
       c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*1024,
       xM =M GB =1000*1000*1000, G =1024*1024*1024, and so on for T, P, E,
       Z, Y.

       Each CONV symbol may be:

       ascii  from EBCDIC to ASCII

       ebcdic from ASCII to EBCDIC

       ibm    from ASCII to alternate EBCDIC

       block  pad newline-terminated records with spaces to cbs-size

       unblock
              replace trailing spaces in cbs-size records with newline

       lcase  change upper case to lower case

       ucase  change lower case to upper case

       sparse try to seek rather than write the output for NUL input blocks

       swab   swap every pair of input bytes

       sync   pad every input block with NULs to ibs-size; when used with
              block or unblock, pad with spaces rather than NULs

       excl   fail if the output file already exists

       nocreat
              do not create the output file

       notrunc
              do not truncate the output file

       noerror
              continue after read errors

       fdatasync
              physically write output file data before finishing

       fsync  likewise, but also write metadata

       Each FLAG symbol may be:

       append append mode (makes sense only for output; conv=notrunc
              suggested)

       direct use direct I/O for data

       directory
              fail unless a directory

       dsync  use synchronized I/O for data

       sync   likewise, but also for metadata

       fullblock
              accumulate full blocks of input (iflag only)

       nonblock
              use non-blocking I/O

       noatime
              do not update access time

       nocache
              discard cached data

       noctty do not assign controlling terminal from file

       nofollow
              do not follow symlinks

       count_bytes
              treat 'count=N' as a byte count (iflag only)

       skip_bytes
              treat 'skip=N' as a byte count (iflag only)

       seek_bytes
              treat 'seek=N' as a byte count (oflag only)

       Sending a USR1 signal to a running 'dd' process makes it print I/O
       statistics to standard error and then resume copying.

              $ dd if=/dev/zero of=/dev/null& pid=$!
              $ kill -USR1 $pid; sleep 1; kill $pid

              18335302+0 records in 18335302+0 records out 9387674624 bytes
              (9.4 GB) copied, 34.6279 seconds, 271 MB/s

       Options are:

       --help display this help and exit

       --version
              output version information and exit

       GNU coreutils online help: <http://www.gnu.org/software/coreutils/>
       Report dd translation bugs to <http://translationproject.org/team/>



AUTHOR         [14]top

       Written by Paul Rubin, David MacKenzie, and Stuart Kemp.



COPYRIGHT         [15]top

       Copyright (C) 2014 Free Software Foundation, Inc.  License GPLv3+:
       GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
       This is free software: you are free to change and redistribute it.
       There is NO WARRANTY, to the extent permitted by law.



SEE ALSO         [16]top

       The full documentation for dd is maintained as a Texinfo manual.  If
       the info and dd programs are properly installed at your site, the
       command

              info coreutils 'dd invocation'

       should give you access to the complete manual.



COLOPHON         [17]top

       This page is part of the coreutils (basic file, shell and text
       manipulation utilities) project.  Information about the project can
       be found at [18]http://www.gnu.org/software/coreutils/.  If you have a
       bug report for this manual page, see
       [19]http://www.gnu.org/software/coreutils/.  This page was obtained from
       the project's upstream Git repository
       (git://git.sv.gnu.org/coreutils) on 2014-01-24.  If you discover any
       rendering problems in this HTML version of the page, or you believe
       there is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is not part of the original manual page), send a mail to
       man-pages@man7.org

GNU coreutils 8.22.16-be97f     January 2014                           DD(1)
 


---
http://www.gnu.org/software/coreutils/manual/html_node/dd-invocation.html

  11.2 dd: Convert and copy a file

   dd copies a file (from standard input to standard output, by default) with a changeable I/O
   block size, while optionally performing conversions on it. Synopses:
     dd [operand]...
     dd option

   The only options are --help and --version. See [8]Common options. dd accepts the following
   operands, whose syntax was inspired by the DD (data definition) statement of OS/360 JCL.

   ‘if=file’
          Read from file instead of standard input.

   ‘of=file’
          Write to file instead of standard output. Unless ‘conv=notrunc’ is given, dd
          truncates file to zero bytes (or the size specified with ‘seek=’).

   ‘ibs=bytes’
          Set the input block size to bytes. This makes dd read bytes per block. The default
          is 512 bytes.

   ‘obs=bytes’
          Set the output block size to bytes. This makes dd write bytes per block. The default
          is 512 bytes.

   ‘bs=bytes’
          Set both input and output block sizes to bytes. This makes dd read and write bytes
          per block, overriding any ‘ibs’ and ‘obs’ settings. In addition, if no
          data-transforming conv option is specified, input is copied to the output as soon as
          it's read, even if it is smaller than the block size.

   ‘cbs=bytes’
          Set the conversion block size to bytes. When converting variable-length records to
          fixed-length ones (conv=block) or the reverse (conv=unblock), use bytes as the fixed
          record length.

   ‘skip=n’
          Skip n ‘ibs’-byte blocks in the input file before copying. If ‘iflag=skip_bytes’ is
          specified, n is interpreted as a byte count rather than a block count.

   ‘seek=n’
          Skip n ‘obs’-byte blocks in the output file before copying. if ‘oflag=seek_bytes’ is
          specified, n is interpreted as a byte count rather than a block count.

   ‘count=n’
          Copy n ‘ibs’-byte blocks from the input file, instead of everything until the end of
          the file. if ‘iflag=count_bytes’ is specified, n is interpreted as a byte count
          rather than a block count. Note if the input may return short reads as could be the
          case when reading from a pipe for example, ‘iflag=fullblock’ will ensure that
          ‘count=’ corresponds to complete input blocks rather than the traditional POSIX
          specified behavior of counting input read operations.

   ‘status=which’
          Transfer information is normally output to stderr upon receipt of the ‘INFO’ signal
          or when dd exits. Specifying which will identify which information to suppress.

        ‘noxfer’
                Do not print the transfer rate and volume statistics that normally make up the
                last status line.

        ‘none’
                Do not print any informational or warning messages to stderr. Error messages
                are output as normal.

   ‘conv=conversion[,conversion]...’
          Convert the file as specified by the conversion argument(s). (No spaces around any
          comma(s).)

          Conversions:

        ‘ascii’
                Convert EBCDIC to ASCII, using the conversion table specified by POSIX. This
                provides a 1:1 translation for all 256 bytes.

        ‘ebcdic’
                Convert ASCII to EBCDIC. This is the inverse of the ‘ascii’ conversion.

        ‘ibm’
                Convert ASCII to alternate EBCDIC, using the alternate conversion table
                specified by POSIX. This is not a 1:1 translation, but reflects common
                historical practice for ‘~’, ‘[’, and ‘]’.

                The ‘ascii’, ‘ebcdic’, and ‘ibm’ conversions are mutually exclusive.

        ‘block’
                For each line in the input, output ‘cbs’ bytes, replacing the input newline
                with a space and padding with spaces as necessary.

        ‘unblock’
                Remove any trailing spaces in each ‘cbs’-sized input block, and append a
                newline.

                The ‘block’ and ‘unblock’ conversions are mutually exclusive.

        ‘lcase’
                Change uppercase letters to lowercase.

        ‘ucase’
                Change lowercase letters to uppercase.

                The ‘lcase’ and ‘ucase’ conversions are mutually exclusive.

        ‘sparse’
                Try to seek rather than write NUL output blocks. On a file system that
                supports sparse files, this will create sparse output when extending the
                output file. Be careful when using this option in conjunction with
                ‘conv=notrunc’ or ‘oflag=append’. With ‘conv=notrunc’, existing data in the
                output file corresponding to NUL blocks from the input, will be untouched.
                With ‘oflag=append’ the seeks performed will be ineffective. Similarly, when
                the output is a device rather than a file, NUL input blocks are not copied,
                and therefore this option is most useful with virtual or pre zeroed devices.

        ‘swab’
                Swap every pair of input bytes. GNU dd, unlike others, works when an odd
                number of bytes are read—the last byte is simply copied (since there is
                nothing to swap it with).

        ‘sync’
                Pad every input block to size of ‘ibs’ with trailing zero bytes. When used
                with ‘block’ or ‘unblock’, pad with spaces instead of zero bytes.

          The following “conversions” are really file flags and don't affect internal
          processing:

        ‘excl’
                Fail if the output file already exists; dd must create the output file itself.

        ‘nocreat’
                Do not create the output file; the output file must already exist.

                The ‘excl’ and ‘nocreat’ conversions are mutually exclusive.

        ‘notrunc’
                Do not truncate the output file.

        ‘noerror’
                Continue after read errors.

        ‘fdatasync’
                Synchronize output data just before finishing. This forces a physical write of
                output data.

        ‘fsync’
                Synchronize output data and metadata just before finishing. This forces a
                physical write of output data and metadata.

   ‘iflag=flag[,flag]...’
          Access the input file using the flags specified by the flag argument(s). (No spaces
          around any comma(s).)

   ‘oflag=flag[,flag]...’
          Access the output file using the flags specified by the flag argument(s). (No spaces
          around any comma(s).)

          Here are the flags. Not every flag is supported on every operating system.

        ‘append’
                Write in append mode, so that even if some other process is writing to this
                file, every dd write will append to the current contents of the file. This
                flag makes sense only for output. If you combine this flag with the ‘of=file’
                operand, you should also specify ‘conv=notrunc’ unless you want the output
                file to be truncated before being appended to.

        ‘cio’
                Use concurrent I/O mode for data. This mode performs direct I/O and drops the
                POSIX requirement to serialize all I/O to the same file. A file cannot be
                opened in CIO mode and with a standard open at the same time.

        ‘direct’
                Use direct I/O for data, avoiding the buffer cache. Note that the kernel may
                impose restrictions on read or write buffer sizes. For example, with an ext4
                destination file system and a linux-based kernel, using ‘oflag=direct’ will
                cause writes to fail with EINVAL if the output buffer size is not a multiple
                of 512.

        ‘directory’
                Fail unless the file is a directory. Most operating systems do not allow I/O
                to a directory, so this flag has limited utility.

        ‘dsync’
                Use synchronized I/O for data. For the output file, this forces a physical
                write of output data on each write. For the input file, this flag can matter
                when reading from a remote file that has been written to synchronously by some
                other process. Metadata (e.g., last-access and last-modified time) is not
                necessarily synchronized.

        ‘sync’
                Use synchronized I/O for both data and metadata.

        ‘nocache’
                Discard the data cache for a file. When count=0 all cache is discarded,
                otherwise the cache is dropped for the processed portion of the file. Also
                when count=0 failure to discard the cache is diagnosed and reflected in the
                exit status. Here as some usage examples:

               # Advise to drop cache for whole file
               dd if=ifile iflag=nocache count=0

               # Ensure drop cache for the whole file
               dd of=ofile oflag=nocache conv=notrunc,fdatasync count=0

               # Drop cache for part of file
               dd if=ifile iflag=nocache skip=10 count=10 of=/dev/null

               # Stream data using just the read-ahead cache
               dd if=ifile of=ofile iflag=nocache oflag=nocache

        ‘nonblock’
                Use non-blocking I/O.

        ‘noatime’
                Do not update the file's access time. Some older file systems silently ignore
                this flag, so it is a good idea to test it on your files before relying on it.

        ‘noctty’
                Do not assign the file to be a controlling terminal for dd. This has no effect
                when the file is not a terminal. On many hosts (e.g., GNU/Linux hosts), this
                option has no effect at all.

        ‘nofollow’
                Do not follow symbolic links.

        ‘nolinks’
                Fail if the file has multiple hard links.

        ‘binary’
                Use binary I/O. This option has an effect only on nonstandard platforms that
                distinguish binary from text I/O.

        ‘text’
                Use text I/O. Like ‘binary’, this option has no effect on standard platforms.

        ‘fullblock’
                Accumulate full blocks from input. The read system call may return early if a
                full block is not available. When that happens, continue calling read to fill
                the remainder of the block. This flag can be used only with iflag. This flag
                is useful with pipes for example as they may return short reads. In that case,
                this flag is needed to ensure that a ‘count=’ argument is interpreted as a
                block count rather than a count of read operations.

        ‘count_bytes’
                Interpret the ‘count=’ operand as a byte count, rather than a block count,
                which allows specifying a length that is not a multiple of the I/O block size.
                This flag can be used only with iflag.

        ‘skip_bytes’
                Interpret the ‘skip=’ operand as a byte count, rather than a block count,
                which allows specifying an offset that is not a multiple of the I/O block
                size. This flag can be used only with iflag.

        ‘seek_bytes’
                Interpret the ‘seek=’ operand as a byte count, rather than a block count,
                which allows specifying an offset that is not a multiple of the I/O block
                size. This flag can be used only with oflag.

          These flags are not supported on all systems, and ‘dd’ rejects attempts to use them
          when they are not supported. When reading from standard input or writing to standard
          output, the ‘nofollow’ and ‘noctty’ flags should not be specified, and the other
          flags (e.g., ‘nonblock’) can affect how other processes behave with the affected
          file descriptors, even after dd exits.

   The numeric-valued strings above (n and bytes) can be followed by a multiplier: ‘b’=512,
   ‘c’=1, ‘w’=2, ‘xm’=m, or any of the standard block size suffixes like ‘k’=1024 (see
   [9]Block size).

   Any block size you specify via ‘bs=’, ‘ibs=’, ‘obs=’, ‘cbs=’ should not be too large—values
   larger than a few megabytes are generally wasteful or (as in the gigabyte..exabyte case)
   downright counterproductive or error-inducing.

   To process data that is at an offset or size that is not a multiple of the I/O block size,
   you can use the ‘skip_bytes’, ‘seek_bytes’ and ‘count_bytes’ flags. Alternatively the
   traditional method of separate dd invocations can be used. For example, the following shell
   commands copy data in 512 KiB blocks between a disk and a tape, but do not save or restore
   a 4 KiB label at the start of the disk:
     disk=/dev/rdsk/c0t1d0s2
     tape=/dev/rmt/0

     # Copy all but the label from disk to tape.
     (dd bs=4k skip=1 count=0 && dd bs=512k) <$disk >$tape

     # Copy from tape back to disk, but leave the disk label alone.
     (dd bs=4k seek=1 count=0 && dd bs=512k) <$tape >$disk

   Sending an ‘INFO’ signal to a running dd process makes it print I/O statistics to standard
   error and then resume copying. In the example below, dd is run in the background to copy 10
   million blocks. The kill command makes it output intermediate I/O statistics, and when dd
   completes normally or is killed by the SIGINT signal, it outputs the final statistics.
     $ dd if=/dev/zero of=/dev/null count=10MB & pid=$!
     $ kill -s INFO $pid; wait $pid
     3385223+0 records in
     3385223+0 records out
     1733234176 bytes (1.7 GB) copied, 6.42173 seconds, 270 MB/s
     10000000+0 records in
     10000000+0 records out
     5120000000 bytes (5.1 GB) copied, 18.913 seconds, 271 MB/s

   On systems lacking the ‘INFO’ signal dd responds to the ‘USR1’ signal instead, unless the
   POSIXLY_CORRECT environment variable is set.

   An exit status of zero indicates success, and a nonzero value indicates failure.



---
http://en.wikipedia.org/wiki/Dd_(Unix)

dd (Unix)

   From Wikipedia, the free encyclopedia

   dd is a command on [7]Unix and [8]Unix-like [9]operating systems whose primary purpose is
   to convert and copy a file.^[10][1]

   On Unix, device drivers for hardware (such as [11]hard disks) and special [12]device files
   (such as [13]/dev/zero and [14]/dev/random) appear in the file system just like normal
   files; dd can also read and/or write from/to these files, provided that function is
   implemented in their respective driver. As a result, dd can be used for tasks such as
   backing up the [15]boot sector of a hard drive, and obtaining a fixed amount of random
   data. The dd program can also perform conversions on the data as it is copied, including
   [16]byte order swapping and conversion to and from the [17]ASCII and [18]EBCDIC text
   encodings.^[19][2]

   The name dd may be an allusion to the [20]DD statement found in [21]IBM's [22]Job Control
   Language (JCL),^[23][3] where the initialism stands for "Data Description."^[24][4] The
   command's syntax resembles the JCL statement more than it does other Unix commands, so the
   syntax may have been a joke.^[25][3] Another explanation for the command's name is that
   "cc" (for "convert and copy", as in the command's description) was already taken by the C
   compiler.^[[26]citation needed]

   The dd command is specified by [27]IEEE Std 1003.1-2008, which is part of the [28]Single
   UNIX Specification.

Usage[[47]edit]

   The [48]command line syntax of dd differs from many other Unix programs, in that it uses
   the syntax option=value for its [49]command line options, rather than the more-standard
   --option value or -option=value formats. By default, dd reads from [50]STDIN and writes to
   [51]STDOUT, but these can be changed by using the if (input file) and of (output file)
   options.

   Usage varies across different [52]operating systems. Also, certain features of dd will
   depend on the computer system capabilities, such as dd's ability to implement an option for
   direct memory access. Sending a [53]SIGINFO signal (or a USR1 signal on Linux) to a running
   dd process makes it print I/O statistics to [54]standard error once and then continue
   copying (note that signals may terminate the process on OS X). dd can read [55]standard
   input from the keyboard. When [56]end-of-file (EOF) is reached, dd will exit. Signals and
   EOF are determined by the software. For example, Unix tools ported to [57]Windows vary as
   to the EOF: [58]Cygwin uses <ctrl-d> (the usual Unix EOF) and [59]MKS Toolkit uses <ctrl-z>
   (the usual Windows EOF).

   In spirit with the [60]Unix philosophy, dd does one thing (and may be considered to do it
   "well" ). Unlike a sophisticated and highly abstracted utility, dd has no algorithm other
   than in the low-level decisions of the user concerning how to vary the run options. Often,
   the options are changed for each run of dd in a multi-step process to solve a computer
   problem.

Output messages[[61]edit]

   The GNU variant of dd as supplied with coreutils on Linux does not describe the format of
   the messages displayed on standard output on completion. However, these are described by
   other implementations, e.g. that with BSD.

   Each of the "Records in" and "Records out" lines shows the number of complete blocks
   transferred + the number of partial blocks, e.g. because the physical medium ended before a
   complete block was read, or a physical error prevented reading the complete block.

Block size[[62]edit]

   A [63]block is a unit measuring the number of [64]bytes that are read, written, or
   converted at one time. Command line options can specify a different block size for
   input/reading (ibs) compared to output/writing (obs), though the block size (bs) option
   will override both ibs and obs. The default value for both input and output block sizes is
   512 bytes (the traditional block size of disks, and POSIX-mandated size of "a block"). The
   count option for copying is measured in blocks, as are both the skip count for reading and
   seek count for writing. Conversion operations are also affected by the "conversion block
   size" (cbs).

   For some uses of the dd command, block size may have an effect on performance. For example,
   when recovering data from a hard disk, a small block size will generally cause the most
   bytes to be recovered. Issuing many small reads is an overhead and may be non-beneficial to
   execution performance. For greater speed during copy operations, a larger block size may be
   used. However, because the amount of bytes to copy is given by bs×count, it is impossible
   to copy a prime number of bytes in one go without going with one of two bad choices, bs=N
   count=1 (memory use) or bs=1 count=N (read request overhead). Alternative programs (see
   below) permit specifying bytes rather than blocks.
   When dd is used for network transfers, the block size may have also an impact on packet
   size, depending on the network protocol used.

   The value provided for block size options is interpreted as a decimal (base 10) integer and
   can also include suffixes to indicate multiplication. The suffix w means multiplication by
   2, b means 512, k means 1024, M means 1024 × 1024, G means 1024 × 1024 × 1024, and so on.
   Additionally, some implementations understand the x character as a multiplication operator
   for both block size and count parameters.

   For example, a block size such as bs=2x80x18b is interpreted as 2 × 80 × 18 × 512 = 1474560
   bytes, the exact size of a 1440 KiB [65]floppy disk.

Uses[[66]edit]

   The dd command can be used for a variety of purposes.

Data transfer[[67]edit]

   dd can duplicate data across files, devices, partitions and volumes. The data may be input
   or output to and from any of these; but there are important differences concerning the
   output when going to a partition. Also, during the transfer, the data can be modified using
   the conv options to suit the medium.

   An attempt to copy the entire disk using [68]cp may omit the final block if it is of an
   unexpected length^[[69]citation needed]; whereas dd may succeed. The source and destination
   disks should have the same size.

   CAPTION: Data transfer forms of dd

   dd if=/dev/sr0 of=myCD.iso bs=2048 conv=noerror,sync create an [70]ISO [71]disk image from
   a CD-ROM.
   dd if=/dev/sda2 of=/dev/sdb2 bs=4096 conv=noerror [72]Clone one [73]partition to another
   dd if=/dev/ad0 of=/dev/ad1 bs=1M conv=noerror Clone a hard disk "ad0" to "ad1".

   The noerror option means to keep going if there is an error. The sync option means to pad
   the output blocks.

Master boot record backup and restore[[74]edit]

   It is possible to repair a master boot record. It can be transferred to and from a repair
   file.

   To duplicate the first two sectors of a floppy drive:
dd if=/dev/fd0 of=MBRboot.img bs=512 count=2

   To create an image of the entire x86 [75]master boot record (including a MS-DOS
   [76]partition table and MBR magic bytes):
dd if=/dev/sda of=MBR.img bs=512 count=1

   To create an image of only the boot code of the [77]master boot record (without the
   [78]partition table and without the magic bytes required for booting):
dd if=/dev/sda of=MBR_boot.img bs=446 count=1

Data modification[[79]edit]

   dd can modify data in place.

   Overwrite the first 512 bytes of a file with null bytes:
dd if=/dev/zero of=path/to/file bs=512 count=1 conv=notrunc

   The notrunc conversion option means do not truncate the output file — that is, if the
   output file already exists, just replace the specified bytes and leave the rest of the
   output file alone. Without this option, dd would create an output file 512 bytes long.

   To duplicate a disk partition as a disk image file on a different partition:
dd if=/dev/sdb2 of=partition.image bs=4096 conv=noerror

Disk wipe[[80]edit]

   Main article: [81]data erasure

   For security reasons, it is sometimes necessary to have a [82]disk wipe of a discarded
   device.

   To check to see if a drive has data on it, send the output to standard out.
dd if=/dev/sda

   To wipe a disk by writing zeros:
dd if=/dev/zero of=/dev/sda bs=4k conv=notrunc

   The bs=4k option makes dd read and write 4 [83]kilobytes at a time. For modern systems, an
   even greater block size may be beneficial due to the transport capacity (think RAID
   systems). Note that filling the drive with random data will always take a lot longer than
   zeroing the drive, because the random data must be rendered by the CPU and/or [84]HWRNG
   first, and different designs have different performance characteristics. (The PRNG behind
   /dev/urandom may be slower than libc's.) On most relatively modern drives, zeroing the
   drive will render any data it contains permanently irrecoverable.^[85][5]

   Zeroing the drive will render any data it contains irrecoverable by software; however it
   still may be recoverable by [86]special laboratory techniques.

   The [87]shred program provides an alternate method for the same task, and finally, the
   [88]wipe program present in many Linux distributions provides an elaborate tool (the one
   that does it "well", going back to the Unix philosophy mentioned before) with many ways of
   clearing.

Data recovery[[89]edit]

   The history of [90]open-source software (OSS) for [91]data recovery and restoration of
   files, drives, and partitions started with GNU dd in 1984, with one block size per dd
   process, and no recovery algorithm other than the user's interactive session running one
   form of dd after another. Then, a C program was authored October 1999 called [92]dd_rescue.
   It has two block sizes in its algorithm. But the author of the 2003 shell script
   [93]dd_rhelp that enhances dd_rescue's data recovery algorithm, now recommends [94]GNU
   ddrescue,^[95][6] a C++ program that was initially released in 2004 and is now in most
   Linux distributions. GNU ddrescue has the most sophisticated block-size-changing algorithm
   available in OSS.^[96][7] (The names ddrescue and dd_rescue are similar, yet they are
   different programs. Because of this, alternate names for more unambiguous distinguishing is
   used; names used are "addrescue" (name on freecode.com), "gddrescue" ([97]Debian package
   name) and "gnu_ddrescue" ([98]openSUSE package name).)

   GNU ddrescue is stable and safe.^[99][8]

   Another open source program called savehd7 uses a sophisticated algorithm, but it also
   requires the installation of its own programming-language interpreter.

Benchmarking drive performance[[100]edit]

   To make drive benchmark test and analyze the sequential (and usually single-threaded)
   system read and write performance for 1024-byte blocks :
dd if=/dev/zero bs=1024 count=1000000 of=file_1GB
dd if=file_1GB of=/dev/null bs=1024

Generating a file with random data[[101]edit]

   To make a file of 100 random bytes using the kernel random driver:
dd if=/dev/urandom of=myrandom bs=100 count=1

Converting a file to upper case[[102]edit]

   To convert a file to uppercase:
dd if=filename of=filename1 conv=ucase

Creating empty files of arbitrary size[[103]edit]

   Create a 1 GiB [104]sparse file, or resize an existing file to 1 GiB without overwriting:
dd if=/dev/zero of=mytestfile.out bs=1 count=0 seek=1G

   (A more modern tool for this is fallocate or truncate, both shipped with GNU coreutils.)

Limitations[[105]edit]

   [106]Seagate documentation warns, "Certain disc utilities, such as DD, which depend on
   low-level disc access may not support 48-bit [107]LBAs until they are
   updated".^[108][9]^[[109]citation needed] Using ATA harddrives over 128 GiB requires 48-bit
   LBA. However, in [110]Linux, dd uses the kernel to read or write to raw [111]device
   files.^[112][10] Support for 48-bit LBA has been present since version 2.4.23 of the
   kernel, released in 2003.^[113][11]^[114][12]

   It is jokingly said that dd stands for "destroy disk" or "delete data", since when used for
   low-level operations on hard disks, a small mistake such as reversing the input file and
   output file parameters could result in the loss of some or all data on a disk.^[115][2]

Dcfldd[[116]edit]

   dcfldd is a fork of dd that is an enhanced version developed by Nick Harbour; who at the
   time was working for the United States' [117]Department of Defense Computer Forensics
   Lab.^[118][13]^[119][14]^[120][15] Compared to dd, dcfldd allows for more than one output
   file, supports simultaneous multiple checksum calculations, provides a verification mode
   for file matching, and can display of the percentage progress of an operation.



---
http://serverfault.com/questions/147935/how-to-determine-the-best-byte-size-for-the-dd-command

[21]How to determine the best byte size for the dd command

   I know that doing a dd if=/dev/hda of=/dev/hdb does a deep hard drive copy. I've heard that
   people have been able to speed up the process by increasing the number of bytes that are
   read and written at a time (512) with the "bs" option. People have suggested that the
   optimal byte size is due to sector size. I personally think it would have something to do
   with the amount of cache that the hard drive has.

   My question is:

   What determines the ideal byte size for copying from a hard drive?

   and

   Why does that determine the ideal byte size?

   Edit:

   ok, so I read the man page for dd again and it says

   "bs=BYTES Block size, both read and write BYTES bytes at a time. This overrides ibs and
   obs."

   So the dd command is asking for the block size in bytes that is used on the hard drive? Is
   this the same as the "Allocation unit size" under the windows format options? Indeed these
   are a power of 2 and the smallest option happens to be 512. So in order to optimize the
   speed... you can either remember what block size you used when you formatted the drive or
   find a tool that tells you. I still don't fully understand what formatting a drive with
   different block sizes does and why dd is able to copy faster if it knows the block size.

   Thanks to Chris S for mentioning that block size is 2 to the power of some number. That is
   what reminded me of the "Allocation unit size" thing.
   [23]linux [24]hard-drive [25]optimization [26]clone
   [27]share|[28]improve this question
         [29]edited Jun 3 '10 at 21:02
   asked Jun 3 '10 at 17:43
   [30]James T
   33529

   I thought that it would have to divide perfectly evenly into the size of the drive or
   partition: hence I have tried to determine the exact byte size of the target partition,
   obtain the prime factors, and determine a reasonably large block that is a multiple of
   several of those prime factors... –  [31]PP. Jun 4 '10 at 8:23
   add comment

2 Answers

   [32]active [33]oldest [34]votes
   up vote 11 down vote accepted

   As Chris S says the optimum block size is hardware dependent. In my experience it is always
   greater than the default 512 bytes. If your working with raw devices then the overlying
   file system geometry will have no effect. I've used the script below to help 'optimise' the
   block size of dd.
#!/bin/bash
#
#create a file to work with
#
echo "creating a file to work with"
dd if=/dev/zero of=/var/tmp/infile count=1175000

for bs in  1k 2k 4k 8k 16k 32k 64k 128k 256k 512k 1M 2M 4M 8M

do
        echo "Testing block size  = $bs"
        dd if=/var/tmp/infile of=/var/tmp/outfile bs=$bs
        echo ""
done
rm /var/tmp/infile /var/tmp/outfile

   [35]share|[36]improve this answer
      answered [37]Jun 4 '10 at 8:18
   community wiki
   [38]Iain
   2
   In OS X, "1M...8M" should be lowercased to "1m...8m". –  [39]Matt Beckman Apr 13 '12 at
   8:22
   1
   you could add a "time " in front of dd, to have additionnal infos on what amount of time
   was spent waiting for IO and what amount is real work... –  [40]Olivier Dulac Apr 3 '13 at
   12:42
   add comment
   up vote 0 down vote

   Unfortunately the perfect size will depend on your system bus, hard drive controller, the
   particular drive itself, and the drivers for each of those. The only way to find the
   perfect size is to keep trying different sizes. Fair warning that some devices only support
   one block size, though this is rare, and usually drivers make up the difference anyway.

   I find that block size of 2^15 or 2^16 work best for my WDC (8mb cache) SATA drives
   connected to a Adaptec SAS RAID controller, 4x PCIe, 64-bit FreeBSD 8.0-STABLE. But for my
   cheap old thumb drive, sizes of 2^10 seem to be fastest.

   The "perfect size" is almost always a power of two.



---
http://superuser.com/questions/234199/good-block-size-for-disk-cloning-with-diskdump-dd

[21]Good block size for disk cloning with diskdump (dd)

   I use dd in its simplest form to clone a hard drive
dd if=INPUT of=OUTPUT

   However, I read in the manpage that dd knows a blocksize parameter. I was wondering whether
   there is an optimal value for the blocksize parameter that will speed up the cloning
   procedure?

   Cheers!

   Stefan
   [23]linux [24]hard-drive [25]backup [26]clone
   [27]share|[28]improve this question
   [29]edited Feb 5 '13 at 2:13
   [30]RTOSkit
   426313
   asked Jan 17 '11 at 9:44
   [31]Phi
   48114
   add comment

5 Answers

   [32]active [33]oldest [34]votes
   up vote 1 down vote accepted

   64k seems to be a good pick:
Results:

  no bs=        78s     144584+0 records
  bs=512        78s     144584+0 records
  bs=1k         38s     72292+0 records
  bs=2k         38s     36146+0 records
  bs=4k         38s     18073+0 records
  bs=5k         39s     14458+1 records
  bs=50k        38s     1445+1 records
  bs=500k       39s     144+1 records
  bs=512k       39s     144+1 records
  bs=1M         39s     72+1 records
  bs=5M         39s     14+1 records
  bs=10M        39s     7+1 records

   (taken from [35]here).

   this matches with my own findings regarding read/write buffering for speeding up an
   io-heavy converter-program i was once pimping @work.
   [36]share|[37]improve this answer
      [38]edited Jan 17 '11 at 13:09
   answered Jan 17 '11 at 9:55
   [39]akira
   26.4k452102
   add comment
   up vote 5 down vote

   dd will happily copy using the BS of whatever you want, and will copy of partial block.

   Basically, the block size (bs) parameter seems to set the amount of memory thats used to
   read in a lump from one disk before trying to write that lump to the other.

   If you have lots of RAM, then making the BS large (but entirely contained in RAM) means
   that the I/O sub-system is utilised as much as possible by doing massively large reads and
   writes - exploiting the RAM. Making the BS small means that the I/O overhead as a
   proportion of total activity goes up.

   Of course in this there is a law of diminishing returns. My rough approximation is that a
   block size in the range about 128K to 32M is probably going to give performance such that
   the overheads are small compared to the plain I/O, and going larger won't make a lot of
   difference. The reason for the lower bound being 128K to 32M is - it depends on your OS,
   hardware, and so on.

   If it were me, I'd do a few experiments timing a copy/clone using a BS of 128K and again
   using (say) 16M. If one is appreciably faster, use it. If not, then use the smaller BS of
   the two.
   [40]share|[41]improve this answer
   answered Jan 17 '11 at 12:15
   [42]quickly_now
   1,49159
   add comment
   up vote 4 down vote

   Yes, but you won't find it without lots of testing. I've found that 32M is a good value to
   use though.
   [43]share|[44]improve this answer
   answered Jan 17 '11 at 9:48
   [45]Ignacio Vazquez-Abrams
   69.1k355121
   add comment
   up vote 2 down vote

   For those that end up here via Google, even if this discussion is a bit old...

   Keep in mind that dd is dumb for a reason: the simpler it is, the fewer ways it can screw
   up.

   Complex partitioning schemes (consider a dual-boot hard drive that additionally uses LVM
   for its Linux system) will start pulling bugs out of the woodwork in programs like
   Clonezilla. Badly-unmounted filesystems can blow ntfsclone sky-high.

   A corrupt filesystem cloned sector-by-sector is no worse than the original. A corrupt
   filesystem after a failed "smart copy" may be in REALLY sorry shape.

   When in doubt, use dd and go forensic. Forensic imaging requires sector-by-sector copies
   (in fact, it can require more sectors than you're going to be able to pull off with dd, but
   that's a long story). It is slow and tedious but it will get the job done correctly.

   Also, get to know the "conv=noerror,sync" options, so that you can clone drives that are
   starting to fail-- or make ISOs from scratched (cough) CDs-- without it taking months.
   [46]share|[47]improve this answer
   answered Nov 1 '12 at 11:45
   [48]Matt Heck
   391
   add comment
   up vote 1 down vote

   First, there are much better tools to clone a hd than dd. A simple file copy ( cp -a ) is a
   perfectly good way. If you want to keep the same fs UUID and the boot loader intact ( as
   well as any fragmentation present ), then clonezilla or ghost4linux are good candidates.

   Because dd is a dumb animal, it wastes time copying free space, and requires that the
   destination be at least as large as the source, and any additional size is unused,
   requiring you to manually expand the fs later.

   As for what block size is best, it depends on a number of factors. The largest is whether
   the source and destination are different partitions on the same disk, or different disks (
   on different controllers ). Whether you use the direct flag is important as well. If you do
   not enable direct and you are copying between two disks, then very large block sizes (
   above 1 MB ) actually slow things down, since the block cache will make dd wait a bit after
   such a large write before it can read from the source again so you don't keep both disks
   busy. If you are copying between two partitions on the same disk, then this delay can
   actually be a good thing and larger block sizes are better because there are fewer seeks.

   I usually find using the direct flag with 32 or so MB block size works best going between
   partitions on the same disk, and 128-512k either without the direct flag, or with direct
   but piping one input dd to another output dd for drive to drive.
   [49]share|[50]improve this answer
   answered Jan 17 '11 at 16:13
   [51]psusi
   3,078410

   Thanks for the answer. Sorry for the late reply. Thanks for pointing out alternatives to
   dd. I was working in a sort of restricted lab environment and falling back to dd was really
   necessary, but good to know about the alternatives for future work. –  [52]Phi Mar 29 '11
   at 12:09



---
https://wiki.archlinux.org/index.php/Disk_Cloning

Disk Cloning

   From ArchWiki

   Disk cloning is the process of making an image of a partition or an entire hard drive. This
   can be useful both for copying the drive to other computers and for backup/recovery
   purposes. There is also a dedicated page [13]File Recovery.

Using dd

   The dd command is a simple, yet versatile and powerful tool. It can be used to copy from
   source to destination, block-by-block, regardless of their filesystem types or operating
   systems. A convenient method is to use dd from a live environment, as in a livecd.
   Warning: As with any command of this type, you should be very cautious when using it; it
   can destroy data. Remember the order of input file (if=) and output file (of=) and do not
   reverse them! Always ensure that the destination drive or partition (of=) is of equal or
   greater size than the source (if=).

Cloning a partition

   From physical disk /dev/sda, partition 1, to physical disk /dev/sdb, partition 1.
dd if=/dev/sda1 of=/dev/sdb1 bs=4096 conv=notrunc,noerror

   If output file of (sdb1 in the example) does not exist, dd will start at the beginning of
   the disk and create it.

Cloning an entire hard disk

   From physical disk /dev/sda to physical disk /dev/sdb
dd if=/dev/sda of=/dev/sdb bs=4096 conv=notrunc,noerror

   This will clone the entire drive, including MBR (and therefore bootloader), all partitions,
   UUIDs, and data.
     * notrunc or 'do not truncate' maintains data integrity by instructing dd not to truncate
       any data.
     * noerror instructs dd to continue operation, ignoring all input errors. Default behavior
       for dd is to halt at any error.
     * bs=4096 sets the block size to 4k, an optimal size for hard disk read/write efficiency
       and therefore, cloning speed.

   Note: To regain unique UUIDs, use "tune2fs /dev/sdbX -U random" on every partitions.
   Note: Partition table changes from dd are not be registered by the kernel. To notify of
   changes without rebooting, use a utility like partprobe (part of GNU parted).

Backing up the MBR

   The MBR is stored in the the first 512 bytes of the disk. It consist of 3 parts:
    1. The first 446 bytes contain the boot loader.
    2. The next 64 bytes contain the partition table (4 entries of 16 bytes each, one entry
       for each primary partition).
    3. The last 2 bytes contain an identifier

   To save the MBR into the file "mbr.img":
  # dd if=/dev/hda of=/mnt/sda1/mbr.img bs=512 count=1

   To restore (be careful : this could destroy your existing partition table and with it
   access to all data on the disk):
  # dd if=/mnt/sda1/mbr.img of=/dev/hda

   If you only want to restore the boot loader, but not the primary partition table entries,
   just restore the first 446 bytes of the MBR:
  # dd if=/mnt/sda1/mbr.img of=/dev/hda bs=446 count=1

   To restore only the partition table, one must use
  # dd if=/mnt/sda1/mbr.img of=/dev/hda bs=1 skip=446 count=64

   You can also get the MBR from a full dd disk image.
  #dd if=/path/to/disk.img of=/mnt/sda1/mbr.img bs=512 count=1

Create disk image

   1. Boot from a liveCD or liveUSB.

   2. Make sure no partitions are mounted from the source hard drive.

   3. Mount the external HD

   4. Backup the drive.
 # dd if=/dev/hda conv=sync,noerror bs=64K | gzip -c  > /mnt/sda1/hda.img.gz

   5. Save extra information about the drive geometry necessary in order to interpret the
   partition table stored within the image. The most important of which is the cylinder size.
 # fdisk -l /dev/hda > /mnt/sda1/hda_fdisk.info

   NOTE: You may wish to use a block size (bs=) that is equal to the amount of cache on the HD
   you are backing up. For example, bs=8192K works for an 8MB cache. The 64K mentioned in this
   article is better than the default bs=512 bytes, but it will run faster with a larger bs=.

Restore system

   To restore your system:
 # gunzip -c /mnt/sda1/hda.img.gz | dd of=/dev/hda

Using cp

   The cp program can be used to clone a disk, one partition at a time. An advantage to using
   cp is that the filesystem type of the destination partition(s) may be the same or different
   than the source. For safety, perform the process from a live environment.
   Note: This method should not be considered in the same category as disk cloning on the
   level at which dd operates. Also, it has been reported that even with the -a flag, some
   extended attributes may not be copied. For better results, rsync or tar should be used.

   The basic procedure from a live environment will be:
     * Create the new destination partition(s) using fdisk, cfdisk or other tools available in
       the live environment.
     * Create a filesystem on each of the newly created partitions. Example:

mkfs -t ext3 /dev/sdb1

     * Mount the source and destination partitions. Example:

mount -t ext3 /dev/sda1 /mnt/source
mount -t ext3 /dev/sdb1 /mnt/destination

     * Copy the files from the source partition to the destination

cp -a /mnt/source/* /mnt/destination

   -a: preserve all attributes , never follow symbolic links and copy recursively
     * Change the mount points of the newly cloned partitions in /etc/fstab accordingly
     * Finally, install the GRUB bootloader if necessary. (See [25]GRUB)

Disk cloning software

Disk cloning in Arch

     * [26]Partclone provides utilities to save and restore used blocks on a partition and
       supports ext2, ext3, ext4, hfs+, reiserfs, reiser4, btrfs, vmfs3, vmfs5, xfs, jfs, ufs,
       ntfs, fat(12/16/32) and exfat. Optionally, a ncurses interface can be used. Partclone
       is available in the community repository.
     * [27]Partimage, an ncurses program, is available in the community repos. Partimage does
       not currently support ext4 or btrfs filesystems. NTFS is experimental.

Disk cloning outside of Arch

   If you wish to backup or propagate your Arch install root, you are probably better off
   booting into something else and clone the partition from there. Some suggestions:
     * [28]PartedMagic has a very nice live cd/usb with PartImage and other recovery tools.
     * [29]Mindi is a linux distribution specifically for disk clone backup. It comes with its
       own cloning program, Mondo Rescue.
     * [30]Acronis True Image is a commercial disk cloner for Windows. It allows you to create
       a live cd (from within Windows), so you do not need a working Windows install on the
       actual machine to use it.
     * [31]FSArchiver allows you to save the contents of a file system to a compressed archive
       file. Can be found on the [32]System Rescue CD.
     * [33]Clonezilla is an enhanced partition imager which can also restore entire disks as
       well as partitions.
     * [34]Redo Backup and Recovery is a Live CD featuring a graphical front-end to partclone.



---
http://stackoverflow.com/questions/54612/fast-disk-cloning

[22]Fast Disk Cloning

   Is there a way to have Linux read ahead when cloning a disk? I use the program named "dd"
   to clone disks. The last time I did this it seemed as though the OS was reading then
   writing but never at the same time. Ideally, the destination disk would be constantly
   writing without waiting that's of course if the source disk can keep up.

   UPDATE: I normally choose a large block size when cloning (ex. 16M or 32MB).
   [24]linux [25]dd [26]hdd
   [27]share|[28]improve this question
   [29]edited Jul 17 '12 at 2:55
   [30]Reinier Torenbeek
   3,1942518
   asked Sep 10 '08 at 16:39
   [31]Mike
   91411020
   add comment

6 Answers

   [32]active [33]oldest [34]votes
   up vote 7 down vote accepted

   Commodore Jaeger is right about:
dd if=/dev/sda of=/dev/sdb bs=1M

   Also, adjusting "readahead" on the drives usually improves performance. The default may be
   something like 256, and optimal 1024. Each setup is different, so you would have to run
   benchmarks to find the best value.
# blockdev --getra /dev/sda
256
# blockdev --setra 1024 /dev/sda
# blockdev --getra /dev/sda
1024
# blockdev --help
Usage:
  blockdev -V
  blockdev --report [devices]
  blockdev [-v|-q] commands devices
Available commands:
    --getsz (get size in 512-byte sectors)
    --setro (set read-only)
    --setrw (set read-write)
    --getro (get read-only)
    --getss (get sectorsize)
    --getbsz    (get blocksize)
    --setbsz BLOCKSIZE  (set blocksize)
    --getsize   (get 32-bit sector count)
    --getsize64 (get size in bytes)
    --setra READAHEAD   (set readahead)
    --getra (get readahead)
    --flushbufs (flush buffers)
    --rereadpt  (reread partition table)
    --rmpart PARTNO (disable partition)
    --rmparts   (disable all partitions)
#

   [35]share|[36]improve this answer
   answered Sep 11 '08 at 4:14
   [37]John Vasileff
   1,73711110

   Thank you... I didn't know this command. –  [38]Mike Sep 11 '08 at 14:12
   add comment
   up vote 5 down vote

   You might try increasing the block size using the bs argument; by default, I believe dd
   uses a block size equal to the disk's preferred block size, which will mean many more reads
   and writes to copy an entire disk. Linux's dd supports human-readable suffixes:
dd if=/dev/sda of=/dev/sdb bs=1M

   [39]share|[40]improve this answer
   answered Sep 10 '08 at 16:46
   [41]Commodore Jaeger
   10.6k23236
   add comment
   up vote 3 down vote

   The fastest for me:
dd if=/dev/sda bs=1M iflag=direct | dd of=/dev/sdb bs=1M oflag=direct

   reaches ~100MiB/s, whereas other options (single process, no direct, default 512b block
   size, ...) don't even reach 30MiB/s...

   To watch the progress, run in another console:
watch -n 60 killall -USR1 dd

   [42]share|[43]improve this answer
   answered Nov 6 '12 at 11:07
   [44]SteveMenard
   391

   Actually dd if=/dev/sda of=/dev/sdb bs=1M is fasted for me. –  [45]pevik Sep 21 '13 at
   11:09
   add comment
   up vote 1 down vote

   Maybe you can use two processes
dd if=indevfile | dd of=outdevfile

   I'll assume you can set the other dd options as it suits you. This has some overhead but
   should allow asynchrony between reading one disk and writing the other.
   [46]share|[47]improve this answer
   [48]edited Jul 19 '13 at 7:09
   [49]Steven Penny
   14.5k74184
   answered Sep 10 '08 at 16:43
   [50]Thomas Kammeyer
   2,563817
   add comment
   up vote 0 down vote

   Are you sure it isn't doing that at the same time? I would expect the disk caches to make
   sure it that happens. If not, non-blocking or even asynchronous reads/writes may help,
   [51]share|[52]improve this answer
   answered Sep 10 '08 at 16:45
   [53]Leon Timmermans
   22.2k24092

   I believe the read/write swap was occurring because of the sounds the disks were making. –
   [54]Mike Sep 10 '08 at 17:02
   add comment
   up vote 0 down vote

   About your update: How big are the caches of your HDs? (specially the writing one). It may
   be that that is too much and you may need to reduce it to prevent unnecessary blocking.
   [55]share|[56]improve this answer
   answered Sep 10 '08 at 16:56
   [57]Leon Timmermans
   22.2k24092

   I cannot remember the cache size of either disk. –  [58]Mike Sep 10 '08 at 17:00
   add comment



---
http://serverfault.com/questions/4906/using-dd-for-disk-cloning

[21]Using DD for disk cloning

   There's been a number of questions regarding disk cloning tools and dd has been suggested
   at least once. I've already considered using dd myself, mainly because ease of use, and
   that it's readily available on pretty much all bootable Linux distributions.

   What is the best way to use dd for cloning a disk? I did a quick Google search, and the
   first result was an apparent [23]failed attempt. Is there anything I need to do after using
   dd, i.e. is there anything that CAN'T be read using dd?
   [24]disk-cloning [25]dd
   [26]share|[27]improve this question
   [28]edited May 9 '12 at 23:57
   [29]Skyhawk
   11.5k22768
   asked May 5 '09 at 18:21
   [30]roe
   8741910

   I'm aware how dd works, my question was more in the direction of any known problems related
   to dd when cloning disks (as described by the link), maybe this wasn't very clear. What his
   answer contains and yours doesn't is "I've never once had any problems with it". I did
   upvote your answer too, as you did definitely present some interesting points (I like the
   one about no progress indication). –  [31]roe May 6 '09 at 20:25

   Looks like you got the Spolsky Bump: [32]joelonsoftware.com/items/2009/05/29.html –
   [33]Kyle Cronin May 29 '09 at 18:04

   didn't see this on here when I asked (and answered) a similar question on superuser -
   [34]superuser.com/questions/11453/… –  [35]warren Aug 31 '09 at 5:58
   add comment

25 Answers

   [36]active [37]oldest [38]votes
   up vote 82 down vote accepted

   dd is most certainly the best cloning tool, it will create a 100% replica simply by using
   the following command. I've never once had any problems with it.
dd if=/dev/sda of=/dev/sdb bs=32M

   Be aware that while cloning every byte, you should not use this on a drive or partition
   that is being used. Especially applications like databases can't cope with this very well
   and you might end up with corrupted data.
   [39]share|[40]improve this answer
   [41]edited Jul 19 '13 at 10:55
   [42]MKzero
   17010
   answered May 5 '09 at 18:31
   [43]Adam Gibbins
   4,68111631
   8
   Of course, as long as /dev/sdb is at least as large as /dev/sda... –  [44]Eddie May 5 '09
   at 21:09
   16
   add a "bs=100M conv=notrunc" and it's much faster in my experience. –  [45]Tim Williscroft
   May 6 '09 at 22:14
   7
   @Eddie - and of course the partition table will be copied too, so if sdb is larger you'll
   have unused space at the end. –  [46]Alnitak May 7 '09 at 8:41
   6
   notrunc means (according to the man page) : do not trunc the output file. I don't
   understand how it can be faster. You can follow the progression of the operation with : #
   dd if=/dev/sda of=/dev/sdb & pid=$! # kill -USR1 $pid; sleep 1; kill $pid –  [47]Manu May
   29 '09 at 19:09
   69
   just be very careful with the 'i' and 'o' letters... –  [48]bandi May 29 '09 at 21:52
   show 10 more comments
   up vote 58 down vote

   To save space, you can compress data produced by dd with gzip, e.g.:
dd if=/dev/hdb | gzip -c  > /image.img

   You can restore your disk with:
gunzip -c /image.img.gz | dd of=/dev/hdb

   To save even more space, defragment the drive/partition you wish to clone beforehand (if
   appropriate), then zero-out all the remaining unused space, making it easier for gzip to
   compress:
mkdir /mnt/hdb
mount /dev/hdb /mnt/hdb
dd if=/dev/zero of=/mnt/hdb/zero

   Wait a bit, dd will eventually fail with a "disk full" message, then:
rm /mnt/hdb/zero
umount /mnt/hdb
dd if=/dev/hdb | gzip -c  > /image.img

   Also, you can get a dd process running in the background to report status by sending it a
   signal with the kill command, e.g.:
dd if=/dev/hdb of=/image.img &
kill -SIGUSR1 1234

   Check your system - the above command is for Linux, OSX and BSD dd commands differ in the
   signals they accept (OSX uses SIGINFO - you can press Ctrl+T to report the status).
   [49]share|[50]improve this answer
   [51]edited Feb 7 '13 at 17:14
   [52]voretaq7♦
   57.4k1068139
   answered May 6 '09 at 22:47
   [53]David Hicks
   1,2701712
   2
   Does this also work with "modern" fs such a BTRFS, NILFS, [whatever you can dream of] ? –
   [54]Steve Schnepp Jun 26 '09 at 14:41

   DD works on block devices, a level of abstraction lower than the file system, so it should,
   yes. I haven't actually tried it, though. Hmm, NILFS looks interesting, I'll have to take a
   look at that. –  [55]David Hicks Jun 28 '09 at 22:47

   Sorry, just checked out NILFS' homepage and realised what you might have meant - can you
   use DD to copy a snapshot from a NILFS filesystem? I don't know, but it'd be interesting to
   find out. –  [56]David Hicks Jun 28 '09 at 23:01

   +1 for the kill -SIGUSR1 %1, and the OSX dd command happily accepts SIGUSR1... super
   useful, thanks! –  [57]stuartc Nov 3 '12 at 10:17

   +1 for Kill -SIGUSR1 1234 I was looking for that. –  [58]hot2use Dec 12 '12 at 13:17
   add comment
   up vote 32 down vote

   CAUTION: dd'ing a live filesystem can corrupt files. The reason is simple, it has no
   understanding of the filesystem activity that may be going on, and makes no attempt to
   mitigate it. If a write is partially underway, you will get a partial write. This is
   usually not good for things, and generally fatal for databases. Moreover, if you screw up
   the typo-prone if and of parameters, woe unto you. In most cases, rsync is an equally
   effective tool written after the advent of [59]multitasking, and will provide consistent
   views of individual files.

   However, DD should accurately capture the bit state of an unmounted drive. Bootloaders,
   llvm volumes, partition UUIDs and labels, etc. Just make sure that you have a drive capable
   of mirroring the target drive bit for bit.
   [60]share|[61]improve this answer
      [62]edited Mar 19 '10 at 21:12
   answered May 5 '09 at 20:20
   [63]jldugger
   6,95443489

   You can always use 'sync' to sync the file system to the hdd before running dd. –
   [64]LiraNuna Jul 17 '09 at 20:08
   5
   I suspect that sync is not the answer to file corruption problems. What happens if a deamon
   or something writes more files after the sync, during the dd operation? –  [65]Deleted Aug
   13 '09 at 10:47
   2
   It's a good idea to umount the drive first (or remount as read-only) but it's not always
   possible –  [66]Alex Bolotov Aug 22 '09 at 9:36

   In which case, you use rsync and let it do file handle magic to get a consistent file and
   let Copy On Write semantics handle the incoming writes. –  [67]jldugger Aug 22 '09 at 21:18
   2
   I'd like to add that running dd on a mounted filesystem WILL NOT CORRUPT the files on the
   mounted filesystem, but what is meant here is that the copy of the filesystem will
   necessarily be in a known good state. –  [68]3molo Apr 12 '13 at 10:11
   show 2 more comments
   up vote 15 down vote

   To clone a disk, all you really need to do is specify the input and output to dd:
dd if=/dev/hdb of=/image.img

   Of course, make sure that you have proper permissions to read directly from /dev/hdb (I'd
   recommend running as root), and that /dev/hdb isn't mounted (you don't want to copy while
   the disk is being changed - mounting as read-only is also acceptable). Once complete,
   image.img will be a byte-for-byte clone of the entire disk.

   There are a few drawbacks to using dd to clone disks. First, dd will copy your entire disk,
   even empty space, and if done on a large disk can result in an extremely large image file.
   Second, dd provides absolutely no progress indications, which can be frustrating because
   the copy takes a long time. Third, if you copy this image to other drives (again, using
   dd), they must be as large or larger than the original disk, yet you won't be able to use
   any additional space you may have on the target disk until you resize your partitions.

   You can also do a direct disk-to-disk copy:
dd if=/dev/hdb of=/dev/hdc

   but you're still subject to the above limitations regarding free space.

   As far as issues or gotchas go, dd, for the most part, does an excellent job. However, a
   while ago I had a hard drive that was about to die, so I used dd to try and copy what
   information I could off it before it died completely. It was then learned that dd doesn't
   handle read errors very well - there were several sectors on the disk that dd couldn't
   read, causing dd to give up and stop the copy. At the time I couldn't find a way to tell dd
   to continue despite encountering a read error (though [69]it appears as though it does have
   that setting), so I spent quite a bit of time manually specifying skip and seek to hop over
   the unreadable sections.

   I spent some time researching solutions to this problem (after I had completed the task)
   and I found a program called [70]ddrescue, which, according to the site, operates like dd
   but continues reading even if it encounters an error. I've never actually used the program,
   but it's worth considering, especially if the disk you're copying from is old, which can
   have bad sectors even if the system appears fine.
   [71]share|[72]improve this answer
      [73]edited May 30 '09 at 18:07
   answered May 5 '09 at 18:26
   [74]Kyle Cronin
   880824

   You can actually also use a read-only mount. A filesystem can be remounted with: mount -o
   remount,ro /path/to/device –  [75]Paul de Vrieze May 30 '09 at 15:11

   Good point, I added a note in my answer about that. –  [76]Kyle Cronin May 30 '09 at 18:07

   I used ddrescue to scrape data off a dying hard drive, and can confirm that it's awesome.
   –  [77]sleske Jun 23 '09 at 0:45
   4
   ...dd provides absolutely no progress indications... - well this is not true - there is
   kinda tricky way how to show progress - you have to find out pid of dd process ('ps -a |
   grep dd') and then send signal USR1 to this process - 'kill -USR1 <dd_pid_here>'(without
   <>) which force dd to show progress information. –  [78]Michal Bernhard Jun 19 '11 at 15:51
   2
   "several sectors on the disk that dd couldn't read": I think that conv=sync,noerror would
   help. –  [79]Gauthier Nov 30 '11 at 10:00
   show 2 more comments
   up vote 12 down vote

   When using dd to clone a disk which may contain bad sectors, use "conv=noerror,sync" to
   ensure that it doesn't stop when it encounters an error, and fills in the missing sector(s)
   with null bytes. This is usually the first step I take if trying to recover from a failed
   or failing disk -- get a copy before doing any recovery attempts, and then do recovery on
   the good (cloned) disk. I leave it to the recovery tool to cope with any blank sectors that
   couldn't be copied.

   Also, you may find dd's speed can be affected by the bs (block size) setting. I usually try
   bs=32768, but you might like to test it on your own systems to see what works the fastest
   for you. (This assumes that you don't need to use a specific block size for another reason,
   e.g. if you're writing to a tape.)
   [80]share|[81]improve this answer
   answered May 7 '09 at 2:42
   [82]TimB
   1,0401014
   6
   If you have a disk with bad sectors, you really should be using 'ddrescue' instead of dd.
   It's much more efficient, and has a much better chance of recovering more data. (Don't get
   it confused with dd_rescue, which is not as good) –  [83]davr Mar 19 '10 at 20:27
   add comment
   up vote 7 down vote

   If the source drive is damaged at all, you'll have more luck using [84]dd_rhelp with
   dd_rescue (my personal preference) or GNU [85]ddrescue.

   The reason behind this is that, on read errors, dd keeps trying and trying and trying -
   potentially waiting for a long time for timeouts to occur. dd_rescue does smart things like
   reading up to an error, then picking a spot further on on the disk and reading backwards to
   the last error, and dd_rhelp is basically a dd_rescue session manager - cleverly starting
   and resuming dd_rescue runs to make it quicker again.

   The end result of dd_rhelp is maximum data recovered in minimum time. If you leave dd_rhelp
   running, in the end it does the exact same job as dd in the same time. However, if dd
   encountered read errors at byte 100 of your 100Gb disk, you'd have to wait a long time to
   recover the other 9,999,900 bytes*, whereas dd_rhelp+dd_rescue would recover the bulk of
   the data much faster.
   [86]share|[87]improve this answer
   [88]edited Apr 12 '13 at 9:59
   [89]Tshepang
   292212
   answered May 31 '09 at 2:12
   [90]Ben Williams
   27919
   add comment
   up vote 6 down vote

   Another nice thing you can do with dd and rescue disks is copy data over the network:
remote_machine$ nc -l -p 12345

local_machine$ dd if=/dev/sda | nc remote_machine 12345

   You can stick gzip in both these pipelines if the network is not local. For progress, use
   pv. To make local_machine's netcat quit after it's done copying, you might add -w 5 or
   something.
   [91]share|[92]improve this answer
   answered May 29 '09 at 18:09
   [93]user5692
   791
   7
   This is not quite correct. The 'remote_machine' command is missing something, such as >
   disk_backup.img or |dd of=/dev/sdb or something else, depending on what you want to do. I'm
   guessing you don't want to dump a disk image to stdout. –  [94]davr Mar 19 '10 at 20:26

   And throw in gzip on both ends to further minimize the sent data. –  [95]3molo Apr 12 '13
   at 10:12
   add comment
   up vote 6 down vote

   The source disk must not have any mounted filesystems. As a user able to read the block
   device (root works), run 'dd if=/dev/sda ....'

   Now, one of the neat things here is that you're creating a stream of bytes... and you can
   do a lot with that: compress it, send it over the network, chunk it into smaller blobs,
   etc.

   For instance:
dd if=/dev/sda | ssh user@backupserver "cat > backup.img"

   But more powerfully:
dd if=/dev/sda | pv -c | gzip | ssh user@backupserver "split -b 2048m -d - backup-`hostname -s`.img.
gz"

   The above copies a compressed image of the source harddrive to a remote system, where it
   stores it in numbered 2G chunks using the source host's name while keeping you updated on
   progress.

   Note that depending on the size of disk, speed of cpu on source, speed of cpu on
   destination, speed of network, etc. You may want to skip compression, or do the compression
   on the remote side, or enable ssh's compression.
   [96]share|[97]improve this answer
      [98]edited May 29 '09 at 19:28
   answered May 29 '09 at 19:23
   [99]retracile
   1,13258

   +1 Piping through gzip can save a lot of time and bandwidth! –  [100]M. Dudley Sep 7 '11 at
   23:33

   I should also note that adding 'bs=1M' to the dd command will usually greatly improve
   speed. –  [101]retracile Jul 26 '12 at 14:11
   add comment
   up vote 4 down vote

   Keep in mind that dd makes an exact copy, including all the blank space.

   That means:
    1. 2nd drive must be at least as big as first
    2. If 2nd drive is larger, extra space will be wasted (filesystem can be expanded mind
       you)
    3. If the source drive is not full, dd will waste alot of time copying blank space.
    4. You can copy either the entire drive, or a single partition this way.
    5. If this is a bootable drive, I'm pretty sure you need to install the bootloader after
       using dd

   Hope that is helpful
   [102]share|[103]improve this answer
   answered May 5 '09 at 18:38
   [104]Brent
   9,83093275
   6
   If you're cloning the whole hard disk, you're also cloning the boot loader. –
   [105]Cristian Ciupitu May 29 '09 at 22:16

   welll, just a thouhgt, but couldn't u just use gparted to resive the partition/disk being
   copied down to whatever is used- then drop dd? Assuming it's a onetime image it should
   mitigate this issue. –  [106]bbqchickenrobot Mar 24 '12 at 19:40
   add comment
   up vote 4 down vote

   Another grand feature is copying MBRs, partition tables and boot records.

   Just
dd if=/dev/sda of=parttable bs=512 count=1

   and the other direction around when you're writing it. Polish with fdisk after.

   You feel much more safe when you have your partition table backed up.

   Also, it makes migrating to another hard drive (while changing partion structure) a joy.
   [107]share|[108]improve this answer
   answered May 29 '09 at 18:18
   [109]alamar
   1664
   add comment
   up vote 4 down vote

   To clone a disk, all you really need to do is specify the input and output to dd:
dd if=/dev/hdb of=hdb.img

   Of course, make sure that you have proper permissions to read directly from /dev/hdb (I'd
   recommend running as root), and that /dev/hdb isn't mounted (you don't want to copy while
   the disk is being changed). Once complete, hdb.img will be a byte-for-byte clone of the
   entire disk.

   There are a few drawbacks to using dd to clone disks. First, dd will copy your entire disk,
   even empty space, and if done on a large disk can result in an extremely large image file.
   Second, dd provides absolutely no progress indications, which can be frustrating because
   the copy takes a long time. Third, if you copy this image to other drives (again, using
   dd), they must be as large or larger than the original disk, yet you won't be able to use
   any additional space you may have on the target disk until you resize your partitions.

   You can also do a direct disk-to-disk copy:
dd if=/dev/hdb of=/dev/hdc

   but you're still subject to the above limitations regarding free space.

   The first drawback can be resolved by gzipping the data as you make the copy. For example:
dd if=/dev/hdb | gzip -9 > hdb.img.gz

   The second drawback can be resolved by using the pipeview (pv) tool. For example:
dd if=/dev/hdb | (pv -s `fdisk -l /dev/hdb | grep -o '[0-9]*\{1\} MB' | awk '{print $1}'`m) | cat >
hdb.img

   I know of no way to overcome the third drawback.

   Additionally, you can speed up the copy time by telling dd to work with larger chunks of
   data. For example:
dd if=/dev/hdb of=hdb.img bs=1024

   [110]share|[111]improve this answer
   answered May 29 '09 at 22:03
   [112]jsumners
   2502411

   You already told the way to overcome the third drawback...resize the partitions. Enlarging
   a partition is generally a safe and fast operation (versus shrinking or moving, which is
   slow and more dangerous since it's moving data around). –  [113]davr Mar 19 '10 at 20:28

   gzipping will not work with a disk that has been used for some time, as it will be filled
   with either current or deleted data. gzip will only work if the empty space is zero'ed,
   which is only the case with a brand new disk. –  [114]Tozz Feb 22 '12 at 20:51
   1
   @Tozz: You can improve the compressibility of a filesystem image by filling the filesystem
   with a file filled with 0's, syncing it to disk, then deleting it. dd if=/dev/zero bs=1M
   of=/balloon; sync; rm /balloon (Modulo extra intelligence in the filesystem layer.) –
   [115]retracile Jul 26 '12 at 14:15
   add comment
   up vote 3 down vote

   For future reference it might be of interest to check out [116]ddrescue. It has saved my
   day a couple of times.
   [117]share|[118]improve this answer
   answered May 6 '09 at 21:06
   [119]Anders Hansson
   17913
   add comment
   up vote 3 down vote

   This is kind of a cheap hack, but it's a quick and dirty way to monitor your DD process.

   Run your dd command. Open a new shell and do a ps awx to find your dd process' PID. Now in
   the new shell type watch -n 10 kill -USR1 {pid of your DD process}

   This will do nothing in the watch output window, but back in the original DD shell, DD will
   start outputting status reports every 10 seconds. You can change the -n 10 in the watch
   command to any other time frame of course.

   Tachyon
   [120]share|[121]improve this answer
   answered Jul 14 '09 at 20:13
   Tachyon

   OS X doesn't have watch available and -USR1 kills dd. The following command works though:
   while [ true ]; do killall -INFO dd; sleep 30; done –  [122]Adam Franco Aug 9 '11 at 23:04

   I don't think this is very practical for a novice, they may be better served with the pv
   command. –  [123]Robbie Mckennie Jul 19 '13 at 9:36
   add comment
   up vote 2 down vote

   dd does provide progress information - well most versions in linux. I've seen some which
   don't but don't recall the unix flavour.

   The man page says: Sending a USR1 signal to a running ‘dd’ process makes it print I/O
   statistics to standard error and then resume copying.

   I use this feature regularly.
   [124]share|[125]improve this answer
   answered May 29 '09 at 16:28
   [126]Steven
   2,398613

   While useful, i doubt its practicality for a beginner. –  [127]Robbie Mckennie Jul 19 '13
   at 9:34
   add comment
   up vote 2 down vote

   How to copy using dd (in this case to a remote machine, but the same principle applies to a
   local copy) which shows progress.

   It works by storing the pid via file descriptor 3 in /tmp/pid, which is then used for the
   subsequent kills with signal USR1. A wrinkle was to filter the output of the progress on
   stderr to only one line via filtering stderr through a subshell.
(dd bs=1M if=$lv-snapshot & echo $! >&3 ) 3>/tmp/pid  2> >(grep 'copied' 1>&2) | gzip --fast | ssh $
DEST "gzip -d | dd bs=1M of=$lv" &
# Need this sleep to give the above time to run
sleep 1
PID=$(</tmp/pid)

while kill -0 $PID; do
  kill -USR1 $PID
  sleep 5
done

   [128]share|[129]improve this answer
   answered Jul 31 '13 at 5:01
   [130]Edward Groenendaal
   313

   Not really relevant to the question, but its a neat shell trick using a sub-shell and high
   (higher than stderr) file descriptors to convey data out of it, +1 –  [131]roe Jul 31 '13
   at 6:10

   I was referring to this page myself for different dd options when cloning disks, so it
   seemed a suitable place at the time to put the end result of what I used for cloning,
   especially since I thought it was rather neat myself :) –  [132]Edward Groenendaal Jul 31
   '13 at 23:29
   add comment
   up vote 1 down vote

   You could actually try something like this
dd if=/dev/sda2 of=/dev/sdb2 bs=4096 conv=notrunc,noerror

   to skip all errors and have exact clone of a hard drive
   [133]share|[134]improve this answer
   [135]edited Jul 19 '13 at 9:27
   [136]Steven Penny
   14919
   answered Aug 22 '09 at 9:23
   hirol
   add comment
   up vote 0 down vote

   Someone had to say this: give Clonezilla a try (http:// clonezilla.org/)

   What do you get? To copy only used parts of the filesystem. Clonezilla uses dd, grub,
   sfdisk, parted, partimage, ntfsclone, and/or partclone. Depending on the options you
   choose.

   Decent documentation can be found at: http:// clonezilla.org/clonezilla-live/doc/
   [137]share|[138]improve this answer
   answered May 29 '09 at 16:53
   Roflo

   I found the documentation a little rough, and cloning a linux PATA drive to a SATA drive
   did Not leave me with something I could boot (yet). But much faster to same result as dd,
   and it worked great for my laptop drive upgrades. –  [139]jbdavid May 30 '09 at 0:43
   add comment
   up vote 0 down vote

   For some reason, dd fails when imaging CDs with audio tracks. You need to use cdrdao or
   something similar to get an image + TOC file.
   [140]share|[141]improve this answer
   answered May 29 '09 at 18:47
   [142]Matt
   1012
   add comment
   up vote 0 down vote

   A note on speed: in my experience dd is twice as fast if you specify bs=1024 instead of the
   default bs=512. Using an even larger block size gives no noticeable speedup over bs=1024.
   [143]share|[144]improve this answer
          answered May 29 '09 at 19:26
   3
   disk clusters are generally around 4k now, so using 4096 is probably a good option, and
   even 8192 if you want to read 2 clusters at a time. Don't go too big though, as you run
   into fragmented memory problems –  [145]user4767 May 29 '09 at 19:32
   add comment
   up vote 0 down vote

   One thing you must be aware of when dd-ing a full disk is that doing so will overwrite the
   master boot record of the receiving disk. This contains the partition table and other vital
   information. If the new disk is not the same as the old disk, this can create all sorts of
   tables. Copying over partitions is generally safer (and swap partitions do not have to be
   copied over)
   [146]share|[147]improve this answer
   answered May 30 '09 at 15:15
   [148]Paul de Vrieze
   1313
   add comment
   up vote 0 down vote

   I've been out of the admin role for many years now, but I know that 'dd' is up to the job.
   I used this technique regularly in the late 80s on Sun Sparc and 386i computers. I had one
   client order over 30 386i systems running CAD software that was distributed on multiple QIC
   tapes.

   We installed on the first computer, configured the app, ran SunOS' sys-unconfig, placed the
   drive in a shoebox with a different SCSI address and then proceeded to 'dd' to the other 30
   drives.
   [149]share|[150]improve this answer
   answered Jun 1 '09 at 11:23
   [151]pbrooks100
   1412
   add comment
   up vote 0 down vote

   As others have mentioned above, one of the gotchas with cloning a mounted file system is
   potential data corruption. This obviously won't apply to full drive clones, but if you're
   using LVM you can Snapshot the LogicalVolume and dd from the snapshot to get a consistent
   image.
   [152]share|[153]improve this answer
   answered Jun 2 '09 at 0:51
   [154]Ophidian
   1,710713
   add comment
   up vote 0 down vote

   You can create a compressed image file of the partition (or disk) on the fly using bzip2 or
   gzip instead of dd. This is nice for storing away images in removable media:
bzip2 -c /dev/sdaX >imagefile.bz2
or
gzip -c /dev/sdaX >imagefile.gz

   If the disk has been heavily used before, you can enhance the compression by filling all
   unused space with zeros before the imaging:
mkdir /mnt/mymountpoint
mount /dev/sdaX /mnt/mymountpoint
cat /dev/zero >/mnt/mymountpoint/dummyfile.bin
(Wait for it to end with a "disk full" error)
rm /mnt/mymountpoint/dummyfile.bin
umount /mnt/mymountpoint

   To restore the image into another disk, all you have to do is:
bzcat imagefile.bz2 >/dev/sdbY
or
zcat imagefile.gz >/dev/sdbY

   [155]share|[156]improve this answer
   answered Jun 26 '09 at 14:37
   [157]JCCyC
   329416

   Upvoted for the trick to fill remaining space with zeroes. Smart! –  [158]Confusion Jun 12
   '12 at 20:18
   add comment
   up vote 0 down vote

   For NTFS volumes, I prefer using [159]ntfsclone. It's part of the [160]ntfsprogs package.
   [161]share|[162]improve this answer
       [163]edited Jul 17 '09 at 18:24
   answered Jun 2 '09 at 0:35
   [164]Ed Brannin
   1115
   add comment
   up vote 0 down vote

   Just a warning to beginners that needs to be said: At least with some Versions, bs=X means
   that memory to the size of X will literally be allocated. bs=2GB on a system with 1GB of
   RAM and insufficient swap WILL cause bad things to happen.
   [165]share|[166]improve this answer
   answered May 9 '12 at 23:47
   [167]rackandboneman
   1,71716
   add comment

protected by [168]Jeff Atwood♦ Jun 8 '10 at 5:46

   This question is protected to prevent "thanks!", "me too!", or spam answers by new users.
   To answer it, you must have earned at least 10 [169]reputation on this site.

Not the answer you're looking for? Browse other questions tagged [170]disk-cloning [171]dd or
[172]ask your own question.
