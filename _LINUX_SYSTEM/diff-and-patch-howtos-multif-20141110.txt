filename: diff-and-patch-howtos-multif_20141110.txt
http://jungels.net/articles/diff-patch-ten-minutes.html

The Ten Minute Guide to diff and patch

   Situation one: you are trying to compile a package from source and you discover that
   somebody has already done the work for you of modifying it slightly to compile on your
   system. They have made their work available as a "patch", but you're not sure how to make
   use of it. The answer is that you apply the patch to the original source code with a
   command line tool called, appropriately, patch.

   Situation two: you have downloaded the source code to an open source package and after an
   hour or so of minor edits, you manage to make it compile on your system. You would like to
   make your work available to other programmers, or to the authors of the package, without
   redistributing the entire modified package. Now you are in a situation where you need to
   create a patch of your own, and the tool you need is diff.

   This is a quick guide to diff and patch which will help you in these situations by
   describing the tools as they are most commonly used. It tells you enough to get started
   right away. Later, you can learn the ins and outs of diff and patch at your leisure, using
   the man pages.

Applying patches with patch

   To apply a patch to a single file, change to the directory where the file is located and
   call patch:
patch < foo.patch

   These instructions assume the patch is distributed in unified format, which identifies the
   file the patch should be applied to. If not, you can specify the file on the command line:
patch foo.txt < bar.patch

   Applying patches to entire directories (perhaps the more common case) is similar, but you
   have to be careful about setting a "p level". What this means is that, within patch files,
   the files to be patched are identified by path names which may be different now that the
   files are located on your computer rather than on the computer where the patch was created.
   The p level instructs patch to ignore parts of the path name so that it can identify the
   files correctly. Most often a p level of one will work, so you use:
patch -p1 < baz.patch

   You should change to the top level source directory before running this command. If a patch
   level of one does not correctly identify any files to patch, inspect the patch file for
   file names. If you see a name like
/users/stephen/package/src/net/http.c

   and you are working in a directory that contains net/http.c, use
patch -p5 < baz.patch

   In general, count up one for each path separator (slash character) that you remove from the
   beginning of the path, until what's left is a path that exists in your working directory.
   The count you reach is the p level.

   To remove a patch, use the -R flag, ie
patch -p5 -R < baz.patch

Creating patches with diff

   Using diff is simple whether you are working with single files or entire source
   directories. To create a patch for a single file, use the form:
diff -u original.c new.c > original.patch

   To create a patch for an entire source tree, make a copy of the tree:
cp -R original new

   Make any changes required in the directory new/. Then create a patch with the following
   command:
diff -rupN original/ new/ > original.patch

   That's all you need to get started with diff and patch. For more information use:
man diff
man patch



---
http://linux.byexamples.com/archives/163/how-to-create-patch-file-using-patch-and-diff/

How to create patch file using patch and diff

   November 23rd, 2006 mysurface Posted in [9]Developer, [10]diff, [11]Misc, [12]patch | Hits:
   336404 | [13]15 Comments »

   Okay, this is what I do. I only know the basic. But before doing this, please backup your
   source code, patch wrongly will screwup your source code.

   First, how to create patch file?
   Patch file is a readable file that created by diff with -c (context output format). It
   doesn’t matter and if you wanna know more, man diff. To patch the entire folder of source
   codes(as usually people do)I do as bellow:

   Assume Original source code at folder Tb01, and latest source code at folder Tb02. And
   there have multiple sub directories at Tb01 and Tb02 too.
diff -crB Tb01 Tb02 > Tb02.patch

   -c context, -r recursive (multiple levels dir), -B is to ignore Blank Lines.
   I put -B because blank lines is really useless for patching, sometimes I need to manually
   read the patch file to track the changes, without -B is really headache.

   How to patch?
   First of all, please do a dry-run before really patch it. Bare in mind, patch will be
   working very specifically. Let say the version 3 Tb03.patch is use to patch from Tb02, if
   you apply patch on Tb01, sometimes it will corrupt your source code. So, to make sure it
   works, do a dry run. Dry-run means a fake-test, do it at the directory of the source code
   targeted to patch.

   Doing dry-run like this:
patch --dry-run -p1 -i Tb02.patch

   The success output looks like this:
patching file TbApi.cpp
patching file TbApi.h
patching file TbCard.cpp
...

   The failure ouptut looks like this:
patching file TbCard.cpp
Hunk #2 FAILED at 585.
1 out of 2 hunks FAILED -- saving rejects to file TbCard.cpp.rej
patching file TbCard.h
Hunk #1 FAILED at 57.
Hunk #2 FAILED at 77.
Hunk #3 succeeded at 83 with fuzz 1 (offset -21 lines).
....

   At last, if the dry-run is giving good result, do this and enjoy the compilation.
patch -p1 -i Tb02.patch

15 Responses to “How to create patch file using patch and diff”

    1. [19]compare files and edit simultaneously with vimdiff » Linux by Examples Says:
       [20]November 24th, 2006 at 1:16 am
       [...] Refers to How to create patch file using patch and diff, you can actually read
       the diff file to compare the different between files. But what if you wanna compare and
       edit simultaneously manually? [...]
    2. [21]mumblyjoe Says:
       [22]March 28th, 2009 at 2:13 am
       Useful example, thanks. There are two things I would add – first, before running patch,
       cd into the new directory (the one to be patched). That’s how the command knows which
       tree to modify.
       diff -crB Tb01 Tb02 > Tb02.patch
       cp -r Tb01 Tb03
       cd Tb03
       patch –dry-run -p1 -i ../Tb02.patch
       Second, if there were files in Tb02 that did not exist in Tb01 and you want them
       included in the patch, give diff the -N option:
       diff -crBN Tb01 Tb02 > Tb02.patch
       Lastly, I’d note that diff and patch really only work with text files. It can’t deal
       with jpegs, pdfs, or other binary objects. This can be a bit of a pain for web and GUI
       developers.
    3. gg2laba Says:
       [23]July 16th, 2009 at 2:41 am
       thanks for exemple,
       mumblyjoe Says: There are two things I would add – first, before running patch, cd into
       the new directory (the one to be patched)
       thanks for adding.
    4. arun Says:
       [24]November 16th, 2009 at 2:30 pm
       Hi..it is really a valuable information. I would like to know, will the patch command
       create a directory?
       or do we have an option for creating a directory?
    5. [25]Mohit P. Tahiliani Says:
       [26]May 11th, 2010 at 3:55 pm
       The examlpe is very clear and is very helpful.
       Thank you!
    6. Andrea Says:
       [27]July 30th, 2010 at 4:35 pm
       thank you!very useful!
    7. Shashi Says:
       [28]January 26th, 2011 at 1:36 am
       Thanks for useful tutorial…
    8. [29]Sang Weyman Says:
       [30]January 30th, 2011 at 5:15 am
       Good stuff really liked this :)
    9. [31]best quality backlinks Says:
       [32]August 9th, 2011 at 5:56 am
       great points altogether, you just received emblem reader. What may you recommend in
       regards to your post that you just made some days ago? Any positive?
   10. basanth Says:
       [33]October 20th, 2011 at 3:32 pm
       good example
   11. [34]how to include a new file into a patch | MoVn - Linux Ubuntu Center Says:
       [35]April 26th, 2012 at 1:09 am
       [...] try to make a patch as introduced here. Say I have two directories pp1(modified
       version) and pp0(clean version), I make a patch file [...]
   12. Zoidberg Says:
       [36]October 27th, 2012 at 6:55 am
       I like:
       diff -u
       it is nicer :-)
   13. [37]Some things in Windows are nice. - Page 2 Says:
       [38]January 1st, 2013 at 4:09 pm
       [...] read here can help make one better than what EXE can do. To create your own patch
       file learn it from here. There is no way M$ can beat gnu/linux/*nix/bsd on matters like
       this one simple lipstick painting. [...]
   14. Amir Says:
       [39]April 18th, 2013 at 2:02 am
       Perfect and simple
       Thank you
   15. [40]PATCH AND DIFF | helpadeveloper Says:
       [41]June 12th, 2014 at 8:42 pm
       [...] How to create patch file using patch and diff [...]



---
http://www.scottro.net/qnd/qnd-diff-patch

Quick-n-Dirty Guide to Creating and Applying diff-style Patches

1) DO YOU HAVE DIFF AND PATCH?
------------------------------

In a shell, type:

which diff
which patch

This should return the paths to diff and patch, probably /usr/bin/diff
and /usr/bin/patch, respectively. If it finds them, continue to Step
2. If it does not, you have a serious problem, as diff and patch are
two of the most fundamental utilities in a Unix system. Hopefully,
your $PATH environment variable just does not contain the proper paths
to the binaries. Try typing in a shell:

for i in /bin /usr/bin /usr/local; do
    find $i -name diff
    find $i name patch
done

If this returns a full path to diff and patch, note that path, then
add it to your $PATH by typing:

export PATH=$PATH:diff_path:patch_path

where diff_path is the path to the diff binary (take the /diff off
the end of what the find command reported for diff) and patch_path
is the path to the patch binary (take the /patch off the end of what
the find command reported for patch). Now, repeat this step, and the
'which' commands should find both diff and patch. If they do, continue
to Step 2. If not, try contacting your local LUG for help. *** Link to
the Help Me! QND ***


2) CREATING PATCHES WITH DIFF
-----------------------------

In a shell, change to the directory where the file you wish to make a
patch for is located. Copy the original file (before your edits) to
the same directory (you *did* make a backup copy of it before you
edited it, right?). Now, type in the shell:

diff -uN original_file new_file >patch.original_file

where original_file is the filename of the original file and new_file
is the filename of the new file (the one containing your edits).

This technique also works for creating a patch for a whole directory
tree (e.g. creating a Linux kernel patch). Just add the -r flag to
your diff command:

diff -uNr original_dir new_dir >patch.original_dir

Here is a concrete example of creating a patch against the vanilla
Linux kernel's source tree:

cd /usr/src
diff -uNr linux-2.4.19 linux-2.4.19-my_version \
          >patch.linux-2.4.19-my_version

That is all there is to creating patches with diff. Move on to Step 3
to see how to apply them with patch.


3) APPLYING PATCHES WITH PATCH
------------------------------

Copy the patch that you generated in Step 2 to the directory
containing the file to which you want to apply the patch. Now, type in
your shell:

patch <patch_file

where patch_file is the filename of the patch file. Note that the
filename of the file to be patched must be the same as it was in Step
2.

If you want to apply a patch to a whole directory tree, add a -p1 to
your patch command:

patch -p1 <patch_file

Here is a concrete example of applying a patch to your Linux kernel
source tree:

cd /usr/src
patch -p1 <patch.linux-2.4.19-my_version

Congratulations, you are finished.



---
http://linux.about.com/od/commands/l/blcmdl1_patch.htm

NAME

   patch - apply a diff file to an original

SYNOPSIS

   patch [options] [originalfile [patchfile]]

   but usually just

   patch -pnum <patchfile

DESCRIPTION

   patch takes a patch file patchfile containing a difference listing produced by the diff
   program and applies those differences to one or more original files, producing patched
   versions. Normally the patched versions are put in place of the originals. Backups can be
   made; see the -b or --backup option. The names of the files to be patched are usually taken
   from the patch file, but if there's just one file to be patched it can specified on the
   command line as originalfile.

   Upon startup, patch attempts to determine the type of the diff listing, unless overruled by
   a -c (--context), -e (--ed), -n (--normal), or -u (--unified) option. Context diffs
   (old-style, new-style, and unified) and normal diffs are applied by the patch program
   itself, while ed diffs are simply fed to the [17]ed(1) editor via a pipe.

   patch tries to skip any leading garbage, apply the diff, and then skip any trailing
   garbage. Thus you could feed an article or message containing a diff listing to patch, and
   it should work. If the entire diff is indented by a consistent amount, or if a context diff
   contains lines ending in CRLF or is encapsulated one or more times by prepending "- " to
   lines starting with "-" as specified by Internet RFC 934, this is taken into account.

   With context diffs, and to a lesser extent with normal diffs, patch can detect when the
   line numbers mentioned in the patch are incorrect, and attempts to find the correct place
   to apply each hunk of the patch. As a first guess, it takes the line number mentioned for
   the hunk, plus or minus any offset used in applying the previous hunk. If that is not the
   correct place, patch scans both forwards and backwards for a set of lines matching the
   context given in the hunk. First patch looks for a place where all lines of the context
   match. If no such place is found, and it's a context diff, and the maximum fuzz factor is
   set to 1 or more, then another scan takes place ignoring the first and last line of
   context. If that fails, and the maximum fuzz factor is set to 2 or more, the first two and
   last two lines of context are ignored, and another scan is made. (The default maximum fuzz
   factor is 2.) If patch cannot find a place to install that hunk of the patch, it puts the
   hunk out to a reject file, which normally is the name of the output file plus a .rej
   suffix, or # if .rej would generate a file name that is too long (if even appending the
   single character # makes the file name too long, then # replaces the file name's last
   character). (The rejected hunk comes out in ordinary context diff form regardless of the
   input patch's form. If the input was a normal diff, many of the contexts are simply null.)
   The line numbers on the hunks in the reject file may be different than in the patch file:
   they reflect the approximate location patch thinks the failed hunks belong in the new file
   rather than the old one.

   As each hunk is completed, you are told if the hunk failed, and if so which line (in the
   new file) patch thought the hunk should go on. If the hunk is installed at a different line
   from the line number specified in the diff you are told the offset. A single large offset
   may indicate that a hunk was installed in the wrong place. You are also told if a fuzz
   factor was used to make the match, in which case you should also be slightly suspicious. If
   the --verbose option is given, you are also told about hunks that match exactly.

   If no original file origfile is specified on the command line, patch tries to figure out
   from the leading garbage what the name of the file to edit is, using the following rules.

   First, patch takes an ordered list of candidate file names as follows:
   *
          If the header is that of a context diff, patch takes the old and new file names in
          the header. A name is ignored if it does not have enough slashes to satisfy the
          -pnum or --strip=num option. The name /dev/null is also ignored.
   *
          If there is an Index: line in the leading garbage and if either the old and new
          names are both absent or if patch is conforming to POSIX, patch takes the name in
          the Index: line.
   *
          For the purpose of the following rules, the candidate file names are considered to
          be in the order (old, new, index), regardless of the order that they appear in the
          header.

   Then patch selects a file name from the candidate list as follows:
   *
          If some of the named files exist, patch selects the first name if conforming to
          POSIX, and the best name otherwise.
   *
          If patch is not ignoring RCS, ClearCase, and SCCS (see the -g num or --get=num
          option), and no named files exist but an RCS, ClearCase, or SCCS master is found,
          patch selects the first named file with an RCS, ClearCase, or SCCS master.
   *
          If no named files exist, no RCS, ClearCase, or SCCS master was found, some names are
          given, patch is not conforming to POSIX, and the patch appears to create a file,
          patch selects the best name requiring the creation of the fewest directories.
   *
          If no file name results from the above heuristics, you are asked for the name of the
          file to patch, and patch selects that name.

   To determine the best of a nonempty list of file names, patch first takes all the names
   with the fewest path name components; of those, it then takes all the names with the
   shortest basename; of those, it then takes all the shortest names; finally, it takes the
   first remaining name.

   Additionally, if the leading garbage contains a Prereq: line, patch takes the first word
   from the prerequisites line (normally a version number) and checks the original file to see
   if that word can be found. If not, patch asks for confirmation before proceeding.

   The upshot of all this is that you should be able to say, while in a news interface,
   something like the following:

   | patch -d /usr/src/local/blurfl

   and patch a file in the blurfl directory directly from the article containing the patch.

   If the patch file contains more than one patch, patch tries to apply each of them as if
   they came from separate patch files. This means, among other things, that it is assumed
   that the name of the file to patch must be determined for each diff listing, and that the
   garbage before each diff listing contains interesting things such as file names and
   revision level, as mentioned previously.

OPTIONS

   -b or --backup
          Make backup files. That is, when patching a file, rename or copy the original
          instead of removing it. When backing up a file that does not exist, an empty,
          unreadable backup file is created as a placeholder to represent the nonexistent
          file. See the -V or --version-control option for details about how backup file names
          are determined.
   --backup-if-mismatch
          Back up a file if the patch does not match the file exactly and if backups are not
          otherwise requested. This is the default unless patch is conforming to POSIX.
   --no-backup-if-mismatch
          Do not back up a file if the patch does not match the file exactly and if backups
          are not otherwise requested. This is the default if patch is conforming to POSIX.
   -B pref or --prefix=pref
          Prefix pref to a file name when generating its simple backup file name. For example,
          with -B /junk/ the simple backup file name for src/patch/util.c is
          /junk/src/patch/util.c.
   --binary
          Read and write all files in binary mode, except for standard output and /dev/tty.
          This option has no effect on POSIX-conforming systems. On systems like DOS where
          this option makes a difference, the patch should be generated by diff -a --binary.
   -c or --context
          Interpret the patch file as a ordinary context diff.
   -d dir or --directory=dir
          Change to the directory dir immediately, before doing anything else.
   -D define or --ifdef=define
          Use the #ifdef ... #endif construct to mark changes, with define as the
          differentiating symbol.
   --dry-run
          Print the results of applying the patches without actually changing any files.
   -e or --ed
          Interpret the patch file as an ed script.
   -E or --remove-empty-files
          Remove output files that are empty after the patches have been applied. Normally
          this option is unnecessary, since patch can examine the time stamps on the header to
          determine whether a file should exist after patching. However, if the input is not a
          context diff or if patch is conforming to POSIX, patch does not remove empty patched
          files unless this option is given. When patch removes a file, it also attempts to
          remove any empty ancestor directories.
   -f or --force
          Assume that the user knows exactly what he or she is doing, and do not ask any
          questions. Skip patches whose headers do not say which file is to be patched; patch
          files even though they have the wrong version for the Prereq: line in the patch; and
          assume that patches are not reversed even if they look like they are. This option
          does not suppress commentary; use -s for that.
   -F num or --fuzz=num
          Set the maximum fuzz factor. This option only applies to diffs that have context,
          and causes patch to ignore up to that many lines in looking for places to install a
          hunk. Note that a larger fuzz factor increases the odds of a faulty patch. The
          default fuzz factor is 2, and it may not be set to more than the number of lines of
          context in the context diff, ordinarily 3.
   -g num or --get=num
          This option controls patch's actions when a file is under RCS or SCCS control, and
          does not exist or is read-only and matches the default version, or when a file is
          under ClearCase control and does not exist. If num is positive, patch gets (or
          checks out) the file from the revision control system; if zero, patch ignores RCS,
          ClearCase, and SCCS and does not get the file; and if negative, patch asks the user
          whether to get the file. The default value of this option is given by the value of
          the PATCH_GET environment variable if it is set; if not, the default value is zero
          if patch is conforming to POSIX, negative otherwise.
   --help
          Print a summary of options and exit.
   -i patchfile or --input=patchfile
          Read the patch from patchfile. If patchfile is -, read from standard input, the
          default.
   -l or --ignore-whitespace
          Match patterns loosely, in case tabs or spaces have been munged in your files. Any
          sequence of one or more blanks in the patch file matches any sequence in the
          original file, and sequences of blanks at the ends of lines are ignored. Normal
          characters must still match exactly. Each line of the context must still match a
          line in the original file.
   -n or --normal
          Interpret the patch file as a normal diff.
   -N or --forward
          Ignore patches that seem to be reversed or already applied. See also -R.
   -o outfile or --output=outfile
          Send output to outfile instead of patching files in place.
   -pnum or --strip=num
          Strip the smallest prefix containing num leading slashes from each file name found
          in the patch file. A sequence of one or more adjacent slashes is counted as a single
          slash. This controls how file names found in the patch file are treated, in case you
          keep your files in a different directory than the person who sent out the patch. For
          example, supposing the file name in the patch file was
          /u/howard/src/blurfl/blurfl.c
          setting -p0 gives the entire file name unmodified, -p1 gives
          u/howard/src/blurfl/blurfl.c
          without the leading slash, -p4 gives
          blurfl/blurfl.c
          and not specifying -p at all just gives you blurfl.c. Whatever you end up with is
          looked for either in the current directory, or the directory specified by the -d
          option.
   --posix
          Conform more strictly to the POSIX standard, as follows.
             *
                    Take the first existing file from the list (old, new, index) when
                    intuiting file names from diff headers.
             *
                    Do not remove files that are empty after patching.
             *
                    Do not ask whether to get files from RCS, ClearCase, or SCCS.
             *
                    Require that all options precede the files in the command line.
             *
                    Do not backup files when there is a mismatch.
   --quoting-style=word
          Use style word to quote output names. The word should be one of the following:
             literal
                    Output names as-is.
             shell
                    Quote names for the shell if they contain shell metacharacters or would
                    cause ambiguous output.
             shell-always
                    Quote names for the shell, even if they would normally not require
                    quoting.
             c
                    Quote names as for a C language string.
             escape
                    Quote as with c except omit the surrounding double-quote characters.
               You can specify the default value of the --quoting-style option with the
               environment variable QUOTING_STYLE. If that environment variable is not set,
               the default value is shell.
   -r rejectfile or --reject-file=rejectfile
          Put rejects into rejectfile instead of the default .rej file.
   -R or --reverse
          Assume that this patch was created with the old and new files swapped. (Yes, I'm
          afraid that does happen occasionally, human nature being what it is.) patch attempts
          to swap each hunk around before applying it. Rejects come out in the swapped format.
          The -R option does not work with ed diff scripts because there is too little
          information to reconstruct the reverse operation.
          If the first hunk of a patch fails, patch reverses the hunk to see if it can be
          applied that way. If it can, you are asked if you want to have the -R option set. If
          it can't, the patch continues to be applied normally. (Note: this method cannot
          detect a reversed patch if it is a normal diff and if the first command is an append
          (i.e. it should have been a delete) since appends always succeed, due to the fact
          that a null context matches anywhere. Luckily, most patches add or change lines
          rather than delete them, so most reversed normal diffs begin with a delete, which
          fails, triggering the heuristic.)
   -s or --silent or --quiet
          Work silently, unless an error occurs.
   -t or --batch
          Suppress questions like -f, but make some different assumptions: skip patches whose
          headers do not contain file names (the same as -f); skip patches for which the file
          has the wrong version for the Prereq: line in the patch; and assume that patches are
          reversed if they look like they are.
   -T or --set-time
          Set the modification and access times of patched files from time stamps given in
          context diff headers, assuming that the context diff headers use local time. This
          option is not recommended, because patches using local time cannot easily be used by
          people in other time zones, and because local time stamps are ambiguous when local
          clocks move backwards during daylight-saving time adjustments. Instead of using this
          option, generate patches with UTC and use the -Z or --set-utc option instead.
   -u or --unified
          Interpret the patch file as a unified context diff.
   -v or --version
          Print out patch's revision header and patch level, and exit.
   -V method or --version-control=method
          Use method to determine backup file names. The method can also be given by the
          PATCH_VERSION_CONTROL (or, if that's not set, the VERSION_CONTROL) environment
          variable, which is overridden by this option. The method does not affect whether
          backup files are made; it affects only the names of any backup files that are made.
          The value of method is like the GNU Emacs `version-control' variable; patch also
          recognizes synonyms that are more descriptive. The valid values for method are
          (unique abbreviations are accepted):
             existing or nil
                    Make numbered backups of files that already have them, otherwise simple
                    backups. This is the default.
             numbered or t
                    Make numbered backups. The numbered backup file name for F is F.~N~ where
                    N is the version number.
             simple or never
                    Make simple backups. The -B or --prefix, -Y or --basename-prefix, and -z
                    or --suffix options specify the simple backup file name. If none of these
                    options are given, then a simple backup suffix is used; it is the value of
                    the SIMPLE_BACKUP_SUFFIX environment variable if set, and is .orig
                    otherwise.
               With numbered or simple backups, if the backup file name is too long, the
               backup suffix ~ is used instead; if even appending ~ would make the name too
               long, then ~ replaces the last character of the file name.
   --verbose
          Output extra information about the work being done.
   -x num or --debug=num
          Set internal debugging flags of interest only to patch patchers.
   -Y pref or --basename-prefix=pref
          Prefix pref to the basename of a file name when generating its simple backup file
          name. For example, with -Y .del/ the simple backup file name for src/patch/util.c is
          src/patch/.del/util.c.
   -z suffix or --suffix=suffix
          Use suffix as the simple backup suffix. For example, with -z - the simple backup
          file name for src/patch/util.c is src/patch/util.c-. The backup suffix may also be
          specified by the SIMPLE_BACKUP_SUFFIX environment variable, which is overridden by
          this option.
   -Z or --set-utc
          Set the modification and access times of patched files from time stamps given in
          context diff headers, assuming that the context diff headers use Coordinated
          Universal Time (UTC, often known as GMT). Also see the -T or --set-time option.
          The -Z or --set-utc and -T or --set-time options normally refrain from setting a
          file's time if the file's original time does not match the time given in the patch
          header, or if its contents do not match the patch exactly. However, if the -f or
          --force option is given, the file time is set regardless.
          Due to the limitations of diff output format, these options cannot update the times
          of files whose contents have not changed. Also, if you use these options, you should
          remove (e.g. with make clean) all files that depend on the patched files, so that
          later invocations of make do not get confused by the patched files' times.

SEE ALSO

   [18]diff(1), [19]ed(1)

   Marshall T. Rose and Einar A. Stefferud, Proposed Standard for Message Encapsulation,
   Internet RFC 934 <URL:<A
   HREF="ftp://ftp.isi.edu/in-notes/rfc934.txt">ftp://ftp.isi.edu/in-notes/rfc934.txt
   > (1985-01).

NOTES FOR PATCH SENDERS

   There are several things you should bear in mind if you are going to be sending out
   patches.

   Create your patch systematically. A good method is the command diff -Naur old new where old
   and new identify the old and new directories. The names old and new should not contain any
   slashes. The diff command's headers should have dates and times in Universal Time using
   traditional Unix format, so that patch recipients can use the -Z or --set-utc option. Here
   is an example command, using Bourne shell syntax:

   LC_ALL=C TZ=UTC0 diff -Naur gcc-2.7 gcc-2.8

   Tell your recipients how to apply the patch by telling them which directory to cd to, and
   which patch options to use. The option string -Np1 is recommended. Test your procedure by
   pretending to be a recipient and applying your patch to a copy of the original files.

   You can save people a lot of grief by keeping a patchlevel.h file which is patched to
   increment the patch level as the first diff in the patch file you send out. If you put a
   Prereq: line in with the patch, it won't let them apply patches out of order without some
   warning.

   You can create a file by sending out a diff that compares /dev/null or an empty file dated
   the Epoch (1970-01-01 00:00:00 UTC) to the file you want to create. This only works if the
   file you want to create doesn't exist already in the target directory. Conversely, you can
   remove a file by sending out a context diff that compares the file to be deleted with an
   empty file dated the Epoch. The file will be removed unless patch is conforming to POSIX
   and the -E or --remove-empty-files option is not given. An easy way to generate patches
   that create and remove files is to use GNU diff's -N or --new-file option.

   If the recipient is supposed to use the -pN option, do not send output that looks like
   this:

   diff -Naur v2.0.29/prog/README prog/README
   --- v2.0.29/prog/README Mon Mar 10 15:13:12 1997
   +++ prog/README Mon Mar 17 14:58:22 1997

   because the two file names have different numbers of slashes, and different versions of
   patch interpret the file names differently. To avoid confusion, send output that looks like
   this instead:

   diff -Naur v2.0.29/prog/README v2.0.30/prog/README
   --- v2.0.29/prog/README Mon Mar 10 15:13:12 1997
   +++ v2.0.30/prog/README Mon Mar 17 14:58:22 1997

   Avoid sending patches that compare backup file names like README.orig, since this might
   confuse patch into patching a backup file instead of the real file. Instead, send patches
   that compare the same base file names in different directories, e.g. old/README and
   new/README.

   Take care not to send out reversed patches, since it makes people wonder whether they
   already applied the patch.

   Try not to have your patch modify derived files (e.g. the file configure where there is a
   line configure: configure.in in your makefile), since the recipient should be able to
   regenerate the derived files anyway. If you must send diffs of derived files, generate the
   diffs using UTC, have the recipients apply the patch with the -Z or --set-utc option, and
   have them remove any unpatched files that depend on patched files (e.g. with make clean).

   While you may be able to get away with putting 582 diff listings into one file, it may be
   wiser to group related patches into separate files in case something goes haywire.



---
http://cocoon.apache.org/2.0/howto/howto-patch.html

   A "Patch" is the set of differences between two versions of the same file. Patches are used
   to send someone the exact changes that you have made to your version of a program or a
   document. They can then apply that patch to their version to merge the changes and bring
   their version up-to-date with your version.

   As our example we use the contribution of a simple documentation patch for the Apache
   Cocoon project. The principles apply to any project and to any type of file, e.g. *.xml,
   *.java, *.txt

   Our example describes the use of command-line tools for a UNIX system. Other tools can be
   used, as long as they produce a "unified diff"

   Here is how to proceed.
   1. Understand what a patch is

   A "Patch" is the set of differences between two versions of the same file. A patch
   comprises one or more "diff" files. These diffs are produced by the program of the same
   name: diff.

   Here is an example of a single diff for the Cocoon Contribution page, where we are
   suggesting a minor text change. Do not get frightened. These are just human-readable
   instructions to the "patch" program.

                                [void.gif] [void.gif] [void.gif]
   [void.gif]
Index: contrib.xml
===================================================================
RCS file: /home/cvspublic/cocoon-2.0/src/documentation/xdocs/contrib.xml,v
retrieving revision 1.7
diff -u -r1.7 contrib.xml
--- contrib.xml 30 Apr 2002 07:44:52 -0000      1.7
+++ contrib.xml 26 May 2002 04:08:23 -0000
@@ -208,7 +208,7 @@
    to create a patch. (The commands are for Linux.)
   </p>

- <s2 title="How to Establish your Local Repository">
+ <s2 title="How to Establish your Local Working Copy">

   <p>
    This will checkout the current copy of the master cvs repository and

                                [void.gif]
                                [void.gif] [void.gif] [void.gif]

   That is a "unified diff" ... there a some lines of context on each side of the changes.
   This patch is basically saying "Change the text on line 208".

     * lines to be deleted are preceded with -
     * lines to be added are preceded with +
     * contextual lines with no leader remain the same

   2. Modify your document and ensure consistency

   Let us now go though the process of preparing that patch. Go ahead and edit your local copy
   of the document at $COCOON_HOME/src/documentation/xdocs/contrib.xml

   Ensure that it is valid XML using your favourite XML editor or an external validating
   parser. Please do not leave it up to the poor committer to fix broken XML.

   Run build docs to be sure that links are not broken and that the new document is presented
   as you intend it to be.
   3. Get ready

   If you are using the HEAD of CVS then ensure that your working copy is up-to-date. Of
   course, if you are using a previous public release version of Cocoon, then it is already
   up-to-date.
   4. Generate the differences

   Prepare the diff file. CVS will contact the remote repository, ensure that your working
   copy is up-to-date, then compare your local copy with the master repository.

                                [void.gif] [void.gif] [void.gif]
                                [void.gif]
cd src/documentation/xdocs
cvs diff -u contrib.xml > $WORK/cocoon/patch/contrib.xml.diff

                                [void.gif]
                                [void.gif] [void.gif] [void.gif]

   5. Pack it up

   With a patch that involves multiple separate diffs and/or new whole xml files, then please
   pack them into a compressed archive, e.g. my-patch.tar.gz or my-patch.zip

   Also, if it helps to make your contribution clearer, then you might replicate the directory
   structure. Only bother with this for a complex patch.

                                [void.gif] [void.gif] [void.gif]
   [void.gif]
+---$WORK/cocoon/patch
|   +---howto
|   |   +---book.xml.diff ........... differences to book.xml to link the 2 docs
|   |   +---howto-new-topic-a.xml ... a complete new document
|   |   +---howto-new-topic-b.xml ... a complete new document
|   +---link
|   |   +---livesites.xml.diff
|   |   +---books.xml.diff
|   |

                                [void.gif]
                                [void.gif] [void.gif] [void.gif]

   6. Describe the patch

   Prepare a brief explanation of what your patch does. Get this ready in a text file before
   you go to Bugzilla. See further hints about this in the "Description" section of the How-to
   Bugzilla.

   What version of CVS did you patch against? Was it HEAD branch? Was it a nightly build? Was
   it a public release?
   7. Submit via Bugzilla

   To contribute your patch to a specific project, use Bugzilla - The Apache Bug Database. The
   procedure is explained in [16]How to Contribute a Patch via Bugzilla.
   Real World Extension
     ______________________________________________________________________________________

   Multiple diffs in a single patch

   A patchfile can contain the differences to various individual documents. For example, the
   following command does that ...

                                [void.gif] [void.gif] [void.gif]
                                [void.gif]
cd src/documentation/xdocs
cvs diff -u contrib.xml userdocs/concepts/sitemap.xml > my-patch.diff

                                [void.gif]
                                [void.gif] [void.gif] [void.gif]

   However, be careful not to go overboard with this technique. Often it is better to produce
   individual diffs and then pack them all into one .zip archive. When producing multiple
   diffs in one patchfile, try to limit it to one particular topic, i.e when fixing the same
   broken external link in various pages, then it would be fine to produce a single diff.
   Consider the committer - they will find it hard to apply your patch if it also attempts to
   fix other things.
   Other ways of obtaining source for diff comparison

   Ideally you will prepare your patches against a CVS repository. There are other ways to do
   this. They do create more work for the committers, however it may be the only way that you
   can do it. We would certainly rather receive your patch however it comes.

   You could get the source document via the web interface to CVS. Here are the steps ...

     * get the [17]relevant XML file via ViewCVS
     * save the file to your local disk: ./contrib.xml.orig
     * create a copy of the file: ./contrib.xml
     * make your modifications and validate the XML
     * use the "diff" command (i.e. not 'cvs diff') as follows
       diff -u contrib.xml.orig contrib.xml > patch/contrib.xml.diff
     * proceed as for Step 5.

   There is another method if all else fails. You could save the public HTML page that was
   generated by Cocoon (currently static) and then prepare your diffs against the HTML source.
   This is obviously much harder for the committer, and should only ever be used for minor
   text edits. Here are the steps ...

     * save the relevant web page ([18]contrib.html) to your local disk: ./contrib.html.orig
     * create a copy of the file: ./contrib.html
     * make your modifications and view the page with your browser
     * use the "diff" command (i.e. not 'cvs diff') as follows
       diff -u contrib.html.orig contrib.html > patch/contrib.html.diff
     * proceed as for Step 5.



---
http://processors.wiki.ti.com/index.php/Working_with_Linux_patches

Working with Linux patches

Contents

     * [7]1 Creating a patch
     * [8]2 Applying a patch
     * [9]3 Reverting a patch
     * [10]4 How to survive with many patches
     * [11]5 Sending patches upstream
     * [12]6 Handling patch rejects
     * [13]7 Diff and patch tricks

   This topic will use the Linux kernel as an example, but this method can be applied to any
   source tree. This topic assumes a Linux host or Cygwin installed on a Windows host.

   To create a patch one uses the [14]GNU diff command, and to apply a patch one uses the
   [15]GNU patch command. Both should be available on your Linux system, or in your Cygwin
   installation.

Creating a patch

   You always keep yourself one level up in the directory structure from the directory you
   want to patch when you execute the diff command. Note that the -u flag is used, which
   generates unified diff. The -r flag used is to traverse all subdirectories recursively, and
   the -N flag makes sure files missing in one of the directories still gets added to the
   patch. And of course you'll want to 'clean' (make distclean) before making the patch:

   make distclean

   So, let's say you have made changes to a Linux kernel. I keep the original kernel tree I am
   working from in the linux-2.6.13-orig directory. I keep my changes in a separate tree,
   linux-2.6.13-mine. To generate a patch file describing my changes with the delta between
   the two versions I would execute:

   diff -uNr linux-2.6.13-orig linux-2.6.13-mine > patch-2.6.13-mytag

   This creates a file called patch-2.6.13-mytag, which is an uncompressed patch file. Note
   that this is readable text, and you should read through it as a sanity check to make sure
   no dot-files or other junk got in there by mistake.

   Also, note the size of the patch file. It should be relatively small. For example, if your
   source code that has changed consists of a few files that are ~10KB, the patch file should
   be on the order of 10-20KB.

   It is important that the patch file (which again is only a text file) is in UNIX mode and
   not DOS mode (depending on where you have edited the file). Please run the following
   command on your patch:

   file patch-2.6.13-mytag

   If you get: patch-2.6.13-mytag: 'diff' output text then your patch should be in the correct
   mode. If you get something like patch-2.6.13-mytag: ASCII English text, with CRLF line
   terminators or similar (note the CRLF which means DOS mode), action is required.

   To put the file in UNIX mode (i.e. remove all the CR characters) execute:

   tr -d '\r' < patch-2.6.13-mytag.dosmode > patch-2.6.13-mytag.unixmode

   Alternatively you can use the dos2unix command, but if only parts of the file is in DOS
   mode this can yield bad results.

   It is also important to make sure that applications do not automatically translate the
   patch files to DOS mode when transferring the file (i.e. mail clients or web browsers). To
   prevent this (and of course to reduce the size of the file) you should compress the patch.
   To compress the patch file using bzip2 execute:

   bzip2 -9 patch-2.6.13-mytag

   This will create a compressed patch with the name patch-2.6.13-mytag.bz2.

   You should replace the mytag part of the filename with something describing the patch. It
   could be your name, the name of your team, or the ISA the patch is for.

   Summary:
     * make distclean
     * diff -uNr linux-2.6.13-orig linux-2.6.13-mine > patch-2.6.13-mytag
     * file patch-2.6.13-mytag optionally followed by:
          + tr -d '\r' < patch-2.6.13-mytag.dosmode > patch-2.6.13-mytag.unixmode
     * bzip2 -9 patch-2.6.13-mytag

Applying a patch

   Patches you download are generally compressed. If they end with the .gz extension they are
   compressed with gzip (patch-2.6.13-sometag.gz). To uncompress this file type:

   gunzip patch-2.6.13-sometag.gz

   This will create an uncompressed patch file called patch-2.6.13-sometag.

   Alternatively the patch ends with the .bz2 extension, in which case you will have to
   execute the following to uncompress:

   bzip2 -d patch-2.6.13-sometag.bz2

   This will also create an uncompressed patch file called patch-2.6.13-sometag.

   If the file has no ending, it is most probably uncompressed. If you have doubts, execute
   the following command to get information on the file type:

   file patch-2.6.13-sometag

   If it's uncompressed it should say that it's a file of type 'diff' output text. To apply
   the patch, move into the project directory (linux kernel directory in this case, for
   instance the directory linux-2.6.13) and type:

   patch -p1 < ../patch-2.6.13-sometag

   This should apply the patch delta to your baseline project directory.

   The -p1 option means patchlevel 1. This means that it should skip one level of directories
   when applying the patch. If you view the patch-2.6.13-mytag file from above, it would read
   on the first two lines:
--- linux-2.6.13-orig/<path to first file changed> Thu Nov 28 23:53:15 2002
+++ linux-2.6.13-mine/<path to first file changed> Tue Dec 3 22:54:07 2002

   This shows which file to start applying patches to. The -p1 option makes the patch command
   ignore the first linux-2.6.13-orig and linux-2.6.13-mine directories when applying the
   patch.

   Summary:
     * gunzip patch-2.6.13-sometag.gz or bzip2 -d patch-2.6.13-sometag.bz2.
     * file patch-2.6.13-sometag
     * cd /path/to/kernel
     * patch -p1 < /path/to/patch-2.6.13-sometag

Reverting a patch

   Sometimes you want to try out the contents of a patch, but perhaps the patch introduced
   bugs you currently don't want to deal with. Fortunately, there is a way to revert patches.
   To revert the patch applied above, execute the following (from the linux-2.6.13 directory):

   patch -Rp1 < patch-2.6.13-sometag

   This will restore the kernel tree to the state it was before the patch was applied.

How to survive with many patches

   If the number of patches you deal with increases, it becomes inconvenient to do this
   manually. Then you may like to have a look to [16]quilt. See [17]How To Survive With Many
   Patches for an introduction to quilt.



---
http://mediatribe.net/en/node/13

Using diff and patch for directories, and managing patches during Drupal upgrades.

   Submitted by Albert on Sun, 11/01/2009 - 15:18
     * [2]Drupal

   Background: I was recently making a Drupal site where I needed (as is often the case) a
   visual text editor along with image- and file-upload capabilities. I tried using the
   [3]wysiwyg module in conjunction [4]FCKEditor 2.6.x, which is a good combination for that
   purpose.

   Since this does not work out of the box, I followed the instructions [5]here.

   This procedure requires modifying files in the Wysiwyg module (residing in
   sites/all/modules) as well as the FCKEditor library itself (in sites/all/libraries).

   The causes potential problems when the module and library are upgraded. My solution is to
   use patches. Here is how.
     * Put the original file in its place (e.g. site/all/modules/wysiwyg or
       sites/all/libraries/fckeditor)
     * Copy the entire directory (e.g. cp sites/all/modules/wysiwyg
       sites/all/modules/wysiwyg.patched)
     * Make the required changes files in the patched (e.g. wysiwyg.patched/) directory
     * I like to make a directory for all my patches on the system (e.g. mkdir patches)
     * For each of your patched directories, execute the diff command. Here is an example for
       the wysiwyg directory. the options "c" and "r" tell the diff program to provide context
       and apply recursively to subdirectories. Providing context is not required, although
       the idea here is to be able to apply the patch to upgrades of the code, which might be
       different than the original, in which case context is very helpful.
           diff -cr sites/all/modules/wysiwyg/ sites/all/modules/wysiwyg.patched/ >
       patches/wysiwyg_module_allow_file_uploads.diff

     * Test your patch by executing the patch command, which applies it to the original, in
       this case "sites/all/modules/wysiwyg", directory. Here is an example with the wysiwyg
       directory. The "p0" option tells the patch command to apply the patch to the same
       directory structure as when the patch was created (in this case
       sites/all/modules/wysiwyg), which makes sense. The default value for "p" (if you don't
       specify it) tells patch to ignore the directory structure and apply the patch, in this
       case, to "wysiwyg".
           patch -p0 < patches/wysiwyg_module_allow_file_uploads.diff

     * You can now get rid of the patched directory
     * Next time an upgrade is released for a directory you patched (say, wysiwyg), just back
       up your old directory, put the new one in its place, and apply the patch with the
       "patch -p0" command.



---
https://linuxacademy.com/blog/2012/09/18/introduction-using-diff-and-patch/

Introduction: Using diff and patch

   [17]Anthony James —  September 18, 2012

   The commands diff and patch form a powerful combination. They are widely used to get
   differences between original files and updated files in such a way that other people who
   only have the original files can turn them into the updated files with just a single patch
   file that contains only the differences. This tutorial explains the basics of how to use
   these great commands.

   Difficulty: Medium

   This tutorial assumes some basic Linux and command line knowledge, like changing
   directories, copying files and editing text files.

Using diff to create a simple patch

   The most simple way of using diff is getting the differences between two files, an original
   file and an updated file. You could, for example, write a few words in a normal text file,
   make some modifications, and then save the modified content to a second file. Then, you
   could compare these files with diff, like this:

     [rechosen@localhost ~]$ diff originalfile updatedfile

   Of course, replace originalfile and updatedfile with the appropiate filenames of your case.
   You will most probably get an output like this:

     1c1
     < These are a few words.
     \ No newline at end of file
     —
     > These still are just a few words.
     \ No newline at end of file

   Note: to demonstrate the creation of a simple patch, I used the file originalfile with the
   content “These are a few words.” and the file updatedfile with the content “These still are
   just a few words.”. You can create these files yourself if you want to run the commands in
   the tutorial and get about the same output.

   The 1c1 is a way of indicating line numbers and specifying what should be done. Note that
   those line numbers can also be line ranges (12,15 means line 12 to line 15). The “c” tells
   patch to replace the content of the lines. Two other characters with a meaning exist: “a”
   and “d”, with “a” meaning “add” or “append” and “d” meaning “delete”. The syntax is (line
   number or range)(c, a or d)(line number or range), although when using “a” or “d”, one of
   the (line number or range) parts may only contain a single line number.
     * When using “c”, the line numbers left of it are the lines in the original file that
       should be replaced with text contained in the patch, and the line numbers right of it
       are the lines the content should be in in the patched version of the file.
     * When using “a”, the line number on the left may only be a single number, meaning where
       to add the lines in the patched version of the file, and the line numbers right of it
       are the lines the content should be in in the patched version of the file.
     * When using “d”, the line numbers left of it are the lines that should be deleted to
       create the patched version of the file, and the line number on the right may only be a
       single number, telling where the lines would have been in the patched version of the
       file if they wouldn’t have been deleted. You might think that that last number is
       redundant, but remember that patches can also be applied in a reverse way. I’ll explain
       more about that later on in this tutorial.

   The “<” means that patch should remove the characters after this sign, and the “>” means
   that the characters after this sign should be added. When replacing content (a “c” between
   the line numbers), you will see both the < and the > sign. When adding content (an “a”
   between the line numbers), you’ll only see the > sign, and when deleting content (a “d”
   between the line numbers), only the < sign.

   The “\”, followed by “No newline at end of file”, is only there because I didn’t press
   enter after typing the words. Generally, it always is good practice to add a final newline
   to every text file you create. Certain pieces of software can’t do without them. Therefore,
   the absence of a final newline is reported so explicit by diff. Adding final newlines to
   the files makes the output a lot shorter:

     1c1
     < These are a few words.
     —
     > These still are just a few words.

   As you may have noticed, I omitted explaining what the 3 -’s are for. They indicate the end
   of the lines that should be replaced and the beginning of the lines that should replace
   them. They separate the old and the new lines. You will only see these when replacing
   content (a “c” between the line numbers).

   If we want to create a patch, we should put the output of diff into a file. Of course, you
   could do this by copying the output from your console and, after pasting it in your
   favourite text editor, saving the file, but there is a shorter way. We can let bash write
   diff’s output to a file for us this way:

     [rechosen@localhost ~]$ diff originalfile updatedfile > patchfile.patch

   Again, replace the filenames with the ones appropiate in your case. You might like to know
   that telling bash to write a command’s output to a file using > works with every command.
   This can be very useful to save to output of a command to a (log) file.

Applying the simple patch we created

   Well then, did we just create a patch? The short answer is: yes, we did. We can use the
   patchfile to change a copy of originalfile to a copy of updatedfile. Of course, it wouldn’t
   make that much sense to apply the patch on the files we created the patch from. Therefore,
   copy the original file and the patchfile to an other place, and go to that place. Then, try
   applying the patch this way:

     [rechosen@localhost ~]$ patch originalfile -i patchfile.patch -o updatedfile

   Again, replace the filenames where necessary. If all went well, the file updatedfile just
   created by patch should be identical to the one you had at first, when creating the patch
   with diff. You can check this using diff’s -s option:

     [rechosen@localhost ~]$ diff -s updatedfile
     [/path/to/the/original/updatedfile]/updatefile

   Replace the part between [ and ] with the path to the original update file. For example, if
   the updatedfile you used when creating the patch is located in the parent directory of your
   current directory, replace “[/path/to/the/original/updatedfile]” with “..” (bash
   understands this as the parent directory of the current working directory). And of course,
   also replace the filenames again where appropiate.

   Congratulations! If diff reported the files to be equal, you just succesfully created and
   used a patch! However, the patch format we just used is not the only one. In the next
   chapter, I will explain about an other patch format.

Contextual patching

   In the first chapter, we created a patch using diff’s normal format. This format, however,
   doesn’t provide any of the lines of context around the ones to be replaced, and therefore,
   a change in the line numbers (one or more extra newlines somewhere, or some deleted lines)
   would make it very difficult for the patch program to determine which lines to change
   instead. Also, if a different file that is being patched by accident contains the same
   lines as the original file at the right places, patch will happily apply the patchfile’s
   changes to this file. This could result in broken code and other unwanted side-effects.
   Fortunately, diff supports other formats than the normal one. Let’s create a patch for the
   same files, but this time using the context output format:

     [rechosen@localhost ~]$ diff -c originalfile updatedfile

   By now, it should be clear that you should replace the filenames where necessary =). You
   should get an output like this:

     *** originalfile 2007-02-03 22:15:48.000000000 0100
     — updatedfile 2007-02-03 22:15:56.000000000 0100
     ***************
     *** 1 ****
     ! These are a few words.
     — 1 —-
     ! These still are just a few words.

   As you can see, the filenames are included. This will save us some typing when applying the
   patch. The timestamps you can see next to the filenames are the date and time of the last
   modification of the file. The line with 15 *’s indicates the starting of a hunk. A hunk
   describes which changes, like replacements, additions and deletions, should be made to a
   certain block of text. The two numbers 1 are line numbers (again, these can also be line
   ranges (12,15 means line 12 to line 15)), and ! means that the line should be replaced. The
   line with a ! before the three -’s (hey, where did we see those before?) should be replaced
   by the second line with a !, after the three -’s (of course, the ! itself will not be
   included; it’s context format syntax).

   As you can see, there aren’t any c’s, a’s and d’s here. The action to perform is determined
   by the character in front of the line. The !, as explained, means that the line should be
   replaced. The other available characters are +, – and ” ” (a space). The + means add (or
   append), the – means delete, and the ” ” means nothing: patch will only use it as context
   to be sure it’s modifying the right part of the file.

   Applying this patch is a bit easier: under the same circumstances as before (let bash write
   the diff output to a file again, then copy the patchfile and the original file to an other
   location), you’ll need to run:

     [rechosen@localhost ~]$ patch -i patchfile.patch -o updatedfile

   You’ll probably think now: why do we still have to specify the new filename? Well, that’s
   because patch was made with the intention to update existing files in mind, not to create
   new updated files. This usually comes in handy when patching source trees of programs,
   which is pretty much the main use of patch. And that brings us to our next subject: to
   patch a whole source tree, multiple files should included in the patchfile. The next
   chapter will tell how to do this.

Getting the differences between multiple files

   The easiest way to get the differences between multiple files is to put them all in a
   directory and to let diff compare the whole directories. You can just specify directories
   instead of files, diff will autodetect whether you’re giving it a file or a directory:

     [rechosen@localhost ~]$ diff originaldirectory/ updateddirectory/

   Note: if the directories you’re comparing also include subdirectories, you should add the
   -r option to make diff compare the files in subdirectories, too.

   This should give an output like this:

     diff originaldirectory/file1 updateddirectory/file1
     1c1
     < This is the first original file.
     —
     > This is the first updated file.
     diff originaldirectory/file2 updateddirectory/file2
     1c1
     < This is the second original file.
     —
     > This is the second updated file.
     14d13
     < We’re going to add something in this file and to delete this line.
     26a26
     > This is line has been added to this updated file.

   Note: for this example, I created some example files. You can download an archive
   containing these files here:
   [18]http://www.linuxtutorialblog.com/post/introduction-using-diff-and-patch-tutorial/diffpa
   tchexamplefiles.tar.gz.

   As you can see, the normal output format only specifies filenames when comparing multiple
   files. You can also see examples of the addition and deletion of lines.

   Now, let’s have a look at the output of the same comparison in the context format:

     diff -c originaldirectory/file1 updateddirectory/file1
     *** originaldirectory/file1 2007-02-04 16:17:57.000000000 +0100
     — updateddirectory/file1 2007-02-04 16:18:33.000000000 +0100
     ***************
     *** 1 ****
     ! This is the first original file.
     — 1 —-
     ! This is the first updated file.
     diff -c originaldirectory/file2 updateddirectory/file2
     *** originaldirectory/file2 2007-02-04 16:19:37.000000000 +0100
     — updateddirectory/file2 2007-02-04 16:20:08.000000000 +0100
     ***************
     *** 1,4 ****
     ! This is the second original file.

     S
     O
     — 1,4 —-
     ! This is the second updated file.

     S
     O
     ***************
     *** 11,17 ****
     C
     E

     - We’re going to add something in this file and to delete this line.

     S
     O
     — 11,16 —-
     ***************
     *** 24,28 ****
     — 23,28 —-
     C
     E

     + This is line has been added to this updated file.

     Something will be added above this line.

   The first thing you should notice is increase in length; the context format provides more
   information than the normal format. This wasn’t that visible in the first example, as there
   wasn’t any context to include. However, this time there was context, and that surely
   lenghtens the patch a lot. You might also have noticed that the filenames are mentioned
   twice every time. This is probably done either to make it easier for patch to recognize
   when to start patching the next file, or to provide better backwards-compatibility (or
   both).

   The other way to let diff compare multiple files is writing a shell script that runs diff
   multiple times and correctly adds all output to one file, including the lines with the diff
   commands. I will not tell you how to do this as the other way (putting the files in a
   directory) is a lot easier and is used widely.

   Creating this patch with diff was considerably easy, but the use of directories kicks in a
   new problem: will patch just patch the mentioned files in the current working directory and
   forget about the directory they were in when creating the patch, or will it patch the files
   inside the directories specified in the patch? Have a look at the next chapter to find out!

Patching multiple files

   In the chapter before this one, we created a patch that can be used to patch multiple
   files. If you haven’t done so already, save diff’s output to an actual patchfile in a way
   like this:

     [rechosen@localhost ~]$ diff -c originaldirectory/ updateddirectory/ > patchfile.patch

   Note: we’ll be using the context format patch here as it generally is good practice to use
   a format that provides context.

   It’s time to try using our patchfile. Copy the original directory and the patchfile to an
   other location, go to that other location, and apply the patch with this command:

     [rechosen@localhost ~]$ patch -i patchfile.patch

   Huh? It reports that it cannot find the file to patch! Yep, that’s right. It is trying to
   find the file file1 in the current directory (patch defaultly strips away all directories
   in front of the filename). Of course, this file isn’t there because we’re trying to update
   the file in the directory originaldirectory. For this reason, we should tell patch not to
   strip away any directories in the filenames. That can be done this way:

     [rechosen@localhost ~]$ patch -p0 -i patchfile.patch

   Note: you might think you could also just move into originaldirectory and run the patch
   command there. Don’t! This is bad practice: if the patchfile includes any files to patch in
   subdirectories, patch will look for them in the working directory, and, obviously, not find
   them or find the wrong ones. Use the -p option to make patch look in subdirectories as it
   should.

   The -p options tells patch how many slashes (including what’s before them, usually
   directories) it should strip away before the filename (note that, when using the option
   -p0, patch looks for the files to patch in both originaldirectory and updateddirectory, in
   our case). In this case, we set it to 0 (do not strip away any slash), but you can also set
   it to 1 (to strip away the first slash including anything before it), or 2 (to strip away
   the first two slashes including everything before it), or any other amount. This can be
   very useful if you’ve got a patch which uses a different directory structure than you. For
   example: if you’d have a patch that uses a directory structure like this:

     (…)
     *** /home/username/sources/program/originaldirectory/file1 2007-02-04 16:17:57.000000000
     +0100
     — /home/username/sources/program/updateddirectory/file1 2007-02-04 16:18:33.000000000
     +0100
     (…)

   You could just count the slashes (/ (1) home/ (2) username/ (3) sources/ (4) program/ (5))
   and give that value with the -p option. If you’re using -p5, patch would look for both
   originaldirectory/file1 and updateddirectory/file1. Please do note that patch considers two
   slashes next to each other (like in /home/username//sources) as a single slash. This is
   because scripts sometimes (accidently or not) put an extra slash between directories.

Reversing an applied patch

   Sometimes a patch is applied while it shouldn’t have been. For example: a patch introduces
   a new bug in some code, and a fixed patch is released. However, you already applied the
   old, buggy patch, and you can’t think of a quick way to get the original files again (maybe
   they were already patched dozens of times). You can then apply the buggy patch in a
   reversive way. The patch command will try to undo all changes it did by swapping the hunks.
   You can tell patch to try reversing by passing it the -R option:

     [rechosen@localhost ~]$ patch -p0 -R -i patchfile.patch

   Usually, this operation will succeed, and you’ll get back the original files you had. By
   the way, there is another reason why you’d want to reverse a patch: sometimes (especially
   when sleepy), people release a patch with the files swapped. You’ve got a big chance that
   patch will detect this automatically and ask you if you want it to try patching
   reversively. Sometimes, however, patch will not detect it and wonder why the files don’t
   seem to match. You can then try applying the patch in a reversed way manually, by passing
   the -R option to patch. It is good practice to make a backup before you try this, as it is
   possible that patch messes up and leaves you with irrecoverably spoiled files.

The unified format

   The diff command can also output the differences in another format: the unified format.
   This format is more compact, as it omits redundant context lines and groups things like
   line number instructions. However, this format is currently only supported by GNU diff and
   patch. If you’re releasing a patch in this format, you should be sure that it will only be
   applied by GNU patch users. Pretty much every Linux flavour features GNU patch.

   The unified format is similar to the context format, but it’s far from exactly the same.
   You can create a patch in the unified format this way:

     [rechosen@localhost ~]$ diff -u originaldirectory/ updateddirectory/

   The output should be something like this:

     diff -u originaldirectory/file1 updateddirectory/file1
     — originaldirectory/file1 2007-02-04 16:17:57.000000000 +0100
     +++ updateddirectory/file1 2007-02-04 16:18:33.000000000 +0100
     @@ -1 +1 @@
     -This is the first original file.
     +This is the first updated file.
     diff -u originaldirectory/file2 updateddirectory/file2
     — originaldirectory/file2 2007-02-04 16:19:37.000000000 +0100
     +++ updateddirectory/file2 2007-02-04 16:20:08.000000000 +0100
     @@ -1,4 +1,4 @@
     -This is the second original file.
     +This is the second updated file.

     S
     O
     @@ -11,7 +11,6 @@
     C
     E

     -We’re going to add something in this file and to delete this line.

     S
     O
     @@ -24,5 +23,6 @@
     C
     E

     +This is line has been added to this updated file.

     Something will be added above this line.

   As you can see, the line numbers/ranges are grouped and placed between @’s. Also, there is
   no extra space after + or -. This saves some bytes. Another difference: the unified format
   does not feature a special replacement sign. It simply deletes (the – sign) the old line
   and adds (the + sign) the altered line instead. The only difference between adding/deleting
   and replacing can be found in the line numbers/ranges: when replacing a line, these are the
   same, and when adding or deleting, they differ.

Format comparison

   Having read about three formats, you probably wonder which one to choose. Here’s a small
   comparison:
     * The normal format features the best compatibility: pretty much every diff/patch-like
       command should recognize it. The lack of context is a big disadvantage, though.
     * The context format is widely supported, though not every diff/patch-like command knows
       it. However, the advantage of being able to include context makes up for that.
     * The unified format features context, too, and is more compact than the context format,
       but is only supported by a single brand of diff/patch-like commands.

   If you’re sure that the patch will be used by GNU diff/patch users only, unified is the
   best choice, as it keeps your patch as compact as possible. In most other cases, however,
   the context format is the best choice. The normal format should only be used if you’re sure
   there’s a user without context format support.

Varying the amount of context lines

   It is possible to make diff include less lines of context around the lines that should be
   changed. Especially in big patchfiles, this can strip away a lot of bytes and make your
   patchfile more portable. However, if you include too few lines of context, patch might not
   work correctly. Quoting the GNU diff man page: “For proper operation, patch typically needs
   at least two lines of context.”

   Specifying the amount of context lines can be done in multiple ways:
     * If you want to use the context format, you can combine it into one option, the -C
       option. Example:

     [rechosen@localhost ~]$ diff -C 2 originaldirectory/ updateddirectory/
       The above command would use the context format with 2 context lines.
     * If you want to use the unified format, you can combine it into one option, the -U
       option. Example:

     [rechosen@localhost ~]$ diff -U 2 originaldirectory/ updateddirectory/
       The above command would use the unified format with 2 context lines.
     * Regardless which format you choose, you can specify the number of lines like this:

     [rechosen@localhost ~]$ diff -2 originaldirectory/ updateddirectory/
       However, this will only work if you also specify a context-supporting format. You’d
       have to combine this option either with -c or -u.

Final words

   Although this tutorial describes a lot of features and workings of diff and patch, it does
   by far not describe everything you can do with these powerful tools. It is an introduction
   in the form of a tutorial. If you want to know more about these commands, you can read, for
   example, their manpages and [19]GNU’s documentation about diff and patch.

   Well then, I hope this tutorial helped you. Thank you for reading! If you liked this
   tutorial, browse around this blog and see if there are more you like. Please help this blog
   to grow by leaving a link here and there, and let other people benefit from the growing
   amount of knowledge on this site. Thanks in advance and happy patching!

