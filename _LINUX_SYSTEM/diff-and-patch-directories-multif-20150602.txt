filename: diff-and-patch-directories-multif_20150602.txt
http://mediatribe.net/en/node/13

Using diff and patch for directories, and managing patches during Drupal upgrades.

   Submitted by Albert on Sun, 11/01/2009 - 15:18
     * [2]Drupal

   Background: I was recently making a Drupal site where I needed (as is often the case) a
   visual text editor along with image- and file-upload capabilities. I tried using the
   [3]wysiwyg module in conjunction [4]FCKEditor 2.6.x, which is a good combination for that
   purpose.

   Since this does not work out of the box, I followed the instructions [5]here.

   This procedure requires modifying files in the Wysiwyg module (residing in
   sites/all/modules) as well as the FCKEditor library itself (in sites/all/libraries).

   The causes potential problems when the module and library are upgraded. My solution is to
   use patches. Here is how.
     * Put the original file in its place (e.g. site/all/modules/wysiwyg or
       sites/all/libraries/fckeditor)
     * Copy the entire directory (e.g. cp sites/all/modules/wysiwyg
       sites/all/modules/wysiwyg.patched)
     * Make the required changes files in the patched (e.g. wysiwyg.patched/) directory
     * I like to make a directory for all my patches on the system (e.g. mkdir patches)
     * For each of your patched directories, execute the diff command. Here is an example for
       the wysiwyg directory. the options "c" and "r" tell the diff program to provide context
       and apply recursively to subdirectories. Providing context is not required, although
       the idea here is to be able to apply the patch to upgrades of the code, which might be
       different than the original, in which case context is very helpful.
           diff -cr sites/all/modules/wysiwyg/ sites/all/modules/wysiwyg.patched/ >
       patches/wysiwyg_module_allow_file_uploads.diff

     * Test your patch by executing the patch command, which applies it to the original, in
       this case "sites/all/modules/wysiwyg", directory. Here is an example with the wysiwyg
       directory. The "p0" option tells the patch command to apply the patch to the same
       directory structure as when the patch was created (in this case
       sites/all/modules/wysiwyg), which makes sense. The default value for "p" (if you don't
       specify it) tells patch to ignore the directory structure and apply the patch, in this
       case, to "wysiwyg".
           patch -p0 < patches/wysiwyg_module_allow_file_uploads.diff

     * You can now get rid of the patched directory
     * Next time an upgrade is released for a directory you patched (say, wysiwyg), just back
       up your old directory, put the new one in its place, and apply the patch with the
       "patch -p0" command.
Resources

     * [R1]The Ten Minute Guide to diff and patch
     * [R2]Introduction: Using diff and patch (tutorial)

     

---
[R1] http://stephenjungels.com/jungels.net/articles/diff-patch-ten-minutes.html

   This article is archived, which means it may not be current and I can't answer questions
   about it. Some readers may still find it useful, though.

The Ten Minute Guide to diff and patch

   Situation one: you are trying to compile a package from source and you discover that
   somebody has already done the work for you of modifying it slightly to compile on your
   system. They have made their work available as a "patch", but you're not sure how to make
   use of it. The answer is that you apply the patch to the original source code with a
   command line tool called, appropriately, patch.

   Situation two: you have downloaded the source code to an open source package and after an
   hour or so of minor edits, you manage to make it compile on your system. You would like to
   make your work available to other programmers, or to the authors of the package, without
   redistributing the entire modified package. Now you are in a situation where you need to
   create a patch of your own, and the tool you need is diff.

   This is a quick guide to diff and patch which will help you in these situations by
   describing the tools as they are most commonly used. It tells you enough to get started
   right away. Later, you can learn the ins and outs of diff and patch at your leisure, using
   the man pages.

Applying patches with patch

   To apply a patch to a single file, change to the directory where the file is located and
   call patch:
patch < foo.patch

   These instructions assume the patch is distributed in unified format, which identifies the
   file the patch should be applied to. If not, you can specify the file on the command line:
patch foo.txt < bar.patch

   Applying patches to entire directories (perhaps the more common case) is similar, but you
   have to be careful about setting a "p level". What this means is that, within patch files,
   the files to be patched are identified by path names which may be different now that the
   files are located on your computer rather than on the computer where the patch was created.
   The p level instructs patch to ignore parts of the path name so that it can identify the
   files correctly. Most often a p level of one will work, so you use:
patch -p1 < baz.patch

   You should change to the top level source directory before running this command. If a patch
   level of one does not correctly identify any files to patch, inspect the patch file for
   file names. If you see a name like
/users/stephen/package/src/net/http.c

   and you are working in a directory that contains net/http.c, use
patch -p5 < baz.patch

   In general, count up one for each path separator (slash character) that you remove from the
   beginning of the path, until what's left is a path that exists in your working directory.
   The count you reach is the p level.

   To remove a patch, use the -R flag, ie
patch -p5 -R < baz.patch

Creating patches with diff

   Using diff is simple whether you are working with single files or entire source
   directories. To create a patch for a single file, use the form:
diff -u original.c new.c > original.patch

   To create a patch for an entire source tree, make a copy of the tree:
cp -R original new

   Make any changes required in the directory new/. Then create a patch with the following
   command:
diff -rupN original/ new/ > original.patch

   That's all you need to get started with diff and patch. For more information use:
man diff
man patch



---
[R2] https://linuxacademy.com/blog/2012/09/18/introduction-using-diff-and-patch/

Introduction: Using diff and patch

   [17]Anthony James —  September 18, 2012

   The commands diff and patch form a powerful combination. They are widely used to get
   differences between original files and updated files in such a way that other people who
   only have the original files can turn them into the updated files with just a single patch
   file that contains only the differences. This tutorial explains the basics of how to use
   these great commands.

   Difficulty: Medium

   This tutorial assumes some basic Linux and command line knowledge, like changing
   directories, copying files and editing text files.

Using diff to create a simple patch

   The most simple way of using diff is getting the differences between two files, an original
   file and an updated file. You could, for example, write a few words in a normal text file,
   make some modifications, and then save the modified content to a second file. Then, you
   could compare these files with diff, like this:

     [rechosen@localhost ~]$ diff originalfile updatedfile

   Of course, replace originalfile and updatedfile with the appropiate filenames of your case.
   You will most probably get an output like this:

     1c1
     < These are a few words.
     \ No newline at end of file
     —
     > These still are just a few words.
     \ No newline at end of file

   Note: to demonstrate the creation of a simple patch, I used the file originalfile with the
   content “These are a few words.” and the file updatedfile with the content “These still are
   just a few words.”. You can create these files yourself if you want to run the commands in
   the tutorial and get about the same output.

   The 1c1 is a way of indicating line numbers and specifying what should be done. Note that
   those line numbers can also be line ranges (12,15 means line 12 to line 15). The “c” tells
   patch to replace the content of the lines. Two other characters with a meaning exist: “a”
   and “d”, with “a” meaning “add” or “append” and “d” meaning “delete”. The syntax is (line
   number or range)(c, a or d)(line number or range), although when using “a” or “d”, one of
   the (line number or range) parts may only contain a single line number.
     * When using “c”, the line numbers left of it are the lines in the original file that
       should be replaced with text contained in the patch, and the line numbers right of it
       are the lines the content should be in in the patched version of the file.
     * When using “a”, the line number on the left may only be a single number, meaning where
       to add the lines in the patched version of the file, and the line numbers right of it
       are the lines the content should be in in the patched version of the file.
     * When using “d”, the line numbers left of it are the lines that should be deleted to
       create the patched version of the file, and the line number on the right may only be a
       single number, telling where the lines would have been in the patched version of the
       file if they wouldn’t have been deleted. You might think that that last number is
       redundant, but remember that patches can also be applied in a reverse way. I’ll explain
       more about that later on in this tutorial.

   The “<” means that patch should remove the characters after this sign, and the “>” means
   that the characters after this sign should be added. When replacing content (a “c” between
   the line numbers), you will see both the < and the > sign. When adding content (an “a”
   between the line numbers), you’ll only see the > sign, and when deleting content (a “d”
   between the line numbers), only the < sign.

   The “\”, followed by “No newline at end of file”, is only there because I didn’t press
   enter after typing the words. Generally, it always is good practice to add a final newline
   to every text file you create. Certain pieces of software can’t do without them. Therefore,
   the absence of a final newline is reported so explicit by diff. Adding final newlines to
   the files makes the output a lot shorter:

     1c1
     < These are a few words.
     —
     > These still are just a few words.

   As you may have noticed, I omitted explaining what the 3 -’s are for. They indicate the end
   of the lines that should be replaced and the beginning of the lines that should replace
   them. They separate the old and the new lines. You will only see these when replacing
   content (a “c” between the line numbers).

   If we want to create a patch, we should put the output of diff into a file. Of course, you
   could do this by copying the output from your console and, after pasting it in your
   favourite text editor, saving the file, but there is a shorter way. We can let bash write
   diff’s output to a file for us this way:

     [rechosen@localhost ~]$ diff originalfile updatedfile > patchfile.patch

   Again, replace the filenames with the ones appropiate in your case. You might like to know
   that telling bash to write a command’s output to a file using > works with every command.
   This can be very useful to save to output of a command to a (log) file.

Applying the simple patch we created

   Well then, did we just create a patch? The short answer is: yes, we did. We can use the
   patchfile to change a copy of originalfile to a copy of updatedfile. Of course, it wouldn’t
   make that much sense to apply the patch on the files we created the patch from. Therefore,
   copy the original file and the patchfile to an other place, and go to that place. Then, try
   applying the patch this way:

     [rechosen@localhost ~]$ patch originalfile -i patchfile.patch -o updatedfile

   Again, replace the filenames where necessary. If all went well, the file updatedfile just
   created by patch should be identical to the one you had at first, when creating the patch
   with diff. You can check this using diff’s -s option:

     [rechosen@localhost ~]$ diff -s updatedfile
     [/path/to/the/original/updatedfile]/updatefile

   Replace the part between [ and ] with the path to the original update file. For example, if
   the updatedfile you used when creating the patch is located in the parent directory of your
   current directory, replace “[/path/to/the/original/updatedfile]” with “..” (bash
   understands this as the parent directory of the current working directory). And of course,
   also replace the filenames again where appropiate.

   Congratulations! If diff reported the files to be equal, you just succesfully created and
   used a patch! However, the patch format we just used is not the only one. In the next
   chapter, I will explain about an other patch format.

Contextual patching

   In the first chapter, we created a patch using diff’s normal format. This format, however,
   doesn’t provide any of the lines of context around the ones to be replaced, and therefore,
   a change in the line numbers (one or more extra newlines somewhere, or some deleted lines)
   would make it very difficult for the patch program to determine which lines to change
   instead. Also, if a different file that is being patched by accident contains the same
   lines as the original file at the right places, patch will happily apply the patchfile’s
   changes to this file. This could result in broken code and other unwanted side-effects.
   Fortunately, diff supports other formats than the normal one. Let’s create a patch for the
   same files, but this time using the context output format:

     [rechosen@localhost ~]$ diff -c originalfile updatedfile

   By now, it should be clear that you should replace the filenames where necessary =). You
   should get an output like this:

     *** originalfile 2007-02-03 22:15:48.000000000 0100
     — updatedfile 2007-02-03 22:15:56.000000000 0100
     ***************
     *** 1 ****
     ! These are a few words.
     — 1 —-
     ! These still are just a few words.

   As you can see, the filenames are included. This will save us some typing when applying the
   patch. The timestamps you can see next to the filenames are the date and time of the last
   modification of the file. The line with 15 *’s indicates the starting of a hunk. A hunk
   describes which changes, like replacements, additions and deletions, should be made to a
   certain block of text. The two numbers 1 are line numbers (again, these can also be line
   ranges (12,15 means line 12 to line 15)), and ! means that the line should be replaced. The
   line with a ! before the three -’s (hey, where did we see those before?) should be replaced
   by the second line with a !, after the three -’s (of course, the ! itself will not be
   included; it’s context format syntax).

   As you can see, there aren’t any c’s, a’s and d’s here. The action to perform is determined
   by the character in front of the line. The !, as explained, means that the line should be
   replaced. The other available characters are +, – and ” ” (a space). The + means add (or
   append), the – means delete, and the ” ” means nothing: patch will only use it as context
   to be sure it’s modifying the right part of the file.

   Applying this patch is a bit easier: under the same circumstances as before (let bash write
   the diff output to a file again, then copy the patchfile and the original file to an other
   location), you’ll need to run:

     [rechosen@localhost ~]$ patch -i patchfile.patch -o updatedfile

   You’ll probably think now: why do we still have to specify the new filename? Well, that’s
   because patch was made with the intention to update existing files in mind, not to create
   new updated files. This usually comes in handy when patching source trees of programs,
   which is pretty much the main use of patch. And that brings us to our next subject: to
   patch a whole source tree, multiple files should included in the patchfile. The next
   chapter will tell how to do this.

Getting the differences between multiple files

   The easiest way to get the differences between multiple files is to put them all in a
   directory and to let diff compare the whole directories. You can just specify directories
   instead of files, diff will autodetect whether you’re giving it a file or a directory:

     [rechosen@localhost ~]$ diff originaldirectory/ updateddirectory/

   Note: if the directories you’re comparing also include subdirectories, you should add the
   -r option to make diff compare the files in subdirectories, too.

   This should give an output like this:

     diff originaldirectory/file1 updateddirectory/file1
     1c1
     < This is the first original file.
     —
     > This is the first updated file.
     diff originaldirectory/file2 updateddirectory/file2
     1c1
     < This is the second original file.
     —
     > This is the second updated file.
     14d13
     < We’re going to add something in this file and to delete this line.
     26a26
     > This is line has been added to this updated file.

   Note: for this example, I created some example files. You can download an archive
   containing these files here:
   [18]http://www.linuxtutorialblog.com/post/introduction-using-diff-and-patch-tutorial/diffpa
   tchexamplefiles.tar.gz.

   As you can see, the normal output format only specifies filenames when comparing multiple
   files. You can also see examples of the addition and deletion of lines.

   Now, let’s have a look at the output of the same comparison in the context format:

     diff -c originaldirectory/file1 updateddirectory/file1
     *** originaldirectory/file1 2007-02-04 16:17:57.000000000 +0100
     — updateddirectory/file1 2007-02-04 16:18:33.000000000 +0100
     ***************
     *** 1 ****
     ! This is the first original file.
     — 1 —-
     ! This is the first updated file.
     diff -c originaldirectory/file2 updateddirectory/file2
     *** originaldirectory/file2 2007-02-04 16:19:37.000000000 +0100
     — updateddirectory/file2 2007-02-04 16:20:08.000000000 +0100
     ***************
     *** 1,4 ****
     ! This is the second original file.

     S
     O
     — 1,4 —-
     ! This is the second updated file.

     S
     O
     ***************
     *** 11,17 ****
     C
     E

     - We’re going to add something in this file and to delete this line.

     S
     O
     — 11,16 —-
     ***************
     *** 24,28 ****
     — 23,28 —-
     C
     E

     + This is line has been added to this updated file.

     Something will be added above this line.

   The first thing you should notice is increase in length; the context format provides more
   information than the normal format. This wasn’t that visible in the first example, as there
   wasn’t any context to include. However, this time there was context, and that surely
   lenghtens the patch a lot. You might also have noticed that the filenames are mentioned
   twice every time. This is probably done either to make it easier for patch to recognize
   when to start patching the next file, or to provide better backwards-compatibility (or
   both).

   The other way to let diff compare multiple files is writing a shell script that runs diff
   multiple times and correctly adds all output to one file, including the lines with the diff
   commands. I will not tell you how to do this as the other way (putting the files in a
   directory) is a lot easier and is used widely.

   Creating this patch with diff was considerably easy, but the use of directories kicks in a
   new problem: will patch just patch the mentioned files in the current working directory and
   forget about the directory they were in when creating the patch, or will it patch the files
   inside the directories specified in the patch? Have a look at the next chapter to find out!

Patching multiple files

   In the chapter before this one, we created a patch that can be used to patch multiple
   files. If you haven’t done so already, save diff’s output to an actual patchfile in a way
   like this:

     [rechosen@localhost ~]$ diff -c originaldirectory/ updateddirectory/ > patchfile.patch

   Note: we’ll be using the context format patch here as it generally is good practice to use
   a format that provides context.

   It’s time to try using our patchfile. Copy the original directory and the patchfile to an
   other location, go to that other location, and apply the patch with this command:

     [rechosen@localhost ~]$ patch -i patchfile.patch

   Huh? It reports that it cannot find the file to patch! Yep, that’s right. It is trying to
   find the file file1 in the current directory (patch defaultly strips away all directories
   in front of the filename). Of course, this file isn’t there because we’re trying to update
   the file in the directory originaldirectory. For this reason, we should tell patch not to
   strip away any directories in the filenames. That can be done this way:

     [rechosen@localhost ~]$ patch -p0 -i patchfile.patch

   Note: you might think you could also just move into originaldirectory and run the patch
   command there. Don’t! This is bad practice: if the patchfile includes any files to patch in
   subdirectories, patch will look for them in the working directory, and, obviously, not find
   them or find the wrong ones. Use the -p option to make patch look in subdirectories as it
   should.

   The -p options tells patch how many slashes (including what’s before them, usually
   directories) it should strip away before the filename (note that, when using the option
   -p0, patch looks for the files to patch in both originaldirectory and updateddirectory, in
   our case). In this case, we set it to 0 (do not strip away any slash), but you can also set
   it to 1 (to strip away the first slash including anything before it), or 2 (to strip away
   the first two slashes including everything before it), or any other amount. This can be
   very useful if you’ve got a patch which uses a different directory structure than you. For
   example: if you’d have a patch that uses a directory structure like this:

     (…)
     *** /home/username/sources/program/originaldirectory/file1 2007-02-04 16:17:57.000000000
     +0100
     — /home/username/sources/program/updateddirectory/file1 2007-02-04 16:18:33.000000000
     +0100
     (…)

   You could just count the slashes (/ (1) home/ (2) username/ (3) sources/ (4) program/ (5))
   and give that value with the -p option. If you’re using -p5, patch would look for both
   originaldirectory/file1 and updateddirectory/file1. Please do note that patch considers two
   slashes next to each other (like in /home/username//sources) as a single slash. This is
   because scripts sometimes (accidently or not) put an extra slash between directories.

Reversing an applied patch

   Sometimes a patch is applied while it shouldn’t have been. For example: a patch introduces
   a new bug in some code, and a fixed patch is released. However, you already applied the
   old, buggy patch, and you can’t think of a quick way to get the original files again (maybe
   they were already patched dozens of times). You can then apply the buggy patch in a
   reversive way. The patch command will try to undo all changes it did by swapping the hunks.
   You can tell patch to try reversing by passing it the -R option:

     [rechosen@localhost ~]$ patch -p0 -R -i patchfile.patch

   Usually, this operation will succeed, and you’ll get back the original files you had. By
   the way, there is another reason why you’d want to reverse a patch: sometimes (especially
   when sleepy), people release a patch with the files swapped. You’ve got a big chance that
   patch will detect this automatically and ask you if you want it to try patching
   reversively. Sometimes, however, patch will not detect it and wonder why the files don’t
   seem to match. You can then try applying the patch in a reversed way manually, by passing
   the -R option to patch. It is good practice to make a backup before you try this, as it is
   possible that patch messes up and leaves you with irrecoverably spoiled files.

The unified format

   The diff command can also output the differences in another format: the unified format.
   This format is more compact, as it omits redundant context lines and groups things like
   line number instructions. However, this format is currently only supported by GNU diff and
   patch. If you’re releasing a patch in this format, you should be sure that it will only be
   applied by GNU patch users. Pretty much every Linux flavour features GNU patch.

   The unified format is similar to the context format, but it’s far from exactly the same.
   You can create a patch in the unified format this way:

     [rechosen@localhost ~]$ diff -u originaldirectory/ updateddirectory/

   The output should be something like this:

     diff -u originaldirectory/file1 updateddirectory/file1
     — originaldirectory/file1 2007-02-04 16:17:57.000000000 +0100
     +++ updateddirectory/file1 2007-02-04 16:18:33.000000000 +0100
     @@ -1 +1 @@
     -This is the first original file.
     +This is the first updated file.
     diff -u originaldirectory/file2 updateddirectory/file2
     — originaldirectory/file2 2007-02-04 16:19:37.000000000 +0100
     +++ updateddirectory/file2 2007-02-04 16:20:08.000000000 +0100
     @@ -1,4 +1,4 @@
     -This is the second original file.
     +This is the second updated file.

     S
     O
     @@ -11,7 +11,6 @@
     C
     E

     -We’re going to add something in this file and to delete this line.

     S
     O
     @@ -24,5 +23,6 @@
     C
     E

     +This is line has been added to this updated file.

     Something will be added above this line.

   As you can see, the line numbers/ranges are grouped and placed between @’s. Also, there is
   no extra space after + or -. This saves some bytes. Another difference: the unified format
   does not feature a special replacement sign. It simply deletes (the – sign) the old line
   and adds (the + sign) the altered line instead. The only difference between adding/deleting
   and replacing can be found in the line numbers/ranges: when replacing a line, these are the
   same, and when adding or deleting, they differ.

Format comparison

   Having read about three formats, you probably wonder which one to choose. Here’s a small
   comparison:
     * The normal format features the best compatibility: pretty much every diff/patch-like
       command should recognize it. The lack of context is a big disadvantage, though.
     * The context format is widely supported, though not every diff/patch-like command knows
       it. However, the advantage of being able to include context makes up for that.
     * The unified format features context, too, and is more compact than the context format,
       but is only supported by a single brand of diff/patch-like commands.

   If you’re sure that the patch will be used by GNU diff/patch users only, unified is the
   best choice, as it keeps your patch as compact as possible. In most other cases, however,
   the context format is the best choice. The normal format should only be used if you’re sure
   there’s a user without context format support.

Varying the amount of context lines

   It is possible to make diff include less lines of context around the lines that should be
   changed. Especially in big patchfiles, this can strip away a lot of bytes and make your
   patchfile more portable. However, if you include too few lines of context, patch might not
   work correctly. Quoting the GNU diff man page: “For proper operation, patch typically needs
   at least two lines of context.”

   Specifying the amount of context lines can be done in multiple ways:
     * If you want to use the context format, you can combine it into one option, the -C
       option. Example:

     [rechosen@localhost ~]$ diff -C 2 originaldirectory/ updateddirectory/
       The above command would use the context format with 2 context lines.
     * If you want to use the unified format, you can combine it into one option, the -U
       option. Example:

     [rechosen@localhost ~]$ diff -U 2 originaldirectory/ updateddirectory/
       The above command would use the unified format with 2 context lines.
     * Regardless which format you choose, you can specify the number of lines like this:

     [rechosen@localhost ~]$ diff -2 originaldirectory/ updateddirectory/
       However, this will only work if you also specify a context-supporting format. You’d
       have to combine this option either with -c or -u.

Final words

   Although this tutorial describes a lot of features and workings of diff and patch, it does
   by far not describe everything you can do with these powerful tools. It is an introduction
   in the form of a tutorial. If you want to know more about these commands, you can read, for
   example, their manpages and [19]GNU’s documentation about diff and patch.

   

---
http://stackoverflow.com/questions/14296852/recursive-diff-to-create-a-patch-and-apply-patch-recursively

[26]recursive diff to create a patch and apply patch recursively

   I'm running into trouble using patch. I have 2 folders with many subfolders and files.

   diff -ur backup/www/ www/ > sync.patch

   Next, I'm trying to apply the patch.

   patch < sync.patch

   It asks me File to patch: as you can see.
|diff -ur ./backup/www/members/categorize.php ./www/members/categorize.php
|--- ./backup/www/members/categorize.php   2012-12-13 15:19:41.000000000 -0500
|+++ ./www/members/categorize.php   2012-10-15 23:32:12.000000000 -0400
--------------------------
File to patch:

   The file ./www/members/categorize.php exists.

***
1 Answer 1

   You probably need to investigate the -p flag for patch, which controls the way that
   directory prefixes are treated. See the [37]man page.

***   
   thanks, I used patch -t -p0 < sync.patch to apply the patches –  [41]Poe Jan 12 '13 at



---
http://stackoverflow.com/questions/8691345/how-to-recursively-create-patch-file-using-diff

[26]How to recursively create patch file using diff

   I am on Linux, working on forking a PHP project. I want to create a patch file of the work
   that I have done, that can be applied to the latest parental code. Both original folder and
   new code folder are many subdirectories deep (so need recursive).

   For some reason when I do :
diff -ur folder1 folder2 > newcode.patch

   I don't manage to get the patch file including all of the new files, and it doesn't even
   contain some of the deeper file changes ( about 3+ levels deep).

   Any ideas how to go about this? I've looked at Meld and Kdiff3...but they don't appear to
   do what I want either.

***   
3 Answers 3

I suspect you have a directory structure that's something like :

folder1/
  text.txt
  level1/
    text1.txt
    level2/
      text2.txt
      level3/
        text3.txt

folder2
  text.txt
  level1/
    text1.txt
    level2/
      text2.txt
      anewdirectory/
        newtext.txt
      level3/
        text3.txt
        newfiled3.txt

   In this case, diff will ignore the file newtext.txt within anewdirectory/. It probably also
   doesn't pick up the text of newfiled3.txt either. Instead it reports something like :
..
Only in folder2/level1/level2/ : anewdirectory
Only in folder2/level1/level2/level3/ : newfiled3.txt
..

   Is this the symptom you're seeing?
   Try :
diff -urBNs folder1/ folder2/ > code.patch

***
   AHA! I had tried with -urBNs... but the answer lies in the trailing slash after the folder
   name, which your example uses! Thanks Katyhuff ++ –  [41]Onyx Jan 1 '12 at 2:00

***   
   Sure thing. Thanks for the upvote. –  [42]katyhuff Jan 1 '12 at 2:03

***   
   If diff -r is not working as described in the man page, it's clearly broken; however, I
   would create a local version control repository using the original code, and then, once
   you've committed that, commit the new code. Any version control system worth its salt will
   be able to create a patch between committed versions.

***   
   Thanks, I wondered about that...but was trying to keep life simple ;) –  [46]Onyx Jan 1 '12

***   
   I'm assuming the original project is under some version of source control. If so, there
   should be good tools built for that source control system that will let you create a patch.
   For example, if the source control system is Subversion (SVN), and you're on Windows, you
   can use TortoiseSVN to build that patch.

   Don't reinvent the wheel.

***
   On Aptosid Linux. But will do as Kojiro suggests, and set up GIT, drag in the original,
   then the new code. –  [50]Onyx Jan 1 '12 at 1:20



---
http://linux.die.net/man/1/patch

patch(1) - Linux man page

Name

   patch - apply a diff file to an original

Synopsis

   patch [options] [originalfile [patchfile]]

   but usually just

   patch -pnum <patchfile

Description

   [INS: :INS]

   patch takes a patch file patchfile containing a difference listing produced by the diff
   program and applies those differences to one or more original files, producing patched
   versions. Normally the patched versions are put in place of the originals. Backups can be
   made; see the -b or --backup option. The names of the files to be patched are usually taken
   from the patch file, but if there's just one file to be patched it can be specified on the
   command line as originalfile.

   Upon startup, patch attempts to determine the type of the diff listing, unless overruled by
   a -c (--context), -e (--ed), -n (--normal), or -u (--unified) option. Context diffs
   (old-style, new-style, and unified) and normal diffs are applied by the patch program
   itself, while ed diffs are simply fed to the [2]ed(1) editor via a pipe.

   patch tries to skip any leading garbage, apply the diff, and then skip any trailing
   garbage. Thus you could feed an article or message containing a diff listing to patch, and
   it should work. If the entire diff is indented by a consistent amount, or if a context diff
   contains lines ending in CRLF or is encapsulated one or more times by prepending "- " to
   lines starting with "-" as specified by Internet RFC 934, this is taken into account. After
   removing indenting or encapsulation, lines beginning with # are ignored, as they are
   considered to be comments.

   With context diffs, and to a lesser extent with normal diffs, patch can detect when the
   line numbers mentioned in the patch are incorrect, and attempts to find the correct place
   to apply each hunk of the patch. As a first guess, it takes the line number mentioned for
   the hunk, plus or minus any offset used in applying the previous hunk. If that is not the
   correct place, patch scans both forwards and backwards for a set of lines matching the
   context given in the hunk. First patch looks for a place where all lines of the context
   match. If no such place is found, and it's a context diff, and the maximum fuzz factor is
   set to 1 or more, then another scan takes place ignoring the first and last line of
   context. If that fails, and the maximum fuzz factor is set to 2 or more, the first two and
   last two lines of context are ignored, and another scan is made. (The default maximum fuzz
   factor is 2.)

   Hunks with less prefix context than suffix context (after applying fuzz) must apply at the
   start of the file if their first line number is 1. Hunks with more prefix context than
   suffix context (after applying fuzz) must apply at the end of the file.

   If patch cannot find a place to install that hunk of the patch, it puts the hunk out to a
   reject file, which normally is the name of the output file plus a .rej suffix, or # if .rej
   would generate a file name that is too long (if even appending the single character # makes
   the file name too long, then # replaces the file name's last character).

   The rejected hunk comes out in unified or context diff format. If the input was a normal
   diff, many of the contexts are simply null. The line numbers on the hunks in the reject
   file may be different than in the patch file: they reflect the approximate location patch
   thinks the failed hunks belong in the new file rather than the old one.

   As each hunk is completed, you are told if the hunk failed, and if so which line (in the
   new file) patch thought the hunk should go on. If the hunk is installed at a different line
   from the line number specified in the diff, you are told the offset. A single large offset
   may indicate that a hunk was installed in the wrong place. You are also told if a fuzz
   factor was used to make the match, in which case you should also be slightly suspicious. If
   the --verbose option is given, you are also told about hunks that match exactly.

   If no original file origfile is specified on the command line, patch tries to figure out
   from the leading garbage what the name of the file to edit is, using the following rules.

   First, patch takes an ordered list of candidate file names as follows:
   •
          If the header is that of a context diff, patch takes the old and new file names in
          the header. A name is ignored if it does not have enough slashes to satisfy the
          -pnum or --strip=num option. The name /dev/null is also ignored.
          •
          If there is an Index: line in the leading garbage and if either the old and new
          names are both absent or if patch is conforming to POSIX , patch takes the name in
          the Index: line.
          •
          For the purpose of the following rules, the candidate file names are considered to
          be in the order (old, new, index), regardless of the order that they appear in the
          header.
   Then patch selects a file name from the candidate list as follows:
   •
          If some of the named files exist, patch selects the first name if conforming to
          POSIX , and the best name otherwise.
          •
          If patch is not ignoring RCS , ClearCase, Perforce, and SCCS (see the -g num or
          --get=num option), and no named files exist but an RCS , ClearCase, Perforce, or
          SCCS master is found, patch selects the first named file with an RCS , ClearCase,
          Perforce, or SCCS master.
          •
          If no named files exist, no RCS , ClearCase, Perforce, or SCCS master was found,
          some names are given, patch is not conforming to POSIX , and the patch appears to
          create a file, patch selects the best name requiring the creation of the fewest
          directories.
          •
          If no file name results from the above heuristics, you are asked for the name of the
          file to patch, and patch selects that name.
   To determine the best of a nonempty list of file names, patch first takes all the names
          with the fewest path name components; of those, it then takes all the names with the
          shortest basename; of those, it then takes all the shortest names; finally, it takes
          the first remaining name.
          Additionally, if the leading garbage contains a Prereq: line, patch takes the first
          word from the prerequisites line (normally a version number) and checks the original
          file to see if that word can be found. If not, patch asks for confirmation before
          proceeding.
          The upshot of all this is that you should be able to say, while in a news interface,
          something like the following:
   | patch -d /usr/src/local/blurfl
   and patch a file in the blurfl directory directly from the article containing the patch.
          If the patch file contains more than one patch, patch tries to apply each of them as
          if they came from separate patch files. This means, among other things, that it is
          assumed that the name of the file to patch must be determined for each diff listing,
          and that the garbage before each diff listing contains interesting things such as
          file names and revision level, as mentioned previously.

Options

   -b or --backup
          Make backup files. That is, when patching a file, rename or copy the original
          instead of removing it. When backing up a file that does not exist, an empty,
          unreadable backup file is created as a placeholder to represent the nonexistent
          file. See the -V or --version-control option for details about how backup file names
          are determined.
   --backup-if-mismatch
          Back up a file if the patch does not match the file exactly and if backups are not
          otherwise requested. This is the default unless patch is conforming to POSIX .
   --no-backup-if-mismatch
          Do not back up a file if the patch does not match the file exactly and if backups
          are not otherwise requested. This is the default if patch is conforming to POSIX .
   -B pref or --prefix=pref
          Use the simple method to determine backup file names (see the -V method or
          --version-control method option), and append pref to a file name when generating its
          backup file name. For example, with -B /junk/ the simple backup file name for
          src/patch/util.c is /junk/src/patch/util.c.
   --binary
          Write all files in binary mode, except for standard output and /dev/tty. When
          reading, disable the heuristic for transforming CRLF line endings into LF line
          endings. (On POSIX -conforming systems, reads and writes never transform line
          endings. On Windows, reads and writes do transform line endings by default, and
          patches should be generated by diff --binary when line endings are significant.)
   -c or --context
          Interpret the patch file as a ordinary context diff.
   -d dir or --directory=dir
          Change to the directory dir immediately, before doing anything else.
   -D define or --ifdef=define
          Use the #ifdef ... #endif construct to mark changes, with define as the
          differentiating symbol.
   --dry-run
          Print the results of applying the patches without actually changing any files.
   -e or --ed
          Interpret the patch file as an ed script.
   -E or --remove-empty-files
          Remove output files that are empty after the patches have been applied. Normally
          this option is unnecessary, since patch can examine the time stamps on the header to
          determine whether a file should exist after patching. However, if the input is not a
          context diff or if patch is conforming to POSIX , patch does not remove empty
          patched files unless this option is given. When patch removes a file, it also
          attempts to remove any empty ancestor directories.
   -f or --force
          Assume that the user knows exactly what he or she is doing, and do not ask any
          questions. Skip patches whose headers do not say which file is to be patched; patch
          files even though they have the wrong version for the Prereq: line in the patch; and
          assume that patches are not reversed even if they look like they are. This option
          does not suppress commentary; use -s for that.
   -F num or --fuzz=num
          Set the maximum fuzz factor. This option only applies to diffs that have context,
          and causes patch to ignore up to that many lines in looking for places to install a
          hunk. Note that a larger fuzz factor increases the odds of a faulty patch. The
          default fuzz factor is 2, and it may not be set to more than the number of lines of
          context in the context diff, ordinarily 3.
   -g num or --get=num
          This option controls patch's actions when a file is under RCS or SCCS control, and
          does not exist or is read-only and matches the default version, or when a file is
          under ClearCase or Perforce control and does not exist. If num is positive, patch
          gets (or checks out) the file from the revision control system; if zero, patch
          ignores RCS , ClearCase, Perforce, and SCCS and does not get the file; and if
          negative, patch asks the user whether to get the file. The default value of this
          option is given by the value of the PATCH_GET environment variable if it is set; if
          not, the default value is zero.
   --help
          Print a summary of options and exit.
   -i patchfile or --input=patchfile
          Read the patch from patchfile. If patchfile is -, read from standard input, the
          default.
   -l or --ignore-whitespace
          Match patterns loosely, in case tabs or spaces have been munged in your files. Any
          sequence of one or more blanks in the patch file matches any sequence in the
          original file, and sequences of blanks at the ends of lines are ignored. Normal
          characters must still match exactly. Each line of the context must still match a
          line in the original file.
   --merge
          Merge a patch file into the original files similar to [3]merge(1). If a conflict is
          found, patch outputs a warning and brackets the conflict with <<<<<<< and >>>>>>>
          lines. A typical conflict will look like this:
<<<<<<<
lines from the original file
=======
lines from the patch
>>>>>>>

          If there are conflicts, the user should edit the result and delete one of the
          alternatives. This option implies --forward and does not take the --fuzz=num option
          into account.
   -n or --normal
          Interpret the patch file as a normal diff.
   -N or --forward
          Ignore patches that seem to be reversed or already applied. See also -R.
   -o outfile or --output=outfile
          Send output to outfile instead of patching files in place. Do not use this option if
          outfile is one of the files to be patched. When outfile is -, send output to
          standard output, and send any messages that would usually go to standard output to
          standard error.
   -pnum or --strip=num
          Strip the smallest prefix containing num leading slashes from each file name found
          in the patch file. A sequence of one or more adjacent slashes is counted as a single
          slash. This controls how file names found in the patch file are treated, in case you
          keep your files in a different directory than the person who sent out the patch. For
          example, supposing the file name in the patch file was
          /u/howard/src/blurfl/blurfl.c
          setting -p0 gives the entire file name unmodified, -p1 gives
          u/howard/src/blurfl/blurfl.c
          without the leading slash, -p4 gives
          blurfl/blurfl.c
          and not specifying -p at all just gives you blurfl.c. Whatever you end up with is
          looked for either in the current directory, or the directory specified by the -d
          option.
   --posix
          Conform more strictly to the POSIX standard, as follows.
          •
          Take the first existing file from the list (old, new, index) when intuiting file
          names from diff headers.
          •
          Do not remove files that are empty after patching.
          •
          Do not ask whether to get files from RCS , ClearCase, Perforce, or SCCS .
          •
          Require that all options precede the files in the command line.
          •
          Do not backup files when there is a mismatch.
   --quoting-style=word
          Use style word to quote output names. The word should be one of the following:
   literal
          Output names as-is.
          shell
          Quote names for the shell if they contain shell metacharacters or would cause
          ambiguous output.
   shell-always
          Quote names for the shell, even if they would normally not require quoting.
          c
          Quote names as for a C language string.
          escape
          Quote as with c except omit the surrounding double-quote characters.
   You can specify the default value of the --quoting-style option with the environment
          variable QUOTING_STYLE. If that environment variable is not set, the default value
          is shell.
   -r rejectfile or --reject-file=rejectfile
          Put rejects into rejectfile instead of the default .rej file. When rejectfile is -,
          discard rejects.
   -R or --reverse
          Assume that this patch was created with the old and new files swapped. (Yes, I'm
          afraid that does happen occasionally, human nature being what it is.) patch attempts
          to swap each hunk around before applying it. Rejects come out in the swapped format.
          The -R option does not work with ed diff scripts because there is too little
          information to reconstruct the reverse operation.
          If the first hunk of a patch fails, patch reverses the hunk to see if it can be
          applied that way. If it can, you are asked if you want to have the -R option set. If
          it can't, the patch continues to be applied normally. (Note: this method cannot
          detect a reversed patch if it is a normal diff and if the first command is an append
          (i.e. it should have been a delete) since appends always succeed, due to the fact
          that a null context matches anywhere. Luckily, most patches add or change lines
          rather than delete them, so most reversed normal diffs begin with a delete, which
          fails, triggering the heuristic.)
   --reject-format=format
          Produce reject files in the specified format (either context or unified). Without
          this option, rejected hunks come out in unified diff format if the input patch was
          of that format, otherwise in ordinary context diff form.
   -s or --silent or --quiet
          Work silently, unless an error occurs.
   -t or --batch
          Suppress questions like -f, but make some different assumptions: skip patches whose
          headers do not contain file names (the same as -f); skip patches for which the file
          has the wrong version for the Prereq: line in the patch; and assume that patches are
          reversed if they look like they are.
   -T or --set-time
          Set the modification and access times of patched files from time stamps given in
          context diff headers, assuming that the context diff headers use local time. This
          option is not recommended, because patches using local time cannot easily be used by
          people in other time zones, and because local time stamps are ambiguous when local
          clocks move backwards during daylight-saving time adjustments. Instead of using this
          option, generate patches with UTC and use the -Z or --set-utc option instead.
   -u or --unified
          Interpret the patch file as a unified context diff.
   -v or --version
          Print out patch's revision header and patch level, and exit.
   -V method or --version-control=method
          Use method to determine backup file names. The method can also be given by the
          PATCH_VERSION_CONTROL (or, if that's not set, the VERSION_CONTROL) environment
          variable, which is overridden by this option. The method does not affect whether
          backup files are made; it affects only the names of any backup files that are made.
          The value of method is like the GNU Emacs 'version-control' variable; patch also
          recognizes synonyms that are more descriptive. The valid values for method are
          (unique abbreviations are accepted):
   existing or nil
          Make numbered backups of files that already have them, otherwise simple backups.
          This is the default.
   numbered or t
          Make numbered backups. The numbered backup file name for F is F.~N~ where N is the
          version number.
   simple or never
          Make simple backups. The -B or --prefix, -Y or --basename-prefix, and -z or --suffix
          options specify the simple backup file name. If none of these options are given,
          then a simple backup suffix is used; it is the value of the SIMPLE_BACKUP_SUFFIX
          environment variable if set, and is .orig otherwise.
   With numbered or simple backups, if the backup file name is too long, the backup suffix ~
          is used instead; if even appending ~ would make the name too long, then ~ replaces
          the last character of the file name.
   --verbose
          Output extra information about the work being done.
   -x num or --debug=num
          Set internal debugging flags of interest only to patch patchers.
   -Y pref or --basename-prefix=pref
          Use the simple method to determine backup file names (see the -V method or
          --version-control method option), and prefix pref to the basename of a file name
          when generating its backup file name. For example, with -Y .del/ the simple backup
          file name for src/patch/util.c is src/patch/.del/util.c.
   -z suffix or --suffix=suffix
          Use the simple method to determine backup file names (see the -V method or
          --version-control method option), and use suffix as the suffix. For example, with -z
          - the backup file name for src/patch/util.c is src/patch/util.c-.
   -Z or --set-utc
          Set the modification and access times of patched files from time stamps given in
          context diff headers, assuming that the context diff headers use Coordinated
          Universal Time ( UTC , often known as GMT ). Also see the -T or --set-time option.
          The -Z or --set-utc and -T or --set-time options normally refrain from setting a
          file's time if the file's original time does not match the time given in the patch
          header, or if its contents do not match the patch exactly. However, if the -f or
          --force option is given, the file time is set regardless.
          Due to the limitations of diff output format, these options cannot update the times
          of files whose contents have not changed. Also, if you use these options, you should
          remove (e.g. with make clean) all files that depend on the patched files, so that
          later invocations of make do not get confused by the patched files' times.

Environment

   PATCH_GET
          This specifies whether patch gets missing or read-only files from RCS , ClearCase,
          Perforce, or SCCS by default; see the -g or --get option.
   POSIXLY_CORRECT
          If set, patch conforms more strictly to the POSIX standard by default: see the
          --posix option.
   QUOTING_STYLE
          Default value of the --quoting-style option.
   SIMPLE_BACKUP_SUFFIX
          Extension to use for simple backup file names instead of .orig.
   TMPDIR, TMP, TEMP
          Directory to put temporary files in; patch uses the first environment variable in
          this list that is set. If none are set, the default is system-dependent; it is
          normally /tmp on Unix hosts.
   VERSION_CONTROL or PATCH_VERSION_CONTROL
          Selects version control style; see the -v or --version-control option.

Files

   $TMPDIR/p*
          temporary files
   /dev/tty
          controlling terminal; used to get answers to questions asked of the user

See Also

   [4]diff(1), [5]ed(1), [6]merge(1).

   Marshall T. Rose and Einar A. Stefferud, Proposed Standard for Message Encapsulation,
   Internet RFC 934 <URL:[7]ftp://ftp.isi.edu/in-notes/rfc934.txt> (1985-01).

Notes For Patch Senders

   There are several things you should bear in mind if you are going to be sending out
   patches.

   Create your patch systematically. A good method is the command diff -Naur old new where old
   and new identify the old and new directories. The names old and new should not contain any
   slashes. The diff command's headers should have dates and times in Universal Time using
   traditional Unix format, so that patch recipients can use the -Z or --set-utc option. Here
   is an example command, using Bourne shell syntax:

   LC_ALL=C TZ=UTC0 diff -Naur gcc-2.7 gcc-2.8

   Tell your recipients how to apply the patch by telling them which directory to cd to, and
   which patch options to use. The option string -Np1 is recommended. Test your procedure by
   pretending to be a recipient and applying your patch to a copy of the original files.

   You can save people a lot of grief by keeping a patchlevel.h file which is patched to
   increment the patch level as the first diff in the patch file you send out. If you put a
   Prereq: line in with the patch, it won't let them apply patches out of order without some
   warning.

   You can create a file by sending out a diff that compares /dev/null or an empty file dated
   the Epoch (1970-01-01 00:00:00 UTC ) to the file you want to create. This only works if the
   file you want to create doesn't exist already in the target directory. Conversely, you can
   remove a file by sending out a context diff that compares the file to be deleted with an
   empty file dated the Epoch. The file will be removed unless patch is conforming to POSIX
   and the -E or --remove-empty-files option is not given. An easy way to generate patches
   that create and remove files is to use GNU diff's -N or --new-file option.

   If the recipient is supposed to use the -pN option, do not send output that looks like
   this:

   diff -Naur v2.0.29/prog/README prog/README
   --- v2.0.29/prog/README Mon Mar 10 15:13:12 1997
   +++ prog/README Mon Mar 17 14:58:22 1997

   because the two file names have different numbers of slashes, and different versions of
   patch interpret the file names differently. To avoid confusion, send output that looks like
   this instead:

   diff -Naur v2.0.29/prog/README v2.0.30/prog/README
   --- v2.0.29/prog/README Mon Mar 10 15:13:12 1997
   +++ v2.0.30/prog/README Mon Mar 17 14:58:22 1997

   Avoid sending patches that compare backup file names like README.orig, since this might
   confuse patch into patching a backup file instead of the real file. Instead, send patches
   that compare the same base file names in different directories, e.g. old/README and
   new/README.

   Take care not to send out reversed patches, since it makes people wonder whether they
   already applied the patch.

   Try not to have your patch modify derived files (e.g. the file configure where there is a
   line configure: configure.in in your makefile), since the recipient should be able to
   regenerate the derived files anyway. If you must send diffs of derived files, generate the
   diffs using UTC , have the recipients apply the patch with the -Z or --set-utc option, and
   have them remove any unpatched files that depend on patched files (e.g. with make clean).

   While you may be able to get away with putting 582 diff listings into one file, it may be
   wiser to group related patches into separate files in case something goes haywire.

Diagnostics

   Diagnostics generally indicate that patch couldn't parse your patch file.

   If the --verbose option is given, the message Hmm... indicates that there is unprocessed
   text in the patch file and that patch is attempting to intuit whether there is a patch in
   that text and, if so, what kind of patch it is.

   patch's exit status is 0 if all hunks are applied successfully, 1 if some hunks cannot be
   applied or there were merge conflicts, and 2 if there is more serious trouble. When
   applying a set of patches in a loop it behooves you to check this exit status so you don't
   apply a later patch to a partially patched file.

Caveats

   Context diffs cannot reliably represent the creation or deletion of empty files, empty
   directories, or special files such as symbolic links. Nor can they represent changes to
   file metadata like ownership, permissions, or whether one file is a hard link to another.
   If changes like these are also required, separate instructions (e.g. a shell script) to
   accomplish them should accompany the patch.

   patch cannot tell if the line numbers are off in an ed script, and can detect bad line
   numbers in a normal diff only when it finds a change or deletion. A context diff using fuzz
   factor 3 may have the same problem. You should probably do a context diff in these cases to
   see if the changes made sense. Of course, compiling without errors is a pretty good
   indication that the patch worked, but not always.

   patch usually produces the correct results, even when it has to do a lot of guessing.
   However, the results are guaranteed to be correct only when the patch is applied to exactly
   the same version of the file that the patch was generated from.

Compatibility Issues

   The POSIX standard specifies behavior that differs from patch's traditional behavior. You
   should be aware of these differences if you must interoperate with patch versions 2.1 and
   earlier, which do not conform to POSIX .
   •
          In traditional patch, the -p option's operand was optional, and a bare -p was
          equivalent to -p0. The -p option now requires an operand, and -p 0 is now equivalent
          to -p0. For maximum compatibility, use options like -p0 and -p1.
   Also, traditional patch simply counted slashes when stripping path prefixes; patch now
          counts pathname components. That is, a sequence of one or more adjacent slashes now
          counts as a single slash. For maximum portability, avoid sending patches containing
          // in file names.
   •
          In traditional patch, backups were enabled by default. This behavior is now enabled
          with the -b or --backup option.
   Conversely, in POSIX patch, backups are never made, even when there is a mismatch. In GNU
          patch, this behavior is enabled with the --no-backup-if-mismatch option, or by
          conforming to POSIX with the --posix option or by setting the POSIXLY_CORRECT
          environment variable.
          The -b suffix option of traditional patch is equivalent to the -b -z suffix options
          of GNU patch.
   •
          Traditional patch used a complicated (and incompletely documented) method to intuit
          the name of the file to be patched from the patch header. This method did not
          conform to POSIX , and had a few gotchas. Now patch uses a different, equally
          complicated (but better documented) method that is optionally POSIX -conforming; we
          hope it has fewer gotchas. The two methods are compatible if the file names in the
          context diff header and the Index: line are all identical after prefix-stripping.
          Your patch is normally compatible if each header's file names all contain the same
          number of slashes.
          •
          When traditional patch asked the user a question, it sent the question to standard
          error and looked for an answer from the first file in the following list that was a
          terminal: standard error, standard output, /dev/tty, and standard input. Now patch
          sends questions to standard output and gets answers from /dev/tty. Defaults for some
          answers have been changed so that patch never goes into an infinite loop when using
          default answers.
          •
          Traditional patch exited with a status value that counted the number of bad hunks,
          or with status 1 if there was real trouble. Now patch exits with status 1 if some
          hunks failed, or with 2 if there was real trouble.
          •
          Limit yourself to the following options when sending instructions meant to be
          executed by anyone running GNU patch, traditional patch, or a patch that conforms to
          POSIX . Spaces are significant in the following list, and operands are required.
          -c
          -d dir
          -D define
          -e
          -l
          -n
          -N
          -o outfile
          -pnum
          -R
          -r rejectfile

Bugs

   Please report bugs via email to <[8]bug-patch@gnu.org>.

   If code has been duplicated (for instance with #ifdef OLDCODE ... #else ... #endif), patch
   is incapable of patching both versions, and, if it works at all, will likely patch the
   wrong one, and tell you that it succeeded to boot.

   If you apply a patch you've already applied, patch thinks it is a reversed patch, and
   offers to un-apply the patch. This could be construed as a feature.

   Computing how to merge a hunk is significantly harder than using the standard fuzzy
   algorithm. Bigger hunks, more context, a bigger offset from the original location, and a
   worse match all slow the algorithm down.

Copying

   Copyright © 1984, 1985, 1986, 1988 Larry Wall.
   Copyright © 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2009 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this manual provided the
   copyright notice and this permission notice are preserved on all copies.

   Permission is granted to copy and distribute modified versions of this manual under the
   conditions for verbatim copying, provided that the entire resulting derived work is
   distributed under the terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this manual into another
   language, under the above conditions for modified versions, except that this permission
   notice may be included in translations approved by the copyright holders instead of in the
   original English.

Authors

   Larry Wall wrote the original version of patch. Paul Eggert removed patch's arbitrary
   limits; added support for binary files, setting file times, and deleting files; and made it
   conform better to POSIX . Other contributors include Wayne Davison, who added unidiff
   support, and David MacKenzie, who added configuration and backup support. Andreas
   Grünbacher added support for merging.
