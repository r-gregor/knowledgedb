http://www.tldp.org/HOWTO/archived/Loopback-Root-FS/Loopback-Root-FS-5.html

...

***
Mount a temporary ram partition
Makes a partition in ram which is useful if you need a temporary working space as read/write access is fast.
Be aware that anything saved in this partition will be gone after your computer is turned off.

$> mount -t tmpfs tmpfs /mnt -o size=1024m

---
﻿filename: howto-speed-up-things-by-using-tmpfs_20151223.txt
http://docs.gz.ro/node/212

How to speed up things by using tmpfs
Submitted by root on Mon, 06/09/2014 - 23:50

You may know (or not) that /dev/shm/ is a direct read/write access to your memory (RAM). So everything you
copy to that place is in fact stored in your RAM, hence, it is turbocharged fast!

By default, the size of /dev/shm/ is half the memory size so if you have 8G of ram, this filesystem will
have 4G:

core:shm# df -h .
Filesystem            Size  Used Avail Use% Mounted on
tmpfs                 4.0G     0  4.0G   0% /dev/shm

core:shm# cat /proc/meminfo | grep MemTotal
MemTotal:        8190552 kB

If you want to make this fs bigger (do it at your own risk - remember, this is in your RAM):
core:shm# mount -o remount,size=6G /dev/shm

Heck, you can also create a different volume group like the default one:
core:shm# mkdir -p /my/superfast/application/ramstorage
core:shm# mount -t tmpfs -o size=500M,mode=0744 tmpfs /my/superfast/application/ramstorage

If you want this after reboot, do not forget to add it to /etc/fstab:
tmpfs /my/superfast/application/ramstorage tmpfs size=500M,mode=0777 0 0

Play as much as you want but remember something very important: tmpfs is volatile memory so after reboot
everything will disappear from there (will be gone forever). You may have to tweak things a bit like for
example copy the stuff to hard disk on shutdown and put them back on startup. Of course, if you need that
temporary file up2date, to back it up from time to time.filename: howto_create-linux-ram-disk-filesystem_multif_20151202.txt
http://www.cyberciti.biz/faq/howto-create-linux-ram-disk-filesystem/

Software RAM disks use the normal RAM in main memory as if it were a partition on a hard drive rather than
actually accessing the data bus normally used for secondary storage such as hard disk. How do I create
and store a web cache on a RAM disk to improve the speed of loading pages under Linux operating systems?

You can create the ram disk as follows (8192 = 8M, no need to format the ramdisk as a journaling file
system) :
# mkfs -q /dev/ram1 8192
# mkdir -p /ramcache
# mount /dev/ram1 /ramcache
# df -H | grep ramcache

Sample outputs:
/dev/ram1              8.2M   1.1M   6.7M  15% /ramcache
Next you copy images or caching objects to /ramcache
# cp /var/www/html/images/*.jpg /ramcache

Now you can edit Apache or squid reverse proxy to use /ramcache to map to images.example.com:

<VirtualHost 1.2.3.4:80>
     ServerAdmin admin@example.com
     ServerName images.example.com
     DocumentRoot /ramcache
     #ErrorLog /var/logs/httpd/images.example.com_error.log
     #CustomLog /var/logs/httpd/images.example.com_access.log combined
</VirtualHost>

Reload httpd:
# service httpd reload

Now all hits to images.example.com will be served from the ram. This can improve the speed of loading
pages or images. However, if server rebooted all data will be lost. So you may want to write /etc/init.d/
script to copy back files to /ramcache. Create a script called initramcache.sh:

#!/bin/sh
mkfs -t ext2 -q /dev/ram1 8192
[ ! -d /ramcache ] && mkdir -p /ramcache
mount /dev/ram1 /ramcache
/bin/cp /var/www/html/images/*.jpg /ramcache

Call it from /etc/rc.local or create softlink in /etc/rc3.d/
# chmod +x /path/to/initramcache.sh
# echo '/path/to/initramcache.sh' >> /etc/rc.local

A Note About tmpfs
tmpfs is supported by the Linux kernel from version 2.4+. tmpfs (also known as shmfs) is a little different
from the Linux ramdisk. It allocate memory dynamically and by allowing less-used pages to be moved onto
swap space. ramfs, in contrast, does not make use of swap which can be an advantage or disadvantage in
many cases. See how to use tmpfs under Linux.



---
http://www.cyberciti.biz/tips/what-is-devshm-and-its-practical-usage.html

/dev/shm is nothing but implementation of traditional shared memory concept. It is an efficient means
of passing data between programs. One program will create a memory portion, which other processes (if
permitted) can access. This will result into speeding up things on Linux.

shm / shmfs is also known as tmpfs, which is a common name for a temporary file storage facility on
many Unix-like operating systems. It is intended to appear as a mounted file system, but one which uses
virtual memory instead of a persistent storage device.

If you type the mount command you will see /dev/shm as a tempfs file system. Therefore, it is a file
system, which keeps all files in virtual memory. Everything in tmpfs is temporary in the sense that no
files will be created on your hard drive. If you unmount a tmpfs instance, everything stored therein is
lost. By default almost all Linux distros configured to use /dev/shm:
$ df -h

Sample outputs:

Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/wks01-root
                      444G   70G  351G  17% /
tmpfs                 3.9G     0  3.9G   0% /lib/init/rw
udev                  3.9G  332K  3.9G   1% /dev
tmpfs                 3.9G  168K  3.9G   1% /dev/shm
/dev/sda1             228M   32M  184M  15% /boot
Nevertheless, where can I use /dev/shm?

You can use /dev/shm to improve the performance of application software such as Oracle or overall
Linux system performance. On heavily loaded system, it can make tons of difference. For example VMware
workstation/server can be optimized to improve your Linux host's performance (i.e. improve the performance
of your virtual machines).

In this example, remount /dev/shm with 8G size as follows:
# mount -o remount,size=8G /dev/shm

To be frank, if you have more than 2GB RAM + multiple Virtual machines, this hack always improves
performance. In this example, you will give you tmpfs instance on /disk2/tmpfs which can allocate 5GB
RAM/SWAP in 5K inodes and it is only accessible by root:
# mount -t tmpfs -o size=5G,nr_inodes=5k,mode=700 tmpfs /disk2/tmpfs

Where,
-o opt1,opt2 : Pass various options with a -o flag followed by a comma separated string of options. In
this examples, I used the following options:
remount : Attempt to remount an already-mounted filesystem. In this example, remount the system and
increase its size.
size=8G or size=5G : Override default maximum size of the /dev/shm filesystem. he size is given in bytes,
and rounded up to entire pages. The default is half of the memory. The size parameter also accepts a
suffix % to limit this tmpfs instance to that percentage of your pysical RAM: the default, when neither
size nor nr_blocks is specified, is size=50%. In this example it is set to 8GiB or 5GiB. The tmpfs
mount options for sizing ( size, nr_blocks, and nr_inodes) accept a suffix k, m or g for Ki, Mi, Gi
(binary kilo, mega and giga) and can be changed on remount.
nr_inodes=5k : The maximum number of inodes for this instance. The default is half of the number of your
physical RAM pages, or (on a machine with highmem) the number of lowmem RAM pages, whichever is the lower.
mode=700 : Set initial permissions of the root directory.
tmpfs : Tmpfs is a file system which keeps all files in virtual memory.

How do I restrict or modify size of /dev/shm permanently?
You need to add or modify entry in /etc/fstab file so that system can read it after the reboot. Edit,
/etc/fstab as a root user, enter:
# vi /etc/fstab

Append or modify /dev/shm entry as follows to set size to 8G

none      /dev/shm        tmpfs   defaults,size=8G        0 0
Save and close the file. For the changes to take effect immediately remount /dev/shm:
# mount -o remount /dev/shm

Verify the same:
# df -h

Recommend readings:
See man pages of mount regarding tmpfs options.
Details regarding tmpfs is available in /usr/share/doc/kernel-doc-/Documentation/filesystems/tmpfs.txt file.


---
http://www.jamescoyle.net/knowledge/951-the-difference-between-a-tmpfs-and-ramfs-ram-disk

THE DIFFERENCE BETWEEN A TMPFS AND RAMFS RAM DISK

Linux penguinThere are two file system types built into most modern Linux distributions which allow you
to create a RAM based storage area which can be mounted and used link a normal folder.

Before using this type of file system you must understand the benefits and problems of memory file system
in general, as well as the two different types. The two types of RAM disk file systems are tmpfs and
ramfs and each type has it’s own strengths and weaknesses.

See my other post for details on how to create a RAM disk in Linux.

What is a memory based file system (RAM disk)?
A memory based file system is something which creates a storage area directly in a computers RAM as if
it were a partition on a disk drive. As RAM is a volatile type of memory which means when the system is
restarted or crashes the file system is lost along with all it’s data.

The major benefit to memory based file systems is that they are very fast – 10s of times faster than
modern SSDs. Read and write performance is massively increased for all workload types. These types of fast
storage areas are ideally suited for applications which need repetitively small data areas for caching or
using as temporary space. As the data is lost when the machine reboots the data must not be  precious as
even scheduling backups cannot guarantee that all the data will be replicated in the even of a system crash.

tmpfs vs. ramfs
The two main RAM based file system types in Linux are tmpfs and ramfs. ramfs is the older file system
type and is largely replaced in most scenarios by tmpfs.

ramfs
ramfs creates an in memory file system which uses the same mechanism and storage space as Linux file system
cache. Running the command free in Linux will show you the amount of RAM you have on your system, including
the amount of file system cache in use. The below is an example of a 31GB of ram in a production server.

free -g
       total used free shared buffers cached
Mem:   31    29   2    0      0       8
-/+ buffers/cache: 20 11
Swap:  13    6	  7

Currently 8GB of file system cache is in use on the system. This memory is generally used by Linux to
cache recently accessed files so that the next time they are requested then can be fetched from RAM very
quickly. ramfs uses this same memory and exactly the same mechanism which causes Linux to cache files
with the exception that it is not removed when the memory used exceeds threshold set by the system.

ramfs file systems cannot be limited in size like a disk base file system which is limited by it’s
capacity. ramfs will continue using memory storage until the system runs out of RAM and likely crashes or
becomes unresponsive. This is a problem if the application writing to the file system cannot be limited
in total size. Another issue is you cannot see the size of the file system in df and it can only be
estimated by looking at the cached entry in free.

tmpfs
tmpfs is a more recent RAM file system which overcomes many of the drawbacks with ramfs. You can specify
a size limit in tmpfs which will give a ‘disk full’ error when the limit is reached. This behaviour
is exactly the same as a partition of a physical disk.

The size and used amount of space on  a tmpfs partition is also displayed in df. The below example shows
an empty 512MB RAM disk.

df -h /mnt/ramdisk
Filesystem Size Used Avail Use% Mounted on
tmpfs	   512M 0    512M  0%	/mnt/ramdisk

These two differences between ramfs and tmpfs make tmpfs much more manageable  however this is one
major drawback; tmpfs may use SWAP space. If your system runs out of physical RAM, files in your tmpfs
partitions may be written to disk based SWAP partitions and will have to be read from disk when the file
is next accessed. In some environments this can be seen as a benefit as you are less likely to get out
of memory exceptions as you could with ramfs because more ‘memory’ is available to use.

See my other post for details on how to create a RAM disk in Linux.



---
http://www.jamescoyle.net/how-to/943-create-a-ram-disk-in-linux

CREATE A RAM DISK IN LINUX

Linux penguinThere are many reasons for creating a memory based file system in Linux, not least of which
is to provide a near zero latency and extremely fast area to story files. A prime use of a RAM disk is
for application caching directories or work areas.

There are two main types of RAM disk which can be used in Linux and each have their own benefits and
weaknesses:

ramfs
tmpfs

See my other post for the differences between ramfs and tmpfs.

Check the amount of free RAM you have left on your machine before creating a RAM disk. Use the Linux
command free to see the unused RAM. The below is an example of a 31GB of ram in a production server.

free -g
       total used free shared buffers cached
Mem:   31    29   2    0      0       8
-/+ buffers/cache: 20 11
Swap:  13    6	  7

The free command shows the amount of RAM availale on your system in addition to the amount of memory used,
free and used for caching. SWAP space is also displayed and shows if your system is writing memory to disk.

Create a folder to use as a mount point for your RAM disk.

mkdir /mnt/ramdisk

Then use the mount command to create a RAM disk.

mount -t [TYPE] -o size=[SIZE] [FSTYPE] [MOUNTPOINT]

Substitute the following attirbutes for your own values:
[TYPE] is the type of RAM disk to use; either tmpfs or ramfs.
[SIZE] is the size to use for the file system. Remember that ramfs does not have a physical limit and
is specified as a starting size.
[FSTYPE] is the type of RAM disk to use; either tmpfs, ramfs, ext4, etc.

Example:
mount -t tmpfs -o size=512m tmpfs /mnt/ramdisk

You can add the mount entry into /etc/fstab to make the RAM disk persist over reboots. Remember however,
that the data will disappear each time the machine is restarted.

vi /etc/fstab

tmpfs	    /mnt/ramdisk tmpfs	 nodev,nosuid,noexec,nodiratime,size=1024M   0 0
filename: howto_ramdisk-usage-linux_multif_20151203.txt
http://minecraft.gamepedia.com/Tutorials/Ramdisk_enabled_server

Tutorials/Ramdisk enabled server

This tutorial is intended to give you a basic understanding of what a ramdisk is, what use it is for
Minecraft and how to make a Minecraft server use a ramdisk.

Contents  [hide]
1 Ramdisk Introduction
2 Advantages and Disadvantages
2.1 Advantages
2.2 Disadvantages
3 Why it makes sense for Minecraft servers
4 Basic Minecraft and ramdisk setup
4.1 GNU/Linux (Easy Way)
4.2 GNU/Linux (alternative)

Ramdisk Introduction
Conventionally, files and directories are stored on hard disk drives which, by today's standards, offer
a lot of space at mediocre data transfer rates (between 80MB/s and 200MB/s). Ramdisks are virtual file
systems (unlike HDDs which are hardware) that live completely inside the computer's RAM. They offer
significantly higher data transfer rates (between 3,000MB/s and 15,000MB/s) at the cost of volatility
(data will be lost after restarting the computer) and space (limited by the amount of RAM installed on
the system, including swap space). Many utilities however make it possible to backup Ramdisk data at
set intervals, and before the system is shut down, then load the last data when the system starts up.

Advantages and Disadvantages
Advantages
Very high transfer speed (data to application)
Very low seek time (searching between and in files)

Disadvantages
Ramdisks will be cleared when a system restarts
Unfeasible if the world size exceeds the available RAM
Why it makes sense for Minecraft servers

In a Minecraft server, one of the strongest bottlenecks are disk I/O related operations (e.g. chunk
management). By moving the data into the RAM, access times will be near instant and data transfer rates will
be significantly faster, making chunk loading and saving much faster operations. Since a Minecraft world
currently consists of very many chunk files, seek time is equally, if not more, important for overall speed.

Basic Minecraft and ramdisk setup
Make sure to back up your files before starting!

GNU/Linux (Easy Way)
A simple way to load a minecraft server into a ramdisk was posted on the Aimless Bits blog [1] on March
12, 2011. It involves modifying the server startup script available on the wiki and making some minor
changes to fstab. This guide fleshes out the process and makes some minor changes to Aimless Bits' script.

This quick guide assumes you have a user for loading minecraft, a minecraft directory and a server
running. It also helps to be familiar with the /etc/init.d/minecraft startup script.

Firstly, start by creating a directory for the ramdisk in your home directory,
i.e. "/home/username/minecraft_ramdisk".
To mount it as a ramdisk, simply edit your /etc/fstab/ file:
sudo nano /etc/fstab

Then add this line, making sure that the path is correct (username, dir name etc.)
tmpfs  /home/username/minecraft_ramdisk tmpfs  defaults,size=512m      0       0

The size of the ramdisk MUST be larger than the minecraft directory world. Make sure that you give
yourself some overhead.

Restart your computer. The ramdisk will now be loaded every time you restart. If you wish to load
immediately, type
mount -t tmpfs none /home/username/minecraft_ramdisk -o size=512m

It's now a matter of simply running a modified script that loads the files on the drive onto the server,
copies them back on a timely basis to prevent data loss, and does backups. Again, this is a modified
version of the script found at Aimless Bits.

If you have /etc/init.d/minecraft, delete it or overwrite it with this script. If you don't, make a new
text file, call it minecraft, and copy this script into it.

#!/bin/bash
# /etc/init.d/minecraft
# version 0.6 2012-02-25 (YYYY-MM-DD)

### BEGIN INIT INFO
# Provides:   minecraft
# Required-Start: $local_fs $remote_fs
# Required-Stop:  $local_fs $remote_fs
# Should-Start:   $network
# Should-Stop:    $network
# Default-Start:  2 3 4 5
# Default-Stop:   0 1 6
# Short-Description:    Minecraft server
# Description:    Starts the minecraft server
### END INIT INFO

#Settings
JARFILE='craftbukkit-beta_1.4.6-R0.3.jar'
USERNAME="minecraft"
MCSTORE="/home/$USERNAME/minecraft"
MCPATH="/home/$USERNAME/minecraft_ramdisk"
CPU_COUNT=1
INVOCATION="java -Xmx2048M -Xms2048M -server -jar $JARFILE -o false"
BACKUPPATH="/home/$USERNAME/minecraft_backups/"
WORLD=Asgarde


as_user() {
  if [ "`whoami`" == "$USERNAME" ] ; then
    bash -c "$1"
  else
    su - $USERNAME -c "$1"
  fi
}

mc_status() {
  ps aux |grep -F -v grep|grep -F -v SCREEN|grep -F --quiet $JARFILE
  return $?
}

mc_start() {
  if mc_status; then
    echo "Tried to start but $JARFILE was already running!"
  else
    echo "$JARFILE was not running... starting."
    if [ -d $MCSTORE/$WORLD.bak ]; then
      echo "last $WORLD.bak still exist, crashed warning! manual check required!!!"
      exit 1
    fi
    cd $MCPATH
    if [ ! -f "$MCPATH/$JARFILE" ]; then
      echo "Ram drive empty...  prepping."
      as_user "cp -R $MCSTORE/* $MCPATH/"
    fi
    as_user "cd $MCPATH && screen -dmS minecraft $INVOCATION"
    sleep 7
    if mc_status; then
      echo "$JARFILE is now running."
    else
      echo "Could not start $JARFILE."
    fi
  fi
}

mc_saveoff() {
  if mc_status; then
    echo "$JARFILE is running... suspending saves"
    TO_SCREEN="screen -p 0 -S minecraft -X eval 'stuff "
    as_user "$TO_SCREEN \"say SERVER BACKUP STARTING. Server going readonly...\"\015'"
    as_user "$TO_SCREEN \"save-off\"\015'"
    as_user "$TO_SCREEN \"save-all\"\015'"
    sync
    sleep 10
  else
    echo "$JARFILE was not running. Not suspending saves."
  fi
}

mc_saveon() {
  if mc_status; then
    echo "$JARFILE is running... re-enabling saves"
    TO_SCREEN="screen -p 0 -S minecraft -X eval 'stuff "
    as_user "$TO_SCREEN \"save-on\"\015'"
    as_user "$TO_SCREEN \"say SERVER BACKUP ENDED. Server going read-write...\"\015'"
  else
    echo "$JARFILE was not running. Not resuming saves."
  fi
}

mc_stop() {
  if mc_status; then
    echo "$JARFILE is running... stopping."
    TO_SCREEN="screen -p 0 -S minecraft -X eval 'stuff "
    as_user "$TO_SCREEN \"say SERVER SHUTTING DOWN IN 5 SECONDS. Saving map...\"\015'"
    as_user "$TO_SCREEN \"save-all\"\015'"
    sleep 5
    as_user "$TO_SCREEN \"stop\"\015'"
    sleep 5
  else
    echo "$JARFILE was not running."
  fi

  if mc_status; then
    echo "$JARFILE could not be shut down... still running."
  else
    echo "$JARFILE is shut down."
  fi
}


mc_update() {
  if mc_status; then
    echo "$JARFILE is running! Will not start update."
  else
    MC_SERVER_URL=http://minecraft.net/`wget -q -O - http://www.minecraft.net/download.jsp | grep
    minecraft_server.jar\</a\> | cut -d \" -f 2`
    as_user "cd $MCPATH && wget -q -O $MCPATH/minecraft_server.jar.update $MC_SERVER_URL"
    if [ -f $MCPATH/minecraft_server.jar.update ]; then
      if `diff $MCPATH/$JARFILE $MCPATH/minecraft_server.jar.update >/dev/null`
     then
       echo "You are already running the latest version of $JARFILE."
     else
       as_user "mv $MCPATH/minecraft_server.jar.update $MCPATH/$JARFILE"
       echo "Minecraft successfully updated."
      fi
    else
      echo "Minecraft update could not be downloaded."
    fi
  fi
}

mc_backup() {
   echo "Backing up minecraft files"
   as_user "tar zcf $BACKUPPATH/MCBKUP_`date "+%Y.%m.%d-%H"`.tar.gz $MCSTORE"
   echo "Backup complete"
}

mc_disksaverun() {
  if mc_status; then
    echo "Saving ramdrive to disk."
    if [ ! -f $MCPATH/$JARFILE ]; then
      echo "Error.. Minecraft not in ram"
    else
      if [ -d $MCSTORE/$WORLD.bak ]; then
        echo "last $WORLD.bak still exist, crashed warning! manual check required!!!"
        exit 1
      fi
      if [ -d $MCSTORE/$WORLD ]; then
        as_user "mv $MCSTORE/$WORLD $MCSTORE/$WORLD.bak"
      fi

      TO_SCREEN="screen -p 0 -S minecraft -X eval 'stuff "
      as_user "$TO_SCREEN \"save-off\"\015'"
      as_user "$TO_SCREEN \"save-all\"\015'"
      as_user "cp -R $MCPATH/* $MCSTORE/"
      as_user "$TO_SCREEN \"save-on\"\015'"

      if [ -d $MCSTORE/$WORLD.bak ]; then
        as_user "rm -r $MCSTORE/$WORLD.bak"
      fi
    fi
  else
    echo "Service is not running"
 fi

}

mc_disksavehalt() {
   echo "Saving ramdrive to disk."
   if [ ! -f $MCPATH/$JARFILE ]; then
     echo "Error.. Minecraft not in ram"
   else
     if [ -d $MCSTORE/$WORLD.bak ]; then
        echo "last $WORLD.bak still exist, crashed warning! manual check required!!!"
        exit 1
     fi
     if [ -d $MCSTORE/$WORLD ]; then
       as_user "mv $MCSTORE/$WORLD $MCSTORE/$WORLD.bak"
     fi

     echo "Saving, screen session closed"
     as_user "cp -R $MCPATH/* $MCSTORE/"

     if [ -d $MCSTORE/$WORLD.bak ]; then
       as_user "rm -r $MCSTORE/$WORLD.bak"
     fi
   fi
}


#Start-Stop here
case "$1" in
  start)
    mc_start
    ;;
  stop)
    mc_stop
    mc_disksavehalt
    ;;
  restart)
    mc_stop
    mc_disksavehalt
    mc_start
    ;;
  update)
    mc_stop
    mc_backup
    mc_update
    mc_start
    ;;
  backup)
    mc_disksaverun
    mc_saveoff
    mc_backup
    mc_saveon
    ;;
  disksavehalt)
    mc_disksavehalt
    ;;
  disksaverun)
    mc_disksaverun
    ;;
  status)
    if mc_status; then
      echo "$JARFILE is running."
    else
      echo "$JARFILE is not running."
    fi
    ;;
  *)
  echo "Usage: /etc/init.d/minecraft {start|stop|update|backup|status|restart|disksaverun}"
  exit 1
  ;;
esac

Move this script into your /etc/init.d/ directory, and make it executable:
mv /directory/wherefileis/filename /etc/init.d/minecraft
chmod a+x /etc/init.d/minecraft

Note: This script misses the command option that the other minecraft init script has on this website,
http://www.minecraftwiki.net/wiki/Server_startup_script Therefor I rewrote the script with the command code
in it, so ramdisk servers can also use th command thing to sync things without having to get another plugin
to schedule things: http://pastebin.com/4ynwL2js Hope someone can use this, if they need the command option.

You're almost done! This script behaves exactly like the standard startup script, only that it takes
care of loading and maintaining the ramdisk. You can also modify the script to use rsync instead of cp

"rsync -r -t $MCSTORE/ $MCPATH/"
in case you want to do other things, such as remote copying, but performance differences are probably
negligible unless you have very big worlds.

DO NOT SKIP THIS STEP. You need to add a crontab entry to save your world. See below for specific reasons,
but you run the risk of losing data if you don't do this. This script has two disk save functions,
disksavehalt and disksaverun. Disksavehalt assumes the screen session is closing or backing up, and thus
does not disable level saving. Do NOT call this function in crontab. Use disksave run instead. To do this
sudo crontab -e
Then add the line:

*/5 * * * * /etc/init.d/minecraft disksaverun
20 */6 * * * /etc/init.d/minecraft backup

The number represents how often in minutes should you save the world. If you feel like you have a robust
setup, power supply backups and the whole shebang, run this less frequently. Otherwise, stick to 5
minutes at the least!

The other line runs minecraft backup every 6 hours, at :20. Don't skimp on backups! You've been warned!

Hope this helps all those would be admins out there. Good luck!

GNU/Linux (alternative)
On most GNU/Linux distributions there is already a ramdisk set up (usually mounted to /dev/shm (shared
memory)) which defaults to using at most half of your total installed RAM. If there is not one already
set up, resources on how to do it are widely available on the Internet.

It is possible to move anything into the ramdisk, but here I will focus on just moving the map into it
and leaving the server files on the conventional drive.

Given the following basic server directory "minecraft_server/", inside a user's home directory, containing
the world "world" and all other required files

~/minecraft_server/
world/
minecraft_server.jar
server.log
server.properties
...

We will want to move "world/" into the shared memory. Because of the volatility of ramdisks, we will also
want to create a new folder into which an automated script will periodically save the current snapshot
of the world, called (for example) "world_storage" by copying the current world to a new name

$ cd ~/minecraft_server/
$ cp -r world/ world_storage/

Now with the old world in a safe location, we can go ahead and move the world into the ram-disk

$ mkdir /dev/shm/minecraft
$ mv world/ /dev/shm/minecraft

By now, the world is loaded into the RAM, but the Minecraft server doesn't see it in its directory anymore,
causing it to recreate it when started. To stop it from doing that, we have to create a symbolic link
to the world in the ramdisk by running

$ ln -s /dev/shm/minecraft/world/ .

This will create a link to "/dev/shm/minecraft/world/" called "world/" in the server's directory, which
the server will use like the actual world folder, but now inside the RAM.

Now we need to take care of the volatility of the ramdisk, by periodically saving the world from the
RAM into "world_storage/". I'm going to use cron for scheduling and rsync for synching here.

First, we need a script that can be called by cron (it doesn't have to be a script, you could call rsync
directly from the cron command line, but this allows for easy customizing later on)

#!/bin/sh

VOLATILE="/home/$USER/minecraft_server/world/"
PERMANENT="/home/$USER/minecraft_server/world_storage/"

#TODO: Check if both directories actually exist, skipped here for clearness
rsync -r -t -v "$VOLATILE" "$PERMANENT"

And then we need to make this script execute every few minutes (I'll use 5 minutes here, you can test
out what works best for you)

$ crontab -e
You will be put into an editor (more precisely: the editor in your "EDITOR" environment variable) for
editing your user cron table. Add the following line:

*/5 * * * * bash /home/<your_username>/minecraft_server/save_world.sh &>/dev/null

Now if your server restarts you will need to recreate the world folder (/dev/shm/minecraft) then
(/dev/shm/minecraft/world) in the shared memory because the /dev/shm/ empties after restart,. You can
do this by making another similar shell script.

So make a shell script file like before:

exec 1>/tmp/backup_world.log 2>&1 #sends the output to this file
#!/bin/sh
#remake the paths
mkdir /dev/shm/minecraft
mkdir /dev/shm/minecraft/world

VOLATILE="/home/$USER/minecraft_server/world/"
PERMANENT="/home/$USER/minecraft_server/world_storage/"

#TODO: Check if both directories actually exist, skipped here for clearness
#reversed the order
rsync -r -t -v "$PERMANENT" "$VOLATILE"

Everytime you restart you need to run this script to remount the Ramdisk. Do not add this to the
crontab. You can add this to the start up if you figure it out.



---
http://superuser.com/questions/870763/mysql-data-on-ramdisk-partition

MySQL data on ramdisk partition
I'm using Docker with Ubuntu for my CI and development environment. I would like to put the database on
a ramdisk partition to speed up the builds, since I have to reload my fixtures a lot, so data persistence
isn't an issue here.

Is that possible? What steps I should add to my Docker file?

***
Here is excerpt from my post in the DBA StackExchange

RAMDISK_SIZE=32g
service mysql stop
mkdir /var/tmpfs
echo "none   /var/tmpfs  tmpfs  defaults,size=${RAMDISK_SIZE} 1 2" >> /etc/fstab
mount -t tmpfs -o size=${RAMDISK_SIZE} none /var/tmpfs
cp -R /var/lib/mysql/* /var/tmpfs
mv /var/lib/mysql /var/lib/mysql_old
ln -s /var/tmpfs /var/lib/mysql
chown -R mysql:mysql /var/tmpfs
chown -R mysql:mysql /var/lib/mysql
service mysql start
I hope you can apply it to Ubuntu

Give it a Try !!!



---
http://blog.csdn.net/wang_xya/article/details/43410651

Ubuntu using Ramdisk for better performance and fast response
ubunturamdisk
2015-02-02 16:56 217

Ubuntu using Ramdisk for better performance and fast response
I have written a tutorial about speed up Ubuntu response time by optimizing the usage of swap area, and
that’s avoiding swapping processes out of physical memory for as long as possible. Here’s another
way using ramdisk to get better performance and fast response for Ubuntu.

Ramdisk is part of system memory. Ubuntu by default uses a half of physical memory (RAM) as ramdisk,
and it is mounted onto /dev/shm, it can be used just like normal disk space (create files and folders and
manipulate them with better performance rather if they were stored on the hard disk). If ramdisk uses more
than a half of RAM, data will be moved into the swap space. If ramdisk uses less, the remaining can still do
what RAM’s doing.

Set upper limit of ramdisk
As is said above, ramdisk by default can use a half of RAM. If you want to change the upper limit,
follow the steps below:

1. Edit /etc/fstab by your favourate editor:
gksudo gedit /etc/fstab

2. Find this line and change to make it looks like this(add this line if not exist, and change 512M to
what you like.):
tmpfs /dev/shm tmpfs defaults,size=512M 0 0

3. Reboot or re-mount
/dev/shm
.

Mount /tmp onto ramdisk
To make it easy to use, you can mount a directory into
/dev/shm

by following commands:
mkdir /dev/shm/tmp
chmod 1777 /dev/shm/tmp
mount --bind /dev/shm/tmp /tmp


---
filename: ram-cache-and-tmpfs-speddup-linux_multif_20151222.txt

http://fixmynix.com/speed-up-firefox-with-ram-cache-and-tmpfs-linux/

Speed up firefox with RAM cache and tmpfs in Linux
BY ARNAB · JULY 29, 2015

Firefox, the second most popular web browser, the default pre installed browser in many GNU/Linux
distributions. It is really great in terms of it’s customization capability and large collection
of add-ons.

Though many users find firefox frustratingly slow and sluggish, so they switch to other browsers like google
chrome/Chromium etc. There are many reasons for it’s sluggish performance, like storing cache to disk,
using slow sqlite databases, frequent disk access by other processes, no DNS cache and like so many of them.

But there are many of ways to make it faster and improve page load time. In this tutorial we are going
to do this by modifying the firefox about:config configurations, moving all profile data to a tmpfs
partition on RAM and moving the cache to RAM instead of hard disk. This guide will work all GNU/Linux
Distributions like Ubuntu, Fedora, Debian, Arch Linux etc. etc.

optimize the about:config configurations
Open up firefox, type about:config in the URL bar , hit Enter and press the I’ll be careful, I
promise! button, now you can edit the configurations. Use the search bar to find configurations easily.

speed up firefox linux about:config
Search for browser.cache.use_new_backend , if the value is 0 , modify it to 1 , this makes the caching
efficient.
Search for network.http.pipelining.ssl toggle it value to true .
Search for network.http.pipelining , toggle the value to true .
Search for network.http.proxy.pipelining , toggle its value to true .
Search for network.http.pipelining.maxrequests , modify the value , set any thing above 100 , like 120 .
If you are not using IPv6, then search for network.dns.disableIPv6  and toggle its value to true .
Search for browser.safebrowsing.enabled and browser.safebrowsing.malware.enabled , toggle the value to
false, in both of them, though this is a little bit dangerous.


move the cache to RAM
As RAM is much much more faster than hard disk, so moving cache to RAM will increase the user experience
greatly. Recent computers have plenty of RAM, at least 4 GB in most cases, so moving the cache to RAM
will not be a problem. But avoid this if you have less than 1 GB RAM.

Again, open up firefox and type about:config in the URL bar, hit Enter and press the I’ll be careful,
I promise! button. Now edit few thing in this section.
Search for browser.cache.disk.enable  in the filter bar, toggle the value to false , this will disable
cache to disk.
Now it is the time to enable cache to RAM, search for browser.cache.memory.enable , if the
value is true leave it else toggle it to true.Now assign how much memory could be used as
RAM cache, search for browser.cache.memory.capacity , if not found create it.speed up firefox
browser.cache.memory.capacityRight click on blank area, then select “New” > “Integer”  , set the
preference name browser.cache.memory.capacity , enter the integer value in KB, like 204800 for 200 MB ,
and done . Check it with about:cache .
finally move profile data to a tmpfs partition

Finally move all profile data to a tmpfs partition on RAM , tmpfs is a incredibly fast special type of
file system that uses a part of RAM to store data. Firefox stores almost every information in SQLite
databases, but SQLite is inheriently slow and disk I/O dependent. This process will make firefox blazing
fast and disk I/O independent.

1. clear all cache and cookies
perhaps you know how to do that, if not, click Edit > Preferances go to Privacy and clear cookies,
then go to Advanced > Network clear Cached Web Content and done !

2. backup default profile data
Create a backup archive of your current data, before doing this close Firefox and look at the commands
bellow.

cd .mozilla/firefox/

cp -a profile_name.default/ profile.bac

rm -rf profile_name.default/*
must replace profile folder name with your own profile folder name.  This will create a folder named
profile.bac containing all profile data and clear all data inside the default profile folder.

3. mount the tmpfs on profile folder
add the line bellow to the /etc/fstab file,

tmpfs /home/$USER/.mozilla/firefox/profile_name.default tmpfs size=128M,user,exec,uid=1000,gid=1000 0 0
my firefox default profile name was p3iyxcse.default , so the line at /etc/fstab looks like bellow.

tmpfs /home/b00m/.mozilla/firefox/p3iyxcse.default tmpfs size=128M,user,exec,uid=1000,gid=1000 0 0
Make sure that the /home/$USER/.mozilla/firefox/profile_name.default directory exists, otherwise tmpfs
mounting will fail .

Now mount the tmpfs at profile directory , i.e. at /home/$USER/.mozilla/firefox/profile_name.default
and copy all the backup data to the default profile folder.

sudo mount -a

cd .mozilla/firefox/

cp -a profile.bac/* profile_name.default/
Do not forget to replace profile_name.default with your own profile name. And now start firefox, if you
have a slow HDD like me, then you will notice a much faster start up time and no sluggish performance .

4. sync any changes to the profile folder with the backup folder
In order to keep the changes intact after a reboot or shutdown, we need to sync the profile folder with
the backup folder time to time. To do this without any user interaction in later, save the script bellow
as ff_profile_sync and add it to crontab  . Before doing this if you do not have rsync , run sudo apt-get
install rsync for Ubuntu/Debian /Linux Mint etc.the script

#!/bin/sh
cd /home/$USER/.mozilla/firefox/
if test -d *.default;then
if test -d profile.bac;then
rsync -a --delete *.default/ profile.bac/
fi;fi
Do not forget to replace $USER with your username, save this script at /usr/local/bin or wherever you
like, make it executable , and add to crontab with crontab -e , set the cron interval 5-10 minuite or
whatever you like.

crontab -e
put the line bellow for a 5 minuite  update interval .

*/5 * * * * /usr/local/bin/ff_profile_sync > /dev/null 2>&1
Finally add the line bellow to the /etc/rc.local file just before the exit 0 , to restore the previous
changes after a reboot .

cp -a /home/$USER/.mozilla/firefox/profile.bac/* /home/$USER/.mozilla/firefox/profile_name.default/
Again, Do not forget to replace $USER with your username and profile_name with your firefox profile name.

This setup will backup all changed profle data to the profile.bac folder automatically, so forgot about
it , and enjoy super fast firefox.

If you have any question or need further assistance just leave a comment, we’d be happy to assist you.
Feel free to share this tutorial with your friends.


---
https://www.joeyconway.com/blog/2011/09/11/ubuntu-ssd-move-chrome-cache-to-ram/

Ubuntu – Move Google Chrome cache from SSD to RAM
Posted on September 11, 2011 by joey — 2 Comments ↓
Running an SSD for the main boot partition is quite convenient for any OS, including Ubuntu. However
having Google Chrome, or any browser, store its cache on the SSD is not the ideal scenario.
Under Ubuntu Natty 11.04 moving Google Chrome’s cache to RAM is fairly simple and only takes a few
commands. The advantages to storing the web browser cache in RAM are: quicker reads/writes than on disk
drives, no wear and tear on disk drives and the cache will be erased on reboot. The disadvantages are:
the cache will be erased on reboot and will consume RAM, which can be limited on some systems.

1) Decide where to move the Chrome cache location to. I’ve picked the following location: /tmp/chrome.
This directory, /tmp/chrome will need to be created on boot and properly setup.
On Ubuntu 11.04 and probably older versions, this can be simply done in the /etc/rc.local file as follows:
sudo gedit /etc/rc.local
Add the following lines:
mkdir /tmp/chrome
mount -t tmpfs -o size=1024M,mode=0744 tmpfs /tmp/chrome/
chmod 777 /tmp/chrome/ -R

There are two ways to accomplish the next and last step. One is to create a symlink between the default
google cache directory and the new temporary cache directory in RAM. The second is to add a switch to
the google chrome command line telling each instance of the application to use our newly created cache
directory in RAM.
1) rm -rf ~/.cache/google-chrome
ln -s /tmp/chrome/ ~/.cache/google-chrome
OR
2) Change the default here: sudo gedit /usr/local/share/applications/google-chrome.desktop
Replace the line:
#Exec=/opt/google/chrome/google-chrome %U
with
Exec=/opt/google/chrome/google-chrome –disk-cache-dir=”/tmp/chrome/”

The only adjustment some might want to make will be the size of the tmpfs partition created in RAM. I
set the size to 1024MB as I don’t ever want to have to worry about it or adjust it. For systems with
a lot of RAM the above size should not be an issue.

Used the following main sources:
Firefox & Chrome Cache on RAM Drive -Fedora / Ubuntu
How To Change Google Chrome’s Cache Location And Size

‹ Android – Custom Recovery Code ResearchUbuntu – Move /home partition from SSD to RAID ›
Posted in Technology Tagged with: ubuntu, natty, 11.04, 10.10, google chrome, ram, tmpfs, ramdisk, cache,
browser cache, mount, fstab, SSD, solid state disk, partition
2 comments on “Ubuntu – Move Google Chrome cache from SSD to RAM”

mike wilson says:
May 23, 2013 at 12:39 pm
Can you help me change it back to the default? I’m running ubuntu 12.04 on an acer c7.

joey says:
May 24, 2013 at 4:03 pm
Sure. The removal process will essentially be the opposite of the installation process. For installing
there are two main steps and for removing there will also be two main steps:
First, remove the tmpfs partition that is created on each boot by removing the three lines that were
added to the /etc/rc.local file.
Second, remove either the symlink and/or the flag added to the chrome execution command.
Hope that helps!


---
http://www.thegeekstuff.com/2008/11/overview-of-ramfs-and-tmpfs-on-linux/

Overview of RAMFS and TMPFS on Linux
[Linux Ramfs and Tmpfs]Using ramfs or tmpfs you can allocate part of the physical memory to be used as a
partition. You can mount this partition and start writing and reading files like a hard disk partition. Since
you?ll be reading and writing to the RAM, it will be faster.

When a vital process becomes drastically slow because of disk writes, you can choose either ramfs or tmpfs
file systems for writing files to the RAM.

Both tmpfs and ramfs mount will give you the power of fast reading and writing files from and to the primary
memory. When you test this on a small file, you may not see a huge difference. You?ll notice the difference
only when you write large amount of data to a file with some other processing overhead such as network.

1. How to mount Tmpfs
	# mkdir -p /mnt/tmp
	# mount -t tmpfs -o size=20m tmpfs /mnt/tmp

The last line in the following df -k shows the above mounted /mnt/tmp tmpfs file system.
	# df -k
	Filesystem      1K-blocks  Used     Available Use%  Mounted on
	/dev/sda2       32705400   5002488  26041576  17%   /
	/dev/sda1       194442     18567    165836    11%   /boot
	tmpfs           517320     0        517320    0%    /dev/shm
	tmpfs           20480      0        20480     0%    /mnt/tmp

2. How to mount Ramfs
	# mkdir -p /mnt/ram
	# mount -t ramfs -o size=20m ramfs /mnt/ram
	
The last line in the following mount command shows the above mounted /mnt/ram ramfs file system.
	# mount
	/dev/sda2 on / type ext3 (rw)
	proc on /proc type proc (rw)
	sysfs on /sys type sysfs (rw)
	devpts on /dev/pts type devpts (rw,gid=5,mode=620)
	/dev/sda1 on /boot type ext3 (rw)
	tmpfs on /dev/shm type tmpfs (rw)
	none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)
	sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw)
	fusectl on /sys/fs/fuse/connections type fusectl (rw)
	tmpfs on /mnt/tmp type tmpfs (rw,size=20m)
	ramfs on /mnt/ram type ramfs (rw,size=20m)

You can mount ramfs and tmpfs during boot time by adding an entry to the /etc/fstab.

3. Ramfs vs Tmpfs
Primarily both ramfs and tmpfs does the same thing with few minor differences.

  * Ramfs will grow dynamically.   So, you need control the process that writes the data to make sure ramfs
    doesn?t go above the available RAM size in the system. Let us say you have 2GB of RAM on your system and
    created a 1 GB ramfs and mounted as /tmp/ram. When the total size of the /tmp/ram crosses 1GB, you can
    still write data to it.   System will not stop you from writing data more than 1GB. However, when it goes
    above total RAM size of 2GB, the system may hang, as there is no place in the RAM to keep the data.
  * Tmpfs will not grow dynamically. It would not allow you to write more than the size you?ve specified
    while mounting the tmpfs. So, you don?t need to worry about controlling the process that writes the data
    to make sure tmpfs doesn?t go above the specified limit. It may give errors similar to ?No space left on
    device?.
  * Tmpfs uses swap.
  * Ramfs does not use swap.

4. Disadvantages of Ramfs and Tmpfs
Since both ramfs and tmpfs is writing to the system RAM, it would get deleted once the system gets rebooted,
or crashed. So, you should write a process to pick up the data from ramfs/tmpfs to disk in periodic
intervals. You can also write a process to write down the data from ramfs/tmpfs to disk while the system is
shutting down. But, this will not help you in the time of system crash.

                       Table: Comparison of ramfs and tmpfs
+--------------------------------------------------------------------------------+
|            Experimentation            |      Tmpfs       |        Ramfs        |
|---------------------------------------+------------------+---------------------|
|Fill maximum space and continue writing|Will display error|Will continue writing|
|---------------------------------------+------------------+---------------------|
|Fixed Size                             |Yes               |No                   |
|---------------------------------------+------------------+---------------------|
|Uses Swap                              |Yes               |No                   |
|---------------------------------------+------------------+---------------------|
|Volatile Storage                       |Yes               |Yes                  |
+--------------------------------------------------------------------------------+

If you want your process to write faster, opting for tmpfs is a better choice with precautions about the
system crash.

This article was written by SathiyaMoorthy. He is working at bksystems, interested in writing articles and  
contribute to open source in his leisure time. The Geek Stuff welcomes your tips and guest articles.


---
http://www.linuxfocus.org/English/November1999/article124.html

...

-------------------------------------------------------------------------------------------------------------
                              Webpages maintained by the LinuxFocus Editor team
                                              (C) Mark Nielsen
                                               LinuxFocus 1999
1999-11-01, generated by lfparser version 0.8
[ !!! OLD !!! ]filename: tmpfs_20150520.txt
https://wiki.archlinux.org/index.php/Tmpfs

tmpfs

   From ArchWiki
   Jump to: [12]navigation, [13]search

   [14]tmpfs is a temporary filesystem that resides in memory and/or your swap partition(s), depending
   on how much you fill it up. Mounting directories as tmpfs can be an effective way of speeding up
   accesses to their files, or to ensure that their contents are automatically cleared upon reboot.
   Note: When using [15]systemd, temporary files in tmpfs directories can be recreated at boot by using
   [16]tmpfiles.d.

Contents

     * [17]1 Usage
     * [18]2 Examples
     * [19]3 Disable automatic mount
     * [20]4 Troubleshooting
          + [21]4.1 Opening symlinks in tmpfs as root fails
     * [22]5 See also

Usage
   Some directories where tmpfs is commonly used are [23]/tmp, [24]/var/lock and [25]/var/run. Do not
   use it on [26]/var/tmp, because that folder is meant for temporary files that are preserved across
   reboots.

   [27]glibc 2.2 and above expects tmpfs to be mounted at /dev/shm for [28]POSIX shared memory. Mounting
   tmpfs at /dev/shm is handled automatically by [29]systemd, so manual configuration in [30]fstab is no
   longer necessary.

   Arch uses a tmpfs /run directory, with /var/run and /var/lock simply existing as symlinks for
   compatibility. It is also used for /tmp by the default systemd setup and does not require an entry in
   [31]fstab unless a specific configuration is needed.

   Generally, I/O intensive tasks and programs that run frequent read/write operations can benefit from
   using a tmpfs folder. Some applications can even receive a substantial gain by offloading some (or
   all) of their data onto the shared memory. For example, [32]relocating the Firefox profile into RAM
   shows a significant improvement in performance.

Examples
   By default, a tmpfs partition has its maximum size set to half your total RAM, but this can be
   customized. Note that the actual memory/swap consumption depends on how much you fill it up, as tmpfs
   partitions do not consume any memory until it is actually needed.

   To explicitly set a maximum size, in this example to override the default /tmp mount, use the size
   mount option:
/etc/fstab
tmpfs   /tmp         tmpfs   nodev,nosuid,size=2G          0  0

   Here is a more advanced example showing how to add tmpfs mounts for users. This is useful for
   websites, mysql tmp files, ~/.vim/, and more. It's important to try and get the ideal mount options
   for what you are trying to accomplish. The goal is to have as secure settings as possible to prevent
   abuse. Limiting the size, and specifying uid and gid + mode is very secure. For more information on
   this subject, follow the links listed in the [33]#See also section.
/etc/fstab
tmpfs   /www/cache    tmpfs  rw,size=1G,nr_inodes=5k,noexec,nodev,nosuid,uid=648,gid=648,mode=1700   0  0

   See the mount command man page for more information. One useful mount option in the man page is the
   default option. At least understand that.

   Reboot for the changes to take effect. Note that although it may be tempting to simply run mount -a
   to make the changes effective immediately, this will make any files currently residing in these
   directories inaccessible (this is especially problematic for running programs with lockfiles, for
   example). However, if all of them are empty, it should be safe to run mount -a instead of rebooting
   (or mount them individually).

   After applying changes, you may want to verify that they took effect by looking at /proc/mounts and
   using findmnt:
$ findmnt --target /tmp
TARGET SOURCE FSTYPE OPTIONS
/tmp   tmpfs  tmpfs  rw,nosuid,nodev,relatime

   The tmpfs can also be temporarily resized without the need to reboot, for example when a large
   compile job needs to run soon. In this case, you can run:
# mount -o remount,size=4G,noatime /tmp

Disable automatic mount
   Under [34]systemd, /tmp may be automatically mounted as a tmpfs even though you have no entry for
   that in your /etc/fstab.

   To disable the automatic mount, run:
# systemctl mask tmp.mount

   Files will no longer be stored in a tmpfs, but your block device instead. The /tmp contents will now
   be preserved between reboots, which you might not want. To regain the previous behavior and clean the
   /tmp folder automatically when restarting your machine, consider using tmpfiles.d(5):
/etc/tmpfiles.d/tmp.conf
# see tmpfiles.d(5)
# always enable /tmp folder cleaning
D! /tmp 1777 root root 0

# remove files in /var/tmp older than 10 days
D /var/tmp 1777 root root 10d

# namespace mountpoints (PrivateTmp=yes) are excluded from removal
x /tmp/systemd-private-*
x /var/tmp/systemd-private-*
X /tmp/systemd-private-*/tmp
X /var/tmp/systemd-private-*/tmp

Troubleshooting
Opening symlinks in tmpfs as root fails
   Considering /tmp is using tmpfs, change the current directory to /tmp, then create a file and create
   a symlink to that file in the same /tmp directory. If you try to open the file you created via the
   symlink, you will get a permission denied error. This is expected as /tmp [35]has the sticky bit set.

   This behaviour can be controlled via /proc/sys/fs/protected_symlinks or simply via sysctl: sysctl -w
   fs.protected_symlinks=0. See [36]Sysctl#Configuration to make this permanent.
   Warning: Changing this behaviour can lead to security issues! Disable it only if you know what you
   are doing.
filename: tmpfs_convert_h-264-AC3_mkv_to_h-264-AAC_mp4_20151222.txt
http://forums.fedoraforum.org/showthread.php?t=290195

[Howtp] Convert h.264/AC3 .mkv to h.264/AAC .mp4

If you are familiar with using BitTorrent to obtain certain ethically grey area high-def video files,
you are probably familiar with the Matroska Media Container, though you may only know it by the extension
.mkv at the end of the file.

Matroska Media Container can contain many different video/audio encodings, in fact the WebM standard
being pushed by Google for HTML5 video is actually a Matroska Media Container using VP8 stream for video
and Vorbis stream for audio.

Anyway, for certain video content commonly shared by BitTorrent, the video stream is h.264 and the audio
stream is Dolby 5.1 AC3.

There is nothing inherently wrong with that, that may be fine for you. Many media players can play
it. However, I like to repackage the .mkv into an MPEG-4 container, keeping the h.264 stream for video
but transcoding the Dolby stream to stereo encoded with AAC.

* My software media player of choice does not decode Dolby 5.1.
* The audio volume level seems to rarely be consistent. Transcoding gives me an opportunity to normalize
the audio so that I don't have to adjust the volume switch between media files.
* I can serve the media file over my LAN using html5 video
* My Bluray player on my TV usually plays the .mkv files just fine but sometimes complains they are
corrupt, my guess is sometimes the .mkv files break the standard in a way the Bluray player doesn't
compensate for. Repackaged as .mp4 it is never an issue.
* I never invested in surround sound, so I don't give a ***** about losing that.
* I'm paranoid that a software update to my bluray player will start checking checksum of media files
with a list known ethically grey area files and refuse to play if there's a match. Repackaging it means
a checksum match is highly unlikely.

The following shell script is what I have been using for years to turn .mkv files into .mp4 files. It
does assume the video stream is h.264 and the audio is Dolby AC3. That's not always the case and I should
fix it, but the torrent tracker I use, that is always the case.

Only "gotcha" is that it requires ffmpeg linked against libfaac and that can be hard to find pre-compiled,
you may have to build it from source. All other binaries used should be readily available for most
Linux distributions.

For Fedora 18, the rpmfusion repos have everything except ffmpeg linked against libfaac. But the src.rpm
will do it if you set a macro telling it to when you rebuild it.

Anyway, if turning .mkv into .mp4 is something that interests you (doesn't interest most), enjoy.

<code>
	#!/bin/bash

	base=`echo $1 |sed -e s?"\.mkv$"?""?`
	CWD=`pwd`
	TMP=`mktemp -d --tmpdir=/tmp`

	### This is fragile and can be done better ###
	n=`mkvinfo ${base}.mkv |grep "Track type" |grep -n "video" |cut -d":" -f1`
	vidTrack=`echo "${n} - 1" |bc`
	n=`mkvinfo ${base}.mkv |grep "Track type" |grep -n "audio" |cut -d":" -f1`
	audTrack=`echo "${n} - 1" |bc`
	### End Fragile ###

	mkvextract tracks ${base}.mkv ${vidTrack}:${TMP}/${base}.h264
	mkvextract tracks ${base}.mkv ${audTrack}:${TMP}/${base}.ac3

	pushd ${TMP}
	a52dec -o wavdolby ${base}.ac3 > tmp.wav
	rm -f ${base}.ac3
	# normalize the audio
	sox --norm tmp.wav -b 16 ${base}.wav rate 48000 dither
	rm -f tmp.wav
	# package in mpeg-4
	ffmpeg -i ${base}.h264 -i ${base}.wav -map 0:0 -map 1:0 \
	  -vcodec copy -acodec libfaac -ab 128k -y -f mp4 ${base}.mp4
	# fiv the MOOV atom for streaming and copy to original directory
	qt-faststart ${base}.mp4 ${CWD}/${base}.mp4
	popd
	rm -rf ${TMP}
</code>

I call it mkv2mp4.sh and keep it in ~/bin/

Use it like this:
	[user@host ~]$ mkv2mp4.sh Game.of.Thrones.S03E01.REPACK.720p.HDTV.x264-EVOLVE.mkv
	
End result will be identical filename but ending in .mp4 instead of .mkv

If /tmp is tmpfs - it is really fast.


---
http://ubuntuforums.org/archive/index.php/t-1939900.html

[SOLVED] Moving Files to memory

Ceiber Boy
March 12th, 2012, 10:22 PM
is it possible to 'store' files in memory? Hear me out!

I have a shed of memory and a slow HDD, so when transcoding large files, instead of trying to read and write to the HDD at the same time would it be quicker to move all the data to memory? I could then use my quad core CPU flat out. Avoiding the bottleneck of my HDD.

i am expecting one of three answers:
1, no, stop being silly.
2, yes but the specific program your using would have to be writtern to do so.
3, yes, this is how

Thanks.:p
Dave_L
March 12th, 2012, 10:34 PM
You can easily create a RAM disk.

Example of creating a 512mb RAM disk with mount point /tmp/ram:


mkdir -p /tmp/ram
sudo mount -t tmpfs -o size=512M tmpfs /tmp/ram/
Ceiber Boy
March 13th, 2012, 11:24 AM
You can easily create a RAM disk.

Example of creating a 512mb RAM disk with mount point /tmp/ram:


mkdir -p /tmp/ram
sudo mount -t tmpfs -o size=512M tmpfs /tmp/ram/


Brilliant. Thanks you Dave
Bucky Ball
March 13th, 2012, 11:32 AM
Ceiber Boy and others please take note; from the heading of this page:


The Community Chat area is for lighthearted and enjoyable discussions, like you might find around a water cooler at work.

This forum is not intended for problem-solving. Please use appropriate forums in future. Thanks. ;)
