filename: c_function-pointers-multif_20230403.txt
https://w3.cs.jmu.edu/kirkpams/OpenCSF/Books/csf/html/FunctionPointers.html

10.8. Function Pointers
   As we have seen, pointers have many uses in the C language. They can be used to provide indirect
   references to primitive types, form the basis of dynamically sized arrays, create instances of
   structs on demand, manipulate string data, and so on. One additional use of pointers is to create a
   reference to a function. That is, a function pointer is a variable that stores the address of a
   function. Readers who have previous experience with assembly language may recall that the name of a
   function is the same as a global label for an instruction. In other words, the name of a function is
   an alias for the address of the first instruction in the function's body. A function pointer, then,
   stores this address.

   To get started with function pointers, Code Listing A.49 defines two simple functions that we
   will use later. A key aspect of these functions is that they have the same signature. That is, the
   two functions take the same number of arguments, the types of the arguments are identical (the names
   of the parameters do not matter), and the return type is the same. In this example, both functions
   take two int arguments and return an int. Lines 6 and 7 are explicit function prototypes that declare
   the functions' interfaces. Function prototypes are only required when a function is used before it is
   defined. For instance, if line 12 were changed to make a call to sub(), the compiler would use the
   prototype on line 7 to confirm that the call is correctly formatted; calling sub (1, 2) would be
   acceptable, while calling sub ("marine") would not, due to the required parameter types. Function
   prototypes can be omitted (and usually are) if the function definition occurs before the first call
   to it.

/* Code Listing A.49:
 * Two simple arithmetic functions with the same function signature
 */

/* Function prototypes as they might appear in a header file */
int add (int, int);
int sub (int, int);

int add (int addend_1, int addend_2) {
	return addend_1 + addend_2;
}

int sub (int minuend, int subtrahend) {
	return minuend - subtrahend;
}

   Code Listing A.50 uses the function declarations from A.49. Line 5 starts by declaring a
   function pointer variable called fun. The full explanation of function pointer declarations is
   provided below. For now, it is sufficient to note that fun is a pointer, so it can store an address.
   The names of the functions from Code Listing A.49, add and sub, are simply readable aliases for
   the addresses of the functions' code. In other words, we can think of add and sub as address
   constants; setting fun = add is similar to setting fun = NULL to create a null pointer. Lines 5 and
   8, then assign the addresses of add and sub to the pointer fun. The effect of this assignment is to
   make fun an alias for the function at that particular point. Lines 6 and 9 demonstrate that using a
   function pointer to make a function call works exactly like a standard function call. That is, the
   call to fun (5, 3) is identical to calling add (5, 3) directly.

/* Code Listing A.50:
 * Declaring a function pointer and assigning its value
 */

int (*fun) (int, int) = add;
int sum = fun (5, 3);

fun = sub;
int diff = fun (5, 3);

printf ("Sum is %d, difference is %d\n", sum, diff);

   Function pointer declarations follow the structure defined in Figure 10.8.1. To understand the
   declaration, the components need to be read from the inside to the outside. That is, the middle
   portion, (*fun), is read first. Specifically, the * declares a pointer, just as any other pointer
   declaration. Wrapping the * and the variable name in parentheses indicates that it is a function
   pointer, in particular. Traversing outward, the rest of the line completes the function pointer's
   type. The variable declaration starts with a single return type and ends with the list of parameter
   types in parentheses. In sum, a function pointer declaration looks exactly like a standard function
   prototype, with the exception of the (*name) structure where the prototype would just have the
   function name.

      +---------------------- specification of target function's return type
      |
      |       +-------------- (*...) declares a function pointer / 'fun' is the variable name
      |       |
      |       |          +--- specificatio of the target function's parameters
      |       |          |
      |       |          |
   [ int ] (*fun) [ (int, int) ];

   When working with function pointers, it is critical to understand the placement and exact role of
   parentheses. The (*name) structure is required to declare a variable instance. Similarly, the
   parameter list must also be in parentheses, just like standard function prototypes and definitions.
   One common mistake is to use parentheses on the right side of the assignment statement as shown
   below:
int (*ptr) (void) = trouble ();

   With one exception, this line is incorrectly written. The declaration on the left indicates that
   there is a new function pointer variable, ptr. Any function that ptr can be set to must adhere to the
   interface that it accepts no arguments (specified by (void)) and returns an int. Given this
   declaration, the compiler will check to see if the value being assigned to ptr has the same type.
   That is, does the right side of the assignment evaluate to a pointer to a function, specifically one
   that takes no arguments and returns an int? Consider one possible declaration for the function called
   trouble():

int trouble (void); // trouble's function prototype

int trouble (void) {
	/* Do something */
	return 5;
}

   At first glance, everything looks okay. The prototype on line 1 and the definition of trouble() both
   indicate that the function takes no arguments and returns an int. However, that is exactly why the
   assignment above is incorrect. On the original line, we are not assigning the address of the function
   to ptr. Rather, the right hand of the assignment calls trouble(), which runs and returns the int
   value 5. As such, the line above is equivalent to setting ptr = 5; this is assigning an int value to
   a pointer variable, not assigning an address!

   The exception to this description is if trouble() was specifically a function that returned another
   function. That is, trouble() is a function that takes no arguments and returns a pointer to a
   function, such that the returned function takes no arguments and returns an int. The syntax for this
   version of trouble() is, frankly, atrocious and unreadable. We provide it here for the curious,
   though we do not recommend ever writing code like this. If it is necessary to return a function
   pointer, typedefs can make this code significantly more readable.

/* The full prototype to be precise */
int (*trouble (void)) (void);

int (*trouble (void)) (void) {
	/* return a function pointer */
}

   Perhaps the most confusing aspect of this declaration is which parameter list goes with which
   function. Counterintuitively, the inner portion defines the input parameters for trouble(). That is,
   the portion that reads (*trouble (void)) indicates that trouble() takes no parameters; the portions
   outside of these parentheses indicate the return type and parameter list for the function that
   trouble() returns.

10.8.1. Passing Function Pointers as Arguments
   Given the complexity of declaring and working with function pointers, it is natural to ask why they
   are beneficial or even necessary. The two most common uses are to pass a function as an argument to
   another function and to build a lookup table of functions. We will start with the first example. This
   application might seem familiar to readers who are familiar with functional programming or the
   concept of lambdas that has been added to languages like Java. Code Listing A.51 provides an
   example of this kind of usage, using the (much maligned) Bubble Sort algorithm.

/* Code Listing A.51:
 * Bubble sort implementation that takes a custom comparison operation
 */

void bubble_sort (void *array[], size_t length, int (*compare) (void *, void *)) {
	for (size_t i = 0; i < length - 1; i++) {
		for (size_t j = 0; j < length - i - 1; j++) {
			if (compare (array[j], array[j+1]) > 0) {
				void *temp = array[j];
				array[j] = array;
				array[j+1] = temp;
			}
		}
	}
}

   The bubble_sort() function takes three parameters: an array of pointers, an array length, and a
   comparison function. As the array parameter is an array of void* elements, this implementation can
   sort any type of objects. That is, the array could contain pointers to strings, pointers to FILE
   objects (e.g., to sort based on file size), or pointers to any custom data types. The compare
   function pointer must point to a function that takes two void* inputs and returns an int. The type
   cannot indicate this, but any function pointer passed as the compare parameter needs to adhere to a
   convention based on strcmp(); return 1 if the first item is "greater" than the second, -1 if the
   second item is "greater," and 0 if they match. Code Listing A.52 provides an example of such a
   comparison that performs a case-insensitive string comparison (as opposed to the case-sensitive
   nature of strcmp()).

/* Code Listing A.52:
 * A case-insensitive string comparison
 */

int strcmp_nocase (char *first, char *second) {
	/* Assume non-empty strings for simplicity */
	char *first_walk = first;
	char *second_walk = second;

	/* Walk until one of the strings reaches a null byte */
	while (*first_walk != '\0' && *second_walk != '\0') {
		/* Make a lower-case copy of the characters and compare */
		int fc = tolower (*first_walk);
		int sc = tolower (*second_walk);
		if (fc > sc)
			return 1;
		if (fc < sc)
			return -1;

		/* Continue to the next character if the current matches */
		first_walk++;
		second_walk++;
	}

	if (*first_walk == *second_walk) // Strings are identical
		return 0;

	if (*first_walk == '\0') // First was shorter than second
		return -1;

	return 1; // First was longer than second
}

   Code Listing A.53 applies these two functions to demonstrate the power of function pointers for
   flexible code execution. Line 5 starts with an array of strings with a mixture of cases. Line 7
   passes this array to bubble_sort() along with a pointer to the strcmp_nocase() function. To be
   precise, the type of strcmp_nocase() does not match the type required for the compare parameter to
   bubble_sort(); strcmp_nocase() takes two char* arguments, whereas the type declaration of compare
   indicates that the function needs to take two void* arguments. Hence, line 7 explicitly casts
   strcmp_nocase() as needed. Similar casting is needed at line 14 for strcmp().

	/* Code Listing A.53:
	 * Passing two functions as parameters to the generic Bubble Sort
	 */
	
	char *strings[] = { "Hello", "goodbye", "Hi", "HIT", "ha" };
	
	bubble_sort ((void **)strings, 5, (int (*)(void *, void *))strcmp_nocase);
	
	printf ("SORTED (case-insensitive):");

	for (size_t i = 0; i < 5; i++) {
		printf (" %s", strings[i]);
	}
	printf ("\n");
	
	bubble_sort ((void **)strings, 5, (int (*)(void *, void *))strcmp);
	
	printf ("SORTED (case-sensitive):");
	for (size_t i = 0; i < 5; i++) {
		printf (" %s", strings[i]);
	}
	printf ("\n");

   Although the preceding code works, the number of parentheses and * operators can make it hard to
   read. One common way to improve the readability is to use a typedef to simplify the type declarations
   and function calls. Code Listing A.54 demonstrates this practice by defining a new type, comp_t,
   as a function pointer that takes two void* parameters and returns an int. Readers who are comfortable
   with typedef may fine the version on line 5 to be odd; normally, the new type name appears at the end
   of the line, just before the ; character. With function pointers, however, the type name is placed
   where the variable name would go in a function pointer declaration. Despite this oddity, line 8 is
   now easier to read than in Code Listing A.51; the compare parameter now matches the comp_t type,
   and the reader does not need to parse the complexities of function pointer declarations. Code
   Listing A.55 shows how the typedef simplifies the calls to bubble_sort() with cleaner casting.

   /* Code Listing A.54:
	* Simplifying the bubble_sort() interface with a typedef
	*/

	typedef int (*comp_t) (void *, void *);

	void bubble_sort (void *array[], size_t length, comp_t compare) {
		/* ... omitting the rest ... */
	}


	/* Code Listing A.55:
	* Using the simplified bubble_sort() interface
	*/

	/* Replacement for A.53, line 7 */
	bubble_sort ((void **)strings, 5, (comp_t)strcmp_nocase);

	/* Replacement for A.53, line 14 */
	bubble_sort ((void **)strings, 5, (comp_t)strcmp);

10.8.2. Function Pointer Lookup Tables
   Another common use for function pointers is to create a lookup table of functions. That is, rather
   than building complex logic structures in code to determine which function needs to be called under
   certain conditions, this information is represented in a table format, such as a one- or
   two-dimensional array. To illustrate this concept, assume that Code Listing A.49 has been
   extended to support the five basic arithmetic operations (addition, subtraction, multiplication,
   division, modulus). Using these functions, Code Listing A.56 builds a single interface,
   calculate(), that can be used for any of them.

	/* Code Listing A.56:
	 * Using the simplified bubble_sort() interface
	 */

	typedef enum ops { ADD, SUB, MUL, DIV, MOD, NOP } op_t;
	typedef int (*arith_t) (int, int);

	int calculate (op_t operation, int x, int y) {
		static const arith_t ops[] = { add, sub, mul, div, mod };

		if (operation >= NOP || operation < 0) {
			errno = EINVAL;
			return 0;
		}

		return ops[operation] (x, y);
	}

   Lines 5 and 6 start by defining custom types for the valid operations (op_t) and the binary
   arithmetic funtions (arith_t). Line 11 defines the lookup table; it is a simple array of the five
   function pointers. (Again, note that these entries are just the names of the functions and do not
   have parentheses.) This line reiterates the value of using a typedef for function pointers, as the
   syntax to declare an array of function pointers, along with the static and const keywords, is
   unnecessarily cumbersome. Defining the enum on line 5 and performing the check on line 13 ensures
   that the operation is one of the five supported. Line 19, then, actually performs the operation. By
   indexing into the ops array, ops[operation] evaluates to a pointer to the specified function. The (x,
   y) notation after that indicates that this function is to be executed with x and y as the arguments.
   This calculate() function takes no special steps based on which function is being called (although it
   would be appropriate to prevent the use of 0 for y with div and mod); rather, the logic of
   determining the function lies entirely in the lookup table structure. Code Listing A.57 uses
   this simplified interface to perform each of the specified operations.

	/* Code Listing A.57:
	 * Using the single calculate() interface
	 */

	printf ("SUM: %d\n", calculate (ADD, 5, 3));
	printf ("DIF: %d\n", calculate (SUB, 5, 3));
	printf ("PRO: %d\n", calculate (MUL, 5, 3));
	printf ("QUO: %d\n", calculate (DIV, 5, 3));
	printf ("REM: %d\n", calculate (MOD, 5, 3));

   Based just on the toy example of five arithmetic operations, it is fair to object to the need for
   tables of function pointers. Clearly, Code Listing A.57 could simply call add (5, 3) instead of
   calling calculate (ADD, 5, 3) to get the same result. From this example, the benefits of function
   pointers might not be evident. It is important to note, though, that function pointers are a
   difficult topic; this example was designed to be as simple as possible to explain the mechanics.

   These lookup tables are widely used in a variety of fields, including compiler design. As the parser
   (one component of a compiler) reads the characters of a file a byte at a time, it needs to keep track
   of what has been read and what was just read. For instance, a C compiler would need to distinguish
   reading a space after "int" and reading a space after "int_value", as the former is a language
   keyword and the latter could be a variable name. Trying to write standard logic code for this
   processing is extremely difficult due to the sheer number of possible branches. Instead, a
   two-dimensional lookup table (a very large one!) provides a more manageable approach. The details
   vary, but a simple way to envision it is that each row indicates a state that represents what
   has been read (i.e., "i", "in", and "int" would be different states); the columns would then be used
   to identify a different function pointer for each possible input character.


---
https://www.educba.com/function-pointer-in-c/

Function Pointer in C

Introduction to Function Pointer in C
       A Function pointer is the most important feature in C which is also known as Subroutine pointer.
       A pointer that points to any function is called a Function Pointer. It points to a specific part
       of code when executing difference is that a function pointer to code as compare to a normal point
       which points to a specific variable in code. The most valuable thing is that we can pass the
       function parameter as an argument and its name can be used to get the address of the function. FP
       is like a variable storing the address of the function.

Syntax of Function Pointer
Syntax #1
Function_returntype ( *Pointer_name) ( argument_list)
       First, we have to write the return type of function which can be void, double, etc. Then we have
       to give a name to our function pointer after that in another bracket we have to list the
       argument.

Syntax #2
void ( *funct_pointer ) ( int );
       In the above syntax func_pointer is a pointer to a function taking an integer argument that will
       return void.

Working of Function Pointer in C
       Let us have a look at the working of Function Pointer in C programming language

Example #1
       Here is the C code to demonstrate the working of Function Pointer:
       Code:
#include <stdio.h>
int sum (int var1, int var2) {
	return var1 + var2 ;
}

int main () {
	int ( *functiontopointer ) (int, int) ;
	functiontopointer = sum ; // This part can also be done using void ( *fun_ptr ) ( int ) = &fun ;
							  //Here we are calling using the function pointer
	int Output1 = functiontopointer (20, 98) ;
	// Here we are calling function in normal way
	int Output2 = sum (20, 98) ;
	printf ( " Calling through function pointer: %d " , Output1 ) ;
	printf ( " \n Calling through function name: %d " , Output2 ) ;
	return 0 ;
}

       Output:
Output1 : Calling using the function pointer: 118
Output2 : Calling using the function name: 118

       Explanation: In the above code, you can see we have declared a method called Sum to add the two
       declared variables var1 and var2 and store the output of addition in Sum. In the main class, we
       have declared a function pointer FTP with an integer argument that returns void. Similarly, for
       using the function pointer functionality we are taking two inputs from the user. One is for
       showing the addition using function pointer while the other one is for showing the result using
       the normal pointer.

Example #2
       Here is the C code to demonstrate the working of Function Pointer:
       Code:
#include <stdio.h>
void addition ( int i , int j ) {
	printf ( " The addition of both the input is %d \n " , i+j ) ;
}

void substraction ( int i , int j ) {
	printf ( " The substraction of both the input is %d\n " , i-j ) ;
}

void multiplication ( int i , int j ) {
	printf ( " The multiplication of both the input is %d\n " , i*j ) ;
}

int main() {
	void ( *funcpointer_arr[] )( int , int ) = { addition, substraction, multiplication} ;
	int character, i = 8, j = 8 ;
	printf ( " Please enter: 0 for Add , 1 for Substract and 2 "
			"for Multiply \n " ) ;
	scanf ( " %d ", &character ) ;
	if ( character > 2 ) return 0 ;
	( *funcpointer_arr [ character ] ) ( i ,  j ) ;
	return 0 ;
}

Output:

	input
	0
		Output
		Please enter your choice: 0 for Addition, 1 for Subtraction, 2 for Multiplication
		The addition of both the numbers is 16

	input
	1
		Output
		Please enter your choice: 0 for Addition, 1 for Subtraction, 2 for Multiplication
		The subtraction of both the number is 0

	input
	2
		Output
		Please enter your choice: 0 for Addition, 1 for Subtraction, 2 for Multiplication
		The multiplication of both the number is 64

       Explanation: In the above code, you can see we are applying the same technique of function
       pointer as we did in the previous code. We have separately created functions for addition,
       multiplication, and subtraction. We have declared a function pointer named void (
       *funcpointer_arr [] )( int, int ) to store the values separately for all the operations with two
       integer data types a and b. Therefore, based on the choices 0, 1, and 2 we can perform the
       preferred operation separately.

Example #3
       Here is another C code to demonstrate the working of Function Pointer:
       Code:

#include <stdio.h>
#include <stdlib.h>

int comparison ( const void* lhs , const void* rhs ) {
	return ( * ( int * ) rhs - * ( int * ) lhs ) ;
}

main() {
	int ( *cmp ) ( const void* , const void* ) ;
	cmp = &comparison ;
	int array [] = {15,42,93,54,15,66,37,8,81} ;
	qsort ( array, sizeof ( array ) / sizeof ( *array ) , sizeof ( *array ) , cmp ) ;
	int x = 0 ;
	while ( x < sizeof ( array ) / sizeof ( *array ) ) {
		printf ( " %d \t " , array [x] ) ;
		x++ ;
	}
}

Output:
    93    81    66    54    42    37    15    15    8

       Explanation: In the above code, you can see we have declared a function pointer named as the
       comparison in which we have two arguments of type constant named as LHS and RHS and the function
       is declared as integer, therefore, it will return this value ( * ( int * ) RHS - *( int * ) LHS
       ). Then in the main class, we are calling our function parameter and declaring a *camp ( pointer
       ) to store the address value of the comparison function pointer. We have declared an array of
       integer data types in which we have defined some random values in a random sequence. Then we are
       using a quick sort method to sort the array in decreasing order sequence in output. Finally,
       until the while condition is satisfied it will print the compared value on by one. Once the while
       condition turns false it will stop and print the final sorted result.

Conclusion
       Function pointer in C programming language can make code faster, easy, short and efficient
       without occupying any large space in the code as the function pointer contains the start of the
       executable code. We can also use a function name to get the address of a function pointer.


---
https://hackaday.com/2018/05/02/directly-executing-chunks-of-memory-function-pointers-in-c/

Directly Executing Chunks Of Memory: Function Pointers In C
April 3, 2023

   In the first part of this series, we covered the basics of pointers in C, and went on to more
   complex arrangements and pointer arithmetic in the second part. Both times, we focused solely on
   pointers representing data in memory.

   But data isn't the only thing residing in memory. All the program code is accessible through either
   the RAM or some other executable type of memory, giving each function a specific address inside that
   memory as entry point. Once again, pointers are simply memory addresses, and to fully utilize this
   similarity, C provides the concept of function pointers. Function pointers provide us with ways to
   make conditional code execution faster, implement callbacks to make code more modular, and even
   provide a foothold into the running machine code itself for reverse engineering or exploitation. So
   read on!

Function Pointers
   In general, function pointers aren't any more mysterious than data pointers: the main difference is
   that one references variables and the other references functions. If you recall from last time how
   arrays decay into pointers to their first element, a function equally decays into a pointer to the
   address of its entry point, with the () operator executing whatever is at that address. As a result,
   we can declare a function pointer variable fptr and assign a function func() to it: fptr = func;.
   Calling fptr(); will then resolve to the entry point of function func() and execute it.

   Admittedly, the idea of turning a function into a variable may seem strange at first and might
   require some getting used to, but it gets easier with time and it can be a very useful idiom. The
   same is true for the function pointer syntax, which can be intimidating and confusing in the
   beginning. But let's have a look at that ourselves.

Function Pointer Syntax
   If we break down a standard function declaration, we have a return type, a name, and an optional list
   of parameters: returntype name(parameters). Defining a function pointer is analogous. The function
   pointer must have a return type and parameters that match the function it is referencing. And just as
   with data pointers, we use the asterisk * to declare the pointer.

   There's one catch. If we have a function int func(void), writing int *fptr(void) won't give us a
   function pointer, but instead another function returning an integer pointer int * as the * sticks to
   the int by default. Parentheses will turn the statement into a function pointer declaration by
   grouping the asterisk with the pointer name instead of the return type: int (*fptr)(void).

   So the general pattern is: returntype (*name)(parameters). Let's have a look at a couple of different
   function pointer declarations.
// function without parameters returning int, the one we just had
int (*fptr1)(void); // --> int function1(void) { ... }

// function with one int parameter returning int
int (*fptr2)(int);  // --> int function2(int param) { ... }

// function with void * parameters returning char *
char *(*fptr3)(void *); // --> char *function3(void *param) { ... }

// function with fptr1 type function pointer as parameter returning void
void (*fptr4)(int (*)(void)); // --> void function4(int (*param)(void)) { ... }

// function with int parameter returning pointer to a fptr1 type function
int (*(*fptr5)(int))(void); // --> int (*function5(int))(void);

   Evidently, the syntax can become rather messy, and you may waste your time trying to make sense of
   it. If you ever encounter a pointer construct in the wild and have difficulties figuring out what
   goes where, the cdecl command line tool can be of great help, and it also comes as online
   version.
cdecl> explain int (*fptr1)(void)
declare fptr1 as pointer to function (void) returning int
cdecl> explain int (*(*fptr5)(int))(void)
declare fptr5 as pointer to function (int) returning pointer to function (void) returning int
cdecl>

   On the other hand, if you find yourself in a situation where you need to write a pointer construct
   that may take multiple attempts to get it right, it's probably a good idea to make use of C's typedef
   operator.
// define new type "mytype" as int
typedef mytype int;
mytype x = 123;

// define new type "fptr_t" as pointer to a function without parameters returning int
typedef int (*fptr_t)(void);
fptr_t fptr = function1;
fptr();

// use fptr_t as parameter and return type
void function4(fptr_t param) { ... }
fptr_t function5(void);

   You may have noticed that all the examples neither used the ampersand & when referencing functions,
   nor the asterisk * when dereferencing pointers to execute their underlying functions. Since functions
   implicitly decay to pointers, there is no need to use them, but we still can. Note that a function
   call has higher precedence over dereferencing, so we need to use parentheses accordingly.
// explicitly referencing with ampersand
fptr_t fptr = &function1;
// explicitly deferencing with asterisk
(*fptr)();
// not *fptr();

   Whether to use the ampersand or asterisk is in the end a matter of taste. If you are at liberty to
   choose for yourself, go with whichever feels more natural and easier to read and understand to you.
   For our examples here, we will omit them both in the code, but we will add the alternative notation
   as comments.

Assigning And Using Function Pointers
   Now that we've seen how to declare function pointers, it's time to actually use them. In the true
   spirit of pointers, our first use case example is the reference to a previous article handling
   the implementation of a state machine with function pointers. It's worth a read on its own,
   especially if you want to know more about state machines, so we don't want to give away too much
   here. But summarized, instead of using a switch statement to determine and handle the current state,
   the state handler functions themselves assign the next state's handler to a function pointer
   variable. The program itself is then periodically executing whichever function is stored in the
   variable.

void (*handler)(void);

void handle_some_state(void) {
	if (condition) {
		handler = handle_some_other_state;
		// handler = &handle_some_other_state;
	}
}

int main(void) {
	while (1) {
		handler();
		// (*handler)();
		...
	}
	return 0;
}

Arrays of Function Pointers
   We can apply a similar approach when we don't have some pre-defined or linear state transitions, but
   for example want to handle random user input, with each input calling its own handler function.

void handle_input(int input) {
	switch (input) {
		case 0:
			do_something();
			break;
		case 1:
			do_something_else();
			break;
			...
	}
}

// function that is periodically called from main()
void handler_loop(void) {
	status = read_status_from_somewhere();
	handle_input(status);
}

   Since function pointers are just variables, we can pack them into an array. Just like with other
   arrays, the brackets [] are attached directly to the name.

// declare array of function pointer of type void func(void)
void(*function_array[])(void) = {
	do_something,      // &do_something,
	do_something_else, // &do_something_else,
	...
};

   We can now replace the previous switch statement by using input as array index:
void handle_input(int input) {
	// execute whichever function is at array index "input"
	function_array[input]();

	// (*function_array[input])();
}

   In theory, this changed the complexity from O(n) to O(1) and made the execution time more
   predictable, but in practice, there are too many other factors, such as architecture, branch
   prediction, and compiler optimization weighing in. On a simple microcontroller, function pointers are
   often faster than if/then or case statements. Still, function pointers don't come for free. Each
   pointer needs a place in the memory, and dereferencing the pointer requires copying the address,
   adding some extra CPU cycles.

   A more convincing argument to replace the switch statement with function pointers is the added
   flexibility. We can now set and replace the handling function at runtime, which is especially useful
   when we are writing a library or some plugin framework where we provide the main logic, and let the
   user decide what to actually do on each state/input/event/etc. (Insert comment about sanitizing user
   input here.) Naturally, using an array makes most sense if the states or input values we handle are
   integers in consecutive order. In other cases, we might need a different solution.

Function Pointers as Function Parameters
   Say we created a library that sends HTTP requests to a web server, and user-defined handlers deal
   with its response based on the HTTP status code. Taking the status code as array index will give
   us a huge, mostly empty array, wasting a lot of memory. The old switch statement would have been the
   better choice here. Well, instead of adjusting the body of the handle_input() function, how about we
   just turn the whole thing into a function pointer? You've just invented the callback.

// function pointer to the handle function
void (*handle_input_callback)(int);

// function to set our own handler
void set_input_handler(void (*callback)(int)) {
	handle_input_callback = callback;
}

// same handler, just using the function pointer now
void handler_loop(void) {
	status = read_status_from_somewhere();
	if (handle_input_callback != NULL) {
		// execute only if a handler was set
		handle_input_callback(status);

		// (*handle_input_callback)(status);
	}
}

   On the user-defined side of the code we would then declare our own handler function and pass it on.

void my_input_handler(int status) {
	switch (status) {
		case 200: // OK
			...
				break;
		case 404: // Not Found
			...
	}
}

int main(void) {
	set_input_handler(my_input_handler);
	// set_input_handler(&my_input_handler);
	while (1) {
		handler_loop();
		...
	}
}

   A real-world system that heavily uses callbacks for user-defined behavior is the non-OS C SDK for
   ESP8266. An example where a function pointer parameter is used to define the function's own behavior
   can be found in the C standard library's Quick Sort function, qsort(), which takes a compare
   function as parameter to determine the order of any given data type.

Function Pointers as struct Members
   After all what we've seen about pointers by now, it shouldn't come as a surprise that function
   pointers can be struct members, and we declare and use them just like any other member.

struct something {
	int regular_member;
	void (*some_handler)(void);
	int (*another_handler)(char *, int);
} foo;

...
foo.some_handler = some_function;

// foo.some_handler = &some_function;
foo.another_handler(buf, size);

// (*foo.another_handler)(buf, size);
...

   structs with an assortment of function pointers as members are commonly found in plugin systems, or
   where hardware dependent code is separated from the common, hardware independent logic. A classic
   example are Linux device drivers, but it doesn't have to be that extreme for starters. Remember that
   overly complex LED toggle example from the first part where we defined the GPIO port as pointer? If
   we used the same concept for a push button input, and added some handler functions, we'd end up with
   a complete generic, hardware independent button handler framework.

   Note that we can assign a NULL pointer also to function pointers, and executing such a function will
   result just like dereferencing any other NULL pointer in a segmentation fault. But if we expect it as
   possible value and check against it before execution, we can use it to disable the execution and make
   the handling itself optional.

Casting Function Pointers
   If function pointers behave no different than any other pointer, we should be able to cast them to
   other pointers as we please. And yes, it is technically possible, and the compiler won't stop us, but
   from the language standard's point of view, chances are executing such a cast function pointer will
   result in undefined behavior. Take the following example:

int function(int a, int b) { ... }

void foo(void) {
	// cast function to type "int func(int)"
	int (*fptr)(int) = (int (*)(int)) function;
	fptr(10); // -> function(10, ???);
}

   While technically a valid cast, we end up calling function() without a value for parameter b. How
   this is handled depends on the underlying system and its calling convention. Unless you have good
   reasons, you probably don't want to cast a function to a mismatching function pointer. Curiosity is
   always a good reason, though.

Casting Between Function Pointers and Data Pointers
   Can you turn functions into data or data into functions? Sure! And doing so is one of the
   cornerstones of hacking. As we recall, we need an accessible address and enough allocated memory at
   that address to successfully handle data pointers. With a function we have both: the function code as
   allocated memory, and the function itself as address. If we cast a function pointer to, say, an
   unsigned char pointer, dereferencing the pointer will give us the compiled machine code for that
   function, ready for reverse engineering.

   Going the other way around, any data pointer that we cast to a function pointer can be run if points
   to valid machine code. Assembling machine code yourself, stashing it in a variable, recasting a
   pointer to that variable, and finally running it surely seems like a lot of hassle for everyday use.
   But that's the basic recipe for exploiting security vulnerabilities by injecting shellcode, and
   generally a fun way to experiment with machine code - and maybe worth its own article some time in
   the future.

The End
   While pointers can create headaches and frustration, they also offer us freedom and possible ways of
   working that are rarely matched by any other language construct out there. And while the world may be
   a safer place thanks to modern language designs that "solve" the problems that can arise with
   pointers if they are not handled with care, pointers will always have their place in both making, and
   breaking, software.


---
http://vandervoord.net/blog/2015/6/2/making-function-pointers-usable-in-c

Making Function Pointers Usable In C

   If you say the phrase "function pointer," does it make you cringe? Does it make your coworkers break
   out in a cold sweat?

   We've seen the function pointer coding disasters. We've heard the horror stories about code jumping
   into random spots of memory and trying to execute it as if it were our function.

   And there is the notation. Egad! The notation for function pointers in C is truly horrific, isn't it?
   After many years, I still occasionally need to look up what the proper syntax is for a function
   pointer typedef (Clearly, I'm not a C compiler).

   But there are just certain situations where a well-placed function pointer does the job like no other
   solution. A few of my favorite examples:

   Dispatch Tables - Your function has received an ID. It might be processing incoming messages. It
   might be handling image processing. It could be many things... but the point is that you have a set
   of operations that need to be called, based on a single key or index of some type. If those
   operations are called in a similar way, you've got the perfect place for an array of function
   pointers.

   Pipelines - You want to chain data from one step to another. Maybe some of the steps are optional.
   Maybe you intend to just run through all of them. The output of one step becomes the input to the
   next. Again, you've likely found the perfect place for a set of function pointers.

   Callbacks - I actually avoid callbacks for the most part... but there are certain situations where a
   callback can handle things more cleanly than any other solution. You know what callbacks are? Yes.
   Function pointers.

   OK. So we've established that function pointers sometimes have their place... but what can we do to
   keep ourselves out of trouble? I'm so glad that you asked! I just happen to have a few tricks that I
   have learned that I would love to share. If you've learned tricks of your own, I'd love to hear them!

OH, SYNTAX
   Okay, so it's a given that we're going to have to face the dreaded function pointer syntax at SOME
   point, but at least we can keep it from rearing it's ugly head everywhere we turn! We can look it up
   once, and then forget about it again; We get some type safety thrown in for free (particularly if you
   have all your warnings turned on); You even get more readable code. What's not to love?

   So don't define your function pointer directly.
int16_t (*myFunc)(int8_t);

   Don't (this is even worse) put it directly in your argument list.
int16_t OuterFunc(int32_t val, int16_t (*innerFunc)(int8_t));

   And please don't (Oh! The Humanity!) hardcode it into your struct-based table.

const struct DispatchTable {
	const char* key;
	const int16_t (*func)(int8_t);
}[] = { /****/ };

   Finally, don't (Shudder!) return a function pointer directly from a function without a typedef:
int16_t (*CalledFunc(int32_t val))(int8_t);

   Isn't it nicer just to create a typedef and then use it for all these other needs? I mean, this looks
   like a human being can actually understand it, right?
typedef int16_t (*FUNC_T)(int8_t);

typedef struct _DISPATCH_T {
	const char* key;
	const FUNC_T func;
} DISPATCH_T;

FUNC_T myFunc;
int16_t OuterFunc(int32_t val, FUNC_T innerFunc);
const DISPATCH_T DispatchTable[] = { /****/ };
FUNC_T CalledFunc(int32_t val);

   Use Typedefs. Your future self will thank you.

BONUS
   Why does the DISPATCH_T typedef also have the struct name _DISPATCH_T in it? Excellent question!
   There are numerous embedded compilers out there that won't put your typedef names into their debug
   output. It's unfortunate, because that would help the readability of their output, but I can
   understand how it happens. They've already stripped that layer of information away before it gets to
   that error. ANYWAY, if you put your struct name in, you'll often get error messages that make more
   sense. Just a tip.

DANGER!
   So, we've made our function pointers more readable with our handy typedef... but aren't they still
   kinda... dangerous?

   Well yes, they can be. Luckily there is something we can do to reduce that risk... actually multiple
   somethings. Let's check them out.

CONST
   Yes, the first one is our friend const. By making our function pointers const whenever possible, we
   are reducing the risk that it is going to get clobbered by something else going on in our system.
   This is particularly true on systems that are ROM-able (or at least put their const data in Flash).

   This leads to another accidental bonus of our typedef usage. It's clear that this will create a const
   function pointer which points at ExternalFunc.
const FUNC_T myFunc = ExternalFunc;

   Can you remember the syntax for doing that longhand? I can usually get it by the second try, but
   really... shouldn't we stick with code that we can get right always? For the record, it's this:
int16_t (const *myFunc)(int8_t);

   Don't forget that if you pass a function pointer, the function accepting it should usually have that
   pointer declared as const too. It's unlikely that any pointer manipulation is going to be
   desirable... you're usually just going to call that function at some point. Might as well save the
   compiler some work and assure it that you're leaving it unchanged.

NULL AND BOUNDS CHECKING
   The other huge thing you can do is good validation. When working with function pointers, you want to
   be very sure that the pointer you're working with is valid. These rules are true of any pointers, I
   know... but consider them extra strict when function pointers are in play.

   First, if you're passing function pointers around, EVERY function that accepts a function pointer
   should validate that it's not NULL. For this to be effective, make sure that you ALWAYS declare your
   function pointer variables to be either a valid function or NULL. Letting the compiler handle it for
   you should not be considered adequate. Be explicit.

   Second, if you have a const table somewhere, clearly the function pointers aren't going to change,
   right? But we can still get into trouble! Here is where we want to do some serious bounds checking.
   If the index or key or whatever isn't in your table, we want to know about it!

   This is such a horrible place for an off-by-one error! In fact, I've seen a really handy practice
   that I've started to make use of myself: In arrays where your key is the index into it, the last
   element of the array is always an error handler. In that case, if there is an off by one error, it
   will at least be executing code meant for handling errors already!

   If there are any "holes" in your table, clearly we will want to replace these with some sort of
   default handler as well. It might be a do-nothing function or an error function (depending on the
   situation). We just want to make sure it is handled.

POINT ON!
   There we go. That's the tips I've accumulated for using function pointers in C. I hope this will help
   others to not fear our flexible little function pointing friends, but that it will also help breed a
   healthy caution around them. Watch out, they bite!

A SECOND BONUS!
   As an added bonus, I thought I would mention that CException works particularly well in situations
   where we are using Function pointers for dispatch or series (pipelines). In both cases, the calling
   function can wrap our calls in a Try... Catch block, which means all our handlers can just throw
   errors when they run into them. Clearly, though, this is a topic for another day.


---
https://web.stanford.edu/class/archive/cs/cs107/cs107.1214/lab4/

Lab 4: void * and Function Pointers

Pre-Lab Exercise
   Before attending your lab, please work through the "Pre-lab Exercise" section below. We plan for the
   exercise to take 20-30min maximum, and it will be essential to the further problems you'll work
   through during your lab session. You'll discuss your findings and questions at the start of your lab
   sessions this week. Feel free to post on the discussion forum if you have questions while working!

   You will be expected to have answers to the last two bulletpoints from part (b) of the prelab:
     * Look carefully to identify the subtle differences between the compare_letters and compare_strings
       callbacks. Q: Could you use the compare_letters to sort an array of strings by the first letter?
       Why or why not?
     * Q: What would a callback comparison function that can be passed to qsort look like if we wanted
       to arrange an array of ints in order of increasing absolute value? (hint - the builtin C abs()
       function can calculate absolute value).

Learning Goals
   During this lab, you will:
    1. explore how C void*/function pointers support generic operations
    2. study the implementation of generic operations and client callback functions
    3. debug void* pitfalls

Get Started
   Clone the lab starter code by using the command below.
git clone /afs/ir/class/cs107/repos/lab4/shared lab4

Pre-Lab Exercise: Callbacks

(a) Overview of comparison functions
   The generic sort/search functions in the C library (qsort, bsearch, lfind ...) are functions that can
   sort or search any type of data. In order to do that, however, they need the caller to provide a
   comparison function in order for them to know how to compare two values. All these functions use the
   same form of standard comparison function:
int comparison_fn_t (const void *, const void *)

   Any version of the comparison function that you may implement for your data receives pointers to the
   two values to compare and returns an integer that indicates their order, using the same +/-/0 return
   values as strcmp.

   The most critical issue to understand is that all generic operations work with data via pointers to
   values, never the values directly. Referring to data by address is fundamental to how C supports
   generic functions. Sending or receiving an actual value is not possible because the values vary in
   type/size. Instead what is exchanged are pointers to values. All pointers, regardless of pointee, are
   8-byte addresses that are type-compatible with void*.

   Implementing a comparison function follows a similar pattern:
    1. Cast the void* argument and set a pointer of known pointee type equal to it.
    2. Dereference the typed pointer to access the value. (Steps 1 and 2 are often combined to cast and
       dereference in one expression.)
    3. Compare values to determine the result to return.

   The actual comparison logic (Step 3) is usually straightforward; it is mishandling the void* in Steps
   1 and 2 that you have to watch out for.

(b) Example comparison functions
   Review the example comparison functions in the callbacks.c file to see how each fits the above
   pattern. Work through the following questions:
     * These callbacks immediately cast the void* arguments and store into a properly typed local
       variable. Q: What is the advantage of doing this up front rather than instead
       casting/dereferencing the argument each time it is used?
     * Supplying a different comparison function to qsort allows you to sort the array using a different
       criteria. For example, the two callbacks that operate on the custom struct city each sort by a
       different field. Q1: How would we write a comparison function to sort in reverse order? Q2: How
       would we write a comparison function that compares by one field as a primary sort order, breaking
       ties by comparing a secondary field?
     * The comparison function that orders cities by zip code returns the difference between the values
       as a quick way to compute a positive, negative, or zero comparison result. Q: Do you see how it
       works? This is a common shortcut for comparing integer values. (Note: the subtraction overflows
       if the difference exceeds INT_MAX, so if you need to support such extreme values, stick with the
       longer if/else with different cases.)
     * All comparison functions fit the same prototype listed above. That means any comparison function
       can be applied to any type of array - there is no type-matching. Q1: What would be the
       consequence of sorting an int array using a character comparison function? Q2: What about sorting
       an array of cities using a string comparison function?
     * Look carefully to identify the subtle differences between the compare_letters and compare_strings
       callbacks. Q: Could you use the compare_letters to sort an array of strings by the first letter?
       Why or why not?
     * Q: What would a callback comparison function that can be passed to qsort look like if we wanted
       to arrange an array of ints in order of increasing absolute value? (hint - the builtin C abs()
       function can calculate absolute value).

Lab Exercises
1) Code Study: gfind_max (20 minutes)

   gfind_max is a generic function we've written to find the largest array element that according to the
   client's comparison function:

void *gfind_max(void *arr, int n, size_t elemsz,
	int (*compare_function)(const void *, const void *))
{
	void *pmax = arr;
	for (int i = 1; i < n; i++) {
		void *ith = (char *)arr + i*elemsz;
		if (compare_function(ith, pmax) > 0) {
			pmax = ith;
		}
	}
	return pmax;
}

1a) Function implementation
   Look over this code to see how a generic function is implemented. This code is also included in the
   generic.c file, along with some functions that use it. Here are some questions to talk over with your
   group:
     * Line 3 shows the idiomatic access to the ith position in a generic array. Be sure you understand
       the expression's purpose/operation. Q: What is the intention of the typecast to (char *)? What
       would be the consequence of removing that cast?
     * The website cdecl.org can convert a declaration from "C gibberish into English". This is
       handy when trying to unravel an inscrutable declaration. Copy the parameter declaration for
       compare_function above and paste into cdecl to gets its explanation in English.
     * Note that invoking the client callback via a function pointer looks pretty much the same as
       making an ordinary function call. Q: What happens if you attempt to call the function pointer
       with the wrong number or wrong type of arguments? Try editing generic.c to remove a parameter
       from when gfind_max calls compare_function and see what happens.
     * gfind_max returns a void *. Q: What does that pointer represent? Why does the function return a
       pointer to a value rather than the value itself?
     * Q: How could a client use gfind_max to find the smallest element instead of the largest?

1b) Using gfind_max
   The necessarily permissive nature of a void* interface makes for a treacherous client experience.
   There are many ways to misuse a generic function, and the compiler often does not warn you about
   these transgressions. Let's explore this situation further.

   The main function in generic.c makes four calls to gfind_max. The first call is completely correct
   and prints the expected result. Each of the subsequent three calls is incorrect in some way. For each
   of these below, try to work out what you believe will be printed, and then verify that your
   understanding is correct by running the program. Drawing memory diagrams and/or tracing in gdb may be
   very helpful in understanding the behavior.
     * Incorrect call #1 passes a char comparison function to be used on an array of int elements.
       Yikes! Q: Why is there no compile or runtime error from our mistake? Does running Valgrind report
       anything helpful? How does gfind_max behave in this case?
     * Q: What is the error in call #2? Where did the reported "max" value even come from? (Note: some
       bytes may be in a different order than you expect. This is because of something called
       "endian-ness", and it turns out the myth machines are "little endian". You can read more
       endianness here, but you don't have to worry about it for CS107. The important thing to know here
       is just generally why the reported max value is what it is).
     * Q: What is the error in call #3? Why will this call always return a pointer to the last element?

2) Debugging: bsearch Bug (15 minutes)
   (Note: for this problems, some bytes may be in a different order than you expect. This is because of
   something called "endian-ness", and it turns out the myth machines are "little endian". You can
   read more endianness here, but you don't have to worry about it for CS107. The important thing to
   know here is just what the general bytes are that you are examining).

   bsearch is a C standard library function to search for an element in an array. As a rule, for bsearch
   to be able to work properly, the array must be sorted according to the same comparison function that
   the search is using. Take a look at bsearch_bug.c - the programmer who wrote the main function is
   confounded by why they couldn't get their code to work using the same comparison function. They
   eventually got it working by resorting to using a different comparison for search than sort. They
   know this can't be good, but were unable to identify the correct fix.

   Your group will investigate!

   Before starting, remember the core principle that all generic operations work with data via pointers
   to values, never the values directly. Keep this in mind as you explore this provided code. Draw
   memory diagrams to keep track of the pointers and levels of indirection you are working with. This
   code is an example of a very common bug on assign4, so getting to the bottom of it now will help
   later on!
     * Introduction: Compile the program as-is and run it to observe that it does seem to work despite
       the mismatch in comparison functions. Change the code to use compare_first_characters as the
       comparison function for both sort and search. Run this version and it crashes. Q: On what
       operation in the code does it crash? Why?
     * A buggy fix: The original author's workaround was to add a different comparison function to be
       used for search. It is a big red flag that this comparison function typecasts its two void*
       arguments to different pointee types. The fact that it manages to "work" at all is sketchy and
       depends on a precise detail of how bsearch is implemented. Q: What detail is that? If you very
       carefully read the man page for bsearch, you will see that this detail is guaranteed to be true
       for a conforming implementation (Hint: what does the first parameter of the comparison function
       represent? How about the second? Check out the second paragraph of the manual page), but that
       still doesn't make it a good idea to depend on it in this way.
     * A proper fix: Q: Identify the proper fix to the code that makes the program work correctly and
       use the same comparison function compare_first_characters for both sort and search, as they
       should. (Hint: take a closer look at the values of the parameters passed into bsearch when
       calling it).

   The point of this exercise is to highlight the necessity of maintaining vigilance as a client of a
   void* interface. It also foreshadows the futility of trying to get the correct code via trial and
   error. While randomly permuting * & and typecasts might eventually land on a correct combination,
   this approach does absolutely nothing for your understanding. Instead, if you take the time to work
   through the operation on paper, draw diagrams, and trace execution in gdb, you can become confident
   about what level of indirection is appropriate in what context and why. Ask questions about what you
   don't understand!

3) Tool Tutorial: GDB Tips (15 minutes)
   We'll periodically try to introduce you to new helpful gdb commands or features to aid in your
   debugging. This week, we introduce the "examine" command, and how to print arrays. For each of these,
   try setting breakpoints and printing out values in the gdb_practice.c file, where we have declared
   some variables already. Feel free to edit and play around with this file to help you get familiar
   with these features.

Examine (x)
   The examine command, x is a helpful command to examine the
   contents of memory independent of the type of data at a memory location. It's like print, but for
   generic memory rather than a specific type of variable. x instead prints out a certain number of
   bytes starting at a given address.

   If you have a pointer ptr, for instance, you could print out in hex the 8 bytes starting at the
   address it contains by executing x/8bx ptr. The optional parameters after the slash specify what you
   would like to print:
     * The first one (e.g. 8 or 2) lets you specify how many you would like to examine.
     * The second (e.g. b or w) specifies whether you would like to print out bytes, words (a word is 4
       bytes), etc.
     * The third (e.g. x) specifies how you would like to print them out (e.g. x for hex, d for
       decimal).

   Check out the documentation link for a full summary. Try out the following with gdb_practice when
   you're ready:
    1. Run gdb on the gdb_practice program. Set a breakpoint on main and step into the function past the
       variable declaration/initializations, including the array nums.
    2. x/4bx ptr prints out the 4 bytes beginning at the address in ptr in hex. Q: What do you see? Why
       is that?
    3. x/8bx ptr prints out the 8 bytes beginning at the address in ptr in hex. Q: What do you see? Why
       is that? (hint: where does number2 live vs. number?)
    4. x/8bx nums prints out the 8 bytes beginning at the start of the array nums in hex. Q: What do you
       see? Why is that?

Printing Arrays
   If you print a stack array from within the function in which it is declared, gdb will show the array
   and its contents. In that context, gdb has access to both the element type and the count of elements,
   and uses it to print a nice representation of the entire array. (Try this in the main function by
   printing out nums!) However, it cannot automatically do the same in other contexts, such as for a
   heap array or for an array/pointer passed into a function (try this in my_function to see what it
   does).

   However, it is possible to print an entire array in contexts outside of where it is declared, but you
   have to provide more information to gdb. Let's see how!
    1. Run gdb on the gdb_practice program. Set a breakpoint on main and step through the function past
       the variable declaration/initializations, including the array nums.
    2. Try p nums. Here in the context of its declaration, gdb knows that it is a stack array of a
       certain size and can show the entire stack array. Great!
    3. Now try p argv. All gdb knows about argv is that it is a pointer. Bummer.
    4. Try p argv[0]@argc and gdb will now print the entire contents of the argv array. Hooray!
    5. The syntax to learn is
p ELEM@COUNT

       where ELEM is the first element to print and COUNT is the count of elements to print. ELEM and
       COUNT are C expressions and can refer to any variables in the current scope.
       Try p nums[1]@2 to show a 2-element portion in the middle of the array.
    6. You can also add in a typecast if needed. For example, (as a hypothetical example, not related to
       the provided code) if you are given a parameter ptr of type void* that you know is the base
       address of an array of nelems elements of type char*, you could print the entire array as p
       *(char **)ptr@nelems.
    7. Try using this feature while paused in the my_function function to print out the contents of the
       passed-in array.

[Optional] Extra Problems
   Finished with lab and itching to further exercise your generics and function pointer skills? Check
   out our extra problems!

Recap
   Nice work on the lab! It's okay if you don't completely finish all of the exercises during lab; your
   sincere participation for the full lab period is sufficient for credit. However, we highly encourage
   you to finish on your own whatever is need to solidify your knowledge. Also take a chance to reflect
   on what you got what from this lab and whether you feel ready for what comes next! The takeaway from
   lab4 should be getting your bearings in the world of raw memory. The goals are for you to be able to
   write and use functions passed as parameters (including the cryptic syntax), and know how to use the
   type system to your advantage wherever you can, but also how to work without it where you must. You
   should know how to make a proper call to memcpy/memmove, exactly where and why you need a typecast,
   and have increased vigilance about using the correct level of indirection. Here are some questions to
   verify your understanding and get you thinking further about these concepts:
     * Why must you typecast a void* in a pointer-arithmetic expression?
     * An asymmetric comparison function is one that casts its two void* arguments to different pointee
       types. Why is passing an asymmetric comparison function to bsearch almost certainly an indication
       of programmer error?
     * C search functions commonly return a pointer to the found element (if any), not the found element
       itself. Why is this?


---
https://stackoverflow.com/questions/11103269/is-cutting-if-statements-by-using-function-pointers-going-to-be-more-efficient

Is cutting if statements by using function pointers going to be more efficient?

   So, there's this rule to try to pull if statements out of high repetition loops:

for( int i = 0 ; i < 10000 ; i++ ) {
	if( someModeSettingOn )  doThis( data[i] ) ;
	else  doThat( data[i] ) ;
}

   They say, it's better to break it up, to put the if statement outside:

if( someModeSettingOn )
	for( int i = 0 ; i < 10000 ; i++ )
		doThis( data[i] ) ;
else
	for( int i = 0 ; i < 10000 ; i++ )
		doThat( data[i] ) ;

   (In case you're saying "Ho! Don't optimize that yourself! The compiler will do it!") Sure the
   optimizer might do this for you. But in Typical C++ Bullshit (which I don't agree with all his
   points, eg his attitude towards virtual functions) Mike Acton says "Why make the compiler guess at
   something you know? Pretty much best point of those stickies, for me.

   So why not use a function pointer instead?

FunctionPointer *fp ;
if( someModeSettingOn )  fp = func1 ;
else fp = func2 ;

for( int i = 0 ; i < 10000 ; i++ ) {
	fp( data[i] ) ;
}

   Is there some kind of hidden overhead to function pointers? Is it is efficient as calling a straight
   function?

***
   In this example it's impossible to say which case will be faster. You need to profile this code on
   target platform/compiler to estimate it.

   And in general, in 99% case such code need not to be optimized. It's example of evil premature
   optimization. Write human-readable code and optimize it only if need after profiling.

***
   Don't guess, measure.

   But, if I absolutely had to guess, I'd say the third variant (function pointer) is going to be slower
   than the second variant (if outside loops), which I suspect might play with CPU's branch prediction
   better.

   The first variant may or may not be equivalent to the second one, depending on how smart the compiler
   is, as you have already noted.

***
   Why make the compiler guess at something you know?

   Because you may complicate the code for future maintainers without providing any tangible benefit to
   the users of your code. This change smells strongly of premature optimization and only after
   profiling would I consider anything other than the obvious (if inside loop) implementation.

   Given that profiling shows it to be a problem then as a guess I believe pulling the if out of the
   loop would be faster than the function pointer because the pointer may add a level of indirection
   that the compiler can't optimize away. It will also decrease the likelihood that the compiler can
   inline any calls.

   However I would also consider an alternate design using an abstract interface instead of an if within
   the loop. Then each data object already knows what to do automatically.

***
   My bet would be on the second version to be the fastest with the if/else outside the loop provided
   that I get a refund when we tie and test this across the widest range of compilers. :-D I make this
   bet with quite a number of years with VTune in hand.

   That said, I would actually be happy if I lost the bet. I think it's very feasible that many
   compilers nowadays could optimize the first version to rival the second, detecting that you're
   repeatedly checking a variable which doesn't change inside the loop and therefore effectively
   hoisting the branching to occur outside the loop.

   However, I haven't encountered a case yet where I've seen an optimizer do the analogical equivalent
   of inlining an indirect function call... though if there was a case where an optimizer could do this,
   yours would definitely be the easiest since it assigns the addresses to the functions to call in the
   same function in which it calls those functions through the function pointers. I'd be really
   pleasantly surprised if optimizers can do that now, especially because I like your third version best
   from a maintainability standpoint (easiest one to change if we want to add new conditions which lead
   to different functions to call, e.g.).

   Still, if it fails to inline, then the function pointer solution will have a tendency to be the most
   costly, not only because of the long jump and potentially the additional stack spills and so forth,
   but also because the optimizer will lack information -- there's an optimizer barrier when it doesn't
   know what function is going to be called through a pointer. At that point it can no longer coalesce
   all this information in IR and do the best job of instruction selection, register allocation, etc.
   This compiler design aspect of indirect function calls isn't discussed quite as often, but is
   potentially the most expensive part of calling a function indirectly.

***
   Not sure if it qualifies as "hidden", but of course using a function pointer requires one more level
   of indirection.

   The compiler has to generate code to dereference the pointer, and then jump to the resulting address,
   as opposed to code that just directly jumps to a constant address, for a normal function call.

***
       "code that just directly jumps to a constant address, for a normal function call" - and that's
       the worst case of a normal function call. It might be inlined.
     * 1
       Mind you, there isn't necessarily "one more level of indirection" in using a function pointer.
       It's some kind of call <register> instruction, compared to some kind of call <constant> function
       (with the constant fixed up by the dynamic linker), or conceivably set <register> <constant> then
       call <register>. I don't think it would generally be said that x + y involves an extra level of
       indirection compared with x + 12345. If stuff gets spilled to stack, then maybe it's extra work
       to use the variable, but the real reasons for function pointers generally being slower are not
       this.

***
   You have three cases:

   If inside the loop, function pointer de-ref inside the loop, if outside the loop.

   Of the three, WITH NO COMPILER OPTIMIZATION, the third is going to be the best. The first does a
   conditional and the second does a pointer de-reference on top of the code you want to run, while the
   third just runs what you want it to.

   If you want to optimize yourself do NOT do the function pointer version! If you don't trust the
   compiler to optimize, then the extra indirection might end up costing you, and it's a lot easier to
   break accidentally in the future (in my opinion).

***
   You have to measure which is faster - but I very much doubt the function pointer answer will be
   faster. Checking a flag probalby has zero latency on modern processors with deep multiple pipelines.
   Whereas a function pointer will make it likely that the compiler will be forced to do an actual
   function call, pushing registers etc.

   "Why make the compiler guess at something you know?"

   Both you and the compiler know some things at compile time - but the processor knows even more things
   at run time - like if there are empty pipelines in that inner loop. The days of doing this kind of
   optimization are gone outside of embedded systems and graphics shaders.

***
   The others all raise very valid points, most notably that you have to measure. I want to add three
   things:
    1. One important aspect is that using function pointers often prevents inlining, which can kill the
       performance of your code. But it definitely depends. Try to play around with the godbolt compiler
       explorer and have a look at the assembly generated:
       https://godbolt.org/g/85ZzpK
       Note than when doThis and doThat are not defined, e.g. as could happen across DSO boundaries,
       there won't be much of a difference.
    2. The second point is related to the branch prediction. Have a look at
       https://danluu.com/branch-prediction/. It should make it clear that the code you have here is
       actually an ideal case for the branch predictor and thus you probably don't have to bother.
       Again, a good profiler like perf or VTune will tell you whether you are suffering from branch
       mispredictions or not.
    3. Finally, there was at least one scenario I've seen where hoisting out the conditionals form a
       loop made a huge difference, despite the above reasoning. This was in a tight mathematical loop,
       which was not getting auto-vectorized due to the conditionals. GCC and Clang can both output
       reports about what loop gets vectorized, or why that wasn't done. In my case, a conditional was
       indeed the issue for the autovectorizer. This was with GCC 4.8 though, so things may have changed
       since then. With Godbolt, it's pretty easy to check whether this is an issue for you. Again,
       always measure on your target machine and check whether you are affected or not.


---

