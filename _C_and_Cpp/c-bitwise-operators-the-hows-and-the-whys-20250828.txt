filename: c-bitwise-operators-the-hows-and-the-whys-20250828.txt
https://medium.com/@peejayhack/bitwise-operators-the-hows-and-the-whys-5ccea3abafa3

Bitwise Operators: The How's and the Why's.
Aug 22, 2022

   Bitwise Manipulation is one concept that irked me for a while. Although straightforward, laying my
   hands on resources was the difficult part.

   Competitive programmers commonly utilize bitwise operators because they improve memory and speed
   performance. Most bitwise operations can only be visualized when numbers are represented in binary,
   that is, zeros and ones. I will be providing the binary conversion of the decimal numbers used in
   this article but I won't be going into detail on converting decimals to binary.

   Without further ado, let's dive right into it. We would be looking at the following bitwise
   operators: AND(&), OR(|), NOT(~), right-shift(>>), left-shift(<<) and XOR(^). The first few might
   seem familiar but stick with me to the end.

The AND Operator
   The AND(&) bitwise operator is somewhat synonymous to the logical and(&&) operator. It only returns
   True if both bits are 1's. Like I stated earlier, bitwise operators deal with the binary form of
   decimals. For example,
   1 & 0 => 0
   0 & 0 => 0
   0 & 1 => 0
   1 & 1 => 1

   As shown in the snippet above, the AND(&) operator only returns true when both bits are 1's. Let's
   look at an application of the and operator.

   APPLICATION OF THE AND(&) OPERATOR
   One application of the AND(&) operator is checking if a number is odd or even. Binary representations
   of even decimal numbers will always end with a zero and representations of odd numbers will always
   end with a 1. We are going to leverage this fact. For example:
   10 => Even => 1010 => ends with a Zero
   16 => Even => 1000 => ends with a Zero
   15 => Odd  => 1111 => ends with a One

   To test if a number(n) is odd or even using the AND operator we simply run
   n & 1
   n & 1 => 1 ? Odd : Even

   If the operation above returns a 1, it's odd. It's however even if it returns a 0.

   Proof:

   5(odd) & 1 = 1

   Behind the hood:

   5 => 1 0 1
   1 => 0 0 1 &
   ------------
        0 0 1

   5 & 1 => 1

   From the image above, we can see 5 & 1 gives us 1.

   6 & 1 on the other hand will yield 0.

   6 => 1 1 0
   1 => 0 0 1 &
   ----------
        0 0 0

   6(even) & 1 => 0

Checking if a number is even or not

if (6 & 1 == 0) {
	printf("It's even");
}

   And you might be soliloquizing "Why not just use the modulus operator?". The bitwise operator is
   significantly faster than the modulus operator which serves as a huge benefit to competitive
   programmers and efficient code.

The OR(|) operator
   The OR(|) operator is synonymous to the logical or(||) operator. The OR bitwise operator returns true
   if any one of the bits being compared is 1. For example:
   1 | 0 => 1
   0 | 1 => 1
   1 | 1 => 1
   0 | 0 => 0

   As shown in the snippet above, the OR operator returns True if either of the bits is 1 and a fallacy
   only if both is 0.

   An example:

   5 | 4 = 5

   101 => 5
   100 => 4 |
   ----------
   101 => 5

   Application of the OR operator
   Writing an implementation of the OR operator is rather laborious but it can be applied to robot
   sensors. How? Supposed we have four zero bits representing directions 0(forward) 0(backward) 0(left)
   0(forward). And we have four other zero digits representing a keypad sensor. All we have to do is set
   one of the sensor digits to one whenever a key is clicked and the machine runs the OR operator to
   determine which is being clicked. Let's look at a snippet to illustrate this.

              Forward   Backward   Right   Left
   Bits    => 0         0          0       0
   Sensor  => 0         1          0       0

              RUNS THE OR OPERATOR ON BOTH
   Result  => 0         1          0       0

   As shown in the snippet above, After running the OR operator between the keypad control and sensor,
   the robot is able to know which way to move.

The Right Shift(>>) operator
   The right shift operator does exactly what it says. It shifts the bits to the right by the number of
   times specified. For example:

   15 >> 2

   The operation above will shift the bits of 15 two times to the right. Let's look at the binary
   representation.
   15 => 1111

   Shifting this two bits to the right will yield 11. Shifting simply means pushing numbers off the edge.

   1111
   after first shift becomes => 111
   Second shift => 11
   The decimal representation of the binary 11 is 3

   There is also a straight-forward formula to computing the right-shift operation.

   Right shift = ( n >> i ) => n / 2^i

   The right shift operator can be used to get the value of a bit at a particular position. Consider the
   following code:

int get_bit(unsigned long int n, unsigned int index) {
	int bit;
	bit = (n >> index);

	if (index > 32)
		return (-1);
	return (bit & 1);
}

   The code above right shifts the bits by the number of indexes and then runs the bitwise AND operator
   on the most recent last digit to determine if it's a 1 or a 0.

The Left-shift(<<) Operator
   The left shift operator is the inverse of the right-shift operator. It shifts the bits to the left
   appending zeros behind. Consider the snippet below:

   1000101 <<  3

   To be left shifted three times
   Becomes
   1000101000

   As you probably noticed above, three zeros were appended to the binary number above changing the
   overall value of the binary number. The direct formula for the left shift operator is (n * 2^i)

   The left shift operator can be used to compute powers of 2 by simply left-shifting the power against
   1. For example:
   1 << 5 => 32
   32 is equivalent to 2^5

   1 << 6 => 64
   64 is equivalent to 2^6

   What's going on under the hood?
   From example 1, binary number 1 becomes 100000 after being left shifted five times.

   Binary number 10000 is equal to 32 in decimal

   With a few tweaks and a for loop, the binary left-shift operator can be used to convert a number from
   binary to decimal.

The XOR(^) operator
   The XOR also known as the Exclusive OR operator is by far the most commonly used bitwise operator.
   The XOR returns true only if a bit is a 1 and the other is a zero. It returns false if both are
   zero's and also false if both bits are 1's. Consider the snippet below:

   1 ^ 0 => 1
   0 ^ 1 => 1
   0 ^ 0 => 0
   1 ^ 1 => 0

   So basically, the XOR operator returns a 0 when a number is being XOR'ed(pun intended) with itself
   and returns the number when it's being XOR'ed with 0.

   An attribute of the XOR operator is that it has the commutative property. That is the order in which
   the operation is carried out doesn't change the result in any way.

   i.e both 5 ^ 5 ^ 6 and 5 ^ 6 ^ 5 will yield the same result.

   One application of the XOR operator is finding a number that occurs only once in an array where all
   other numbers occur twice.
   array = [5, 6, 7, 5, 7, 8, 9, 6, 9]

   From the array above, we can see that only the number 8 occurs once in the array. How can we obtain
   this though?

   My approach is to take each number from the array run the XOR operation on them. This gives us
   5 ^ 6 ^ 7 ^ 5 ^ 7 ^ 8 ^ 9 ^ 6 ^ 9

   But how does this even help us?

   Recall I said earlier that "the XOR operator returns a 0 when a number is being XOR'ed with itself
   and returns the number when it's being XOR'ed with 0" and I also said the XOR operator is
   commutative. Keeping both of this in mind, let's re-arrange the digits above.

   5 ^ 5 ^ 7 ^ 7 ^ 8 ^ 8 ^ 9 ^ 9 ^ 6
   "The XOR operator returns zero when a number is being XOR'ed with it self". Applying this:
   5 ^ 5 = 0
   7 ^ 7 = 0
   8 ^ 8 = 0
   9 ^ 9 = 0

   Giving us:
   (0) ^ (0) ^ (0) ^ (0) ^ 6

   And also recall I said XOR returns the number when it's being XOR'ed with 0. Applying this concept gives us:
   0 ^ 6 = 6

   Therefore giving us the number that occurs only once in the array.

The NOT(~) operator
   The NOT operator flips bits. All bits are flipped, 1's turn to 0 and 0's turn to 1.

   For example, the binary number 10010101 becomes 01101010.

   The direct formula for computing the NOT operator in decimal is x = -(x + 1)

   That is, ~17 becomes -(17 + 1) => -18

   Conclusion
   Although, bitwise operators are efficient, it's best to avoid them for code readability sake except
   when absolutely necessary!


---

