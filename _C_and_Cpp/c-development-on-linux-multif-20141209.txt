filename: c-development-on-linux-multif_20141209.txt
http://how-to.linuxcareer.com/c-development-on-linux-introduction

1. Introduction

    What you're just reading is the beginning of series of articles dedicated to development
   on Linux systems. However, with minor modifications (if any), you will be able to use this
   knowledge you will get by reading our series on any other system that uses the same tools
   (OpenIndiana, BSD...). This first article will deal gradually with the intricacies of
   writing C code on Linux. You are expected to have basic programming knowledge, either on
   Linux/Unix systems or on other platforms. The idea is that you should know the basics of
   programming, like what a variable is or how to define a structure. Even though, you will
   get this information from this article, we won't insist very much on beginner-level
   concepts. A word of warning: we won't include everything there is to tell about C, because
   that would take lots of space and of course, we don't actually know everything about C.
   However, for more information and discussion about C please visit our new [36]Linux Career
   forum.

1.1. Why C?

   Some of you might argue that C is not the best beginner-level language ever. Agreed, but
   again, you're expected to have some basic programming knowledge, for one. Second, C and
   Unix, and Linux afterwards, are intimately tied together that it only seemed natural to
   start our development series with C. From the kernel, of which a substantial part of it is
   written in C, to lots of everyday user-land applications, C is used massively on your Linux
   system. For example, GTK is based on C, so if you're using Gnome or XFCE applications,
   you're using C-based applications. C is an old, well-established programming language,
   vital tool in many parts in the IT world, from embedded systems to mainframes. Therefore,
   it is only fair to assume that C skills will not only enrich your CV, but they will also
   help you to solve many issues on your Linux system, that is only if you take this seriously
   and practice a lot by reading and writing C code.

2. About C

2.1. History

   C is more than 40 years old, with beginnings at Bell Labs with Brian Kernighan, Dennis
   Ritchie and Ken Thompson as the "usual suspects." Unix development and C's evolution are
   intimately linked, as we said, because Unix was initially written in assembly, but that had
   lots of shortcomings. Therefore, when moving to the PDP-11 as the main hardware platform,
   the developers started C as the as a core language for Unix. In 1978, Kernighan and Ritchie
   wrote, "The C Programming Language," a book that is today as it was 20 years ago: THE book
   on C programming. We heartily recommend you get it.

2.2. Classification

   There are always people keen on classification of things and of course, programming is no
   different. Joking aside, since we're at the beginning, we thought you should know that C is
   a procedural structured programming language, with weak typing. What we just said, in
   English, is that C uses procedures (the usual name used by C programmers, and the one we'll
   use as well, is functions however), that it uses a structured approach (think blocks of
   code) and finally, it supports implicit type conversions. If you don't know what any of the
   above means, fear not, you'll find out!

2.3. Our approach

   This article which is just the introductory part and we will regularly publish next parts
   where each chapter will deal with an important part of the language: variables, pointers,
   structs, etc. ( subscribe to [37]RSS feed if you have not done so yet ) At the end of the
   theoretical part, we will show you a practical example, for which we chose [38]yest, a tiny
   piece of software written by Kimball Hawkins (thanks, Kimball). We will compile it, then
   package it for Debian and Fedora systems. Debian developer Andree Leidenfrost will then
   show you how to submit our new package into Debian repository, making sure we respect all
   package requirements to be admitted to Debian distribution (thanks, Andree). We recommend
   you to try our examples on your system, take some time to examine the code and try to make
   modifications of your own.

3. The necessary tools

    Before we begin, let us make sure we have all essential tools installed on your Linux
   system. You will need a compiler, namely gcc, the binutils package and a text editor or an
   IDE. Whether you choose text editor or some sort of IDE depends largely on your
   preferences, but more on that later. Depending on your Linux distribution and installation
   options you have used, you might already have the necessary tools installed. We put
   together a tiny script to help you see whether you have all mandatory development tools
   installed:
#!/bin/sh
gcc -v
if [ $? != 0 ]; then
       echo "GCC is not installed!"
fi
ld -v
if [ $? != 0 ]; then
        echo "Please install binutils!"
fi

   Save this script as devtoolscheck.sh, run it:
 $ sh devtoolscheck.sh

   On my machine I get following output:
$ sh devtools.sh
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/x86_64-linux-gnu/gcc/x86_64-linux-gnu/4.6.1/lto-wrapper
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Debian 4.6.1-4' --with-bugurl=
file:///usr/share/doc/gcc-4.6/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++,go
--prefix=/usr --program-suffix=-4.6 --enable-shared --enable-multiarch
[config options snipped]
Thread model: posix
gcc version 4.6.1 (Debian 4.6.1-4)
GNU ld (GNU Binutils for Debian) 2.21.52.20110606

   Why you need binutils binaries and gcc, you will see shortly. Now let's focus a bit on
   "editor vs IDE" question.

   The only thing we will advise you in this respect is "use what you feel comfortable with
   and disregard what others tell you". This matter is very subjective and it depends on many
   variables. For example, if you develop (or used to develop) on other operating systems, you
   might be used to an IDE. You will find many good IDEs on Linux, including Eclipse, Geany,
   KDevelop or Anjuta. Try installing them to see what you find more suitable. On the other
   hand, if you want to go the simple editor way, there are lots of options here as well:
   vi(m), emacs, kate, nano, jed and so on. By searching the Internet  you will find a lot of
   discussions regarding what the best editor is. We say install few of them and find out what
   suits you best. You are the only judge of this, and it will be a tool you will use
   frequently, so take your your time, use it, read about it and get familiar with
   it. Regardless of your choice, we will assume that you have made your choice in regards to
   the editing tool and you are familiar with its use.

4. The compilation process

   C program compilation process

   In simple words, this process is what starts from the source code you wrote and if all goes
   well the result is an executable binary or a library. Needless to say, there's more to it
   but it is essential for you to understand the above sentence before you move on. You do not
   need to memorize all the concepts now as they will become clearer later. At this stage it's
   only important to get the general idea.

   Let's say we have the source code written and now we want a compiler to process it and give
   us the executable binary. The workflow of this process is illustrated on your right.

   Please note that this is applicable only to C, which is a compiled language, as opposed to
   interpreted languages (Perl, Python, Shell), and we will refer strictly to gcc and friends
   for the rest of our guide. As the figure on your right illustrates the preprocessor (cpp)
   takes your source code, looks for preprocessor instructions (in C, they start with a hash)
   and if everything looks right, the result is an output understandable by compiler. The
   compiler (gcc) does all the hard work, including code optimization for the underlying
   hardware (if you are interested in compiler theory or cross-compilation, there are lots of
   good books on the subject, but we assume a more beginner level here). The result is
   assembly code, intimately close to the machine, from which the binaries will be generated
   (as is the tool). In the end, depending on the options and the code, "ld" will link the
   executable to all necessary libraries and voila! the end result: your program. If you want
   to see all the resulting intermediate files, gcc flag -save-temps as will help you to do
   so. We recommend you read the gcc manual page, at least frugally, and make sure that your
   compiler us up to date. You will get used to usual gcc flags by reading our examples, but
   you are expected to know what they do, not just copy and paste commands you see on the
   screen.

5. Example C program

   Every self-respecting programming tutorial starts with a "Hello, world" program. This
   program does nothing else but print "Hello, world!" on the screen, then exits. It's used to
   illustrate the very basic structure of a program and some essential concepts. So, without
   further ado, here it is.
#include <stdio.h>
/* This is a comment */

int main()
{
    printf("Hello, world!\n");
    return 0;
}

    Now, let us dissect the program line by line and see what each line represents. The first
   one is a preprocessor directive (see above) which asks for the stdio.h file, which provides
   the definition for the printf function. Header files are files that usually contain various
   definitions (functions, variables...) and make .c files less cluttered. All what a source
   file (.c) will need is an #include statement and possibly an argument to the linker.
   Everything that's defined in the included header file will be available in your source
   code.

   main() is a mandatory function in every C program. As the name states, the main activity
   will happen here, regardless of how many functions you have defined. int main() means that
   this function does not have any arguments (the empty parentheses) and that it returns an
   integer (the initial int). All these will be discussed later. The most important thing here
   is the printf function, which takes our text as an argument and displays it. "\n" means
   "newline" and it's the equivalent of using the Enter key (or ^M). It is called an escape
   sequence and all escape sequences in C begin with "\". For example, to better understand
   what an escape sequence is, imagine you're writing HTML code and you need to print a "<"
   character. HTML's syntax uses angle brackets to define HTML tags, so chances are your
   bracket will be interpreted as HTML code instead of being displayed. So, what to do? We
   escape it with "&lt;" and it will appear properly. Just the same, if you want to insert a
   newline character, you can't type it directly, as the compiler could care less if you write
   your program on a single line or not and therefore you you need to escape your new line
   character with "\n".

   return 0 tells the compiler that everything is ok and the execution of main() function ends
   there. That is because 0 is the code for successful execution, while values greater than 0
   (integers) is an indication that something went wrong. The curly braces that begin and end
   the main function delimit its' execution block, that is, what happens in main(), stays in
   main(). You may have noticed the semicolons at the end of the statements: they are
   mandatory as a sign that the current statement ended there, but they are not to be used in
   preprocessor directives as #include.

6. Compilation

   Compilation will be discussed in more details in upcoming parts of this guide. But for
   the completeness here is a simple command line example on how to compile and execute
   our first "Hello World" C program:
$ gcc -o hello hello.c
$ ./hello
Hello, world!

7. Conclusion

   We hope we didn't cram too much information in your brain and that you will enjoy staying
   with us on this programming tutorial. Part 2 will be dealing with a comparison between C
   and other programming languages in order to help those who already have some experience in
   development. So make sure you are subscribed to our [39]RSS feedso you'll know when part
   two arrives.

   Here is what you can expect next:
     * [40]I. C development on Linux - Introduction
     * [41]II. Comparison between C and other programming languages
     * [42]III. Types, operators, variables
     * [43]IV. Flow control
     * [44]V. Functions
     * [45]VI. Pointers and arrays
     * [46]VII. Structures
     * [47]VIII. Basic I/O
     * [48]IX. Coding style and recommendations
     * [49]X. Building a program
     * [50]XI. Packaging for Debian and Fedora
     * [51]XII. Getting a package in the official Debian repositories



---
http://how-to.linuxcareer.com/c-development-on-linux-comparison-between-c-and-other-programming-languages

C development on Linux - Comparison between C and other programming languages - II.

1. Introduction

    Since in our [39]first part of this article we said we expected you, the reader, to have
   some programming knowledge, in this part we want to help you get a on where C stands
   in comparison to other programming languages you might know. The choice of those languages
   was pretty tough because of various criteria, but in the end we stopped at C++, Perl and
   Python. Since programming languages can be classified in lots of ways (depending on
   paradigm, syntax or style, for example), we didn't try to find languages that are in the
   same category as C. Instead, since the aforementioned languages are pretty popular in the
   Linux world, we chose them, mentioning what every language's place is in the great scheme,
   what it's generally used for and of course, the differences between them and C. This
   article will be structured as follows: we'll start with important elements of every
   language, like variable declaration, typing or structure and compare that with how it's
   done with C. Thusly we hope to give you an idea about the language before we start. The
   parts this article is made of will be exactly like the [40]announced structure of this
   article, to make comprehension easier. If you have suggestions or questions in regards to
   this article please visit our new [41]Linux Forum. We will be glad to help you there. Thank
   you.

2. The comparison

2.1. Types, operators, variables

2.1.1. C++

    C++ was initially named "C with classes", which says a lot about its' relation with C. It
   is widely seen as a superset of C ( thus C++  the unary increment operator ++ ) ,
   introducing object-oriented programming features. Types are essentially used the same, with
   bool being introduced in C++ for boolean operations. Basically, when talking about C and
   C++ differences, most of those come from the OOP concepts C++ has and C does not. For
   example C++ has operator overloading, an OOP-specific term, which means that an operator
   may have different implementations depending on the data it's operating on. For example, in
   C++ you can do this:

a << 2

   Now, if a is an integer, this will do a bitwise operation on it (left shift by 2), but if a
   is an output stream, the above line will try to write a '2' to it. This kind of behavior is
   one of the reason C++ is criticized for allowing poor programming practices. Variables and
   constants are declared the same way as in C.

2.1.2. Perl

   With Perl it's simpler: it only has three data types. These are scalars, arrays and hashes
   or associative arrays. Scalars are prefixed with a dollar sign, arrays are prefixed with a
   @ and hashes are prefixed with %s. The difference regarding types is that Perl is a dynamic
   programming language, while C is weak-typed, meaning that in C you will deal with proper
   declarations of variables, like "this variable is an integer" or "this other variable is a
   pointer to a float". The differences regarding arithmetic operators are just that Perl has
   '**' for exponentiation, while C needs a function to achieve that.

2.1.3. Python

   Python's variable declaration is context-based. For example, we want to declare a string,
   an integer and a float:
var1 = "String"
var2 = 100
var3 = 100.98

   With C, this would have been like
char* var1 = "String";
int var2 = 100;
float var3 = 100.98;

    C doesn't have a string type as other languages do, so a string must be declared as an
   array of characters or a pointer to a char, while Python offers numbers, dictionaries,
   strings, lists and tuples as data types.

2.2. Flow control

   All four languages described here have many things in common when it comes to flow control.
   For example, when starting an if block, none requires an ending keyword, like fi in
   [42]Bash or Algol68. Speaking of if blocks, the syntax is similar, so if you used to
   program in C++, Perl or Python you'll find C's way very familiar. The same can be said
   about the rest of the flow control operations: for, do, while, switch/case or
   break/continue. Again, if you're accustomed to the way the three languages do flow control,
   you'll need a few minutes to get used to C. Some main differences could be: Perl has more
   keywords to deal with this than C, like redo, last or next.  Python has the pass keyword
   for...doing nothing basically, but it's useful when one needs an empty class. For example:
class Empty:
     pass

2.3.  Functions

   A simple function declaration in C would be like this:
int sum (int a, int b)
    {
        return a + b;
    }

    This would be a function named sum that returns an integer from calculating the sum of
   its' arguments, a and b, also integers. Note the blocks that make a clear delimitation as
   to where the function's body starts and when it ends. In Perl the term function is used
   interchangeably with subroutine. You can, as in C, first declare a function, then define
   it, or declare it and define it in one shot, like we did above. You have to use the sub
   keyword in order to tell the Perl interpreter what you want to do. In Python our sum
   example would look like this:
def sum ( a, b ):
  return a + b

    You perhaps noticed that we said nothing about C++. Well, as far as we're concerned, there
   is no difference between C and C++ in this respect.

2.4. Pointers and arrays

    A pointer is a variable that holds the memory location of another variable. As in C,
   [43]pointers and arrays are tied together pretty tight and offer many advanced features to
   the C++ programmer. Again, there is no important difference between the two. Perl has
   references that offer the same functionality. For example, this piece of code defines a
   variable named var and a reference to it named refvar:
$var = 20;
$refvar = \$var;

   In C, we would have done something like
int var;
var = 20;
int *refvar;
refvar = &var;

   Perl, like Python, doesn't allow the programmer to do direct memory manipulation. Some see
   this as a good thing, others not. Python offers ctypes, which is a library that offers the
   pointer() function for using pointers. The short story is: Python doesn't use pointers. The
   long story is that Python's way to reference variables, that is by-value only, is different
   to a programmer used to C.

   If you used arrays on C++ or Perl, the concept is mostly the same. Perl has a different
   syntax, but if you already know what an array is, you'll be alright in C. Python offers the
   array module that offers this functionality, because it already has lists as a basic type,
   except arrays are more restrictive.

2.5. Structures

   In C, a struct is a record that contains a fixed, labelled set of objects, all wrapped into
   one. For example:
struct customer {
   int account;
   char *name;
   float balance;
};

   Quoting Wikipedia, "In C++, a structure is a class defined with the struct keyword. Its
   members and base classes are public by default. A class defined with the class keyword has
   private members and base classes by default. This is the only difference between structs
   and classes in C++.". In Perl until version 5, structs were a problem (or lack thereof),
   but now there is perldsc (Perl Data Structures Cookbook), available at perldoc.org. In
   Python you can always (well, almost) use tuples or dictionaries for this.

2.6. Including files

   As you have seen in the first part, in C one uses preprocessor directives to include
   definitions from other files. This functionality is offered also by C++, with the same
   syntax, except header files are named $name.hpp and that you don't need the file extension:
#include <iostream>

   iostream is the C++ equivalent of stdio.h. In Perl, we have the use keyword for this, and
   can be used like this:
use Module;

   In Python, the equivalent of use is import, used in exactly the same way as in Perl, except
   it doesn't require a semicolon at the end.

3. Other considerations

   Many of you have noticed that all languages chosen for our comparison are object-oriented,
   while C is not. This is not an unfair comparison, because if we would have chosen Fortran
   or Prolog as our terms of comparison, chances are, since many programmers today don't use
   these languages, that our article wouldn't have been very popular. On the other hand, we
   thought of this as a way to get your feet wet, because habit is part of the human nature
   and if you ever used one or more of these languages, it will be easier on you when you
   start learning C. So this part of the article is intended as a helping hand and if we
   managed to do that, that it's ok.

4. C and C++

   Some of you may wonder: if C++ is so similar to C, but it's more complex and offers more,
   why bother with C? This has been a topic discussed more than it should have been, and we
   will try to give an answer of our own. First of all, C is simpler. K&R has 266 pages, while
   "The C++ programming language" by the creator, Bjarne Stroustrup, has 1090. 'Nuff said.
   Second, existing code. Regardless of hardware architecture, operating system or purpose, C
   is widespread and then some. From OS kernels to GUI libraries, C is there and has no intent
   to leave anywhere. That isn't to say C++ isn't used by many developers. We're just saying
   that sooner or later you'll find yourself having to work with C code or use a language
   influenced by it, so C knowledge is always good-looking on a [44]CV. Third, if you want to
   learn C and C++, you're better off starting with C, because of its' aforementioned
   simplicity and because once you'll have the basics, C++ will look easier to learn. Finally,
   it's all about the right tool for the job. If you need fast code, the ability to go
   low-level and a simple language, go with C.

5. Conclusion

   After this second part of this article, we will start  learning C programming on Linux, as
   we think that too many introductory parts make no sense. Make sure you're subscribed to our
   [45]RSS feed to know when the next part will be published. For a further discussion and
   questions about this this and any other Linux topic please visit our new [46]Linux forum.
   We will but glad to help you there.



---
http://how-to.linuxcareer.com/c-development-on-linux-types-variables-operators

C development on Linux - Types, variables, operators - III.

1. Introduction

   As [37]promised, starting with this part of our C development article, we will get started
   with learning, without further introduction. I couldn't find no better way to start other
   than this, because types, operators and variables are an essential part of C and you will
   use them all the time when writing your own programs. For example, you can write a simple C
   program without defining your own functions, but it's harder to do that without some
   variables, unless you wanna stick to "Hello, world!". A variable is nothing more than a
   location in memory holding a value that can be altered (hence the name). But before you
   declare a variable you must know what kind of value you want it to hold, and here you will
   use types. And in order to operate on those variables, you'll need...operators, of course.
   I intend to make this course as concise as possible, so I recommend attention and as usual,
   practice. Any questions can be addressed on our [38]forums, and we will do our best to
   answer them.

2. Types

   As said, before you go and declare a variable, you must know what kind of value will it
   hold. Will it be a number? If so, how large could it possibly get? Is it an integer? Or
   maybe you want to declare a string? These are things you must know for certain before
   choosing the type, and we recommend extra care when it comes to possible buffer overflows.
   C is the kind of language that gives you enough rope to hang yourself and doesn't do much
   hand-holding, and these errors are very hard to spot in a large program.

   Before we start, you must be aware of relationships between hardware and types. This is
   where we expect you to do some reading for yourself especially if you're using hardware
   other than x86, be it 32 or 64-bit, compilers other than gcc or operating systems other
   than Linux. Usually, these differences appear when dealing with floating point values. We
   won't get deeper into this, as it's not the time nor the place, but you are expected to
   read some documentation on your compiler, especially hardware-dependent parts. Now let's
   start.
char c;
unsigned char uc;
short s;
unsigned short us;
int i;
unsigned u;
long l;
unsigned long ul;
float f;
double d;
long double ld;
const int ci;

   We decided to take the path of "example first, explanations later" here, because we felt
   that some of you will find the above example familiar. There are other related languages
   that declare their variables in almost the same way, and after all, the keywords are
   intuitive. Before we go on, it must be said that char, int, float and double are the
   primary data types in C. Unsigned and signed are modifiers, meaning that if you need to
   work with values smaller than zero, you should tell the compiler that your variable is
   signed, as in it can be larger or smaller than zero. long and short (these are applicable
   to integers usually) allow you to store bigger values, or smaller, and the number of bytes
   is machine-dependent, but a short must be always smaller than an int, which in turn must be
   always smaller than a long. As you can see, in practice one does not use long int or short
   int, just long or short. The const keyword tells the compiler that once a variable has a
   value, it cannot be changed.

   Let's start with the smallest type, char. It is guaranteed to be large enough to hold one
   byte's worth, and it's always fixed size. If people will tell you that a byte is always
   eight bits, better think again. Every popular hardware architecture indeed uses eight-bit
   bytes, but there are exceptions, so don't make assumptions if you want to write portable
   code. On x86, since a byte is eight bits, a char (unsigned) can hold values from 0 to 255,
   that is 2^8. If a char is signed, then it can hold values from -128 to 127. But the name
   may mislead you: a character can indeed be stored in a char, but if you're using Unicode,
   we're talking multibyte there and you'll have to use wchar_t, but more on that later.

   Now that you know what type modifiers are, we can get to integers. On integers, you can
   combine the sign and length modifiers, as seen in the example above, to fit your needs.
   Remember to have an editor handy and check with the limits.h header (on my system it's to
   be found in /usr/include) to find out the actual limits on your system. As a short rule, an
   int will hold values from 0 to 65535 or, if signed, from -32768 to 32767. And a long
   modifier will double the number of storage bytes, so if an int requires 2 bytes, a long
   will require 4. We'll leave it up to the user to figure out the rest of the integers and
   their minimal and maximal values. We will however, show you how to find out sizes and
   limits on your system.

   floats are floating-point values, which implies that you must define a variable like this:
float value;
value = 234.00;

   even if it doesn't have nothing after the dot (the decimal part), so it's an integer
   actually. There are actually situations where you must declare an integer value as a float,
   because the value might change and the declared type must be able to store floating point
   values. All the values on your machine can be found in float.h.

3. Variables

   Now that you know what types you have available in C, let's see how you can effectively use
   them. Some of might wonder "if we have long doubles that can store values so big, why not
   use them everywhere?" . Programming is about efficiency, and C programming especially so,
   and that's why storing a value like 23 in a double will use 4 times the necessary memory,
   for nothing. When you declare a variable, a chunk of memory is reserved for it depending on
   the type. So why waste memory for no good reason? Create a habit of using the exact type
   that fits your (possible) values, not less, not more. You have seen above how to declare
   variables. Now let's see how to define them, as in let's give them a value.
c = 'a';
i = 234;
f = 12643.984;
ld = 16546581654161598309.87;

   We took the names from the previous examples, which, as you may have noticed, are written
   to reflect the assigned type, so 'ld' is a long double and so on. In this example we took
   two steps: the first to declare the variable, the second to define it by assigning it a
   value. Some will say it's good style to write code like that, but you can do both
   operations in one step and no one will hurt you:
char c = 'a';
int i = 234;
float f = 12643.984;
long double ld = 16546581654161598309.87;

   We recommend and even urge you to use names with a meaning in your code, and comment it as
   much as possible: chances are there'll be others reading what you wrote and their life will
   be so much easier if you do. Also, use caps only when necessary, especially since C uses
   all-caps in various preprocessor directives. Also the first character in the variable name
   must be a letter.

   As promised, since all talk and no play ain't good, we'll show you a little program you can
   use to see the minimal and maximal values of various types, but we'll just illustrate a
   few. The rest will be your job to do, following our example, with an editor having limits.h
   and float.h open. There will be some new elements here, but never worry, they will be
   explained.
#include <stdio.h>
#include <float.h>
#include <limits.h>

int main()
{
  unsigned long long ullmax = ULLONG_MAX;
  long lmax = LONG_MAX;
  long double ldmax = LDBL_MAX;

  printf("The max value of an unsigned long long is %Lu.\n", ullmax);
  printf("The max value of a long is %ld.\n", lmax);
  printf("The max value of a long double is %Lf.\n", ldmax);

  return 0;
}

   So, we declare three variables with meaningful names and assign them the values of three
   macros defined in limits.h and float.h. Then of course, we'll have to print them. We do
   that using printf(), and here we'll stop for a little talk. We recommend 'man 3 printf' for
   further details on format strings, that is, the part inside printf's double quotes that
   start with a '%'. They tell printf what kind of value it should expect, so it should behave
   differently with different types. In the first example '%Lu' means long long (the L), which
   is unsigned (the 'u'). For integers, the format string is 'd', for decimal, and because
   it's a long integer, it will be'%ld'. In the third printf, f stands for float, a double is
   basically a long float, and a long double is a long long float, hence the format.

   Now, save the above code, compile it and run it. This program, once you add more to it,
   will help you when you want to declare a variable, but you're yet uncertain what type it
   should fit into.

4. Operators

4.1. Arithmetic operators

   This subchapter, of course, deals with the usual basic operators you learned in primary
   school. But there's a little more. Foe example,. the +, -, *, / and % operators are the
   binary operators. % is the modulo operator, meaning that if we have 50 % 2, the result will
   be 0 because the result of the division 50 / 2 has an integer as a result. You can use the
   first four operators with any numeric value, but modulo deals only with integers.
   Precedence is the same as in the arithmetics book.

4.2. Relational operators

   These operators are >, >=, <=, <, and they all have the same precedence. For the next part
   we recommend extra care, because it's cause for much confusion in the beginner's league,
   and non-beginners alike. Like said above, one uses '=' to give some value to a variable.
   But if you want to check if a variable has a certain value, you use '==', and if it hasn't,
   use '!=', where '!' is the logical negation operator, as you'll see. Let's take the
   following (useless) example:
#include <stdio.h>

int main()
{
  int var = 4;

  if (var == 4)
    printf("var is 4!\n");
  else
    printf("There's something amiss.\n");

  return 0;
}

4.3. Casting

   In a nutshell, casting is forcing the compiler to forget about a variable's type and treat
   as having another type that you supply. This isn't done randomly, only between compatible
   types, and care is recommended when using casting. For example, let's say we want to find
   out the ASCII value of 'a'. The code could look like this:
#include <stdio.h>

int main()
{
  char c = 'a';
  printf("The ASCII value of 'a' is %d.\n", (int)c);

  return 0;
}

   You will get the value 97, which is indeed the ASCII value of 'a'. So, by using parentheses
   before and after the type you want to "impose" and all this before the variable's name, you
   get casting. The example above works because a char is nothing more than a small int, so
   the types are compatible. Try casting the variable above to other types and note the
   results.

4.4. Increment and decrement operators

   You've heard about C++ for sure. Well, it's name suggests that it's somehow more than C,
   because '++' is an increment operator (adds 1 to the variable's value), just as '--' is a
   decrement operator. These are unary operators and can be prefixed as well as postfixed.
   What does that mean? It means that you can write either ++c or c++, and the result may or
   may not be similar. The difference is that with '++' prefixed, the value of the variable is
   first incremented by one, then used, and the other way around. We'll show you a short
   example of when it matters and when it doesn't.
#include <stdio.h>

int main()
{
  int x;
  int n = 10;
  int z;

  n++; /* n will be 11 now */
  ++n; /*ditto, prefix or postfix unimportant */

  x = n++; /* x will be 10 */
  z = ++n; /* z will be 11 */

  return 0;
}

   But what if you want to increment/decrement with more than one? Simple, since c++ is the
   equivalent of c+=1. Replace 1 with whatever value you need and you're set. These compound
   operators can also be used with any other binary arithmetic operators (e.g. *= or /=) and
   the bitwise operators as well, like 'a &= b'.

4.5. Bitwise operators

   In C you can do bitwise operations easily, but remember! They work and are to be used only
   with integer types, signed or unsigned. These operators are:
& - bitwise AND
| - bitwise OR
^ - XOR
<< - left shift
>> - right shift
-  - one's complement

4.6. Logical operators

   We've already dealt with '!', which negates any logical expression, but there are two very
   important logical operators (be careful not to mix them up with the bitwise ones): and and
   or, respectively. So, if I want to write in C something like "if variable 1 has value 2 and
   variable 2 has value 8", I'll write like this:
if (var1 == 2 && var2 == 8)
  ...

   Here both conditions must evaluate as true for the instructions following if to execute. If
   either will do, or both, we replace '&&' with '||' (conjunction versus disjunction).

4.7. Other operators

   People that have some C experience may have noticed the lack of some operators. Of course,
   and we're aware of that, but what sense would it make to list the indirection operator
   while readers don't know what a pointer is? So, the other operators, specific to other
   parts of C, will be dealt with in due time.

5. Conclusion

   With the examples offered in this part, we're certain you have enough to play a little and
   try various options. You know, the compiler won't bite if you feed it wrong data, nor will
   the computer explode. And, like we said before, you can't learn programming by reading
   books only. So get your keyboard and create something interesting.



---
http://how-to.linuxcareer.com/c-development-on-linux-flow-control-iv

C development on Linux - Flow Control - IV.

1. Introduction

   You have already been exposed to a small part of what flow control is in our [35]previous
   part, namely the section about relational operators. As you start writing more complex
   programs, you will feel the need to control the order in which your program executes
   various parts.
   Flow control is present in most programming languages in one form or another, and what
   you're about to read here is essential to writing C programs.Everything you might want to
   ask or discuss you can take to our new [36]forums, as before.

2. if/else/else if

   This part of flow control is probably the most intuitive and simpler, although you can
   easily fall to the dark side and start writing unintelligible code with ifs. The idea is
   simple: if (condition_is_true) do_something; else do_something_else; . So it's all about
   logic, binary logic that is, in which an expression can have two values: true or false. If
   you used C or Java, you're used with the bool datatype. A bool variable can be only true or
   only false at a given moment. But C, although it doesn't have the bool datatype, makes it
   easy to deal with binary logic, as you will see.

   Let's say you want to tell the user of your program if he's old or not, depending on his
   age. Not quite useful and possibly offending, but for the sake of illustrating our point,
   it will do. So the main idea is: if the age entered is above a threshold, then we tell the
   user he's old. If not, we tell him/her he/she is still young and blooming. The code for
   such a program would look like this:
#include <stdio.h>
#define LIMIT 50

int main()
{
  int age;
  printf("Hello, please enter your age!\n");
  scanf("%d", &age);
  if(age < LIMIT)
  {
    printf("Your age is %d.\n", age);
    printf("Quite young, I say.\n");
  }
  else if(age == LIMIT)
  {
    printf("You say your age is %d.\n", age);
    printf("Almost there.\n");
  }
  else
  {
    printf("So your age is %d, huh?\n", age);
    printf("Geezer.\n");
  }

  return 0;
}

   This program is clearly of no practical use, but there are elements in it that will help us
   get our point across and illustrate some new elements. For example you will see we defined
   a constant named LIMIT (it's recommended to capitalize your constants) with a value of 50,
   which is the threshold we talked about above. Next you will notice that C doesn't use
   'then' after the if expression like the Bourne shell does, for example. Finally, we wrote
   this program like this because we can illustrate another important concept: blocks. A block
   is a series of instructions that belong together, united by braces. Please bear in mind
   that if you use else if you can omit the final else, depending on the situation.

   So, our first block says "if age is smaller than 50, print 'Your age is $age' and print
   'Quite young, I say'. When you start reading other people's code, you will notice blocks
   are used a lot in C , and we recommend you use them whenever you need them and sometimes
   even when you don't, to make your code more accesible to mere mortals. What was meant by
   "even when you don't"? Well, C allows you to nest ifs and things may go south very easily
   and create bugs that will be hard to trace, or your code can become a mess to read by
   others and even you, so if you plan to really use nested ifs and can't live without them,
   we recommend you abuse the use of braces for clarity. There are lots of situations where
   the logical AND operator can save you and make your code become more readable. Consider the
   following example:
int number = 3;

if ((number > 2) && (number < 4))
{
  printf ("number is three");

/* This could have been written like this:*/

int number =3;

if (number > 2)
{
  if (number < 4)
  {
    printf ("number is three");
  }
}

   Again, this is a simple example, but I think you got the point. Use whatever method
   necessary and remember that '&&' is not always a substitute for nested ifs, but if you need
   overly complicated if structures, you probably need to rethink your program's logic.

3. while and for

   With this section of our article, we introduce another essential concept of C programming:
   loops. A loop allows you to repeat a certain instruction or block depending on a condition,
   that is, execute something until some condition changes its truth value from true to false.
   As you can see, this concept is related to conditional instructions and they can be used
   together if need be.

3.1. while

   The theoretical concept of while is 'while (expression_is_true) execute_something;' . With
   each iteration, the expression in reevaluated and if it's still true, the instruction(s)
   is/are executed again, until the expression we test against becomes false. From here we can
   infer that if we want to write an infinite loop using while, we can write
while(1)
{
  do_stuff();
  do_more_stuff();
}

   Like we said, C doesn't have a bool keyword, but you can do something to overcome this: you
   can compile your programs to adhere to the C99 edition of the standard (-std=c99 as a gcc
   flag), which will let you access the _Bool datatype, you can use stdbool.h which defines 1
   as true and 0 as false or you can define TRUE and FALSE with preprocessor instructions.
   What method do you think would work better and why? How would you rewrite the code snippet
   above considering what was said above?

   Anyway, let's continue with a complete, working example. Let's say we want to output some
   message on the screen 5 times. We will talk about the same example later using for, but for
   now let's see how to do it with while.
#include <stdio.h>

int main()
{
  int i;
  i = 5;
  while(i != 0)
  {
    printf("Hello!\n");
    i--;
  }

  return 0;
}

   So while executes the instructions between its braces until 'i != 0' evaluates as false,
   that is when i equals zero, then it stops. For this loop to work, we need to decrement i at
   each pass, until it reaches zero.

3.1.1. Exercise

   while loop interactive C Now, considering the following flow control design on your right,
   modify the above code to conform. Do you find these designs useful?

   [TIP]: Read till the end of the article, you might find some useful hints there.

3.2. for

   A loop written with for is more compact and organized, but it does the same thing as a
   while loop: evaluate an expression and execute something if the expression is true. This
   means that there are situations where the instructions may not execute at all, if the
   condition is false from the start. You'll see in a whim why this is important. Using for vs
   while is a matter of situation, habit and personal preference, so there isn't really
   anything one can do and the other can't.

   A for loop has three parts: initialization, loop, increment/decrement. It's important to
   know that any part of the three can be omitted, but the semicolons, as you will see, must
   remain. So, a infinite loop with for would look like this:
for(;;)
{
  do_something();
  do_something_else();
}

   Now, provided you have i already declared as an integer, but not defined, how would you
   write the code that outputs "Hello!" five times using a for loop? It's pretty easy when you
   look at it carefully, so try to avoid Google or other sources of inspiration. The feeling
   you'll have when you will have solved this for yourself is next to nothing.

4. switch/case

   If you want to use an interactive program and you realize that at one point you'll have to
   deal with multiple options, chosen from a list of constants, then switch is what you need.
   This situation is often encountered when writing interactive applications, where you will
   use dialogs like this: "If you want to do that, press that; if you need this, press this"
   and so on. For example, we will show you a program that shows you an integer value that you
   introduce in hex or octal, depending on your choice.
#include <stdio.h>

int main()
{
  char option;
  int number;

  printf("Please enter the number you want converted.\n");
  /*Please refrain from using gets() because of its
 * insecure "features" */
  scanf("%i", &number);

  printf("What kind of conversion do you need?\n");
  printf("Press 'o' for octal and 'x' for hexadecimal.\n");

  while((option = getchar()) != EOF && (option = getchar()) != '\n')
  {
    switch(option)
    {
      case 'o':
        printf("The number in octal is 0%o.\n", number);
        break;
      case 'x':
        printf("The number in hex is 0x%x.\n", number);
        break;
      default:
        printf("Option not valid.\n");
  break;
    }
  }
  return 0;
}

   Switch C Now let's dissect the program and see what and how it does things. One thing newly
   introduced here is the getchar() function, as defined in stdio.h . It's used here to get a
   single character from user input and then write the character to a variable. We could have
   used option = getchar() once, before the while, but we wrote the code like this to
   emphasize how you can use it. We'll leave it up to you to figure out why we check for EOF
   and the newline character, and we encourage you to try and see what happens if you omit
   those checks. The syntax of a switch statement is pretty simple and self-explanatory, so
   we'll be pretty brief.

   We use break; in every case because otherwise the loop would continue to the next tag (tags
   are what is written before the colon). The default: tag is not mandatory, but it's useful
   to do something in case to other tag matches the existing data, and it's also considered
   good programming practice. As another exercise, we recommend you try and rewrite our code
   below using scanf() instead of getchar() and see how it goes. Will it work?

5. do/while

   We said earlier that while and for evaluate first and execute after, so there are chances
   the instructions might never get executed. There will be situations when you will want the
   exact reverse, and this where do/while enters the stage. The logical flow is inverted, as
   compared to while, as in do (something) while (condition_is_true). So the evaluation is
   done after the execution, which guarantees at least one round before the compiler realizes
   that the condition is false (or not).

   Let's see how an infinite loop would look like with do/while:
do
  printf("Hello!\n");
while(1);

   You can simply try to verify how the flow goes by simply replacing 1 with 0 in the above
   code and see what happens: The program will print 'Hello!' once, before realizing that the
   while expression evaluates as false. do/while constructions are usually less used that
   their counterparts, but you will see that there are situations where they make your life
   easier. Can you give an example?

6. break, continue, and goto

   We already "met" break before, and it can be simply described as the method of getting out
   of a loop in other ways than the default. You can use it with loops or switch
   constructions, as opposed to continue, which doesn't really make sense in a switch. We'll
   leave it to you to write some code where break and continue are used and useful, and we
   will continue with one of the C programmer's "enemies": goto. I started programming with
   BASIC, and I still shiver when I remember the use of goto there, and while C has it too,
   its use is not recommended in any case, maybe except for some system-related programs. It's
   not recommended because with goto you can easily turn your work into spaghetti code, that
   is, code that's very hard to read and debug because the reader is forced to "jump" to
   various sections of the code in order to understand it. But for the sake of completeness,
   here's how it works. You declare a label, afterwards you assign some instructions to it and
   then you can use it in different portions of your code. Usually you can get away with a
   custom function instead of this, so use goto ONLY when all else fails.
if(error_unknown)
  goto error;

/*[...]*/
error:
printf("Generic error!.\n");

   Now whenever you have an untreated/unknown error, you can use the error goto label to print
   that very helpful message. Again, avoid goto like the plague. It's easier than you might
   realize to get used to it and create a bad habit of writing spaghetti code. We can't
   emphasize this enough.

7. Conclusion

   Provided you've read this part carefully and tried to solve the challenges we posed, you
   now have made another step in the land of C programming. Try to read and write as much code
   as possible, and don't be afraid to ask if something goes wrong.



---
http://how-to.linuxcareer.com/c-development-on-linux-functions-v

C development on Linux - Functions - V.

1. Introduction

   The C standard library offers a plethora of functions for many usual tasks. Also there are
   lots of libraries for extra functionality, like GUI design (GTK+) or database interfacing
   (libpq). However, as you advance in the C programming world, you will soon find yourself
   repeating the same instructions in the same order over and over again and that will become
   time-consuming and inefficient. So you can just wrap all those instructions in a function
   and just call said function when you need it. Here's what you're gonna learn by reading
   this article, plus some useful tips that will make your life easier. Any suggestions or
   problems go to the [33]forums, as before.

2. Creating your functions

   For a simple start, let's say you wanna write a calculator. We won't focus on the interface
   (GUI vs curses vs slang vs CLI) as we're interested on the internals. It would be clunky to
   not create a function for every operation you decide to support, unless there is one
   already, like pow() , defined in math.h, which returns the result of a base raised to a
   power. So, for example, for addition you will have a function named add() that takes two
   arguments, at least for now, and returns the result. So when the user chooses to add the
   number (s)he introduced, you just call the function with the numbers the user entered and
   you needn't worry about anything else. These three terms that I wrote in italics are
   essential in understanding functions. A function usually (but not always) takes something,
   does a number of operations on that something and spits out the result. "Not always"
   because main(), as you could see before, can be called with no arguments, and there are
   other examples as well. But for now, let's focus on our examples. The numbers that need to
   be added together are the arguments, that "something" you give the function for processing.
   The processing part is in the body of the function, when you tell it to add the numbers
   together. After that, the "spitting out" part is called returning a value, which is, in our
   case, the result of the addition.

   Let's see what we talked about in a practical example:
#include <stdio.h>
/* this contains the definition of printf()*/
double add(double x, double y);

int main()
{
  float first, second;
  printf("Please enter the first number.\n");
  scanf("%F",&first);
  printf("Please enter the second number.\n");
  scanf("%F",&second);

  double add(double a, double b)
  {
    return a + b;
  }

  printf("The result of the addition is %F\n", add(first, second));

  return 0;
}

   The above code, although simplistic at best, helps us point out precisely what we talked
   about before. First we declare the function, before main(), and the purpose is to know the
   name, the type of the arguments and the type the function returns. This line is also called
   defining the function prototype. As you can see, the arguments' names from the declaration
   need not be the same as the ones used in the definition, but if that troubles you, use a
   constant naming scheme, it's alright. Before we use the function we must define it, as in
   tell the world what is it exactly that it does. Even if the function's body is single-line,
   just as it is in our example, it is best you use braces for readability and for good habit.
   Here, everything the function does is return the result of the addition between two
   numbers.

   C function prototype, definition,call

   We suggest you use names for functions, arguments and ordinary variables or constants that
   reflect what they do, again for good habit and for sparing the programmers reading your
   code the attempts to guess what variable "xyzgth" does or is used for. Also, use comments.
   Even if in the above code comments might seem overkill, they're not. When you look at the
   code two months later, you won't have any idea what was in your mind when you wrote the
   code. So use and abuse comments, they'll save you, trust me.

2.1. Exercise

   There are functions that can accept a variable number of arguments, like printf() for
   example. You are allowed to use Google to see what they do and try to rewrite the add()
   function to accept more than two arguments, or create another function. You can also use
   "man 3 printf".
     ______________________________________________________________________________________

   We told you before that main() can be called with no arguments. Of course, that means it
   can be called with arguments as well. When is this useful? In programs simple such as ours,
   since we call them with no arguments, the parentheses of main() are empty. But when your
   programs will grow in complexity, especially if they will be command-line oriented you will
   need to add the functionality of arguments, like gcc's -v flag that prints the version.
   When such functionality is desired, main() must have arguments, two to be precise. The main
   function becomes
int main(int argc, char **argv)
{
  ....
}

   Before you freak out over the cryptic names and the double asterisks, wait till you get the
   explanation, which is actually simple. The first argument is an integer named argc, and the
   name comes from "ARGument Count". A little better, right? About the second argument...well,
   the name stands for "ARGument Vector" officially and it's a pointer to a pointer to a char.
   Now, in English, while argc stores the number of arguments, argv stores the arguments as a
   series of strings. The "pointer to..." part will be explained in the next part of the
   article, for now all you need to know is that if, for example, the user will type three
   arguments to the program, index zero of argv will be the name of the program itself, index
   one will store the first argument to the program and so on. This is how you can use a
   switch/case to check for the arguments passed to your programs. Before we give you a short
   example, we feel compelled to tell you that main has two arguments as defined by the
   standard, and this is how it's used on most Linux and Unix systems. However, if you (will)
   work on Windows or Darwin, main() will have one or two more arguments, but those are
   system-dependent and so are not defined or required by the standard. Also, "char **argv"
   might also be written as "char *argv[]". You will see both, depending on the developer's
   preference.

   You might remember we told you in the first part of our series how we're gonna use Kimball
   Hawkins' yest program for examples. It's time we start, so here's how yest deals with a
   part of the possible user input:
if ( strncmp( argv[i], "--help", 6 ) == 0 ||
             strncmp( argv[i], "-?",     2 ) == 0 ||
             strncmp( argv[i], "?",      1 ) == 0 ||
             strncmp( argv[i], "help",   4 ) == 0 )
            yest_help();        /* help requested, display it */

if ( strncmp( argv[i], "--version", 9 ) == 0 ||
             strncmp( argv[i], "--license", 9 ) == 0 )
            yest_version();     /* version/license information requested */

   You may see in this code how Kimball comments his code, although the name of the functions
   he calls - yest_help() and yest_version() - are pretty self-explanatory. The standard
   strncmp() function, to be found in string.h, compares two strings, in our case argv[i] and
   "help", for example, but only the first x characters (4 in the "help" line) and returns
   zero if the first string matches the second.

   main arguments

2.2. Exercise

   How would you use switch/case to check if the first argument is "--help" and the second is
   "--version"? Can these options be used together? How would the code differ?

3. Things to be aware of

   C does not allow you to define a function inside another, with the exception main(), which
   is, as we can see, special. Be also aware that what you define inside a function "lives"
   inside a function only. So you can have a variable named "a" defined inside three different
   functions with no problems at all, but that may lead to issues in larger programs, so we
   don't recommend it.

3.1. Custom header files

   As your programs will grow bigger and bigger, you'll find the need to split them. You can
   have more than one source files, but you can also write your own headers. So going back to
   our addition program, you can create a header named operations.h which will have the line
   "double add(double x, double y);", so your program will deal only with the definition, the
   part where you say that add() will return a + b. Including your custom header is done just
   as you include system-installed ones with one important exception: remember to use double
   quotes instead of angle brackets, like this: "#include "operations.h"". This header can be
   placed in the directory where the other source files are stored or in another path,
   specified as an argument to gcc so it would know where to look. Header files can contain
   also constants definitions (with #define) or other declarations, as long as you know that
   they will be used in every source file of the program. It's not mandatory, it's just good
   practice. So, how would you write a calculator that deals only with the basic arithmetic
   operations and uses headers?

3.2. Recursive functions

   As we expect you to have some programming background, we're certain that you know what
   recursive functions are and how/when to use them. This is why this subchapter will be
   shorter than it would normally be. In short, one says about a function to be recursive when
   it calls itself. Although the concept might be daunting for new programmers, one simpler,
   real-life way recursion can be explained is this: try sitting between two mirrors facing
   each other. The effect you see is a visual representation of recursion. But we will give
   you a short example, so that you understand better when and how to use it. You probably
   remember from school when you were taught about factorials. A factorial is the product of a
   all integers smaller than it or equal, as long as they're greater than zero. The notation
   for this is an exclamation sign, so 6! = 6*5*4*3*2*1=720. How can we do this in C in the
   most efficient manner? Of course, using recursion.
int factorial(int number)
{
  if(number <= 1)
    return 1;
  else
    return number * factorial(number-1)
}

4. Conclusion

   We recommend you use functions as often as possible, and put their prototypes in header
   files as often, because your code will be more organized and your work will become easier.
   Speaking of headers, we leave it as a final exercise for you to start reading the header
   file defining mathematical operations (math.h) to get an idea how it looks like and what it
   contains. Then use it in order to improve the calculator with some improved functionality
   beyond basics.



---
http://how-to.linuxcareer.com/c-development-on-linux-pointers-and-arrays-vi

C development on Linux - Pointers and Arrays - VI.

1. Introduction

   We have come to a crucial point in our series of articles regarding C development. It's
   also, not coincidentally, that part of C that gives lots of headaches to beginners. This is
   where we come in, and this article's purpose (one of them, anyway), is to debunk the myths
   about pointers and about C as a language hard/impossible to learn and read. Nonetheless, we
   recommend increased attention and a wee bit of patience and you'll see that pointers are
   not as mind-boggling as the legends say.

2. Definitions and warnings

   It seems natural and common sense that we should start with the warnings, and we heartily
   recommend you remember them: while pointers make your life as a C developer easier, they
   also can introduce hard-to-find bugs and incomprehensible code. You will see, if you
   continue reading, what we're talking about and the seriousness of said bugs, but the bottom
   line is, as said before, be extra careful.

   A simple definition of a pointer would be "a variable whose value is the address of another
   variable". You probably know that operating systems deal with addresses when storing
   values, just as you would label things inside a warehouse so you have an easy way of
   finding them when needed. On the other hand, an array can be defined as a collection of
   items identified by indexes. You will see later why pointers and arrays are usually
   presented together, and how to become efficient in C using them. If you have a background
   in other, higher-level languages, you are familiar with the string datatype. In C, arrays
   are the equivalent of string-typed variables, and it is argued that this approach is more
   efficient.

3. Pointers

   You have seen the definition of a pointer, now let's start with some in-depth explanations
   and, of course, examples. A first question you may ask yourself is "why should I use
   pointers?". Although I might get flamed over this comparison, I'll take my chances: do you
   use symlinks in your Linux system? Even if you haven't created some yourself, your system
   uFses them and it makes work more efficient. I've heard some horror stories about senior C
   developers that swear they never used pointers because they're "tricky", but that only
   means the developer is incompetent, nothing more. Plus, there are situations where you'll
   have to use pointers, so they are not to be treated as optional, because they're not. As
   before, I believe in learning by example, so here goes:
int x, y, z;
x = 1;
y = 2;

int *ptoi; /* ptoi is, and stands for, pointer to integer*/
ptoi = &x; /* ptoi points to x */
z = *ptoi; /* z is now 1, x's value, towards which ptoi points */
ptoi = &y; /*ptoi now points to y */

   If you're scratching your head in confusion, don't run away: it only hurts the first time,
   you know. Let's go line by line and see what we did here. We first declared three integers,
   that's x, y and z, and gave x and y values 1 and 2, respectively. This is the simple part.
   The new element comes along with the declaration of the variable ptoi, which is a pointer
   to an integer, so it points towards an integer. This is accomplished by using the asterisk
   before the name of the variable and it's said to be a redirect operator. The line 'ptoi =
   &x;' means "ptoi now points towards x, which must be an integer, as per ptoi's declaration
   above". You can now work with ptoi like you would with x (well, almost). Knowing this, the
   next line is the equivalent of 'z = x;'. Next, we dereference ptoi, meaning we say "stop
   pointing to x and start pointing to y". One important observation is necessary here: the &
   operator can only be use on memory-resident objects, those being variables (except
   register[1]) and array elements.

   [1] register-type variables are one of the elements of C that exist, but the majority of
   the programmers shun them. A variable with this keyword attached suggests to the compiler
   that it will be used often and it should be stored in a processor register for faster
   access. Most modern compilers ignore this hint and decide for themselves anyway, so if
   you're not sure you need register, you don't.

   We said that ptoi must point to an integer. How should we proceed if we wanted a generic
   pointer, so we won't have to worry about data types? Enter the pointer to void. This is all
   we'll tell you, and the first assignment is to find out what uses can the pointer to void
   can have and what are its' limitations.

4. Arrays

   You will see in this sub-chapter why we insisted on presenting pointers and arrays in one
   article, despite the risk of overloading the reader's brain. It's good to know that, when
   working with arrays, you don't have to use pointers, but it's nice to do so, because
   operations will be faster, with the downside of less comprehensible code. An array
   declaration has the result of declaring a number of consecutive elements available through
   indexes, like so:
int a[5];
int x;

a[2] = 2;
x = a[2];

   a is a 5-element array, with the third element being 2 (index numbering starts with zero!),
   and x is defined as also being 2. Many bugs and errors when first dealing with arrays is
   that one forgets the 0-index problem. When we said "consecutive elements" we meant that
   it's guaranteed that the array's elements have consecutive locations in memory, not that if
   a[2] is 2, then a[3] is 3. There is a data structure in C called an enum that does that,
   but we won't deal with it just yet. I found some old program I wrote while learning C, with
   some help from my friend Google, that reverses the characters in a string. Here it is:
#include <stdio.h>
#include <string.h>

int main()
{
  char stringy[30];
  int i;
  char c;
  printf("Type a string .\n");
  fgets(stringy, 30, stdin);
  printf("\n");

  for(i = 0; i < strlen(stringy); i++)
    printf("%c", stringy[i]);
  printf("\n");
  for(i = strlen(stringy); i >= 0; i--)
    printf("%c", stringy[i]);
  printf("\n");

  return 0;
}

   This is one way of doing this without using pointers. It has flaws in many respects, but it
   illustrates the relation between strings and arrays. stringy is a 30-character array that
   will be used to hold user input, i will be the array index and c will be the individual
   character to be worked on. So we ask for a string, we save it to the array using fgets,
   prints the original string by starting from stringy[0] and going on, using a loop
   incrementally, until the string ends. The reverse operation gives the desired result: we
   again get the string's length with strlen() and start a countdown 'til zero then print the
   string character by character. Another important aspect is that any character array in C
   ends with the null character, represented graphically by '\0'.

   How would we do all this using pointers? Don't be tempted to replace the array with a
   pointer to char, that won't work. Instead, use the right tool for the job. For interactive
   programs like the one above, use arrays of characters of fixed length, combined with secure
   functions like fgets(), so you won't be bitten by buffer overflows. For string constants,
   though, you can use
char * myname = "David";

   and then, using the functions provided to you in string.h, manipulate data as you see fit.
   Speaking of which, what function would you choose to add myname to strings that address the
   user? For example, instead of "please enter a number" you should have "David, please enter
   a number".

5. Pointers and arrays

   You can, and are encouraged to, use arrays in conjunction with pointers, although at first
   you might be startled because of the syntax. Generally speaking, you can do anything
   array-related with pointers, with the advantage of speed at your side. You might think that
   with today's hardware, using pointers with arrays just to gain some speed isn't worth it.
   However, as your programs grow in size and complexity, said difference will start being
   more obvious, and if you ever think of porting your application to some embedded platform,
   you will congratulate yourself. Actually, if you understood what was said up to this point,
   you won't have reasons to get startled. Let's say we have an array of integers and we want
   to declare a pointer to one of the array's elements. The code would look like this:
int myarray[10];
int *myptr;
int x;
myptr = &myarray[0];
x = *myptr;

   So, we have an array named myarray, consisting of ten integers, a pointer to an integer,
   that gets the address of the first element of the array, and x, which gets the value of
   said first element via a pointer. Now you can do all sorts of nifty tricks to move around
   through the array, like
*(myptr + 1);

   which will point towards the next element of myarray, namely myarray[1].

   Pointer to array

   One important thing to know, and at the same time one that illustrates perfectly the
   relationship between pointers and arrays, is that the value of an array-type object is the
   address of its' first (zero) element, so if myptr = &myarray[0], then myptr = myarray. As
   somewhat of an exercise, we invite you to study this relationship a bit and code some
   situations where you think it will/could be useful. This is what you will encounter as
   pointer arithmetic.

6. Considerations on strings in C and calls

   Before we have seen that you can do either
char *mystring;
mystring = "This is a string."

   or you can do the same by using
char mystring[] = "This is a string.";

   In the second case, as you might have inferred, mystring is an array big enough as to hold
   the data attributed to it. The difference is that by using arrays you can operate on
   individual characters inside the string, while by using the pointer approach you cannot. It
   is a very important issue to remember that will save you from the compiler having large men
   coming to your house and do terrible things to your grandma. Going a little further,
   another issue you should be aware of is that if you forget about pointers, calls in C are
   made by value. So when a function needs something from a variable, a local copy is made and
   work is done on that. But if the function alters the variable, changes are not reflected,
   because the original stays intact. By using pointers, you can use calling by reference, as
   you will see in our example below. Also, calling by value might become resource-intensive
   if the objects being worked on are big. Technically, there is also a call by pointer, but
   let's keep it simple for now.

   Let's say we want to write a function that takes an integer as an argument and increments
   it with some value. You will probably be tempted to write something like this:
void incr(int a)
{
  a+=20;
}

   Now if you try this, you will see that the integer will not be incremented, because only
   the local copy will be. If you would have written
void incr(int &a)
{
  a+=20;
}

   your integer argument will be incremented with twenty, which is what you want. So if you
   still had some doubts about the usefulness of pointers, here's one simple yet significant
   example.

7. Somewhat advanced topics

   We thought about putting these topics in a special section because they are a little harder
   to understand for beginners, but are useful, must-know parts of C programming. So...

7.1. Pointers to pointers

   Yes, pointers are variables just like any other, so they can have other variables point to
   them. While simple pointers as seen above have one level of "pointing", pointers to
   pointers have two, so such a variable points to another that points to another. You think
   this is maddening? You can have pointers to pointers to pointers to pointers to....ad
   infinitum, but you already crossed the threshold of sanity and usefulness if you got such
   declarations. We recommend using cdecl, which is a small program usually available in most
   Linux distros that "translates"between C and C++ and English and the other way around. So,
   a pointer to a pointer can be declared as
int **ptrtoptr;

   Now, as per how multiple-level pointers are of use, there are situations when you have
   functions, like the comparison above, and you want to get a pointer from them as return
   value. You also might want an array of strings, which is a very useful feature, as you will
   see in a whim.

7.2. Multi-dimensional arrays

   The arrays you have seen so far are unidimensional, but that doesn't mean you are limited
   to that. For example, a bi-dimensional array can be imagined in your mind as being an array
   of arrays. My advice would be to use multi-dimensional arrays if you feel the need, but if
   you're good with a simple, good ole' unidimensional one, use that so your life as a coder
   will be simpler. To declare a bi-dimensional array (we use two dimensions here, but you're
   not limited to that number), you will do
 int bidimarray [4][2];

   which will have the effect of declaring a 4-by-2 integer array. To access the second
   element vertically (think of a crossword puzzle if that helps!) and the first horizontally,
   you can do
bidimarray [2][1];

   Remember that these dimensions are for our eyes only: the compiler allocates memory and
   works with the array about the same way, so if you don't see the utility of this, don't use
   it. Ergo, our array above can be declared as
int bidimarray[8]; /* 4 by 2, as said */

7.3. Command line arguments

   In our [36]previous installment of the series we talked about main and how it can be used
   with or without arguments. When your program needs it and you have arguments, they are char
   argc and char *argv[]. Now that you know what arrays and pointers are, things start to make
   way more sense. However, we thought about getting in a bit of detail here. char *argv[] can
   be written as char **argv as well. As some food for thought, why do you think that is
   possible? Please remember that argv stands for "argument vector" and is an array of
   strings. Always you can rely on the fact that argv[0] is the name of the program itself,
   while argv[1] is the first argument and so on. So a short program to see the its' name and
   the arguments would look like this:
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv)
{
        while(argc--)
                printf("%s\n", *argv++);
        return 0;
}

8. Conclusion

   We chose the parts that looked the most essential for the understanding of pointers and
   arrays, and intentionally left out some subjects like pointers to functions. Nonetheless,
   if you work with the information presented here and solve the exercises, you'll have a
   pretty good start on that part of C that's considered as the primary source of complicated
   and incomprehensible code.

   Here is an excellent reference regarding [37]C++ pointers. Although it's not C, the
   languages are related, so the article will help you better understand pointers.

References

  37. http://linuxconfig.org/c-understanding-pointers



---
http://how-to.linuxcareer.com/c-development-on-linux-structures-vii

C development on Linux - Structures - VII.

1. Introduction

   We will continue in this part of our tutorial with the complex data types in C, and we will
   talk about structures. Many modern programming languages offer them, one shape or another,
   and so does C. As you will see later, structures allow you to manipulate data easier, by
   allowing you to store different variables of (possibly) different types under one single
   "roof".

2. Beginning structures

   Although I wanted to postpone the definition part for this sub-chapter, it seems like I
   couldn't wait and included it in the introduction. Yes, folks, that's what a structure is,
   and you will see in a whim how useful it is when I will show you some examples. One
   interesting parallel is the one referring to a database table: if you have a table called
   users (the unique name), then you will put in that table the exact data which pertains
   directly to the users: age, gender, name, address, and so on. But these are different
   types! No problem, you can do that with a table, just as you can do it with a struct: age
   will be an integer, gender will be a char, name will be a string and so on. Then you will
   be able to access the members of the table easily, by referring to the name of the
   table/member. But this is not a database course, so let's move on. But before that, let's
   take a short look at a logical aspect: you are invited to create structs with members that
   have something in common from a logical point of view, like the example above. Make it
   easier for you and the people that will later look at your code. So, let's see how our
   users database table would translate in a C struct:
struct users {
        int age;
        char gender;
        char *name;
        char *address;
};

   Please do not forget the semicolon at the end. OK, so I boasted that the members of the
   structure are simple to access. Here's how, provided you want to access the age of the
   user:
printf("The age of the user is %d.\n", users.age);


   But for that printf to work, we'll have to define the age first. That can be done like this
struct users {
        int age;
        ...
} usrs;
usrs.age = 25;
...

...

   What we did here is declare an instance of the struct (you can have as many instances as
   you please), named "usrs". You can have usrs1, usrs2, usrs3 and so on, so you can use these
   attributes (like age, gender, address) on all of them. The second way to do this is to
   declare the struct as we did the first time (e.g. without instances) and then declare the
   respective instances later in the code:
...
struct users usrs1, usrs2, usrs3;

   ...and then take care of the age, gender, address and so on as we did above.

   When we talk about structs in conjunction with [32]functions, the most important thing to
   talk about is probably the fact that structs are regarded as a whole, not as a compound
   made of several elements. Here's an example:
void show_age(usrs i)
{
        printf("User's age is %d.\n", i.age);
        printf("User's name is %s.\n", (&i)->name);
}

   What this function does is: it takes a numeric argument and prints out all the users that
   have that specific age. You might have noticed a new operator in the above code (if you
   haven't, look again). The "->" operator does exactly what the dot operator does, allowing
   you to access a member of the structure, with the specification that it's used when
   pointers are involved, just as the dot operator is used in cases when pointers are not
   involved. One more important consideration here. Given the following code:
struct mystruct {
        int myint;
        char *mystring;
} *p;

   what do you think the following expression will do?
++p->myint;

3. Advanced topics

   One of the things you'll see pretty often in relation with structures, but not only, is the
   typedef keyword. As the name implies, it allows you to define custom datatypes, like in the
   examples below:
typedef int Length; /* now Length is a synonym for int */
typedef char * String;

   Regarding structs , typedef basically eliminates the need to use the 's' word. So here's a
   struct declared in this manner:
typedef struct colleagues {
        int age;
        char gender;
        ...
} colls;

   For our next topic, we will take an idea found in K&R and use it to illustrate our point.
   Why? It's well-thought and it shows very well and in a simple way what we're about to
   illustrate. But before we begin, here's a question for you: knowing that C allows nested
   structs, do you think nested structs by means of typedef could be accepted? Why?

   So, here's the next topic: struct arrays. Now that you [33]know what arrays are you can
   easily guess what this is about. However, some questions remain: how to implement the
   concept and, more important, what could be the use? The example we talked about will soon
   shed some light on both matters. LEt's presume you have a program, written in C, and you
   want to count the number of occurrences of all the keywords the standard defines. We need
   two arrays: one to store the keywords and another to store the number of occurrences
   corresponding to each keyword. This implementation can be written as such:
char *keywords[NRKEYWORDS];
int results [NRKEYWORDS];

   Looking at the concept you will soon see that it uses a pairs concept, which is more
   efficiently described by using a structure. So, because of the end result we'll need, we
   will have an array whose each element is a structure. Let's see.
struct keyword {
        char *keywords;
        int results;
} keywrdtbl [NRKEYWORDS];

   Now let's initialize the array with the keywords and the initial number of occurrences
   which will, of course, be 0.
struct keyword {
         char *keywords;
         int results;
 } keywrdtbl [] = {
         "auto", 0,
         "break", 0,
         "case", 0,
         ...
         "while", 0
 };

   Your next and last assignment, since this task is a bit more complex, is to write a
   complete program that takes itself as the text to work on and print the number of
   occurances of every keyword, according to the method above.

   The last subject on structs I will deal with is the matter of pointers to structs. If you
   wrote the program in the last exercise, you might already have quite a good idea how it
   could be re-written so it can use pointers instead on indexes. So if you like writing code,
   you might consider this as an optional exercise. So there's nothing much around here, just
   a few aspects, like (very important), you must introduce some extra code with extra care so
   that when parsing the source code of the file you're scanning for keywords, and of course
   the search function must be modified, you won't create or stumble upon an illegal pointer.
   See the [34]previous part for reference on pointer arithmetic and differences between using
   arrays and using pointers. Another issue to be careful with is the size of the structs.
   Don't be fooled : there can be only one way to get a structure's way right, and that is by
   using sizeof().
#include <stdio.h>

struct test {
        int one;
        int two;
        char *str;
        float flt;
};

int main()
{
        printf("Struct's size is %d.\n", sizeof(struct test));
        return 0;
}

   This should return 24, but that is not guaranteed, and K&R explains this is because of
   various alignment requirements. I recommend using sizeof whenever you are in doubt, and
   presume nothing.

4. Unions

   I should have altered the title and include the word "unions", and maybe even "bitfields".
   But because of the importance and general usage pattern of structures versus unions and
   bitfields, especially now that hardware is becoming a cheaper commodity (not necessarily
   healthy thinking, but anyway), I guess the title will say only "structures". So what is an
   union? A union resembles much a structure, what differs is the way the compiler deals with
   the storage (memory) for it. In short, a union is a complex data type that can store
   different types of data, but one member at a time. So regardless how big the variable
   stored will be, it will have its' place, but others won't be allowed in the union at that
   precise moment. Hence the name "union". The declarations and definitions of unions are the
   same as structures, and it's guaranteed that the union will take as much memory as its'
   biggest member.

5. Bitfields

   If you will want to use C in embedded systems programming and/or low-level stuff is your
   game, then this part will seem appealing. A bitfield (some write it bit field), doesn't
   have a keyword assigned like enum or union, and it requires you to know your machine. It
   allows you to go beyond the tipical word-based limitations other languages confine you to.
   It also allows you to, and this might be a formal definition, "pack" more than one object
   in a single word.

6. Enums

   To start with a short historical fact, enums were introduced in C when C89 was out the
   door, meaning K&R lacked this nifty type. An enum allows the programmer to create a set of
   named values, also known as enumerators, which have as their main characteristic that they
   have an integer value associated with them, either implicitly (0,1,2...) or explicitly by
   the programmer (1,2,4,8,16...) . This makes it easy to avoid magic numbers.
enum Pressure { pres_low, pres_medium, pres_high };
enum Pressure p = pres_high;

   Now, this is easier, if we need pres_low to be 0, medium 1 and so forth, and you won't have
   to use #defines for this. I recommend [35]a bit of reading if you're interested.

7. Conclusion

   Although the information might seem a bit more condensed than before, don't worry. The
   concepts are relatively easy to grasp and a little bit of exercise will work wonders. We're
   waiting for you at our [36]Linux Forums for any further discussion.



---
http://how-to.linuxcareer.com/c-development-on-linux-basic-io-viii

C development on Linux - Basic I/O - VIII.

1. Introduction

   With this part of our C development on Linux article we are getting ready to get out of the
   theoretical zone and enter the real life one. If you followed the series until this point
   and tried to solve all the exercises, you will now have some idea about what C is about, so
   you need to get out in the wild and do some practical stuff, without which theory doesn't
   have much value. Some of the concepts you'll see below are already known, but they are
   extremely important for any C program on any Unix-like OS. Yes, the information is valid
   regardless of the OS, as long as it's some kind of Unix, but if you'll stumble onto
   something Linux-specific, you will know. We will treat concepts like standard input, output
   and error, in-depth printf() and file access, among others.

2. Basic I/O

   Before we go any further, let's take some time and see what this I/O is about. As many of
   you know, the term stands for Input/Output and has a broad meaning, but in our case we are
   interested on how to print messages to the console and how to get input from the user, plus
   more advanced topics in the same vein. The standard C library defines a series of functions
   for this, as you will see, and after reading a bit you'll notice that you will find it
   pretty hard to live without, unless you want to re-write said functions for fun. It better
   be clear from the start that the facilities this material talks about aren't part of the C
   language per se; as I said, the standard C library offers them.

2.1. Standard I/O

   In short, the above subtitle means "get input from the user, print characters on the
   standard output and print errors on standard error". Nowadays, the main input source, at
   least at this level, is the keyboard, and the device the system prints on is the screen,
   but things weren't always like this. Input was made on teletypes (by the way, the device
   name tty comes from that), and the process was slow and clunky. Any Unix-like system still
   has some historical leftovers regarding, but not only, I/O, but for the rest of this
   article we will treat stdin as the keyboard and stdout/stderr as the screen. You know that
   you can redirect to a file, by using the '>' operator offered by your shell, but we aren't
   interested in that for the time being. Before we begin the article finally, a little
   reminder: Mac OS up to version 9 has some unique features regarding our subject that pushed
   me to read some documentation before starting development on it. For example, on all
   Unix(-like) systems the Enter key generates a LF (line feed). On Windows it's CR/LF , and
   on Apple up to Mac OS 9 it's CR. In short, every commercial Unix vendor tried to make their
   OSs "unique" by adding features. Speaking of documentation, your system's manual pages will
   prove invaluable, although maybe arid at times, and also a good book on Unix design will
   look good at your side.

   We've seen printf() in our previous installments and how to print text on the screen. We've
   also seen scanf() as a means to get text from the user. For single characters, you can
   count on getchar() and putchar(). We'll see now some useful functions from headers included
   in the standard library. The first header we will talk about is ctype.h, and it contains
   functions useful for checking the case of a character or changing it. Remember that every
   standard header has a manual page, explaining what functions are available, and said
   functions in turn have man pages, detailing the return types, arguments and so on. Here's
   an example that converts every character in a string to lowercase, using tolower(). How
   would you attain the opposite?
#include <stdio.h>
#include <ctype.h>

int main()
{
  int c; /* the character read*/
  while ((c = getchar()) != EOF)
    putchar (tolower(c));
  return 0;
}

   Another question for you is: in what way should the code be modified so that it prints the
   lower-cased result only after a sentence? That is, provided the sentence is always ended by
   a dot and a space.

2.1.1. printf() in detail

   Since it's a function so widely used, I only felt that it deserves a sub-section of its'
   own. printf() accepts arguments prefixed with the '%' symbol and followed by a letter (or
   more), thus telling it what kind of input it should expect. We've worked before with '%d',
   which stands for decimal, which is appropriate when working with integers. Here's a more
   complete list of printf()'s format specifiers:
     * d, i - integer
     * o - octal, without the prefixing zero
     * x, X - hexadecimal, without the prefixing 0x
     * u - unsigned int
     * c - char
     * s - string, char *
     * f, e, E, g, G, - float - check your system's printf() manual
     * p - pointer, void *, implementation-dependent, standard between Linux distros

   I highly recommend you to take some time to play with these specifiers, and the fact that I
   didn't get into more detail like precision is because you will have to do some reading for
   yourself. While you're at it, pay special attention to the variable argument list part, and
   note that Linux has a command named printf, as part of coreutils, so make sure that you use
   the section 3 manpage (Linux-specific, as other Unices may have the manual sections laid
   out differently).

   scanf() is the opposite of printf, in that it takes input from the user instead of
   outputting to the user. The format specifiers are almost the same, with certain exceptions
   regarding floats and the fact that it doesn't have a %p. Why do you think that is? It also
   supports variable arguments lists, just like printf().

3. File access

   This is another essential part of I/O and since C is relatively low-level, it allows you to
   read and write files to disk in a simple manner. The header that offers this simple
   functionality is stdio.h, and the function you will be using is fopen(). It takes the
   filename as the argument, as well as the mode it should be read (read/write (r,w). append
   (a) or binary(b), as opposed to text - but the latter's implementation is
   system-dependent). fopen() returns a FILE pointer, which is a type. Before anything you
   will need a file pointer, as illustrated:
FILE *fp; /*file pointer */
fp = fopen("/home/user/testfile.txt", "w");
fprintf(fp, "My test file.")

   Simple: I opened a file on my disk and wrote to it the string "My test file". You might
   have guessed, I have some exercises. Would it make a difference if the file exists or not?
   What if it existed, but was empty? Should I have used append instead of write mode? Why?

   After using the file, one must close it. This is important, because by closing your program
   tells the operating system "Hey, I'm done with this file. Close all dirty buffers and write
   my file to disk in a civilized manner, so no data loss occurs".
fclose(fp);

   Here's a real life example of using file I/O from Kimball Hawkins' yest program, which
   helps us remember two things: one, that because of the Unix design (everything is a file),
   stdin, stdout and stderr are files, so they can be used with file I/O functions, and two,
   that the next part treats stderr and exit.
void store_time()
{
    if ( time_ok == FALSE ) return;     /* No time information, skip it */

    /* Hour */
    if ( tfield[0] > 24 ) {
        fprintf(stderr, "ERROR: Bad input hour: '%d'\n", tfield[0]);
        exit(1);
    }
    theTime->tm_hour = tfield[0];

    /* Minute */
    if ( tfield[1] > 0 ) {
        if ( tfield[1] > 60 ) {
            fprintf(stderr, "ERROR: Bad input minute: '%d'\n", tfield[1]);
            exit(1);
        }
        theTime->tm_min = tfield[1];
    }
}

4. Treating errors with stderr and exit

   Your program must have some way to deal with errors and let the OS and the user know
   something went wrong. While this part is in no way a dissertation on how to treat your
   possible situations in C, it deals with a very useful and well-thought element of Unix:
   output errors to another place, different than stdin, so that the user can separate the two
   when debugging the issue. Also, use exit codes so that the user knows when the program
   finished successfully and when it didn't. This is why stderr exists, for the first part,
   and this is why exit() also exists, for the second part. The astute reader already got the
   idea from the code sample above, so all it takes is tell the system not to output text on
   the default/standard output, but to the special "channel" that exists especially for this.
   Regarding exit(), it works like this: zero for success, any other value between 1 and 255
   in case of failure. It's included in stdlib.h and does not return a value. It is up to you,
   as you can see in Kimball's code above, to tell exit if there is a problem, so it can
   inform the parent function about the exit status.

5. Useful headers

   Needless to say, knowing the standard C library is mandatory if you want to get serious
   with C development on Linux. So here are a few other headers that offer facilities related
   to I/O and more:

5.1. string.h

   This header will prove very helpful when working with string conversions (strto*()),
   comparing strings (strcmp()) or checking a string's length (strlen()).

5.2. ctype.h

   Besides case conversion, ctype.h offers functions that check various properties of
   characters. Some of them are isalnum(), isupper(), isalpha() or isspace(), and you are
   invited to guess what they do and how they work.

5.3. math.h

   Many functions needed for more than the four basic arithmetic operations are to be found
   here, including sin(), cos() or exp().

6. Further reading

   The more experienced readers will nail me to the cross for not treating more advanced
   subjects like malloc() or size_t. As I repeatedly said, this series in not intended as a
   know-all online book for C development (there is no such thing, anyway), but rather a good
   starting point for beginners. I feel that the future C developer must be relatively well
   versed in pointers and how memory allocation works before he/she starts having malloc()
   nightmares. After the end of this series, you are recommended to get a in-depth book on C,
   after asking some opinions from the Old Ones (not H.P. Lovecraft's Old Ones, I hope), so
   you avoid false or misleading information. While you'll know about free() and malloc()
   until we finish, it's probably best to get a printed book and sleep with it under your
   pillow.

7. Conclusion

   The article that will follow this one shall be a little longer, as we will delve further
   into the Unix way of C programming, but a good understanding of what was said here is
   recommended for the next steps to be as smooth as possible.



---
http://how-to.linuxcareer.com/c-development-on-linux-coding-style-and-recommendations-ix

C development on Linux - Coding style and recommendations - IX.

2. Introduction

   You may wonder what is meant by the title. Code is code, right? It's important to be
   bug-free and that's that, what else? Development is more than writing code and
   testing/debugging it. Imagine you have to read someone else's work, and I suppose you
   already done that, and all the variables are named foo, bar, baz, var, etc. And the code
   isn't commented nor documented. You will probably feel the sudden urge to invoke unknown
   gods, then go to the local pub and drown your sorrows. They say that you should not do unto
   others what you don't want done unto you, so this part will focus of general coding
   guidelines, plus GNU-specific ideas that will help you have your code accepted. You are
   supposed to have read and understood the previous parts of this series, as well as solve
   all the exercises and, preferably, read and wrote as much code as possible.

3. Recommendations

   Before starting, please take note of the actual meaning of the word above. I don't, in any
   way, want to tell you how to write your code, nor am I inventing these recommendations.
   These are the result of years of work by experienced programmers, and many will not just
   apply to C, but to other languages, interpreted or compiled.

   I guess the first rule I want to stress out is: comment your code, then check if you
   commented enough, then comment some more. This is not beneficial for others that will
   read/use your code, but also for you. Be convinced that you will not remember what exactly
   you meant to write after two or three months, nor will you know what int ghrqa34; was
   supposed to mean, if anything. Good developers comment (almost) every line of their code as
   thoroughly as possible, and the payoff is more than you might realize at first, despite the
   increased time it takes to write the program. Another advantage is that by commenting,
   because this is how our brain works, whatever we wished to do will be better remembered, so
   again you won't look at your code, fast-forward a few months, wondering who wrote your
   code. Or why.

   The C parser doesn't really care how ordered your code is. That means you can write a
   typical "Hello, world" program like this, and it would still compile:
#include <stdio.h> int main(){printf("Hello, world!"); return 0;}

   It seems much more readable the way we wrote it the first time, doesn't it? The general
   rules regarding formatting are: one instruction per line , choose your tab width and be
   consistent with it, but make sure that it complies with the project's guidelines, if you're
   working on one, also make liberal use of blank lines, for delimiting various parts of the
   program, together with comments, and finally, although this is not necessarily coding
   style-related, before you start coding seriously, find an editor you like and learn to use
   it well. We will soon publish an article on editors, but until then Google will help you
   with some alternatives. If you hear people on forums, mailing lists, etc. saying "editor x
   sucks, editor y FTW!", ignore them. This is a very subjective matter and what's good for me
   might not be so good for you, so at least try some of the editors available for Linux for a
   few days each before even starting to try creating some opinion.

   Be consistent in variable naming. Also make sure the names fit with the others, so there is
   harmony within the entire program. This applies even if you're the only author of the
   software, it will be easier to maintain later. Create a list of used prefixes and suffixes
   (e.g. max, min, get, set, is, cnt) and go with them, unless asked otherwise. Consistency is
   the key word here.

3.1. GNU-specific guidelines

   What follows is a summary of the [31]GNU coding standards , because we know you don't like
   to read such things. So if you're writing code that would like to fit into the GNU
   ecosystem, this is the document to read. Even if you don't, it's still a good read on how
   to write proper code.

   This document is always worth a read in it's entirety if you are creating or maintaining
   GNU software, but you will find the most important parts below. One first issue worth
   mentioning is how to deal with function prototypes. Please go back to the part dealing with
   that if you have any issues. The idea is "if you have your own functions, use a prototype
   declaration before main(), then define the function when needed." Here's an example:
#include <stdio.h>

int func (int, int)

int main()

[...]

int func (int x, int z)

[...]

   Use proper and constant indentation. This cannot be emphasized enough. Experienced
   programmers with years and years of code behind will take it very badly when you submit
   code with improper indentation. In our case, the best way to get used to how GNU does this
   is by using GNU Emacs (although this is not in any form our way to tell you that "GNU Emacs
   is good for you, use it.", as we're proponents of free will and choice), where the default
   behaviour for C code is indentation set at two spaces and braces on a line for themselves.
   Which brings us to another important issue. Some people use braces like this:
while (var == 1) {
  code...
}

   ...while others, including GNU people, do it like this:
while (var == 1)
{
  code...
}

   Of course, this also applies to conditional expressions, functions and every occasion where
   you need to use braces in C code. As far as noticed, this choice is something very
   GNU-specific, and how much of this you respect depends solely on your taste and stance on
   the issue.

   Our next issue is a technical one, and a promise I had to keep: the malloc() issue. Besides
   writing pertinent and meaningful error messages, unlike the ones we've all seen in other
   operating systems, check that malloc() and friends always return zero. These are very
   serious issues, and you'll get a few words lesson about malloc() and when to use it. By now
   you know what allocating memory automatically or statically is. But these methods don't
   cover all bases. When you need to allocate memory and have more control over the operation,
   there's malloc() and friends, for dynamic allocation. Its' purpose is to allocate available
   memory from the heap, then the program uses the memory via a pointer that malloc() returns,
   then said memory must be free()d. And "must" is to be written with capitals in 2 feet
   letters with a burning red color. That's about it with malloc(), and the reasons have
   already been exposed earlier in the [32]previous part.

   You are urged to use a consistent interface in all your command-line programs. If you're
   already a seasoned GNU/Linux user you have noticed that almost all programs have --version
   and --help, plus, for example, -v for verbose, if such is the case. We'll not get into all
   of it here; grab a copy of the GNU Coding Standards, you will need it anyway.

   Although I personally tend to overlook this, and to many it's a minor issue, it will
   improve the readability of your code, because, again, that's how our brain works. The idea
   is: when you're in doubt about using spaces, use them. For example:
int func (var1, var2);

int func(var1,var2);

   There are some that say you can't avoid nested ifs. There are others that say "why avoid
   nested ifs?" And there are yet others that simply do not use nested ifs. You will create
   your own opinion on this as time passes and lines of code you write increase. The idea is,
   if you use them, make them as readable as humanly possible, as they easily can lead to
   almost-spaghetti code, hard to read and to maintain. And again, use comments.

   The GNU coding standard say that it's good to have your code be as portable as can be, "but
   not paramount". Portable hardware-wise? That depends on the program's purpose and what
   machines you have at your disposal. We are referring more to the software side, namely
   portability between Unix systems, open source or not. Avoid ifdefs if you can, avoid
   assumptions regarding file locations (e.g. Solaris installs third-party software under
   /opt, while BSD and GNU/Linux do not), and generally aim for clean code. Speaking of
   assumptions, do not even assume that a byte is eight bits or that a CPU's address space
   [33]must be an even number.

   Documenting your code, in form of [34]manual pages and well-written READMEs and so on, is
   another paramount aspect of software development. Yes, it IS a tedious task, but if you
   don't have a documentation writer on your team, it's your responsibility to do it, as every
   good programmer does his/her job from A to Z.

4. Conclusion

   Next time we'll continue from where we left off here: going from idea to a complete
   program, with Makefiles, documentation, release cycles and all the fun stuff. The only
   exercise I have for you is to skim through the GNU coding standards and modify your code as
   to conform. And get ready, next time it's fun time!



---
http://how-to.linuxcareer.com/c-development-on-linux-building-a-program-x

C development on Linux - Building a program - X.

1. Introduction

   After all that theory and talking, let's start by building the code written through the
   last nine parts of this series. This part of our series might actually serve you even if
   you learned C someplace else, or if you think your practical side of C development needs a
   little strength. We will see how to install necessary software, what said software does
   and, most important, how to transform your code into zeros and ones. Before we begin, you
   might want to take a look at our most recent articles about how to customize your
   development environment:
     * [32]Introduction to VIM editor
     * [33]Introduction to Emacs
     * [34]Customizing VIM for development
     * [35]Customizing Emacs for development

2. Building your program

   Remember the first part of our [36]C Development series? There we outlined the basic
   process that takes place when you compile your program. But unless you work in compiler
   development or some other really low level stuff, you won't be interested how many JMP
   instructions the generated assembler file has, if any. You will only want to know how to be
   as efficient as possible. This is what this part of the article is all about, but we are
   only scratching the surface, because of the extensiveness of the subject. But an
   entry-level C programmer will know after reading this everything needed to work
   efficiently.

2.1. The tools

   Besides knowing exactly what you want to achieve, you need to be familiar with the tools to
   achieve what you want. And there is a lot more to Linux development tools than gcc,
   although it alone would be enough to compile programs, but it would be a tedious task as
   the size of your project increases. This is why other instruments have been created, and
   we'll see here what they are and how to get them. I already more than suggested you read
   the gcc manual, so I will only presume that you did.

2.1.1. make

   Imagine you have a multi-file project, with lots of source files, the works. Now imagine
   that you have to modify one file (something minor) and add some code to another source
   file. It would be painful to rebuild all the project because of that. Here's why make was
   created: based on file timestamps, it detects which files need to be rebuilt in order to
   get to the desired results (executables, object files...), named targets. If the concept
   still looks murky, don't worry: after explaining a makefile and the general concepts, it
   will all seem easier, although advanced make concepts can be headache-inducing.

    make has this exact name on all platforms I worked on, that being quite a lot of Linux
   distros, *BSD and Solaris. So regardless of what package manager you're using (if any), be
   it apt*, yum, zypper, pacman or emerge, just use the respective install command and make as
   an argument and that's it. Another approach would be, on distros with package managers that
   have group support, to install the whole C/C++ development group/pattern. Speaking of
   languages, I wanted to debunk a myth here, that says makefiles (the set of rules that make
   has to follow to reach the target) is only used by C/C++ developers. Wrong. Any language
   with a compiler/interpreter able to be invoked from the shell can use make's facilities. In
   fact, any project that needs dependency-based updating can use make. So an updated
   definition of a makefile would be a file that describes the relationships and dependencies
   between the files of a project, with the purpose of defining what should be
   updated/recompiled in case one or more files in the dependency chain changes. Understanding
   how make works is essential for any C developer who works under Linux or Unix - yes,
   commercial Unix offers make as well, although probably some version that differs from GNU
   make, which is our subject. "Different version" means more than numbers, it means a BSD
   makefile is incompatible with a GNU makefile. So make sure you have GNU make installed if
   you're not on a Linux box.

   In the first part of this article, and some subsequent ones, we used and talked about parts
   of [37]yest, a small program that displays yesterday's date by default, but does a lot of
   nifty date/time-related things. After working with the author, Kimball Hawkins, a small
   makefile was born, which is what we'll be working with.

   First, let's see some basics about the makefile. The canonical name should be GNUmakefile,
   but if no such file exists it looks for names like makefile and Makefile, in that order, or
   so the manual page says. By the way, of course you should read it, and read it again, then
   read it some more. It's not as big as gcc's and you can learn a lot of useful tricks that
   will be useful later. The most used name in practice, though, is Makefile, and I have never
   seen any source with a file named GNUmakefile, truth be told. If, for various reasons, you
   need to specify another name, use make's -f, like this:
 $ make -f mymakefile

   Here's yest's Makefile, that you can use to compile and install said program, because it's
   not uploaded of Sourceforge yet. Although it's only two-file program - the source and the
   manpage - you will see make becomes useful already.
# Makefile for compiling and installing yest

UNAME := $(shell uname -s)
CC = gcc
CFLAGS = -Wall
CP = cp
RM = rm
RMFLAGS = -f
GZIP = gzip
VERSION = yest-2.7.0.5

yest:
ifeq ($(UNAME), SunOS)
        $(CC) -DSUNOS $(CFLAGS) -o yest $(VERSION).c
else
        $(CC) $(CFLAGS) -o yest $(VERSION).c
endif

all: yest install maninstall

install: maninstall
        $(CP) yest /usr/local/bin

maninstall:
        $(CP) $(VERSION).man1 yest.1
        $(GZIP) yest.1
        $(CP) yest.1.gz /usr/share/man/man1/

clean:
        $(RM) $(RMFLAGS) yest yest.1.gz

deinstall:
        $(RM) $(RMFLAGS) /usr/local/bin/yest /usr/share/man/man1/yest1.gz

   If you look carefully at the code above, you will already observe and learn a number of
   things. Comments begin with hashes, and since makefiles can become quite cryptic, you
   better comment your makefiles. Second, you can declare your own variables, and then you can
   make good use of them. Next comes the essential part: targets. Those words that are
   followed by a colon are called targets, and one use them like make [-f makefile name]
   target_name. If you ever [38]installed from source, you probably typed 'make install'.
   Well, 'install' is one of the targets in the makefile, and other commonly-used targets
   include 'clean', 'deinstall' or 'all'. Another most important thing is that the first
   target is always executed by default if no target is specified. In our case, if I typed
   'make', that would have been the equivalent of 'make yest', as you can see, which means
   conditional compilation (if we are on Solaris/SunOS we need an extra gcc flag) and creation
   of an executable named 'yest'. Targets like 'all' in our example are doing nothing by
   themselves, just tell make that they depend on other files/targets to be up to date. Watch
   the syntax, namely stuff like spaces and tabs, as make is pretty pretentious about things
   like this.

   Here's a short makefile for a project that has two source files. The filenames are src1.c
   and src2.c and the executable's name needs to be exec. Simple, right?
exec: src1.o src2.o
      gcc -o exec src1.o src2.o

src1.o: src1.c
        gcc -c src1.c

src2.o: src2.c
        gcc -c src2.c

   The only target practically used, which is also the default, is 'exec'. It depends on
   src1.o and src2.o, which, in turn, depend on the respective .c files. So if you modify,
   say, src2.c, all you have to do is run make again, which will notice that src2.c is newer
   than the rest and proceed accordingly. There is much more to make than covered here, but
   there is no more space. As always, some self-study is encouraged, but if you only need
   basic functionality, the above will serve you well.

2.1.2. The configure script

   Usually it's not just 'make && make install', because before those two there exists a step
   that generates the makefile, especially useful when dealing with bigger projects.
   Basically, said script checks that you have the components needed for compilation
   installed, but also takes various arguments that help you change the destination of the
   installed files, and various other options (e.g. Qt4 or GTK3 support, PDF or CBR file
   support, and so on). Let's see in a short glance what those configure scripts are all
   about.

   You don't usually write the configure script by hand. You use autoconf and automake for
   this. As the names imply, what they do is generate configure scripts and Makefiles,
   respectively. For example, in our previous example with the yest program, we actually could
   use a configure script that detects the OS environment and changes some make variables, and
   after all that generates a makefile. We've seen that the yest makefile checks if we're
   running on SunOS, and if we are, adds a compiler flag. I would expand that to check if
   we're working on a BSD system and if so, invoke gmake (GNU make) instead of the native make
   which is, as we said, incompatible with GNU makefiles. Both these things are done by using
   autoconf: we write a small configure.in file in which we tell autoconf what we need to
   check, and usually you will want to check for more than OS platform. Maybe the user has no
   compiler installed, no make, no development libraries that are compile-time important and
   so on. For example, a line that would check the existence of time.h in the system standard
   header locations would look like so:
 AC_CHECK_HEADERS(time.h)

   We recommend you start with a not-too-big application, check the source tarball contents
   and read the configure.in and/or configure.ac files. For tarballs that have them,
   Makefile.am is also a good way to see how an automake file looks. There are a few good
   books on the matter, and one of them is Robert Mecklenburg's "Managing Projects with GNU
   Make".

2.1.3. gcc tips and usual command-line flags

   I know the gcc manual is big and I know many of you haven't even read it. I take pride in
   reading it all (all that pertains to IA hardware anyway) and i must confess I got a
   headache afterwards. Then again, there are some options you should know, even though you
   will learn more as you go.

   You have already encountered the -o flag, that tells gcc what the resulting outfile, and
   -c, that tells gcc not to run the linker, thus producing what the assembler spits out,
   namely object files. Speaking of which, there are options that control the stages at which
   gcc should stop execution. So to stop before the assembly stage, after the compilation per
   se, use -S. In the same vein, -E is to be used if you want to stop gcc right after
   preprocessing.

   It's a good practice to follow a standard, if not for uniformity, but for good programming
   habits. If you're in the formative period as a C developer, choose a standard (see below)
   and follow it. The C language was standardized first after Kernighan and Ritchie (RIP)
   published "The C Programming Language" in 1978. It was a non-formal standard, but in was
   shortly dubbed K&R and respected. But now it's obsolete and not recommended. Later, in the
   '80s and the '90s, ANSI and ISO developed an official standard, C89, followed by C99 and
   C11. gcc also supports other standards, like gnuxx, where xx can be 89 or 99, as examples.
   Check the manual for details, and the option is '-std=', "enforced" by '-pedantic'.

   Warnings-related options start with "-W", like '-Wall' (it tells gcc to enable all errors,
   although they're not quite all enabled) or '-Werror' (treat warnings as errors, always
   recommended). You can pass supplemental arguments to the programs that help with the
   intermediary steps, such as preprocessor, assembler or linker. For example, here's how to
   pass an option to the linker:
 $ gcc [other options...] -Wl,option [yet another set of options...]

   Similarly and intuitively, you can use 'Wa,' for the assembler and 'Wp,' for the
   preprocessor. Take note of the comma and the white space that tells the compiler that the
   preprocessor/assembler/linker part has ended. Other useful families of options include '-g'
   and friends for debugging, '-O' and friends for optimization or '-Idirectory' - no white
   space - to add a header-containing location.

3. Conclusion

   I recommend you take your time to read this article, play with the examples, then write
   your own, increasing the complexity as you go.



---
http://how-to.linuxcareer.com/c-development-on-linux-packaging-for-debian-and-fedora-xi

C development on Linux - Packaging for Debian and Fedora - XI.

1. Introduction

   You're already in the know regarding the C programming language. You got the taste of it
   and felt like you want to go further and write your own. Or maybe help the community and
   package that favorite software of yours for the distribution you like and use. Regardless
   of the situation, this part of the C development series will show you how to create
   packages for two of the most popular distributions, Debian and Fedora. If you read our
   articles so far and you have some solid knowledge of the command line, and you can say that
   you know your distro of choice, you're ready.

2. Before we go further...

   Let's get some concepts and general ideas out of the way, just so we make sure we are on
   the same page. What we are about to outline here is available regardless of the project you
   decide to package (or contribute) for, be it Arch, NetBSD or OpenSolaris. The idea is: be
   careful. Check the code, whether it's yours or not, and make sure you remember that perhaps
   lots of people will use your code. You have a responsibility on your hands, and a pretty
   big one at that. If you doubt this, reverse places for a second: a package maintainer isn't
   careful when inspecting code and some sneaky, but grave bug makes his way installed on your
   computer. It's sneaky, as it only manifests itself on certain hardware and in certain
   situations, but it's grave enough to delete all the files resident inside your home folder.
   You happen to have that exact combination of hardware and mayhem ensues, as you forgot to
   write to DVD those pictures from your holiday. You get angry, your first reaction is to
   manifest negative feeling towards the operating system (or distribution) and so, following
   your decision to change distributions immediatley, that distro loses one user, all because
   one person's lack of attention and thoroughness.

3. Debian

    Given Debian's excellent documentation, we won't be able to cover all the things one needs
   to become a developer. After all, this is not what we wanted. What we wanted is to show you
   basically how to get from a tarball to a .deb. Becoming a Debian developer takes lots of
   time and involves you helping out the community via IRC or mailing lists, reporting and
   helping fixing bugs, and so on, so that is not the object of our article. Have [30]a look
   at the documentation the project provides for more insight. The Debian policy, New
   maintainer's guide and the Developer's reference are more than important for starting up,
   they must be like some kind of a book you sleep under the pillow with.

   Your first stop should be, as outlined above, the policy, where you MUST acquaint yourself
   with the filesystem hierarchy, the archives, the fields in a control file and specific
   items to be remembered regarding diferent categories of software: binaries, libraries,
   source, games, documentation, ... Remember that a .deb file is nothing more than an
   archive, and it's made of two parts: the control part, with the control file and the
   install/ uninstall scripts, and the payload, where the files to be installed reside. It's
   not as hard as one would think it is. It's a very good idea that you download a .deb file,
   even better if it's packing some software you are familiar with, and start looking inside
   to see what's what. [HINT] - You can use the control file to create your own, as long as
   you're careful. As an example, let's take [31]vim. deb files are nothing but ar(1)
   archives, so they can simply be unpacked by using the following command:
 $ ar vx vim-nox_7.3.547-5_amd64.deb

   Of course, v stands for verbose, and x stands for extract. After this operation, we will
   see three files: control.tar.gz, data.tar.xz and a small text file called debian-binary,
   which is nothing more but a file telling dpkg, the Debian package manager, what binary
   format is used. But that is of no interest for the time being. Nor is the data archive,
   which consists of the files that are to be unpacked on your system: the binary, manual
   pages, libraries, and so on, depending on the software we are talking about. The control
   archive is of utmost importance here. If you unpack it, you will see the essential file,
   named control, the md5sums of the files to be installed, and two scripts, one that takes
   care of the post installation issues, and the other that takes care of pre-removal. Since
   we had yest as a software example, let's take it and see how the control file would look.
   It is up to you to decide, dear reader, if yest needs those two scripts and if so, how
   should they be altered. So here's a control file, taken from vim-nox and modified for yest.
Package: yest
Source: yest
Version: 2.7.0.5
Architecture: amd64
Maintainer: Rares Aioanei
Installed-Size: 40355
Depends: libc6 (>= 2.11)
Suggests:
Provides: yest
Section: other
Priority: normal
Homepage: sourceforge.net/projects/yest
Description: This is a command line date/time manipulation and formatting program, very useful in sc
ripts. You can easily add or subtract days, hours and/or minutes
 from a specified date. Supports all date(1) output formats plus more.

   There you go, folks. Do you think there is anything else you need to create a package?
   Check if all your files are in place, then you can use a more old-school method, especially
   since the software is small and simple and un-quirksome, if such words exist.
 $ dpkg -b yestdir yest.deb

   Now, a lot of folks will tell me, and I can't wait, of course, that this is an old method
   of doing stuff and so on. And they're right. I suggest looking through the
   dpkg-buildpackage manual page, as well as lintian for checking the quality of your .deb,
   and remember to do this before you start anything, so you can make sure you have it all
   installed:
 # apt-get install build-essential autoconf automake autotools-dev dh-make debhelper devscripts fake
root xutils lintian pbuilder

4. Fedora

   In my opinion, Fedora/Red Hat makes it easier for people to package for them compared to
   Debian and derivatives. That being said, easier doesn't always mean better, at least in the
   IT world. You will be able to make an educated opinion after this article, we hope.

   Again, make sure you have all the tools installed, which can be done by typing this:
 # yum install @development-tools fedora-packager

   Now create a user named makerpm, make sure that he is in the mock group and assign a
   password:
 # useradd -m -G mock makerpm && passwd makerpm

   Log in as that user and issue the command
 $ rpmdev-setuptree

   in the home directory. You will see, after the command exits, a new directory structure
   named rpmbuild. Take some time to examine it and figure out the purposes of each directory
   and file. Now, just as Debian makes use of control files, Fedora uses specfiles. They are
   called like so because they have the .spec extension, so the user knows it specifies the
   parameters of package building: version, name, author, maintainer, depends, and so on.
   Anyways, I am getting ahead of myself. Let's start just like we did before and download a
   source package (again vim, for consistency) to see where's where. For that one needs to
   install the yum-utils package, which offers yumdownloader:
 $ yumdownloader --source vim-enhanced

   Now, to install into ~/rpmbuild, we type
 $ rpm -ivh vim-enhanced[...].src.rpm

   Remember that an RPM file is an archive, just as .deb files are. The difference is the
   format: while Debian uses ar, Fedora/RH uses cpio as the format of choice. Knowing this,
   what would be the method to use for manually unpacking .rpms?

   You may have noticed there is a directory named SPECS in your ~/rpmbuild. cd to it and
   create a file using vim or emacs, a file named yest.spec. You will be pleasantly surprised
   to find that those two editors are modified by Fedora in such a way so that they offer you
   a "skeleton" of a specfile (as long as the file you want to create has the .spec
   extension), so you can just fill in the blanks. Now, your assignment is, based on the
   control file above and your knowledge so far, to write a complete specfile for yest and, of
   course, create a RPM out of it. The Fedora wiki has a [32]detailed explanation on every
   section of a specfile, please read it. We will only help you with the actual building and
   checking of the package. In short, use yest.spec as an argument to rpmlint to check the
   file's compliance with the Fedora Packaging Guidelines and then, when everything proves to
   be in order, and after you read the rpmbuild manual, do something like this:
 $ rpmbuild -ba yest.spec

   The options given to rpmbuild stand for "build all", but you can also build just the source
   package, using -bs. Remember that Mock and Koji are two very helpful tools, and also
   remember that rpmlint is your ticket towards quality specfiles.

5. Conclusion

   One thing to remember is that whether you created the software you're packaging or not,
   maintainership is very important, sometimes even more important as the act of creation
   itself. So make sure you know what responsibility you are taking upon yourself: if you're
   not prepared to donate time, it's better that you don't start at all, or make sure you can
   give the package to someone else to maintain. We hope you enjoyed our little tour of Linux
   packaging.



---
http://how-to.linuxcareer.com/c-development-on-linux-getting-a-package-in-the-official-debian-repositories-xii

C development on Linux - Getting a package in the official Debian repositories - XII.

1. Introduction

   This is the last installment of our C development series, and arguably the most
   non-technical one. If you followed us from the beginning and practiced as much as possible,
   you now have some basic knowledge on C development and how to package your (favorite)
   application for two of the most used Linux distribution families, Debian and Redhat. This
   article is about the community, how to contribute, how to collaborate and finally, how to
   get your package in the official Debian archives. If you read the previous articles in the
   series you won't need any other technical knowledge; all you need is the will to put your
   knowledge to work for community's benefit.

2. Getting started

   You have an application, you packaged it and now you're anxious to upload it to the Debian
   archives (by the way, many of the ideas presented here apply to many Open Source projects:
   what differs usually is the way of doing things). We'd say not so fast. Take a minute to
   breathe and find ways to make yourself known to the community. Take some time to read the
   Debian New Maintainer's Guide, if you haven't already, and remember the key word here:
   community. Everyone is a volunteer, and we chose Debian especially because of its
   democratic views, and nobody is paid or forced in any way to do your bidding. Anyway, since
   we know how much you like to read guides and manuals, part of this article will consist of
   some sane advice regarding collaboration. First, get used to get by on your own. Nobody
   likes a person that, when he or she hits the first sign of trouble, instead of going to the
   best Internet friend, $SEARCH_ENGINE, start polluting the forums, mailing lists and IRC
   channels with puerile questions like "What gcc flags do I need to compile my code for
   i686?". The only thing you will gain is a less than friendly RTFM and lots of missing geek
   points. Yes, we know that the gcc manual is big and a sure shot for headaches, but reading
   the manual, then searching the net first is the Right Way (TM). No exceptions. You will
   make a first good impression when you show the other developers that you made your
   homework. On the other hand, giving beginners a hard time, especially when such behavior is
   not called for, will not get you any popularity. Remember that you were once like them,
   remember that you, as we all, still have a lot to learn, and perhaps point the person
   towards a resource you think is helpful. In this context, remember that word again:
   community. Your work doesn't mean much, despite the fact that it means the world to you,
   unless the community finds it useful. Collaborate with them and be ready to accept
   feedback, and be thankful for it, even though you might not like what you hear. Leave your
   pride at the door and remember that the best and maybe only way to make your software
   better is community feedback. But don't fall into extremes, and try to be impartial.
   Perhaps some people will try to put you down just for the fun of it: ignore them and
   concentrate on constructive criticism.

3. Tools of the trade

   The first tool you will ever need as a Debian developer, or any other distro/project for
   that matter, is patience. It doesn't really matter if it's your own software you're
   packaging, or someone else's, as we did with yest. One doesn't become a developer over
   night, especially in a quality-oriented project as Debian. Now, to get into the practical
   side of things, the first and most obvious tool you need is the compiler for the language
   your program is written in. Or, if the program is written in some interpreted language,
   make sure the interpreter (Perl, Python, Ruby...) is there as a dependency. We, however,
   will concentrate on the C side, as this is after all a C development article series, and
   will give you a non-exhaustive list of utilities you better have installed on your
   development machine:
auto* tools (autoconf, automake, ...)
debhelper and dh-make -- Debian-specific
devscripts, fakeroot -- same, see the Guide for details
a VCS of your choice, depending on the situation at hand -- we prefer to take no sides here
gnupg -- for digitally signing your packages, mandatory in Debian
lintian -- the name is a combination of lint and Debian, so it's self-explanatory
patch - you should know by know why you'd need it
pbuilder -- for creating a chroot

   If you were careful, you would have noticed that we omitted an important utility in that
   list. Can you spot it?

3.1. Documentation

   Debian recommends two documents. In fact, no. Debian recommends the two documents, but we
   say it's essential you read them more than once and keep them handy at all times. Those are
   the Debian Policy and the Developers Reference, both available via Web and as packages.
   Also the GNU Coding Standards should be at hand when you need it, especially when/if you're
   writing the application yourself.

4. Upstream

   Since we're focusing on yest as the primary example for this series, it's easy to figure
   out that we're just packagers, not primary developers, so we need to keep contact with
   upstream. The rules of communication outlined above apply, of course, and close
   collaboration with upstream makes for a healthy package that gets updated promptly as soon
   as the author uploads the new version. Although said author probably tested the software
   before releasing it into the wild, if you do some unit testing for yourself before
   uploading the package, even better. Take a look at tools like DejaGNU for this and report
   any issues found to upstream. Speaking of reporting, you must understand the responsibility
   you're taking upon yourself when becoming maintainer. ALL bug reports from Debian users
   will come to you, and it's your duty to act as a catalyst between the users and upstream in
   order to fix all issues.

5. The mentor

   Many of you, especially the older ones like me, have seen the Karate Kid series. If
   anything, that movie shows a relationship between a master and an apprentice (OK, you can
   use Star Wars as an example as well...). If you think that you ask to become a developer
   and your wish is granted in minutes, you forgot about patience. No, you need to ask for
   mentoring first, showing your accomplishments, your motivations and so on. After a while,
   after you've proven worthy, you will submit an application to become a maintainer, with the
   mentor vouching for you.

6. Uploading

   You're almost there, all you have to do is perform the upload proper. If you've come this
   far, you can already pat yourself on the back. Now, the application you need is called
   dupload(1), and you should create a file named dupload.conf(5) in your home directory and
   start modifying settings. You can, if the manual page of the file seems scary, take
   /etc/dupload.conf as an example. After saving ~/dupload.conf, you can do something like
   this:
 $ dupload yest-2.7.0.5_i386.changes

   Now, it's left as an exercise to the reader to find out what else must be done when
   uploading a package for the first time. Also, chapter 9 of the Debian New Maintainer's
   Guide should be read and read again and then some more. That's about it! If you liked our
   series, don't be shy! Tells us on [32]the forums!
