filename: c-preprocessor-stringification-multif-20260115.txt
https://users.informatik.haw-hamburg.de/~krabat/FH-Labor/gnupro/2_GNUPro_Compiler_Tools/The_C_Preprocessor/cppStringification.html

Stringification

   Stringification means turning a code fragment into a string constant whose contents are the text for
   the code fragment. For example, stringifying foo (z) results in "foo (z)".

   In the C preprocessor, stringification is an option available when macro arguments are substituted
   into the macro definition. In the body of the definition, when an argument name appears, the
   character # before the name specifies stringification of the corresponding actual argument when it is
   substituted at that point in the definition. The same argument may be substituted in other places in
   the definition without stringification if the argument name appears in those places with no #.

   What follows is an example of a macro definition that uses stringification.

#define WARN_IF(EXP) \
do { if (EXP) \
	fprintf (stderr, "Warning: " #EXP "\n"); } \
while (0)

   The actual argument for EXP is substituted once as given, into the if statement, and once as
   stringified, into the argument to fprintf. The do and while (0) are a work-around to make it possible
   to write WARN_IF (arg);, c55 which the resemblance of WARN_IF to a function would make C programmers
   want to do; see Swallowing the semicolon.

   The stringification feature is limited to transforming one macro argument into one string constant;
   there is no way to combine the argument with other text and then stringify it all together. The
   previous example shows how an equivalent result can be obtained in ANSI Standard C using the feature
   that adjacent string constants are concatenated as one string constant. The preprocessor stringifies
   the actual value of EXP into a separate string constant, resulting in text like the following output.

do {if (x==0)\
	fprintf (stderr, "Warning: " "x == 0" "\n"); } \
while (0)

   The C compiler then sees three consecutive string constants and concatenates them into one,
   producing, effectively, the following output.

do {if (x==0)\
	fprintf (stderr, "Warning: x == 0\n"); } \
while (0)

   Stringification in C involves more than putting doublequote characters around the fragment; it is
   necessary to put backslashes in front of all doublequote characters, and all backslashes in string
   and character constants, in order to get a valid C string constant with the proper contents. Thus,
   stringifying p="foo\n"; results in "p=\"foo\\n\";". However, backslashes that are not inside of
   string or character constants are not duplicated: \n by itself stringifies to "\n".

   Whitespace (including comments) in the text being stringified is handled according to precise rules.
   All leading and trailing whitespace is ignored. Any sequence of whitespace in the middle of the text
   is converted to a single space in the stringified result.


---
https://gcc.gnu.org/onlinedocs/gcc-5.5.0/cpp/Stringification.html

  3.4 Stringification

   Sometimes you may want to convert a macro argument into a string constant. Parameters are not
   replaced inside string constants, but you can use the '#' preprocessing operator instead. When a
   macro parameter is used with a leading '#', the preprocessor replaces it with the literal text of the
   actual argument, converted to a string constant. Unlike normal parameter replacement, the argument is
   not macro-expanded first. This is called stringification.

   There is no way to combine an argument with surrounding text and stringify it all together. Instead,
   you can write a series of adjacent string constants and stringified arguments. The preprocessor will
   replace the stringified arguments with string constants. The C compiler will then combine all the
   adjacent string constants into one long string.

   Here is an example of a macro definition that uses stringification:

#define WARN_IF(EXP) \
do { if (EXP) \
	fprintf (stderr, "Warning: " #EXP "\n"); } \
while (0)

WARN_IF (x == 0);
	-> do { if (x == 0)
		fprintf (stderr, "Warning: " "x == 0" "\n"); } while (0);

   The argument for EXP is substituted once, as-is, into the if statement, and once, stringified, into
   the argument to fprintf. If x were a macro, it would be expanded in the if statement, but not in the
   string.

   The do and while (0) are a kludge to make it possible to write WARN_IF (arg);, which the resemblance
   of WARN_IF to a function would make C programmers want to do; see Swallowing the Semicolon.

   Stringification in C involves more than putting double-quote characters around the fragment. The
   preprocessor backslash-escapes the quotes surrounding embedded string constants, and all backslashes
   within string and character constants, in order to get a valid C string constant with the proper
   contents. Thus, stringifying p = "foo\n"; results in "p = \"foo\\n\";". However, backslashes that are
   not inside string or character constants are not duplicated: '\n' by itself stringifies to "\n".

   All leading and trailing whitespace in text being stringified is ignored. Any sequence of whitespace
   in the middle of the text is converted to a single space in the stringified result. Comments are
   replaced by whitespace long before stringification happens, so they never appear in stringified text.

   There is no way to convert a macro argument into a character constant.

   If you want to stringify the result of expansion of a macro argument, you have to use two levels of
   macros.

#define xstr(s) str(s)
#define str(s) #s
#define foo 4

str (foo)
	-> "foo"
xstr (foo)
	-> xstr (4)
	-> str (4)
	-> "4"

   s is stringified when it is used in str, so it is not macro-expanded first. But s is an ordinary argument
   to xstr, so it is completely macro-expanded before xstr itself is expanded (see
   [https://gcc.gnu.org/onlinedocs/gcc-5.5.0/cpp/Argument-Prescan.html#Argument-Prescan]Argument Prescan).
   Therefore, by the time str gets to its argument, it has already been macro-expanded.


---
http://gloworm.stanford.edu/local/DOC/cpp_15.html

Stringification

   Stringification means turning a code fragment into a string constant whose contents are the text for
   the code fragment. For example, stringifying `foo (z)' results in `"foo (z)"'.

   In the C preprocessor, stringification is an option available when macro arguments are substituted
   into the macro definition. In the body of the definition, when an argument name appears, the
   character `#' before the name specifies stringification of the corresponding actual argument when it
   is substituted at that point in the definition. The same argument may be substituted in other places
   in the definition without stringification if the argument name appears in those places with no `#'.

   Here is an example of a macro definition that uses stringification:

#define WARN_IF(EXP) \
do { if (EXP) \
	fprintf (stderr, "Warning: " #EXP "\n"); } \
while (0)

   Here the actual argument for `EXP' is substituted once as given, into the `if' statement, and once as
   stringified, into the argument to `fprintf'. The `do' and `while (0)' are a kludge to make it
   possible to write `WARN_IF (arg);', which the resemblance of `WARN_IF' to a function would make C
   programmers want to do; see section Swallowing the Semicolon.

   The stringification feature is limited to transforming one macro argument into one string constant:
   there is no way to combine the argument with other text and then stringify it all together. But the
   example above shows how an equivalent result can be obtained in ANSI Standard C using the feature
   that adjacent string constants are concatenated as one string constant. The preprocessor stringifies
   the actual value of `EXP' into a separate string constant, resulting in text like

do { if (x == 0) \
	fprintf (stderr, "Warning: " "x == 0" "\n"); } \
while (0)

   but the C compiler then sees three consecutive string constants and concatenates them into one,
   producing effectively

do { if (x == 0) \
	fprintf (stderr, "Warning: x == 0\n"); } \
while (0)

   Stringification in C involves more than putting doublequote characters around the fragment; it is
   necessary to put backslashes in front of all doublequote characters, and all backslashes in string
   and character constants, in order to get a valid C string constant with the proper contents. Thus,
   stringifying `p = "foo\n";' results in `"p = \"foo\\n\";"'. However, backslashes that are not inside
   of string or character constants are not duplicated: `\n' by itself stringifies to `"\n"'.

   Whitespace (including comments) in the text being stringified is handled according to precise rules.
   All leading and trailing whitespace is ignored. Any sequence of whitespace in the middle of the text
   is converted to a single space in the stringified result.


---
https://www.geeksforgeeks.org/c/stringizing-and-token-pasting-operators-in-c/

# and ## Operators in C
04 Aug, 2025

   In C, # and ## operators are preprocessor operators using in macros for token manipulation. They are
   known as stringizing and token pasting operators and are used in macro definition with #define
   preprocessor. In this article, we will learn about these operators and how to use them in C programs.

Stringizing Operator (#)
   Syntax
#define MACRO_NAME(arg) #arg

   Example

#include <stdio.h>

// Macro definition using stringification (#)
// convert the argument x into a string
#define PRINT_STRING(x) printf(#x)

int main() {
	// Using the macro
	PRINT_STRING(Hello Geeks);

	return 0;
}

   Output
Hello Geeks

   Explanation: The # operator in the macro PRINT_STRING(x) converts the argument x into a string by
   enclosing it into double quotes. The statement PRINT_STRING(Hello Geeks) is hence converted into
   printf("Hello Geeks").

     Note: This operator should not be confused with the # operator used for defining preprocessor
     directive.

   The stringizing operator (#) is a preprocessor operator that causes the corresponding actual argument
   to be enclosed in double quotation marks. When the # operator is placed before an argument in a macro
   definition, it converts that argument into a string literal. It is generally used with macros in C.

Token Pasting Operator (##)
   Syntax
 #define MACRO_NAME(arg1, arg2) arg1 ## arg2

   Examples:

#include <stdio.h>

// Macro definition using the Token-pasting operator
#define concat(a, b) a##b

int main(void) {
	int xy = 30;

	// Printing the concatenated value of x and y
	printf("%d", concat(x, y));
	return 0;
}

   Output
30

   Explanation: The ## operator in the macro concat(a, b) is the token-pasting operator. It concatenates
   two tokens (a and b) into a single token. In this example, concat(x, y) concatenates x and y to form
   xy, which refers to the variable int xy = 30;. Therefore, printf("%d", concat(x, y)); prints the
   value of xy, which is 30.

   The token-pasting operator (##) allows tokens used as actual arguments to be concatenated to form
   other tokens. It is often useful to merge two tokens into one while expanding macros. This is called
   token pasting or token concatenation.

   The ## pre-processing operator performs token pasting. When a macro is expanded, the two tokens on
   either side of each '##' operator are combined into a single token, which then replaces the '##' and
   the two original tokens in the macro expansion.

Application of Token-pasting operator (##)
   The ## provides a way to concatenate actual arguments during macro expansion. If a parameter in the
   replacement text is adjacent to a ##, the parameter is replaced by the actual argument, the ## and
   surrounding white space are removed, and the result is re-scanned.

   Predict the output of the following program:

#include <stdio.h>

#define combine(a, b, c, d, e, f, g) c ## d ## e ## f
#define start combine(m, a, i, n, p, r, o)

int start() {
	printf("Did you figure it out?\n");
	return 0;
}


---
https://en.cppreference.com/w/cpp/preprocessor/replace.html

Replacing text macros

The preprocessor supports text macro replacement. Function-like text macro replacement is also supported.

Syntax
#define identifier replacement-list (optional)                    (1)
#define identifier (parameters ) replacement-list (optional)      (2)
#define identifier (parameters , ...) replacement-list (optional) (3) (since C++11)
#define identifier (...) replacement-list (optional)              (4) (since C++11)
#undef identifier                                                 (5)

Explanation

#define directives
The #define directives define the identifier as macro, that is instruct the compiler to replace most
successive occurrences of identifier with replacement-list, which will be additionally processed. Exceptions
arise from the rules of scanning and replacement. If the identifier is already defined as any type of macro,
the program is ill-formed unless the definitions are identical.

Object-like macros
Object-like macros replace every occurrence of defined identifier with replacement-list. Version (1) of the #
define directive behaves exactly like that.

Function-like macros
Function-like macros replace each occurrence of defined identifier with replacement-list, additionally taking
a number of arguments, which then replace corresponding occurrences of any of the parameters in the 
replacement-list.

The syntax of a function-like macro invocation is similar to the syntax of a function call: each instance of
the macro name followed by a ( as the next preprocessing token introduces the sequence of tokens that is
replaced by the replacement-list. The sequence is terminated by the matching ) token, skipping intervening
matched pairs of left and right parentheses.

For version (2), the number of arguments must be the same as the number of parameters in macro definition.
For versions (3,4), the number of arguments must not be less than the number of parameters (not(since C++20)
counting ...). Otherwise the program is ill-formed. If the identifier is not in functional-notation, i.e.
does not have parentheses after itself, it is not replaced at all.

Version (2) of the #define directive defines a simple function-like macro.
Version (3) of the #define directive defines a function-like macro with variable number of arguments. The
additional arguments (called variable arguments) can be accessed using __VA_ARGS__ identifier, which is then
replaced with arguments, supplied with the identifier to be replaced.

Version (4) of the #define directive defines a function-like macro with variable number of arguments, but no
regular arguments. The arguments (called variable arguments) can be accessed only with __VA_ARGS__
identifier, which is then replaced with arguments, supplied with the identifier to be replaced.

-------------------------------------------------------------------------------------------------------------
For versions (3,4), replacement-list may contain the token sequence __VA_OPT__(content ), which is
replaced by content if __VA_ARGS__ is non-empty, and expands to nothing otherwise.

#define F(...) f(0 __VA_OPT__(,) __VA_ARGS__)
F(a, b, c) // replaced by f(0, a, b, c)
F()        // replaced by f(0)
                                                                                                     (since
#define G(X, ...) f(0, X __VA_OPT__(,) __VA_ARGS__)                                                  C++20)
G(a, b, c) // replaced by f(0, a, b, c)
G(a, )     // replaced by f(0, a)
G(a)       // replaced by f(0, a)

#define SDEF(sname, ...) S sname __VA_OPT__(= { __VA_ARGS__ })
SDEF(foo);       // replaced by S foo;
SDEF(bar, 1, 2); // replaced by S bar = { 1, 2 };
-------------------------------------------------------------------------------------------------------------

Note: if an argument of a function-like macro includes commas that are not protected by matched pairs of left
and right parentheses (most commonly found in template argument lists, as in assert(std::is_same_v<int, int>)
; or BOOST_FOREACH(std::pair<int, int> p, m)), the comma is interpreted as macro argument separator, causing
a compilation failure due to argument count mismatch.

Scanning and Replacement
  * Scanning keeps track of macros they replaced. If scan finds text matching such macro, it marks it "to be
    ignored" (all scans will ignore it). This prevents recursion.
  * If scanning found function-like macro, arguments are scanned before put inside replacement-list. Except #
    and ## operators take argument without scan.
  * After macro was replaced, result text is scanned.

Note, it is possible to define pseudo recursive macro:

-------------------------------------------------------------------------------------------------------------
#define EMPTY
#define SCAN(x)     x
#define EXAMPLE_()  EXAMPLE
#define EXAMPLE(n)  EXAMPLE_ EMPTY()(n-1) (n)
EXAMPLE(5)
SCAN(EXAMPLE(5))
-------------------------------------------------------------------------------------------------------------

Output:
EXAMPLE_ ()(5 -1) (5)
EXAMPLE_ ()(5 -1 -1) (5 -1) (5)

Reserved macro names
A translation unit that includes a standard library header may not #define or #undef names declared in any
standard library header.

A translation unit that uses any part of the standard library is not allowed to #define or #undef names
lexically identical to:

  * keywords
-------------------------------------------------------------------------------------------------------------
  * identifiers with special meaning                                                              (since
  * any standard attribute token, except that likely and unlikely may be defined as function-like C++11)
    macros(since C++20)
-------------------------------------------------------------------------------------------------------------
Otherwise, the behavior is undefined.

# and ## operators
In function-like macros, a # operator before an identifier in the replacement-list runs the identifier
through parameter replacement and encloses the result in quotes, effectively creating a string literal. In
addition, the preprocessor adds backslashes to escape the quotes surrounding embedded string literals, if
any, and doubles the backslashes within the string as necessary. All leading and trailing whitespace is
removed, and any sequence of whitespace in the middle of the text (but not inside embedded string literals)
is collapsed to a single space. This operation is called "stringification". If the result of stringification
is not a valid string literal, the behavior is undefined.

-------------------------------------------------------------------------------------------------------------
When # appears before __VA_ARGS__, the entire expanded __VA_ARGS__ is enclosed in quotes:

#define showlist(...) puts(#__VA_ARGS__)                                                  (since C++11)
showlist();            // expands to puts("")
showlist(1, "x", int); // expands to puts("1, \"x\", int")
-------------------------------------------------------------------------------------------------------------

A ## operator between any two successive identifiers in the replacement-list runs parameter replacement on
the two identifiers (which are not macro-expanded first) and then concatenates the result. This operation is
called "concatenation" or "token pasting". Only tokens that form a valid token together may be pasted:
identifiers that form a longer identifier, digits that form a number, or operators + and = that form a +=. A
comment cannot be created by pasting / and * because comments are removed from text before macro substitution
is considered. If the result of concatenation is not a valid token, the behavior is undefined.

Note: some compilers offer an extension that allows ## to appear after a comma and before __VA_ARGS__, in
which case the ## does nothing when the variable arguments are present, but removes the comma when the
variable arguments are not present: this makes it possible to define macros such as fprintf (stderr, format, 
##__VA_ARGS__). This can also be achieved in a standard manner using __VA_OPT__, such as fprintf (stderr,
format __VA_OPT__(, ) __VA_ARGS__).(since C++20)

#undef directive
The #undef directive undefines the identifier, that is cancels previous definition of the identifier by #
define directive. If the identifier does not have associated macro, the directive is ignored.

Predefined macros
The following macro names are predefined in every translation unit:
-------------------------------------------------------------------------------------------------------------
                                       denotes the version of C++ standard that is being used,
                                       expands to value

                                         * 199711L(until C++11),
                                         * 201103L(C++11),
__cplusplus
                                         * 201402L(C++14),
                                         * 201703L(C++17),
                                         * 202002L(C++20), or
                                         * 202302L(C++23)
                                           (macro constant)
-------------------------------------------------------------------------------------------------------------
                                       expands to the integer constant 1 the
__STDC_HOSTED__                        implementation is
(C++11)                                hosted (runs under an OS), ​0​ if freestanding (runs without
                                       an OS)
                                       (macro constant)
-------------------------------------------------------------------------------------------------------------
                                       expands to the name of the current file, as a
__FILE__                               character string literal, can be changed by the # line directive
                                       (macro constant)
-------------------------------------------------------------------------------------------------------------
                                       expands to the line number of the current physical source line, an
__LINE__                               integer constant, can be changed by the #line directive
                                       (macro constant)
-------------------------------------------------------------------------------------------------------------
                                       expands to the date of translation, a character string literal of the
                                       form "Mmm dd yyyy" . The first
__DATE__                               character of "dd" is a space if the day of the month is less than 10.
                                       The name of the month is as if generated by std:: asctime()
                                       (macro constant)
-------------------------------------------------------------------------------------------------------------
                                       expands to the time of translation, a
__TIME__                               character string literal of the form "hh:mm:ss"
                                       (macro constant)
-------------------------------------------------------------------------------------------------------------
                                       expands to an std::size_t literal whose value is the alignment
                                       guaranteed by a call to
__STDCPP_DEFAULT_NEW_ALIGNMENT__       alignment-unaware
(C++17)                                operator new (larger alignments will be passed to alignment-aware
                                       overload, such as operator new(std:: size_t, std:: align_val_t))
                                       (macro constant)
-------------------------------------------------------------------------------------------------------------
                                       expands to 1 if and only if the implementation
__STDCPP_­BFLOAT16_­T__
__STDCPP_­FLOAT16_­T__
__STDCPP_FLOAT32_T__
__STDCPP_FLOAT64_T__
__STDCPP_FLOAT128_T__ supports
(C++23)                                corresponding extended floating-point type
                                       (macro constant)
-------------------------------------------------------------------------------------------------------------
__STDC_EMBED_NOT_FOUND__
__STDC_EMBED_FOUND__
__STDC_EMBED_EMPTY__                   expands to 0, 1 and 2 respectively
(C++26)                                (macro constant)

The following additional macro names may be predefined by the implementations:
-------------------------------------------------------------------------------------------------------------
__STDC__                 implementation-defined value, if present, typically used to indicate C conformance
                         (macro constant)
-------------------------------------------------------------------------------------------------------------
__STDC_VERSION__         implementation-defined value, if present
(C++11)                  (macro constant)
-------------------------------------------------------------------------------------------------------------
                         expands to an integer constant of the form yyyymmL, if wchar_t uses Unicode, (until
                         the date indicates the latest revision of Unicode supported                  C++23)

__STDC_ISO_10646__       implementation-defined value, if present
(C++11)                  (macro constant)                                                       (since C++23)
-------------------------------------------------------------------------------------------------------------
__STDC_MB_MIGHT_NEQ_WC__ expands to 1 if 'x' == L'x' might be false for a member x of the basic character
(C++11)                  set, such as on EBCDIC-based systems that use Unicode for wchar_t
                         (macro constant)
-------------------------------------------------------------------------------------------------------------
__STDCPP_THREADS__       expands to 1 if the program can have more than one thread of execution
(C++11)                  (macro constant)
-------------------------------------------------------------------------------------------------------------
__STDCPP_STRICT_POINTER_SAFETY__ expands to 1 if the implementation has strict std::pointer_safety
(C++11)(removed in C++23)        (macro constant)
-------------------------------------------------------------------------------------------------------------

The values of these macros (except for __FILE__ and __LINE__) remain constant throughout the translation
unit. Attempts to redefine or undefine these macros result in undefined behavior.

-------------------------------------------------------------------------------------------------------------
Language feature-testing macros
The standard defines a set of preprocessor macros corresponding to C++ language features introduced   (since
in C++11 or later. They are intended as a simple and portable way to detect the presence of said      C++20)
features.
See Feature testing for details.
-------------------------------------------------------------------------------------------------------------
Notes
                                                                                                    (since
The function-local predefined variable __func__ is not a predefined macro, but it is usually used   C++11)
together with __FILE__ and __LINE__, e.g. by assert.
-------------------------------------------------------------------------------------------------------------

Example

#include <iostream>

// Make function factory and use it
#define FUNCTION(name, a) int fun_##name() { return a; }

FUNCTION(abcd, 12)
FUNCTION(fff, 2)
FUNCTION(qqq, 23)

#undef FUNCTION
#define FUNCTION 34
#define OUTPUT(a) std::cout << "output: " #a << '\n'

// Using a macro in the definition of a later macro
#define WORD "Hello "
#define OUTER(...) WORD #__VA_ARGS__

int main() {
	std::cout << "abcd: " << fun_abcd() << '\n';
	std::cout << "fff: " << fun_fff() << '\n';
	std::cout << "qqq: " << fun_qqq() << '\n';

	std::cout << FUNCTION << '\n';
	OUTPUT(million); //note the lack of quotes

	std::cout << OUTER(World) << '\n';
	std::cout << OUTER(WORD World) << '\n';
}

Output:

abcd: 12
fff: 2
qqq: 23
34
output: million
Hello World
Hello WORD World

Defect reports
The following behavior-changing defect reports were applied retroactively to previously published C++
standards.

-------------------------------------------------------------------------------------------------------------
DR         Applied to   Behavior as published                                           Correct behavior
-------------------------------------------------------------------------------------------------------------
                        it was unclear whether __LINE__ expands to the current          expands to the
CWG 2908   C++98        physical line number or the current logical line number         current
                                                                                        physical line number
-------------------------------------------------------------------------------------------------------------
                        a translation unit that includes a standard library header
LWG 294    C++98        could contain macros that define names declared in other        prohibited
                        standard library headers
-------------------------------------------------------------------------------------------------------------
P2621R2    C++23        universal character names were not allowed                      allowed
                        to be formed by token concatenation
-------------------------------------------------------------------------------------------------------------

See also
C++ documentation for Macro Symbol Index
C documentation for Replacing text macros

Retrieved from "https://en.cppreference.com/mwiki/index.php?title=cpp/preprocessor/replace&oldid=182196"


---

