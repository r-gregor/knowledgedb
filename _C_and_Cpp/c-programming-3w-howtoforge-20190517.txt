c_programming_3w-howtoforge_20190517.txt
https://www.howtoforge.com/linux-c-programming-introduction/

C Programming Language - Introduction

   C is a procedural programming language that was designed by American computer scientist Dennis
   Ritchie. The language - which first appeared in 1972 - was developed by Ritchie in association with
   Bell Labs. Despite being close to 50 years old, the C programming language has not lost its relevance
   in the modern day computer software development scene. It's still used in time and speed critical
   areas like OS and firmware development (to name a few).

   Several of the newer languages like C++, Java, PHP, and more are based on C. And that's the reason
   students are still advised to get proficient in C in order to have good command on any of the newer
   languages based on C. So keeping this importance in mind, we will kick-start a series of tutorials
   where we will be discussing the basics of the C programming language.

   Please note that we'll be using Linux for all our examples and explanation. Specifically, we'll be
   using Ubuntu 18.04 LTS.

Basic C program
   To begin with, let's take a look at a simple C program.
#include <stdio.h>
int main (void)
{
    printf("\n Hello World \n");
    return 0;
}

   So you can see the program begins with a #. In C programming language, any line that begins with a #
   is dealt by preprocessor at the first stage of compilation of the program. We won't go in to the
   specifics of compilation stages, but for the time being, keep in mind that the first thing that will
   happen during compilation of this program is that the line beginning with # will get replaced by
   whatever is there in the stdio.h header file.

   Then comes the next line: 'int main (void)'. This is basically beginning of a function called 'main'
   which returns an integer (int) value and accepts nothing (void). It's worth mentioning here that
   every C program that you'll see consists of one or more functions. The 'main' function is the one
   where the execution starts once the program is run. While all other functions get called from within
   main or other functions (meaning you have control over their calling sequence), main itself gets
   called as the first function from within the system.

   Moving on, then you see a curly bracket ( { ). This basically defines the beginning scope of a
   function. Of course, towards the end, you'll see a reverse curly bracket ( } ), which defines the end
   of scope of the function. All the instructions inside these brackets are treated as part or body of
   the function.

   Here, there are two lines of code in the body of the 'main' function. The first is 'printf("\n Hello
   World \n");'. Printf is a system library function that prints formatted strings on STDOUT. For now,
   just keep in mind that it prints anything you supply within double quotes (" ") except escape
   sequences (like '\n', which is translated into a newline). The second line of the body is 'return 0'.
   It basically marks the end of the 'main' function and sends '0' as the result to the function that
   called 'main'.

   So all in all, we should expect this program to print 'Hello World' in output.

Compile and execute C program
   Now that we have understood a simple C program, lets go ahead and execute it. So the first step would
   be save the code in a file named, say, hello-world.c. You can use the Vim editor to do this. Once
   you save the code in hello-world.c, make sure you have the gcc tool installed on your Linux system.
   If not, you can download and install (at least on Ubuntu) using the following command:
sudo apt install gcc

   Gcc is basically a GNU compiler for the C programming language. Once it's there on your system, just
   use it in the following way to compile the hello-world.c program:
gcc -Wall hello-world.c -o hello

   Here, -Wall is a gcc command option that enables a lot of compilation time warnings that the compiler
   would otherwise not throw. The other option you see is -o, which is used to specify an output file
   name. So in this case, we want the output file to be named 'hello'.

   As you run the command mentioned above, you'll see a file named 'hello' will be produced. It's an
   executable file. you can run it in the following way:
./hello

   For example, when I executed this command, the following output was produced:

   [21]Hello World Program in C Programming Language

   So you can see, 'hello world' was produced in the output.

Conclusion
   In this article, we learned the very basics of C programming language using a demo program. Now that
   we know how to write, compile and execute a C program, we will step into other aspects in the next
   article. Stay tuned.


---
https://www.howtoforge.com/c-programming-tutorial-part-2-preprocessors/

C Programming Tutorial Part 2 - Preprocessors

   In the first part of our ongoing C programming tutorial series, we briefly touched on the
   preprocessing stage. In this tutorial, we will discuss it in a little more detail so that you have a
   basic idea about it before learning other C programming aspects.

   Preprocessing is usually the first stage of program compilation, where-in anything beginning with a
   '#' gets processed. Let's take a basic example code.
#include <stdio.h>
int main (void)
{
    printf("\n Hello World \n");
    return 0;
}

   Yes, this is the same piece of code we used in the first part of this article series. Here, it's the
   first line that begins with a hash '#'. In layman's terms, the line '#include <stdio.h>' makes sure
   the content of header file 'stdio.h' are included in this program during compilation.

   So what happens in the preprocessing stage is, this line gets replaced with the actual content of the
   header file. Here's how the code looks after the preprocessing stage:

   [17]C Code File

   So you can see, everything above the few lines of code we wrote (look at the bottom of the
   screenshot) is the contents of stdio.h. Now, I won't go in details of how I managed to see the code
   after preprocessing, but this was to give you a clear idea on what happens during preprocessing.

   Moving on, lines that include a header file aren't the only ones that begin with a hash (#). There's
   also something called Macros that also begin with #. So it's important to discuss them here (at least
   their basics).

   A Macro is nothing but a name (usually in capital letters) that refers to a piece of code. Macros are
   defined using the '#define' directive. Here's an example:
#include <stdio.h>
#define PRINT_HELLO_WORLD printf("\n Hello World \n");
int main (void)
{
    PRINT_HELLO_WORLD
    PRINT_HELLO_WORLD
    return 0;
}

   So we defined a macro PRINT_HELLO_WORLD with value printf("\n Hello World \n"); . Now, wherever we'll
   use this macro name in the code, it will get replaced with its value during the preprocessing stage.
   Here's the code after pre-processing:

   [18]C Program Macro

   So you see that both occurrences of the macro were replaced by its value at the pre-processing stage.
   Of course, there are several other details related to macros that you should know about in order to
   successfully use them. We will discuss those details in a Macro dedicated part of this tutorial
   series.

   Moving on, the third type of lines beginning with # are #ifdef and #endif. These are used for
   conditional compilation. To give you a quick idea, there are times when you'd not want a part of code
   to get compiled based on a certain condition, it's in cases like these, these directives are used.

   Here's an example:
#include <stdio.h>
#define PRINT_HELLO_WORLD printf("\n Hello World \n");
int main (void)
{
#ifdef CONDITION
    PRINT_HELLO_WORLD
#endif
    PRINT_HELLO_WORLD
    return 0;
}

   In the code above, since 'CONDITION' isn't defined anywhere, so the first occurrence of
   'PRINT_HELLO_WORLD' will be omitted from code at the preprocessing stage only. Here's the proof:

   [19]Code condition

   So you can see only one printf statement after the preprocessing stage.

Conclusion
   In this tutorial, we discussed preprocessing to give C programming beginners a basic idea of what
   happens during this stage. Now, move on to part 3 to learn further about C programming basics.
   Himanshu Arora


---
https://www.howtoforge.com/c-programming-tutorial-part-3-variables/

C Programming Tutorial Part 3 - Variables basics

   Up until now, we've discussed the basics of what a C program is, how to compile and execute it,
   and what are preprocessors. If you have gone through these tutorials, it's time we discuss the
   next topic, which is variables.

   Variables are one of the core elements of C programming as they store values for programmers to use
   as per their requirement. Let's understand their basics through an example. Following is a basic C
   program:
#include <stdio.h>
int main (void)
{
 int a = 10;
 char b = 'z';
 float c = 1.5;
 printf("\n a=%d, b=%c, c=%f \n", a,b,c);
 return 0;
}

   In previous C programming tutorials, we have already explained things like what is 'stdio.h,' what
   does '#include' mean, and what is a function (especially 'main'). So, we'll directly jump onto the
   variables part.

   The line 'int a =10' means there is a variable named 'a' which can hold integer ('int') type values,
   and the current value it's holding is '10'. Similarly, 'b' can hold characters and 'c' can hold
   floating point numbers, with their current values being 'z' and '1.5', respectively.

   The example program shown above prints these values in output through the 'Printf' function. Note
   that %d, %c, and %f are used to tell the 'printf' function that variables 'a', 'b', 'c' should be
   treated as integer, character, and float, respectively.

Operations on variables
   Of course, you can do a lot more than just printing these values in output. For example, the
   following program calculates factorial of number 5.
#include <stdio.h>
int main (void)
{
 int num = 5;
 int result = 1;
 while (num > 0)
 {
    result = result * num;
    num = num -1;
 }
 printf("\n Factorial of 5 is %d\n", result);

 return 0;
}

   For those who aren't aware, the factorial of a number, say 'n', is the result of the following
   multiplication:
nx(n-1)x(n-2)x.....1

   So, if the number is 5, then factorial of 5 (or, 5!) would be 5x4x3x2x1, which equals 120.

   Coming back to the program, we have defined two integer variables named 'num' and 'result'. While num
   contains the number whose factorial is to be calculated (5 in this case), 'result' just holds a dummy
   value of '1' to begin with. Then comes a 'while' loop.

   As the name suggests, loops are used in C functions to repeatedly execute a set of instructions. In
   case of 'while', the loop begins by checking a condition ('num should be greater than zero' in this
   case) and then instructions inside the loop are executed repeatedly until the while condition becomes
   false.

   In our case,  value of 'num' is 5 initially. So the execution will enter inside the loop and the
   first value of result 'would' be '5' (1x5). Thereafter 'num' becomes 'num -1', which means the new
   value of 'num' is now 4.

   The loop then executes again because 4 is still greater than zero. This time, 'result' would be 5x4,
   which is 20. And 'num' then becomes (4-1), which is 3. This way, the loop continues to execute until
   'num' becomes 0, and by that time, result is '120', which is the factorial of 5.

   So here's the output produced by this program:
Factorial of 5 is 120

   Now, instead of a specific value (like '5' in this case), what if you want the user of the program to
   specify the number whose factorial is to be calculated? Well, that can be done in the following way:
#include <stdio.h>
int main (void)
{
 int num = 0, temp=0;
 printf("\n Enter a positive integer: ");
 scanf("%d", &num);
 temp = num;
 int result = 1;
 while (temp > 0)
 {
    result = result * temp;
    temp = temp -1;
 }
 printf("\n Factorial of %d is %d\n", num, result);

 return 0;
}

   So here, we have used a new function called 'scanf', which does exactly opposite of 'printf' - it
   accepts input from user.

   Now, every variable has a certain amount of memory associated with it in terms of bytes. The scanf
   function requires you to pass the starting address of a variable's memory, which you can access by
   placing '&' before the variable's name.

   We have introduced a new variable 'temp' here as we need the actual number passed by the user (stored
   in 'num' here) in the last 'printf' statement.

Conclusion
   In this tutorial, we touched upon the basics of variables. This tutorial should have given you a
   basic idea on what variables are, and how they can be used in the C programming language. There are
   several other aspects related to variables that need to be discussed - we'll be doing that in the
   next tutorial.


---
https://www.howtoforge.com/c-programming-tutorial-part-3-variables-and-memory/

C Programming Tutorial 4 - Variables and Memory

   In this tutorial series so far, we have discussed how to create and run a basic C program, what
   are preprocessors, as well as basics of variables. Now let's dig a bit deep into variables and
   discuss the memory aspect.

   Assuming you have already gone through all our tutorials so far (or you have basic knowledge required
   to understand this tutorial), let's begin with a simple code example we used in one of our previous
   tutorials.
#include <stdio.h>
int main (void)
{
 int num = 0, temp=0;
 printf("\n Enter a positive integer: ");
 scanf("%d", &num);
 temp = num;
 int result = 1;
 while (temp > 0)
 {
    result = result * temp;
    temp = temp -1;
 }
 printf("\n Factorial of %d is %d\n", num, result);

 return 0;
}

   This program, as you can see, calculates factorial of a number entered by a user.

   Now, for smaller integers like 5 or 6, this program will work fine - it will correctly output the
   factorial result. But, let's say you try it out for number 13. Here's the result you'll get:
Factorial of 13 is 1932053504

   But that's not true as the factorial of 13 is 6227020800. So, naturally, the question is why our
   program gave wrong answer? Well, the answer lies in the amount of memory an int variable occupies in
   system.

   In most systems today, int occupies 4 bytes (or 32 bits) of memory. Note that you can use the
   following line in your program to know the amount of bytes int occupies on your system.
printf("\n int size in bytes is: %d ", sizeof (int));

   And since an int variable can store negative values as well, the range of values it can store varies
   from -2,147,483,648 to 2,147,483,647.

   Now, since factorial of 13 is far greater than the maximum value an int variable can hold, our
   program gives a wrong output. The only way to get the program corrected is to use a variable type
   that has the capacity to hold 6227020800.

   If you want to hold a bigger positive integer value, you can use 'unsigned int', which can store
   values ranging from 0 to 4,294,967,295 (assuming this type of variables occupy 4 bytes on your
   system). But here, even 'unsigned int' won't do as the factorial of 13 is beyond its max capacity.

   So our savior here would be 'long long,' which occupies 8 bytes or 64 bits of memory. So here's the
   revised program:
#include <stdio.h>
int main (void)
{
 long long num = 0; long long temp=0;
 printf("\n Enter a positive integer: ");
 scanf("%d", &num);
 temp = num;
 long long result = 1;
 while (temp > 0)
 {
 result = result * temp;
 temp = temp -1;
 }
 printf("\n Factorial of %lld is %lld\n", num, result);

 return 0;
}

   The way you make printf or scanf identify a 'long long' variable is by using %lld (or %I64d in some
   cases). Here's the output this modified program produces:
Factorial of 13 is 6227020800

   Which is correct.

   So, now we know the limitation of 'int' and how 'unsigned int' and 'long long' can be used to
   overcome that. Keep in mind that 'long; ' is also a variable type but on most systems today, both int
   and long occupy 4 bytes.

   Oh, and yes, while 'int', 'unsigned int' and 'long long' are for integers, there's 'float' and
   'double' for floating point numbers. Float is 32 bit and has 7 decimal digits of precision, while
   double is 64 bit and has 15 decimal digits of precision.

   The mention of floating point numbers brings me to another important point here. It's related to
   division. Let's take a simple C code example to understand this.
int main (void)
{
 int a=5, b=10;
 printf("\n a/b is %d", a/b);

 return 0;
}

   So this program does nothing, but divide a by b, or 5 by 10.

   In real life, if you ask anyone the result of 5/10, you'll get 0.5 as the answer in majority of the
   cases. But here, the answer will be zero (0). Reason being, both 'a' and 'b' are integers, and hence
   the result of their division will also be considered as an integer, and so the floating part will get
   disregarded.

   To preserve the floating part, you'll have to make sure both 'a' and 'b' are floating point
   variables.
#include <stdio.h>
int main (void)
{
 float a=5, b=10;
 printf("\n a/b is %f", a/b);

 return 0;
}

   In this case, the output would be 0.5.

Conclusion
   In this tutorial, we discussed about variable size and how it affects storage of values. I hope you'd
   got a good idea on how and when to use int, unsigned int, long long, float, and double. In the next
   tutorial, we'll be discussing character type variables as well as arrays.


---
https://www.howtoforge.com/c-programming-tutorial-part-3-character-variables/

C Programming Tutorial Part 5 - Character variables

   In the previous two tutorials, we discussed the basics of variables including how they occupy
   memory. But we mainly focused on integers and floats. In this tutorial, we will discuss about
   characters (or char type variables).

   Variables of 'char' type occupy 1 byte (or 8 bits) in the memory.  As I mentioned earlier in case of
   'int' and 'float,' you can check the amount of memory a character occupies on your system using the
   following C program:
#include <stdio.h>
int main (void)
{
 printf("\n sizeof char in bytes is %u", sizeof(char));

 return 0;
}

   On my system, the following was the output:
 sizeof char in bytes is 1

   Now comes the question of how to accept characters as input from user and how to print them in
   output. Well, for accepting characters in input, there's a dedicated function named 'getchar'.
   Similarly, to print individual characters, you have 'putchar'. The following piece of code should
   give you a better idea on how these functions work:
#include <stdio.h>
int main (void)
{
 int c;
 c = getchar();
 putchar(c);

 return 0;
}

   The code above, when executed, first waits for user to input a character. After that, it simply
   outputs the same character on terminal.

   It could be a bit surprising for you that the value 'getchar' returns is stored in an integer, but
   that's how it is (the function returns an int). But you can always compare the value returned by
   'getchar' with a character. Here's an example:
#include <stdio.h>
int main (void)
{
 int c;
 c = getchar();
 if(c == 'a')
 {
    printf("matched");
 }
 else
 {
    printf ("doesn't match");
 }
 return 0;
}

   So here, if the user inputs 'a', then the program prints 'matched' in output. Else, you get to see
   'doesn't match'.

   Oh, and yes, this is the first time we've used 'if' and 'else' statements. As you'd have understood
   by now, 'if' lets you execute a set of statements if a condition is true. When the 'if' condition
   fails, code execution automatically enters 'else' block. Note that you can use an 'if' statement
   without and 'else' statement, but vice versa is not valid.

   Now, coming back to getchar and putchar, let's quickly discuss how these functions can be used to
   solve real life problems. Let's say you wanna count the number of lines a user provided as input to
   your program, then you can do that in the following way:
#include <stdio.h>
int main (void)
{
 int c =0, counter=0;
 c = getchar();
 while(c != EOF)
 {
    c = getchar();
    if(c == '\n')
    counter = counter+1;
 }
 printf("\n The input contains %d lines \n", counter+1);
 return 0;
}

   To understand the above program, you must first know what EOF is. Well, EOF stands for End Of File.
   It's used to signify that user has done with entering input.

   So when you, as a user providing input, are done with the process, you press ctrl+d (a couple of
   times). It's this action that produces a value equivalent to that of EOF, which can be checked in the
   program - just like we did.

   Coming back to the program, you first check the first character of input to see if it's EOF. If it's
   not, you enter the while loop and continuously check each character until you get an EOF. During this
   whole process, whenever you get a newline character (\n), you increase the 'counter' variable.

   After and EOF is detected, the while loop is terminated and we print the number of lines, which one
   more than the value of counter.

   The reason we add one to 'counter' in the 'printf' function is, the number of lines is always one
   more than the number of newline characters (or in layman terms, the number of times user pressed the
   'Enter' key). Of course, this is assuming whenever user presses enter, they enter some text as well.

   So if you give this program an input like the following:
Hello
Welcome to HowtoForge
Thanks

    The output would be:
The input contains 3 lines

   Note that our code assumes user will provide at least one line. Couple of corner cases aren't handle
   intentionally to keep things simple. One is when the user provides EOF without providing any other
   character in input, and the other is when a line has been provided without providing a newline
   character.

   Calculating number of lines is just one example. You can also extend this code to calculate total
   number of words entered by the user. Consider this as an assignment and try to code it yourself. As a
   hint, I'd say consider spaces (' ') and tabs ('\t'), similar to the way we considered newlines ('\n')
   to calculate number of lines.

Conclusion
   In this tutorial, we discussed a bit more on characters, including how to use them, accept them as
   input and print them in output. We also discussed an example where the getchar function helped us
   calculate number of lines in input. Do try out the assignment I gave in the last paragraph and let me
   know if you have any doubt or query.


---
https://www.howtoforge.com/c-command-line-tutorial-part-6/

C Command Line Tutorial 6 - Code indentation, increment/decrement operators, do-while and for loops, and more

   We have covered a total of 5 C programming tutorials so far. Each tutorial focused on something
   specific. In process of remaining close to the topic, some generic concepts remained untouched. Some
   of those concepts we'll be discussing here in this tutorial.

   So let's begin.

1. Code indentation
   You should always properly indent your code. For starters, indentation is a practice where-in you put
   spaces/tabs/newlines to make the code look more readable. Usually, lines of code associated with a
   block or loop are positioned at same gap. For example, here's an unindented code:
#include <stdio.h>
int main (void)
{
 int c =0, counter=0;
 c = getchar();
 while(c != EOF)
 {
 c = getchar();
 if(c == '\n')
 counter = counter+1;
 }
 printf("The input contains %d lines", counter+1);
 return 0;
}

   And here's the same code with indentation applied:
#include <stdio.h>
int main (void)
{
    int c =0, counter=0;
    c = getchar();

   while(c != EOF)
   {
       c = getchar();

       if(c == '\n')
           counter = counter+1;
   }

   printf("The input contains %d lines", counter+1);

   return 0;
}

   So you can see, the indented code looks sorted out and easy to read and review.

2. Increment and decrement operators
   You may have noticed in previous tutorials, we have used the following way to increment a variable:
a = a+1;

   While there's nothing wrong with this way, there's another way which is popular and used a lot. It's
   to use an increment operator.
a++

   Using this way, the value of 'a' increments by 1. Note that this is a post-increment. There's a
   pre-increment operator as well:
++a

   The difference between the two is in post-increment, the variable is first used and then its value if
   increment. On the other hand, in pre-increment, the value is first increased and then the variable is
   used.

   The following piece of code will better explain the difference.
#include <stdio.h>
int main (void)
{
    int a =0, b=0;

    printf("a = %d", a++);
    printf("\n b = %d", ++b);

    return 0;
}

   The output of this program is:
a = 0
b = 1

   So you can see, while post increment didn't reflect immediately, pre-increment did.

   The same logic applies to decrement operators as well.
#include <stdio.h>
int main (void)
{
    int a =1, b=1;

    printf("a = %d", a--);
    printf("\n b = %d", --b);

    return 0;
}

   The output is:
a = 1
b = 0

3. Comments
   There are two ways in which you can comment code in C. One is using '//'. This way, you can only
   comment a single line at a time.
// int a = 10;
// a = 9;

   The other way is to put /* .... */ around the lines. This allows you to comment multiple lines at
   once.
/* int a = 10;
a = 9; */

4. For and do-while loop
   Up until now, we have only touched upon the while loop, wherein the code execution only enters the
   while block if the condition is true.
while(condition)
{
/*
   line of code
   line of code
   ...
*/
}

   There also exists a do-while loop, wherein the block of code is executed once for the first time and
   then the while condition is checked.
 do
 {
 // few lines of code
 } while (condition);

   Now, the question is when to use do-while? I'll give you an example. Suppose you want the user to
   input a value which is greater than 10, and the requirement is to keep asking the user to enter such
   a value until the program gets one. Then here's how the do-while loop will be helpful in that case:
do
 {
     printf("Please enter a number greater than 10: ");
     scanf("%d", &n);
 }while(n<=10);

   Next up is 'for' loop, which like 'while' has a condition to check, but also has an increment
   statement or decrement statement that's helpful in many cases.
for(initialization; condition; increment/decrement)
{
  // lines of code here
}

   Here's an example code that prints all even numbers between 0 and 20.
#include <stdio.h>
int main()
{
 int i;

 for(i=0;i<=20;i=i+2)
 printf(" %d ", i);
 return 0;
}

   Of course, there are many tips and tricks related to 'for' loop, but we'll discuss them slowly and
   steadily in our future tutorials.

Conclusion
   Here, in this tutorial, we learned some good tips as well as new concepts. We'll be expanding upon
   these in tutorials to come. Until then, practice whatever we discussed here today, and drop in a
   comment in case you have any doubt or query.


---
https://www.howtoforge.com/c-programming-tutorial-part-7-arrays/

Linux C Programming Tutorial Part 7: Arrays

   So we have already discussed the concept of variables in C programming. To
   quickly refresh, a variable is something which can hold a value of a particular type - it could be an
   integer, character, or even floating point. However, there's one limitation of variables: they can
   only hold a single value at any given time.

   This means if you want to hold several values, you'll have to deal with equal number of variables.
   For example, if you want a program to accept 10 integer values from user and then output them, then
   either you'll write it in this way:
#include <stdio.h>
int main()
{
 int a=0,b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;
 printf("Enter 10 integer values\n");
 scanf("%d",&a);
 scanf("%d",&b);
 scanf("%d",&c);
 scanf("%d",&d);
 scanf("%d",&e);
 scanf("%d",&f);
 scanf("%d",&g);
 scanf("%d",&h);
 scanf("%d",&i);
 scanf("%d",&j);

 printf("You entered the following values:\n");
 printf("%d\n",a);
 printf("%d\n",b);
 printf("%d\n",c);
 printf("%d\n",d);
 printf("%d\n",e);
 printf("%d\n",f);
 printf("%d\n",g);
 printf("%d\n",h);
 printf("%d\n",i);
 printf("%d\n",j);

 return 0;
}

   Or in the following way:
#include <stdio.h>
int main()
{
 int a=0,b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;

 printf("Enter 10 integer values\n");
 scanf("%d %d %d %d %d %d %d %d %d %d",&a,&b,&c,&d,&e,&f,&g,&h,&i,&j);

 printf("You entered the following values:\n");
 printf("%d %d %d %d %d %d %d %d %d %d\n",a,b,c,d,e,f,g,h,i,j);

 return 0;
}

   The second approach may be slightly better if you compare in terms of lines of code written, but
   there's still a better way, and that is to use an integer array.

   Yes, if there's a requirement to hold multiple values of same type, then you should opt for an array.
   Here's how an integer array capable of holding 10 values is defined:
int arr[10]

   So here, 'int' refers to the type of values array 'arr' will store. The number 10 in square brackets
   tells the capacity of 'arr' is 10 values. Now, here's a piece of code using this array:
#include <stdio.h>
int main()
{
 int arr[10],i;

 printf("Enter 10 integer values\n");

 for(i=0;i<10;i++)
 scanf("%d",&(arr[i]));

 printf("You entered the following values:\n");

 for(i=0;i<10;i++)
 printf("%d\n",arr[i]);

 return 0;
}

   Note that we've already discussed scanf and printf functions in one of our earlier tutorials, so you
   can refer to those articles in case you want to know more about them.

   Coming back to arrays, you'd have observed the 'for' loop in the code above begins with i=0. That's
   because array subscripts (the number inside square brackets)  always start from zero. So here, in our
   case, arr[0] refers to the first value entered by the user, arr[1] refers to the second value, and so
   on until arr[9] which refers to the 10th value.

   It's also worth mentioning that you can easily access the memory address of each value stored in the
   array. This can be done using the array name, which is 'arr' in this case. So if you use just 'arr'
   in the code, then it's nothing but the memory address of the first element.

   Similarly, if you want to access the memory address of the second element, just use 'arr+1'. For
   third element, use 'arr+2', and so on and so forth. The following piece of code and its output should
   give you a better idea.
#include <stdio.h>
int main()
{
 int arr[10],i;

 printf("The address of first and second values are: %u %u\n", arr, arr+1);

 return 0;
}

   And here's the output:
The address of first and second values are: 2904035888 2904035892

   As you can see, there's a difference of 4 bytes in these addresses - that's because one integer value
   occupies 4 bytes on my system.

Conclusion
   Here, in this tutorial, we discussed the basics of arrays. Note that we only gave example of an
   integer array. You can have array of other types as well, like characters. Try out the examples we've
   used in this tutorial, and let us in know in the comments section below if you have any doubt or
   query.


---
https://www.howtoforge.com/c-programming-call-by-value-vs-call-by-pointer/

Linux C Programming Tutorial Part 8 - Call by Value Vs Call by Pointer/Address

   In our first part of this ongoing tutorial series, we discussed briefly about functions,
   including their declaration and body. What we didn't discuss at that time was the multiple ways in
   which functions are called. Here, in this tutorial, we will quickly discuss the ways that exist.

   In C language, you can call a function in a couple of ways: call by value and call by pointer or
   address. Let's discuss both these concepts with some easy to understand examples.

   Let's say you want to write a program that swaps two values. Here's how you can do it:
#include <stdio.h>
int main()
{
 int a=0, b=0, c=0;

 printf("Enter two integer values\n");

 scanf("%d %d",&a,&b);

 printf("Entered values are: %d and %d", a,b);
 c = a;
 a = b;
 b = c;

 printf("\nSwapped values are: %d and %d", a,b);

 return 0;
}

   Here's the output of this code with entered values as 5 and 9:
Enter two integer values
5 9
Entered values are: 5 and 9
Swapped values are: 9 and 5

   Now, suppose the requirement is to have a separate function - say 'swap' - which does all the
   swapping related work and can be called whenever the programmer wants to swap two values. Following
   is the code that does this:
#include <stdio.h>
void swap (int val1, int val2)
{
 int temp = 0;

 temp = val1;
 val1 = val2;
 val2 = temp;

 printf("\nSwapped values are: %d and %d", val1,val2);
}
int main()
{
 int a=0, b=0;

 printf("Enter two integer values\n");

 scanf("%d %d",&a,&b);

 printf("Entered values are: %d and %d", a,b);
 swap(a,b);
 return 0;
}

   So there you go. A separate function named 'swap' has been created that receives two values
   (originally entered by user and captured in 'main' function) as arguments and then swaps them and
   prints the output.

   The way 'swap' has been called here is known as 'call by value'. Reason being, when the call is made,
   only the values held by 'a' and 'b' are passed to the 'swap' function as arguments. These values are
   received by arguments 'val1' and 'val2', and it's these variables on which the swap process is
   performed.

   This means that variables 'a' and 'b' in the 'main' function continue to hold original values even
   after the swap operation has been performed. But what if the requirement is to have values of 'a' and
   'b' swapped after calling the 'swap' function? Well, this is where the 'call by pointer/address'
   method comes into picture.

   So basically what we do here is, we pass the address of variables (like 'a' and 'b' in our case) as
   arguments. The functionwhich is called ('swap' in this case) is equipped to receive addresses as
   arguments and then the swap process is done on the values kept at these addresses, which effectively
   means values of original variables ('a' and 'b' here) get swapped.

   Now, in the previous paragraph, we said the function "is equipped to receive addresses as arguments."
   Well, by "equipped," we meant it has special type of arguments that can receive addresses. These
   arguments are 'pointer' type variables. We will discuss 'pointers' in detail in an upcoming tutorial,
   but for now, just keep in mind that pointer variables store memory addresses as values.

   Here's how a pointer to an integer is declared/defined:
int *x;

   So basically, x is a pointer variable that can be used to store memory address of an integer
   variable. Suppose 'i' is an integer variable, then here's how you can make 'x' store the address of
   'i':
x = &i;

   And whenever you want to access the value of 'i' through 'x', you write '*x'. For example, here's how
   you can change the value of 'i' to, say, 10:
*x = 10;

   So with all this in mind, here's how you can call 'swap' using the call by address or pointer method:
#include <stdio.h>
void swap (int *val1, int *val2)
{
 int temp = 0;

 temp = *val1;
 *val1 = *val2;
 *val2 = temp;

}
int main()
{
 int a=0, b=0, c=0;

 printf("Enter two integer values\n");

 scanf("%d %d",&a,&b);

 printf("Entered values are: %d and %d", a,b);
 swap(&a,&b);

 printf("\nSwapped values are: %d and %d", a,b);
 return 0;
}

   So this time, instead of passing values of 'a' and 'b' as arguments, we passed the addresses of these
   variables. In 'swap' function, the addresses are received in two pointer variables ('val1' and
   'val2'). And using the two pointer variables, the logic directly swaps values of 'a' and 'b'.

   Here's the output:
Enter two integer values
6 8
Entered values are: 6 and 8
Swapped values are: 8 and 6

Conclusion
   This article should've given you at least a basic idea of what 'call by value' and 'call by
   address/pointer' ways of function calling are, and when they can be used. Try out the examples we've
   listed here and let us know in comments below if you have any doubt or query.


---
https://www.howtoforge.com/c-programming-tutorial-part-9-strings/

Linux C Programming Tutorial Part 9 : Strings

   In this ongoing C programming tutorial series, we have already touched upon the concept of
   character arrays. Closely related to character arrays is the concept of strings, which we'll be
   discussing here.

   A string differs from a character array in one major area - it is terminated by a Null character
   '\0'. There is no such terminating character in a charcter array. The following piece of code shows
   some ways in which a string can be defined:
#include <stdio.h>
int main()
{
 char str[] = "string";
 char str1[] = {'s','t','r','i','n','g','\0'};
 char str2[10] = "string";
 char str3[10] = {'s','t','r','i','n','g','\0'};
 char *str4 = "string";
 printf("\n str=%s, str1=%s, str2=%s, str3=%s, and str4=%s", str, str1, str2, str3, str4);
 return 0;
}

   So, a bunch of characters in double quotes is a string (terminating Null character is implicit
   there), and a series of characters explicitly ending with a \0 character is also a string.

   The output of this program is:
 str=string, str1=string, str2=string, str3=string, and str4=string

   Keep in mind you can't print non-string character arrays this way, as there is no terminating Null
   charcter there to signify end of the array. Here's a piece of code that tries to do this:
#include <stdio.h>
int main()
{
 char str[] = {'e','n','d'};
 char c ='t';
 printf("\n str=%s", str);
 return 0;
}

   But ends up printing garbage values at the end instead:
str=end??

   Moving on, just like the %s format specifier in 'Printf' tells compiler to treat input variables as
   strings, you can also use %s in 'scanf' function to accept strings as input from user. Here's an
   example:
#include <stdio.h>
int main()
{
 char str[30];

 printf("\n Enter a string with length less than 30 characters: ");
 scanf("%s",str);
 printf("\n str=%s", str);
 return 0;
}

   It's worth mentioning that a sequence of zero or more character surrounded by double quotes is called
   a string constant, or string literal. This means both "howtoforge" and "" are string constants or
   string literals.

   You can find length of a string using the standard strlen() function. Here's an example:
#include <stdio.h>
int main()
{
 char str[] = "howtoforge";
 printf("\n Length of string 'howtoforge' is: %d", strlen(str));
 return 0;
}

   The output produced by this program is 10, which is exactly the number of characters in 'howtoforge',
   and hence its length.

   Moving on, it's worth keeping in mind that a character in single quotes (like 'd') and a character in
   double quotes (like "d") are different from each other.  While the first one is a character constant
   (which can be used to produce numeric value of the character in the machine's character set), the
   second one is a string (meaning there's a terminating \0 character in it).

   Finally, let's quickly take a look at how strings can be passed as arguments to functions.
#include <stdio.h>
void change_value(char s[])
{
 s[0] = 'H';
 s[5] = 'F';

 printf("%s", s);

}
int main()
{
 char str[] = "howtoforge";
 change_value(str);
 return 0;
}

   So in the program above, it's the name of the array 'str' that's passed as argument because it refers
   to the base address of the array. The declaration for function 'change_value' is such that it expects
   an array as input. Here's the output of this program:
HowtoForge

Conclusion
   So in this tutorial, we discussed the basics of strings, including how they are defined and how they
   can be used. We'll learn more about strings in tutorials to come but this article should be enough to
   get you started. Let us know in comments below if you have any query or doubt related to strings.


---
https://www.howtoforge.com/c-programming-tutorial-part-9-variable-scopes/

Linux C Programming Tutorial Part 10 - Variable Scopes

   If you are following our C programming tutorial series, you should be aware of the concept of
   variables. While we've discussed the basics of variables, there's another important aspect related to
   variables that we'll be discussing here: scope of variables.

   Let's start with the swapping values code that we used in one of our previous tutorials:
#include <stdio.h>
void swap (int val1, int val2)
{
 int temp = 0;

 temp = val1;
 val1 = val2;
 val2 = temp;

 printf("\nSwapped values are: %d and %d", val1,val2);
}
int main()
{
 int a=0, b=0;

 printf("Enter two integer values\n");

 scanf("%d %d",&a,&b);

 printf("Entered values are: %d and %d", a,b);
 swap(a,b);
 return 0;
}

   Here, in this piece of code, variables 'val1' and 'val2' have local scope, meaning they come to life
   when the function 'swap' gets called and they die as soon as the call to 'swap' is over. You just
   can't access 'val1' and 'val2' before or after the call to function 'swap'. Similarly, scope of
   variables 'a' and 'b' is also local - local to function 'main'.

   Note that these local scope variables are also known as automatic variables.

   Now, while variables with local scope are limited to the block in which they are declared, there is
   another type of variables whose scope is global. As the name suggests, global scope variables can be
   used across functions. For example, the variable 'var' is a global integer variable, and can be used
   in both 'main' and 'swap' functions.
#include <stdio.h>
int var;
void swap (int val1, int val2)
{
 int temp = 0;

 temp = val1;
 val1 = val2;
 val2 = temp;

 printf("\nSwapped values are: %d and %d", val1,val2);
}
int main()
{
 int a=0, b=0;

 printf("Enter two integer values\n");

 scanf("%d %d",&a,&b);

 printf("Entered values are: %d and %d", a,b);
 swap(a,b);
 return 0;
}

   By default, the value '0' is assigned to global variables. But that's not the case with local
   variables - you need to assign a value to them when they are defined, otherwise they hold a garbage
   value. For example, in the following program:
#include <stdio.h>
int var;
int main()
{
 int a;

 printf("Local variable 'a' currently holds: %d", a);

 printf("\n Global variable var currently holds: %d", var);
 return 0;
}

   There are high chances that you'll get a non-zero value for 'a'. 'var' on the other hand, will always
   be zero in the beginning.

   Moving on, can there be global and local variables of same name? Well, the answer is yes. Ok, then
   what will the following piece of code produce in output:
#include <stdio.h>
int var = 5;
int main()
{
 int var = 10;

 printf("Local variable 'a' currently holds: %d", var);

 printf("\n Global variable var currently holds: %d", var);
 return 0;
}

   Well, the output will be '10' in both cases. Reason being, the local variable 'var' will override the
   global 'var'. So now the next logical question is, how to access the global 'var' inside 'main' in
   this case? Sadly, the answer is NO. In fact, you should avoid getting into situations like these when
   working with C language.

   Next comes the concept of 'extern' variables. In layman's term, by using the keyword 'extern' with
   any variable declaration, you're telling the compiler that this variable is already declared/defined
   somewhere else and we're just using it here. For example, in the following piece of code, the
   compiler doesn't know that 'var' exists when it tries to compile the printf statement inside the main
   function.
#include <stdio.h>
int main()
{
 printf("\n Global variable var currently holds: %d", var);
 return 0;
}
int var = 5;

   That's why you get an error like the following during compilation:
main.c: In function 'main':
main.c:14:58: error: 'var' undeclared (first use in this function)
 printf("\n Global variable var currently holds: %d", var);
 ^
main.c:14:58: note: each undeclared identifier is reported only once for each function it appears in

   But if you declare 'var' as extern here, you'll see everything works fine. That's because the
   compiler gets to the original 'var' declaration eventually.
#include <stdio.h>
int main()
{
 extern int var;

 printf("\n Global variable var currently holds: %d", var);
 return 0;
}
int var = 5;

   And you get the correct output:
Global variable var currently holds: 5

   So this is how extern works. Extern variables are often used when your program/project is split over
   multiple source code files and you want to, say, use in 'file1', a variable defined in 'file2'.

   And finally, as we are discussing variable scopes, it'd be better if we discuss 'static' variables
   here as well. Static variables are special in the sense they retain their value even after going out
   of scope. This means they are initialized only once, which is the first time.
static int counter

   Following is a piece of code that uses a static variable to count the number of times a function gets
   called.
#include <stdio.h>
int swap (int val1, int val2)
{
 static int counter = 1;
 int temp = 0;

 temp = val1;
 val1 = val2;
 val2 = temp;

 printf("\n Function called %d times\n", counter);
 counter++;
}
int main()
{
 int a=9, b=4;

 swap(a,b);
 swap(a,b);
 swap(a,b);
 return 0;
}

   Here's the output:
 Function called 1 times

 Function called 2 times

 Function called 3 times

   So you can see, the variable 'counter' retained its value even after going out of scope. Just like
   global variables, static variables also have a default value of '0'.

Conclusion
   In this tutorial, we discussed several important concepts, all related to scope of variables in the C
   programming language. Don't forget to create your own programs to better understand the difference
   between extern, static, global, and local variables. And as always, in case of any doubt or query,
   drop in a comment below.


---
https://www.howtoforge.com/c-programming-tutorial-part-11-arithmetic-relational-and-logical-operators/

Linux C Programming Tutorial Part 11 - Arithmetic, Relational, and Logical operators

   Up until now, in this C programming tutorial series, we have discussed basic things like
   functions, arrays, variables, and more. Continuing with the flow, in this tutorial, we will discuss
   another such basic concept: operators.

   As a beginner in C programming language, you'll majorly deal with three kinds of operators:
   arithmetic, relational, and logical. Let's begin with the airthmetic operators.

   There are essentially 5 types of arithmetic operators in C: +, -, *, /, and %. While +, -, and / are
   self-explanatory, * refers to multiplication and % is modulus operator. In case you aren't aware, the
   % operator gives you a remainder. For example:
a % b

   Here, the % operator makes sure you get the remainder value when 'a' is divided by 'b.' This means
   the remainder can be zero in cases 'a' is completely divisible by 'b'. Here's a small example that
   should give you better clarity on these operators:
#include <stdio.h>
int main()
{
 int a = 10, b = 3, c =0;
 c = a + b;
 printf("%d\n", c);

 c = a - b;
 printf("%d\n", c);

 c = a*b;
 printf("%d\n", c);
 c = a/b;
 printf("%d\n", c);

 c = a%b;
 printf("%d\n", c);

 return 0;
}

   Following is the output of this program:
13
7
30
3
1

   It's worth mentioning here that when dealing with floats and doubles, you should not use the %
   operator.  Also, the + and - operators we've used here are binary operators, meaning they require two
   operands (for example, 'a' and 'b' in our case). There are also unary + and - operators, which work
   on a single operand.

   Here's an example of the unary - operator in action:
#include <stdio.h>
int main()
{
 int a = 10, b = 3, c =0;
 c = -a;
 printf("c = %d", c);
}

   Here's the output:
c = -10

   Among all operators discussed so far, precedence wise, unary + and - share the top spot, followed
   by *, / and %, that are in turn followed by binary + and -.

   Please note that there are some other unary operators as well, some of which we have already
   discussed indirectly in our previous tutorials. Here's the list: ++, --, !, &, and sizeof.

   We've already discussed the increment and decrement operators ++ and -- (in both prefix and postfix
   forms). ! is NOT operator which negates anything on which it is applied. For example, if the outcome
   of a condition is true, applying ! will convert it into false, and vice versa.

   Moving on, & is used to fetch address of a variable (as already seen in case of scanf() function
   arguments), while sizeof operator gives you size of the operand passed to it. The following piece of
   code should give you a better idea about these operators:
#include <stdio.h>
int main()
{
 int a = 10, b = 3, c =0, d =1, e=0, f=9;

 printf("a = 10 and a++ = %d\n", a++);

 printf("b = 3 and ++b = %d\n", ++b);

 printf("c = 0 and c-- = %d\n", c--);

 printf("d = 1 and --d = %d\n", --d);

 if(!e)
 {
 printf("\n e is zero or FALSE and its address is: %u\n", &e);
 printf("\n sizeof 'f' is: %u\n", sizeof(f));
 }


 return 0;
}

   And here's the output:
a = 10 and a++ = 10
b = 3 and ++b = 4
c = 0 and c-- = 0
d = 1 and --d = 0

 e is zero or FALSE and its address is: 856178696

 sizeof 'f' is: 4

   Moving on, let's quickly take a look at relational and logical operators. Following are relational
   operators:
> >= < <= == !=

   Here are how they can be used:
a > b
a >= b
a < b
a <= b
a == b
a != b

   In order of their appearance above, these operators check whether 'a' is greater, greater than or
   equal to, less than, less than or equal to, equal, and not equal to 'b'. The first four operators
   have the same precedence, which is higher than the last two. Note that the last two operators are
   also called equality operators.

   And finally, coming to logical operators. There are essentially two: && and ||. Both these operators
   are mostly used to evaluate conditions or expressions. For example:
if (cond1 && cond2)
{
}
if (expr1 && expr2)
{
}
if (cond1 || cond2)
{
}
if (expr1 || expr2)
{
}

   In case of the first two if statements, the execution will only enter the block if both conditions
   are true. Whereas in case of last two if statements, the execution will enter the block if any of the
   condition of expression is true.

   Keep in mind that relational operators have lower precedence than arithmetic operators, and that of
   logical operators is lower than relational and equality operators. Among themselves, && has higher
   precedence than ||.

Conclusion
   In this tutorial, we discussed the basics of operators, how they work and their precedence. It's
   suggested you create some sample C programs to test out the concepts discussed here. In case of any
   doubt or query, let us know in comments below.


---
https://www.howtoforge.com/c-programming-assignment-operators/

Linux C Programming Tutorial Part 12 - Assignment Operators and Conditional Expressions

   In this ongoing C programming tutorial series, we have already discussed some of the basic stuff
   like arithmetic, logical, and relational operators as well as conditional loops like 'if' and
   'while'. Adding upon that, this tutorial will focus on assignment operators (other than =) and
   conditional expressions.

   Let's start with assignment operators. If you have created basic C programs until now (which I am
   sure you would have especially after following our tutorial series), there are high chances you'd
   have done something similar to the following:
a = a + 1;

   Right?

   The new thing we're going to learn today is that you can rewrite this expression as the following:
a += 1;

   Yes, the  += is an operator and is also called an assignment operator.

   Now, if I say using assignment operators like these makes the code more compact and readable, some of
   you may argue that in context of the example we used, an increment operator would have been equally
   good as that also makes sure the value of 'a' gets increased by 1.
a++;

   I agree, but think of other scenarios like the following:
b = b + 10;
b = b + c

   In these cases, using the assignment operator definitely makes the code writing, reading, and
   reviewing one step easy.

   Still not convinced? Perhaps, the following generic example will give you an even better idea on the
   value of assignment operators. Take a look:
arr1[arr2[integer1 + integer2] + arr3[integer3 + integer4] + arr4 [integer5 + integer6]] = arr1[arr2[integer1
+ integer2] + arr3[integer3 + integer4] + arr4 [integer5 + integer6]] + 5

   This line of code takes time to be understood specifically because you have to make sure the two
   arrays (on each side of the = operator) refer to the same value or not. In this case, they do, so a
   better way would be to use an assignment operator in the following way:
arr1[arr2[integer1 + integer2] + arr3[integer3 + integer4] + arr4 [integer5 + integer6]] += 5;

   So, using an assignment operator in this case not only made the line very easy to understand but also
   made it more compiler friendly in the sense that it may help compiler produce efficient code.

   Now that you are convinced (I really hope you do) about the fact that assignment operators are
   useful, here's a list of operators that have a corresponding binary operator:
+ - * / % << >> & ^ |

   The first five operators in the list we've already discussed in our tutorials so far. The last five
   are bitwise operators, and we'll be discussing them in one of our upcoming tutorials. Meanwhile,
   here's a quick reference to assignment operators corresponding to some of these operators:
a += b;
a -= b;
a *= b;
a /= b;
a %= b;

   So in general, you can keep in mind that the following:
expression1 = (expression1) op (expression2)

   can be expressed as:
expression1 op= expression2

   where 'op' is the operator in use, like +, -, *, and more.

   Please note that the following expression as well as expressions similar to it:
a *= b - c

   will expand as:
a = a * (b-c)

   I hope I was able to make the concept of assignment operators clear at least on the basic level.
   Moving on, now let's quickly discuss conditional expressions.

   Take the following example:
if(a==b)
  c = c + 1;
else
  c = c - 1;

   Conditional expressions help you write logics like these in a single line. Here's how:
c = (a==b) ? (c+1) : (c -1)

   So here, first the condition (a==b) is checked. If it's true, then (c+1) is assigned to c, else (c-1)
   is assigned to c. Here's a sample code to make things more clear:
int main()
{
 int a = 6, b = 5, c = 9;

 c = (a==b) ? (c+1) : (c -1) ;
 printf("\n %d \n", c);
 return 0;
}

   Since a is not equal to b here, so c is assigned (c-1), which means the new value of c becomes 8.
   Just in case you need, here's the generic form of conditional expressions:
expression1 ? expression2 : expression3

Conclusion
   I hope you got a basic idea about assignment operators and conditional expressions. You are now
   encouraged to use these in your day to day coding activities, and if you run into any kind of issue,
   don't forget to leave us a comment here.


---
https://www.howtoforge.com/c-programming-bitwise-operators/

Linux C Programming Tutorial Part 13 - Bitwise Operators (Basics)

   Up until now in this ongoing C programming tutorial series, we have discussed multiple kinds of
   operators, like arithmetic, logical, relational, and assignment. However, there's another kind of
   operators that are very integral to the C programming language. We are talking about bitwise
   operators.

   As you might already know by now, every variable you use in your C program is stored in the form of
   bytes in memory. Further, these bytes are divided into 8 bits each. A bit can either be 1 or 0. For
   example, if a is a short integer (which occupies two bytes) with value 1, then on memory level,
   here's how a is represented:
00000000 00000001

   Similarly, if b is 3, then here's how it's represented in memory:
00000000 00000011

   The Bitwise operators which we're about to discuss here work on these bits. Let's start with the
   bitwise AND operator, which is represented by &. It takes two equal-length binary representations and
   performs a logical AND operation on corresponding bits.

   In logical AND operation, only when both corresponding bits are 1, the result is 1. Else, the result
   is 0. So if you do the following:
a & b

   Where 'a' is 1 and 'b' is 3 (as described in the beginning of this tutorial), then the operation
   yields the following result:
00000000 00000001

   This is because if you logically AND the bit representations of 'a' and 'b', only the rightmost bit
   remains '1' and all other bits become '0'.  In integer (or more precisely, decimal) form, this bits
   representation turns out to be '1'.

   Here's the code for this operation:
#include <stdio.h>
int main()
{
 short a = 1;
 short b = 3;
 printf("a & b = %i", a&b);
 return 0;
}

   And here's the output of this code:
a & b = 1

   Just like &, there are other bitwise operators. Here's the complete list:
&  - AND
|  - inclusive OR
^  - exclusive OR
<< - left shift
>> - right shift
~  - one's complement or NOT

   The OR operator (|) performs logical inclusive OR operation on corresponding bits of its operands -
   if any of the bits is 1, the resulting bit is also 1, else the resulting bit is 0. The exclusive OR
   (or XOR) operator works pretty much like the OR operator, just that the resulting bit is 0 if both
   bits are 0 or 1.

   The left shift operator shifts the bits number of times specified by the second operand. For example,
   the following line makes sure the bits of 'a' get shifted to the left 3 times.
a << 3

   If 'a' was short integer with value 1, then it's bit representation was something like:
00000000 00000001

   But after the left shift operation, it's bit representation became:
00000000 00001000

   So you can see, every bit shifted 3 times, bringing bit with value '1' to the fourth position (and
   filling vacant bit positions with '0's). So now, the decimal value of 'a' becomes 8.

   On the same lines, the right shift operator (>>) shifts the bits to right. Lastly, the one's
   complement or NOT operator - which is the only unary operator in this list - inverses all the
   bits (or performs logical negation on each bit) of the operand. For example, if 'a' is a one byte
   variable, and is represented in the following way in memory:
11111110

   Then, ~a will make it:
00000001

   Note that bitwise operators can only be applied to char, short, int, and long variables (both signed
   and unsigned).

Conclusion
   I hope I was able to make the basic concept of bitwise operators clear. Of course, there are some
   scenarios like applying shift operators on signed values as well as practical examples of bitwise
   operators that we didn't cover here. But those will definitely be covered in an upcoming tutorial.


---
https://www.howtoforge.com/linux-c-programming-14-bitwise-operator-examples/

Linux C Programming Tutorial Part 14 - Bitwise operators practical examples

   In one of our earlier articles, we discussed the basics of bitwise operators. I hope you went
   through that article and are now ready to witness and understand some practical usage examples of
   these operators. So without further ado, let's begin.

1. Swap values of two variables
   I am sure you'd aware of the logic to swap values of two variables. It involves taking a third
   variable to temporarily store one value and then assign that value to one of the variables (whose
   original value has already been assigned to the other variable).

   For example, if 'a' and 'b' are variables whose values need to be swapped, and 'c' is the temporary
   variable, then here's how the standard logic goes:
c = a;
a = b;
b = c;

   But did you know this whole swapping process can be done through bitwise operators? Yes, that's true,
   and the logic, in that case, doesn't even require a third variable. Here's the code:
#include <stdio.h>
int main()
{
 int a, b;

 printf("Enter first number: ");
 scanf("%d", &a);

 printf("Enter second number: ");
 scanf("%d", &b);

 printf("As per your input, a = %d, and b = %d", a,b);

 a = a ^ b;
 b = a ^ b;
 a = a ^ b;

 printf("\nAfter swapping, a = %d, and b = %d", a,b);
 return 0;
}

   Here's the output:
Enter first number: 7
Enter second number: 2
As per your input, a = 7, and b = 2
After swapping, a = 2, and b = 7

2. Check number of binary '1's in a number
   Sometimes you may find yourself in a situation wherein you need to count the number of bits set to
   '1' in a number. You'll be glad to know you can easily do this using bitwise operators. Here's the
   logic:
#include <stdio.h>
int main()
{
 int a, num_of_bits = 0;

 printf("Enter a number: ");
 scanf("%d", &a);
 while(a)
 {
 if(a & 1)
 num_of_bits++;

 a = a >> 1;
 }

 printf("\nNumber of binary 1s in this number is %d", num_of_bits);

 return 0;
}

   Here's the output:
Enter a number: 5

Number of binary 1s in this number is 2

3. C program to check if given bit position is 1 or not
   Sometimes, especially when working on a code that's related to computer networking (protocols etc),
   you are required to check whether or not a particular bit position is set to 1 or not. This can
   easily be done using bitwise operators.

   Here's the code:
 #include <stdio.h>
int main()
{
 int num, position, temp;

 printf("Enter a number: ");
 scanf("%d", &num);

 printf("Enter the bit position (keeping zero as base index and 31 as max): ");
 scanf("%d", &position);
 if(((num>>position)&1) == 1)
 printf("\nBit at the position is 1");
 else
 printf("\nBit at the position is 0");

 return 0;
}

   Here's the output:
Enter a number: 2
Enter the bit position (keeping zero as base index and 31 as max): 3

Bit at the position is 0

   4. Convert decimal number to its binary form
   Bitwise operators can also be used to convert a decimal number to its binary form. Here's one logic
   for it:
#include <stdio.h>
int main()
{
 int num, i = 0, temp = 0;
 int bin[32] = {0}; // this will initialize all array elements to 0
 /* Input number from user */
 printf("Enter any number: ");
 scanf("%d", &num);
 for(i =31; i>=0; i--)
 {
   if((num & 1) == 1)
   {
      bin[i] = 1;

   num = num>>1;
 }
 printf("The binary form of the number you entered is: ");

 for(i=0; i<32; i++)
 {
    printf("%d",bin[i]);
 }
 return 0;
}

   Here was the output in my case:
Enter any number: 15
The binary form of the number you entered is: 00000000000000000000000000001111

Conclusion
   The four examples we've shown here should be enough to give you a good idea on how bitwise operators
   can be used in real-world scenarios. Try these out on your machines, tweak them, and make them do
   more, or something new. In case of any doubt or query, drop a comment here.


---
https://www.howtoforge.com/c-programming-15-complement-negative-numbers/

Linux C Programming Tutorial Part 15 - 2's Complement and Negative numbers

   Up until now, in this ongoing C programming tutorial series, we have discussed quite a few
   concepts, but missed a basic one. It's about negative numbers. Yeah, though we briefly mentioned
   signed vs unsigned variables in one of our initial tutorials, we didn't actually discuss how negative
   numbers are stored in memory.

   Well, that's exactly what will be discussed in this tutorial. So without further ado, let's start
   with the discussion.

2's complement
   Before we begin with the explanation on negative numbers representation in memory, it's important we
   know the concept of 1's and 2's complement, both of which are binary level operations.

   Let's take a very simple example. Suppose you have a 4 byte integer 'a' with decimal value 15. Then
   here's how it is represented in binary form memory:
00000000 00000000 00000000 00001111

   Now, to calculate the one's complement, just invert all the bits. So following is the 1's complement
   representation of 15:
11111111 11111111 11111111 11110000

   Now, if you add 1 to the above binary representation, you get the 2's complement.
11111111 11111111 11111111 11110001

   So the above representation is the two's complement of 15.

Negative numbers
   Now, some of you must be thinking why we discussed 1's and 2's complement? Well, the answer lies in
   the fact that the binary representation of a negative number is calculated through 2's complement.

   Hard to believe? Here's the proof:

   The 2's complement we calculated in the previous section can be represented in hexadecimal form as
   0xFFFFFFF1. Now, let's see what this value is in decimal form through a C program

   Here's the code:
#include <stdio.h>
int main()
{
 int a = 0xFFFFFFF1;
 printf("a = %d", a);
 return 0;
}

   And the following is the output:
a = -15

   Believe it now? We started with a number '15', calculated its 2's complement, and when we converted
   the two's complement value again into decimal, we found it's -15.

   Moving on, now let's slightly tweak the code to make sure the printf call reads the value of variable
   'a' as as an unsigned integer.
#include <stdio.h>
int main()
{
 int a = 0xFFFFFFF1;
 printf("a = %u", a);
 return 0;
}

    Here's the output now:
a = 4294967281

   Oops, the output changed, and now it's a huge positive value. But why this happened? Isn't 0xFFFFFFF1
   the 2's complement of 15 as we saw earlier?

   Yes, 0xFFFFFFF1 is two's complement of 15, but if you don't look it from that perspective, it is also
   a normal value (4294967281). The difference lies in how it is read. If it is read as a signed integer
   (through %d in printf), you'll see the output as -15, but if it is read as an unsigned integer
   (through %u in printf), you'll see the output as 4294967281.

   As a rule of thumb with signed variables (which deal with both negative and positive values), keep in
   mind that binary representation of negative numbers always has '1' as the leftmost bit, while in case
   of positive numbers the bit in question is always 0.

   Finally, note that you can also reverse a two's complement representation to get its positive
   counterpart. As an example, let's again take the 0xFFFFFFF1 value, which is hex representation of
   -15. It is represented in binary form as:
11111111 11111111 11111111 11110001

   Now, to get its positive counterpart, just perform a 2's complement again. Which means, first do a
   1's complement:
00000000 00000000 00000000 00001110

   And then add 1
00000000 00000000 00000000 00001111

   Now, if you convert this, you'll get value 15 in decimal form.

Conclusion
   I hope this tutorial helped you understand the concept of negative numbers in context of how they are
   represented in memory. I suggest you try out the examples we used in this tutorial, and in case you
   encounter any problem, or you have any doubt or query, drop us a comment below.


---
https://www.howtoforge.com/c-programming-16-switch-break-and-continue-statements/

Linux C Programming Tutorial Part 16: Switch, Break, and Continue statements

   We've already discussed some of the basic loops used in the C programming language, including
   for, while, and do...while. These loops, as most of you'd agree, basically help you when instructions
   are to be executed repeatedly under one or more conditions. So you write less code while making it
   more readable in the process.

   Just like these loops, there are some statements that help you write better code in C. Some of those
   statements are Switch, Break, Continue, and Goto. Let's discuss them one by one.

Switch statement
   Switch is basically a statement that accepts a value, based on which it executes a piece of code.
   It's a control statement as in it changes the control of execution based on the input value.

   Here's the structure of switch:
...
...
...
switch (expression)
{
   case const_val_1: //some code
                     break;
   case const_val_2: //some code
                     break;
   case const_val_3: //some code
                     break;
   default:          //some code
                     break;
 }
...
...
...

   So here, 'expression' is a value that's passed as input to 'switch' statement, and based on the case
   which matches 'expression' value, the corresponding code is executed. Following is a working example
   where-in switch makes the code less complex and improves readability.
#include <stdio.h>
int main()
{
 int roll;
 printf("Enter a roll number in range of 1 - 5: ");
 scanf("%d", &roll);

 switch(roll)
 {
     case 1: printf("name of student is RON");
             break;
     case 2: printf("name of student is ROGER");
             break;
     case 3: printf("name of student is SAM");
             break;
     case 4: printf("name of student is LUCIE");
             break;
     case 5: printf("name of student is DORN");
             break;
     default: printf("Entered roll number didn't match any candidate");
             break;
 }
 return 0;
}

   So here, the roll number that's entered by user in input is fed to the switch statement, and the code
   corresponding to the case that matches is executed.

   Note that the 'break' statement at the end of each case makes sure the switch statement is exited
   after the matched case is executed. If no 'break' statement is present, the execution flow enters the
   next case.

   The 'default' case is there to make sure user gets notified if no case matches the value in switch.
   Having a 'default' case is not mandatory, but it is always useful.

   Also, since the default case is usually the last case in the switch statement, having 'break' at the
   end of it is also not mandatory, but is encouraged as it is considered defensive programming (just in
   case more cases get added in future after the 'default' case).

Break and Continue
   Note that in addition to 'switch', the 'break' statement can also be used to perform an early exit
   from loops like for, while, and do...while.
...
...
...
for(i=0; i<10; i++)
{
   //statements
    if(condition)
        break;

   //statements
}
...
...
...

   Now coming to 'continue', just like 'break' causes an early exit from a loop, 'continue' forces the
   next iteration of the loop, which in case of while and do...while starts with condition check and in
   case of a 'for' loop is the increment step.

   Here's an example that uses 'continue' to skip odd numbers inside a for loop:
...
...
...
for(i=0; i<100; i++)
{
    if(i%2)
        continue;

    //statements
}
...
...
...

   Note that you can't use 'continue' inside switch, except for the cases when 'switch' itself is part
   of a loop.

Conclusion
   In this tutorial, we discussed break, continue, and switch statements. Do try out the examples or
   demo code we shared in this tutorial on your system to get a better hang of these concepts. In case
   of any doubt or query, let us know in comments below.


---
https://www.howtoforge.com/c-programming-17-variable-initialization/

Linux C Programming Tutorial Part 17: Variable Initialization

   Initialization of variables is something which we have been doing throughout this ongoing C
   programming tutorial series so far, but we never really discussed it explicitly. Well, that changes
   now as we'll be discussing variable initialize in a bit of detail here.

   So what exactly is initialization? Well, as the name suggests, when a value gets assigned to a
   variable for the first time, that is known as variable initialization. For example:
int a = 1;

   Now, this is also known as explicit initialization. Reason being, even if you don't assign a value to
   a variable like 'a', and try to print the variable's value, you'll see some random value.

   For example, consider the following code:
#include <stdio.h>
int main()
{
 int a;
 printf("a = %d", a);
 return 0;
}

   When I executed this code, I got 'a' as '0'. But this will not always be true because automatic
   variables like 'a' are initialized to random values in the absence of explicit initialization. That's
   the reason it's always suggested to explicitly initialize them with a value, say '0', in order to
   avoid a garbage value being used mistakenly.

   Note that it's only automatic variables that get garbage value if left uninitialized. Static and
   global variables get '0' as their initial value even if you don't explicitly assign a value. Here's
   an example:
int x;
void func();
{
 static int b;

 //statements
 b++;
}
int main()
{
 int a;
 //statements

 func();
 return 0;
}

   In the code above, it's guaranteed that variables 'x' and 'b' will be initialized to '0', but there
   is no guarantee of what value the variable 'a' will contain.

   Moving on, you can only initialize static and global variables with constant values. In other words,
   it's not possible to assign values to static and global variables in terms of other variables.

   Here's an example:
#include <stdio.h>
int k;
int x = k;
void func()
{
 int z = 2;

 static int b = z;
 b++;
}
int main()
{
 int a;
 printf("a = %d", a);

 func();
 return 0;
}

   When I compiled this code, I got the following errors:
main.c:12:9: error: initializer element is not constant
 int x = k;
         ^
main.c: In function 'func':
main.c:18:20: error: initializer element is not constant
     static int b = z;
                    ^

   As 'x' is global and 'b' is static, you can see the compiler clearly says the initializer elements is
   not constant. So this reaffirms the fact that only constants can be used to initialize global and
   static variables.

   Moving on, arrays can be also initialized in different ways. For example, one way is to initialize
   is:
int arr[] = {1,2,3,4,5};

   This way, the size of the array is calculated by counting the number of initializer elements. So in
   this example, array 'arr' has a size of 5, with values 1-5 as its elements (in that order).

   Next, let's say the size of array is predefined, and you initialize the array using the method above.
   Here's an example:
int arr[5] = {1,2,3,4};

   Then, in this case, the first four elements will be picked up from the list provided within {}, and
   the final element will be '0'. So yes, you can provide fewer elements than the size of the array in
   this manner, and let the compiler take care of the rest by initializing them with '0'.

   For example, the following program:
#include <stdio.h>
int main()
{
 int arr[10] = {1,2,3,4,5};
 int i = 0;

 for(i=0;i<10;i++)
 printf("%d ", arr[i]);
 return 0;
}

   produces the following output:
1 2 3 4 5 0 0 0 0 0

Conclusion
   In this tutorial, we discussed a bit about initialization of variables. I'd encourage you to try out
   the examples as well as concepts discussed here. In case you have any doubt or query, you're welcome
   to drop in a comment below.


---
https://www.howtoforge.com/c-programming-tutorial-part-18-recursive-functions/

Linux C Programming Tutorial Part 18: Recursive functions

   Irrespective of the programming language you use, as you start coding more and more, you get to learn
   concepts that make your code crisp and easy to read/understand. There are several such concepts in
   the C as well. One of them is 'recursive functions,' which we'll be discussing here in this article.

   A recursive function is a function that calls itself. The call can be made directly from within the
   function's body, or indirectly from within some other function which gets called by the function in
   question.

   Following is an example of direct recursion:
int func (int a)
{
    //statements
    func(a-1);
    // statements
    return 0;
}

   And here's an example of indirect recursion:
int func (int a)
{
    //statements
    func_new(a);
    // statements
    return 0;
}
int func_new(int b)
{
    //statements
    func(b-1);
    //statementsur
    return 0;
}

   As already mentioned in the beginning, recursion helps you achieve compact code, one that's not only
   easy to write but easy to understand and review as well. Let's take an example to make this advantage
   more clear.

   I am sure you all must have heard about the concept of factorial. For those who aren't aware,
   factorial is the result you get when you multiply an integer with all the positive integers less than
   it. For example, the factorial of 5 is 5x4x3x2x1, which is equal to 120.

   Here's a simple code to find the factorial of a number:
#include <stdio.h>
int main()
{
 int a = 0, i = 0, fact = 1;
 printf("Enter a number: ");
 scanf("%d", &a);

 for(i=1; i<=a; i++)
 {
 fact = fact * i;

 }
 printf("Factorial of the number is: %d ", fact);
 return 0;
}

   Note that this code is just to let you know how factorial of a number can be calculated through a C
   program. The program doesn't take care of corner cases that may affect the accuracy of result it
   produces.

   So this is one of the many ways in which you can calculate factorial of a number without using a
   recursive function. Now let's see a piece of code that uses recursion to calculate a factorial.
#include <stdio.h>
int factorial (int b)
{
 if(!b)
 return 1;

 return (b * factorial(b-1));
}
int main()
{
 int a = 0, fact = 1;
 printf("Enter a number: ");
 scanf("%d", &a);

 fact = factorial(a);

 printf("Factorial of the number is: %d ", fact);
 return 0;
}

   So you can see, the function 'factorial' which actually calculates the factorial is very compact. And
   if you pay close attention, it's very easy to understand as well.

   For those who don't know what's happening, the value that user has entered, say 5, is passed on the
   to the 'factorial' function when it's first called from within the 'main' function. Inside
   'factorial' function, there's a check to see if the input value is zero, which is not true when the
   function gets called first time with input value '5'.

   Then, the return statement contains an expression which multiplies 5 with the return value of
   'factorial(4)'. So now, the 'factorial' function executes once again, and we reach the following
   expression: return (4 * factorial(3)). And then again these steps repeat.

   So if you look broadly, here's how these function calls get stacked:
     * 5 * factorial(4)
     * 4 * facttorial(3)
     * 3 * factorial(2)
     * 2 * factorial (1)
     * 1 * factorial (0)

   Now when factorial(0) executes, the 'if' condition in the 'factorial' function becomes true, and
   value '1' is returned. So now, this is how the above listed calls complete (compare the last entry in
   previous list with first entry in this list, and so on):
     * 1 * 1
     * 2 * (1*1)
     * 3 * (2*(1*1))
     * 4 * (3*(2*(1*1)))
     * 5 *  (4 * (3*(2*(1*1))))

   Which is effectively 5 * 4 *3 * 2 * 1, which in turn is 120, the factorial of 5.

   So this is how recursive functions work. While there's no doubt about the recursive function
   advantages we listed so far, there are some disadvantages as well.

   For example, in our example above, until the call 'factorial(0)' completed, all previous 'factorial'
   calls were waiting for the function processing to be completed. Not to mention the fact that
   automatic or local variables occupy memory for each recursive call made.

   So there's effectively no savings in storage space when you use recursion. Plus, there's also no
   gurantee that your code will be faster in execution. The real advantage of a recursive function is
   when you deal with data structures, which will be discussing later on as part of this ongoing C
   tutorial series.

Conclusion
   To conclude, while you may not use recursive function frequently in your day to day coding tasks,
   it's an important concept that you must be aware of. Try out the example we've mentioned here, and
   tweak it to understand the concept of recursive functions even better.


---
https://www.howtoforge.com/linux-c-programming-tutorial-part-19-pointers-and-arrays/

Linux C Programming Tutorial Part 19: Pointers and Arrays

   Up until now in this ongoing C programming tutorial series, we have briefly discussed the basics
   of pointers. There are, however, several more pointers related concepts that need to be discussed. So
   in this tutorial, we will be discussing the concept of pointers and arrays.

   Before we begin with pointers and arrays, let's quickly refresh the basic concept of pointers itself.
   Pointers are a special kind of variables that can hold addresses. For example, a pointer 'ptr' to a
   character can be declared in the following way;
char *ptr;

   And you can use the ampersand sign to store an address into it. Here's an example:
char c = 'a';
ptr = &c;

   So now, pointer 'ptr' contains the address of variable 'c'. Alternatively, you can also say that
   'ptr' now points to variable 'c'.

   To access or manipulate the value of the variable pointed to by the pointer, you can use the *
   operator. For example, to change the value of variable c from 'a' to 'b', you can use the pointer
   'ptr' in the following way:
*ptr = 'b';

   The following program should give you a better idea on these basic pointer concepts we've discussed
   so far:
#include <stdio.h>
int main()
{
 char c = 'a';
 char *ptr = &c;

 *ptr = 'b';

 printf ("variable c = %c", c);
 return 0;
}

   Here's the output of this program:
variable c = b

   So you can see using a pointer, the value of a variable was changed.

Pointers and Arrays

   As you will spend more and more time writing and reading C code, you'll observe that pointers and
   arrays are often used together. For example, you can access individual elements of an array using a
   pointer. Consider the following piece of code:
...
...
...
char arr[] = {'a','b','c','d','e'}
char *ptr;
ptr = &arr[0]
...
...
...

   Here, pointer 'ptr' points to the first element of the array 'arr', which if you talk in terms of
   indexes, sits at position zero of the array. Now, you can use the * operator with 'ptr' to
   access/manipulate the value which the pointer is pointing to.

   Moving on, once you have a pointer pointing to the first element of an array, it's easy to access
   other elements of the array as well. For example, if - in context of the code excerpt above - you use
   the following expression anywhere:
*(ptr+1)

   then it lets you access the second element of the array, something which you usually do use the
   following way:
arr[1]

   So effectively, adding 1 to 'ptr' takes to the address of the next element in the array, and using *
   you can access the value stored at that address. Similarly, adding 2 takes you to the third element
   ... so on and so forth.

   Here's a program that should give you a clearer idea on what we discussed just now:
#include <stdio.h>
int main()
{
 char arr[] = {'a','b','c','d','e'};
 char *ptr = &arr[0];

 for(int i=0;i<strlen(arr);i++)
 printf ("arr[%d] is %c \n", i, *(ptr+i));
 return 0;
}

   And here's the output:
arr[0] is a
arr[1] is b
arr[2] is c
arr[3] is d
arr[4] is e

   So you can see, the expression '*(ptr+i)' - with i varying from 0 to the last index in the array -
   allowed us to access all elements of the array.

   NOTE 1: The name of the array, when used in the code, gives you the base address of the array. This
   means the name of the array and the address of its first element is one and the same thing. So in the
   context of an array 'arr', '&arr[0]' and 'arr' is one and the same thing. This extends to other
   elements as well, meaning &arr[2] can also be written as (arr+2) and so on.

   NOTE 2: Extending what we discussed in the note above, every array element representation can be
   broken down to pointer representation. For example: arr[2] is equivalent to '*(arr + 2)'.

   NOTE 3: While you can assign an array address to a pointer, vice versa is not valid. Also, unlike
   pointers, you can't use ++ or -- operators with array name. Broadly speaking, you can't change the
   addresses at which array elements are located originally.

Conclusion
   This tutorial focused on the concept of pointers and arrays, how they are related and how array
   elements can be accessed through pointers. Towards the end, we also discussed some important points
   when it comes to code that utilizes pointers to arrays.

   Do try out these concepts locally on your machine to get a better idea of how these things work, and
   in case of any doubt or query, leave a comment below.


---
https://www.howtoforge.com/c-programming-tutorial-part-20-pointer-address-arithmetic/

Linux C Programming Tutorial Part 20 - Pointer address arithmetic

   In our previous tutorial in this ongoing C Programming series, we discussed pointers in a bit of
   detail. Extending that discussion, here we are with some more discussion worthy concepts related to
   pointers. So without further ado, let's begin.

Pointer address arithmetic in C

   Firstly, let's focus on address arithmetic when dealing with pointers. Like we discussed in our
   previous tutorial if you have a pointer pointing to an array (let's say the beginning of it), it's
   very easy to access the elements of that array. Here's an example:
#include <stdio.h>
int main()
{
    char arr[]={'a','b','c','d'};
    int a[]={1,2,3,4};

    char *ptr = arr;
    int *p = a;

    for(int i=0; i<sizeof(arr); i++)
    {
        printf("\n Character pointer pointing to %u, with value %c", ptr, *ptr);
        ptr++;
    }

    for(int i=0; i<(sizeof(a)/sizeof(int)); i++)
    {
        printf("\n Integer pointer pointing to %u, with value %d", p, *p);
        p++;
    }
    return 0;
}

   So in this code, we have two arrays - 'arr' and 'a'. While the first one is a character array, the
   second one is an integer array. Then we have to pointers pointing to these arrays - 'ptr' and 'p',
   respectively. Then there are a couple of 'for' loops wherein we print current address the pointer is
   pointing to and the value contained at that address.

   Here's the output of this code on my machine:
 Character pointer pointing to 726409312, with value a
 Character pointer pointing to 726409313, with value b
 Character pointer pointing to 726409314, with value c
 Character pointer pointing to 726409315, with value d
 Integer pointer pointing to 726409296, with value 1
 Integer pointer pointing to 726409300, with value 2
 Integer pointer pointing to 726409304, with value 3
 Integer pointer pointing to 726409308, with value 4

   Now, what's noteworthy here is the addresses printed in the output. For character array, adding '1'
   to the pointer incremented it to the very next address, but for an integer array, adding '1' to the
   pointer made it jump 4 addresses ahead. Why is that so?

   Well, it all depends on the type of pointer. A character pointer always jumps the number of bytes a
   character occupies, which is usually 1. Similarly, a pointer to an integer usually jumps 4 bytes when
   incremented by 1. So this should explain the difference in character and integer pointer jumps in the
   above output.

   Moving on with the pointer arithmetic, pointers can be used in comparison expressions in select
   cases. For example, if you want to confirm whether or not a pointer 'ptr' points to an element of an
   array 'arr' (sized 'size'), then you can do the comparison in the following way:
if((ptr >= arr) && (ptr < (arr + size)))

   So effectively, the above expression checks whether or not the address held by the pointer is of one
   of its elements.

   Also, if there are multiple pointers pointing to elements of the same array, you can use the
   following comparison operators  ==, !=, <, and >=. In fact, you can also perform pointer subtraction
   in these cases. Here's an example:
#include <stdio.h>
int main()
{
    char arr[]= "Welcome to HowtoForge";

    char *ptr = arr;
    char *p = arr;

    while(*p != '\0')
   {
      p++;
   }

   printf("\n Length of the string is %d", (p - ptr));

   return 0;
}

   So in this program, we made sure one pointer points to the first element of the array, while the
   second pointer is continuously incremented until it points to the last element (which is '\0' in
   constant strings).

   Then, given the fact that we're dealing with characters here (which occupy one byte each), by
   subtracting the address pointed by first pointer from that pointed by the second pointer, we could
   find the number of characters, which if you see is the exact length of the string.

   NOTE: Keep in mind that operations like addition, multiplication, division, and more are invalid when
   it comes to pointers. Also, the kind of acceptable operations we've listed so far are also only valid
   when pointers are of same type and are pointing to elements of the same array.

Conclusion
   After discussing basic pointer concepts in the previous tutorial, we built up on the pointers concept
   by discussing the pointer address arithmetic here. We suggest you practice what all we discussed here
   on your machine in the form of programs. And in case you of any doubt or query, don't hesitate to
   leave a comment below.


---
https://www.howtoforge.com/c-programming-tutorial-part-21-character-pointers-array-of-pointers-and-pointer-to-pointer/

Linux C Programming tutorial Part 21: Character pointers, array of pointers, and pointer to pointer

   The concept of pointers is indeed one of the very important concepts in the C programming language.
   Up until now, we have discussed several aspects of pointers in C. Expanding on that, in this
   tutorial, we will be discussing a few more pointer concepts.

Character pointers, array of pointers, and pointer to pointer in C

   Let's begin with character pointers with the following lines of code:
char p[] = "I like HowtoForge"
char *p = "I like HowToForge"

   The first line defines an array 'p' with size equal to the number of characters in double quotes. But
   the next line defines a pointer 'p' which points towards a string constant.

   The difference here is that the first 'p' being an array, you can easily modify or change the
   contents of the array. But since the second 'p' is pointing to a string constant, you just can't
   change the string contents.

   For example, the following piece of code tries to modify a string constant:
#include <stdio.h>
int main()
{
   char *p = "I like HowToForge";

   p[0] = 'U';
   return 0;
}

   And here's the output produced by this code on my system:
Segmentation fault

   This error suggests the program execution came to an abrupt end, and that's because we tried to
   change something which is constant.

   Also, keep in mind that while the pointer 'p' can be made to point a different string, you cannot
   change the base address of the array 'p' (if you remember, this we have already discussed in one of
   our previous tutorials).

   Now moving on to pointer arrays, just like you've seen integer, character, and another type of
   arrays, there can also be an array of pointers. For example, the following program defines an array
   'arr' of integer pointers and assigns values to it.
#include <stdio.h>
int main()
{
 int *arr[3];
 int a = 0, b = 1, c = 2;

 arr[0] = &a;
 arr[1] = &b;
 arr[2] = &c;
 return 0;
}

   Note that the values assigned to the array are addresses. This is because 'arr' is an array of
   pointers, and pointers store nothing but addresses. Now, if you want to access values kept at these
   addresses, you'll have to use the *operator.

   Following example (which is nothing but an extension of the previous example) showcases this:
#include <stdio.h>
int main()
{
   int *arr[3];
   int a = 0, b = 1, c = 2;

   arr[0] = &a;
   arr[1] = &b;
   arr[2] = &c;

   for(int i=0; i < 3; i++)
      printf("\n arr[%d] is: %d",i,*(arr[i]));
 return 0;
}

   Here's the output:
arr[0] is: 0
arr[1] is: 1
arr[2] is: 2

   Similar to integer pointer arrays (like one we discussed here), you can have arrays storing character
   pointers and more.

   Now, let's move on to pointer to pointers. As we have iterated a number of times so far, a pointer
   stores an address. Now, up till now in this ongoing C programming tutorial series, we have only seen
   a pointer pointing to a non-pointer variable, but the fact is pointers can point to other pointers as
   well.

   This means a pointer can store an address of another pointer. For example, following is a double
   pointer or a pointer to pointer:
int **ptr;

   Here's is a piece of code that utilizes a double pointer:
#include <stdio.h>
int main()
{
   int *ptr;
   int **p;

   int a = 10;

   ptr = &a;

   p = &ptr;

   printf("\n Pointer 'p' points to pointer 'ptr' which further points to value: %d", **p);
   return 0;
}

   Here's the output:
Pointer 'p' points to pointer 'ptr' which further points to value: 10

   So this was an example of a double pointer. On similar lines, you can have a pointer to a pointer to
   a pointer, defined as, for example, int ***ptr. The maximum number of such 'pointer to pointer
   to......' levels is implementation specific (in some cases the limit is 12 though).

   Practically, however, you'll likely only encounter pointer to pointers up to level three, as having
   more levels makes the logic more complex to understand and maintain.

Conclusion
   We discussed three important pointers related concepts here. You are advised to try out the examples
   and concepts we discussed here on your system to get a better idea of how these things work. In case
   of any doubt or query, drop us a comment below.


---
https://www.howtoforge.com/linux-c-programming-tutorial-part-22-accessing-command-line-arguments-within-c-program/

Linux C Programming tutorial part 22 - Accessing command line arguments within C program

   In the previous tutorial, we discussed multiple concepts related to pointers in C programming
   language. One of the concepts we discussed was an array of pointers. We used the example of an
   integer pointer array to demonstrate the concept.

How to access command line arguments within a C program

   But as mentioned in that tutorial, an array of pointers can be of different types. For example,
   here's an array of character pointers:
char *arr[] = {"HowtoForge", "FaqForge", "Linux"};

   And here's a small program that shows how this array can be used:
#include <stdio.h>
int main()
{
 char *arr[] = {"HowtoForge", "FaqForge", "Linux"};

 printf("\n %s", *arr);
 printf("\n %s", *(arr+1));
 printf("\n %s", *(arr+2));

 return 0;
}

   'arr' is the address of the first element of this array. Now, since this is an array of pointers, so
   the first element (and all other elements, accessed by adding 1 and 2 to arr) is nothing but address.
   So to access the value kept that address, we use the * operator.

   Following is the output of this program:
HowtoForge
FaqForge
Linux

   So this is how you access values from an array of character pointers. Now, you must be thinking why
   we discussed all this?

   Well, we did it because this brings us to another important concept, which is the ability to access
   command line arguments in environments that support the C programming language. Let's discuss this in
   detail.

   As should be well aware by now, 'main' is the first function in your program that gets called when
   the program is executed. It's called with two arguments: argc and argv. While the former tells you
   about the number of command line arguments, the latter is actually an array of pointers to arguments
   themselves.

   Please note that the name of the program itself is passed as an argument to the main function. So
   because of this, the number of arguments - represented by argc - is one more than the actual number
   of arguments passed to the program. Following is an example:
#include <stdio.h>
int main(int argc, char *argv[])
{
 printf("\n %d", argc);
 printf("\n %s", *argv);

 return 0;
}

   Now, we executed this program - called a.out, and present in the 'home' directory of our system -
   without any arguments. And here's the output:
 1
 /home/a.out

   So you can see the execution name of the program was passed as an argument. Had I used the following
   command:
/home/a.out htf ff

   Then in that case, argc would have been 3 and argv would have contained addresses of strings
   '/home/a.out', 'htf', and 'ff'.

   Here's a better way to write the arguments printing program:
#include <stdio.h>
int main(int argc, char *argv[])
{
   for(int i=0; i<argc; i++)
      printf("\n %s", *(argv+i));

 return 0;
}

   It's worth remembering that the arguments are stored in the array in the same order they are passed
   on the command line.

Conclusion
   You will likely encounter several situations wherein you'll have to deal with command line arguments
   inside your C code. What we discussed here should form a basis for you. Do try out some programs at
   your end to get a better idea on how command line arguments are accessed inside a C program.


---
https://www.howtoforge.com/linux-c-programming-tutorial-part-23-structures/

Linux C Programming Tutorial Part 23 - Structures

   So far in this ongoing C programming tutorial series, we have discussed several aspects, ranging
   from variables to functions to even pointers. However, that's still like scratching the surface, as
   there are many other important concepts in the C programming language.

   Today, in this tutorial, we will discuss one such concept - the concept of structures.

Structures in C Programming Language

   Here's how a structure is declared:
struct TAG {
variable declaration
variable declaration
...
...
...
};

   TAG can be any name you want to give to this structure, like emp_details.

   It should be common knowledge by now that variables are used to store values in a C program. Up until
   now, we have seen programs/code using one or more variables, but have never seen multiple variables
   being grouped together. Yes, that's possible, and that's essentially what structures do.

   Imagine a case wherein the code you write deals with the maintenance of employee details at a
   company. Every time a new employee joins, your program is fed with the employee's name, age,
   designation, and department. So, in this case, it's ideal to have the code written in a way that all
   this information related to an employee is treated as a single unit.

   So one option to write the code this way is to create a structure that groups all this employee
   related information. All you need to do is to create an instance of the structure (or a variable of
   that structure type) and fill up all details related to the new employee.

   Following are a couple of ways in which you can create structure type variables (a, b, and c in this
   case):
struct emp_details {
variable declaration
variable declaration
...
...
...
}a, b, c;
struct emp_details a;
struct emp_details b;
struct emp_details c;

   Enough of theory, let's take an easy to understand example. Suppose your team consists of 2 members,
   and you want to have their details stored in your computer through a program that you want to code in
   C. The following piece of code should give you a basic idea on how structures can be helpful in that
   case:
#include <stdio.h>
struct emp_details {
 int emp_code;
 int emp_age;

 };
int main()
{
   struct emp_details employee[2];

   printf("\n enter code and age of first member\n");
   scanf("%d", &employee[0].emp_code);
   scanf("%d", &employee[0].emp_age);

   printf("\n enter code and age of second member\n");
   scanf("%d", &employee[1].emp_code);
   scanf("%d", &employee[1].emp_age);

   for(int i=0; i<2; i++)
   {
      printf("\n Code and age of member %d is: %d and %d \n", i+1, employee[i].emp_code, employee[i].emp_age);
   }
 return 0;
}

   So here in this code, we first declared a structure named 'emp_details' with 'emp_code' and 'emp_age'
   as its two member variables. Then in the 'main' function, we defined two objects of this structure in
   the form of an array. Thereon, we populated member variables corresponding to these objects by
   accepting input from the user. And finally, the program outputs these values back to the user.

   Here's the output when we executed the program on our machine:
enter code and age of first member
105
27

enter code and age of second member
110
32

 Code and age of member 1 is: 105 and 27

 Code and age of member 2 is: 110 and 32

   Variables that are part of a structure unit can be of any type. You can even have objects/instance of
   a different structure as part of your structure. All this and more in our next tutorial on
   structures, so stay tuned.

Conclusion
   This tutorial focused on the basics of structures in C programming language. We learned how to
   declare a structure, then define an object or instance for it, and finally, how to access structure
   variables. In our upcoming tutorials, we will delve a bit deeper and learn more about structures.


---
https://www.howtoforge.com/linux-c-programming-tutorial-part-24-multi-dimensional-arrays/

Linux C Programming Tutorial Part 24 - Multi dimensional arrays

   If you're following this ongoing C programming tutorial series, you'd be aware of the concept
   of arrays. To quickly refresh, arrays are used to store multiple values of the same type in
   continuous storage.

Multidimensional arrays in C

   For example, the following is an integer array capable of storing 5 numbers.
int arr[5]

   Any value stored in an array can be accessed easily using the array name and the corresponding index
   value. As indexes begin from 0, let's say if you want to access the second element in an array, you
   can do that in the following way:
arr[1]

   The following program accepts 5 integers from user as input, stores them in an array, and then
   outputs them back to user.
#include <stdio.h>
int main()
{
 int arr[5],i;

 printf("Enter 5 integer values\n");

 for(i=0;i<5;i++)
 scanf("%d",&(arr[i]));

 printf("You entered the following values:\n");

 for(i=0;i<5;i++)
 printf("%d\n",arr[i]);

 return 0;
}

   Now, this type of array is known as a single dimensional array. Yes, that means there also exist
   multi dimensional arrays - two dimensional arrays, three dimensional arrays, and so on. For example,
   following is a two dimensional array:
int arr[2][3]

   You can visualize this array as a 2-D table of numbers with 2 rows and 3 columns - something like the
   following:
x x x
x x x

   So there are a total of 6 elements this array can hold. It's worth mentioning that the total number
   of elements an array can hold can be easily calculated by multiplying the indices in the declaration
   of the array. For example, in case of 'arr', the capacity of the array can be calculated by doing
   2x3, which equals 6.

   Coming to the initialization part, a 2-D array like 'arr' can be initialized in the following way:
int arr [2][3] = {1,2,3,4,5,6}

   As this above initialization makes it hard to visualize these values in a 2-D array, there's another
   (read: better) way that you can opt. Here it is:
int arr [2][3] = { {1,2,3}, {4,5,6} };

   So now it's easy to visualize that numbers 1,2,3 are in one row, while 4,5,6 are in the other. Here
   you go:
1 2 3
4 5 6

   As for how to deal with a 2-D array in C, following is a small program that accepts these 6 values
   from user, stores them in a 2-D array 'arr', and then finally outputs them back to user:
#include <stdio.h>
int main()
{
   int arr[2][3],i,j;

   printf("You are about to enter values for a 2x3 array\n");

   for(i=0;i<2;i++)
   {
     for(j=0;j<3;j++)
     {
       printf("\n Enter value to be stored at row %d and column %d :: ",i,j);
       scanf("%d",&arr[i][j]);
     }
   }


   printf("\n You entered the following values:\n");

   for(i=0;i<2;i++)
   {
     for(j=0;j<3;j++)
     {
       printf("\n Row %d and column %d = %d\n",i,j,arr[i][j]);
     }
   }

   return 0;
}

   And here's the output:
You are about to enter values for a 2x3 array

 Enter value to be stored at row 0 and column 0 :: 1

 Enter value to be stored at row 0 and column 1 :: 2

 Enter value to be stored at row 0 and column 2 :: 3

 Enter value to be stored at row 1 and column 0 :: 4

 Enter value to be stored at row 1 and column 1 :: 5

 Enter value to be stored at row 1 and column 2 :: 6
You entered the following values:

 Row 0 and column 0 = 1

 Row 0 and column 1 = 2

 Row 0 and column 2 = 3

 Row 1 and column 0 = 4

 Row 1 and column 1 = 5

 Row 1 and column 2 = 6

   So that was some basic information about two dimensional arrays. What about 3-D arrays? Well, on the
   same lines, you can define and initialize three dimensional arrays as well. Here's an example:
int arr[2][3][4]

   So how would one go about visualizing this array? Well, think of a three dimensional world (the world
   we live in), and then visualize three dimensions perpendicular to each other. That's how the three
   dimensions of this array fit in.

   Carrying a capacity of 24 elements (2x3x4), this array can be initialized in the following way:
int x[2][3][4] =
 {
   { {1,2,3,4}, {5,6,7,8}, {9,10,11,12} },
   { {13,14,15,16}, {17,18,19,20}, {21,22,23,24} }
 };

   And here's a C program making use of a 3-D array:
#include <stdio.h>
int main()
{
   int arr[2][3][4],i,j,k;

   printf("You are about to enter values for a 2x3x4 array\n");

   for(i=0;i<2;i++)
   {
     for(j=0;j<3;j++)
     {
       for(k=0;k<4;k++)
       {
          printf("\n Enter value to be stored at arr[%d][%d][%d] :: ",i,j,k);
          scanf("%d",&arr[i][j][k]);
       }
     }
   }


 printf("\n You entered the following values:\n");

   for(i=0;i<2;i++)
   {
     for(j=0;j<3;j++)
     {
       for(k=0;k<4;k++)
       {
          printf("\n arr[%d][%d][%d] = %d\n",i,j,k,arr[i][j][k]);
       }
     }
   }

 return 0;
}

Conclusion
   In this tutorial, we expanded upon our existing understanding of arrays by discussing the concept of
   multidimensional arrays. You are advised to try out examples used in this tutorial on your system (as
   well as create new ones) to get a better understanding of how these arrays work. In case of any doubt
   or query, leave a comment below.


---
https://www.howtoforge.com/linux-c-programming-tutorial-part-25-function-pointers/

Linux C Programming Tutorial Part 25 - Function pointers

   Up until now in this ongoing C programming tutorial series, we have discussed the basic concept
   of pointers as well as quite a few aspects related to pointers, like pointer to an array and array of
   pointers. Expanding upon our understanding of pointers, in this tutorial, we will discuss the concept
   of pointers to functions.

Function pointers in C programming language

   Just like we have pointers to variables, there can also be pointers to functions. Following is an
   example of a function pointer declaration:
void (*fn_ptr)(int)

   So here we have a function pointer named 'fn_ptr' that can point to any function which returns void
   and accepts an integer as input. Needless to say, this is just the declaration part - like any other
   pointer, you need to assign it an address (that of a function in this case) to make use of it.

   Following is an example making use of this pointer:
#include <stdio.h>
void print_int(int a)
{
 printf("\n The integer value is: %d\n",a);
}
int main()
{
 void (*fn_ptr)(int);
 fn_ptr = &print_int;
 (*fn_ptr)(10);
 return 0;
}

   So as you can see, we first defined a function 'print_int' that accepts an integer and returns void.
   Then, in the 'main' function, we declared 'fn_ptr' as a function pointer that can point to functions
   like 'print_int'. This was followed by assigning address of 'print_int' function to 'fn_ptr', and
   finally, making a call to the function using the pointer.

   Here's the output produced:
The integer value is: 10

   What's worth mentioning here is that you can further simplify this program by avoiding & and * from
   last two lines. Following is the modified code:
#include <stdio.h>
void print_int(int a)
{
 printf("\n The integer value is: %d\n",a);
}
int main()
{
 void (*fn_ptr)(int);
 fn_ptr = print_int;
 fn_ptr(10);
 return 0;
}

   Moving on, like an array of pointers, you can also have an array of function pointers. For example,
   following is an array of function pointers capable of storing 3 function addresses.
void (*fn_ptr[3])(int)

   And following is an example making use of this array of pointers:
void print_int1(int a)
{
 printf("\n The integer value is: %d\n",a);
}
void print_int2(int a)
{
 printf("\n The integer value is: %d\n",a+1);
}
void print_int3(int a)
{
 printf("\n The integer value is: %d\n",a+2);
}
int main()
{
 void (*fn_ptr[3])(int);

 fn_ptr[0] = print_int1;
 fn_ptr[1] = print_int2;
 fn_ptr[2] = print_int3;

 fn_ptr[0](10);
 fn_ptr[1](10);
 fn_ptr[2](10);
 return 0;
}

   Here's the output produced by this code:
The integer value is: 10

The integer value is: 11

The integer value is: 12

   Another aspect of function pointers you should know about is that you can use them as function
   arguments as well. For example, there can be a function that accepts a pointer to a function as an
   argument. For example:
void some_random_func(void (*fn_ptr)(int))

   Following is an example code that utilizes this function:
#include <stdio.h>
void another_random_func(int a)
{
 printf("\n The integer to entered is: %d\n", a);
}
void some_random_func(void (*fn_ptr)(int))
{
 fn_ptr(5);
}
int main()
{
 some_random_func(another_random_func);
 return 0;
}

   So what we did here is, we created a function dubbed 'some_random_func' which accepts a function
   pointer in the input. Then, from 'main', we called 'some_random_func' with the address of another
   function 'another_random_func' as an argument. Then using the pointer, we successfully called
   'another_random_func'.

   Here's the output:
The integer to entered is: 5

Conclusion
   Function pointers can come in handy when you want to create something called a 'callback mechanism'.
   But before getting into that, it's better if you get a good understanding of this concept. We suggest you
   try examples from this tutorial on your local machine (and also create new ones). In case of any doubt or
   query, leave a comment below.


---
https://www.howtoforge.com/linux-c-programming-tutorial-part-26-structures-and-functions/

Linux C Programming Tutorial Part 26 - Structures and Functions

   In one of our previous command line tutorials, we touched upon the concept of Structures. Using
   easy to understand examples, we discussed basic stuff like what are structures and why are they
   required. Expanding upon that, in this tutorial, we will discuss how structures and functions can be
   used together.

Structures and Functions in C Programming Language

   Before we begin, let's quickly refresh how a structure is declared. Here's an example:
struct emp_details {
 int emp_code;
 int emp_age;

 };

   So here, the struct keyword - which is mandatory if you're defining a structure in C - signifies the
   beginning of the declaration. It is followed by a tag, or you can say the name of the structure.
   Then, inside brackets, you have two integer variables, which are grouped together as part of this
   structure.

   To use this structure, you first need to define its instance or object. You can do that in the
   following way:
emp_details obj;

   And then the structure members can be accessed in the following way:
obj.emp_code
obj.emp_age

   Now, coming to functions, a function can return structures as well as accept structures in form of
   arguments. Here's an example:
#include <stdio.h>
struct emp_details {
 int emp_code;
 int emp_age;

 };

 struct emp_details fill(int code, int age)
 {
 struct emp_details obj;
 obj.emp_code = code;
 obj.emp_age = age;

 return obj;
 }
int main()
{
 int x,y;

 printf("Enter employee code: ");
 scanf("%d", &x);

 printf("\n Enter employee age: ");
 scanf("%d", &y);

 struct emp_details new_obj;

 new_obj = fill(x,y);

 printf("\n The employee code and age you entered are: %d and %d", new_obj.emp_code, new_obj.emp_age);

 return 0;
}

   So here, in this example, we have a function 'fill' that accepts two integers, treats them as code
   and age, fills up a structure based on this information, and returns the structure by value to the
   caller of the function.

   Now, as I mentioned earlier in a statement above, structures can also be passed as function
   arguments. Following is an example, where the function 'fill' accepts an 'emp_details' structure as
   an argument.
#include <stdio.h>
struct emp_details {
 int emp_code;
 int emp_age;

 };

 void fill(struct emp_details obj)
 {
 printf("\n The employee code and age you entered are: %d and %d", obj.emp_code, obj.emp_age);
 }
int main()
{
 int x,y;

 printf("Enter employee code: ");
 scanf("%d", &x);

 printf("\n Enter employee age: ");
 scanf("%d", &y);

 struct emp_details new_obj;
 new_obj.emp_code = x;
 new_obj.emp_age = y;

 fill(new_obj);
 return 0;
}

   And here's the output in my case:
Enter employee code: 36
 Enter employee age: 29

 The employee code and age you entered are: 36 and 29

   Moving on, like normal variables, arrays, and more, there can be pointers to structures as well.
   Here's an example:
struct emp_details *ptr;

   As always, pointers come in handy in case the structure size is large, and you are sending it as an
   argument to a function. Ideally, here's how you can access structure variables through pointer
   objects:
(*ptr).emp_code
(*ptr).emp_age

   But for the sake for simplicity, C allows you omit * and . and use '->' instead. Following is an
   example:
ptr->emp_code
ptr->emp_age

   Here's an example that makes use of structure pointer:
#include <stdio.h>
struct emp_details {
 int emp_code;
 int emp_age;

 };

 void fill(struct emp_details *obj)
 {
 printf("\n The employee code and age you entered are: %d and %d", obj->emp_code, obj->emp_age);
 }
int main()
{
 int x,y;

 printf("Enter employee code: ");
 scanf("%d", &x);

 printf("\n Enter employee age: ");
 scanf("%d", &y);

 struct emp_details new_obj;
 new_obj.emp_code = x;
 new_obj.emp_age = y;

 fill(&new_obj);
 return 0;
}

   While this is the same example we used previously, the changes - as we are using a structure pointer
   now - are highlighted in bold.

Conclusion
   In this tutorial, we expanded upon our understanding of structures by discussing how functions and
   structures can be used together. You are encouraged to try out the examples we used here on your
   local system. In case of any doubt or query, leave a comment below.


---
https://www.howtoforge.com/linux-c-programming-tutorial-part-27-array-of-structures/

Linux C Programming tutorial part 27 - Array of structures

   In this ongoing C programming tutorial series, we have been discussing lately about structures.
   We have already covered the basics of structures, how structures can be used with functions, as well
   as the concept of pointers to structures.

   Now, expanding further on the concept of structures, we'll discuss how to create an array of
   structures using easy to understand examples.

Array of structures in C programming language

   So let's begin. Here's a simple structure named 'student_details' which as you can see, can be used
   to store roll number and marks for students:
struct student_details{
int roll_no;
int marks;
};

   Now, suppose there are 5 students in total, and the requirement is to accept input from user about
   these student details. Then one way to write code for this is:
#include <stdio.h>
struct student_details{
int roll_no;
int marks;
};
int main()
{
 struct student_details obj1;
 struct student_details obj2;
 struct student_details obj3;
 struct student_details obj4;
 struct student_details obj5;
 ...
 ...
 ...

   Or may be something like this:
#include <stdio.h>
struct student_details{
int roll_no;
int marks;
};
int main()
{
 struct student_details obj1, obj2, obj3, obj4, obj5;
 ...
 ...
 ...

   Now, there's no harm if you follow the aforementioned approaches. The only concern that arises is
   whether these approaches are scalable. I mean, what if instead of 5, you need to create, say, 50
   objects or instances. In that case, following these approaches will definitely make code writing and
   maintenance much more complex.

   So is there a solution? Well, yes. A better way is to create an array of 'student_details' structure.
   Here's how:
struct student_details obj[5];

   Following is a complete program that utilizes this structure array:
#include <stdio.h>
struct student_details{
int roll_no;
int marks;
};
int main()
{
 struct student_details obj[5];
 int i;

 for(i=0;i<5;i++)
 {
 printf("\n Enter roll number: ");
 scanf("%d", &(obj[i].roll_no));
 printf("\n Enter marks (out of 100): ");
 scanf("%d", &(obj[i].marks));
 }

 printf("\n Here's the data you've entered::");

 for(i=0;i<5;i++)
 {
 printf("\n Roll number: %d", (obj[i].roll_no));
 printf("-- Marks: %d", (obj[i].marks));
 }

 return 0;
}

   So here, we used the 'student_details' structure we discussed earlier, and created an array of 5
   objects of its type. Then, the program asks user to input student roll number and marks one by one.
   Info corresponding to each student is stored in each instance of structure array. And finally, the
   stored info is printed back as output to user.

   Here's the output in my case:
Enter roll number: 1

 Enter marks (out of 100): 67

 Enter roll number: 2

 Enter marks (out of 100): 73

 Enter roll number: 3

 Enter marks (out of 100): 56

 Enter roll number: 4

 Enter marks (out of 100): 52

 Enter roll number: 5

 Enter marks (out of 100): 85

 Here's the data you've entered::
 Roll number: 1-- Marks: 67
 Roll number: 2-- Marks: 73
 Roll number: 3-- Marks: 56
 Roll number: 4-- Marks: 52
 Roll number: 5-- Marks: 85

   Using this approach, you can easily scale your program. This means, even if there are 50 students
   whose information needs to be stored and printed, you just need to increase the size of array to 50,
   and make very few related changes. Rest of the code remains the same. So, in a nutshell, you can
   handle scalability easily when using arrays as compared to the approaches we discussed in the
   beginning of the tutorial.

Conclusion
   In this tutorial, we covered the basic concept of array of structures. Using easy to understand
   examples, we discussed why a structure array is important, when to use it, and how to use it. You are
   advised to try out the examples from this tutorial on your machine. And in case of any doubt or
   query, leave a comment below.


---
