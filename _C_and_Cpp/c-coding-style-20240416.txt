filename: c_coding-style_20240416.txt
https://nullprogram.com/blog/2023/10/08/

My personal C coding style as of late 2023
October 08, 2023

   This has been a ground-breaking year for my C skills, and paradigm shifts in my technique has
   provoked me to reconsider my habits and coding style. It's been my largest personal style change in
   years, so I've decided to take a snapshot of its current state and my reasoning. These changes have
   produced significant productive and organizational benefits, so while most is certainly subjective,
   it likely includes a few objective improvements. I'm not saying everyone should write C this way, and
   when I contribute code to a project I follow their local style. This is about what works well for me.

  Primitive types
   Starting with the fundamentals, I've been using short names for primitive types. The resulting
   clarity was more than I had expected, and it's made my code more enjoyable to review. These names
   appear frequently throughout a program, so conciseness pays. Also, now that I've gone without, _t
   suffixes are more visually distracting than I had realized.

typedef uint8_t   u8;
typedef char16_t  c16;
typedef int32_t   b32;
typedef int32_t   i32;
typedef uint32_t  u32;
typedef uint64_t  u64;
typedef float     f32;
typedef double    f64;
typedef uintptr_t uptr;
typedef char      byte;
typedef ptrdiff_t size;
typedef size_t    usize;

   Some people prefer an s prefix for signed types. I prefer i, plus as you'll see, I have other designs
   for s. For sizes, isize would be more consistent, and wouldn't hog the identifier, but signed
   sizes are the way and so I want them in a place of privilege. usize is niche, mainly for interacting
   with external interfaces where it might matter.

   b32 is a "32-bit boolean" and communicates intent. I could use _Bool, but I'd rather stick to a
   natural word size and stay away from its weird semantics. To beginners it might seem like "wasting
   memory" by using a 32-bit boolean, but in practice that's never the case. It's either in a register
   (return value, local variable) or would be padded anyway (struct field). When it actually matters, I
   pack booleans into a flags variable, and a 1-byte boolean rarely important.

   While UTF-16 might seem niche, it's a necessary evil when dealing with Win32, so c16 ("16-bit
   character") has made a frequent appearance. I could have based it on uint16_t, but putting the name
   char16_t in its "type hierarchy" communicates to debuggers, particularly GDB, that for display
   purposes these variables hold character data. Officially Win32 uses a type named wchar_t, but I like
   being explicit about UTF-16.

   u8 is for octets, usually UTF-8 data. It's distinct from byte, which represents raw memory and is a
   special aliasing type. In theory these can be distinct types with differing semantics, though I'm not
   aware of any implementation that does so (yet?). For now it's about intent.

   What about systems that don't support fixed width types? That's academic, and far too much time has
   been wasted worrying about it. That includes time wasted on typing out int_fast32_t and similar
   nonsense. Virtually no existing software would actually work correctly on such systems - I'm certain
   nobody's testing it after all - so it seems nobody else cares either.

   I don't intend to use these names in isolation, such as in code snippets (outside of this article).
   If I did, examples would require the typedefs to give readers the complete context. That's not worth
   extra explanation. Even in the most recent articles I've used ptrdiff_t instead of size.

  Macros
   Next, some "standard" macros:

#define countof(a)    (size)(sizeof(a) / sizeof(*(a)))
#define lengthof(s)   (countof(s) - 1)
#define new(a, t, n)  (t *)alloc(a, sizeof(t), _Alignof(t), n)

   While I still prefer ALL_CAPS for constants, I've adopted lowercase for function-like macros because
   it's nicer to read. They don't have the same namespace problems as other macro definitions: I can
   have a macro named new() and also variables and fields named new because they don't look like
   function calls.

   For GCC and Clang, my favorite assert macro now looks like this:

#define assert(c)  while (!(c)) __builtin_unreachable()

   It has useful properties beyond the usual benefits:
	 * It does not require separate definitions for debug and release builds. Instead it's controlled by
	   the presence of Undefined Behavior Sanitizer (UBSan), which is already present/absent in these
	   circumstances. That includes fuzz testing.
	 * libubsan provides a diagnostic printout with a file and line number.
	 * In release builds it turns into a practical optimization hint.

   To enable assertions in release builds, put UBSan in trap mode with -fsanitize-trap and then enable
   at least -fsanitize=unreachable. In theory this can also be done with -funreachable-traps, but as of
   this writing it's been broken for the past few GCC releases.

  Parameters and functions
   No const. It serves no practical role in optimization, and I cannot recall an instance where it
   caught, or would have caught, a mistake. I held out for awhile as prototype documentation, but on
   reflection I found that good parameter names were sufficient. Dropping const has made me noticeably
   more productive by reducing cognitive load and eliminating visual clutter. I now believe its
   inclusion in C was a costly mistake.

   (One small exception: I still like it as a hint to place static tables in read-only memory closer to
   the code. I'll cast away the const if needed. This is only of minor importance.)

   Literal 0 for null pointers. Short and sweet. This is not new, but a style I've used for about 7
   years now, and has appeared all over my writing since. There are some theoretical edge cases where it
   may cause defects, and lots of ink has been spilled on the subject, but after a couple 100K lines
   of code I've yet to see it happen.

   restrict when necessary, but better to organize code so that it's not, e.g. don't write to "out"
   parameters in loops, or don't use out parameters at all (more on that momentarily). I don't bother
   with inline because I compile everything as one translation unit anyway.

   typedef all structures. I used to shy away from it, but eliminating the struct keyword makes code
   easier to read. If it's a recursive structure, use a forward declaration immediately above so that
   such fields can use the short name:

typedef struct map map;
struct map {
	map *child[4];
	// ...
};

   Declare all functions static except for entry points. Again, with everything compiled as a single
   translation unit there's no reason to do otherwise. It was probably a mistake for C not to default to
   static, though I don't have a strong opinion on the matter. With the clutter eliminated through short
   types, no const, no struct, etc. functions fit comfortably on the same line as their return type. I
   used to break them apart so that the function name began on its own line, but that's no longer
   necessary.

   In my writing I sometimes omit static to simplify, and because outside the context of a complete
   program it's mostly irrelevant. However, I will use it below to emphasize this style.

   For awhile I capitalized type names as that effectively put them in a kind of namespace apart from
   variables and functions, but I eventually stopped. I may try this idea in different way in the
   future.

  Strings
   One of my most productive changes this year has been the total rejection of null terminated strings -
   another of those terrible mistakes - and the embrace of this basic string type:

#define s8(s) (s8){(u8 *)s, lengthof(s)}
typedef struct {
	u8   *data;
	size len;
} s8;

   I've used a few names for it, but this is my favorite. The s is for string, and the 8 is for UTF-8 or
   u8. The s8 macro (sometimes just spelled S) wraps a C string literal, making a s8 string out of it. A
   s8 is handled like a fat pointer, passed and returned by copy. s8 makes for a great function
   prefix, unlike str, all of which are reserved. Some examples:

static s8   s8span(u8 *, u8 *);
static b32  s8equals(s8, s8);
static size s8compare(s8, s8);
static u64  s8hash(s8);
static s8   s8trim(s8);
static s8   s8clone(s8, arena *);

   Then when combined with the macro:

	if (s8equals(tagname, s8("body"))) {
		// ...
	}

   You might be tempted to use a flexible array member to pack the size and array together as one
   allocation. Tried it. Its inflexibility is totally not worth whatever benefits it might have.
   Consider, for instance, how you'd create such a string out of a literal, and how it would be used.

   A few times I've thought, "This program is simple enough that I don't need a string type for this
   data." That thought is nearly always wrong. Having it available helps me think more clearly, and
   makes for simpler programs. (C++ got it only a few years ago with std::string_view and std::span.)

   It has a natural UTF-16 counterpart, s16:

#define s16(s) (s16){u##s, lengthof(u##s)}
typedef struct {
	c16 *data;
	size len;
} s16;

   I'm not entirely sold on gluing u to the literal in the macro, versus writing it out on the string
   literal.

  More structures
   Another change has been preferring structure returns instead of out parameters. It's effectively a
   multiple value return, though without destructuring. A great organizational change. For example, this
   function returns two values, a parse result and a status:

typedef struct {
	i32 value;
	b32 ok;
} i32parsed;

static i32parsed i32parse(s8);

   Worried about the "extra copying?" Have no fear, because in practice calling conventions turn this
   into a hidden, restrict-qualified out parameter - if it's not inlined such that any return value
   overhead would be irrelevant anyway. With this return style I'm less tempted to use in-band signals
   like special null returns to indicate errors, which is less clear.

   It's also led to a style of defining a zero-initialized return value at the top of the function, i.e.
   ok is false, and then use it for all return statements. On error, it can bail out with an immediate
   return. The success path sets ok to true before the return.

static i32parsed i32parse(s8 s) {
	i32parsed r = {0};
	for (size i = 0; i < s.len; i++) {
		u8 digit = s.data[i] - '0';
		// ...
		if (overflow) {
			return r;
		}
		r.value = r.value*10 + digit;
	}
	r.ok = 1;
	return r;
}

   Aside from static data, I've also moved away from initializers except the conventional zero
   initializer. (Notable exception: s8 and s16 macros.) This includes designated initializers. Instead
   I've been initializing with assignments. For example, this buffered output "constructor":

typedef struct {
	u8 *buf;
	i32 len;
	i32 cap;
	i32 fd;
	b32 err;
} u8buf;

static u8buf newu8buf(arena *perm, i32 cap, i32 fd) {
	u8buf r = {0};
	r.buf = new(perm, u8, cap);
	r.cap = cap;
	r.fd  = fd;
	return r;
}

   I like how this reads, but it also eliminates a cognitive burden: The assignments are separated by
   sequence points, giving them an explicit order. It doesn't matter here, but in other cases it does:

	example e = {
		.name = randname(&rng),
		.age  = randage(&rng),
		.seat = randseat(&rng),
	};

   There are 6 possible values for e from the same seed. I like no longer thinking about these
   possibilities.

  Odds and ends
   Prefer __attribute to __attribute__. The __ suffix is excessive and unnecessary.

__attribute((malloc, alloc_size(2, 4)))

   For Win32 systems programming, which typically only requires a modest number of declarations and
   definitions, rather than include windows.h, write the prototypes out by hand using custom types.
   It reduces build times, declutters namespaces, and interfaces more cleanly with the program (no more
   DWORD/BOOL/ULONG_PTR, but u32/b32/uptr).

#define W32(r) __declspec(dllimport) r __stdcall
W32(void)   ExitProcess(u32);
W32(i32)    GetStdHandle(u32);
W32(byte *) VirtualAlloc(byte *, usize, u32, u32);
W32(b32)    WriteConsoleA(uptr, u8 *, u32, u32 *, void *);
W32(b32)    WriteConsoleW(uptr, c16 *, u32, u32 *, void *);

   For inline assembly, treat the outer parentheses like braces, put a space before the opening
   parenthesis, just like if, and start each constraint line with its colon.

static u64 rdtscp(void) {
	u32 hi, lo;
	asm volatile (
		"rdtscp"
		: "=d"(hi), "=a"(lo)
		:
		: "cx", "memory"
	);
	return (u64)hi<<32 | lo;
}

   There's surely a lot more to my style than this, but unlike the above, those details haven't changed
   this year. To see most of the mentioned items in action in a small program, see [**1]wordhist.c, one
   of my testing grounds for hash-tries, or for a slightly larger program, [**2]asmint.c, a mini
   programming language implementation.


---
[**1]
https://github.com/skeeto/scratch/blob/master/misc/wordhist.c

// Word count histogram (hash-trie experiment)
// Windows: $ cc -nostartfiles -fno-builtin -o wordhist wordhist.c
//          $ cl /GS- wordhist.c /link /subsystem:console kernel32.lib
// Unix:    $ cc -o wordhist wordhist.c
// Usage:   $ ./wordhist <corpus.txt
// Ref: https://nullprogram.com/blog/2023/09/30/
// This is free and unencumbered software released into the public domain.
#include <stddef.h>
#include <stdint.h>

typedef uint8_t   u8;
typedef int32_t   b32;
typedef int32_t   i32;
typedef uint32_t  u32;
typedef uint64_t  u64;
typedef uintptr_t uptr;
typedef char      byte;
typedef ptrdiff_t size;
typedef size_t    usize;

#define sizeof(x)    (size)sizeof(x)
#define alignof(x)   (size)_Alignof(x)
#define countof(a)   (sizeof(a)/sizeof(*(a)))
#define lengthof(s)  (countof(s) - 1)
#define new(a, t, n) (t *)alloc(a, sizeof(t), alignof(t), n)

static void osfail(void);
static i32  oswrite(i32, u8 *, i32);

static void oom(void) {
	static const u8 msg[] = "out of memory\n";
	oswrite(2, (u8 *)msg, lengthof(msg));
	osfail();
}

typedef struct {
	byte *beg;
	byte *end;
} arena;

static byte *alloc(arena *a, size objsize, size align, size count) {
	size avail = a->end - a->beg;
	size padding = -(uptr)a->beg & (align - 1);
	if (count > (avail - padding)/objsize) {
		oom();
	}
	size total = count * objsize;
	byte *p = a->beg + padding;
	a->beg += padding + total;
	for (size i = 0; i < total; i++) {
		p[i] = 0;
	}
	return p;
}

static void copy(u8 *restrict dst, u8 *restrict src, size len) {
	for (size i = 0; i < len; i++) {
		dst[i] = src[i];
	}
}

#define S(s) (s8){(u8 *)(s), lengthof(s)}
typedef struct {
	u8  *buf;
	size len;
} s8;

static s8 s8span(u8 *beg, u8 *end) {
	s8 s = {0};
	s.buf = beg;
	s.len = end - beg;
	return s;
}

static b32 s8equal(s8 a, s8 b) {
	if (a.len != b.len) {
		return 0;
	}
	for (size i = 0; i < a.len; i++) {
		if (a.buf[i] != b.buf[i]) {
			return 0;
		}
	}
	return 1;
}

static size s8cmp(s8 a, s8 b) {
	size len = a.len<b.len ? a.len : b.len;
	for (size i = 0; i < len; i++) {
		size d = a.buf[i] - b.buf[i];
		if (d) {
			return d;
		}
	}
	return a.len - b.len;
}

static u32 s8hash(s8 s) {
	u64 h = 0x100;
	for (size i = 0; i < s.len; i++) {
		h ^= s.buf[i];
		h *= 1111111111111111111u;
	}
	return (h ^ h>>32) & (u32)-1;
}

static s8 s8clone(arena *a, s8 s) {
	s8 c = {0};
	c.buf = new(a, u8, s.len);
	c.len = s.len;
	copy(c.buf, s.buf, s.len);
	return c;
}

typedef struct seen seen;
struct seen {
	seen *next;
	seen *child[4];
	s8	  word;
	size  count;
};

static seen *upsert(seen **s, s8 word, arena *a) {
	for (u32 h = s8hash(word); *s; h *= 31u) {
		if (s8equal((*s)->word, word)) {
			return *s;
		}
		s = &(*s)->child[h>>30];
	}
	*s = new(a, seen, 1);
	(*s)->word = s8clone(a, word);
	return *s;
}

static b32 u8isword(u8 b) {
	static const u8 table[256] = {
		['\t'] = 1, ['\n'] = 1, ['\r'] = 1, [' ' ] = 1, ['!' ] = 1,
		['"' ] = 1, ['#' ] = 1, ['(' ] = 1, [')' ] = 1, ['*' ] = 1,
		['+' ] = 1, [',' ] = 1, ['.' ] = 1, ['/' ] = 1, [':' ] = 1,
		[';' ] = 1, ['<' ] = 1, ['=' ] = 1, ['>' ] = 1, ['?' ] = 1,
		['@' ] = 1, ['[' ] = 1, ['\\'] = 1, [']' ] = 1, ['^' ] = 1,
		['`' ] = 1, ['{' ] = 1, ['|' ] = 1, ['}' ] = 1, ['~' ] = 1,
	};
	return !table[b];
}

typedef struct {
	seen *seen;
	seen *first;
	s8	  word;
	size  cap;
} wordhist;

static void u8push(wordhist *wh, arena *a, u8 b) {
	if (wh->cap == wh->word.len) {
		wh->cap = wh->cap ? wh->cap*2 : 64;
		u8 *word = new(a, u8, wh->cap);
		copy(word, wh->word.buf, wh->word.len);
		wh->word.buf = word;
	}
	wh->word.buf[wh->word.len++] = b;
}

static void finishword(wordhist *wh, arena *a) {
	if (!wh->word.len) {
		return;
	}
	seen *node = upsert(&wh->seen, wh->word, a);
	if (!node->count) {
		node->next = wh->first;
		wh->first = node;
	}
	node->count++;
	wh->word.len = 0;
}

static void countwords(wordhist *wh, arena *a, u8 *buf, size len) {
	if (!len) {
		finishword(wh, a);
	}
	for (size i = 0; i < len; i++) {
		u8 b = buf[i];
		if (u8isword(b)) {
			u8push(wh, a, b);
		} else {
			finishword(wh, a);
		}
	}
}

static b32 seencmp(seen *a, seen *b) {
	if (a->count == b->count) {
		return s8cmp(a->word, b->word) < 0;
	} else {
		return b->count < a->count;
	}
}

static seen *merge(seen *a, seen *b) {
	seen  *head = 0;
	seen **tail = &head;
	while (a && b) {
		if (seencmp(b, a)) {
			*tail = b;
			tail = &b->next;
			b = b->next;
		} else {
			*tail = a;
			tail = &a->next;
			a = a->next;
		}
	}
	*tail = a ? a : b;
	return head;
}

static seen *sort(seen *head, arena scratch) }
	i32 len = 0;
	seen **list = new(&scratch, seen *, 64);
	size *depth = new(&scratch, size, 64);

	while (head) {
		list[len] = head;
		depth[len++] = 0;
		while (head->next && seencmp(head, head->next)) {
			head = head->next;
		}
		seen *last = head;
		head = head->next;
		last->next = 0;

		for (; len>1 && depth[len-1]==depth[len-2]; len--) {
			list[len-2] = merge(list[len-2], list[len-1]);
			depth[len-2]++;
		}
	}

	for (; len > 1; len--) {
		list[len-2] = merge(list[len-2], list[len-1]);
	}
	return len ? list[0] : 0;
}

typedef struct {
	u8 *buf;
	i32 len;
	i32 cap;
	b32 err;
} bufout;

static void flush(bufout *b) {
	if (!b->err && b->len) {
		b->err = !oswrite(1, b->buf, b->len);
		b->len = 0;
	}
}

static void s8write(bufout *b, s8 s) {
	u8 *buf = s.buf;
	u8 *end = s.buf + s.len;
	while (!b->err && buf<end) {
		i32 avail = b->cap - b->len;
		i32 count = avail<end-buf ? avail : (i32)(end-buf);
		copy(b->buf+b->len, buf, count);
		buf += count;
		b->len += count;
		if (b->len == b->cap) {
			flush(b);
		}
	}
}

static void print(bufout *b, size x) {
	u8 buf[32];
	u8 *end = buf + countof(buf);
	u8 *beg = end;
	size t = x<0 ? x : -x;
	do {
		*--beg = '0' - (u8)(t%10);
	} while (t /= 10);
	if (x < 0) {
		*--beg = '-';
	}
	s8write(b, s8span(beg, end));
}

static u32 wordhist_main(arena a) {
	wordhist wh[1] = {0};
	i32 cap = 1<<12;
	u8 *buf = new(&a, u8, cap);

	for (i32 len = -1; len;) {
		len = osread(0, buf, cap);
		countwords(wh, &a, buf, len);
	}

	bufout stdout[1] = {0};
	stdout->cap = cap;
	stdout->buf = buf;
	for (seen *w = sort(wh->first, a); w; w = w->next) {
		print(stdout, w->count);
		s8write(stdout, S(" "));
		s8write(stdout, w->word);
		s8write(stdout, S("\n"));
	}
	flush(stdout);
	return stdout->err;
}


#ifdef _WIN32
typedef struct {int dummy;} *handle;

#define W32(r) __declspec(dllimport) r __stdcall
W32(byte *) VirtualAlloc(byte *, usize, u32, u32);
W32(handle) GetStdHandle(u32);
W32(b32)    ReadFile(handle, u8 *, u32, u32 *, void *);
W32(b32)    WriteFile(handle, u8 *, u32, u32 *, void *);
W32(void)   ExitProcess(u32);

static void osfail(void) {
	ExitProcess(1);
}

static i32 osread(i32 fd, u8 *buf, i32 cap) {
	handle stdin = GetStdHandle(-10 - fd);
	u32 len;
	ReadFile(stdin, buf, cap, &len, 0);
	return len;
}

static b32 oswrite(i32 fd, u8 *buf, i32 len) {
	handle stdout = GetStdHandle(-10 - fd);
	u32 dummy;
	return WriteFile(stdout, buf, len, &dummy, 0);
}

void mainCRTStartup(void) {
	enum { CAP = 1<<28 };
	arena a = {0};
	a.beg = VirtualAlloc(0, CAP, 0x3000, 4);
	a.end = a.beg + CAP;
	u32 r = wordhist_main(a);
	ExitProcess(r);
}

#else
#include <stdlib.h>
#include <unistd.h>

static void osfail(void) {
	_exit(1);
}

static i32 osread(i32 fd, u8 *buf, i32 cap) {
	return (i32)read(fd, buf, cap);
}

static b32 oswrite(i32 fd, u8 *buf, i32 len) {
	for (i32 off = 0; off < len;) {
		i32 r = (i32)write(fd, buf+off, len-off);
		if (r < 1) {
			return 0;
		}
		off += r;
	}
	return 1;
}

int main(void) {
	enum { CAP = 1<<28 };
	arena a = {0};
	a.beg = malloc(CAP);
	a.end = a.beg + CAP;
	return wordhist_main(a);
}
#endif


---
[**2]
https://github.com/skeeto/scratch/blob/master/misc/asmint.c

// "assembler-interpreter" for a toy assembly language
//
// See enum mnemonic for syntax overview. The ISA has 26 32-bit
// registers (a-z), a 3-way comparison flag, and a call stack.
//
// Porting note: The host must implement os_oom() and os_loadstdin(),
// call run() with some working memory, write the returned buffers to
// stdout/stderr, and exit with the given status.
//
// Example program (random number generator):
//         mov  s, 12345
//         mov  c, 20
// _loop:  mov  h, c
//         call rand16
//         cmp  r, 0
//         jg   _print
//         mul  r, -1
// _print: msg  r
//         dec  c
//         cmp  c, 0
//         jg   _loop
//         end
// rand16: mul  s, 1615571549
//         inc  s
//         mov  r, s
//         div  r, 65536
//         ret
//
// Ref: https://github.com/youssefeldesouky/Assembler-Interpreter
// This is free and unencumbered software released into the public domain.

#include <stddef.h>
#include <stdint.h>

typedef uint8_t   u8;
typedef int32_t   b32;
typedef int32_t   i32;
typedef uint32_t  u32;
typedef uint64_t  u64;
typedef intptr_t  iptr;
typedef uintptr_t uptr;
typedef char      byte;
typedef ptrdiff_t size;

#define sizeof(x)    (size)sizeof(x)
#define alignof(x)   (size)_Alignof(x)
#define countof(a)   (sizeof(a) / sizeof(*(a)))
#define lengthof(s)  (countof(s) - 1)
#define new(a, t, n) (t *)alloc(a, sizeof(t), alignof(t), n)

static void os_oom(void);

typedef struct {
	byte *beg;
	byte *end;
} arena;

#if __GNUC__
__attribute((malloc, alloc_size(2, 4)))
#endif
static byte *alloc(arena *a, size objsize, size align, size count) {
	size avail = a->end - a->beg;
	size padding = -(uptr)a->beg & (align - 1);
	if (count > (avail - padding)/objsize) {
		os_oom();
	}
	size total = objsize * count;
	byte *p = a->beg + padding;
	a->beg += padding + total;
	for (size i = 0; i < total; i++) {
		p[i] = 0;
	}
	return p;
}

static arena newscratch(arena *a) {
	arena scratch = {0};
	size cap = (a->end - a->beg) / 2;
	scratch.beg = new(a, byte, cap);
	scratch.end = scratch.beg + cap;
	return scratch;
}

#define S(s) (s8){(u8 *)s, lengthof(s)}
typedef struct {
	u8  *buf;
	size len;
} s8;

static s8 s8span(u8 *beg, u8 *end) {
	s8 s = {0};
	s.buf = beg;
	s.len = end - beg;
	return s;
}

static b32 s8equal(s8 a, s8 b) {
	if (a.len != b.len) {
		return 0;
	}
	size mismatch = 0;
	for (size i = 0; i < a.len; i++) {
		mismatch += a.buf[i] != b.buf[i];
	}
	return !mismatch;
}

static u64 s8hash(s8 s) {
	u64 h = 0x100;
	for (size i = 0; i < s.len; i++) {
		h ^= s.buf[i];
		h *= 1111111111111111111;
	}
	return h ^ h>>32;
}

typedef struct {
	i32 value;
	b32 ok;
} i32result;

static i32result s8i32(s8 s) {
	size i = 0;
	b32 neg = 0;
	u32 value = 0;
	i32result r = {0};
	u32 limit = 0x7fffffff;

	switch (*s.buf) {
	case '-':
		i = 1;
		neg = 1;
		limit = 0x80000000;
		break;
	case '+':
		i = 1;
		break;
	}

	for (; i < s.len; i++) {
		i32 d = s.buf[i] - '0';
		if (value > (limit - d)/10) {
			return r;
		}
		value = value*10 + d;
	}

	r.value = neg ? -value : value;
	r.ok = 1;
	return r;
}

static b32 whitespace(u8 c) {
	return c=='\t' || c=='\r' || c== ' ';
}

static b32 digit(u8 c) {
	return c>='0' && c<='9';
}

static b32 upper(u8 c) {
	return c>='A' && c<='Z';
}

static b32 lower(u8 c) {
	return c>='a' && c<='z';
}

static b32 letter(u8 c) {
	return upper(c) || lower(c);
}

static b32 identifier(u8 c) {
	return c=='_' || letter(c) || digit(c);
}

static s8 trim(s8 s) {
	if (!s.len) {
		return s;
	}
	u8 *p = s.buf;
	u8 *e = p + s.len;
	for (; p<e && whitespace(*p); p++) {}
	s.buf = p;
	s.len = e - p;
	return s;
}

typedef enum {
	tok_error,
	tok_eof,
	tok_newline,
	tok_comma,
	tok_colon,
	tok_integer,
	tok_string,
	tok_register,
	tok_identifier,
} toktype;

typedef struct {
	s8      src;
	s8      token;
	toktype type;
} token;

static token lex(s8 s) {
	token r = {0};

	for (;;) {
		s = trim(s);
		if (!s.len) {
			r.type = tok_eof;
			return r;
		} else if (*s.buf == ';') {
			u8 *buf = s.buf;
			u8 *end = s.buf + s.len;
			for (buf++; buf<end && *buf!='\n'; buf++) {}
			s = s8span(buf, end);
			continue;
		}
		break;
	}

	u8 *beg = s.buf;
	u8 *end = s.buf + s.len;
	u8 *buf = beg;

	if (*buf == '\n') {
		r.src = s8span(++buf, end);
		r.token = s8span(beg, buf);
		r.type = tok_newline;
		return r;
	}

	if (*buf == ',') {
		r.src = s8span(++buf, end);
		r.token = s8span(beg, buf);
		r.type = tok_comma;
		return r;
	}

	if (*buf == ':') {
		r.src = s8span(++buf, end);
		r.token = s8span(beg, buf);
		r.type = tok_colon;
		return r;
	}

	if (*buf == '\'') {
		for (buf++; buf<end && *buf!='\''; buf++) {}
		if (buf == end) {
			return r;
		}
		r.src = s8span(buf+1, end);
		r.token = s8span(beg+1, buf);
		r.type = tok_string;
		return r;
	}

	if (*buf=='-' || *buf=='+') {
		for (buf++; buf<end && digit(*buf); buf++) {}
		r.src = s8span(buf, end);
		r.token = s8span(beg, buf);
		if (r.token.len < 2) {
			return r;
		}
		r.type = tok_integer;
		return r;
	}

	if (digit(*buf)) {
		for (buf++; buf<end && digit(*buf); buf++) {}
		r.src = s8span(buf, end);
		r.token = s8span(beg, buf);
		r.type = tok_integer;
		return r;
	}

	if (letter(*buf) || *buf=='_') {
		for (buf++; buf<end && identifier(*buf); buf++) {}
		r.src = s8span(buf, end);
		r.token = s8span(beg, buf);
		b32 isregister = r.token.len==1 && lower(*r.token.buf);
		r.type = isregister ? tok_register : tok_identifier;
		return r;
	}

	return r;
}

typedef enum {
	m_null,
	m_inc,  // inc R
	m_dec,  // dec R
	m_ret,  // ret
	m_end,  // end    successful program halt
	m_mov,  // mov R, R|I
	m_add,  // add R, R|I
	m_sub,  // sub R, R|I
	m_mul,  // mul R, R|I
	m_div,  // div R, R|I
	m_cmp,  // cmp [R, I]|[I, R]|[R, R]
	m_jmp,  // jmp  L
	m_jne,  // jne  L
	m_je,   // je   L
	m_jge,  // jge  L
	m_jg,   // jg   L
	m_jle,  // jle  L
	m_jl,   // jl   L
	m_call, // call L
	m_msg,  // msg [string|R, *]    print operands, then a newline
} mnemonic;

static mnemonic tomnemonic(s8 s) {
	static const s8 names[] = {
		#define E(s) {(u8 *)s, lengthof(s)}
		E("inc"), E("dec"), E("ret"), E("end"),
		E("mov"), E("add"), E("sub"), E("mul"), E("div"),
		E("cmp"),
		E("jmp"), E("jne"), E("je" ), E("jge"), E("jg" ), E("jle"), E("jl" ),
		E("call"),
		E("msg"),
	};
	for (i32 i = 0; i < countof(names); i++) {
		if (s8equal(names[i], s)) {
			return i + 1;
		}
	}
	return 0;
}

typedef struct msg msg;
struct msg {
	msg *next;
	s8   string;
	u8   reg;
};

typedef enum {
	op_abort,
	op_inc, op_dec,
	op_movri, op_movrr,
	op_addri, op_addrr,
	op_subri, op_subrr,
	op_mulri, op_mulrr,
	op_divri, op_divrr,
	op_cmpii, op_cmpir, op_cmpri, op_cmprr,
	op_jmp,
	op_jne, op_je, op_jge, op_jg, op_jle, op_jl,
	op_call, op_ret,
	op_msg,
	op_end
} opcode;

typedef struct insn insn;
struct insn {
	insn   *next;
	msg    *head;
	s8     label;
	size   addr;
	size   lineno;
	opcode op;
	i32    imm[2];
	u8     reg[2];
};

typedef struct {
	s8     src;
	insn *insn;
} insnresult;

static insnresult parseinsn(mnemonic m, s8 src, arena *a) {
	insnresult r = {0};
	insn *n = new(a, insn, 1);
	msg **tail = &n->head;

	token t = {0};
	t.src = src;

	i32result ir;
	switch (m) {
	case m_null:
		return r;

	case m_mov:
	case m_add:
	case m_sub:
	case m_mul:
	case m_div:
		n->op = op_movri + 2*(m - m_mov);
		t = lex(t.src);
		switch (t.type) {
		default:
			return r;
		case tok_register:
			n->reg[0] = *t.token.buf;
			break;
		}

		t = lex(t.src);
		if (t.type != tok_comma) {
			return r;
		}

		t = lex(t.src);
		switch (t.type) {
		default:
			return r;
		case tok_integer:
			ir = s8i32(t.token);
			if (!ir.ok) {
				return r;
			}
			n->imm[1] = ir.value;
			break;
		case tok_register:
			n->op++;  // op_XXXrr
			n->reg[1] = *t.token.buf;
			break;
		}
		break;

	case m_cmp:
		t = lex(t.src);
		switch (t.type) {
		default:
			return r;
		case tok_integer:
			n->op = op_cmpii;
			ir = s8i32(t.token);
			if (!ir.ok) {
				return r;
			}
			n->imm[0] = ir.value;
			break;
		case tok_register:
			n->op = op_cmpri;
			n->reg[0] = *t.token.buf;
			break;
		}

		t = lex(t.src);
		if (t.type != tok_comma) {
			return r;
		}

		t = lex(t.src);
		switch (t.type) {
		default:
			return r;
		case tok_integer:
			ir = s8i32(t.token);
			if (!ir.ok) {
				return r;
			}
			n->imm[1] = ir.value;
			break;
		case tok_register:
			n->op++;  // op_XXXrr
			n->reg[1] = *t.token.buf;
			break;
		}
		if (n->op == op_cmpii) {
			return r;  // reject "cmp int, int"
		}
		break;

	case m_jmp:
	case m_jne:
	case m_je:
	case m_jge:
	case m_jg:
	case m_jle:
	case m_jl:
	case m_call:
		t = lex(t.src);
		if (t.type != tok_identifier) {
			return r;
		}
		n->label = t.token;
		n->op = op_jne + (m - m_jne);
		break;

	case m_msg:
		n->op = op_msg;
		for (toktype last = 0;;) {
			t = lex(t.src);
			switch (t.type) {
			case tok_newline:
			case tok_eof:
				if (last != tok_comma) {
					r.insn = n;
					r.src = t.src;
				}
				return r;
			case tok_string:
				if (last && last!=tok_comma) {
					return r;
				}
				*tail = new(a, msg, 1);
				(*tail)->string = t.token;
				tail = &(*tail)->next;
				break;
			case tok_register:
				*tail = new(a, msg, 1);
				(*tail)->reg = *t.token.buf;
				tail = &(*tail)->next;
				break;
			case tok_comma:
				if (!last || last == tok_comma) {
					return r;
				}
				break;
			default:
				return r;
			}
			last = t.type;
		}

	case m_inc:
	case m_dec:
		n->op = op_inc + (m - m_inc);
		t = lex(t.src);
		switch (t.type) {
		case tok_register:
			n->reg[0] = *t.token.buf;
			break;
		default:
			return r;
		}
		break;

	case m_ret: n->op = op_ret; break;
	case m_end: n->op = op_end; break;
	}

	t = lex(t.src);
	switch (t.type) {
	case tok_eof:
	case tok_newline:
		r.insn = n;
		r.src = t.src;
		return r;
	default:
		return r;
	}
}

typedef struct labels labels;
struct labels {
	labels *child[4];
	s8      label;
	size    addr;
};

static size *upsert(labels **t, s8 label, arena *a) {
	for (u64 h = s8hash(label); *t; h = h>>62 | h<<2) {
		if (s8equal((*t)->label, label)) {
			return &(*t)->addr;
		}
		t = &(*t)->child[h>>62];
	}
	if (!a) {
		return 0;
	}
	*t = new(a, labels, 1);
	(*t)->label = label;
	return &(*t)->addr;
}

typedef struct {
	insn *head;
	size  lineno;
	b32   ok;
} ast;

// Note: returns pointers into the source buffer.
static ast parse(s8 src, arena *perm, arena scratch) {
	ast r = {0};
	r.lineno = 1;

	token t = {0};
	t.src = src;

	size addr = 0;
	labels *table = 0;
	insn **tail = &r.head;

	for (;;) {
		mnemonic m;
		t = lex(t.src);
		switch (t.type) {
		case tok_error:
		case tok_comma:
		case tok_colon:
		case tok_integer:
		case tok_string:
		case tok_register:
			return r;

		case tok_newline:
			r.lineno++;
			break;

		case tok_eof:
			// Populate labels with addresses
			for (insn *n = r.head; n; n = n->next) {
				if (n->label.buf) {
					size *value = upsert(&table, n->label, 0);
					if (!value) {
						r.lineno = n->lineno;
						return r;  // label not found
					}
					n->addr = *value;
				}
			}
			r.ok = 1;
			return r;

		case tok_identifier:
			m = tomnemonic(t.token);
			if (m) {
				insnresult ir = parseinsn(m, t.src, perm);
				if (!ir.insn) {
					return r;
				}
				t.src = ir.src;
				ir.insn->lineno = r.lineno++;
				*tail = ir.insn;
				tail = &(*tail)->next;
				addr++;
			} else {
				s8 label = t.token;
				t = lex(t.src);
				if (t.type != tok_colon) {
					return r;
				}
				*upsert(&table, label, &scratch) = addr;
			}
			break;
		}
	}
}

typedef struct {
	u8 op;
	u8 reg[2];
	union {
		i32  imm;
		size addr;
		msg *head;
	} operand;
} word;

// Note: retains references to the AST.
static word *assemble(insn *head, arena *perm) {
	size len = 0;
	for (insn *n = head; n; n = n->next, len++) {}

	size i = 0;
	word *image = new(perm, word, len+1);
	for (insn *n = head; n; n = n->next, i++) {
		image[i].op = (u8)n->op;
		switch (n->op) {
		case op_abort:
		case op_cmpii:
			return 0;

		case op_ret:
		case op_end:
			break;

		case op_inc:
		case op_dec:
			image[i].reg[0] = n->reg[0];
			break;

		case op_movri:
		case op_addri:
		case op_subri:
		case op_mulri:
		case op_divri:
		case op_cmpri:
			image[i].reg[0] = n->reg[0];
			image[i].operand.imm = n->imm[1];
			break;

		case op_movrr:
		case op_addrr:
		case op_subrr:
		case op_mulrr:
		case op_divrr:
		case op_cmprr:
			image[i].reg[0] = n->reg[0];
			image[i].reg[1] = n->reg[1];
			break;

		case op_cmpir:
			image[i].operand.imm = n->imm[0];
			image[i].reg[1] = n->reg[1];
			break;

		case op_jmp:
		case op_jne:
		case op_je:
		case op_jge:
		case op_jg:
		case op_jle:
		case op_jl:
		case op_call:
			image[i].operand.addr = n->addr;
			break;

		case op_msg:
			image[i].operand.head = n->head;
			break;
		}
	}

	return image;
}

typedef struct {
	u8  *buf;
	size len;
	size cap;
	b32  err;
} output;

static s8 tos8(output *o) {
	s8 s  = {0};
	s.buf = o->buf;
	s.len = o->len;
	return s;
}

static void print(output *o, s8 s) {
	size avail = o->cap - o->len;
	size count = s.len<avail ? s.len : avail;
	u8 *dst = o->buf + o->len;
	for (size i = 0; i < count; i++) {
		dst[i] = s.buf[i];
	}
	o->len += count;
	o->err |= count != s.len;
}

static void printi32(output *o, i32 v) {
	u8	buf[16];
	u8 *end = buf + countof(buf);
	u8 *beg = end;
	i32 t = v<0 ? v : -v;
	do {
		*--beg = '0' - (u8)(t%10);
	} while (t /= 10);
	if (v < 0) {
		*--beg = '-';
	}
	print(o, s8span(beg, end));
}

typedef struct {
	output out;
	b32    ok;
} result;

// Note: returned buffer is allocated out of scratch.
static result execute(word *image, arena scratch) {
	result r = {0};

	r.out.cap = 1<<16; // arbitrary capacity (TODO: os_write() to flush?)
	r.out.buf = new(&scratch, u8, r.out.cap);

	size len = 0;
	size cap = 1<<10;
	size *stack = new(&scratch, size, cap);

	i32 cmp = 0;
	i32 regs[26] = {0};

	for (size i = 0;; i++) {
		i32 a, b;
		word *w = image + i;
		switch (w->op) {
		case op_abort:
			return r;

		case op_inc:
			regs[w->reg[0]-'a'] += (u32)1;
			break;

		case op_dec:
			regs[w->reg[0]-'a'] -= (u32)1;
			break;

		case op_movri:
			regs[w->reg[0]-'a'] = w->operand.imm;
			break;

		case op_movrr:
			regs[w->reg[0]-'a'] = regs[w->reg[1]-'a'];
			break;

		case op_addri:
			regs[w->reg[0]-'a'] += (u32)w->operand.imm;
			break;

		case op_addrr:
			regs[w->reg[0]-'a'] += (u32)regs[w->reg[1]-'a'];
			break;

		case op_subri:
			regs[w->reg[0]-'a'] -= (u32)w->operand.imm;
			break;

		case op_subrr:
			regs[w->reg[0]-'a'] -= (u32)regs[w->reg[1]-'a'];
			break;

		case op_mulri:
			regs[w->reg[0]-'a'] *= (u32)w->operand.imm;
			break;

		case op_mulrr:
			regs[w->reg[0]-'a'] *= (u32)regs[w->reg[1]-'a'];
			break;

		case op_divri:
			switch (w->operand.imm) {
			case  0:
				return r;  // divide by zero
			case -1:
				regs[w->reg[0]-'a'] = -(u32)regs[w->reg[0]-'a'];
				break;
			default:
				regs[w->reg[0]-'a'] /= w->operand.imm;
			}
			break;

		case op_divrr:
			switch (regs[w->reg[1]-'a']) {
			case  0:
				return r;  // divide by zero
			case -1:
				regs[w->reg[0]-'a'] = -(u32)regs[w->reg[0]-'a'];
				break;
			default:
				regs[w->reg[0]-'a'] /= regs[w->reg[1]-'a'];
			}
			break;

		case op_cmpii:
			return r;

		case op_cmpir:
			a = w->operand.imm;
			b = regs[w->reg[1]-'a'];
			cmp = (a>b) - (a<b);
			break;

		case op_cmpri:
			a = regs[w->reg[0]-'a'];
			b = w->operand.imm;
			cmp = (a>b) - (a<b);
			break;

		case op_cmprr:
			a = regs[w->reg[0]-'a'];
			b = regs[w->reg[1]-'a'];
			cmp = (a>b) - (a<b);
			break;

		case op_jmp:
			i = w->operand.addr - 1;
			break;

		case op_jne:
			if (cmp) i = w->operand.addr - 1;
			break;

		case op_je:
			if (!cmp) i = w->operand.addr - 1;
			break;

		case op_jge:
			if (cmp >= 0) i = w->operand.addr - 1;
			break;

		case op_jg:
			if (cmp > 0) i = w->operand.addr - 1;
			break;

		case op_jle:
			if (cmp <= 0) i = w->operand.addr - 1;
			break;

		case op_jl:
			if (cmp < 0) i = w->operand.addr - 1;
			break;

		case op_call:
			if (len == cap) {
				return r;  // stack overflow
			}
			stack[len++] = i;
			i = w->operand.addr - 1;
			break;

		case op_ret:
			if (!len) {
				return r;  // stack empty
			}
			i = stack[--len];
			break;

		case op_msg:
			for (msg *m = w->operand.head; m; m = m->next) {
				if (m->string.buf) {
					print(&r.out, m->string);
				} else {
					printi32(&r.out, regs[m->reg-'a']);
				}
			}
			print(&r.out, S("\n"));
			break;

		case op_end:
			r.ok = 1;
			return r;
		}
	}
}

static s8 os_loadstdin(arena *);

typedef struct {
	s8  out;
	s8  err;
	i32 status;
} status;

static status run(arena heap) {
	status r = {0};

	arena scratch = newscratch(&heap);

	output stderr = {0};
	stderr.cap = 1<<8;
	stderr.buf = new(&heap, u8, stderr.cap);

	s8 src = os_loadstdin(&heap);

	ast program = parse(src, &heap, scratch);
	if (!program.ok) {
		print(&stderr, S("<stdin>:"));
		printi32(&stderr, (i32)program.lineno);
		print(&stderr, S(": invalid program\n"));
		r.err = tos8(&stderr);
		r.status = 2;
		return r;
	}

	word *image = assemble(program.head, &heap);
	result er = execute(image, scratch);
	if (!er.ok) {
		r.err = S("fatal error: execution aborted\n");
		r.status = 1;
		return r;
	}
	r.out = tos8(&er.out);
	return r;
}


#if FUZZ
// $ afl-gcc-fast -DFUZZ -g3 -fsanitize=undefined asmint.c
// $ afl-fuzz -i Assembler-Interpreter/programs -o results ./a.out
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

__AFL_FUZZ_INIT();

static uptr oom[5];
void os_oom(void)
{
	__builtin_longjmp(oom, 1);
}

static s8 os_loadstdin(arena *a) {
	__builtin_trap();
}

int main(void)
{
	__AFL_INIT();
	s8	  src = {0};
	size  cap = 1<<21;
	byte *mem = malloc(cap);
	u8	 *buf = __AFL_FUZZ_TESTCASE_BUF;
	while (__AFL_LOOP(10000)) {
		src.len = __AFL_FUZZ_TESTCASE_LEN;
		src.buf = realloc(src.buf, src.len);
		memcpy(src.buf, buf, src.len);
		if (__builtin_setjmp(oom)) {
			continue;
		}
		arena heap = {0};
		heap.beg = mem;
		heap.end = mem + cap;
		ast program = parse(src, &heap, newscratch(&heap));
		if (program.ok) {
			assemble(program.head, &heap);
		}
	}
}


#elif _WIN32
// w64devkit $ cc -nostartfiles -o asmint asmint
// MSVC		 $ cl asmint.c /link /subsystem:console kernel32.lib
// Usage	 $ ./asmint <program.asm

#define W32(r) __declspec(dllimport) r __stdcall
W32(byte *) VirtualAlloc(byte *, size, u32, u32);
W32(iptr)   GetStdHandle(u32);
W32(b32)    WriteFile(iptr, u8 *, u32, u32 *, void *);
W32(b32)    ReadFile(iptr, u8 *, u32, u32 *, void *);
W32(b32)    GetFileSizeEx(iptr, u64 *);
W32(void)   ExitProcess(u32);

static void os_oom(void) {
	uptr stderr = GetStdHandle(-12);
	static u8 msg[] = "out of memory\n";
	u32 dummy;
	WriteFile(stderr, msg, lengthof(msg), &dummy, 0);
	ExitProcess(101);
}

static s8 os_loadstdin(arena *a) {
	s8 r = {0};

	iptr stdin = GetStdHandle(-10);
	u64 len64;
	GetFileSizeEx(stdin, &len64);
	if (len64 > 0x7fffffff) {
		return r;
	}
	u32 len = (u32)len64;

	r.buf = new(a, u8, len);
	if (ReadFile(stdin, r.buf, len, &len, 0)) {
		r.len = len;
	}
	return r;
}

#ifdef __i386__
__attribute((force_align_arg_pointer))
#endif
void mainCRTStartup(void)
{
	size cap = 1<<24;
	arena heap = {0};
	heap.beg = VirtualAlloc(0, cap, 0x3000, 4);
	heap.end = heap.beg + cap;

	status r = run(heap);
	u32 dummy;
	uptr stdout = GetStdHandle(-11);
	uptr stderr = GetStdHandle(-12);
	if (r.err.len) {
		WriteFile(stderr, r.err.buf, (u32)r.err.len, &dummy, 0);
	}
	if (r.out.buf) {
		if (!WriteFile(stdout, r.out.buf, (u32)r.out.len, &dummy, 0)) {
			r.status = 100;
		}
	}
	ExitProcess(r.status);
}


#else
// $ cc -o asmint asmint
// $ ./asmint <program.asm
#include <stdio.h>
#include <stdlib.h>

static s8 os_loadstdin(arena *a) {
	s8 s = {0};
	b32 err = 0;

	err |= fseek(stdin, 0, SEEK_END);
	long len = ftell(stdin);
	err |= len < 1;
	err |= fseek(stdin, 0, SEEK_SET);
	if (err) {
		return s;
	}

	s.buf = new(a, u8, len);
	s.len = fread(s.buf, 1, len, stdin);
	return s;
}

static void os_oom(void) {
	exit(101);
}

int main(void) {
	size cap = 1<<24;
	arena heap = {0};
	heap.beg = malloc(cap);
	heap.end = heap.beg + cap;

	status r = run(heap);
	if (r.err.len) {
		fwrite(r.err.buf, r.err.len, 1, stderr);
	}
	if (r.out.len) {
		fwrite(r.out.buf, r.out.len, 1, stdout);
	}
	fflush(stdout);
	return ferror(stdout) ? 100 : 0;
}

#endif

