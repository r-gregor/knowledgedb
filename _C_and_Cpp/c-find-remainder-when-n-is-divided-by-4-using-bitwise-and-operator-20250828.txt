filename: c-find-remainder-when-n-is-divided-by-4-using-bitwise-and-operator-20250828.txt
https://www.geeksforgeeks.org/dsa/find-the-remainder-when-n-is-divided-by-4-using-bitwise-and-operator/

Find the remainder when N is divided by 4 using Bitwise AND operator
12 Jul, 2025

   Given a number N, the task is to find the remainder when N is divided by 4 using Bitwise AND
   operator.

   Examples:
     Input: N = 98
     Output: 2
     Explanation: 98 % 4 = 2. Hence the output is 2.

     Input: 200
     Output: 0
     Explanation: 200 % 4 = 0. Hence output is 0.

   Naive approach:
   For solving the above-mentioned problem we can use a na√Øve method by using the Modulo (%)
   operator to find the remainder. But, the Modulo operator is computationally expensive and the method
   is inefficient.

   C++
#include <iostream>
using namespace std;

int main() {
	int N = 98;
	int rem = N % 4;
	cout << rem << endl;
	return 0;
}

   Java
class Main {
	public static void main(String[] args) {
		int N = 98;
		int rem = N % 4;
		System.out.println(rem);
	}
}

   Python3
def findRemainder(n: int) -> int:
	return n % 4

# Driver code
n = 98
print(findRemainder(n))

   C#
using System;

class Program {
	static void Main() {
		int N = 98;
		int rem = N % 4;  // Calculate the remainder when N is divided by 4
		Console.WriteLine(rem);  // Print the remainder
	}
}

   JavaScript
function main() {
	let N = 98;
	let rem = N % 4;
	console.log(rem);
}

main();

   Output
2

   C

#include <stdio.h>

int main(int argc, char **argv) {

	int N = 98;
	int rem = N % 4;
	printf("%d\n", rem);

	return 0;
}


   Efficient Approach:
   If we carefully observe the binary representation of N and its remainder with 4, we observe that
   remainder is simply the rightmost two bits in N. To get the rightmost two bits in number N, we
   perform bitwise AND (&) with 3 because 3 in binary is 0011. To understand the approach better let us
   have a look at the image below:

   N ----> (N)2     Reminder after dividig by 4 ---> Binary
   0        0000    0                                00
   1        0001    1                                01
   2        0010    2                                10
   3        0011    3                                11
   4        0100    0                                00
   5        0101    1                                01
   6        0110    2                                10
   7        0111    3                                11
              --                                     ^
              |                                      |
              +--------------------------------------+
   (Observe that remainder is the rightmost two bits in binary representation of N)

   Below is the implementation of the above approach:

   C++
// C++ implementation to find N
// modulo 4 using Bitwise AND operator

#include <bits/stdc++.h>
using namespace std;

// Function to find the remainder
int findRemainder(int n) {
	// Bitwise AND with 3
	int x = n & 3;

	// Return  x
	return x;
}

// Driver code
int main() {

	int N = 43;
	int ans = findRemainder(N);
	cout << ans << endl;

	return 0;
}

   C
// C implementation to find N
// modulo 4 using Bitwise AND operator

#include <stdio.h>

// Function to find the remainder
int findRemainder(int n) {

	// Bitwise AND with 3
	int x = n & 3;

	// return  x
	return x;
}

// Driver code
int main() {

	int N = 43;
	int ans = findRemainder(N);
	printf("%d", ans);

	return 0;
}

   Java
// Java implementation to find N
// modulo 4 using Bitwise AND operator

class Main {

	// Driver code
	public static void main(String[] args) {

		int N = 43;
		int ans = findRemainder(N);
		System.out.println(ans);
	}

	// Function to find the remainder
	public static int findRemainder(int n) {
		// Bitwise AND with 3
		int x = n & 3;

		// return  x
		return x;
	}
}

   Python 3
# Python 3 implementation to find N
# modulo 4 using Bitwise AND operator

# Function to find the remainder
def findRemainder(n):
	# Bitwise AND with 3
	x = n & 3

	# Return  x
	return x

# Driver code
if __name__ == '__main__':
	N = 43

	ans = findRemainder(N)

	print(ans)

# This code is contributed by Surendra_Gangwar

   C#
// C# implementation to find N
// modulo 4 using Bitwise AND operator
using System;

class GFG {

	// Driver code
	public static void Main() {

		int N = 43;
		int ans = findRemainder(N);
		Console.Write(ans);
	}

	// Function to find the remainder
	public static int findRemainder(int n) {
		// Bitwise AND with 3
		int x = n & 3;

		// return  x
		return x;
	}
}

# This code is contributed by chitranayal

   JavaScript
<script>

// Javascript program implementation to find N
// modulo 4 using Bitwise AND operator

// Function to find the remainder
	function findRemainder(n) {
		// Bitwise AND with 3
		let x = n & 3;

		// return  x
		return x;
	}

// Driver Code
	let N = 43;
	let ans = findRemainder(N);
	document.write(ans);

</script>

   Output
3

   Time Complexity: O(1)
   Auxiliary Space: O(1)

   Another Approach:
   We can solve this problem using	right shift operator (>>). The right shift operator shifts the bits
   of a number to the right by a specified number of positions. When we shift a number to the right by 2
   positions (i.e., n >> 2), we effectively divide it by 4 and get the quotient as the result.

   If we multiply the quotient by 4 and subtract it from the original number, we get the remainder. This
   can be expressed mathematically as:

   N = 4 * (N >> 2) + (N & 3)

   Below is the implementation of the above approach:
   C++
// C++ implementation to find N
// modulo 4 using Bitwise AND operator

#include <bits/stdc++.h>
using namespace std;

// Function to find the remainder
int findRemainder(int n) {
	// find quotient using right shift operator
	int quotient = n >> 2;

	// find remainder using bitwise AND operator
	int remainder = n - (quotient << 2);

	return remainder;
}


// Driver code
int main() {
	int N = 43;
	int ans = findRemainder(N);
	cout << ans << endl;

	return 0;
}

   C
#include<stdio.h>

// Function to find the remainder
int find_remainder(int n) {
	// find quotient using right shift operator
	int quotient = n >> 2;

	// find remainder using bitwise AND operator
	int remainder = n - (quotient << 2);

	return remainder;
}

// Driver code
int main() {
	int N = 43;
	int ans = find_remainder(N);
	printf("%d\n", ans);
	return 0;
}

   Java
public class Main {
	// Function to find the remainder
	public static int findRemainder(int n) {
		// find quotient using right shift operator
		int quotient = n >> 2;

		// find remainder using bitwise AND operator
		int remainder = n - (quotient << 2);

		return remainder;
	}

	// Driver code
	public static void main(String[] args) {
		int N = 43;
		int ans = findRemainder(N);
		System.out.println(ans);
	}
}
// This code is contributed by Prajwal Kandekar

   Python3
# Function to find the remainder
def find_remainder(n):
	# find quotient using right shift operator
	quotient = n >> 2

	# find remainder using bitwise AND operator
	remainder = n - (quotient << 2)

	return remainder

# Driver code
if __name__ == '__main__':
	N = 43
	ans = find_remainder(N)
	print(ans)

   C#
using System;

class Program {
	// Function to find the remainder
	static int FindRemainder(int n) {
		// find quotient using right shift operator
		int quotient = n >> 2;

		// find remainder using bitwise AND operator
		int remainder = n - (quotient << 2);

		return remainder;
	}

	// Main function
	static void Main(string[] args) {
		int N = 43;
		int ans = FindRemainder(N);
		Console.WriteLine(ans);
	}
}

   JavaScript
// JS implementation to find N
// modulo 4 using Bitwise AND operator

// Function to find the remainder
function findRemainder(n) {
	// find quotient using right shift operator
	let quotient = n >> 2;

	// find remainder using bitwise AND operator
	let remainder = n - (quotient << 2);

	return remainder;
}


// Driver code
let N = 43;
let ans = findRemainder(N);
console.log(ans);

   Time Complexity: O(1)
   Auxiliary Space: O(1)

   Approach : Bitwise AND operator approach

   Steps:
   Calculate the last two bits of the given number by performing a Bitwise AND operation with 3 (11 in
   binary).

   Return the result based on the following cases:
   a. If the last two bits are 00, then the remainder is 0.
   b. If the last two bits are 01, then the remainder is 1.
   c. If the last two bits are 10, then the remainder is 2.
   d. If the last two bits are 11, then the remainder is 3.

   Here is the implementation of above approach:-

   C++
#include <iostream>
using namespace std;

int remainderBy4(int n) {
	int lastTwoBits = n & 3;
	if (lastTwoBits == 0) {
		return 0;
	} else if (lastTwoBits == 1) {
		return 1;
	} else if (lastTwoBits == 2) {
		return 2;
	} else {
		return 3;
	}
}

// Driver code
int main() {
	int n = 43;
	cout << remainderBy4(n) << endl;
	return 0;
}

   Java
public class Main {
	public static int remainderBy4(int n) {
		int lastTwoBits = n & 3;
		if (lastTwoBits == 0) {
			return 0;
		} else if (lastTwoBits == 1) {
			return 1;
		} else if (lastTwoBits == 2) {
			return 2;
		} else {
			return 3;
		}
	}

	// Driver code
	public static void main(String[] args) {
		int n = 43;
		System.out.println(remainderBy4(n));
	}
}

   Python3
def remainderBy4(n: int) -> int:
	lastTwoBits = n & 3
	if lastTwoBits == 0:
		return 0
	elif lastTwoBits == 1:
		return 1
	elif lastTwoBits == 2:
		return 2
	else:
		return 3

# Driver code
n = 43
print(remainderBy4(n))

   C#
using System;

public class Program {
	public static int RemainderBy4(int n) {
		int lastTwoBits = n & 3;
		if (lastTwoBits == 0) {
			return 0;
		} else if (lastTwoBits == 1) {
			return 1;
		} else if (lastTwoBits == 2) {
			return 2;
		} else {
			return 3;
		}
	}

	// Driver code
	static void Main(string[] args) {
		int n = 43;
		Console.WriteLine(RemainderBy4(n));
	}
}

   JavaScript
function remainderBy4(n) {
	let lastTwoBits = n & 3;
	if (lastTwoBits === 0) {
		return 0;
	} else if (lastTwoBits === 1) {
		return 1;
	} else if (lastTwoBits === 2) {
		return 2;
	} else {
		return 3;
	}
}

// Driver code
let n = 43;
console.log(remainderBy4(n));

   Output
3

   Complexity:
   Time Complexity: O(1) as we are only performing a single Bitwise AND operation and a few simple
   comparisons.
   Auxiliary Space: O(1) as we are not using any extra data structure to store values.


---

