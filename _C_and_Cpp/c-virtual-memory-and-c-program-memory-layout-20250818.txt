filename: c-virtual-memory-and-c-program-memory-layout-20250818.txt
https://medium.com/@breakpoint.tutorials/memory-organization-of-a-c-program-a32417e91f5b

Virtual memory and C program memory layout
May 23, 2020

   Hello everyone,

   In this post, I wanted to provide an in depth analysis of memory organization of a C program. At the
   end of this post, I hope that you are going to have a really clear idea of what goes on with respect
   to memory when you compile and run a C program.

   For this exercise I am using a 64 bit (x86) Linux machine, and this is important because the memory
   organization is based on the type of architecture and Operating System that is being used.
   To understand what really goes on, first we'll talk about Virtual memory, followed briefly by how the
   OS manages it. Then we'll take a look at a C program and analyze the different memory segments for
   variables and functions.

   Virtual Memory:
   Lets understand the concept of abstraction before we jump into Virtual Memory. Abstraction is
   something we humans do all the time in our lives. While you're reading this post, you don't have to
   think about how words typed by someone on their computer made it's way to your screen. We are
   abstracted away from the details of what goes on under the hood. It just makes our lives simpler,
   doesn't it?. Turns out this concept is really useful in programming. When writing your first "hello
   world" program, you just wrote -

#include <stdio.h>

int main() {
	printf("hello world!\n");
}

   You most likely didn't try to look at this stdio.h file or see what the printf function is actually
   doing. It made your life easy to abstract this detail.

   Now lets take an analogy of something we have seen in our lives to understand Virtual Memory.

   Lets say we are in a school or college, and there is a classroom named A-401 where multiple classes
   are conducted. At 9 a.m., its Chemistry 101, at 10 a.m., its Advance Operating Systems. A set of
   students attend the Chemistry 101 class and use the classroom for the entire hour, they think the
   classroom is their's for the entire duration. The next hour, another set of students do the same for
   Advance Operating Systems. Both set of students don't really care about how this classroom was
   allocated to them, who created this timetable etc. This classroom is being shared by both groups of
   students.

   | Virtual memory is a memory management technique that provides an "idealized abstraction of the
   | storage resources that are actually available on a given machine which "creates the illusion to
   | users of a very large (main) memory.

   Virtual memory is similar to our analogy. Chemistry 101 is like Virtual Memory & A-401 is like
   Physical memory. Students are the processes and the school admins (who create the timetable and
   allocate classrooms) are like the Operating System. The processes, like the students, don't care how
   they get their memory or who is allocating this virtual memory and mapping it to physical memory,
   they just use it when they are running. The OS abstracts these details, so that a process does not
   have to deal with the complex task of sharing memory with other processes. Imagine having to talk to
   students of other classes to ensure you have a classroom allocated during a specific time, sounds
   like a nightmare!

   The main necessity of virtual memory comes from the fact that the operating system has to manage the
   memory allocations of multiple processes seamlessly. Operating systems support concurrent execution
   of programs by scheduling different processes in time and at any point in time, only one process can
   be running (on a single core CPU). For example, you could have a word document editor, a calculator
   and a browser open simultaneously, and each program is running in a process. If you want to manage
   the memory requirements of these concurrent processes, the most elegant way to do it is to let each
   process have its own address space (virtual) and deal with the mapping to physical addresses
   internally in the OS.

   Reiterating it again, each running process in linux, gets its own virtual address space or virtual
   memory and this is huge, and for my machine its 128 TB, yes that TB which stands for Tera Bytes (1
   million million bytes). There's no a way a personal computer can have that much physical memory,
   usually RAM sizes in personal computers can be around 8 GB or 16 GB.

   When a process is running, it accesses memory locations using variables and pointers and function
   calls. Now someone's gotta translate these huge virtual addresses to actual physical address for
   anything to make sense, right? Yes, that's the role of the Operating System. The OS uses page tables
   and TLBs to manage this translation. Basically its a table that says for example, 0x7ffed8c67338
   (Virtual) --> 0x70800000 (Physical)

   That's just an example, in reality the memory is divided into pages and the mapping is stored for
   each page and not for each +address. Duh! obviously it doesn't make sense to store a mapping for each
   address, since the number of addresses is so huge as we have seen. 128 TB!

   Now, the interesting stuff, lets look at a simple C program and understand what is in the process
   address space.

   Quick refresher, when you run your c program, you are essentially launching a process and when you
   launch a process, a virtual address space gets created for this process. I am going to write another
   post related to processes and link it here. Until then, like we learnt today, lets just abstract the
   details ;-)

   Memory Organization:
   The memory allocation of a C program looks like this:

   +-------------------+ High address
   | Command Line args |
   +-------------------+
   |       Stack       |
   +- - - - - - - - - -+
   |        Heap       |
   +-------------------+
   |        Data       |
   +-------------------+
   |        Text       |
   +-------------------+ Low addres

   Stack is a segment of memory used for all the local variables within functions and also all the
   information needed to jump to functions and return from them. The stack segment keeps growing
   downwards as you jump into functions, a new stack frame is created.

   Heap is a segment of memory primarily used for dynamic memory allocation, things you only know how
   much you need while the program is running. For example, based on user input, you might wanna
   allocate memory, so if the user input is small, you want less, big, you want big, the jargon being
   dynamic memory allocation. The Heap segment grows upwards towards the Stack segment as and when you
   allocate memory.

   Data segment is used for all the data that you allocate statically, outside of functions. These are
   global variables and static variables.

   Text segment is where your code lives, and some variables that are declared with the const keyword.
   This is segment cannot be written to by the program.

   Lets look at our example program here.

#include <stdio.h>
#include <stdlib.h>
#define PRINT_DELIMITER() printf("------------------------\n");
#define PRINT_MEM_SEG(seg, addr) printf("[%s]: %p\n", seg, addr);

static void func(void) {
	printf("hello\n");
}

int main(int argc, char *argv[]) {
	PRINT_DELIMITER();

	PRINT_MEM_SEG("CMD LINE ARGS", &argv[0]);
	PRINT_DELIMITER();

	int stack_var = 25;
	PRINT_MEM_SEG("STACK", &stack_var);
	PRINT_DELIMITER();

	int *heap_ptr = malloc(sizeof(int));
	PRINT_MEM_SEG("HEAP", heap_ptr);
	PRINT_DELIMITER();

	static int data_var = 10;
	PRINT_MEM_SEG("DATA", &data_var);
	PRINT_DELIMITER();

	PRINT_MEM_SEG("TEXT", func);

	return 0;
}


Output of the above C program (on EN - Cygwin):
------------------------
[CMD LINE ARGS]: 0xa00000750
------------------------
[STACK]: 0x7ffffcc34
------------------------
[HEAP]: 0xa00010820
------------------------
[DATA]: 0x100402010
------------------------
[TEXT]: 0x100401080


Output of the above C program (https://www.programiz.com/c-programming/online-compiler/):
------------------------
[CMD LINE ARGS]: 0x7ffd9000e358
------------------------
[STACK]: 0x7ffd9000e234
------------------------
[HEAP]: 0xd246b0
------------------------
[DATA]: 0x404028
------------------------
[TEXT]: 0x401146

   We can see these addresses, and observe a few things. The stack addresses are so huge, but remember,
   these are virtual addresses, and I mentioned how the size of this virtual address space for a process
   in my machine is 128 TB and the stack is at the top of the address space. As we continue to go down
   the address space, we see heap followed by data and the text segment.

   There is another segment called bss which is a part of the data segment, however bss is only for
   those variables that do not have any initialization value. Look at the difference between these two
   segments in the below code.

   All bss variables will be initialized to 0, essentially when the program is about to start running,
   the bss segment is just memset to all zeros.

static int bss_var;
static int data_var = 500;

   That is the end of this post, stay tuned for more posts related to C programming, Operating Systems
   and Embedded Systems. Hope you liked this post, if you did, please share it :-)


---

