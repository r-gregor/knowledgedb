filename: c_modules_20220309.txt
https://www.icosaedro.it/c-modules.html

Modular programming in C
2017-09-13.

   This paper explains how C programs can be structured by modules.

What modules are
   Modularization is a method to organize large programs in smaller parts, i.e. the modules. Every
   module has a well defined interface toward client modules that specifies how "services" provided by
   this module are made available. Moreover, every module has an implementation part that hides the code
   and any other private implementation detail the clients modules should not care of.

         main program
         +-----------------------------------------+
         |                                         |
         | [ program_name.c ]---->[ program_name ] | 
         |                         ^  ^   ^  ^     |
         +-------------------------|--|---|--|-----+
                                   |  |   |  |                            
           +-----------------------+  |   |  +------------------+                                                    
           |                +---------+   +----+                |                                 
    +------|----------------|-------+   +------|----------------|-------+                                                                  
    |      |                |       |   |      |                |       |
    | [module1.h]-+         |       |   | [module2.h]-+         |       |
    |             |   ............. |   |             |   ............. |
    |             +-->: module1.c : |   |             +-->: module2.c : |
    | [module1.c]---->:...........: |   | [module2.c]---->:...........: |  ...
    +-------------------------------+   +-------------------------------+                             
    module1                             module2                            ...

   Layout of the source three. Dotted boxes are files generated by the compiler, while arrows indicate
   files involved in their generation.

   Modularization has several benefits, especially on large and complex programs:
     * modules can be re-used in several projects;
     * changing the implementation details of a modules does not require to modify the clients using
       them as far as the interface does not change;
     * faster re-compilation, as only the modules that have been modified are actually re-compiled;
     * self-documenting, as the interface specifies all that we need to know to use the module;
     * easier debugging, as modules dependencies are clearly specified and every module can be tested
       separately.

   Programming by modules using the C language means splitting every source code into an header file
   module1.h that specifies how that module talks to the clients, and a corresponding implementation
   source file module1.c where all the code and the details are hidden. The header contains only
   declarations of constants, types, global variables and function prototypes that client programs are
   allowed to see and to use. Every other private item internal to the module must stay inside the code
   file. We will now describe in detail the general structure of the interface and the implementation
   files.

Module interface
   Every interface file should start with a brief description of its purpose, author, copyright
   statement, version and how to check for further updates. All these information are simply C comments
   or Doxygen DocBlocks.

   Proper C declarations must be enclosed between C preprocessor directives that prevent the same
   declarations from being parsed twice in the same compilation run. Here is the skeleton of our
   module1.h interface file using Doxygen DocBlocks:

/**
 * Skeleton example of a C module. Illustrates the general structure of a
 * module's interface.
 * @copyright 2008 by icosaedro.it di Umberto Salsi
 * @license as you wish
 * @author Umberto Salsi <salsi@icosaedro.it>
 * @version 2008-04-23
 * @file
 */

#ifndef module1_H
#define module1_H

/*
 * System headers required by the following declarations
 * (the implementation will import its specific dependencies):
 */
#include <stdlib.h>
#include <math.h>

/*
 * Application specific headers required by the following declarations
 * (the implementation will import its specific dependencies):
 */
#include "module2.h"
#include "module3.h"

/* Set EXTERN macro: */
#ifdef module1_IMPORT
	#define EXTERN
#else
	#define EXTERN extern
#endif

/* Constants declarations here. */

/* Types declarations here. */

/* Global variables declarations here. */

/* Function prototypes here. */

#undef module1_IMPORT
#undef EXTERN
#endif

   As a general rule, to prevent collisions in the global space of names, every public identifier must
   start with the name of the module, then an underscore, and then the actual name of the item.

   The purpose of the module1_IMPORT and the EXTERN macros is to allow the definition file to be
   included by client modules AND the implementation of the module, so that global public variables can
   be declared only once, and the compiler can check if the function prototypes do really match their
   implementation.

   And here is the trick. The implementation file module1.c will define the macro module1_IMPORT just
   before including its own header file; in this way the EXTERN macro is left empty and all the public
   variables and public functions will result properly defined: variables will be allocated by the
   compiler in the text section of the generated object file; function prototypes will be checked
   against their implementation.

   Client modules, instead, do not define the module1_IMPORT macro, then the compiler will see only
   external variables and external functions the linker will have to resolve.

Header file: Constant declarations
   Constants can be both simple macros or enumerative values. Enumeratives are more suited to define
   also a new type and are discussed below along the type declarations. Usually constants are simple int
   or double numbers, but also float and literal strings are allowed.

/* module1.h -- Constants declarations */

#define module1_MAX_BUF_LEN (4*1024)

#define module1_RED_MASK    0xff0000
#define module1_GREEN_MASK  0x00ff00
#define module1_BLUE_MASK   0x0000ff

#define module1_ERROR_FLAG    (1<<0)
#define module1_WARNING_FLAG  (1<<1)
#define module1_NOTICE_FLAG   (1<<2)

Header file: Type declarations
   This section of the header file contains enumerative declarations, data structure declarations,
   explicit type declarations and opaque type declarations. Enumeratives are suitable to declare several
   constants. struct declarations are suitable to declare data structures whose internal details are
   exposed to client modules.

   To enforce the encapsulation of the implementation details, an opaque data type can be declared
   instead of an explicit data type. Opaque data types are types whose internal details are hidden to
   the client modules; their actual internal structure is fully declared only in the implementation
   module, so that client modules cannot access their internal details. This opaque declaration follows
   this general pattern for the .h and the .c files respectively:

   +----------------------------------------------------------------+
   | Opaque data type                                               |
   +-----------------------------------------+----------------------+
   | module.h                                | module.c             | 
   +-----------------------------------------+----------------------+                                        
   | typedef struct module_Type module_Type; | struct module_Type { |                                                            
   |                                         |     int field1;      |                                                            
   |                                         |     int field2;      |                                                            
   |                                         |     ...              |                                                            
   |                                         | };                   |                                                            
   +-----------------------------------------+----------------------+

   Note that two identifiers are defined: one module_Type is an opaque struct, and the other module_Type
   is a type derived from this struct type. There is no conflict between these two types because they
   belong to two different symbol tables inside the C compiler.

   The drawback of the opaque types is that clients modules cannot dynamically allocate opaque data
   structures, nor they can declare arrays or struct fields of such types because their size is known
   only inside their own implementation; only pointers to such opaque types are allowed:

Clients can't do this:       
module1_Type elems[100];  /* ERR */

struct AnotherType {
	int           field1;
	int           field2;
	module1_Type  field3;  /* ERR */
};


...but can use pointers:
module1_Type *elems[100];  /* ok */

struct AnotherType {
	int           field1;
	int           field2;
	module1_Type *field3;  /* ok */
};

   Since client modules can deal only with pointers to opaque types, the implementation must then
   provide every allocation and initialization routine that may be required, whose typical name follows
   the scheme module_type_alloc() and module_type_free() respectively.

/* module1.h -- Types declarations */

enum module1_Direction {
	module1_NORTH,
	module1_EAST,
	module1_SOUTH,
	module1_WEST
};

/**
 * Explicit type declaration example.
 */
typedef struct module1_Node {
	struct module1_Node *left, *right;
	char * key;
} module1_Node;

/**
 * Alternative opaque declaration of the node above.
 */
typedef struct module1_Node module1_Node;

Header file: Global variables
   It is a good rule to avoid public global variables at all. But if you really need them, here is the
   recipe to deal with their declaration and initialization. The module1_IMPORT macro is required in
   order to allocate the variable in the "text" section of the code module. Without this macro every
   client module would allocate its own copy if the variable, which is not what we expect.

/* module1.h -- Global variables declarations */

EXTERN int module1_counter
#ifdef module1_IMPORT
	= -1
#endif
;

EXTERN module1_Node *module1_root;
   The preprocessor code protects the initial value from being evaluated by client modules, so that the
   variables are allocated in the code module and here initialized. Client modules will only see an
   external variable of some type.

   Note that global variables are always initialized to zero and pointers are set to NULL, which
   typically is just the initial safe value programs expect, so there is need to assign an explicit
   initial value.

Header file: Function prototypes
   All the functions that need to be accessible from client modules must be declared with a prototype.
   Remember that functions without arguments must have a dummy void formal argument, otherwise the
   compiler would complain with a quite misleading error message telling the prototype is missing when
   it looks to be right there!

/* module1.h -- Function prototypes */

/**
 * Initializes this module. Should be called in main() once for all.
 */
EXTERN void module1_initialization(void);

/**
 * Releases internal data structures. Should be called in main()
 * before ending the program.
 */
EXTERN void module1_termination(void);

/**
 * Add a node to the root three.
 * @param key Value to add to the tree.
 * @return Allocated node.
 */
EXTERN module1_Node * module1_add(char * key);

/**
 * Releases node from memory.
 * @param n Node to release.
 */
EXTERN void module1_free(module1_Node * n);

Module implementation
   The implementation module module1.c should include the required headers, then it should define the
   module1_IMPORT macro before including its own header file. By including its own header the compiler
   grabs all the constants, types and variables it requires. Moreover, by including its own header file
   the code file allocates and initialize the global variables declared in the header. Another useful
   effect of including the header is that prototypes are checked against the actual functions, so that
   for example if you forgot some argument in the prototype, or if you changed the code missing to
   update the header, then the compiler will detect the mismatch with a proper error message.

   Macros, constants and types declared inside a code file cannot be exported, as they are implicitly
   always "private".

   Global variables for internal use must have the static keyword in order to make them "private".

   Remember also to declare as static all the functions that are private to the code module. The static
   keyword tells to the compiler that these functions are not available for linking, and then they will
   not be visible anymore once the code file has been compiled in its own module1.o object file.

   Since all the private items are not exported, there is not need to prepend the module name module1_ to
   their name, as they cannot collide with external items. Private items are still available to the
   debugger, anyway.

/* module1.c -- See module1.h for copyright and info */

/* Import system headers and application specific headers: */
#include <malloc.h>
#include <string.h>
#include "module4.h"
#include "module5.h"

/* Including my own header for checking by compiler: */
#define module1_IMPORT
#include "module1.h"

/* Private macros and constants: */

/* Private types: */

/* Actual declaration of the private opaque struct: */
struct module1_Node {
	struct module1_Node *left, *right;
	char * key;
};

/* Private global variables: */
static module1_Node * spare_nodes = NULL;
static int allocated_total_size = 0;

/* Private functions: */
static module1_Node * alloc_Node(void){ ... }
static void free_Node(module1_Node * p){ ... }

/* Implementation of the public functions: */
void module1_initialization(void){ ... }
void module1_termination(void){ ... }
module1_Node * module1_add(char * key){ ... }
void module1_free(void){ ... }

   Note that public functions are left by last, since usually they need some private function; moreover,
   since public functions already have their prototype, public functions can be called everywhere in the
   code above them.

   The code file should never need to declare function prototypes, the only exception being recursive
   functions.

Main program
   The name of our project will be program_name and its source file is program_name.c. This source is
   the only one that does not require an header file, and it contains the only public function, main(),
   that does not need a prototype. The main source includes and initializes all the required modules,
   and finally terminates them once the program is finished. The general structure of the main program
   source file is as follows:

/**
 * Our sample program.
 * @copyright 2008 by icosaedro.it di Umberto Salsi
 * @license as you wish
 * @author Umberto Salsi <salsi@icosaedro.it>
 * @version 2008-04-23
 * @file
 */

/* Include standard headers: */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* Include modules header we directly invoke here: */
#include "module1.h"
#include "module2.h"

int main(int argc, char **argv) {
	/* Initialize modules: */
	module1_initialization();
	module2_initialization();

	/* Perform our job. */

	/* Properly terminate the modules, if required: */
	module2_termination();
	module1_termination();

	return 0;
}

Makefile
   Compiling, linking and other common ordinary tasks are usually delegated to a Makefile, the
   configuration file for the make command. make already has default rules that tell how to build object
   files *.o out from their source file *.c, but unfortunately it is not aware of our modular structure
   of the source. To deal with our modules we have to tell to make that also *.h header files have to be
   added to its dependencies rules. This will require an explicit rule, as we can't rely on the default
   one. Moreover the main program, the only one that has not an header file, must to be compiled with
   another rule and it may require also to specify some external library to linking with. Finally, this
   is the resulting Makefile skeleton:

# Makefile

# Compiler flags: all warnings + debugger meta-data
CFLAGS = -Wall -g

# External libraries: only math in this example
LIBS = -lm

# Pre-defined macros for conditional compilation
DEFS = -DDEBUG_FLAG -DEXPERIMENTAL=0

# The final executable program file, i.e. name of our program
BIN = program_name

# Object files from which $BIN depends
OBJS = module1.o module2.o module3.o

# This default rule compiles the executable program
$(BIN): $(OBJS) $(BIN).c
	$(CC) $(CFLAGS) $(DEFS) $(LIBS) $(OBJS) $(BIN).c -o $(BIN)

# This rule compiles each module into its object file
%.o: %.c %.h
	$(CC) -c $(CFLAGS) $(DEFS) $< -o $@

clean:
	rm -f *~ *.o $(BIN)

depend:
	makedepend -Y -- $(CFLAGS) $(DEFS) -- *.c

   With this Makefile, compiling the source becomes as simple as issuing the make command alone, no
   arguments are required. Other tags may also be present, as make clean, make dist and so on. The last
   tag make depend will be the subject of the next paragraph.

Modules dependent from other modules
   The source three we considered till now is very simple, with a main program that depends from
   several, independent modules. The %.o rule takes care to update every *.o file if any module source
   gets modified, while the $(BIN) rule re-compiles and re-link the main program if its source or any of
   the modules gets modified.

   But what if some module depends from some other sub-module, either including it in its header or in
   its code file? And what if modules, besides contributing to the main program, are also mutually
   dependent? The figure below schematically illustrates a situation in which module1.h/.c requires a
   sub-module module4.h, and module2 requires module3.

                                     [ program name ]
                                       ^    ^    ^
                                       |    |    |
                     +-----------------+    |    +-------------------+      
                     |                      |                        |      
              +-------------+        +-------------+          +-------------+
              | [module1.h] |        | [module2.h] |<-----------[module3.h] |
              | [module1.c] |        | [module2.c] |    "!"   | [module3.c] |
              +-------------+        +-------------+          +-------------+
                     ^                                                          
                     | "!"                                                     
                     |                                                         
              +-------------+                                                  
              | [module4.h] |                                                  
              | [module4.c] |                                                  
              +-------------+                                                  

   A more complex source layout, where module 1 (either in its .h or .c file) requires module 4, and
   module 2 (either in its .h or .c) requires module 3. If not properly directed, our Makefile in its
   basic form fails to detect these dependencies, and sources are not re-compiled as required.

   The make command does not parse the content of the files and it is not aware of these new
   dependencies. So if we modify module4 it will omit to re-compile module2, and if we modify module3 it
   will omit to re-compile module2. We can fix simply adding specific rules that handle these
   dependencies, but we have also to remember to update these rules according to any change in our
   source three layout.

   The special tag make depend can do all that boring work for us, as it builds automatically all the
   dependencies between the source files, and appends them to the Makefile itself. Issuing make depend,
   in fact, the Makefile gets changed with these new lines:

---- The Makefile as above, but remember to add ----
---- module4.o to the list of the object files. ----

# DO NOT DELETE

module1.o: module4.h
module2.o: module3.h
program_name.o: module1.h module2.h module3.h module4.h

   These rules complete the %.o rule we wrote by hand. The last rule reports the file program_name.o we
   do not generate, and it is ignored in the context of our Makefile. So, for example, modifying
   module4.h and issuing the make command, the rule %.o causes the re-compilation of module4.c, the rule
   module1.o added by makedepend combined with the rule %.o causes the re-compilation of module1.c, and
   finally the rule $(BIN) produces the updated executable program program_name.

   Summarizing, after every change to the layout of the source three it is safe to update the Makefile
   issuing the command "make depend", and then we can use the command "make" as usual to generate the
   executable program.

Final suggestions
   The GNU GCC compiler has a -Wall flag that enables all the possible warning messages. I always use
   this flag because it helps to write clean code, and it saves from many obscure mistakes that would be
   difficult to detect otherwise.

   You may use the nm command to check if some internal item (variable or function) escaped from our
   modularization. This command displays all the symbols available in the object file, either available
   to the linker or to the debugger. For every symbol this command prints also a letter that marks its
   status and its availability. Public items (i.e. those that the object file make available to the
   client modules) are marked by an uppercase letter B D T etc. while local symbols have lowercase
   letters b d t etc.:

$ nm module1.o
00000000 t alloc_Node
0000000c b allocated_total_size
00000014 T module1_add
00000000 D module1_counter
0000001e T module1_free
0000000f T module1_init
00000004 B module1_root
0000000a t free_Node
00000008 b spare_nodes

   A simple grep allows to immediately detect variables and items actually exported by modules:

$ nm module1.o | grep " [A-Z] "
00000014 T module1_add
00000000 D module1_counter
0000001e T module1_free
0000000f T module1_init
00000000 B module1_root

   We can improve this shell command writing an useful tool that displays all the private identifiers
   erroneously exported by each code module:

#!/bin/sh
# Usage: c-detect-private-exported *.o
echo "Detecting private items exported by object files:"
while [ $# -gt 0 ]; do
	base=`basename $1 .o`
	nm $1 | grep " [A-Z] " | cut -d " " -f3 |
	while read id; do
		grep -q -w $id $base.h || echo "    $id"
	done
	shift
done


   This script accepts a list of .o files and displays all the identifiers exported that are not
   declared in the corresponding .h file: these symbols can then be readily added to their proper
   include file.

==============================================================================================================

Tools and examples
    [**1]check-included is a Bash shell script that checks all the included modules are actually used in the
    source. Type check-included -h for help.
    
    [**2]create-c-module is a Bash shell script that generates the skeleton of a new module as described her
    . Type create-c-module -h for help.

    [**3]make-makefile, or when 'make depend' is not flexible enough. It is a Bash shell script that
    generates the Makefile for all the C source programs in the current directory by scanning recursively
    header files and C sources. Type make-makefile -h for help.

    [http://cvs.icosaedro.it:8080/viewvc/public/tt/src/util/]Concrete examples of modules. The Makefile has
    been created by the make-makefile script above.
    The names of the modules are mostly self explanatory, but the most notable ones for what it cares to our
    discussion are:
    array: dynamic array of pointers; several specific implementations are also built over this module:
    bufarray, pairarray, ustringarray.

    buf: dynamic buffer of bytes.
    encoder: stream text translator from an encoding to another.
    hashtable: a collection of key/value pairs, also known as "dictionary" or "map".
    memory: memory allocator with leaks detector, dispose function with modules' specific destructor cal
    , and modules' cleanup function.

    mime: email MIME format encoder and decoder.
    sparsearray: sparse array of pointers.
    terminal: basic terminal management with support for locale encoding.
    ustring: Unicode strings as dynamic buffers of characters.

    [http://cvs.icosaedro.it:8080/viewvc/public/acm/src/util/]Even more concrete examples of modules. The
    Makefile has been created by the make-makefile script above; a specific Makefile-include.txt has also
    been added to support compilation of the sources under Linux and under Windows with the MinGW
    development kit, so the following modules are for both Linux and Windows:
    audio: allow to load and control the execution of a WAV audio file.
    gui: simple abstraction of the underlying windowing system that allows to mange keyboards, mouse and
    window events; the only graphical primitive provided allows to draw a line because this was the only
    requirement of the program this module belongs to, but adding more features is easy.

    prng: pseudo-random number generator with easier and safer interface to prevent common mistakes.
    timer: simple real-time timer you can start, stop, restart and reset.
    varray: implements a collection of objects that can be allocated and retrieved by univocal handles 
    or "versioned entries") rather than by pointers to detect or prevent access to already released objects.

    wav: WAV PCM file reader.
    zulu: "zulu" UTC time and date conversion routines.


---
[**1]
http://cvs.icosaedro.it:8080/viewvc/public/tools/check-included?view=markup

#!/bin/bash
	PROGNAME=check-included
	VERSION="$Date: 2017/03/15 14:11:51 $"

	function help() {
			echo "
	$PROGNAME - Checks C program modularization and useless #include lines.

	SYNOPSIS

			$PROGNAME [-h|--help] [file.h] [file.c]

	If no argument given, checks every *.h and *.c in the current directory.

	This is code-cleaner utility safe to use because it checks only, does not modify
	anything. For each source file passed as an argument (either .h or .c) checks if
	it follows the modularization best practices suggested here. In more detail,
	if M is the name of the module:

	1. The header file M.h must define and undefine the EXTERN macro properly:

	#ifdef M_IMPORT
		#define EXTERN
	#else
		#define EXTERN extern
	#endif

	...definitions here...

	#undef EXTERN

	2. The implementation file M.c must import its header properly:

	#define M_IMPORT
	#include \"M.h\"

	3. Detects unused included modules.
	An included module \"M.h\" is assumed to be used iff any identifier whose name
	begins with \"M_\" is found in the source. Then this script works in the
	assumption that every public item exported by a module be protected by the name
	of the module itself. This name scheme holds for macros, struct names, types,
	variables and functions.

	Diagnostic messages are sent to stdout, program errors are sent to stderr.
	Exits with status code 0 if all ok, 1 if not.

	Rationale and more info: http://www.icosaedro.it/c-modules.html

	Author: Umberto Salsi <salsi@icosaedro.it>
	Version: $VERSION"
	}

	# Checks if the module header .h defines and destroys the EXTERN macro.
	# $1: header file.
	function check_modularization_h() {
		local h m result SP NL
		h=$1
		m=$(basename $h .h)
		result=0
		# Linear white spaces (new)regex:
		SP="[ "$'\t'"]*"
		# New line with white spaces (new)regex:
		NL="$SP"$'\r'"?.$SP"

		if ! grep -q -E -z "#ifdef${SP}${m}_IMPORT${NL}#define${SP}EXTERN${NL}#else${NL}#define${SP}EXTERN${SP}extern${NL}#endif${NL}" $h; then
			result=1
			echo "$h: missing EXTERN macro definition, expected:"
			echo "	#ifdef ${m}_IMPORT"
			echo "			#define EXTERN"
			echo "	#else"
			echo "			#define EXTERN extern"
			echo "	#endif"
		fi

		if ! grep -q -E -z "#undef${SP}EXTERN${NL}" $h; then
				result=1
				echo "$h: missing EXTERN macro undef, expected:"
				echo "	#undef EXTERN"
		fi
		return $result
	}


	# Checks if the implementation module .c includes properly its header.
	# Does nothing if the file is a program (that is, no .h file available).
	# $1: implementation module.

	function check_modularization_c() {
		local c m result SP NL
		c=$1
		if [ ! -f ${c%%.c}.h ]; then
			# No .h available -- its a program.
			return 0
		fi

		m=$(basename $c .c)
		result=0
		# Linear white spaces (new)regex:
		SP="[ "$'\t'"]*"
		# New line with white spaces (new)regex:
		NL="$SP"$'\r'"?.$SP"

		if ! grep -q -E -z "#define${SP}${m}_IMPORT${NL}#include${SP}\"$m.h\"${NL}" $c; then
			result=1
			echo "$c: missing ${m}_IMPORT macro definition or header inclusion, expected:"
			echo "	#define ${m}_IMPORT"
			echo "	#include \"$m.h\""
		fi

		return $result
	}


	# Returns a list of modules included by the given file, each module with
	# path but without extension.
	# $1: source file.
	# Return: list of modules directly included by this source file, with path
	# but without extension.

	function list_includes() {
		grep "^#include[ \\t]\\+\"" $@ | sed -e "s/^[^\"]*\"//" -e "s/\\.h\".*//g"
	}


	function check_included() {
		local i b result
		f=$1
		result=0
		for i in $(list_includes $f); do
			b=$(basename $i)
			if ! grep -q "\\<${b}_" $f; then
				echo "$f: module $i included but not used (no ${b}_* symbols found)."
				result=1
			fi
		done
		return $result
	}


	function check() {
		local f result
		f=$1
		if [ ! -r $f ]; then
			echo "$1: cannot read" >&2
			return 1
		fi

		result=0
		case $f in
			*.h) check_modularization_h $f || result=1 ;;
			*.c) check_modularization_c $f || result=1 ;;
		esac

		check_included $f || result=1
		return $result
	}

	check_all=yes
	result=0

	while [ $# -gt 0 ]; do
		case $1 in
			-h|--help) help; exit ;;
			-*) echo "$PROGNAME: ERROR: unknown option $1, try --help" >&2 ; exit 1 ;;
			*.h|*.c) check $1 || result=1 ; check_all=no ;;
			*) echo "$PROGNAME: ERROR: unexpected argument $1, try --help" >&2 ; exit 1 ;;
		esac
		shift
	done

	if [ $check_all = yes ]; then
		for f in $(ls *.h *.c 2>/dev/null); do
			check $f || result=1
		done
	fi

	exit $result


---
[**2]
http://cvs.icosaedro.it:8080/viewvc/public/tools/create-c-module?view=markup

#!/bin/bash

	function help() {
		echo "Creates a module.h and module.c template files for a C module."
		echo "Syntax:"
		echo "          create-c-module MODULE"
		echo "where MODULE is the basename of the .h and .c files."
	}


	if [ $# -eq 1 ]; then
		module=$1
		struct=${module}_Type
	else
		echo "ERROR: required one parameter." >&2
		help
		exit 1
	fi

	module=$1
	struct=${module}_Type

	h=$module.h
	c=$module.c

	if [ -f $h -o -f $c ]; then
		echo "ERROR: either $h or $c file already exists." >&2
		exit 1
	B
	fi

	#################### H ##########################

	echo "/**
	* @file
	* @author Umberto Salsi <salsi@icosaedro.it>
	* @version \$Date\$
	*/

	#ifndef $(echo -n $module | tr a-z A-Z)_H
	#define $(echo -n $module | tr a-z A-Z)_H

	#ifdef ${module}_IMPORT
		#define EXTERN
	#else
		#define EXTERN extern
	#endif

	typedef struct $struct $struct;

	/**
	* Allocates a new $struct.
	* @return New $struct. Must be released with memory_dispose().
	*/
	EXTERN $struct * ${module}_new(void);

	#undef EXTERN
	#endif" > $h

	######################## C #######################

	echo "#include <stdio.h>
	#include <stdlib.h>
	#include <assert.h>

	#include \"memory.h\"

	#define ${module}_IMPORT
	#include \"$module.h\"

	struct $struct {
		/* Specific fields of $struct here. */
	};

	static void ${module}_destruct(void *p) {
		$struct *this = ($struct *) p;
		/* Reset internal state of $struct. */
	}

	$struct * ${module}_new() {
		$struct * this = memory_allocate(sizeof($struct), ${module}_destruct);
		/* Set internal state of $struct. */
		return this;
}
" > $c


---
[**3]
http://cvs.icosaedro.it:8080/viewvc/public/tools/make-makefile?view=markup

#!/bin/bash
	PROGNAME=$(basename $0)
	VERSION="$Date: 2017/04/26 14:07:41 $"

	# Executable file extension:
	EXE=".exe"

	function help() {
		echo "
	$PROGNAME - Creates Makefile for all C source files in current directory.
	Existing Makefile is saved in backup file if either not generated by this
	program or modified by hand since it was generated.

	Syntax:

	        make-makefile [-h] [--help] [SRC.c] ...

	Options:

	   --help | -h    Only displays this help and exits.

	If one or more SRC.c source files are given, displays on stdout the targets that
	would be generated for that source, but does not create the Makefile.

	If any of the .c files of the programs or modules involved in a target contains
	the "LINKING_OPTIONS" marker, all the options listed up to the end of the line
	are added to the compilation command. Example:

	    /*
	     * COMPILATION_OPTIONS -iconv
	     */

	If a file named "Makefile-include.txt" is present in the directory, it is
	included.

	Rationale and more info: http://www.icosaedro.it/c-modules.html

	Author: Umberto Salsi <salsi@icosaedro.it>
	Version: $VERSION
	"
	}

	# File to include (optional):
	MAKEFILE_INCLUDE=Makefile-include.txt

	# Preamble of the checksum marker added to the end of the generated Makefile
	# to later detect for content changes.
	CHECKSUM_MARKER="# Checksum of the original file:"

	# Returns the checksum for a text file.
	# $1: Text file.
	function checksum_calculate() {
		cat $1 | tr -d '\r' | grep -v "^$CHECKSUM_MARKER [0-9]\\+\$" | cksum | (read cksum x; echo $cksum)
	}


	# Appends a checksum line to a text file.
	# $1: File to mark with the checksum.
	function checksum_append() {
		local cksum
		cksum=$(checksum_calculate $1)
		echo "$CHECKSUM_MARKER $cksum" >> $1
	}


	# Returns true if the file contains a valid checksum marker.
	# $1: File to check.
	function checksum_good() {
		local old_cksum cur_cksum
		[ -r $1 ] || return 1
		old_cksum=$(cat $1 | tr -d '\r' | grep "^$CHECKSUM_MARKER [0-9]\\+\$" | tail -n 1 | sed "s/^$CHECKSUM_MARKER //")
		cur_cksum=$(checksum_calculate $1)
		[ "x$old_cksum" = "x$cur_cksum" ]
	}

	# Normalize path as a string, no disk access. Removes useless "/./", removes
	# multiple slash "///", resolves where possible parent directory references
	# "/../".
	# Sends the result to stdout.
	#
	# The resulting normalized path may have only one of the following formats:
	#
	# 1. Absolute path starting with "/", possibly followed by names separated
	#    by a single "/". Examples: "/", "/NAME", "/NAME/NAME".
	#
	# 2. The current directory ".".
	#
	# 3. One or more parent directories ".." possibly followed by zero or more
	#    names. Examples: "..", "../..", "../NAME", "../../NAME/NAME".
	#
	# 4. One or more names separated by "/". Examples: "NAME", "NAME/NAME".
	#
	# The normalized empty string is the current directory ".".
	#
	# Here NAME is any sequence of bytes excluding "/" and NUL; "." and ".." are
	# not names.
	#
	# File path normalization is required by this program to check if a file has
	# been already processed, avoid infinite loops, avoid wasting time, works with
	# files that do not exist yet, and allows to generate a cleaner output and with
	# only relative paths.
	# Test code available at the end of this script.
	#
	# From an idea of S. Chauveau,
	# http://www.linuxjournal.com/content/normalizing-path-names-bash Fri, 09/04/2009
	# $1: path to normalize.

	function normalize_path(){
		local DIR i nb OLD_IFS PREFIX part j
		declare -a PARTS RESULT
		DIR="$1"

		# Split the path into parts using / as separator:
		OLD_IFS="$IFS" ; IFS="/" ; PARTS=($DIR) ; IFS="$OLD_IFS"

		# Detect an absolute path by checking the 1st character:
		if [ "${DIR:0:1}" == "/" ] ; then PREFIX="/"; else PREFIX=""; fi

		# Scan each part one at a time copying good parts to $KEEP[j].
		j=0 # next available index to $KEEP
		nb=${#PARTS[*]}
		for ((i=0; i<nb; i++)) ; do
			part="${PARTS[i]}"
			if [ "$part" = "." -o "$part" = "" ] ; then
				# Remove "." and empty part.
				continue
			elif [ "$part" = ".." ]; then

				# Drop ".." if the left part is already the root:
				if [ $j -eq 0 ] && [ "$PREFIX" = "/" ]; then
					continue
				fi

				# ...or the left part is a named part (NOT "..") to drop too:
				if [ $j -gt 0 ] && [ "${KEEP[j-1]}" != ".." ]; then

					# drop left named part:
					unset KEEP[j-1]
					j=$((j-1))
					continue
				fi
			fi

			KEEP[j]="$part"
			j=$((j+1))
		done

		# and finally reconstruct the path
		IFS='/' ; DIR="$PREFIX${KEEP[*]}" ; IFS="$OLD_IFS"
		if [ -z "$DIR" ]; then
			# Relative path and no parts remaining: either empty path or only back
			# and forth like "a/../b/.." that bring nowhere. The current directory
			# "." is the best translation of this concept of "stay there":
			DIR="."
		fi

		echo "$DIR"
	}

	# Returns a list of modules included by the given file, each module with
	# path but without extension.
	# $1: source file.
	# Return: list of modules directly included by this source file, with path
	# but without extension.

	function list_includes() {
		grep "^#include[ \\t]\\+\"" $@ | sed -e "s/^[^\"]*\"//" -e "s/\\.h\".*//g"
	}

	# Warn above this recursion limit:
	WARN_RECURSION=20
	# Fatal error above this recursion limit:
	ERROR_RECURSION=100
	recursion_level=0

	# Increases recursion level and error if too deep.
	function entering() {
		recursion_level=$((recursion_level + 1))
		if [ $recursion_level -ge $ERROR_RECURSION ]; then
			echo "$PROGNAME: ERROR: recursion safeguard limit $ERROR_RECURSION reached." >&2
			recursion_level=$((recursion_level-1))
			return 1
		elif [ $recursion_level -ge $WARN_RECURSION ]; then
			echo "$PROGNAME: Warning: recursion level $recursion_level reached." >&2
			return 0
		else
			return 0
		fi
	}

	# Decreases the recursion level.
	function exiting() {
		recursion_level=$((recursion_level - 1))
		if [ $recursion_level -lt 0 ]; then
			echo "$PROGNAME: ERROR: recursion negative!?" >&2
			exit 1
		fi
	}

	# Recursively adds a source and its dependencies to global $objs, each entry
	# with path but without extension, separated by at least one space, no duplicates.
	# Both the .c and the .h source files are examined recursively.
	# $1: source file name without extension.
	# $2: if "yes" this is the first recursive call over a module or it is a linking,
	# then we must recurse on .c too. Set to "no" for deeper recursion on module
	# compilation, so that only .h are scanned because implementations .c do not care.
	# $3: if "yes" we are collection all the dependencies for linking, then we must
	# recurse on any .h and .c at any deep and collect all the involved modules. Set
	# to "no" for single module compilation.

	function recurse() {
		local b recurseOnC isLinking base srcs deps i
		b=$1
		recurseOnC=$2
		isLinking=$3
		base=$(dirname $b)

		if [ $base = "." ]; then
			base=""
		else
			base="$base/"
		fi

		if [[ "$objs" == *" $b "* ]]; then
			return
		fi

		entering || return
		objs="$objs $b "

		if [ $recurseOnC = yes ]; then
			srcs="$b.c"
		else
			srcs=""
		fi

		[ -f $b.h ] && srcs="$srcs $b.h"
		deps=$( list_includes $srcs )

		if [ -z "$deps" ]; then
				exiting
				return
		fi

		for i in $deps; do
			i=$(normalize_path $base$i)
			if [ ! -f $i.c ]; then
				echo "$b: cannot find $i" >&2
			else
				recurse $i $isLinking $isLinking
			fi
		done
		exiting
	}

	# Sends to stdout the Makefile targets that build .o and .exe. For library
	# modules (both .h and .c do exit) only the .o is generated. For programs
	# (only .c does exit) the executable .exe is generated too.
	# Shares the global variable $objs along with the recurse() function where
	# the file names without extension of the recursively examined source files
	# are collected.
	# $1: source file name without extension.

	function compile() {
		local b f deps h
		b=$1

		# Compile module.
		# ===============
		# Dependencies are: .h and .c of the module, any .h included from these and
		# any other .h included by these latter .h (recursively). Note that the
		# implementations .c of the other modules are not scanned, only their
		# interfaces are. Here a program is nothing more than a module without
		# interface .h, its interface being the implicit "main()" function.
		# echo "--> $b.o" >&2
		# list of source file names without extension separated by space
		objs=""
		recurse $b yes no

		if [ $recursion_level -ne 0 ]; then
			echo "$PROGNAME: unbalanced calls to entering/exiting function" >&2
			exit 1
		fi

		deps=$(echo $objs | tr ' ' '\n' | grep -v "^$" | sort | uniq )
		echo
		echo -n "$b.o: $b.c"
		[ -f $b.h ] && echo -n " $b.h"

		for f in $deps; do
			[ $f = $b ] && continue
			echo -n " $f.h"
		done

		echo
		echo -e "\t\$(CC) \$(CFLAGS) -c $b.c -o $b.o"

		if [ -f $b.h ]; then
			return
		fi

		# It's a program: linking.
		# ========================
		# Dependencies are: .c and the .o of any module included directly and
		# indirectly, including each implementation and its dependencies recursively.
		###echo "--> $b" >&2
		# list of source file names without extension separated by space
		objs=""
		recurse $b yes yes

		if [ $recursion_level -ne 0 ]; then
			echo "$PROGNAME: unbalanced calls to entering/exiting function" >&2
			exit 1
		fi

		deps=$(echo $objs | tr ' ' '\n' | grep -v "^$" | sort | uniq )
		echo
		echo -n "$b$EXE:"
		o=""

		for f in $deps; do
			o="$o $f.o"
		done

		echo "$o"
		echo -ne "\t\$(CC) \$(CFLAGS) -o $b$EXE $o \$(LIBS) "

		# Add linker options annotated in the .c sources.
		for f in $deps; do
			grep LINKER_OPTIONS $f.c
		done \

		| sed -e "s/.*LINKER_OPTIONS//" -e "s/^[ \\t]\\+//" -e "s/[ \\t\\r]\\+\$//" \
		| grep -v "^\$" | sort | uniq | tr '\n' ' '
		echo
	}

	# Sends to stdout the Makefile content to build programs and libraries
	# found in this directory. Also generates the usual 'all' and 'clean' targets
	# that recursively operates on subdirectories.
	function create_makefile() {
		local c b all
		echo "# This file generated by $PROGNAME, do not edit!"
		echo "# Create Makefile-include.txt instead for your customizations."
		echo "CC := gcc"
		echo "CFLAGS := -Wall -Werror -g -fmax-errors=99 -Wuninitialized -Wmissing-prototypes -Wredundant-decls"
		echo "LIBS :="

		# "all" target compiles all .c into .o and programs in this dir:
		#  echo "--> all" >&2
		programs=""
		echo
		echo ".PHONY: all"
		echo "all:"

		# Recursively build sub-dirs first for which a Makefile is already available:
		find . -maxdepth 1 -type d \! -name CVS \! -name . \
		| while read subdir; do
			if [ -f $subdir/Makefile ]; then
				echo -e "\tcd $subdir && make all"
			fi
		done
		
		# Buils .o and .exe in this dir:
		all=""

		for c in $(ls *.c 2>/dev/null); do
			b=${c%.c}
			if [ -f $b.h ]; then
				all="$all $b.o" # builds .o
			else
				programs="$programs $b"
				all="$all $b$EXE" # builds .exe
			fi
		done

		if [ ! -z "$all" ]; then
			echo -e "\tmake $all"
		fi

		echo
		[ -f $MAKEFILE_INCLUDE ] || echo -n "#"
		echo "include $MAKEFILE_INCLUDE"

		# "test" target starts all the programs in this dir:
		if [ ! -z "$programs" ]; then
			# echo "--> test" >&2
			echo
			echo ".PHONY: test"
			echo -n "test:"
			for b in $programs; do
				echo -n " $b$EXE"
			done
			echo
			
			for b in $programs; do
				echo -e "\t./$b$EXE"
			done
			echo
		fi

		# "clean" removes objs, exe, core dumps:
		###echo "--> clean" >&2
		echo
		echo ".PHONY: clean"
		echo "clean:"
		echo -ne "\trm -f *.o *.exe *.stackdump"
		
		for b in $programs; do
			echo -ne " $b"
		done

		echo
		# Recursively clean sub-dirs first for which a Makefile is already available:
		find . -maxdepth 1 -type d \! -name CVS \! -name . \
		| while read subdir; do
			if [ -f $subdir/Makefile ]; then
				echo -e "\tcd $subdir && make clean"
			fi
		done

		# For each .c, create target to build .o and, if program, the .exe too:
		for c in $(ls *.c 2>/dev/null); do
			b=${c%.c}
			compile $b
		done
		echo
	}

	main() {
		local create_makefile
		create_makefile=yes
		while [ $# -gt 0 ]; do
			case $1 in
			-h|--help) help; exit;;
			-*) "$PROGNAME: ERROR: unknown option $1, try --help" >&2; exit 1;;
			*.c)
				compile ${1%.c}
				create_makefile=no
			;;
				*) "$PROGNAME: ERROR: unexpected argument $1, try --help" >&2; exit 1;;
			esac
			shift
		done

		# Create new Makefile in tmp file:
		[ $create_makefile = no ] && exit
		create_makefile > Makefile-tmp
		checksum_append Makefile-tmp

		# Save a backup of the existing Makefile is not generated or modified:
		if [ -f Makefile ]; then
			if ! checksum_good Makefile; then
				cp Makefile Makefile-$(date +%s).bak || exit 1
			fi
		fi

		# Ok, create or overwrite Makefile:
		mv Makefile-tmp Makefile
	}

	main "$@" ; exit


	############ TEST CODE FOLLOWS - IGNORE #################

	# Test code for the file path normalization function.
	# $1: path to normalize.
	# $2: expected normalized path.
	function normalize_path_test() {
		local p
		p=$(normalize_path $1)

		if [ "$p" != "$2" ]; then
			echo "Test failed:"
			echo "    in:  $1"
			echo "    got: $p"
			echo "    exp: $2"
		fi
	}

	# Test code for the file path normalization function.
	function normalize_path_tests() {
		normalize_path_test "" "."
		normalize_path_test "/" "/"
		normalize_path_test "." "."
		normalize_path_test ".." ".."
		normalize_path_test "a///b///" "a/b"
		normalize_path_test "a/" "a"
		normalize_path_test "/a" "/a"
		normalize_path_test "a" "a"
		normalize_path_test "./a" "a"
		normalize_path_test "/./a" "/a"
		normalize_path_test "a/b/" "a/b"
		normalize_path_test "a/./b/./." "a/b"
		normalize_path_test "a/../b" "b"
		normalize_path_test "a/b/../../c" "c"
		normalize_path_test "../aa" "../aa"
		normalize_path_test "../../aa" "../../aa"
		normalize_path_test "/../a" "/a" # in fact "ls /../tmp" works
	}

	#normalize_path_tests; exit


---

