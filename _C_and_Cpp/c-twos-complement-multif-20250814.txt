filename: twos-complement-multif-20250814.txt
https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html

Two's Complement
April 2000

   Two's complement is not a complicated scheme and is not well served by anything lengthly. Therefore,
   after this introduction, which explains what two's complement is and how to use it, there are mostly
   examples.

   Two's complement is the way every computer I know of chooses to represent integers. To get the two's
   complement negative notation of an integer, you write out the number in binary. You then invert the
   digits, and add one to the result.

   Suppose we're working with 8 bit quantities (for simplicity's sake) and suppose we want to find how
   -28 would be expressed in two's complement notation. First we write out 28 in binary form.
00011100

   Then we invert the digits. 0 becomes 1, 1 becomes 0.
11100011

   Then we add 1.
11100100

   That is how one would write -28 in 8 bit binary.

Conversion from Two's Complement
   Use the number 0xFFFFFFFF as an example. In binary, that is:
1111 1111 1111 1111 1111 1111 1111 1111

   What can we say about this number? It's first (leftmost) bit is 1, which means that this represents a
   number that is negative. That's just the way that things are in two's complement: a leading 1 means
   the number is negative, a leading 0 means the number is 0 or positive.

   To see what this number is a negative of, we reverse the sign of this number. But how to do that? The
   class notes say (on 3.17) that to reverse the sign you simply invert the bits (0 goes to 1, and 1 to
   0) and add one to the resulting number.

   The inversion of that binary number is, obviously:
0000 0000 0000 0000 0000 0000 0000 0000

   Then we add one.
0000 0000 0000 0000 0000 0000 0000 0001

   So the negative of 0xFFFFFFFF is 0x00000001, more commonly known as 1. So 0xFFFFFFFF is -1.

Conversion to Two's Complement
   Note that this works both ways. If you have -30, and want to represent it in 2's complement, you take
   the binary representation of 30:
0000 0000 0000 0000 0000 0000 0001 1110

   Invert the digits.
1111 1111 1111 1111 1111 1111 1110 0001

   And add one.
1111 1111 1111 1111 1111 1111 1110 0010

   Converted back into hex, this is 0xFFFFFFE2. And indeed, suppose you have this code:

#include <stdio.h>

int main() {
	int myInt;
	myInt = 0xFFFFFFE2;
	printf("%d\n",myInt);

	return 0;
}

   That should yield an output of -30. Try it out if you like.

Arithmetic with Two's Complement
   One of the nice properties of two's complement is that addition and subtraction is made very simple.
   With a system like two's complement, the circuitry for addition and subtraction can be unified,
   whereas otherwise they would have to be treated as separate operations.

   In the examples in this section, I do addition and subtraction in two's complement, but you'll notice
   that every time I do actual operations with binary numbers I am always adding.

  Example 1
   Suppose we want to add two numbers 69 and 12 together. If we're to use decimal, we see the sum is 81.
   But let's use binary instead, since that's what the computer uses.

                                   1 1    Carry Row
  0000 0000 0000 0000 0000 0000 0100 0101 (69)
+ 0000 0000 0000 0000 0000 0000 0000 1100 (12)
----------------------------------------------
  0000 0000 0000 0000 0000 0000 0101 0001 (81)

  Example 2
   Now suppose we want to subtract 12 from 69. Now, 69 - 12 = 69 + (-12). To get the negative of 12 we
   take its binary representation, invert, and add one.
0000 0000 0000 0000 0000 0000 0000 1100

   Invert the digits.
1111 1111 1111 1111 1111 1111 1111 0011

   And add one.
1111 1111 1111 1111 1111 1111 1111 0100

   The last is the binary representation for -12. As before, we'll add the two numbers together.

  1111 1111 1111 1111 1111 1111 1    1    Carry Row
  0000 0000 0000 0000 0000 0000 0100 0101 (69)
+ 1111 1111 1111 1111 1111 1111 1111 0100 (-12)
---------------------------------------------------
  0000 0000 0000 0000 0000 0000 0011 1001 (57)

   We result in 57, which is 69-12.

  Example 3
   Lastly, we'll subtract 69 from 12. Similar to our operation in example 2, 12 - 69 = 12 + (-69).
   The two's complement representation of 69 is the following. I assume you've had enough illustrations
   of inverting and adding one.
1111 1111 1111 1111 1111 1111 1011 1011

   So we add this number to 12.

                                 111      Carry Row
  0000 0000 0000 0000 0000 0000 0000 1100 (12)
+ 1111 1111 1111 1111 1111 1111 1011 1011 (-69)
---------------------------------------------------
  1111 1111 1111 1111 1111 1111 1100 0111 (-57)

   This results in 12 - 69 = -57, which is correct.

Why Inversion and Adding One Works
   Invert and add one. It works, and you may want to know why. If you don't care, skip this, as it is hardly
   essential. This is only intended for those curious as to why that rather strange technique actually makes
   mathematical sense.

   Inverting and adding one might sound like a stupid thing to do, but it's actually just a mathematical
   shortcut of a rather straightforward computation.

  Borrowing and Subtraction
   Remember the old trick we learned in first grade of "borrowing one's" from future ten's places to
   perform a subtraction? You may not, so I'll go over it. As an example, I'll do 93702 minus 58358.
  93702
- 58358
-------

   Now, then, what's the answer to this computation? We'll start at the least significant digit, and
   subtract term by term. We can't subtract 8 from 2, so we'll borrow a digit from the next most
   significant place (the tens place) to make it 12 minus 8. 12 minus 8 is 4, and we note a 1 digit
   above the ten's column to signify that we must remember to subtract by one on the next iteration.
     1
  93702
- 58358
-------
      4

   This next iteration is 0 minus 5, and minus 1, or 0 minus 6. Again, we can't do 0 minus 6, so we
   borrow from the next most significant figure once more to make that 10 minus 6, which is 4.
    11
  93702
- 58358
-------
     44

   This next iteration is 7 minus 3, and minus 1, or 7 minus 4. This is 3. We don't have to borrow this
   time.
    11
  93702
- 58358
-------
    344

   This next iteration is 3 minus 8. Again, we must borrow to make thi 13 minus 8, or 5.
  1 11
  93702
- 58358
-------
   5344

   This next iteration is 9 minus 5, and minus 1, or 9 minus 6. This is 3. We don't have to borrow this
   time.
  1 11
  93702
- 58358
-------
  35344

   So 93702 minus 58358 is 35344.

  Borrowing and it's Relevance to the Negative of a Number
   When you want to find the negative of a number, you take the number, and subtract it from zero. Now,
   suppose we're really stupid, like a computer, and instead of simply writing a negative sign in front
   of a number A when we subtract A from 0, we actually go through the steps of subtracting A from 0.

   Take the following idiotic computation of 0 minus 3:

               1         11        111       1111
000000     000000     000000     000000     000000
-    3     -    3     -    3     -    3     -    3
------     ------     ------     ------     ------
                7         97        997       9997

   Et cetera, et cetera. We'd wind up with a number composed of a 7 in the one's digit, a 9 in every
   digit more significant than the 10^0's place.

  The Same in Binary
   We can do more or less the same thing with binary. In this example I use 8 bit binary numbers, but
   the principle is the same for both 8 bit binary numbers (chars) and 32 bit binary numbers (ints). I
   take the number 75 (in 8 bit binary that is 01001011[2]) and subtract that from zero.

   Sometimes I am in the position where I am subtracting 1 from zero, and also subtracting another
   borrowed 1 against it.

                       1            11            111           1111
  00000000       00000000      00000000       00000000       00000000
- 01001011     - 01001011    - 01001011     - 01001011     - 01001011
----------     ----------    ----------     ----------     ----------
                        1            01            101           0101

    11111         111111       1111111       11111111
  00000000       00000000      00000000       00000000
- 01001011     - 01001011    - 01001011     - 01001011
----------     ----------    ----------     ----------
     10101         110101       0110101       10110101


   If we wanted we could go further, but there would be no point. Inside of a computer the result of
   this computation would be assigned to an eight bit variable, so any bits beyond the eighth would be
   discarded.

   With the fact that we'll simply disregard any extra digits in mind, what difference would it make to
   the end result to have subtracted 01001011 from 100000000 (a one bit followed by 8 zero bits) rather
   than 0? There is none. If we do that, we wind up with the same result:

 11111111
 100000000
- 01001011
----------
 010110101

   So to find the negative of an n-bit number in a computer, subtract the number from 0 or subtract it
   from 2^n. In binary, this power of two will be a one bit followed by n zero bits.

   In the case of 8-bit numbers, it will answer just as well if we subtract our number from (1 +
   11111111) rather than 100000000.

         1
+ 11111111
- 01001011
----------

   In binary, when we subtract a number A from a number of all 1 bits, what we're doing is inverting the
   bits of A. So the subtract operation is the equivalent of inverting the bits of the number. Then, we
   add one.

   So, to the computer, taking the negative of a number, that is, subtracting a number from 0, is the
   same as inverting the bits and adding one, which is where the trick comes from.


---
https://www.geeksforgeeks.org/digital-logic/twos-complement/

Two's Complement
23 Jul, 2025

There are three different ways to represent signed integer (article). a: Signed bit, b: 1's Complement, and
c: 2's Complement. Let's try to understand how these methods have derived and why 2's complement is preferred
over others.

As we know that data are stored in bits. How can we store signed integer in the memory? To solve this
problem, first we will develop a naïve solution and then will iterate it till we have the best solution for
our problem.

a) Signed bit
When trying to store a signed integer, it seems obvious to reserve the left most bit for sign and use
remaining bits to actually store the values. For example: in 4-bit system, first bit from left will be
reserved for sign (0 represent positive whereas 1 represent negative) and other 3 bits will be used to store
the values. Similarly in 8-bit system, first bit from left will be used for sign and remaining 7 will be used
for values.

------------------------------------------------
Sr. No.   Binary Representation    Decimal Value
------------------------------------------------
A         0000                     +0
B         0001                     +1
C         0010                     +2
D         0011                     +3
E         0100                     +4
F         0101                     +5
G         0110                     +6
H         0111                     +7
I         1000                     -0
J         1001                     -1
K         1010                     -2
L         1011                     -3
M         1100                     -4
N         1101                     -5
O         1110                     -6
P         1111                     -7
------------------------------------------------

By using this approach, we are successfully able to represent signed integer. But when we analysis it more
closely, we could observe following drawbacks:

1) Two representations of zero:
In 4-bit system, we should be able to store 16 (24) values, but +1 to +7 and -1 to -7 are only 14 values.
Where are remaining two values? When we observe the table carefully, we will find out that those two values
converge to 0. Thus, we have two representations of zero, that means, one representation for +0 and another
for -0.

But are two representations of 0 a big concern? So what? Instead of 16 unique values, we are only able to
store 15 values. We can afford to reduce the range by 1, isn't it? To the software developer, it might not
concern but for a circuit designer it might be very frustrating to first check if value is +0 and then to
check if it -0.

2) Signed extension doesn't work for negative numbers:
Size of the data is increasing rapidly. Some time we need to extend the bit system so that we can increase
the range of data that can be stored. In 2014, Gangnam Style video overflowed YouTube view limit and it
forced YouTube to upgrade view count from 32-bits to 64-bits signed integer. Similarly, 32-bit Unix clock
will overflow on 19 Jan 2038 because it records time in seconds in a 32-bit signed integer.

So, it is equally important that our representation system should be extendable easily which is not possible
with this representation system. 

--------------------------------------------------------
Decimal  4-bit   5-bit               6-bit
--------------------------------------------------------
+2       0010    00010               000010
+7       0111    00111               000111
-2       1010    10010 (! = 11010)   100010 (! = 111010)
-7       1111    10111 (! = 11111)   100111 (! = 111111)
--------------------------------------------------------

3) Binary addition doesn't work:
Let's try to add two binary numbers:

-----------------------------------------------------------------------------
                   Binary   Decimal     Binary   Decimal     Binary   Decimal
-----------------------------------------------------------------------------
Number-1           0010     +2          0111     +7          1101     -5
Number-2           1010     -2          1010     -2          0011     +3
Binary addition    1100     -4          0001     +1          0000     +0
Decimal addition            +0                   +5                   -2
-----------------------------------------------------------------------------

Why is a simple binary addition not working here? The reason is that the sign bit (left most) is not an
ordinary bit and not part of actual number. Imagine the situation where one has to design the hardware
circuitry to ignore the sign bit to perform addition and then append the sign bit.

So, this was a naïve way to represent signed integer. The main problem with this approach is that we have
mapped negative numbers down up. If we change our mapping system to top down them some of above issue will be
resolved.

b) 1's Complement
If we remap our negative numbers from top-down, then we will be getting following binary table:

--------------------------------------------------------------
S. No.   Binary Representation            Decimal Value
                                  ----------------------------
                                  1's complement    Signed bit
--------------------------------------------------------------
A        0000                     +0                +0
B        0001                     +1                +1
C        0010                     +2                +2
D        0011                     +3                +3
E        0100                     +4                +4
F        0101                     +5                +5
G        0110                     +6                +6
H        0111                     +7                +7
I        1000                     -7                -0
J        1001                     -6                -1
K        1010                     -5                -2
L        1011                     -4                -3
M        1100                     -3                -4
N        1101                     -2                -5
O        1110                     -1                -6
P        1111                     -0                -7
--------------------------------------------------------------

How to get binary representation of an integer in 1's complement method?
  * Positive numbers are represented similar to signed integer method
  * Negative numbers are represented by inverting every bit of corresponding positive number (inverting can
    easily be done by using NOT gate during hardware design)

Let's analyze this closely to see if we have achieved some improvement.
1) Two representations of zero:
In this approach also we have two representations of zero.

2) Signed extension [S:doesn't :S]work for negative numbers:
Signed extension works perfectly for negative numbers.

---------------------------------
Decimal    4-bit   5-bit   6-bit
---------------------------------
+2         0010    00010   000010
+7         0111    00111   000111
-2         1101    11101   111101
-7         1000    11000   111000
---------------------------------

3) Binary addition works with modified rules:

-------------------------------------------------------------------------
                   Binary   Decimal   Binary   Decimal   Binary   Decimal
-------------------------------------------------------------------------
Number-1           0010     +2        0111     +7        1010     -5
Number-2           1101     -2        1101     -2        0011     +3
Binary addition    1111     -0        0100     +4        1101     -2
Decimal addition            +0                 +5                 -2
-------------------------------------------------------------------------

The answer is not always correct, but it is very close to the right answer. We can make it work if we follow
the rule that if you have generated carry forward on your left most bit, then don't throw it away instead
bring it back and add it to the right most bit.

----------------------------------------------------------------------------------
                            Binary   Decimal   Binary   Decimal   Binary   Decimal
----------------------------------------------------------------------------------
Number-1                    0111     +7        1110     -1        0111     +7
Number-2                    1101     -2        1001     -6        1011     -4
Binary addition             (1) 0100 +4        (1) 0111 +7        (1) 0010 +2
Adding carry forward back   0101     +5        1000     -7        0011     +3
----------------------------------------------------------------------------------

Definitely 1's complement method is better than signed bit. Our major concerns are resolved but remain issue
(having two representations of zero) and our hack in binary addition give clues to improve 1's complement
method. Let's rephrase those sentences to make it easier.

  * We have an extra representation of zero which is unnecessary
  * While addition two binary numbers, if we have a carry forward in left most bit, then we have to add +1 to
    the result i.e., the right answer can be found by traversing down to next row in the binary table.

Both of them direct us that an extra representation of zero is the root cause of issue. So, let's remove this
extra zero and shift all negative values to the next row (-7 will move from I -> J, -6 will move from J -> K
and so on...)

c) 2's Complement
When we remove -0 from the 1's complement table and shift all negative values one row below, then we will get
following table which is called 2's complement:

----------------------------------------------------------------------------------------
S. No. Binary Representation                        Decimal Value
                               ---------------------------------------------------------
                               2's complement                1's complement   Signed bit
----------------------------------------------------------------------------------------
A      0000                    +0                            +0               +0
B      0001                    +1                            +1               +1
C      0010                    +2                            +2               +2
D      0011                    +3                            +3               +3
E      0100                    +4                            +4               +4
F      0101                    +5                            +5               +5
G      0110                    +6                            +6               +6
H      0111                    +7                            +7               +7
I      1000                    -8                            -7               -0
J      1001                    -7 = inverse of 7 + 1-bit     -6               -1
K      1010                    -6 = inverse of 6 + 1-bit     -5               -2
L      1011                    -5 = inverse of 5 + 1-bit     -4               -3
M      1100                    -4 = inverse of 4 + 1-bit     -3               -4
N      1101                    -3 = inverse of 3 + 1-bit     -2               -5
O      1110                    -2 = inverse of 2 + 1-bit     -1               -6
P      1111                    -1 = inverse of 1 + 1-bit     -0               -7
----------------------------------------------------------------------------------------

How to get binary representation of an integer in 2's complement method?
  * Positive numbers are represented similar to signed integer method
  * Negative numbers are represented by inverting every bit of corresponding positive number then adding 1
    bit to it

1) One representation of zero:
Now we have only one representation of zero and it allows us to store total 16 unique values (+0 to +7 and -1
to -8).

2) Signed extension works for negative numbers:
Signed extension works perfectly for negative numbers.

-------------------------------
Decimal  4-bit   5-bit   6-bit
-------------------------------
+2       0010    00010   000010
+7       0111    00111   000111
-2       1110    11110   111110
-7       1001    11001   111001
-------------------------------

3) Binary addition:
--------------------------------------------------------------------------
         Binary Decimal   Binary Decimal   Binary Decimal   Binary Decimal
--------------------------------------------------------------------------
Number-1 0010   +2        0111   +7        1011   -5        1111   -1
Number-2 1110   -2        1110   -2        0011   +3        1010   -6
Answer   0000   +0        0101   +5        1110   -2        1001   -7
--------------------------------------------------------------------------

4) First bit is a signed bit:
2's complement has this nice property that first bit is a sign bit because all positive starts with 0 whereas
all negative with 1.

5) Memory overflow check:
While doing addition, we made sure that our answer is within the range but while designing hardware, memory
overflow needs to be detected. It will be very bad idea for hardware designers to check magnitude to catch
overflow. 2's complement method provides a very simple way to detect memory overflow. If carry in to signed
bit is not equal to carry out of signed bit, then it is case of memory overflow i.e., if carry in to signed
bit is 0 but carry out is 1 or if carry in 1 but carry out is 0, then it is case of memory overflow.

----------------------+----------+----------+----------+----------+----------+---------+----------+---------
                      | Binary   |  Decimal |  Binary  |  Decimal |  Binary  | Decimal |  Binary  | Decimal
----------------------+----------+----------+----------+----------+----------+---------+----------+---------
Number-1              | 1011     |    -5    |  0010    |    2     |  0111    |   +7    |  1011    |   -5
----------------------+----------+----------+----------+----------+----------+---------+----------+---------
Number-2              | 1100     |    -4    |  0110    |    6     |  1110    |   -2    |  0011    |    3
----------------------+----------+----------+----------+----------+----------+---------+----------+---------
Addition              | (1) 0111 |          |  (0)1000 |          |  (1)0101 |         |  (0)1110 |
----------------------+----------+----------+----------+----------+----------+---------+----------+---------
carry in to sign bit  |    0     |          |    1     |          |     1    |        |     0     |
----------------------+----------+ Overflow +----------+ Overflow +----------+   No   +-----------+   No
carry out to sign bit |    1     |          |    0     |          |     1    |        |     0     |
----------------------+----------+----------+----------+----------+----------+--------+-----------+---------


---

