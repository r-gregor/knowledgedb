filename: c-parameterized-types-using-new-tag-compatibility-rule-20251006.txt
https://nullprogram.com/blog/2025/06/26/

Parameterized types in C using the new tag compatibility rule
June 26, 2025

   C23 has [https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3037.pdf]a new rule for struct, union, and enum
   compatibility finally appearing in compilers starting with GCC 15, released this past April, and Clang
   later this year. The same struct defined in different translation units (TU) has always been compatible -
   essential to how they work. Until this rule change, each such definition within a TU was a distinct,
   incompatible type. The new rule says that, ackshually, they are compatible! This unlocks some type
   parameterization using macros.

   How can a TU have multiple definitions of a struct? Scope. Prior to C23 this wouldn't compile because
   the compound literal type and the return type were distinct types:

struct Example { int x, y, z; };

struct Example example(void) {
	struct Example { int x, y, z; };
	return (struct Example){1, 2, 3};
}

   Otherwise the definition of struct Example within example was fine, if strange. At first this may not
   seem like a big deal, but let's revisit my technique for dynamic arrays:

typedef struct {
	T        *data;
	ptrdiff_t len;
	ptrdiff_t cap;
} SliceT;

   Where I write out one of these for each T that I might want to put into a slice. With the new rule we
   can change it slightly, taking note of the introduction of a tag (the name after struct):

#define Slice(T)        \
	struct Slice##T {   \
		T        *data; \
		ptrdiff_t len;  \
		ptrdiff_t cap;  \
	}

   This makes the "write it out ahead of time" thing simpler, but with the new rule we can skip the
   "ahead of time" part and conjure slice types on demand. Each declaration with the same T is
   compatible with the others due to matching tags and fields. So, for example, with this macro we can
   declare functions using slices parameterized for different element types.

Slice(int) range(int, Arena *);

float mean(Slice(float));

Slice(Str) split(Str, char delim, Arena *);
Str join(Slice(Str), char delim, Arena *);

   Or using it with our model parser:

typedef struct {
	float x, y, z;
} Vec3;

typedef struct {
	int32_t v[3];
	int32_t n[3];
} Face;

typedef struct {
	Slice(Vec3) verts;
	Slice(Vec3) norms;
	Slice(Face) faces;
} Model;

typedef Slice(Vec3) Polygon;

   I worried these macros might confuse my tools, particularly Universal Ctags because it's
   important to me. Everything handles prototypes better than expected, but ctags doesn't see fields
   with slice types. Overall they're like a very limited form of C++ templates. Though only the types
   are parameterized, not the functions operating on those types. Outside of unwarranted macro abuse,
   this new technique does nothing regarding generic functions. On the other hand, my generic slice
   function complements the new technique, especially with the help of C23's new typeof to mitigate
   _Alignof's limitations:

typedef struct { char *beg, *end; } Arena;
void *alloc(Arena *, ptrdiff_t count, int size, int align);

#define push(a, s)                        \
	((s)->len == (s)->cap                 \
	 ? (s)->data = push_(                 \
	 		(a),                          \
	 		(s)->data,                    \
	 		&(s)->cap,                    \
	 		sizeof(*(s)->data),           \
	 		_Alignof(typeof(*(s)->data))  \
	 	),                                \
	 	(s)->data + (s)->len++            \
	 : (s)->data + (s)->len++)

void *push_(Arena *a, void *data, ptrdiff_t *pcap, int size, int align) {
	ptrdiff_t cap = *pcap;

	if (a->beg != (char *)data + cap*size) {
		void *copy = alloc(a, cap, size, align);
		memcpy(copy, data, cap*size);
		data = copy;
	}

	ptrdiff_t extend = cap ? cap : 4;
	alloc(a, extend, size, align);
	*pcap = cap + extend;
	return data;
}

   This exploits the fact that implementations adopting the new tag rule also have the upcoming C2y
   null pointer rule (note: also requires a cooperating libc). Putting it together, now I can write
   stuff like this:

Slice(int64_t) generate_primes(int64_t limit, Arena *a) {
	Slice(int64_t) primes = {};

	if (limit > 2) {
		*push(a, &primes) = 2;
	}

	for (int64_t n = 3; n < limit; n += 2) {
		bool valid = true;
		for (ptrdiff_t i = 0; valid && i<primes.len; i++) {
			valid = n % primes.data[i];
		}
		if (valid) {
			*push(a, &primes) = n;
		}
	}

	return primes;
}

   But it doesn't take long to run into limitations. It makes little sense to define, say, a Map(K, V)
   without a generic function to manipulate it. This also doesn't work:

typedef struct {
	Slice(Str)          names;
	Slice(Slice(float)) edges;
} Graph;

   Due to Slice##T in the macro, required to establish a unique tag for each element type. The parameter
   to the macro must be an identifier, so you have to build up to it (or define another macro), which
   sort of defeats the purpose, which was entirely about convenience.

typedef Slice(float) Edges;

typedef struct {
	Slice(Str)   names;
	Slice(Edges) edges;
} Graph;

   The benefits are small enough that perhaps it's not worth the costs, but it's been at least worth
   investigating. I've written a small demo of the technique if you'd like to see it in action, or test the
   abilities of your local C implementation:
   [**1][https://gist.github.com/skeeto/3fe27cd81ca5bdb4926b12e03bdfbc62]demo.c


---
[**1]
https://gist.github.com/skeeto/3fe27cd81ca5bdb4926b12e03bdfbc62

// Requires GNU C23: GCC >= 15 or Clang >= 21
#include <stddef.h>
#include <string.h>

#define affirm(c)       while (!(c)) unreachable()
#define lenof(a)        (iz)(sizeof(a) / sizeof(*(a)))
#define new(a, n, t)    (t *)alloc(a, n, sizeof(t), _Alignof(t))
#define maxof(t)        ((t)-1<1 ? (((t)1<<(sizeof(t)*8-2))-1)*2+1 : (t)-1)
#define S(s)            (Str){(u8 *)s, lenof(s)-1}

typedef unsigned char           u8;
typedef int                     b32;
typedef int                     i32;
typedef long long               i64;
typedef typeof((u8*)0-(u8*)0)   iz;
typedef typeof(sizeof(0))       uz;

typedef struct {
	u8 *beg;
	u8 *end;
} Arena;

static void *alloc(Arena *a, iz count, iz size, iz align) {
	iz pad = -(uz)a->beg & (align - 1);
	affirm(count < (a->end - a->beg - pad)/size);
	u8 *r = a->beg + pad;
	a->beg += pad + count*size;
	return memset(r, 0, count*size);
}

typedef struct {
	u8 *data;
	iz	len;
} Str;

static Str span(u8 *beg, u8 *end) {
	affirm(beg <= end);
	return (Str){beg, end-beg};
}

static Str slice(Str s, iz beg, iz end) {
	affirm(beg >= 0 && end <= s.len);
	return span(s.data+beg, s.data+end);
}

#define Slice(T)        \
	struct Slice##T {   \
		T *data;        \
		iz len;         \
		iz cap;         \
	}

#define push(a, s)                        \
	((s)->len == (s)->cap                 \
	 ? (s)->data = push_(                 \
	 		(a),                          \
	 		(s)->data,                    \
	 		&(s)->cap,                    \
	 		sizeof(*(s)->data),           \
	 		_Alignof(typeof(*(s)->data))  \
	 	),                                \
	 	(s)->data + (s)->len++            \
	 : (s)->data + (s)->len++)

static void *push_(Arena *a, void *data, iz *pcap, iz size, iz align) {
	iz cap = *pcap;

	if (a->beg != (u8 *)data + cap*size) {
		void *copy = alloc(a, cap, size, align);
		memcpy(copy, data, cap*size);
		data = copy;
	}

	iz extend = cap ? cap : 4;
	alloc(a, extend, size, align);
	*pcap = cap + extend;
	return data;
}

static Slice(i32) range(i32 n, Arena *a) {
	Slice(i32) r = {};
	affirm(n < maxof(i32));
	for (i32 i = 0; i < n; i++) {
		*push(a, &r) = i;
	}
	return r;
}

static Slice(Str) split(Str s, u8 delim, Arena *a) {
	Slice(Str) r = {};
	iz beg = 0;
	for (iz i = 0; i < s.len; i++) {
		if (s.data[i] == delim) {
			*push(a, &r) = slice(s, beg, i);
			beg = i + 1;
		}
	}
	*push(a, &r) = slice(s, beg, s.len);
	return r;
}

static Slice(u8) append(Arena *a, Slice(u8) buf, Str s) {
	while (buf.cap-buf.len < s.len) {
		iz oldlen = buf.len;
		buf.len = buf.cap;
		push(a, &buf);
		buf.len = oldlen;
	}
	memcpy(buf.data+buf.len, s.data, s.len);
	buf.len += s.len;
	return buf;
}

static Str join(Slice(Str) strings, Str delim, Arena *a) {
	Slice(u8) buf = {};
	for (iz i = 0; i < strings.len; i++) {
		if (i) buf = append(a, buf, delim);
		buf = append(a, buf, strings.data[i]);
	}
	return (Str){buf.data, buf.len};
}

static Slice(i64) generate_primes(i64 limit, Arena *a) {
	Slice(i64) primes = {};

	if (limit > 2) {
		*push(a, &primes) = 2;
	}

	for (i64 n = 3; n < limit; n += 2) {
		b32 valid = true;
		for (iz i = 0; valid && i<primes.len; i++) {
			valid = n % primes.data[i];
		}
		if (valid) {
			*push(a, &primes) = n;
		}
	}

	return primes;
}


// Demo
#include <stdio.h>

static void print(Str s) {
	fwrite(s.data, 1, s.len, stdout);
	putchar('\n');
}

int main() {
	static u8 mem[1<<21];
	Arena a = {mem, mem+lenof(mem)};

	Slice(i32) nums = range(10, &a);
	for (iz i = 0; i < nums.len; i++) {
		printf("%d%c", (int)nums.data[i], i==nums.len-1?'\n':' ');
	}

	Str input = S("foo bar baz");
	Slice(Str) words = split(input, ' ', &a);
	print(input);
	for (iz i = 0; i < words.len; i++) {
		print(words.data[i]);
	}

	Str sentence = join(words, S(","), &a);
	print(sentence);

	Slice(i64) primes = generate_primes(100, &a);
	printf("primes:");
	for (iz i = 0; i < primes.len; i++) {
		printf(" %lld", (long long)primes.data[i]);
	}
	putchar('\n');

	return 0;
}


---

