filename: c_static-keyword-01-multif_20240124.txt
https://www.javatpoint.com/static-in-c

Static in C

   Static is a keyword used in C programming language. It can be used with both variables and functions,
   i.e., we can declare a static variable and static function as well. An ordinary variable is limited
   to the scope in which it is defined, while the scope of the static variable is throughout the
   program.

Static keyword can be used in the following situations:

     * Static global variable
       When a global variable is declared with a static keyword, then it is known as a static global
       variable. It is declared at the top of the program, and its visibility is throughout the program.
     * Static function
       When a function is declared with a static keyword known as a static function. Its lifetime is
       throughout the program.
     * Static local variable
       When a local variable is declared with a static keyword, then it is known as a static local
       variable. The memory of a static local variable is valid throughout the program, but the scope of
       visibility of a variable is the same as the automatic local variables. However, when the function
       modifies the static local variable during the first function call, then this modified value will
       be available for the next function call also.
     * Static member variables
       When the member variables are declared with a static keyword in a class, then it is known as
       static member variables. They can be accessed by all the instances of a class, not with a
       specific instance.
     * Static method
       The member function of a class declared with a static keyword is known as a static method. It is
       accessible by all the instances of a class, not with a specific instance.

   Let's understand through an example.

#include <stdio.h>

int main() {
	printf("%d",func());
	printf("\n%d",func());
	return 0;
}

int func() {
	int count=0; // variable initialization
	count++; // incrementing counter variable

	return count;
}

   In the above code, the func() function is called. In func(), count variable gets updated. As soon as
   the function completes its execution, the memory of the count variable will be removed. If we do not
   want to remove the count from memory, then we need to use the count variable as static. If we declare
   the variable as static, then the variable will not be removed from the memory even when the function
   completes its execution.

   Output
1

1

Static variable
   A static variable is a variable that persists its value across the various function calls.

   Syntax
   The syntax of a static variable is given below:

   static data_type variable_name;

   Let's look at a simple example of static variable.

#include <stdio.h>

int main() {
	printf("%d",func());
	printf("\n%d",func());

	return 0;
}

int func() {
	static int count=0;
	count++;
	return count;
}

   In the above code, we have declared the count variable as static. When the func() is called, the
   value of count gets updated to 1, and during the next function call, the value of the count variable
   becomes 2. Therefore, we can say that the value of the static variable persists within the function
   call.

   Output
1

2

Static Function
   As we know that non-static functions are global by default means that the function can be accessed
   outside the file also, but if we declare the function as static, then it limits the function scope.
   The static function can be accessed within a file only.

   The static function would look like as:

static void func() {
	printf("Hello javaTpoint");
}

Differences b/w static and global variable
   Global variables are the variables that are declared outside the function. These global variables
   exist at the beginning of the program, and its scope remains till the end of the program. It can
   be accessed outside the program also.

   Static variables are limited to the source file in which they are defined, i.e., they are not
   accessible by the other source files.

   Both the static and global variables have static initialization. Here, static initialization means if
   we do not assign any value to the variable then by default, 0 value will be assigned to the variable.

Differences b/w static local and static global variable

   Static global variable
   If the variable declared with a static keyword outside the function, then it is known as a static
   global variable. It is accessible throughout the program.

   Static local variable
   The variable with a static keyword is declared inside a function is known as a static local variable.
   The scope of the static local variable will be the same as the automatic local variables, but its
   memory will be available throughout the program execution. When the function modifies the value of
   the static local variable during one function call, then it will remain the same even during the next
   function call.

Properties of a static variable
   The following are the properties of a static variable:
     * The memory of a static variable is allocated within a static variable.
     * Its memory is available throughout the program, but the scope will remain the same as the
       automatic local variables. Its
     * value will persist across the various function calls.
     * If we do not assign any value to the variable, then the default value will be 0.
     * A global static variable cannot be accessed outside the program, while a global variable can be
       accessed by other source files.



---
https://datatrained.com/post/static-keyword-in-c/

What is the static keyword in C?

   The static keyword in c is used to specify that a variable or a function has static storage duration.
   A variable declared as static inside a function retains its value even after the function has
   returned, which means the variable remains in memory throughout the life of the program. A static
   function is a function that can only be called from within the same file that it is defined in.

   The use of static keyword in c provides several benefits in C programming. Firstly, it enables data
   to be preserved between function calls, which can be useful in some cases. Secondly, it can help
   reduce name collisions, as static variables and functions are only visible within the same file.
   Finally, using the static keyword can help improve program efficiency by reducing the overhead
   associated with dynamic memory allocation and deallocation.

   In summary, the static keyword is used to specify that a variable or a function has static storage
   duration. This can help preserve data between function calls, reduce name collisions, and improve
   program efficiency.

Static variables in C
   In the C programming language, a static keyword is a variable that is allocated statically, which
   means it exists throughout the lifetime of the program. Unlike automatic variables, static variables
   are not created and destroyed every time a function is called. Instead, they are initialized only
   once before the program starts, and their values persist between function calls.

   To declare a static keyword in c, you use the keyword static in front of the variable's data type.
   For example, to declare a static integer variable, you would write static int x;.

   Static keyword are particularly useful for maintaining state information across function calls. They
   can also be used to control access to shared resources, such as shared memory or hardware devices,
   and to store constants that need to be accessed across multiple functions.

   One important aspect of static keyword is their scope. A static variable declared inside a function
   is only visible to that function. In contrast, a static variable declared outside of a function
   (i.e., at file scope) can be accessed by any function within the same file.

   It's worth noting that static keyword are not thread-safe. If your program uses multiple threads,
   you'll need to use synchronization techniques, such as mutexes or semaphores, to ensure that static
   variables are accessed correctly.

   Overall, static keyword in C provide a powerful mechanism for managing state and controlling access
   to shared resources. Understanding their basics is essential for any C programmer.

How to declare and initialize static keyword in C

   Static keyword in C are variables whose lifetime extends throughout the entire execution of the
   program. They can only be accessed within the scope of the function where they are declared, and
   their value persists between function calls.

   To declare a static keyword in c, simply add the keyword static before the variable's data type in
   the function where it will be used. For example:

void myFunction() {
	static int myStaticVariable = 0;
	// rest of the code

}

   In the above example, myStaticVariable is a static variable of type int that is initialized to 0.

   To initialize a static variable, you can do so in the same line as the declaration or separately
   using an assignment operator. For example:

static int myStaticVariable1 = 10;
static int myStaticVariable2;

void myFunction() {
	myStaticVariable2 = 20;
	// rest of the code

}

   In the above example, myStaticVariable1 is initialized to 10 during declaration, while
   myStaticVariable2 is initialized to 0 by default and then set to 20 using the assignment operator
   within the function myFunction.

   It is important to note that since static keyword persist between function calls, they can be useful
   for maintaining state information or for implementing caching mechanisms. However, their usage should
   be careful and thoughtful to prevent any unintended consequences.

How does the static keyword in C work?
   In C, a static function is a function that can only be accessed within the scope of the file where it
   is declared. structure and union in c, This means that it cannot be called from other files using
   the extern keyword. Static functions are declared using the static keyword before the function's
   return type.

   Declaring a function as static limits its scope to the current translation unit, which is the
   collection of files that are compiled together to form a single object file. This makes the function
   invisible to other translation units, improving encapsulation and reducing name collisions.

   Here is an example of a static function:

static int myStaticFunction(int a, int b) {
	return a + b;
}

   In the above example, myStaticFunction is declared as a static function and can only be accessed
   within the file where it is declared.

   Static functions are often used for helper functions that are not intended to be used outside of a
   particular file. By making these functions static, they cannot be called from outside the file, which
   helps to keep the coding organized and prevents accidental misuse.

   In summary, static functions in C are used to limit the scope of a function to the current file,
   improving encapsulation and reducing name collisions. They are often used for helper functions that
   are not intended to be used outside of a particular file.

The benefits of using static keyword in C and functions in C
   Static variables and functions in C offer several benefits to programmers, including:

   Encapsulation: By limiting the scope of static keyword and functions to the current file, they help
   to encapsulate code and prevent naming conflicts. This makes it easier to organize and maintain large
   codebases.

   Memory management: Since static keyword persist throughout the lifetime of the program, they can be
   used to manage memory more efficiently by reducing the need for dynamic memory allocation.

   Performance: static keyword and functions can provide a performance boost since they are resolved at
   compile-time rather than at run-time.

   Data persistence: static keyword in C retain their values between function calls, making them useful
   for storing persistent data that needs to be shared across multiple function calls.

   Information hiding: Static functions can be used to hide implementation details from other parts of
   the code, reducing complexity and making the code easier to understand.

   Code reusability: Static functions can be used to implement reusable utility functions that can be
   used throughout the codebase.

   In summary, static keyword in C and functions in C provide several benefits that can help to improve
   code organization, memory management, performance, and code reuse. They can also be used to hide
   implementation details and provide data persistence, making them a powerful tool for C programmers.

Static variables vs. global variables in C: What's the difference?
   Static variables and global variables in C are both used to define variables that are accessible
   throughout the program, but they differ in their scope and lifetime.

   Global variables are declared outside of any function, and they are accessible from any part of the
   program. They have a lifetime that extends throughout the execution of the program, and their values
   are retained between function calls. Global variables can be useful for sharing data between
   different parts of a program, but they can also introduce potential problems such as naming
   conflicts, security vulnerabilities, and poor encapsulation.

   On the other hand, static variables are declared within a function and have a lifetime that extends
   throughout the execution of the program, but their scope is limited to the function where they are
   declared. Static variables are not visible outside of the function, and they are not subject to
   naming conflicts or security vulnerabilities that can arise from global variables.

   Static keyword in c are useful for managing memory more efficiently and for maintaining state
   information across multiple function calls. They are often used for caching frequently used data, or
   for storing data that needs to be shared between functions within the same file.

   In summary, while both static keyword and global variables provide a means to define variables that
   are accessible throughout a program, static variables offer greater control over scope and lifetime,
   which can help to improve encapsulation and reduce potential problems.

How static keyword in C and functions can improve program performance in C
   Static keyword in C and functions in C can improve program performance by reducing the amount of time
   and memory needed to execute the program.

   Static variables are stored in a special memory region called the data segment, which is allocated at
   compile-time. This means that they do not need to be dynamically allocated at runtime, reducing the
   overhead associated with memory allocation and deallocation. Additionally, since static variables
   retain their values between function calls, they can be used to store frequently accessed data, which
   reduces the need to recalculate the data each time the function is called.

   Similarly, static functions are resolved at compile-time, which reduces the amount of time needed to
   call the function. Since static functions are not visible outside of the file where they are
   declared, the compiler can optimize the code more effectively, resulting in faster execution times.
   Additionally, since static functions cannot be called from outside the file, the compiler can perform
   more aggressive optimizations, such as inlining and loop unrolling, which further improves
   performance.

   Overall, the use of static keyword and functions in C can lead to faster program execution times and
   more efficient memory usage. However, it is important to use them judiciously, as they can also
   introduce potential problems such as naming conflicts, poor encapsulation, and increased code
   complexity.

Examples of using the Static Keyword in C Programs
   The static keyword in c is used to define variables and functions that have a limited scope and a
   static lifetime. Here are some examples of how the static keyword can be used in C programs:

   Static variables:

void myFunction() {
	static int count = 0;
	count++;
	printf("The function has been called %d times.\n", count);
}

   In the above example, the count variable is declared as a static variable inside the myFunction
   function. Since static variables retain their values between function calls, the count variable will
   be incremented each time the function is called, and the value will be retained across function
   calls.

   Static functions:


static int myHelperFunction(int a, int b) {
	return a + b;
}

int myFunction(int a, int b) {
	return myHelperFunction(a, b);
}

   In this example, the myHelperFunction function is declared as a static function. Since static
   functions have a limited scope, they can only be called within the same file where they are defined.
   The myFunction function calls the myHelperFunction function, which can be considered as a utility
   function that is used only within the same file.

   Static variables with external linkage:

static int x = 0;

void incrementX() {
	x++;
}

int getX() {
	return x;
}

   In this example, the x variable is declared as a static variable with external linkage. This means
   that the variable is only visible within the same file, but it can be accessed from other functions
   within the same file. The incrementX function increments the x variable, and the getX function
   returns the value of x.

   Overall, the static keyword in c provides a way to define variables and functions with a limited
   scope and a static lifetime, which can be useful for managing memory more efficiently, improving
   performance, and reducing potential problems such as naming conflicts and poor encapsulation.

Common Mistakes to Avoid when using Static Variables in C
   While using static variables in c can provide many benefits, there are some common mistakes that
   programmers should be aware of to avoid potential problems:

   Initialization: Static variables are automatically initialized to zero, but if a programmer
   explicitly initializes a static variable, they should ensure that the value is not dependent on
   runtime state, as the initialization is performed only once when the program is loaded.

   Lifetime: It is important to understand the lifetime of static variables, as they retain their values
   between function calls. If a programmer uses a static variable to store data that needs to be reset
   between function calls, they should explicitly reset the variable to the desired value.

   Naming conflicts: Since static variables are only visible within the same file, it is possible to
   inadvertently use the same name for static variables in different files, resulting in naming
   conflicts. To avoid this problem, programmers should use unique names for static variables, or use
   the static keyword with external linkage to ensure that the variable is only visible within the same
   file.

   Thread safety: Since static variables retain their values between function calls, they can introduce
   potential problems in multi-threaded programs. If multiple threads access the same static variable
   concurrently, it can lead to race conditions and other synchronization problems.

Conclusion
   In conclusion, the static keyword in c has multiple uses and meanings depending on the context in
   which it is used. When used with a variable inside a function, it causes the variable to retain its
   value between function calls. This is useful for creating variables that need to persist their values
   across multiple function calls, but should not be accessible from other parts of the program.

   When used with a function or global variable, it restricts its visibility to the file in which it is
   declared, making it private and inaccessible to other files. Additionally, the static keyword can be
   used to declare a static member of a struct or union, which means that the member will be shared
   by all instances of the struct or union.

   Overall, the static keyword provides a way to control the scope and lifetime of variables and
   functions in C, and is an important feature of the language.

Frequently Asked Questions
   1. What is the purpose of using the static keyword in C with a variable inside a function?

   The static keyword in C inside a function causes the variable to retain its value between function
   calls. This is useful for creating variables that need to persist their values across multiple
   function calls, but should not be accessible from other parts of the program.
   2. Can the static keyword in C be used with global variables?

   Yes, the static keyword in C can be used with global variables. When used with a global variable, it
   restricts its visibility to the file in which it is declared, making it private and inaccessible to
   other files.
   3. What happens if you use the static keyword in C with a function declaration?

   When used with a function declaration, the static keyword in C restricts the visibility of the
   function to the file in which it is declared, making it private and inaccessible to other files. This
   can be useful for creating helper functions that should not be called from other files.
   4. Can the static keyword in C be used to declare a member of a struct or union?

    Yes, the static keyword in C can be used to declare a static member of a struct or union. This means
   that the member will be shared by all instances of the struct or union.
   5. Is the static keyword in C required for all local variables?

    No, the static keyword is not required for all local variables. It is only necessary when you want a
   variable to retain its value between function calls. If you do not need a variable to persist its
   value, then you can declare it without the static keyword in C.



---
https://www.c-programming-simple-steps.com/static-keyword-in-c.html

The static keyword in C

Definition
   The static keyword in C is a storage-class specifier. It has different meanings, depending on the
   context. Inside a function it makes the variable to retain its value between multiple function calls.
   Outside of a function it restrains the visibility of the function or variable to the current file
   (compilation unit).

Syntax
   The syntax of the static keyword in C is very simple. When defining a variable or function, write the
   static modifier before the type or name.

   These two are equivalent:
static <variable type> <variable name>
<variable type> static <variable name>

   And these are equivalent, too:
static <function type> <function name>()
<function type> static <function name>()

Simple syntax examples
   Here are two examples of static variables:
int static callCount = 0;
static int callCount = 0;

   Here are two examples of static functions:
static void count() {
	...
}

void static count() {
	...
}

The static keyword inside a function
   In C, inside a function, we use the static modifier to declare variables with static storage
   duration. Such variables retain their value throughout multiple calls of the function. These
   variables are initialized only once at compile time. Their life time matches the life time of our
   program.

   Look at the example below. The initialization statement callCount = 0 will not be executed a second
   time. The variable callCount will be initialized to 0 and it will be incremented with each call to
   the function count().

int main() {
	count();
	count();
	count();
}

void count() {
	static int callCount = 0;
	++callCount;
	printf("The function \"count\" was called %d times.\n", callCount);
}

   The output is:

       The function count was called 1 times.
       The function count was called 2 times.
       The function count was called 3 times.

Using the C static keyword outside of a function
   The static keyword can be used with global variables and functions. In this context it limits their
   visibility to the current file (translation unit is more precise here). This means that we cannot
   access a static function or variable from another source file.

   It is a good practice to declare most of your functions static. Leave visible only the functions that
   need to be accessed from other files. This principle is called encapsulation. If you come from an OOP
   language like Java or C#, this is similar to using private and public modifiers.

   The same way we can hide the definition of a variable. This is useful when we want to define
   different variables with the same name in our source files.

Example with a global variable
   The following definitions will give an error during compilation:

   source1.c:
       int count = 0;

   source2.c:
       int count = 0;

   This will not compile and the error looks something like this:

       (.bss+0x0): multiple definition of `count'

   ...or like this:

       source2.obj : error LNK2005: _count already defined in source1.obj

   To define different variables with the same name on global level, you need to use the static keyword
   for at least one of them:

   source1.c:
       static int count = 0;

   source2.c:
       static int count = 0;

Example with static functions in C

static void count() {
	static int callCount = 0;
	++callCount;
	printf("The function \"count\" was called %d times.\n", callCount);
}

Specifying the minimum size of an array parameter
   This is another use of the static keyword in C, although it is rarer. Since C99, we can tell the
   compiler a minimum number of elements that the array contains. This is only valid when we pass an
   array pointer to a function. Here is an example of usage:

void printArray(int myArray[static 10], int size) {
	int i;
	printf("[");
	for(i = 0; i < size; ++i) {
		printf("%d ", myArray[i]);
	}
	printf("]\n");
}

   Sometimes this technique is used to guarantee that the argument will be not null.

void myFunction(int myArray[static 1], int size) {
	...
}

Examples download
   The following zip file contains the source files for all of the examples above. As always you can
   download it for free:
   [https://www.c-programming-simple-steps.com/support-files/static-keyword-in-c.zip]static-keyword-in-c.zip

Storage
   In C, the static variables are placed in the BSS or DATA segments. The BSS segment contains the
   uninitialized data. The DATA segment keeps the initialized data.



---
https://en.wikipedia.org/wiki/Static_(keyword)

Static (keyword)

C and C++
   In C and C++, the effect of the static keyword depends on where the declaration occurs.

   static may act as a storage class (not to be confused with classes in object-oriented
   programming), as can extern, auto and register (which are also reserved words). Every
   variable and function has one of these storage classes; if a declaration does not specify the storage
   class, a context-dependent default is used:
     * extern for all top-level declarations in a source file,
     * auto for variables declared in function bodies.

   Storage class         Lifetime                     Visibility
   extern                program execution            external (whole program)
   static                program execution            internal (translation unit only)
   auto, register        function execution           (none)

   In these languages, the term "static variable" has two meanings which are easy to confuse:
    1. A variable with the same lifetime as the program, as described above (language-independent); or
    2. (C-family-specific) A variable declared with storage class static.

   Variables with storage class extern, which include variables declared at top level without an
   explicit storage class, are static in the first meaning but not the second.

Static global variable
   A variable declared as static at the top level of a source file (outside any function definitions) is
   only visible throughout that file ("file scope", also known as "internal linkage"). In this
   usage, the keyword static is known as an "access specifier".

Static function
   Similarly, a static function - a function declared as static at the top level of a source file
   (outside any class definitions) - is only visible throughout that file ("file scope", also known
   as "internal linkage").

Static local variables
   Variables declared as static inside a function are statically allocated, thus keep their memory
   location throughout all program execution, while having the same scope of visibility as automatic
   local variables (auto and register), meaning they remain local to the function. Hence whatever values
   the function puts into its static local variables during one call will still be present when the
   function is called again.

C++ specific

Static member variables
   In C++, member variables declared as static inside class definitions are class variables
   (shared between all class instances, as opposed to instance variables).

Static member function
   Similarly, a static member function - a member function declared as static inside a class
   definition - is meant to be relevant to all instances of a class rather than any specific instance. A
   member function declared as static can be called without instantiating the class.

Java
   This keyword static means that this method is now a class method; it will be called through class
   name rather than through an object.

   A static method is normally called as <classname>.methodname(), whereas an instance method is
   normally called as <objectname>.methodname().



---
https://stackoverflow.com/questions/572547/what-does-static-mean-in-c

What does "static" mean in C?

   I've seen the word static used in different places in C code; is this like a static function/class in
   C# (where the implementation is shared across objects)?

***
    1. A static variable inside a function keeps its value between invocations.
    2. A static global variable or a function is "seen" only in the file it's declared in

   (1) is the more foreign topic if you're a newbie, so here's an example:

#include <stdio.h>

void foo() {
	int a = 10;
	static int sa = 10;

	a += 5;
	sa += 5;

	printf("a = %d, sa = %d\n", a, sa);
}


int main() {
	int i;

	for (i = 0; i < 10; ++i)
		foo();
}

   This prints:
a = 15, sa = 15
a = 15, sa = 20
a = 15, sa = 25
a = 15, sa = 30
a = 15, sa = 35
a = 15, sa = 40
a = 15, sa = 45
a = 15, sa = 50
a = 15, sa = 55
a = 15, sa = 60

   This is useful for cases where a function needs to keep some state between invocations, and you don't
   want to use global variables. Beware, however, this feature should be used very sparingly - it makes
   your code not thread-safe and harder to understand.

   (2) Is used widely as an "access control" feature. If you have a .c file implementing some
   functionality, it usually exposes only a few "public" functions to users. The rest of its functions
   should be made static, so that the user won't be able to access them. This is encapsulation, a good
   practice.

   Quoting Wikipedia:
     In the C programming language, static is used with global variables and functions to set their
     scope to the containing file. In local variables, static is used to store the variable in the
     statically allocated memory instead of the automatically allocated memory. While the language does
     not dictate the implementation of either type of memory, statically allocated memory is typically
     reserved in data segment of the program at compile time, while the automatically allocated memory
     is normally implemented as a transient call stack.

   And to answer your second question, it's not like in C#.

   In C++, however, static is also used to define class attributes (shared between all objects of the
   same class) and methods. In C there are no classes, so this feature is irrelevant.

***
   There is one more use not covered here, and that is as part of an array type declaration as an
   argument to a function:

int someFunction(char arg[static 10]) {
	...
}

   In this context, this specifies that arguments passed to this function must be an array of type char
   with at least 10 elements in it.

***
   Short answer ... it depends.
    1. Static defined local variables do not lose their value between function calls. In other words
       they are global variables, but scoped to the local function they are defined in.
    2. Static global variables are not visible outside of the C file they are defined in.
    3. Static functions are not visible outside of the C file they are defined in.

***
   Multi-file variable scope example

   Here I illustrate how static affects the scope of function definitions across multiple files.

   a.c
#include <stdio.h>

/*
Undefined behavior: already defined in main.
Binutils 2.24 gives an error and refuses to link.
https://stackoverflow.com/questions/27667277/why-does-borland-compile-with-multiple-definitions-of-same-object-in-different-c
*/

/*int i = 0;*/

/* Works in GCC as an extension: https://stackoverflow.com/a/3692486/895245 */
/*int i;*/

/* OK: extern. Will use the one in main. */
extern int i;

/* OK: only visible to this file. */
static int si = 0;

void a() {
	i++;
	si++;
	puts("a()");
	printf("i = %d\n", i);
	printf("si = %d\n", si);
	puts("");
}

   main.c

#include <stdio.h>

int i = 0;
static int si = 0;

void a();

void m() {
	i++;
	si++;
	puts("m()");
	printf("i = %d\n", i);
	printf("si = %d\n", si);
	puts("");
}

int main() {
	m();
	m();
	a();
	a();
	return 0;
}


   Compile and run:
$> gcc -c a.c -o a.o
$> gcc -c main.c -o main.o
$> gcc -o main main.o a.o

   Output:
m()
i = 1
si = 1

m()
i = 2
si = 2

a()
i = 3
si = 1

a()
i = 4
si = 2

   Interpretation
     * there are two separate variables for si, one for each file
     * there is a single shared variable for i

   As usual, the smaller the scope, the better, so always declare variables static if you can.

   In C programming, files are often used to represent "classes", and static variables represent private
   static members of the class.

   What standards say about it
   C99 N1256 draft 6.7.1 "Storage-class specifiers" says that static is a "storage-class specifier".

   6.2.2/3 "Linkages of identifiers" says static implies internal linkage:
     If the declaration of a file scope identifier for an object or a function contains the
     storage-class specifier static, the identifier has internal linkage.

   and 6.2.2/2 says that internal linkage behaves like in our example:
     In the set of translation units and libraries that constitutes an entire program, each declaration
     of a particular identifier with external linkage denotes the same object or function. Within one
     translation unit, each declaration of an identifier with internal linkage denotes the same object
     or function.

   where "translation unit is a source file after preprocessing.

   How GCC implements it for ELF (Linux)?

   With the STB_LOCAL binding.

   If we compile:
int i = 0;
static int si = 0;

   and disassemble the symbol table with:
readelf -s main.o

   the output contains:
Num:    Value          Size Type    Bind   Vis      Ndx Name
  5: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 si
 10: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 i

   so the binding is the only significant difference between them. Value is just their offset into the
   .bss section, so we expect it to differ.

   STB_LOCAL is documented on the ELF spec at
   http://www.sco.com/developers/gabi/2003-12-17/ch4.symtab.html:

     STB_LOCAL Local symbols are not visible outside the object file containing their definition. Local
     symbols of the same name may exist in multiple files without interfering with each other

   which makes it a perfect choice to represent static.

   Variables without static are STB_GLOBAL, and the spec says:

     When the link editor combines several relocatable object files, it does not allow multiple
     definitions of STB_GLOBAL symbols with the same name.

   which is coherent with the link errors on multiple non static definitions.

   If we crank up the optimization with -O3, the si symbol is removed entirely from the symbol table: it
   cannot be used from outside anyways. TODO why keep static variables on the symbol table at all when
   there is no optimization? Can they be used for anything? Maybe for debugging.

***
   People keep saying that 'static' in C has two meanings. I offer an alternate way of viewing it that
   gives it a single meaning:
     * Applying 'static' to an item forces that item to have two properties: (a) It is not visible
       outside the current scope; (b) It is persistent.

   The reason it seems to have two meanings is that, in C, every item to which 'static' may be applied
   already has one of these two properties, so it seems as if that particular usage only involves the
   other.

   For example, consider variables. Variables declared outside of functions already have persistence (in
   the data segment), so applying 'static' can only make them not visible outside the current scope
   (compilation unit). Contrariwise, variables declared inside of functions already have non-visibility
   outside the current scope (function), so applying 'static' can only make them persistent.

   Applying 'static' to functions is just like applying it to global variables - code is necessarily
   persistent (at least within the language), so only visibility can be altered.

   NOTE: These comments only apply to C. In C++, applying 'static' to class methods is truly giving the
   keyword a different meaning. Similarly for the C99 array-argument extension.

***
   From Wikipedia:
     In the C programming language, static is used with global variables and functions to set their
     scope to the containing file. In local variables, static is used to store the variable in the
     statically allocated memory instead of the automatically allocated memory. While the language does
     not dictate the implementation of either type of memory, statically allocated memory is typically
     reserved in data segment of the program at compile time, while the automatically allocated memory
     is normally implemented as a transient call stack.

***
   If you declare a variable in a function static, its value will not be stored on the function call
   stack and will still be available when you call the function again.

   If you declare a global variable static, its scope will be restricted to within the file in which you
   declared it. This is slightly safer than a regular global which can be read and modified throughout
   your entire program.

***
   I hate to answer an old question, but I don't think anybody has mentioned how K&R explain it in
   section A4.1 of "The C Programming Language".

   In short, the word static is used with two meanings:
    1. Static is one of the two storage classes (the other being automatic). A static object keeps its
       value between invocations. The objects declared outside all blocks are always static and cannot
       be made automatic.
    2. But, when the static keyword (big emphasis on it being used in code as a keyword) is used with a
       declaration, it gives that object internal linkage so it can only be used within that translation
       unit. But if the keyword is used in a function, it changes the storage class of the object (the
       object would only be visible within that function anyway). The opposite of static is the extern
       keyword, which gives an object external linkage.

   Peter Van Der Linden gives these two meanings in "Expert C Programming":
     * Inside a function, retains its value between calls.
     * At the function level, visible only in this file.

***
   Share what I learned about this point.

   In C static is a declaration specifier, which falls into three categories:
     * storage classes: there are four classes: auto, static, extern and register.
     * type qualifiers: like keywords: const, volatile, etc.
     * type specifiers: like keywords: void, char, short, int, etc.

   So static is a storage classes. It will determine the following three properties of each variable in
   a C program.
     * storage duration: means when memory is allocated for the variable and when the memory is
       released. A variable with static storage duration stays at the same memory location as long as
       the program is running.
     * scope: means the portion of the program text in which the variable can be accessed. A static
       variable has a file scope instead of a block scope.
     * linkage: means the extent to which the variable can be shared by different parts(or files) of a
       program. If a static variable is declared inside a block then it has no linkage. If a static
       variable is declared outside blocks, then it has internal linkage. Internal linkage makes it
       accessible in a single file.

   The static storage class has a different effect on a variable depending on it is declared outside a
   block or inside a block. Need to consider case by case.

...


---

