filename: c-anonymous-unions-and-structures-multyf-20250925.txt
https://www.geeksforgeeks.org/c/g-fact-38-anonymous-union-and-structure/

Anonymous Union and Structure in C
23 Jul, 2025

   In C, anonymous unions and anonymous structures are the unnamed structures and unions whose members
   can be directly accessed without creating a variable. These are generally used when the members of
   the union or structure need to be accessed directly, without using a separate name for the union or
   structure.

   Example:

#include <stdio.h>

struct A {
	int i;
	struct {
		int ii;
		char cc;
	};
};

int main() {
	// Define and name the anonymous union
	struct A a;
		a.i = 1;
		a.ii = 20;
	a.cc = 'C';

	printf("%d %d %c", a.i, a.ii, a.cc);

	return 0;
}

   Output
1 20 C

   Explanation: In the above code, we have created structure A inside which we have defined an unnamed
   structure whose members we have accessed directly later in the program as if they are the direct
   members of A. Similarly, we can define an anonymous union.

Syntax
   The syntax of anonymous structure and union are same as the normal structs and unions but
   without a name.

 union/structure {
	 type1 member1;
	 type1 member2;
	.
	.
 } (variables if any);

   The variable of anonymous structure can only be defined with the declaration as shown in the syntax

Examples of Anonymous Unions and Structures
   The below examples illustrate how the anonymous structure and unions are used in C:

Anonymous Structure Outside Nesting

#include <stdio.h>

// Anonymous structure
struct {
	int ii;
	char cc;
} anon;

int main() {
	// Define and name the anonymous union
	anon.ii = 20;
	anon.cc = 'C';
	printf("%d %c", anon.ii, anon.cc);

	return 0;
}

   Output
20 C

Anonymous Union in Local Scope

#include <stdio.h>

int main() {
	// Define an anonymous union
	union {
		int age;
		float height;
	} person;

	// Assigning values to the members
	person.age = 25;
	printf("%d\n", person.age);

	person.height = 5.5;
	printf("%.2f", person.height);

	return 0;
}

   Output
25
5.50

   Explanation: In this code, an anonymous union is defined inline inside the main() function without a
   name, containing two members: age (integer) and height (float). The person variable accesses these
   members, but since union members share memory, only one member can hold a value at a time.

Anonymous Union within a Structure
   Anonymous unions can also be used within structures to allow flexible data representation.

#include <stdio.h>

struct Data {
	int id;

	// Anonymous union inside structure
	union {
		int i;
		float f;
	};
};

int main() {
	struct Data data;

	data.id = 1;
	data.i = 100;

	printf("%d\n", data.id);
	printf("%d\n", data.i);

	data.f = 5.5;
	printf("%.1f", data.f);

	return 0;
}

   Output
1
100
5.5

   Explanation: In this code, a structure Data contains an anonymous union with i and f. The main()
   function initializes the structure, assigns values to the union members, and prints the values. Since
   it's a union, both members share the same memory, and the last assigned value overwrites the previous
   one.

What about C++?
   Anonymous Unions and Structures are NOT part of C++ 11 standard, but most of the C++ compilers
   support them. Since this is a C only feature, the C++ implementations don't allow to anonymous
   struct/union to have private or protected members, static members, and functions.


---
https://www.tutorialspoint.com/cprogramming/c_anonymous_structures_and_unions.htm

Anonymous Structures and Unions in C

   The feature of anonymous structures and unions was introduced in C11 standard. The aim was to enhance
   the flexibility of C and also to discard the need of superfluous naming in certain cases.

   The feature of defining struct and union anonymously has been found to be extremely useful,
   especially in applications involving the creation of complex data structures, hardware register
   mappings, etc. This allows for more straightforward and readable code.

Anonymous Structure
   An anonymous structure is a structure definition without a tag or a typedef. It is usually
   nested within another struct.

Syntax for Anonymous Struct

   Here is the syntax of defining an anonymous structure −
struct type {
	elem1;
	elem2;
	struct {
		elem3;
		elem4;
	};
};

Access Members of Anonymous Structure
   Members of an anonymous struct/union can access the parent struct directly, simplifying the notation.

Example 1
   In the code below, we have defined a structure with the name as employee. Inside it, an anonymous
   struct is intended to hold date, month and year of birth of the employee. In the example on nested
   structure, we had an internal dob structure. Now well use anonymous struct.

#include <stdio.h>

struct employee {
	char name[10];
	float salary;
	struct {
		int d, m, y;
	};
};

int main(){

	struct employee e1;
	strcpy (e1.name, "Kiran");
	e1.salary=25000;
	e1.d = 12;
	e1.m = 5;
	e1.y = 1990;

	printf("Name: %s\n", e1.name);
	printf("Salary: %f\n", e1.salary);
	printf("Date of Birth: %d-%d-%d\n", e1.d, e1.m, e1.y);

	return 0;
}

Output
   When you run this code, it will produce the following output −
Name: Kiran
Salary: 25000.000000
Date of Birth: 12-5-1990

   Note that the "d", "m" and "y" elements of inner anonymous struct are accessed directly.

Example 2
   The outer struct type in the following example is student, which has a nested anonymous struct to
   store the title and ID of the course.

#include <stdio.h>

struct student {
	char name[10];
	int age;
	struct {
		char coursettl[20];
		int courseid;
	};
};

int main(){

	struct student s1;
	strcpy (s1.name, "Kiran");
	s1.age = 27;
	strcpy(s1.coursettl, "C Programming");
	s1.courseid=1;

	printf("Name: %s\n", s1.name);
	printf("age: %d\n", s1.age);
	printf("Course Title: %s Course ID: %d\n", s1.coursettl, s1.courseid);

	return 0;
}

Output
   When you run this code, it will produce the following output −
Name: Kiran
age: 27
Course Title: C Programming Course ID: 1

Anonymous Union
   An anonymous union is a special type of union that doesn't have a name. Unlike regular unions,
   anonymous unions are primarily used to create unnamed members that can be accessed directly without
   qualifying them with a union name.

Syntax for Anonymous Union
   Here is the syntax of defining an anonymous union −

struct type {
	elem1;
	elem2;
	union {
		elem3;
		elem4;
	};
};

Access Members of Anonymous Union
   The members of the anonymous union can be accessed directly without using a union name.

Example
   Anonymous unions do not have a name. The elements share the same memory location.

   Take a look at the following example −

#include <stdio.h>

struct mystruct {
	int var;
	union {
		int var1;
		float var2;
		char var3;
	};
};

int main(){

	struct mystruct data;

	data.var = 10;
	data.var2 = 5.55;

	printf("mystruct.var: %d\n", data.var);
	printf("anonymous union elements: %d %f %c", data.var1, data.var2, data.var3);

	return 0;
}

Output
   Run the code and check its output −
mystruct.var: 10
anonymous union elements: 1085381018 5.550000

   Note: Like a regular union, the uninitialized members of an anonymous union variable also show
   garbage value.

Advantages of Anonymous Struct and Union
   One of the main advantages is the ability to access the members directly without any inner struct or
   union name. This can make the code more readable. Here is a list of some other advantages of using
   anonymous structures and unions −
     * Memory Efficiency − Like regular unions, anonymous unions allow different data types to
       share the same memory space, leading to more memory-efficient code, especially useful in
       low-memory environments.
     * Flexibility − Anonymous structures provide flexibility in how data is represented and accessed,
       allowing for more dynamic and versatile data structures.
     * Convenience − This feature allows for a compact representation of a variable that can hold
       different data types.
     * Ease of Initialization − They can be easier to initialize and use, as they do not require the
       declaration of a union variable.

   Note that anonymous struct or union types were not part of the C standard before C11. Hence, their
   use in the code may lead to compatibility problems, if the target system uses a compiler compliant
   with earlier standards.


---
https://stackoverflow.com/questions/8932707/when-are-anonymous-structs-and-unions-useful-in-c11

When are anonymous structs and unions useful in C11?

   C11 adds, among other things, 'Anonymous Structs and Unions'.

   I poked around but could not find a clear explanation of when anonymous structs and unions would be
   useful. I ask because I don't completely understand what they are. I get that they are structs or
   unions without the name afterwards, but I have always (had to?) treat that as an error so I can only
   conceive a use for named structs.

***
   Anonymous union inside structures are very useful in practice. Consider that you want to implement a
   discriminated sum type (or tagged union), an aggregate with a boolean and either a float or a
   char* (i.e. a string), depending upon the boolean flag. With C11 you should be able to code

typedef struct {
	bool is_float;
	union {
		float f;
		char* s;
	};
} mychoice_t;

double as_float(mychoice_t* ch) {
	if (ch->is_float) return ch->f;
	else return atof(ch->s);
}

   With C99, you'll have to name the union, and code ch->u.f and ch->u.s which is less readable and more
   verbose.

   Another way to implement some tagged union type is to use casts. The Ocaml runtime gives a
   lot of examples.

***
   A typical and real world use of anonymous structs and unions are to provide an alternative view to
   data. For example when implementing a 3D point type:

typedef struct {
	union{
		struct{
			double x;
			double y;
			double z;
		};
		double raw[3];
	};
}vec3d_t;

vec3d_t v;
v.x = 4.0;
v.raw[1] = 3.0; // Equivalent to v.y = 3.0
v.z = 2.0;

   This is useful if you interface to code that expects a 3D vector as a pointer to three doubles.
   Instead of doing f(&v.x) which is ugly, you can do f(v.raw) which makes your intent clear.

***
struct bla {
	struct { int a; int b; };
	int c;
};

   the type struct bla has a member of a C11 anonymous structure type.

   struct { int a; int b; } has no tag and the object has no name: it is an anonymous structure type.

   You can access the members of the anonymous structure this way:
struct bla myobject;
myobject.a = 1;  // a is a member of the anonymous structure inside struct bla
myobject.b = 2;  // same for b
myobject.c = 3;  // c is a member of the structure struct bla

***
   Another useful implementation is when you are dealing with rgba colors, since you might want access
   each color on its own or as a single int.

typedef struct {
	union {
		struct {uint8_t a, b, g, r;};
		uint32_t val;
	};
} Color;

   Now you can access the individual rgba values or the entire value, with its highest byte being r.
   i.e:

int main(void) {
	Color x;
	x.r = 0x11;
	x.g = 0xAA;
	x.b = 0xCC;
	x.a = 0xFF;

	printf("%X\n", x.val);

	return 0;
}

***
   I'm not sure why C11 allows anonymous structures inside structures. But Linux uses it with a
   certain language extension:

/**
 * struct blk_mq_ctx - State for a software queue facing the submitting CPUs
 */
struct blk_mq_ctx {
	struct {
		spinlock_t          lock;
		struct list_head    rq_lists[HCTX_MAX_TYPES];
	} ____cacheline_aligned_in_smp;

	/* ... other fields without explicit alignment annotations ... */

} ____cacheline_aligned_in_smp;

   I'm not sure if that example strictly necessary, except to make the intent clear.

   EDIT: I found another similar pattern which is more clear-cut. The anonymous struct feature is used
   with this attribute:
#if defined(RANDSTRUCT_PLUGIN) && !defined(__CHECKER__)
#define __randomize_layout __attribute__((randomize_layout))
#define __no_randomize_layout __attribute__((no_randomize_layout))
/* This anon struct can add padding, so only enable it under randstruct. */
#define randomized_struct_fields_start  struct {
#define randomized_struct_fields_end    } __randomize_layout;
#endif

   I.e. a language extension / compiler plugin to randomize field order (ASLR-style exploit
   "hardening"):

struct kiocb {
	struct file   *ki_filp;

	/* The 'ki_filp' pointer is shared in a union for aio */
	randomized_struct_fields_start

	loff_t        ki_pos;
	void          (*ki_complete)(struct kiocb *iocb, long ret, long ret2);
	void          *private;
	int           ki_flags;
	u16           ki_hint;
	u16           ki_ioprio; /* See linux/ioprio.h */
	unsigned int  ki_cookie; /* for ->iopoll */

	randomized_struct_fields_end
};


---
https://learn.microsoft.com/en-us/cpp/cpp/anonymous-class-types?view=msvc-170

Anonymous Class Types
2021-08-03

In this article
   Classes can be anonymous - that is, they can be declared without an identifier. This is useful when
   you replace a class name with a typedef name, as in the following:

typedef struct {
	unsigned x;
	unsigned y;
} POINT;

   Note
   The use of anonymous classes shown in the previous example is useful for preserving compatibility
   with existing C code. In some C code, the use of typedef in conjunction with anonymous structures is
   prevalent.

   Anonymous classes are also useful when you want a reference to a class member to appear as though it
   were not contained in a separate class, as in the following:

struct PTValue {
	POINT ptLoc;
	union {
		int  iValue;
		long lValue;
	};
};

PTValue ptv;

   In the preceding code, iValue can be accessed using the object member-selection operator (.) as
   follows:

int i = ptv.iValue;

   Anonymous classes are subject to certain restrictions. For more information about anonymous unions,
   see Unions. Anonymous classes:
     * Cannot have a constructor or destructor.
     * Cannot be passed as arguments to functions (unless type checking is defeated using ellipsis).
     * Cannot be returned as return values from functions.

Anonymous structs

START: Microsoft Specific
   A Microsoft C extension allows you to declare a structure variable within another structure without
   giving it a name. These nested structures are called anonymous structures. C++ does not allow
   anonymous structures.

   You can access the members of an anonymous structure as if they were members in the containing
   structure.

// anonymous_structures.c
#include <stdio.h>

struct phone {
	int  areacode;
	long number;
};

struct person {
	char   name[30];
	char   gender;
	int    age;
	int    weight;
	struct phone;    // Anonymous structure; no name needed
} Jim;

int main() {
	Jim.number = 1234567;
	printf_s("%d\n", Jim.number);
}

//Output: 1234567
END: Microsoft Specific


---
https://medium.com/@pauljlucas/anonymous-structures-in-c-eaff5e44a146

Anonymous Structures in C
Aug 10, 2025

Introduction
   As I wrote, C allows anonymous unions, that is a union without a name:

enum token_kind {
	TOKEN_NONE,
	TOKEN_INT,
	TOKEN_FLOAT,
	TOKEN_CHAR,
	TOKEN_STR
};

struct token {
	enum token_kind kind;
	union {                  // "anonymous" union
		long   i;
		double f;
		char   c;
		char  *s;
	};
};

struct token t = { .kind = TOKEN_CHAR, .c = 'a' };

   It turns out that C (but not C++) also allows anonymous structures. They tend to be used even less
   than anonymous unions, but, in a few cases, anonymous structures are just the thing.

In Expressions
   Among my previous articles, the one on Handy C/C++ Preprocessor Macros actually used an anonymous
   structure, though I didn't specifically call attention to it. In that article, what was needed was a
   way to use static_assert in an expression:

#define STATIC_ASSERT_EXPR(EXPR,MSG) \
	(!!sizeof( struct { static_assert( (EXPR), MSG ); char c; } ))

   As I wrote:
     The trick is to realize that static_assert can be used pretty much anywhere, including inside a
     struct declaration that's an argument to sizeof() that makes the whole thing an expression.

   In this case, the struct isn't being used for its "struct-ness," but only to make the use of
   static_assert there valid C.

Inside Unions
   Just as anonymous unions can be used inside structures, anonymous structures can be used inside
   unions, for example:

union point_3d {
	struct {
		int x, y, z;
	};
	int v[3];
};

   defines a 3D point such that either coordinates can be accessed individually via x, y, or z - or as a
   3-element vector v. The struct is used to group members together as one member of the union. Just as
   with anonymous unions, the struct members behave as if they're direct members of their enclosing
   union (except they have distinct offsets).

For Flexible Array Members
   As I wrote, C99 introduced the ability to have the last member of a struct with more than one
   named member be a flexible array member, that is an array of an unspecified size:

typedef struct slist_node slist_node_t;
struct slist_node {
	slist_node_t               *next;
	alignas( max_align_t ) char data[];  // flexible array
};

   I wrote:
     While you can have such a struct on the stack, it's not useful since no size is set aside for the
     array (hence, accessing the array is undefined behavior). To be useful, such a struct has to
     be allocated on the heap ....

   It turns out there is a way to allocate such a struct on the stack using a compound literal of an
   anonymous structure:

#define STRUCT_FAM(STRUCT,FAM,NFAM) (STRUCT*) &(                          \
	struct {                                                              \
		alignas(STRUCT) char buf[sizeof(STRUCT) + sizeof(FAM) * (NFAM)];  \
	}                                                                     \
){ 0 }

   Then, to allocate an slist_node on the stack where data is sized to accommodate, say, a struct like:

typedef struct c_scope_data c_scope_data_t;

struct c_scope_data {
	char    *name;
	c_type_t type;
};

   we can do:
slist_node_t *const node = STRUCT_FAM( slist_node_t, c_scope_data_t, 1 );

   and node will point to an slist_node in the stack frame of the enclosing function and its lifetime is
   the scope containing the declaration.

   (These code snippets are from the source code of [https://github.com/paul-j-lucas/cdecl]cdecl.)

   In the macro, buf is declared to be the total size of the structcontaining the flexible array member
   (that excludes it from the size) plus the size that we want the flexible array member to be treated
   as (times the number of array elements).

   The problem is that an array of char might not be suitably aligned for a structure, hence the need
   for alignas. However, alignas can't be used in the declaration of a compound literal - except if it's
   inside a structure, here an anonymous structure.

   This still works because the offset of buf relative to the start of the structure it's in is 0, hence
   a pointer to the struct via & is the same as for buf that is then cast to STRUCT*.

Conclusion
   Anonymous structures, though use in practice is rare, have a few niche uses that work nicely.
   C Programming


---
https://heycoach.in/blog/anonymous-structs-and-unions-in-c/

Anonymous Structs and Unions in C

   Welcome, dear reader! Today, we're diving into the mysterious world of Anonymous Structs and Unions
   in C. If you've ever felt like your code could use a little more mystery and intrigue, you're in the
   right place! Think of this as the secret agent of C programming-stealthy, efficient, and a little bit
   confusing at times. So, grab your magnifying glass, and let's get started!

What Are Anonymous Structs and Unions?
   First things first, let's break down what we mean by anonymous structs and unions. In the world of C,
   a struct is like a box that can hold different types of data. Imagine it as a toolbox where you can
   store various tools (data types) together. Now, an anonymous struct is a toolbox without a name tag.
   You can use it, but you can't call it by name. It's like that friend who shows up to the party but
   doesn't want anyone to know they're there.

   Similarly, a union is a special data type that allows you to store different data types in the same
   memory location. Think of it as a magic box that can transform into different shapes depending on
   what you need at the moment. You can only use one shape at a time, though-so choose wisely!

Why Use Anonymous Structs and Unions?
   Now, you might be wondering, "Why on earth would I want to use something anonymous?" Well, here are
   some compelling reasons:
     * Encapsulation: They help keep your code neat and tidy by encapsulating data without cluttering
       the global namespace.
     * Temporary Use: Perfect for situations where you need a struct or union just for a short time-like
       a one-night stand, but with data.
     * Readability: They can make your code more readable by reducing the number of named types you have
       to keep track of.
     * Flexibility: You can define them on the fly, which is great for dynamic data structures.
     * Memory Efficiency: They can save memory by allowing you to use the same space for different data
       types.
     * Less Boilerplate: You don't have to declare a type name, which means less typing-yay for
       laziness!
     * Scoped Usage: They can be defined within functions, limiting their scope and preventing
       accidental misuse.
     * Anonymous Unions: They allow you to access members directly without needing to reference the
       union name.
     * Cleaner Code: They can help reduce the number of lines of code, making your program look more
       professional.
     * Debugging Ease: They can simplify debugging by keeping related data together without the overhead
       of named types.

How to Declare Anonymous Structs and Unions
   Ready to get your hands dirty? Here's how you can declare anonymous structs and unions in C:

Anonymous Struct Declaration

struct {
	int age;
	float height;
} person;

   In this example, we've created an anonymous struct to hold a person's age and height. You can access
   the members like this:
person.age = 30;
person.height = 5.9;

Anonymous Union Declaration

union {
	int intValue;
	float floatValue;
} data;

   Here, we've created an anonymous union that can hold either an integer or a float. Remember, you can
   only use one at a time:
data.intValue = 42; // Use the integer
data.floatValue = 3.14; // Now the float

Using Anonymous Structs and Unions in Functions
   Anonymous structs and unions shine when used in functions. Let's see how they can make your life
   easier:
     * Function Parameters: You can pass anonymous structs directly to functions without needing to
       define a type.
     * Return Types: Functions can return anonymous structs, making it easy to return multiple values.
     * Local Scope: They can be defined within a function, keeping your global namespace clean.
     * Dynamic Allocation: You can dynamically allocate anonymous structs using malloc.
     * Initialization: You can initialize them directly in the function call.
     * Nested Structures: You can nest anonymous structs within other structs or unions.
     * Cleaner Code: They help reduce the amount of boilerplate code in your functions.
     * Type Safety: They maintain type safety while allowing flexibility.
     * Debugging: Easier to debug since they are scoped to the function.
     * Readability: Makes your function signatures cleaner and easier to read.

Examples of Anonymous Structs and Unions in Action
   Let's look at some real-world examples to see how anonymous structs and unions can be used
   effectively:

Example 1: Storing Student Information

#include <stdio.h>

void printStudentInfo() {
	struct {
		char name[50];
		int age;
	} student = {"Alice", 20};

	printf("Name: %s, Age: %d\n", student.name, student.age);
}

Example 2: Using Unions for Different Data Types

#include <stdio.h>

void printData() {
	union {
		int intValue;
		float floatValue;
	} data;

	data.intValue = 10;
	printf("Integer: %d\n", data.intValue);
	data.floatValue = 5.5;
	printf("Float: %f\n", data.floatValue);
}

Common Pitfalls and Best Practices
   While anonymous structs and unions can be incredibly useful, they come with their own set of
   challenges. Here are some common pitfalls to avoid:
     * Memory Management: Be cautious with memory allocation; always free dynamically allocated structs.
     * Data Overwriting: Remember that unions can only hold one value at a time-don't forget what you
       stored!
     * Scope Confusion: Be aware of the scope of your anonymous structs; they can't be accessed outside
       their defined context.
     * Debugging Complexity: Debugging can be tricky if you lose track of which member of a union is
       currently valid.
     * Readability Issues: Overusing anonymous types can make your code harder to read; use them
       judiciously.
     * Type Safety: Ensure you're using the correct type when accessing union members.
     * Initialization: Always initialize your structs and unions to avoid undefined behavior.
     * Documentation: Document your code well, especially when using anonymous types, to help others
       (and future you) understand it.
     * Compiler Support: Ensure your compiler supports anonymous structs and unions, as some older
       compilers may not.
     * Testing: Thoroughly test your code to catch any potential issues with anonymous types.

Conclusion
   And there you have it! Anonymous structs and unions in C are like the ninjas of the programming
   world-stealthy, efficient, and sometimes a little confusing. They can help you write cleaner, more
   efficient code, but they also come with their own set of challenges. So, use them wisely!

   If you enjoyed this journey into the world of anonymous types, why not explore more advanced C
   topics? There's a whole universe of programming concepts waiting for you! Until next time, happy
   coding!


---
https://gcc.gnu.org/onlinedocs/gcc/Unnamed-Fields.html

6.2.6 Unnamed Structure and Union Fields

   As permitted by ISO C11 and for compatibility with other compilers, GCC allows you to define a
   structure or union that contains, as fields, structures and unions without names. For example:

struct {
	int a;
	union {
		int b;
		float c;
	};
	int d;
} foo;

   In this example, you are able to access members of the unnamed union with code like 'foo.b'. Note
   that only unnamed structs and unions are allowed, you may not have, for example, an unnamed int.

   You must never create such structures that cause ambiguous field definitions. For example, in this
   structure:

struct {
	int a;
	struct {
		int a;
	};
} foo;

   it is ambiguous which a is being referred to with 'foo.a'. The compiler gives errors for such
   constructs.

   Unless -fms-extensions is used, the unnamed field must be a structure or union definition without a
   tag (for example, 'struct { int a; };'). If -fms-extensions is used, the field may also be a
   definition with a tag such as 'struct foo { int a; };', a reference to a previously defined structure
   or union such as 'struct foo;', or a reference to a typedef name for a previously defined structure
   or union type.

   The option -fplan9-extensions enables -fms-extensions as well as two other extensions. First, a
   pointer to a structure is automatically converted to a pointer to an anonymous field for assignments
   and function calls. For example:

struct s1 { int a; };
struct s2 { struct s1; };
extern void f1 (struct s1 *);
void f2 (struct s2 *p) { f1 (p); }

   In the call to f1 inside f2, the pointer p is converted into a pointer to the anonymous field.

   Second, when the type of an anonymous field is a typedef for a struct or union, code may refer to the
   field using the name of the typedef.

typedef struct { int a; } s1;
struct s2 { s1; };
s1 f1 (struct s2 *p) { return p->s1; }

   These usages are only permitted when they are not ambiguous.


---

