filename: c_dynamic-memory-allocation-multif_20211027.txt
https://www.learn-c.org/en/Dynamic_allocation


Dynamic allocation

   Dynamic allocation of memory is a very important subject in C. It allows building complex data
   structures such as linked lists. Allocating memory dynamically helps us to store data without
   initially knowing the size of the data in the time we wrote the program.

   To allocate a chunk of memory dynamically, we have to have a pointer ready to store the location of
   the newly allocated memory. We can access memory that was allocated to us using that same pointer,
   and we can use that pointer to free the memory again, once we have finished using it.

   Let's assume we want to dynamically allocate a person structure. The person is defined like this:
typedef struct {
	char * name;
	int age;
} person;

   To allocate a new person in the myperson argument, we use the following syntax:
person * myperson = (person *) malloc(sizeof(person));

   This tells the compiler that we want to dynamically allocate just enough to hold a person struct in
   memory and then return a pointer of type person to the newly allocated data. The memory allocation
   function malloc() reserves the specified memory space. In this case, this is the size of person in
   bytes.

   The reason we write (person *) before the call to malloc() is that malloc() returns a "void pointer,"
   which is a pointer that doesn't have a type. Writing (person *) in front of it is called typecasting,
   and changes the type of the pointer returned from malloc() to be person. However, it isn't strictly
   necessary to write it like this as C will implicitly convert the type of the returned pointer to that
   of the pointer it is assigned to (in this case, myperson) if you don't typecast it.

   Note that sizeof is not an actual function, because the compiler interprets it and translates it to
   the actual memory size of the person struct.

   To access the person's members, we can use the -> notation:
myperson->name = "John";
myperson->age = 27;

   After we are done using the dynamically allocated struct, we can release it using free:
free(myperson);

   Note that the free does not delete the myperson variable itself, it simply releases the data that it
   points to. The myperson variable will still point to somewhere in the memory - but after calling
   myperson we are not allowed to access that area anymore. We must not use that pointer again until we
   allocate new data using it.



---
https://www.programiz.com/c-programming/c-dynamic-memory-allocation

C Dynamic Memory Allocation

   In this tutorial, you'll learn to dynamically allocate memory in your C program using standard
   library functions: malloc(), calloc(), free() and realloc().

   As you know, an array is a collection of a fixed number of values. Once the size of an array is
   declared, you cannot change it.

   Sometimes the size of the array you declared may be insufficient. To solve this issue, you can
   allocate memory manually during run-time. This is known as dynamic memory allocation in C
   programming.

   To allocate memory dynamically, library functions are malloc(), calloc(), realloc() and free() are
   used. These functions are defined in the <stdlib.h> header file.

C malloc()
   The name "malloc" stands for memory allocation.

   The malloc() function reserves a block of memory of the specified number of bytes. And, it returns a
   pointer of void which can be casted into pointers of any form.

Syntax of malloc()

ptr = (castType*) malloc(size);

   Example
ptr = (float*) malloc(100 * sizeof(float));

   The above statement allocates 400 bytes of memory. It's because the size of float is 4 bytes. And,
   the pointer ptr holds the address of the first byte in the allocated memory.

   The expression results in a NULL pointer if the memory cannot be allocated.

C calloc()
   The name "calloc" stands for contiguous allocation.

   The malloc() function allocates memory and leaves the memory uninitialized, whereas the calloc()
   function allocates memory and initializes all bits to zero.

Syntax of calloc()

ptr = (castType*)calloc(n, size);

   Example:
ptr = (float*) calloc(25, sizeof(float));

   The above statement allocates contiguous space in memory for 25 elements of type float.
     ________________________________________________________________________________________________

C free()
   Dynamically allocated memory created with either calloc() or malloc() doesn't get freed on their own.
   You must explicitly use free() to release the space.

Syntax of free()

free(ptr);

   This statement frees the space allocated in the memory pointed by ptr.

Example 1: malloc() and free()

// Program to calculate the sum of n numbers entered by the user

#include <stdio.h>
#include <stdlib.h>

int main() {
	int n, i, *ptr, sum = 0;

	printf("Enter number of elements: ");
	scanf("%d", &n);

	ptr = (int*) malloc(n * sizeof(int));

	// if memory cannot be allocated
	if(ptr == NULL) {
		printf("Error! memory not allocated.");
		exit(0);
	}

	printf("Enter elements: ");
	for(i = 0; i < n; ++i) {
		scanf("%d", ptr + i);
		sum += *(ptr + i);
	}

	printf("Sum = %d", sum);

	// deallocating the memory
	free(ptr);

	return 0;
}

   Output
Enter number of elements: 3
Enter elements: 100
20
36
Sum = 156

   Here, we have dynamically allocated the memory for n number of int.

Example 2: calloc() and free()

// Program to calculate the sum of n numbers entered by the user

#include <stdio.h>
#include <stdlib.h>

int main() {
	int n, i, *ptr, sum = 0;
	printf("Enter number of elements: ");
	scanf("%d", &n);

	ptr = (int*) calloc(n, sizeof(int));
	if(ptr == NULL) {
		printf("Error! memory not allocated.");
		exit(0);
	}

	printf("Enter elements: ");
	for(i = 0; i < n; ++i) {
		scanf("%d", ptr + i);
		sum += *(ptr + i);
	}

	printf("Sum = %d", sum);
	free(ptr);
	return 0;
}

   Output
Enter number of elements: 3
Enter elements: 100
20
36
Sum = 156

C realloc()
   If the dynamically allocated memory is insufficient or more than required, you can change the size of
   previously allocated memory using the realloc() function.

Syntax of realloc()

ptr = realloc(ptr, x);

   Here, ptr is reallocated with a new size x.

Example 3: realloc()

#include <stdio.h>
#include <stdlib.h>

int main() {
	int *ptr, i , n1, n2;
	printf("Enter size: ");
	scanf("%d", &n1);

	ptr = (int*) malloc(n1 * sizeof(int));

	printf("Addresses of previously allocated memory:\n");
	for(i = 0; i < n1; ++i)
		printf("%pc\n",ptr + i);

	printf("\nEnter the new size: ");
	scanf("%d", &n2);

	// rellocating the memory
	ptr = realloc(ptr, n2 * sizeof(int));

	printf("Addresses of newly allocated memory:\n");
	for(i = 0; i < n2; ++i)
		printf("%pc\n", ptr + i);

	free(ptr);

	return 0;
}

   Output
Enter size: 2
Addresses of previously allocated memory:
26855472
26855476

Enter the new size: 4
Addresses of newly allocated memory:
26855472
26855476
26855480
26855484



---
https://www.design-reuse.com/articles/25090/dynamic-memory-allocation-fragmentation-c.html

Dynamic Memory Allocation and Fragmentation in C and C++

Abstract:
In C and C++, it can be very convenient to allocate and de-allocate blocks of memory as and when
needed. This is certainly standard practice in both languages and almost unavoidable in C++. However,
the handling of such dynamic memory can be problematic and inefficient. For desktop applications, where
memory is freely available, these difficulties can be ignored. For embedded - generally real time -
applications, ignoring the issues is not an option.

Dynamic memory allocation tends to be nondeterministic; the time taken to allocate memory may not be
predictable and the memory pool may become fragmented, resulting in unexpected allocation failures. In
this session the problems will be outlined in detail and an approach to deterministic dynamic memory
allocation detailed.

C/C++ Memory Spaces
It may be useful to think in terms of data memory in C and C++ as being divided into three separate spaces:

Static memory. This is where variables, which are defined outside of functions, are located. The keyword
static does not generally affect where such variables are located; it specifies their scope to be local
to the current module. Variables that are defined inside of a function, which are explicitly declared
static, are also stored in static memory. Commonly, static memory is located at the beginning of the RAM
area. The actual allocation of addresses to variables is performed by the embedded software development
toolkit: a collaboration between the compiler and the linker. Normally, program sections are used to
control placement, but more advanced techniques, like Fine Grain Allocation, give more control. Commonly,
all the remaining memory, which is not used for static storage, is used to constitute the dynamic storage
area, which accommodates the other two memory spaces.

Automatic variables. Variables defined inside a function, which are not declared static, are automatic. There
is a keyword to explicitly declare such a variable - auto - but it is almost never used. Automatic
variables (and function parameters) are usually stored on the stack. The stack is normally located using
the linker. The end of the dynamic storage area is typically used for the stack. Compiler optimizations
may result in variables being stored in registers for part or all of their lifetimes; this may also be
suggested by using the keyword register.

The heap. The remainder of the dynamic storage area is commonly allocated to the heap, from which
application programs may dynamically allocate memory, as required.

Dynamic Memory in C
In C, dynamic memory is allocated from the heap using some standard library functions. The two key
dynamic memory functions are malloc() and free().

The malloc() function takes a single parameter, which is the size of the requested memory area in bytes. It
returns a pointer to the allocated memory. If the allocation fails, it returns NULL. The prototype for
the standard library function is like this:

          void *malloc(size_t size);

The free() function takes the pointer returned by malloc() and de-allocates the memory. No indication
of success or failure is returned. The function prototype is like this:

          void free(void *pointer);

To illustrate the use of these functions, here is some code to statically define an array and set the
fourth element's value:

         int my_array[10];
         my_array[3] = 99;

The following code does the same job using dynamic memory allocation:

         int *pointer;
         pointer = malloc(10 * sizeof(int));
         *(pointer+3) = 99;

The pointer de-referencing syntax is hard to read, so normal array referencing syntax may be used, as
[ and ] are just operators:

          pointer[3] = 99;

When the array is no longer needed, the memory may be de-allocated thus:

       free(pointer);
       pointer = NULL;

Assigning NULL to the pointer is not compulsory, but is good practice, as it will cause an error to be
generated if the pointer is erroneous utilized after the memory has been de-allocated.

The amount of heap space actually allocated by malloc() is normally one word larger than that requested. The
additional word is used to hold the size of the allocation and is for later use by free(). This "size
word" precedes the data area to which malloc() returns a pointer.

There are two other variants of the malloc() function: calloc() and realloc().

The calloc() function does basically the same job as malloc(), except that it takes two parameters -
the number of array elements and the size of each element - instead of a single parameter (which is
the product of these two values). The allocated memory is also initialized to zeros. Here is the prototype:

          void *calloc(size_t nelements, size_t elementSize);

The realloc() function resizes a memory allocation previously made by malloc(). It takes as parameters
a pointer to the memory area and the new size that is required. If the size is reduced, data may be
lost. If the size is increased and the function is unable to extend the existing allocation, it will
automatically allocate a new memory area and copy data across. In any case, it returns a pointer to the
allocated memory. Here is the prototype:

void *realloc(void *pointer, size_t size);

Dynamic Memory in C++
Management of dynamic memory in C++ is quite similar to C in most respects. Although the library functions
are likely to be available, C++ has two additional operators - new and delete - which enable code
to be written more clearly, succinctly and flexibly, with less likelihood of errors. The new operator
can be used in three ways:

        p_var = new typename;
        p_var = new type(initializer);
        p_array = new type [size];

In the first two cases, space for a single object is allocated; the second one includes initialization. The
third case is the mechanism for allocating space for an array of objects.

The delete operator can be invoked in two ways:

          delete p_var;
          delete[] p_array;

The first is for a single object; the second deallocates the space used by an array. It is very important
to use the correct de-allocator in each case.

There is no operator that provides the functionality of the C realloc() function.

Here is the code to dynamically allocate an array and initialize the fourth element:

      int* pointer;
      pointer = new int[10];
      pointer[3] = 99;

Using the array access notation is natural. De-allocation is performed thus:

      delete[] pointer;
      pointer = NULL;

Again, assigning NULL to the pointer after deallocation is just good programming practice. Another option
for managing dynamic memory in C++ is the use the Standard Template Library. This may be inadvisable
for real time embedded systems.

Issues and Problems
As a general rule, dynamic behavior is troublesome in real time embedded systems. The two key areas
of concern are determination of the action to be taken on resource exhaustion and nondeterministic
execution performance.

There are a number of problems with dynamic memory allocation in a real time system. The standard
library functions (malloc() and free()) are not normally reentrant, which would be problematic in a
multithreaded application. If the source code is available, this should be straightforward to rectify
by locking resources using RTOS facilities (like a semaphore). A more intractable problem is associated
with the performance of malloc(). Its behavior is unpredictable, as the time it takes to allocate memory
is extremely variable. Such nondeterministic behavior is intolerable in real time systems.

Without great care, it is easy to introduce memory leaks into application code implemented using malloc()
and free(). This is caused by memory being allocated and never being deallocated. Such errors tend to
cause a gradual performance degradation and eventual failure. This type of bug can be very hard to locate.

Memory allocation failure is a concern. Unlike a desktop application, most embedded systems do not have
the opportunity to pop up a dialog and discuss options with the user. Often, resetting is the only option,
which is unattractive. If allocation failures are encountered during testing, care must be taken with
diagnosing their cause. It may be that there is simply insufficient memory available - this suggests
various courses of action. However, it may be that there is sufficient memory, but not available in one
contiguous chunk that can satisfy the allocation request. This situation is called memory fragmentation.

Memory Fragmentation
The best way to understand memory fragmentation is to look at an example. For this example, it is assumed
hat there is a 10K heap. First, an area of 3K is requested, thus:

         #define K (1024)
         char *p1;
         p1 = malloc(3*K);

Then, a further 4K is requested:

        p2 = malloc(4*K);

3K of memory is now free.

Some time later, the first memory allocation, pointed to by p1, is de-allocated:

        free(p1);

This leaves 6K of memory free in two 3K chunks. A further request for a 4K allocation is issued:

       p1 = malloc(4*K);

This results in a failure - NULL is returned into p1 - because, even though 6K of memory is available,
there is not a 4K contiguous block available. This is memory fragmentation.

It would seem that an obvious solution would be to de-fragment the memory, merging the two 3K blocks to
make a single one of 6K. However, this is not possible because it would entail moving the 4K block to
which p2 points. Moving it would change its address, so any code that has taken a copy of the pointer
would then be broken. In other languages (such as Visual Basic, Java and C#), there are defragmentation
(or "garbage collection") facilities. This is only possible because these languages do not support
direct pointers, so moving the data has no adverse effect upon application code. This defragmentation
may occur when a memory allocation fails or there may be a periodic garbage collection process that is
run. In either case, this would severely compromise real time performance and determinism.

Memory with an RTOS
A real time operating system may provide a service which is effectively a reentrant form of
malloc(). However, it is unlikely that this facility would be deterministic.

Memory management facilities that are compatible with real time requirements - i.e. they are deterministic
- are usually provided. This is most commonly a scheme which allocates blocks - or "partitions"
- of memory under the control of the OS.

Block/partition Memory Allocation
Typically, block memory allocation is performed using a "partition pool", which is defined statically
or dynamically and configured to contain a specified number of blocks of a specified fixed size. For
Nucleus OS, the API call to define a partition pool has the following prototype:

  STATUS
   NU_Create_Partition_Pool (NU_PAR TITION_POOL *pool, CHAR *name, VOID *start_address, UNSIGNED pool_size,
   UNSIGNED partition_size, OPTION suspend_type);

This is most clearly understood by means of an example:

   status = NU_Create_Partition_Pool(&MyPoo l, "any name", (VOID *) 0xB000, 2000, 40, NU_FIFO);

This creates a partition pool with the descriptor MyPool, containing 2000 bytes of memory, filled with
partitions of size 40 bytes (i.e. there are 50 partitions). The pool is located at address 0xB000. The
pool is configured such that, if a task attempts to allocate a block, when there are none available, and
it requests to be suspended on the allocation API call, suspended tasks will be woken up in a first-in,
first-out order. The other option would have been task priority order.

Another API call is available to request allocation of a partition. Here is an example using Nucleus OS:

      status = NU_Allocate_Partition(&MyPool, &ptr, NU_SUSPEND);

This requests the allocation of a partition from MyPool. When successful, a pointer to the allocated block
is returned in ptr. If no memory is available, the task is suspended, because NU_SUSPEND was specified;
other options, which may have been selected, would have been to suspend with a timeout or to simply
return with an error.

When the partition is no longer required, it may be de-allocated thus:

      status = NU_Deallocate_Partition(ptr);

If a task of higher priority was suspended pending availability of a partition, it would now be run. There
is no possibility for fragmentation, as only fixed size blocks are available. The only failure mode is
true resource exhaustion, which may be controlled and contained using task suspend, as shown.

Additional API calls are available which can provide the application code with information about the status
of the partition pool - for example, how many free partitions are currently available. Care is required
in allocating and de-allocating partitions, as the possibility for the introduction of memory leaks remains.

Memory Leak Detection
The potential for programmer error resulting in a memory leak when using partition pools is recognized
by vendors of real time operating systems. Typically, a profiler tool is available which assists with
the location and rectification of such bugs.

Real Time Memory Solutions
Having identified a number of problems with dynamic memory behavior in real time systems, some possible
solutions and better approaches can be proposed.

Dynamic Memory
It is possible to use partition memory allocation to implement malloc() in a robust and deterministic
fashion. The idea is to define a series of partition pools with block sizes in a geometric progression;
e.g. 32, 64, 128, 256 bytes. A malloc() function may be written to deterministically select the
correct pool to provide enough space for a given allocation request. This approach takes advantage of
the deterministic behavior of the partition allocation API call, the robust error handling (e.g. task
suspend) and the immunity from fragmentation offered by block memory.

Conclusions
C and C++ use memory in various ways, both static and dynamic. Dynamic memory includes stack and heap.

Dynamic behavior in embedded real time systems is generally a source of concern, as it tends to be
non-deterministic and failure is hard to contain.

Using the facilities provided by most real time operating systems, a dynamic memory facility may be
implemented which is deterministic, immune from fragmentation and with good error handling.



---
https://www.javatpoint.com/dynamic-memory-allocation-in-c

Dynamic memory allocation in C

   The concept of dynamic memory allocation in c language enables the C programmer to allocate memory at
   runtime. Dynamic memory allocation in c language is possible by 4 functions of stdlib.h header file.
    1. malloc()
    2. calloc()
    3. realloc()
    4. free()

   Before learning above functions, let's understand the difference between static memory allocation and
   dynamic memory allocation.

   -----------------------------------------------------------------------------------------------------
   static memory allocation                             dynamic memory allocation
   -----------------------------------------------------------------------------------------------------
   memory is allocated at compile time.                 memory is allocated at run time.
   memory can't be increased while executing program.   memory can be increased while executing program.
   used in array.                                       used in linked list.
   -----------------------------------------------------------------------------------------------------

   Now let's have a quick look at the methods used for dynamic memory allocation.
   malloc()  allocates single block of requested memory.
   calloc()  allocates multiple block of requested memory.
   realloc() reallocates the memory occupied by malloc() or calloc() functions.
   free()    frees the dynamically allocated memory.

malloc() function in C
   The malloc() function allocates single block of requested memory.
   It doesn't initialize memory at execution time, so it has garbage value initially.
   It returns NULL if memory is not sufficient.
   The syntax of malloc() function is given below:

ptr=(cast-type*)malloc(byte-size)

   Let's see the example of malloc() function.

#include<stdio.h>  
#include<stdlib.h>  

int main() {
	int n,i,*ptr,sum=0;    
	printf("Enter number of elements: ");    
	scanf("%d",&n);    
	ptr=(int*)malloc(n*sizeof(int));  //memory allocated using malloc    

	if (ptr==NULL) {    
		printf("Sorry! unable to allocate memory");    
		exit(0);    
	}    

	printf("Enter elements of array: ");    
	for (i=0;i<n;++i) {    
		scanf("%d",ptr+i);    
		sum+=*(ptr+i);    
	}    

	printf("Sum=%d",sum);    
	free(ptr);     
	return 0;  
}

   Output
Enter elements of array: 3
Enter elements of array: 10
10
10
Sum=30

calloc() function in C

   The calloc() function allocates multiple block of requested memory.
   It initially initialize all bytes to zero.
   It returns NULL if memory is not sufficient.
   The syntax of calloc() function is given below:

ptr=(cast-type*)calloc(number, byte-size)

   Let's see the example of calloc() function.

#include<stdio.h>  
#include<stdlib.h>  

int main() {  
	int n,i,*ptr,sum=0;	
	printf("Enter number of elements: ");	
	scanf("%d",&n);    
	ptr=(int*)calloc(n,sizeof(int));  //memory allocated using calloc	

	if (ptr==NULL) {
		printf("Sorry! unable to allocate memory");    
		exit(0);
	}

	printf("Enter elements of array: ");

	for (i=0;i<n;++i) {
		scanf("%d",ptr+i);
		sum+=*(ptr+i);
	}

	printf("Sum=%d",sum);
	free(ptr);
	return 0;  
} 

   Output
Enter elements of array: 3
Enter elements of array: 10
10
10
Sum=30

realloc() function in C
   If memory is not sufficient for malloc() or calloc(), you can reallocate the memory by realloc()
   function. In short, it changes the memory size.

   Let's see the syntax of realloc() function.

ptr=realloc(ptr, new-size) 

free() function in C
   The memory occupied by malloc() or calloc() functions must be released by calling free() function.
   Otherwise, it will consume memory until program exit.

   Let's see the syntax of free() function.

free(ptr)



---
https://medium.com/geekculture/an-easy-guide-to-understand-dynamic-memory-allocation-in-c-programming-language-bb34d29f7a06

An Easy Guide to Understand Dynamic Memory Allocation in C Programming Language

   One marvelous thing about C is that it is so intertwined with memory - and by that, I mean the
   programmer has quite a good understanding of "what goes where". Manual memory management for
   dynamic memory allocation in the C programming language is possible via a group of functions
   in the C standard library, namely malloc, realloc, calloc and free as we will see later in this
   article.

C has three main pools of memory:
    1. static: global variable storage, permanent for the entire run of the program.

static int static_No;
   This is the area in which the variables that have been declared global or static and those string
   constants (for example "My string") are stored. In this memory area, you find all those data that are
   present from the very beginning of a program until the end of the execution.

   2. stack: local variable storage (automatic, continuous memory).
int main(void) {
	int i; /* i is only visible/usable inside main()*/
	return 0;
}

   A memory stack is an area in which the variables appear and disappear at a certain point during the
   execution of a program. We use it mainly to store the variables local to a function. These variables
   have a reduced scope, they are only available while the function (where we have defined them) is
   being executed. All these variables are stored in the stack and therefore, the area continuously
   receives operations to insert and delete variables.

   3. heap: dynamic storage (large pool of memory, not allocated in contiguous order).
   This area contains memory available to be reserved and freed at any point during the execution of a
   program. It is not reserved for local variable functions as in the stack, but for "dynamic memory"
   for data structures that are not known to be needed until the program is being executed. This is
   where malloc() and free() fall in.

     Note that out of these three memory zones, only the global memory has a fixed size that is known
     when the program starts execution. Both the stack and the heap store data the size of which cannot
     be know until the program is executing.

Let's talk about malloc( ) and free( )
   Say that you would like to allocate a certain amount of memory during the execution of your
   application. You can call the malloc()function at any time, and it will request a block of memory
   from the heap. The operating system will reserve a block of memory for your program, and you can use
   it in any way you like. When you are done with the block, you return it to the operating system for
   recycling by calling the free()function, then other applications can reserve it later for their own
   use.

   The malloc() or "memory allocation" method in C is used to dynamically allocate a single large block
   of memory with the specified size. It returns a pointer of type void which can be cast into a pointer
   of any form.
/* Let's see the abracadabra of malloc and free in this code*/
int main() {
	int *p;
	p = (int *)malloc(sizeof(int)); /*requested for 4 bytes */
	if (p == 0) {
		printf("ERROR: Out of memory\n");
		return 1;
	}

	*p = 5;
	printf("%d\n", *p);
	free(p); /*free the requested memory for int *p */
	return 0;
}

The key processes happening in the above code are:
    1. The malloc statement first looks at the amount of memory available on the heap and asks, "Is
       there enough memory available to allocate a block of memory of the size requested?" The amount of
       memory needed for the block is known from the parameter passed into malloc - in this case,
       sizeof(int) is 4 bytes. If there is not enough memory available, the malloc function returns the
       address zero to show the error (another name for zero is NULL and you will see it used throughout
       C code). Otherwise malloc proceeds.
    2. If memory is available on the heap, the system "allocates" or "reserves" a block from the heap of
       the size specified so that it isn't accidentally used by over one malloc statement.
    3. The system then places into the pointer variable (p, in this case) the address of the reserved
       block. *p itself contains an address. The allocated block can hold a value of the type specified,
       and the pointer points to it.

   The program next checks the pointer p to make sure that the allocation request is successful with the
   line if (p == 0) (which could have also been written as if (p == NULL) or even if (!p). If the
   allocation fails (if p is zero), the program ends. If the allocation is successful, the program then
   initializes the block to the value 5, prints out the value, and calls the free function to return the
   memory to the heap before the program ends.

   free() in C is used to dynamically "de-allocate" the memory. The memory allocated using functions
   malloc() and calloc() is not de-allocated on its own. Hence the free() method is used, whenever the
   dynamic memory allocation takes place. It helps to reduce wastage of memory by freeing it. The
   variable to be freed is passed in the parenthesis. See the above code block.

   malloc() has its twin brother calloc() and twin sister realloc(), let's see what the siblings have
   for us

Calloc( )
   blocks of memory of the specified type. It is very much similar to malloc() but has two different
   points and these are:
   i) It initializes each block with a default value '0'.
   ii) It has two parameters or arguments as compared to malloc()
/* n = number of elements
 * element_size = the size of each element
 */ptr = (cast-type*)calloc(n, element_size);

realloc( )
   This function attempts to resize the memory block pointed to by a pointer that was previously
   allocated with a call to malloc or calloc
void *realloc(void *ptr, size_t size)
     * ptr - This is the pointer to a memory block previously allocated with malloc, calloc or realloc
       to be reallocated. If this is NULL, a new block is allocated and a pointer to it is returned by
       the function.
     * size - This is the new size for the memory block in bytes. If it is 0 and the pointer points to
       an existing block of memory, the memory block pointed by pointer is de-allocated and a NULL
       pointer is returned.

NOTE
   It is very important to check that the pointer is zero after each allocation. Since the heap varies
   in size constantly depending on which programs are running, how much memory they have allocated,
   etc., there is never any guarantee that a call to malloc will succeed. You should check the pointer
   after any call to malloc to make sure the pointer is valid.

   Delete the malloced block of memory before the program ends. When a program ends, the operating
   system "cleans up after it," releasing its executable code space, stack, global memory space, and any
   heap allocations for recycling. Therefore, there are no long-term consequences to leaving allocations
   pending at program termination. However, I think it is not the best coding technique, and "memory
   leaks" during the execution of a program are harmful.

   I hope this guide made this concept easier for you to understand.
   Take a tour of my previously written articles



---
https://www.cs.fsu.edu/~myers/c++/notes/dma.html

Dynamic Memory Allocation

Allocating memory
   There are two ways that memory gets allocated for data storage:
    1. Compile Time (or static) Allocation
          + Memory for named variables is allocated by the compiler
          + Exact size and type of storage must be known at compile time
          + For standard array declarations, this is why the size has to be constant
    2. Dynamic Memory Allocation
          + Memory allocated "on the fly" during run time
          + dynamically allocated space usually placed in a program segment known as the heap or the
            free store
          + Exact amount of space or number of items does not have to be known by the compiler in
            advance.
          + For dynamic memory allocation, pointers are crucial

Dynamic Memory Allocation
     * We can dynamically allocate storage space while the program is running, but we cannot create new
       variable names "on the fly"
     * For this reason, dynamic allocation requires two steps:
         1. Creating the dynamic space.
         2. Storing its address in a pointer (so that the space can be accesed)
     * To dynamically allocate memory in C++, we use the new operator.
     * De-allocation:
          + Deallocation is the "clean-up" of space being used for variables or other data storage
          + Compile time variables are automatically deallocated based on their known extent (this is
            the same as scope for "automatic" variables)
          + It is the programmer's job to deallocate dynamically created space
          + To de-allocate dynamic memory, we use the delete operator

Allocating space with new
     * To allocate space dynamically, use the unary operator new, followed by the type being allocated.
 new int;        // dynamically allocates an int
 new double;     // dynamically allocates a double

     * If creating an array dynamically, use the same form, but put brackets with a size after the type:
 new int[40];      // dynamically allocates an array of 40 ints
 new double[size]; // dynamically allocates an array of size doubles
                   //  note that the size can be a variable

     * These statements above are not very useful by themselves, because the allocated spaces have no
       names! BUT, the new operator returns the starting address of the allocated space, and this
       address can be stored in a pointer:
 int * p;        // declare a pointer p
 p = new int;    // dynamically allocate an int and load address into p

 double * d;     // declare a pointer d
 d = new double; // dynamically allocate a double and load address into d

 // we can also do these in single line statements
 int x = 40;
 int * list = new int[x];
 float * numbers = new float[x+10];

       Notice that this is one more way of initializing a pointer to a valid target (and the most
       important one).

  Accessing dynamically created space
     * So once the space has been dynamically allocated, how do we use it?
     * For single items, we go through the pointer. Dereference the pointer to reach the dynamically
       created target:
  int * p = new int;    // dynamic integer, pointed to by p

  *p = 10;              // assigns 10 to the dynamic integer
  cout << *p;           // prints 10

     * For dynamically created arrays, you can use either pointer-offset notation, or treat the pointer
       as the array name and use the standard bracket notation:
  double * numList = new double[size];  // dynamic array

  for (int i = 0; i < size; i++)
      numList[i] = 0;                   // initialize array elements to 0

  numList[5] = 20;                      // bracket notation
  *(numList + 7) = 15;                  // pointer-offset notation
                                        //   means same as numList[7]

  Deallocation of dynamic memory
     * To deallocate memory that was created with new, we use the unary operator delete. The one operand
       should be a pointer that stores the address of the space to be deallocated:
  int * ptr = new int;          // dynamically created int
  // ...
  delete ptr;                   // deletes the space that ptr points to

       Note that the pointer ptr still exists in this example. That's a named variable subject to scope
       and extent determined at compile time. It can be reused:
  ptr = new int[10];            // point p to a brand new array

     * To deallocate a dynamic array, use this form:
  delete [] name_of_pointer;

       Example:
  int * list = new int[40];     // dynamic array

  delete [] list;               // deallocates the array
  list = 0;                     // reset list to null pointer

       After deallocating space, it's always a good idea to reset the pointer to null unless you are
       pointing it at another valid target right away.

     * To consider: So what happens if you fail to deallocate dynamic memory when you are finished with
       it? (i.e. why is deallocation important?)

Application Example: Dynamically resizing an array
   If you have an existing array, and you want to make it bigger (add array cells to it), you cannot
   simply append new cells to the old ones.  Remember that arrays are stored in consecutive memory, and
   you never know whether or not the memory immediately after the array is already allocated for
   something else.   For that reason, the process takes a few more steps.  Here is an example using an
   integer array.  Let's say this is the original array:
 int * list = new int[size];

   I want to resize this so that the array called list has space for 5 more numbers (presumably because
   the old one is full).
   There are four main steps.
    1. Create an entirely new array of the appropriate type and of the new size. (You'll need another
       pointer for this).
 int * temp = new int[size + 5];

    2. Copy the data from the old array into the new array (keeping them in the same positions). This is
       easy with a for-loop.
 for (int i = 0; i < size; i++)
    temp[i] = list[i];

    3. Delete the old array -- you don't need it anymore! (Do as your Mom says, and take out the
       garbage!)
 delete [] list;  // this deletes the array pointed to by "list"
    4. Change the pointer. You still want the array to be called "list" (its original name), so change
       the list pointer to the new address.
 list = temp;

   That's it! The list array is now 5 larger than the previous one, and it has the same data in it that
   the original one had. But, now it has room for 5 more items.



---
https://www.tutorialspoint.com/cprogramming/c_memory_management.htm

C - Memory Management

   This chapter explains dynamic memory management in C. The C programming language provides several
   functions for memory allocation and management. These functions can be found in the <stdlib.h> header
   file.

---------------------------------------------------------------------------------------------------------
   Sr.No.  Function & Description
---------------------------------------------------------------------------------------------------------
   1       void *calloc(int num, int size);
           This function allocates an array of num elements each of which size in bytes will be size.
---------------------------------------------------------------------------------------------------------
   2       void free(void *address);
           This function releases a block of memory block specified by address.
---------------------------------------------------------------------------------------------------------
   3       void *malloc(size_t size);
           This function allocates an array of num bytes and leave them uninitialized.
---------------------------------------------------------------------------------------------------------
   4       void *realloc(void *address, int newsize);
           This function re-allocates memory extending it upto newsize.
---------------------------------------------------------------------------------------------------------

Allocating Memory Dynamically
   While programming, if you are aware of the size of an array, then it is easy and you can define it as
   an array. For example, to store a name of any person, it can go up to a maximum of 100 characters, so
   you can define something as follows -
   char name[100];

   But now let us consider a situation where you have no idea about the length of the text you need to
   store, for example, you want to store a detailed description about a topic. Here we need to define a
   pointer to character without defining how much memory is required and later, based on requirement, we
   can allocate memory as shown in the below example -
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {

	char name[100];
	char *description;

	strcpy(name, "Zara Ali");

	/* allocate memory dynamically */
	description = malloc( 200 * sizeof(char) );

	if( description == NULL ) {
		fprintf(stderr, "Error - unable to allocate required memory\n");
	} else {
		strcpy( description, "Zara ali a DPS student in class 10th");
	}

	printf("Name = %s\n", name );
	printf("Description: %s\n", description );
}

   When the above code is compiled and executed, it produces the following result.
Name = Zara Ali
Description: Zara ali a DPS student in class 10th

   Same program can be written using calloc(); only thing is you need to replace malloc with calloc as
   follows -
calloc(200, sizeof(char));

   So you have complete control and you can pass any size value while allocating memory, unlike arrays
   where once the size defined, you cannot change it.

Resizing and Releasing Memory
   When your program comes out, operating system automatically release all the memory allocated by your
   program but as a good practice when you are not in need of memory anymore then you should release
   that memory by calling the function free().

   Alternatively, you can increase or decrease the size of an allocated memory block by calling the
   function realloc(). Let us check the above program once again and make use of realloc() and free()
   functions -
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {

	char name[100];
	char *description;

	strcpy(name, "Zara Ali");

	/* allocate memory dynamically */
	description = malloc( 30 * sizeof(char) );

	if ( description == NULL ) {
		fprintf(stderr, "Error - unable to allocate required memory\n");
	} else {
		strcpy( description, "Zara ali a DPS student.");
	}

	/* suppose you want to store bigger description */
	description = realloc( description, 100 * sizeof(char) );

	if ( description == NULL ) {
		fprintf(stderr, "Error - unable to allocate required memory\n");
	} else {
		strcat( description, "She is in class 10th");
	}

	printf("Name = %s\n", name );
	printf("Description: %s\n", description );

	/* release memory using free() function */
	free(description);
}

   When the above code is compiled and executed, it produces the following result.
Name = Zara Ali
Description: Zara ali a DPS student.She is in class 10th

   You can try the above example without re-allocating extra memory, and strcat() function will give an
   error due to lack of available memory in description.


---
