filename: c-bit-packing-bit-switch-system-20251204.txt
from:     Why Some Low-Level Projects Are Full of Weird Code Like This
          https://www.youtube.com/watch?v=z7wVUfnm7M0

Bit packing: bit switch system
2025-12-04

Storing multiple values into single number is called 'bit packing'. For manipulating single bit inside a
number we use bitwise operators/operations (AND, OR, NOT, XOR and bit shifting). It should be used when
memory or storage are extremely limited (emedded systems, ...).

Example: We need 8-switch syistem for us to be able to set, clear, toggle and read each of the 8 switches.
Instead of setting 8 1-byte numbers to represent true/false or on/off state, we can use a single 8-bit
(1 byte) number as 8-bit switch system.

  +---------------------------------+    from:                  to:
  |         [              ]        |                           [1][1][0][0][1][1][0][1]
  |                                 |                            |  |  |  |  |  |  |  |
  | Enable notifications       [ X] |    00000001 ---------------+  |  |  |  |  |  |  |
  | Alow sound/vibration       [ X] |    00000001 ------------------+  |  |  |  |  |  |
  | Auto-play videos           [X ] |    00000000 --------------------+   |  |  |  |  |
  | Save login/session         [X ] |    00000000 ------------------------+  |  |  |  |
  | Content filtering          [ X] |    00000001 --------------------------+   |  |  |
  |                                 |                                           |  |  |
  | Enable backups             [ X] |    00000001 ------------------------------+  |  |
  | Auto-download attachements [X ] |    00000000 ---------------------------------+  |
  | Sync over cellular data    [ X] |    00000001 ------------------------------------+
  |                                 |

Let's create 4 functions to operate on a word (1 byte):
    function(word, n);
        word -> 10110011
        n    -> position inside word from 0 - 7
                10110011
               (76543210)

----------------------------------------------+---------------------------------------------
 1 - set(word, n)                             |     2 - clear(word, n)
                                              |
 n -----------------+                         |     n ----------------+
                    |                         |                       |
                    3                         |                       4
 word           10110011                      |     word           10110011
        -OR-                                  |            -AND-
 mask           00001000  = (1 << 3)          |     mask           11101111  = !(1 << 4)
 -----------------------                      |     -----------------------
 result         10111011                      |     result         10101011
                    -                         |                       -
                                              |
 void set(uint8_t *word, uint8_t n) {         |     void set(uint8_t *word, uint8_t n) {
    *word = *word | (1u << n);                |        *word = *word & ~(1u << n);
 }                                            |     }
                                              |
----------------------------------------------+---------------------------------------------
 3 - toggle(word, n)                          |     4 - read(word, n)
                                              |
 n ----------------+                          |     n ----------------+
                   |                          |                       |
                   4                          |                       4
 word           10110011                      |     word           10110011
        -XOR-                                 |     word >> n      00001011
 mask           00010000  = (1 << 4)          |            -AND-
 -----------------------                      |     mask           00000001  = 00000001 (1)
 result         10101011                      |     -----------------------
                   -                          |     result         00000001
                                              |                           -
                                              |
 void set(uint8_t *word, uint8_t n) {         |     uint8_t read(uint8_t *word, uint8_t n) {
    *word = *word ^ (1u << n);                |      /* return (*word >> n) & 1;  //?? */
 }                                            |         return (*word & (1u << n));
                                              |     }
                                              |

Real example
We have an embedded system with sensor that reports 4 possible moisture levels for every second, and We
must programm a microcontroller to record those readings continuosly for a whole year. Available onboard
storage is only 10 MB. If each state is represented by whole 1 byte number, that would take ...
1 byte x 3600 x 24 x 365 = 31.536.000 bytes --> 31 MB (cca) 31 MB of storage. But if we use only 2 bits
for a single state ...
    (00) - Dry
    (01) - Slightly moist
    (10) - Wet
    (11) - Saturaded
... we can pack 4 readings into a single byte, so we reduce a storage cost by a factor of 4, which is less
than 10MB: 31.536.000 bytes / 4 --> 7.8 MB.

It is also very apropriate way of storing RGBA values (Red,Green,Blue,Opacity) for colors. It is also used in
encoding and compression algotithms, encription and hashing.


---

