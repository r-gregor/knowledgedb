filename: c_bit-fields-and-bit-masking-structures-unions-multif_20241127.txt
https://www.geeksforgeeks.org/c-bitmasking/

Bitmasking In C
22 Sep, 2023

   In this article, we are going to learn about Bitmask in C which is a powerful way to basically work
   with bits and functions upon boolean logic. It can be used to store data compactly and with much more
   efficiency in certain cases.

What is a Bit?
   A bit is the smallest unit of data which can either store a 0 or 1 inside it. All the data in the
   computer is stored using these bits. These 2 possible values can also be represented as boolean
   values that are True or False. Using this we can apply boolean logic to manipulate data stored on the
   computer.

Bitmasking in C
   Bitmasking is a technique that involves bit manipulation. It is basically like putting a mask over
   certain bits and hiding the other un-useful bits, so as to make the program much more efficient and
   optimize the memory.

   A bitmask is a sequence of bits that can also be known as a bitset or bit field and is used to
   perform bitwise operations on the given data.

   There are basically 6 bitwise operators in C that can be used to manipulate bits which are as
   follows:
     * & (Bitwise AND Operator)
     * | (Bitwise OR Operator)
     * ^ (Bitwise XOR Operator)
     * ~ (Bitwise NOT Operator)
     * >> (RIght Shift Operator)
     * << (Left Shift Operator)

   Using these operators, we perform different bit masking techniques according to the requirements.
   Let's discuss these techniques and how to implement them.

Bitmasking Techniques

1. Setting a Bit
   In this technique, we set a particular bit to 1 without touching any of the other bits. For this, we
   use the bitwise OR ( | ) operator and the left shift (<<) operator.

   Basically, we take the integer 1 and using the left shift operator, shift the binary representation
   of 1 (that is 1 only) to n places where (n+1) is the place of bit which we want to set. Then using
   the bitwise OR operator we turn the given number's (n+1)^th bit to 1.

Syntax

number | (1 << bit_position_to_set)

Example:

#include <stdio.h>

int main() {

	int x = 13;
	printf("Ans: %d", 13 | (1 << 5));

	return 0;
}


   Output
Ans: 45

2. Clearing a Bit
   In this operation, we set a specific bit to 0 (as opposed to 1 in the previous case) without touching
   any of the other bits. We use the bitwise AND operator (&), bitwise NOT operator (~), and the left
   shift operator (<<) to achieve the task.

   Basically, we again take 1 and shift it the the specified position. Then, we perform the NOT
   operation on this to convert that into a 0 and other bits of the value (1<<n) to 1. Then we do the
   AND operation to clear the specified bit and obtain the result.

Syntax:

number & ~(1 << bit_position_to_clear)

Example:

#include<stdio.h>

int main() {
	int x = 13;
	printf("Ans: %d", 13 & ~(1 << 2) );

	return 0;
}


   Output
Ans: 9

3. Flipping a Bit
   In this operation, we flip a specific bit that is if the bit is 0 then turn it to 1 else turn it to
   0. This operation requires the use of bitwise XOR (^) operator along with the left shift (<<)
   operator.

   Basically, as in previous operations, we shift 1 to the specified number of positions and then
   perform the XOR operation to flip the bit of the given number.

Syntax:

number ^ (1 << bit_position_to_flip)

Example:

#include<stdio.h>

int main() {
	int x = 13;
	printf("Ans: %d", 13 ^ (1 << 3) );

	return 0;
}


   Output
Ans: 5

4. Checking a Bit
   In this operation, we check if a particular bit is 1 or not using the bitwise AND operator (&) along
   with the left shift operator (<<).

   We shift 1 using the left shift operator to the specified position and then perform the bitwise AND
   operation on that so as to check if that specific bit is 0 or 1. If the bit is 0 then the result
   would be 0 else the result would be 2^(bit_position).

Syntax:

number & (1 << bit_position_to_check)

Example:

#include<stdio.h>

int main() {
	printf("Ans: %d \n", 13 & (1 << 3) );
	printf("Ans: %d \n", 13 & (1 << 4) );

	return 0;
}


   Output
Ans: 8
Ans: 0

Application of Bitmasking in C
   Following are some main applications of bit masking in the C programming language.
     * It is used in data compression to decrease its size.
     * It is used in cryptography to encrypt the data.
     * It is used in the optimization of a lot of algorithms.



---
https://blog.mbedded.ninja/programming/languages/c/bit-fields-and-bit-manipulation-masking/

Bit Fields And Bit Manipulation/Masking
Feb 12, 2016

   A bit field is a software/firmware variable that stores many bits in a consecutive memory structure.

   Bit masking is the process of masking (selecting) specific bits in a bit field (a multi-bit
   software/firmware variable), e.g. a 32-bit integer, or uint32_t) to manipulate, without modifying the
   value of any bits that where not selected.

   Bit masking is thought-of as a low-level operation, and is normally only seen in languages such C and
   C++ (higher level languages may still use bit masking, but the code is likely to be abstracted away
   from the user). C and C++ bit masking usually makes extensive use of pre-processor macros.

Setting Bits
   The bit-wise OR operation (|) can be used to set bits in a variable to 1. The bits in the bit field
   which you wish to set to 1 are ORed with 1, while those you wish to leave unchanged are ORed with 0.

   uint8_t bitField1 = 0b10110011;

   // Using the bitwise OR operator to set bits 4-7 to 1
   bitField |= 0b11110000;
   // bitField = 0b11110011;

Clearing Bits
   The bit-wise AND operation (&) can be used to set bits in a variable to 0. The bits in the bitfield
   which you wish to clear are ANDed with 0, while those you wish to leave unchanged are ANDed with 1.

   uint8_t bitField1 = 0b10110011;

   // Using the bitwise AND operator to keep only bits 4-7 (bits 0-3 will be cleared)
   bitField &= 0b11110000;
   // bitField = 0b10110000;

Creating A Multi-Bit Bit Mask
   This following example uses a macro to perform the masking and setting of bits. A function could be
   used, but macros are generally more efficient due to the lack of a function call.

   //! @brief The maximum width (in bits) that the following bit field manipulation macros can work with.

   #define MAX_BIT_FIELD_WIDTH_BITS 32
   //! @brief Creates a "MAX_BIT_FIELD_WIDTH_BITS"-wide bit mask for the specified bit range a to b (inclusive).
   //! @details Example:
   //! BIT_MASK(5, 12) returns the value (if MAX_BIT_FIELD_WIDTH_BITS = 32).
   //! 0b 0000 0000 0000 0000 0011 1111 1110 0000
   //! @warning ONLY WORKS WITH UP TO "MAX_BIT_FIELD_WIDTH_BITS" WIDE BIT FIELDS
   #define BIT_MASK(a, b) (((unsigned) -1 >> ((MAX_BIT_FIELD_WIDTH_BITS - 1) - (b))) & ~((1U << (a)) -  1))
   //! @brief Use this macro to set a number of bits within a bit field.
   //! @details Example:
   //! SET_BITS(myUint16, 12, 3, 0b101)
   //! will set bits 12 through to 14 with 1, 0 and 1 respectively.
   //! @warning ONLY WORKS WITH UP TO "MAX_BIT_FIELD_WIDTH_BITS" WIDE BIT FIELDS
   #define SET_BITS(var, startBit, numBits, val) \
   var = var & ~BIT_MASK(startBit, startBit + numBits - 1); \
   var = var | (val << startBit);

   You can then use it as in the following:

   uint8_t aRegister = 0x00;

   SET_BITS(aRegister, 2, 4, 0b1011);
   // aRegister = 0b00101100;
   SET_BITS(aRegister, 0, 3, 0b011);
   // aRegister = 0b00101011;

   Note
   The above BIT_MASK and SET_BITS macros only work for variables up to MAX_BIT_FIELD_WIDTH_BITS wide!

Use In The Industry
   Many microcontroller manufactures (e.g. Atmel), provide firmware libraries and example code
   which make extensive use of bitfield manipulation to modify the registers which control the hardware
   peripherals (e.g the register(s) which configures the baud rate, parity and num. stop bits for a
   UART).


---
https://www.opensourceforu.com/2015/03/be-cautious-while-using-bit-fields-for-programming/

Be Cautious while using Bit Fields for Programming
March 26, 2015

   In this article, the author tells embedded C programmers why writing code involving bit fields needs
   to be done carefully, failing which the results may not be as expected. However, bit fields are handy
   as they involve only low level programming and result in efficient data storage.

   Embedded C programmers who have worked with structures should also be familiar with the use of bit
   fields structures. Use of bit fields is one of the key optimisation methods in embedded C
   programming, because these allow one to pack together several related entities, where each set of
   bits and single bits can be addressed. Of course, the usage of bit fields is easy' and comes handy,
   especially during low level programming. Though considered as one of the unique features of C
   programming, bit fields do have some limitations. Let us look at these by exploring the example
   problems in this article.

   Data types and bit fields
   Let us look into the signed qualifiers affecting the output of the bit field structure. Please note
   that the code snippets provided here are tested with the GCC compiler [gcc version 4.7.3] running
   under a Linux environment.

   Let us consider a simple small C code snippet as shown below, with a structure named bit field, with
   three integer fields: hours, mins and secs, of bit field sizes 5, 6 and 6, respectively:

typedef struct bit_field {
	int hours : 5;
	int mins : 6;
	int secs : 6;
}time_t;

   Now let us declare a variable alarm of type time_t and set values as 22, 12 and 20, respectively:

   //Declaration of the variable of type time_t
   time_t alarm;
   /Assigning the values to the different members of the bit-field structures
   alarm.hours = 22;
   alarm.mins  = 12;
   alarm.secs  = 20;

   When we print these values using a simple printf statement, what could be the output? At first, most
   of us will envision the answers to be 22, 12 and 20, for hours, mins and secs respectively. Whereas
   when we actually compile and run the run the code, the value printed for the hours would be different
   - 10, 12 and 20.

   Where did we go wrong?
   1. We all know that the default signed qualifier for the int' is signed int'.
   2. We reserved 5 bits for storing the hours field assuming we were using the 24-hour format. From
   among 5 bits, 1 bit was used for storing the sign of the number, which means only 4 bits were then
   available for storing the actual value. In these 4 bits, we can store the numbers ranging from -16 to
   +15 according to the formula (-2^k) to ([+2^k] -1)) including 0, where  k'  indicates the number
   of bits.

   3. We will see how 22 is stored in binary form in 5 bits through pictorial representation (Figure 2).
   4. From the table(as shown in Figure 2), it is very clear that sign bit (b4) is SET, which
   indicates the value is negative. So, when printed using the printf statement, we will get -10 (the
   decimal value of 10110), because of which we got an unexpected output.
   
   [b4][b3][b2][b1][b0]
   [1 ][ 0][ 1][ 1][ 0]
Figure 2 : Pictorial representation of binary value of 24 in '5' bits

   Now that we have understood the problem, how do we fix it? It is very simple; just qualify int to
   unsigned int just before the hours in the bit field structure, as shown below. The corrected output
   is shown in Figure 3.

Output:
	Hours : 22
	Minutes : 12
	Seconds : 20
Figure 3 : Correct output after correct usage of datatype

#include <stdio.h>
typedef struct bit_field {
	unsigned int hours  : 5;
	unsigned int mins   : 6;
	unsigned int secs    : 6;
}time_t;

int main() {
	//Declaration of the variable of type time_t
	time_t alarm;

	//Assigning the values to the different members of the bit-field structures
	alarm.hours = 22;
	alarm.mins  = 12;
	alarm.secs  = 20;
	printf("Hours : %d\nMins : %d\nSecs : %d\n", alarm.hours, alarm.mins, alarm.secs);
}

   Bit wise operators definitely provide advantages, but they need to be used a bit carefully. In the
   embedded programming environment, they might lead to major issues in case they are not handled
   properly.

   Endianess of the architecture and bit fields
   In this problem, we will see how Endianess affects the bit fields. Bit fields in C always start at
   Bit 0, which is the least significant bit (LSB) on Little Endian. But most compilers on Big Endian
   systems inconveniently consider the most significant bit (MSB)Bit 0.
   Note: Big Endian machines pack bit fields from the most significant byte to the least significant.

   Little Endian machines pack bit fields from the least significant byte to the most.
   To start with, let us consider the code( Labelled as byte_order.c) given below:

#include <stdio.h>
typedef union {
	unsigned int value;
	struct {
		unsigned char one   : 8;
		unsigned char two   : 8;
		unsigned char three : 8;
		unsigned char four  : 8;
	} bit_field;
} data_t;

int main() {
	data_t var = {0x1A1B1C1D};
	unsigned char *ptr = (unsigned char *)(&var);

	printf("The entire hex value is 0x%X\n", var.value);
	printf("The first byte is 0x%X @ %p\n", *(ptr + 0), ptr + 0);
	printf("The second byte is 0x%X @ %p\n", *(ptr + 1), ptr + 1);
	printf("The third byte is 0x%X @ %p\n", *(ptr + 2), ptr + 2);
	printf("The fourth byte is 0x%X @ %p\n", *(ptr + 3), ptr + 3);

	return 0;
}


Output:
	The entire hex value is 0x1A1B1C1D
	The first byte is 0x1D @ 0xbfe7c478
	The second byte is 0x1C @ 0xbfe7c479
	The third byte is 0x1B @ 0xbfe7c47a
	The fourth byte is 0x1A @ 0xbfe7c47b
Figure 4 : Output of the code byte_order.c

   When I run this code in my system, I get the output shown in Figure 4.

	[ 1D ][ 1C ][ 1B ][ 1A ]
	\                       \
	 Low Adress              Highg Address
Figure 5 : Byte-ordering in Little - Endianess Machine


	[ 1A ][ 1B ][ 1C ][ 1D ]
	\                       \
	 Low Adress              Highg Address
Figure 6 : Byte-ordering in Big - Endianess Machine

   From Figure 4, it is very clear that the underlying architecture is following the little Endian. When
   the same code is run under a different architecture, which follows Big Endian, the result will be
   different. So, portability issues need to be considered while using bit fields.
   Lets look at one more example to understand how bits are packed in Big Endian and Little Endian.
   To start with, let us consider the sample code(Labelled as bit_order.c) given below:

#include <stdio.h>
typedef union {
	unsigned short value;
	struct {
		unsigned short v1   : 1;
		unsigned short v2   : 2;
		unsigned short v3   : 3;
		unsigned short v4   : 4;
		unsigned short v5   : 5;
	} bit;
} data_t;

int main() {

	data_t var ;
	unsigned char *ptr = (unsigned char*)(&var);
	var.bit.v1   = 1;
	var.bit.v2   = 2;
	var.bit.v3   = 3;
	var.bit.v4   = 4;
	var.bit.v5   = 5;

	printf("The Entire hex value is 0x%X\n", var.value);
	printf("The first byte is 0x%X @ %p\n", *(ptr + 0), ptr + 0);
	printf("The second byte is 0x%X @ %p\n", *(ptr + 1), ptr + 1);

	return 0;
}

Output:
	The entire hwex value is 0x151D
	The first byte is 0x1D @ 0xbfe909da
	The second byte is 0x15 @ 0xbfe909db
Figure 7 : output of the code bit_order.c

   When I run this code in my system, I get the output as shown in Figure 7.

   From this figure, one can see that the bits are packed from the least significant on a little Endian
   machine. Figure 8 helps us understand how the bits ordering takes place.

	+---------------------------------------------------------------------------------+
	| Hex value      |       1       |       5       |       1       |       D        |
	+----------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+----+
	| Binary value   | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 1  |
	+----------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+----+
	| Struct Members |   |      v5:5         |     v4:4      |   v3:3    |  v2:2 |v1:1|
	+----------------+---+-------------------+---------------+-----------+-------+----+
	|                                                |
	Address + 1                                      Address + 0
Figure 8 : Bit - ordering in small Endianess architecture

   If you run the same code in big Endian architecture, you will get the output given in Figure 9.

Expected output:
	The entire Hex value: 0xCD0A
	The first byte is 0xCD @ XXXX
	The second byte ie 0x0A @ YYYY

	Note:
	XXXX & YYYY are some addresses
Figure 9: Expected output of the code bit_order.c when run in big-endian architecture.


   For more clarity, see Figure 10.
   From the last two examples, it is very clear that bit fields pose serious portability issues. When
   the same programs are compiled on different systems, they may not work properly. This is because some
   C compilers use the left-to-right order, while other C compilers use the right-to-left order. They
   also have architecture-specific bit orders and packing issues.

	+----------------------------------------------------------------------------------+
	| Hex value      |        C       |       D       |       0       |       A        |
	+----------------+----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+----+
	| Binary value   | 1  | 1 | 0 | 0 | 1 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0  |
	+----------------+----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+----+
	| Struct Members |v1:1|  v2:2 |   v3:3    |     v4:4      |       v5:5        |    |
	+----------------+----+-------+-----------+---------------+-------------------+----+
	|                                                 |
	Address + 1                                       Address + 0
Figure 10 : Bit- ordering in Big Endianess Architecture

   As a concluding note, let us list the advantages and limitations of bit fields structures.
   Advantages
   1. Efficiency - Storage of data structures by packing.
   2. Readability - Members can be easily addressed by the names assigned to them.
   3. Low level programming  The biggest advantage of bit fields is that one does not have to keep
      track of how flags and masks actually map to the memory. Once the structure is defined, one is
      completely abstracted from the memory representation as in the case of bit-wise operations, during
      which one has to keep track of all the shifts and masks.

   Limitations
   1. As we saw earlier, bit fields result in non-portable code. Also, the bit field length has a
      high dependency on word size.
   2. Reading (using scanf) and using pointers on bit fields is not possible due to
      non-addressability.
   3. Bit fields are used to pack more variables into a smaller data space, but cause the compiler to
      generate additional code to manipulate these variables. This results in an increase in both space as
      well as time complexities.
   4. The sizeof() operator cannot be applied to the bit fields, since sizeof() yields the result in
      bytes and not in bits.


---
https://www.linkedin.com/pulse/handling-bitfields-embedded-c-ricardo-alejos

Handling bitfields in embedded C
Sep 11, 2020

   Let us imagine that we want to code a function that refreshes the watchdog timer in our 32-bit
   microcontroller. And according to our microcontroller's datasheet, for doing it, we need to write the
   value "0xCAFE" in the "KEY" field of the "WDTCTL" register.

   The datasheet says that the WDTCTL register is at address "0x80420000", and that its "KEY" field
   embraces from bit 4 to bit 19.

Why not a "struct" with bitfields?
   We could think that using a "struct" with bitfields would do the job just fine. However, compilers
   have no standard way of allocating the bitfields of a structure in physical memory.

   Consider the "struct" in Listing 1.

#include <stdint.h>

struct WDTCTL_REGISTER {
	uint32_t reserved_00 :  4;
	uint32_t key         : 16;
	uint32_t reserved_01 : 12;
}__attribute__((packed));

#define wdt00_wdtctl ((volatile struct WDTCTL_REGISTER *)(0x80420000))

   Listing 1. A struct which pretends to model the WDTCTL register.

   For the sake of having a clear example, let us initialize a struct of the type WDTCTL_REGISTER as in
   Listing 2.

struct WDTCTL_REGISTER wdt_demo = {
	.reserved_00 = 0xA,
	.key = 0xBBBB,
	.reserved_01 = 0xCCC
};

	Listing 2. Initialization of "wdt_demo".

   What would be the value of the 32-bit word at the address "&wdt_demo"? 0xABBBBCCC, 0xCCCBBBBA,
   0xACCCBBBB? There is no way of knowing before we either run the code or read how our compiler
   implements bitfields. The problem becomes even more mysterious when the data structure involves
   padding (when the datatypes and bitfields do not match the memory alignment required by the compiler
   or the target).

   A solution like this one could make different compilers yield programs with different behaviours even
   if we don't change the code (i.e. there is no guarantee that the code in Listings 1 and 2 has the
   same behaviour when compiled with the CLANG, GCC, or the IAR compilers). This means that, for keeping
   the behaviour consistent, we would need to add conditional compilation statements ("#ifdef", "#if",
   and their friends)which would use one implementation or another depending on which compiler we are
   using.

Integer sizes and bitwise operations
   The implementation in Listing 3 satisfies the conditions to refresh the watchdog timer.

#include <stdint.h>

#define wdt00_wdtctl (*((volatile uint32_t *)(0x80420000)))
#define WDT_KEY (0xCAFE)
#define WDT_KEY_POS (4)
#define WDT_KEY_MASK (0xFFF0000FF)

void refresh_wdt() {
	uint32_t temporal_buffer;

	// Get a copy of the register value
	temporal_buffer = wdt00_wdtctl;

	// Clear the contents of the "KEY" field in the buffer
	temporal_buffer &= WDT_KEY_MASK;

	// Set the contents of the "KEY" field in the buffer
	temporal_buffer |= WDT_KEY << WDT_KEY_POS;

	// Set the register value to the value in the buffer
	wdt00_wdtctl = temporal_buffer;
}

   Listing 3. A function to set the value of the "KEY" field to "0xCAFE".

   Although the code in Listing 3 works, writing a big project like this can be overwhelmingly tedious:
   we would have to compute the mask of every single field that we pretend to use in our application
   from the values in the microcontrollers' datasheet.

The macro approach
   Maybe you have seen around some macros for setting, clearing, and toggling bits if you haven't let me
   introduce them to you in Listing 4.

#define SET_BIT(dest, bit_pos)    ((dest) |= (1 << bit_pos))
#define TOGGLE_BIT(dest, bit_pos) ((dest) ^= (1 << bit_pos))
#define CLEAR_BIT(dest, bit_pos)  ((dest) &= ~(1 << bit_pos))

   Listing 4. Traditional bit manipulation macros.

   Although these macros will help with 1-bit flags, they won't help us much when we have to set
   multi-bit fields. So let us design ours now. Here, we are particularly interested in being able to
   write and read the values of bitfields in 32-bit registers. Still, we could adapt the following
   macros for other standard widths (8, 16, and 64 bits).

   Our first building block is a macro which can produce a mask of an arbitrary number of
   right-justified (least significant) ones. For example, a mask with 13 right-justified ones
   corresponds to the value 0x1FFFF (which in binary has 13 bits with value 1). Let us call this macro
   "GET_U32B_PLAIN_MASK(length)".

   A trick we can do to get this behaviour is to shift the number 1 "length" times to the right and
   subtract 1. For example, we can get our 13-bit mask by moving the value one 13 places to the right
   (which yields the value 0x20000), and then we subtract one and get "0x1FFFF".

   To prevent the compiler from raising warnings because we may shift a number beyond the length of the
   integer type, we can use an inline conditional statement for the case in which we want a mask with
   the same size of the data type in use (for 32 bits it would be "0xFFFFFFFF").

#include <stdint.h>

#define GET_U32B_PLAIN_MASK(length) \
(\
	(length) >= 32 ? \
	0xFFFFFFFF \
	: \
	((((uint32_t)1) << (length)) - 1) \
)

   Listing 5. The implementation of "GET_U32B_PLAIN_MASK(length)".

   The next building block is to build a mask which allows us to preserve the value of the field we are
   interested in. For example, if we wanted to keep the value of the "KEY" field (bits 4 to 19) in the
   "WDTCTL" register, we would need a mask with the value "0x000FFFF0" (which when ANDed with the value
   of the whole WDTCTL register only preserves the KEY field value, and zeroes the rest). Let us call
   this macro "GET_U32B_FIELD_MASK(msb, lsb)".

   We can get such a mask from two "plain masks". First, we generate a mask with "msb + 1" bits. Then,
   from the last mask, we subtract another plain mask with "lsb" bits. For example, the mask for the
   "KEY" field in the "WDTCTL" can be computed subtracting the masks "0x000FFFFF-0x0000000F =
   0x000FFFF0".

#include <stdint.h>

#define GET_U32B_PLAIN_MASK(length) \
(\
	(length) >= 32 ? \
	0xFFFFFFFF \
	: \
	((((uint32_t)1) << (length)) - 1) \
)

#define GET_U32B_FIELD_MASK(msb, lsb) \
(\
	GET_U32B_PLAIN_MASK((msb)+1) - \
	GET_U32B_PLAIN_MASK(lsb) \
)

   Listing 6. Implementation of "GET_U32B_FIELD_MASK(msb, lsb)".

   Next, we proceed to build our field-setter macro, "SET_U32B_FIELD(dest, msb, lsb, value)". This macro
   has to:
    1. Read the old value of the destination buffer.
    2. Mask the old value with a negated field mask.
    3. Mask the value to set to the size of the field to fill ("msb-lsb+1").
    4. Shift the masked value to its LSB position.
    5. Perform a logic OR between the old destination value, and the masked and shifted value.

#define GET_U32B_PLAIN_MASK(length) \
(\
	(length) >= 32 ? \
		0xFFFFFFFF \
		: \
		((((uint32_t)1) << (length)) - 1) \
)


#define GET_U32B_FIELD_MASK(msb, lsb) \
		(\
			GET_U32B_PLAIN_MASK((msb)+1) - \
			GET_U32B_PLAIN_MASK(lsb) \
		)


#define SET_U32B_FIELD(dest, msb, lsb, value) \
(\
	(dest) = (\
		((dest) & ~(GET_U32B_FIELD_MASK(msb, lsb))) | \
		( \
			(\
				(value) & \
				GET_U32B_PLAIN_MASK((msb)-(lsb)+1) \
		) << (lsb)) \
	) \
)

   Listing 7. Implementation of "SET_U32B_FIELD(dest, msb, lsb, value)".

   Finally, let's develop our "GET_U32B_FIELD(src, msb, lsb)" macro to fetch the value of a field within
   a 32-bit integer. This last macro has to:
    1. Shift the value in "src" in "lsb" places to the right.
    2. Mask the resulting value with a plain mask of "msb+1" bits.

#include <stdint.h>

#define GET_U32B_PLAIN_MASK(length) \
(\
	(length) >= 32 ? \
		0xFFFFFFFF \
		: \
		((((uint32_t)1) << (length)) - 1) \
)


#define GET_U32B_FIELD_MASK(msb, lsb) \
(\
	GET_U32B_PLAIN_MASK((msb)+1) - \
	GET_U32B_PLAIN_MASK(lsb) \
)

#define GET_U32B_FIELD(src, msb, lsb) \
(\
	((src) >> (lsb)) & (GET_U32B_PLAIN_MASK((msb)+1)) \
)

   Listing 8. Implementation of "GET_U32B_FIELD(src, msb, lsb)".

   If we had all our macros in a header file named "bitfields.h", then we could recode the solution in
   Listing 3 as in Listing 9. This new implementation:
     * Is shorter and easier to read.
     * Removes the runtime overhead of the function call (the compiler replaces macros "in-line").
     * The compiler performs all the masking and shift maths, not the microcontroller (yielding faster
       execution times and more energy-efficient code).
     * Allows us using the data from the datasheet "as-is". We don't need to compute the masks
       ourselves, nor the shift sizes, and so on. Possibly, we could parse the datasheet and generate a
       header file with bitfield descriptors.

#include <stdint.h>
#include "bitfields.h"

#define wdt00_wdtctl (*((volatile uint32_t *)(0x80420000)))
#define WDT_KEY (0xCAFE)
#define WDT_KEY_LSB (4)
#define WDT_KEY_MSB (5)

#define refresh_wdt() \
	SET_U32B_FIELD( \
		wdt00_wdtctl, \
		WDT_KEY_MSB, \
		WDT_KEY_LSB \
	)

   Listing 9. Re-implementation of "refresh_wdt()" as a macro.


---
https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/bit-fields-r3037/

Bit Fields
April 16, 2013

   During a discussion on GameDev recently, I suggested someone use a bit field as a method to avoid
   having to deal with various masking and shift operations in a manual and potentially buggy manner.
   The suggestion was taken and then a snippet of the code was given; everything looked correct at first
   glance but in fact it was incorrect. In the process of updating my suggestion for the specific usage,
   I did a bit of Googling for something simple, only to find that the usage of bit fields and solid
   information on behavior is severely lacking. I hope to centralize some of the information and also
   give some examples of bit fields beyond the trivial examples I found in my searches.

What Is A Bit Field
   The general definition of a bit field is the ability to access and manipulate multiple logical
   neighboring bits in memory in a clean and concise manner. While technically correct this leaves a lot
   to be desired and also does not supply a very good reason to ever use a bit field in order to
   simplify your code. Additionally, the C and C++ standards leave some wiggle room in the definitions
   so there is a small amount of per compiler information to be learned when using bit fields.

   The standard was left loose due to the fact that a primary usage of bit fields in C was to map
   between the language and underlying hardware control registers. This is beyond the scope here but in
   order for compilers to map to specific hardware, sometimes the rules of how bits were laid out needed
   to be tweaked from platform to platform. It is the same reason that an 'int' in C/C++ does not
   specify that it is 32 or 64 bits in length explicitly; int can be tweaked to the best fit for the CPU
   and architecture. In order to avoid any bad assumptions, we are going to base all examples and
   explanations on the idea that the target platform is an Intel x86 instruction set CPU and the
   compiler is set up accordingly. So, given that clarification, our first example is the following:

struct BitField {
	unsigned short Count : 8;
	unsigned short Offset : 7;
	unsigned short Inverted : 1;
};

   What this example is doing is defining specific bits within the fundamental unsigned short to be
   presented to the programmer as named fields which can be accessed or modified. The 'Count' field is
   specified as being 8 bits wide and as such has a valid range of 0-255. The 'Offset' is 7 bits wide
   and of course 'Inverted' is 1 bit. Using the bit field is as simple as accessing members of a
   structure in a normal fashion:

BitField a;
a.Count = 12;
a.Offset = 31;
a.Inverted = 0;

   Nothing particularly surprising, so what good does specifying this as a bit field do? For one thing,
   in this case: "sizeof( a )==2". We have packed all three of the fields into a single unsigned short,
   so it is compressed. The same structure without the bit field specifications would be "sizeof( a
   )==6", quite a savings. The benefit to the programmer is that because we know the limits of intended
   data, we can pack the data into a smaller space; this is often used in network transmissions, file
   storage and other areas where you want to minimize the size of data.

Bit Field Overflow
   The example so far packs into a single unsigned short because the number of bits used in total is 16,
   which happens to match the number of bits within the fundamental type we specified: unsigned short.
   So, what happens when the specification bit count is more than 16? Let's change the example to be:

struct BitField {
	unsigned short Count : 8;
	unsigned short Offset : 7;
	unsigned short Origin : 2;
};

   Now the count of bits says we have 17. There are two primary side effects of this change, the first
   being that "sizeof( BitField )!=2", it is instead now "sizeof( BitField )==4". The compiler has added
   another unsigned short to the structure in order to contain all the bits we specified, so there are
   now 15 bits which are unused in this structure.

   The second side effect is that the 'Origin' field which replaced 'Inverted' is no longer where you
   may expect it in the binary data. Instead of splitting the 2 bits, both bits are placed in the new
   element added to the structure. This means that in the first 16 bit value the high bit is no longer
   used and that there are actually only 14 unused bits in the newly added element. Given that the
   compiler avoids splitting fields over the fundamental type boundaries, what happens if you tried the
   following?
struct BitField
{
        unsigned short WhatsThis : 17;
};

   The compiler will likely give you a warning, if not an error, on the ': 17' portion saying that the
   specified bit count exceeds the size of the underlying type. Normally this means that the field will
   end up being only 16 bits long and you are not getting the 17th bit allocated. So, if you attempt to
   use the entire 17 bits the top bit will be truncated.

Mixing Types In a Bit Field
   What happens when you try to specify the type of single bit fields as a 'bool' in C++:

struct BitField {
	int FirstField : 8;
	bool SecondField : 1;
	int ThirdField : 8;
	int FourthField : 8;
};

   You will be in for an unpleasant surprise with this definition as the behavior in this case is
   compiler specific. The C++ standard supplies no rules to standardize the behavior here and as such we
   have an example of Visual Studio and GCC/Clang differences. I could find no documentation about
   Visual Studio's behavior here and can only write the observed result and the guessed rules which
   cause it.

   The size of this bit field is actually 12, Visual Studio seems to close the first int, open a bool
   type for the single bit then open another int for the last two fields. On the other hand, both GCC
   and Clang seem to be just fine with packing the bool into the int type and the size of the bit field
   remains 4 bytes. Another variation of this, with a different result, could be the following:

struct BitField {
	int FirstField : 8;
	unsigned int SecondField : 8;
	int ThirdField : 8;
	int FourthField : 8;
};

   If you report the size of this structure, you will get 4 bytes again on the three compilers. Visual
   Studio does not seem to care if the type is signed or unsigned in this case, it only cares that the
   fundamental type sizeof is the same. To be safe, it is suggested not to mix the fundamental types or
   at least do some serious testing to guarantee the compiler behavior. This is not a compiler bug, the
   C++ standard does not specify anything of use in clarifying the behavior here, so it is open to
   interpretation.

The Allowed Fundamental Types
   A primary item which my searches failed to show initially was which fundamental types were allowed,
   most results just showed "unsigned" in examples. When the results were more specific, most of the
   documentation you find refers to the C99 standard which specifies that the fundamental types can be
   one of: _Byte, signed int and unsigned int. But what about the C++ standards? This actually took a
   little digging but the answer is that C++ greatly expanded the allowed types to be: any integral type
   or enumeration type.

   So, in C++, fundamental types such as 'long long' (64 bit integer on x86) can be used as the type.
   The enumeration type is a bit beyond the intended scope but enumerations are considered to be a
   signed integer type unless you use C++11 class typing on the enumeration. How the compiler interprets
   mixing the enumeration into the bit field is implementation defined and as such you need to test your
   compiler behavior. By these definitions the prior examples, in C99, would have been flagged as
   warnings or errors due to the use of unsigned short. Though, most compilers did support this and
   other variations.

Bit Field Binary Representation
   Mapping the bit fields to their binary representations is a compiler specific item, so this section
   may need to be researched for your compiler. On most modern compilers though (MSVC, GNU and Clang
   targeting x86/x64 code as examples), the general rule is that the fields take bits from the
   fundamental type in the order you specify starting with the first field taking the lowest bits and
   continuing up till ending the bit field or moving to the next fundamental type. So, for instance, our
   original example will have the following binary representation:

struct BitField {
	unsigned short Count : 8;
	unsigned short Offset : 7;
	unsigned short Inverted : 1;
};


        +- inverted
       /               +- Offset
      /               /     +- Count
     /               /     /
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	| | | | | | | | | | | | | | | | |
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	|                               |
	16                              0

Fine Grained Bit Field Control
   Packing bits tightly is only one of the abilities of a bit field. Additionally, you can insert
   padding and also control at what points a new fundamental type is allocated. We'll use an example of
   mapping a hypothetical binary image format header to a bit field for easier manipulation and access.
   We'll start with a textual description of the intentionally horrible image format header chunk:

Image Format:
Byte 0-1: Magic identifier: 0xf321
Byte 2: Version of format. Valid formats 0-5.
Byte 3: low nibble specifies x origin, high nibble specifies y origin. 0=top or left, 1=bottom or right.
Byte 4-7: Width of image. (Little endian.)
Byte 8-11: Height of image. (Little endian.)

   Using bit fields we can define this as a structure which can be binary loaded and saved on a little
   endian CPU. The largest fundamental type described here is a 32 bit integer, so we want to end up
   with the width and height fields being represented as full integer values. Yet, at the same time we
   want to keep the bit counts we specify for the fields appropriate to the data ranges specified in the
   format.

   For instance, we know the valid formats are 0-5 so the first byte only has 3 bits of range involved.
   A naive method of mapping the description to a bit field would be to insert padding manually as
   follows:

struct Header {
	int Magic : 16;
	int Version : 3;
	int pad0 : 5; // Padding to next byte.
	int YOrigin : 1;
	int pad1 : 3; // Padding to next nibble.
	int XOrigin : 1;
	int Width : 32; // Will be in the next 'int' automatically since it won't fit in the prior one.
	int Height : 32; // Next int again.
};

   Personally, I don't like the unused 'pad' fields in my code, much less in an auto complete list if
   your editor supports such things. Additionally, I'd rather be explicit in expecting width to be in
   the next int as intended. So, we use unnamed fields in the definition to help out here:

struct Header {
	int Magic : 16;
	int Version : 3;
    int : 5; // Padding to next byte.
	int YOrigin : 1;
    int : 3; // Padding to next nibble.
	int XOrigin : 1;
    int : 0; // Explicitly tell the compiler to allocate a new integer.
	int Width : 32; // Will be in the next 'int' automatically since it won't fit in the prior one.
	int Height : 32; // Next int again.
};

   This does exactly the same thing but now you don't have to pepper the structure with 'padx' field
   names unless you have a specific purpose, in which case you could probably use a better name than
   'pad'. Say for instance, you expect to eventually allow more than 8 type versions and thus end up
   using some of the 5 padding bits.

   You could name the pad: "VersionReserved". The name makes sense as it is reserved specifically for
   extension of the version field. But, assuming you don't care about the bits for the time being, the
   unnamed field does the same job and doesn't dirty up auto completions and such.

   What exactly is the unnamed '0' field though, 0 bits, huh? This is a special standards required
   behavior which tells the compiler to immediately allocate a new fundamental type for the next field
   to begin filling. While it is already implied that the 32 bit field will have to be placed in a new
   int since it won't fit otherwise, this is an explicit hint for readability in this case.

Real World Examples
   So all the description is fine, but at this point you may be asking yourself, why would I ever bother
   with this? There are several cases where a bit field can be extremely valuable, either in
   simplification or in clearing up messy programming. I'll give two examples in the following which
   could be used in today's coding requirements.

Working With 16 Bit Colors
   Working with 16 bit colors can often cause a fair amount of headaches. You pass the color around as
   an uint16_t (unsigned short) but then need to manipulate the r, g and b components individually.
   Accessing the components individually involves masking out the relevant portions of the value and
   then shifting them into place for further work.

   So, for instance your color is probably packed as 5:6:5 such that there are 5 r and b bits and 6 g
   bits. Accessing the b bits is simple: "int b = color & 0x1f;". Accessing r and g involve shifts, so
   for instance, to get the g you could use: "int g = (color>>5) & 0x3f;". Replacing items in the colors
   is more complicated due to having to mask out the original value prior to inserting the new bits.

   Doing such accesses, even with helpers or macros is often error-prone so, in steps the bit field:

typedef uint16_t ColorRGB565_t;
union ColorRGB565 {
	ColorRGB565_t Composite;
	struct {
		ColorRGB565_t B : 5;
		ColorRGB565_t G : 6;
		ColorRGB565_t R : 5;
	};
};

   So the compiler does all the masking and shifting for you and makes the type a bit cleaner to use.
   Better yet, by using the bit field you are giving the compiler more opportunity to perform
   optimizations for you. Perhaps in a function where you extract the G twice, if you use shifts and
   masking yourself or a helper function, the compiler may not be able to recognize that they are both
   doing the same thing and eliminate one of the extractions.

   With the bit field, it is much more likely that the compiler will notice the duplication and remove
   it. But, considerably better, is that all the shifting and masking is handled by the compiler without
   hassles for the programmer.

Working With IEEE 754 Floating Points
   Eventually, all programmers should probably understand the floating point format. But much as in the
   16 bit color example, extracting and manipulating the bits in a float is both error-prone and often
   confusing. So, it is the bit field definition to the rescue once again:

typedef uint32_t FloatBinaryRep_t;
union FloatBinaryRep {
	float Value;
	struct {
		FloatBinaryRep_t Mantissa : 23;
		FloatBinaryRep_t Exponent : 8;
		FloatBinaryRep_t Sign : 1;
	};
};

     By strict aliasing rules, the given union is actually undefined by the C++ standard. Thankfully
     both MSVC and GNU specifically state that this is valid and as such you can use this style of
     aliasing. On a compiler without the guarantee it would be required to memcpy the data from the
     float into the bit field representation.

   Using this union allows you to write simplified code for several things. Duplicating some items in
   the standard libraries for instance, you could detect nan's using the following code:

bool IsNan(float f) {
	FloatBinaryRep_t fbr;
	fbr.Value = f;

	if(fbr.Exponent=0xFF && fbr.Mantissa!=0)
		return true;

	return false;
}

   More important uses are beyond the scope of this article but an example would be implementing a
   tolerant equivalence check which scales with the magnitudes of the inputs. This is an important
   feature since the standard tolerance used by many programs is something like "abs( a-b ) > tolerance"
   which has to be specifically coded for the input data.

   If your values range from 1-100 the tolerances are likely in the '0.0001f' range, but if your values
   are 0-1, the tolerance may need to be more like '0.00000001f' to be useful. A more flexible tolerance
   is one which understands the binary representation and works as a percentage of difference instead of
   the fixed range used in the simple delta comparisons.

Conclusion
   Hopefully you have a better understanding of bit fields, their possible uses and of course the
   idiosyncrasies of their implementations. Bringing all of the information into one place, with
   examples beyond the trivial, was the primary goal. Hopefully this short article will be a reasonable
   reference for people in the future.



---
https://www.quora.com/How-are-bit-manipulation-and-bit-fields-in-C-important-in-the-real-world

How are bit manipulation and bit fields in C important in the real world?

Profile photo for Pablo Fuente Salas Pablo Fuente Salas Author has 6.7K answers and 2.6M answer views5y
Originally Answered: How are bit manipulation and bit fields in C useful in the real world?

First you must understand whats C mostly used this days. That is, as microcontrollers. (of course can be used
for anything else, but thats the main). On microcontrollers you havea chip that is small compared with a
computer. And it has perhaps only 3 inputs and 5 outputs (there are biggers of course). But internally, it may
be all the inputs and output on the same register (that actually depends on the microcontroller). But from c
you may have something like bit 0,1 and 2, are input and they Require by hardware to always be 1 to
act as inputs.

At the same time all the rest of the bits are outputs, and lets suppose you need tochange bit 4, without
changing the input. Then you cannot just set the value 8 on the output, because you will be overriging the
other 4 outputs. Also, you may need for any reason to not change the other 3 bits.

In such case the best to di is, read the register and then do a reg = reg | 8;

If you want to make it 1 the bit 4
or reg = reg & (~8) to make it 0
or reg = reg ^ 8 if you want to switch it.

Now if you mean in a normal computer, if you are using C if because you want the program to run as fast as
possible and to use as less memory as possible too. (even if it takes a lot of extra work becaues it will, if
no there is no point using C)

For that if for example you may want to use some compression on a file. To make it easier lets suppose we only
have 4 possible values on the file (its not normal but can be applied even with 256 possible values).

4 values can be achieved with only 2 bits. but without compressiong they will take 1 byte (8 bits each).

So lets suppose we need to save in an array 100 bytes of values from 0 to 3. The straigtforward will be lets
just store them as integer. but, now suppose you need to store 1 gb of just that. To store that is a LOT more
memory and may not even be good to have all of that in memory at the same time.

Now with simple compressiong, 1 byte has 8 bits, and we only are using 2 and wasting 6. so, we can just say,
hey lets join 4 data on just one character. That way instead of 1gb this will use 250Mb (a lot less)

This even so has a cost, the cost is that, we can no longer access them just by index because the first byte
will have 4 data.

So if we want to get the first element will still be cero but, will not be just the first but the first 4.

To get any element, first we must reduce the index (that will be just a division by 4) but we are here also
for speed and there is a better way to divide by four integers. Thats index >> 2 (and thats bitwise).

So the real index goes from index to index>>2, now that only gives pair of 4 values. The second part will be
to gather the number for easy we will store the lowest in the lowest part of the bit like this 33221100, the
first intem if its a 3 will be 0x03= 3, the second will be 0x0C=12, 0x30=48 and 0xC0= 184, as you can see its
the same value multiplied by 4 each time (why by four because its 2 bit up).

So to get only the value we want, we can do something like
array[index>>2] >> ((index & 3)<<1))

So this reduses places in the range to 0-3 the data we want (index & 3)<<1 gathers if we will use the first,
second third or fourt chunk.

If index&3= 0 its saying to 0x03 shift 0 times, so gives the first chunk and so on then if its not the 3rd
there is going to be extra data above the 3. so we eliminate them with:
eachdata=(array[index>>2] >>((index & 3)<<1)) 0x03

Thats to read to write is similar. Besides that, to compress even more. We can scan the full file and "count"
how many 0, 1, 2 and 3 it has.

Then we assign less bits to the one having more count (in this case will not be too good but with more
variabilite it gets better.

For this example lets suppose there 2 has 50% of the total, 1 has 25% and the others are both 12.5% each. (it
will never happen but just to explain it better). Then we can reconfigure it so, the bit 1 (and only 1 bit),
means the number 2.

The number 1 is 01 (cannot start with 1 or will mean number 2) then 0 is 000 (it needs 3 ceros)
and then 3 is 001 supposing the same file as before (250MB compressed with the first system).

Eeven so there is 1 gb of data, but now 500MB (2) only uses 1 bit.

250MB (1) uses 2 bits, and 250 uses 3 bits. (0 and 3) so the 2 really uses 500*1/8 MBytes
1 uses (250*2/8) MBytes
0 and 3 uses (250*3/8) Mbytes

Making the sum this goes to 62.5 + 62.2 + 93,75 = 218.75 MBytes.

As you can see its rather less than 250 Megabytes (and there are even better compressions taking in
consideration where the data is).

for this one you have to first serialize the data and then shift it into position and for that you use a LOT
of bitwise.


---
https://www.pagetable.com/?p=250

Readable and Maintainable Bitfields in C
2009-06-23

   Bitfields are very common in low level C programming. You can use them for efficient storage of a
   data structure with lots of flags, or to pass a set of flags between functions. Let us look at the
   different ways of doing this.

   The straightforward way to deal with bitfields is to do the Boolean logic by hand:

Boolean Magic

#define FLAG_USER   (1 << 0)
#define FLAG_ZERO   (1 << 1)
#define FLAG_FORCE  (1 << 2)
/* bits 3-30 reserved */
#define FLAG_COMPAT (1 << 31)

int create_object(int flags) {
	int is_compat = (flags & FLAG_COMPAT);

	if (is_compat)
		flags &= ~FLAGS_FORCE;

	if (flags & FLAG_FORCE) {
		[...]
	}
	[...]
}

int create_object_zero(int flags) {
	create_object(flags | FLAGS_ZERO);
}

void caller() {
	create_object(FLAG_FORCE | FLAG_COMPAT);
}

   You can see code like this everywhere, so most C programmers can probably read and understand this
   quite easily. But unfortunately, this method is very error-prone. Mixing up "&" and "&&" and omitting
   the "~" when doing "&=" are common oversights, and since the compiler only sees "int" types, this
   also doesn't give you any kind of type-safety.

Bitfields
Let us look at the same code using bitfields instead:

typedef unsigned int boolean_t;
#define FALSE 0
#define TRUE !FALSE

typedef union {
	struct {
		boolean_t user:1;
		boolean_t zero:1;
		boolean_t force:1;
		int :28;                /* unused */
		boolean_t compat:1;     /* bit 31 */
	};
	int raw;
} flags_t;

int create_object(flags_t flags) {
	boolean_t is_compat = flags.compat;

	if (is_compat)
		flags.force = FALSE;

	if (flags.force) {
		[...]
	}
	[...]
}

int create_object_zero(flags_t flags) {
	flags.zero = TRUE;
	create_object(flags);
}

void caller() {
	create_object((flags_t) { { .force = TRUE, .compat = TRUE } });
}

   Flags can just be used like any variables. The compiler abstracts the Boolean logic away. The only
   downside is that the code with the static initializer requires some advanced syntax.

Endianness
   Bitfields in C always start at bit 0. While this is the least significant bit (LSB) on Little Endian
   (bit 0 has a weight of 2^0), most compilers on Big Endian systems inconveniently consider the most
   significant bit (MSB) bit 0 (bit 0 has a weight of 2^31, 2^63 etc. depending on the word size), so in
   case your bitfield needs to be binary-compatible across machines with different endianness, you will
   need to define two versions of the bitfield.

The Raw Bitfield
   Did you notice the "int raw" in the union? It lets us conveniently (and type-safely) export the raw
   bit value without having to use a cast.
        printf("raw flags: 0x%xn", flags.raw);

   We can use this to reconstruct the FLAG_* constants in the original example, in case some code needs
   it:
#define FLAG_USER   (((flags_t) { { .user   = TRUE } }).raw)
#define FLAG_ZERO   (((flags_t) { { .zero   = TRUE } }).raw)
#define FLAG_FORCE  (((flags_t) { { .force  = TRUE } }).raw)
#define FLAG_COMPAT (((flags_t) { { .compat = TRUE } }).raw)

   This code constructs a temporary instance of the bitfield, sets one bit, and converts it into a raw
   integer - all at compile time.

Bitfield Access from Assembly
   With the same trick, you can also access your bitfield from assembly, for example if the bitfield is
   part of the Thread Control Block in your operating system kernel, and the low level context switch
   code needs to access one of the bits. The "int raw" can be used to statically convert a flag into the
   corresponding raw mask:

typedef unsigned int boolean_t;

typedef union {
	struct {
		boolean_t bit0:1;
		boolean_t bit1:1;
		int :19;
		boolean_t bit31:1;
	};
	int raw;
} bitfield_t;


int test() {
	int param = -1;
	int result;

	__asm__ volatile (
		"test	 %2, %1    n"
		"xor	 %0, %0    n"
		"setcc	 %0	   n"
		: "=r" (result)
		: "r" (param),
		  "i" (((bitfield_t) { { .bit31 = TRUE } }).raw)
	);
	return result;
}

   The corresponding x86 assembly code looks like this:

	.text
	.align  4,0x90
	.globl  _test
_test:
	pushl   %ebp
	movl    %esp, %ebp
	movl    $-1, %eax
	## InlineAsm Start
	test    $0x80000000, %eax
	xor     %eax, %eax
	setcc   %eax
	## InlineAsm End
	popl    %ebp
	ret

	.subsections_via_symbols

   This works fine with LLVM, but unfortunately GCC (4.2.1) has problems detecting that the raw value is
   available at compile time, so the "i" has to be replaced with an "r": GCC will then pre-assign a
   register with the raw value instead of being able to use an immediate with the "test" instruction.

How to Not Do It
   I have seen C++ code doing this:

enum {
	FLAG_USER,
	FLAG_ZERO,
	FLAG_FORCE,
	FLAG_COMPAT = 31
}

int create_object(bitfield_t flags) {
	bool is_compat = flags.is_set(FLAG_COMPAT);

	if (is_compat)
		flags -= FLAGS_FORCE;

	if (flags.is_set(FLAG_FORCE)) {
		[...]
	}
	[...]
}

int create_object_zero(int flags) {
	create_object(flags + FLAGS_ZERO);
}

void caller() {
	create_object(((bitfield_t)FLAG_FORCE) + FLAG_COMPAT);
}

   This all looks quite weird. The constants are bit index values, and they are added and subtracted.
   The reason is C++ operator overloading:

class bitmask_t {
	word_t      maskvalue;

	public:
	[...]
		inline bitmask_t operator -= (int n) {
			maskvalue = maskvalue & ~(1UL << n);
			return (bitmask_t) maskvalue;
		}
	[...]
}

   This is horrible. The code that uses this class makes no sense unless you read and understand the
   implementation of the class. And you have to be very careful: While it is possible to "add" a flag to
   an existing bitfield, you cannot just add two flags - it would do the arithmetic and add the two
   values.

   Mapping the setting and clearing of bits onto the addition and subtraction operators is clearly wrong
   in the first place: Flags in a bitfield are equivalent to elements in a set. Setting a flag is
   equivalent to the "union" operation, which even in Mathematics has its own symbol instead of
   overloading the "+" operator.


---
https://jarombek.com/blog/jun-23-2018-bit-field

Working with Bit Fields
June 23rd, 2018

I was recently reading a book on Java and read through a chapter on how to use bit fields. Bit Fields are a
data structure that I never really understood completely (along with most of the bitwise operators), so I
figured I would take some time to look at Bit Fields in detail.


A data structure that consists of one or many memory locations (bits). Each of these bits has a unique meaning
defined by the programmer1. It is common practice to use an unsigned integer data type of a specified length
for a bit field. For example, in C you can define a bit field as unsigned int bitField : 2. This bit field
consists of two bits which can be turned on or off - each of which has a unique meaning defined by the
programmer.

I decided to go back to C for my bit field implementation since the data structure is often used in situations
where low memory consumption is imperative. While I am no master at C, I really enjoy playing around with the
language and hope to understand it to a greater capacity some day.

Bit Field C Implementation
I started my implementation by defining some bit masks along with a type definition representing a user. The
last field in the User type definition - statusField - is a 3-bit field.
#define VALIDATED 01
#define SUBSCRIBED 02
#define ADMIN 04

typedef struct {
	char first[31];
	char last[31];
	unsigned int statusField : 3;
} User;

The preprocessor definitions for this code are three bit masks which can be applied to the bit field. Every
time a macro such as VALIDATED is used in the code, its occurrence is replaced with the definitions
replacement text (ex. VALIDATED is replaced with 01)2.

Bit Mask
A bit mask is a series of bits used to perform operations on another series of bits. A mask is commonly used
to check for the existence of certain bits or remove/add certain bits to a value3, 4. For example, let's say
we have a series of bits 010. If we wanted to toggle on the first bit in the previous sequence, we can use the
bit mask 001 and perform a bitwise OR operation. The result of 010 | 001 is 011, so the first bit was
successfully toggled on by the bit mask.

The typedef struct code defines a new data type that has multiple fields - a users first and last name along
with a bit field containing their status5. The bit field represents a users privileges/status on an online
website.

Next I wrote some code to declare a new user type and set its bit field to 000.

int main() {
	User andy;
	strcpy(andy.first, "Andrew");
	strcpy(andy.last, "Jarombek");

	// Set the status as 000
	andy.statusField = 0;

	...
}

Now comes the interesting part. I set up some functions to alter bits in the bit field using bit masks.

/**
 * Add a status to the bit field on a user type
 * @param user - a User type
 * @param mask - the status to add to the bit field
 */
void addStatus(User *user, unsigned int mask) {
	user->statusField |= mask;
}

/**
 * Remove a status from the bit field on a user type
 * @param user - a User type
 * @param mask - the status to add to the bit field
 */
void removeStatus(User *user, unsigned int mask) {
	user->statusField &= ~mask;
}

/**
 * Check to see if a status is in the bit field
 * @param bitField - a bit field to search through
 * @param mask - a bit mask to bitwise 'and' with the bit field
 * @return 0 if the mask doesn't exist in the bit field, an integer >= 1 otherwise
 */
int containsStatus(unsigned int bitField, unsigned int mask) {
	return bitField & mask;
}

To turn on bits in a bit field, the bitwise OR operation is performed between the bit field and the mask. For
example, 000 | 010 results in the middle bit being turned on - 010.

To turn off bits in the bit field, the bitwise AND and NOT operators are used. For example, 011 & ~010 turns
off the middle bit, resulting in 001.

To check if a bit is turned on in a bit field, a simple bitwise AND is used between the bit field and the
mask. If the value resulting from the bitwise AND is greater than 0, the bit is turned on in the field.
Otherwise, its turned off. For example, 011 & 010 checks if the middle bit is turned on. Since the result is
010 or 2, we know that the bit is turned on in the bit field.

The bit masks are the preprocessor macros VALIDATED, SUBSCRIBED, and ADMIN. They are used in the following
code to turn on bits, turn off bits, and check for existence of bits in the bit field.

...

// Set the status as 000
andy.statusField = 0;

printUser(andy);

// Validate the user, change the status from 000 to 001
addStatus(&andy, VALIDATED);
printUser(andy);

// Give the user admin rights, change the status from 001 to 101
addStatus(&andy, ADMIN);
printUser(andy);

// Take away the admin rights to the user, change the status from 101 to 001
removeStatus(&andy, ADMIN);
printUser(andy);

// Give the subscribed status, change the status from 001 to 011
addStatus(&andy, SUBSCRIBED);
printUser(andy);

if (containsStatus(andy.statusField, VALIDATED)) {
	printf("The User IS Validated \n");
} else {
	printf("The User IS NOT Validated \n");
}

if (containsStatus(andy.statusField, SUBSCRIBED)) {
	printf("The User IS Subscribed \n");
} else {
	printf("The User IS NOT Subscribed \n");
}

if (containsStatus(andy.statusField, ADMIN)) {
	printf("The User IS an Admin \n");
} else {
	printf("The User IS NOT an Admin \n");
}


Andrew, Jarombek, 0
Andrew, Jarombek, 1
Andrew, Jarombek, 5
Andrew, Jarombek, 1
Andrew, Jarombek, 3
The User IS Validated
The User IS Subscribed
The User IS NOT an Admin

The full code for the C implementation can be found [**1]here.

Bit Field Java Implementation
Bit fields can also be used in Java. The following code for a User class defines static final variables for
the bit masks. Note that in Java all integers are signed and 32 bits long, so you have 31 bits to play with in
a bit field data structure.

public final class User {

	/* Flags for different statuses */
	static final int VALIDATED = 1;
	static final int SUBSCRIBED = 2;
	static final int ADMIN = 4;

	private int statusBitField;
	private String first;
	private String last;

	// Package-private constructor for the user.  The bit field is defaulted to a value of 0.
	User(String first, String last) {
		statusBitField = 0;
		this.first = first;
		this.last = last;
	}

	// private constructor that takes in a bit field.
	private User(String first, String last, int bitField) {
		this.statusBitField = bitField;
		this.first = first;
		this.last = last;
	}

	// Add a status to the users bit field
	static User addStatus(User user, int status) {
		int updatedStatusBitField = user.statusBitField | status;

		return new User(user.first, user.last, updatedStatusBitField);
	}

	// Remove a status from the users bit field
	static User removeStatus(User user, int status) {
		int updatedStatusBitField = user.statusBitField & ~status;

		return new User(user.first, user.last, updatedStatusBitField);
	}

	// Perform an action (supplied by the second argument) when given a boolean
	// representing the existence of a status for the user.
	void containsStatus(int mask, Consumer<Boolean> action) {
		action.accept(containsStatus(mask));
	}

	// Check for the existance of a status in a bit field
	boolean containsStatus(int mask) {
		return (statusBitField & mask) > 0;
	}
}

The following code performs operations on the user class, similar to the C implementation.

// Base user has a bit field of value 000
User user = new User("Andy", "Jarombek");

// Add the validated flag to the bit field: 000 -> 001
User validatedUser = User.addStatus(user, User.VALIDATED);

// Add the admin flag to the bit field: 001 -> 101
User adminUser = User.addStatus(validatedUser, User.ADMIN);

// Remove the admin flag from the bit field: 101 -> 001
User revokedAdminUser = User.removeStatus(adminUser, User.ADMIN);

// Add the subscribed flag to the bit field: 001 -> 011
User subscribedUser = User.addStatus(revokedAdminUser, User.SUBSCRIBED);

System.out.println(user);
System.out.println(validatedUser);
System.out.println(adminUser);
System.out.println(revokedAdminUser);
System.out.println(subscribedUser);

// Check to see if the user has different statuses based on the bit field
subscribedUser.containsStatus(User.VALIDATED,
		(bool) -> System.out.println("User is Validated: " + bool));

subscribedUser.containsStatus(User.SUBSCRIBED,
		(bool) -> System.out.println("User is Subscribed: " + bool));

subscribedUser.containsStatus(User.ADMIN,
		(bool) -> System.out.println("User is Admin: " + bool));



Andy, Jarombek, 0
Andy, Jarombek, 1
Andy, Jarombek, 5
Andy, Jarombek, 1
Andy, Jarombek, 3
User is Validated: true
User is Subscribed: true
User is Admin: false

The full code for the
[https://github.com/AJarombek/jarombek-com-sources/blob/master/2018/06-Jun/6-23-Bit-Field/Java/User.java]User
class and
[https://github.com/AJarombek/jarombek-com-sources/blob/master/2018/06-Jun/6-23-Bit-Field/Java/Main.java]Main
class utilizing bit fields is on GitHub.

While you can use bit fields in Java like the previous implementation, using primitive int variables for bit
fields goes against some of Java's core principles. Using int primitives for bit fields is not type safe -
which is often a crucial requirement for a Java data structure6. Luckily there is a type safe approach for bit
fields in Java. This approach uses the EnumSet collection to store the fields. The fields themselves are
represented as enums. This approach is not only type safe and more readable, but also has the same performance
as the non-safe integer approach.

The code for the EnumSet approach is on GitHub in the
[https://github.com/AJarombek/jarombek-com-sources/blob/master/2018/06-Jun/6-23-Bit-Field/Java/EnumSetUser.java]EnumSetUser
and
[https://github.com/AJarombek/jarombek-com-sources/blob/master/2018/06-Jun/6-23-Bit-Field/Java/EnumSetMain.java]EnumSetMain
classes.

Conclusions
Researching bit fields was a really valuable exercise to gain further knowledge of bitwise operations and low
level data structures. Expect more discoveries on Java and C in the future.


---
[**1]

/*
 * Author: Andrew Jarombek
 * Date: 6/22/2018
 * Demonstrate bit fields in C
 */

#define VALIDATED 01
#define SUBSCRIBED 02
#define ADMIN 04

#include <string.h>
#include <stdlib.h>
#include <stdio.h>

// Type to hold a user construct
typedef struct {
	char first[31];
	char last[31];
	unsigned int statusField : 3;
} User;

void addStatus(User *user, unsigned int mask);
void removeStatus(User *user, unsigned int mask);
int containsStatus(unsigned int bitField, unsigned int mask);
void printUser(User user);

int main() {
	User andy;
	strcpy(andy.first, "Andrew");
	strcpy(andy.last, "Jarombek");

	// Set the status as 000
	andy.statusField = 0;

	printUser(andy);

	// Change the status from 000 to 001
	addStatus(&andy, VALIDATED);

	printUser(andy);

	// Change the status from 001 to 101
	addStatus(&andy, ADMIN);

	// The user now is validated and is an admin
	printUser(andy);

	// Take away the admin rights to the user, change the status from 101 to 001
	removeStatus(&andy, ADMIN);
	printUser(andy);

	// Give the subscribed status, change the status from 001 to 011
	addStatus(&andy, SUBSCRIBED);
	printUser(andy);

	if (containsStatus(andy.statusField, VALIDATED)) {
		printf("The User IS Validated \n");
	} else {
		printf("The User IS NOT Validated \n");
	}

	if (containsStatus(andy.statusField, SUBSCRIBED)) {
		printf("The User IS Subscribed \n");
	} else {
		printf("The User IS NOT Subscribed \n");
	}

	if (containsStatus(andy.statusField, ADMIN)) {
		printf("The User IS an Admin \n");
	} else {
		printf("The User IS NOT an Admin \n");
	}
}

/**
 * Add a status to the bit field on a user type
 * @param user - a User type
 * @param mask - the status to add to the bit field
 */
void addStatus(User *user, unsigned int mask) {
	// Equivalent of statusField = statusField | mask.  Combines the "on" bits
	// from the existing statuses on the bit field and the new status bits
	user->statusField |= mask;
}

/**
 * Remove a status from the bit field on a user type
 * @param user - a User type
 * @param mask - the status to add to the bit field
 */
void removeStatus(User *user, unsigned int mask) {
	// Equivalent of statusField = statusField & ~mask.
	user->statusField &= ~mask;
}

/**
 * Check to see if a status is in the bit field
 * @param bitField - a bit field to search through
 * @param mask - a bit mask to bitwise 'and' with the bit field
 * @return 0 if the mask doesn't exist in the bit field, an integer >= 1 otherwise
 */
int containsStatus(unsigned int bitField, unsigned int mask) {
	return bitField & mask;
}

/**
 * Print out a User types properties
 * @param user - a User type
 */
void printUser(User user) {
	printf("%s, %s, %d \n", user.first, user.last, user.statusField);


---
https://www.learn-c.org/en/Bitmasks

Bitmasks

   Bit masking is simply the process of storing data truly as bits, as opposed to storing it as
   chars/ints/floats. It is incredibly useful for storing certain types of data compactly and
   efficiently.

   The idea for bit masking is based on boolean logic. For those not familiar, boolean logic is the
   manipulation of 'true' (1) and 'false' (0) through logical operations (that take 0s and 1s as their
   argument). We are concerned with the following operations:
     * NOT a - the final value is the opposite of the input value (1 -> 0, 0 -> 1)
     * a AND b - if both values are 1, the final value is 1, otherwise the final value is 0
     * a OR b - if either value is 1, the final value is 1, otherwise the final value is 0
     * a XOR b - if one value is 1 and the other value is 0, the final value is 1, otherwise the final
       value is 0

   In computing, one of these true/false values is a bit. Primitives in C (int, float, etc) are made up
   of some number of bits, where that number is a multiple of 8. For example, an int may be at least 16
   bits in size, where a char may be 8 bits. 8 bits is typically referred to as a byte. C guarantees
   that certain primitives are at least some number of bytes in size. The introduction of stdint.h
   in C11 allows the programmer to specify integer types that are exactly some number of bytes, which is
   extremely useful when using masks.

   Bit masks are often used when setting flags. Flags are values that can be in two states, such as
   'on/off' and 'moving/stationary'.

Setting bit n
   Setting bit n is as simple as ORing the value of the storage variable with the value 2^n.

   storage |= 1 << n;

   As an example, here is the setting of bit 3 where storage is a char (8 bits):

   01000010 OR 00001000 == 01001010

   The 2^n logic places the '1' value at the proper bit in the mask itself, allowing access to that same
   bit in the storage variable.

Clearing bit n
   Clearing bit n is the result of ANDing the value of the storage variable with the inverse (NOT) of
   the value 2^n:

   storage &= ~(1 << n);

   Here's the example again:

   01001010 AND 11110111 == 01000010

Flipping bit n
   Flipping bit n is the result of XORing the value of the storage variable with 2^n:

   storage ^= 1 << n;

   01000010 01001010 XOR XOR 00001000 00001000 == == 01001010 01000010

Checking bit n
   Checking a bit is ANDing the value of 2^n with the bit storage:

   bit = storage & (1 << n);

   01000010 01001010 AND AND 00001000 00001000 == == 00000000 00001000



---
http://www.folder101.com/Control/Notes/BitMasking/BitMasking.htm

+----------------------------------------------------------------------------------------+
| Bit Masking                                                                            |
|                                                                                        |
|     Read on for an introduction to bit masking - a low level operation on bits.        |
|     Masking can be used to extract specific bits from a set of bits, block other bits, |
|     compare values, and many other operations.                                         |
|                                                                                        |
|         Introduction to Bit Masking                                                    |
|                                                                                        |
|         Using AND Masking                                                              |
|                                                                                        |
|                   Extracting Bits Using AND                                            |
|                                                                                        |
|                   Setting Bits to 0 Using AND                                          |
|                                                                                        |
|         Using OR Masking                                                               |
|                                                                                        |
|                   Extracting Bits Using OR                                             |
|                                                                                        |
|                   Setting Bits to 1 Using OR                                           |
|                                                                                        |
|         Using XOR Masking                                                              |
|                                                                                        |
|                   Comparing Bits Using XOR                                             |
|                                                                                        |
|         Why Use Bit Masking?                                                           |
|                                                                                        |
| -------------------------------------------------------------------------------------- |
|                                                                                        |
| Introduction to Bit Masking                                                            |
|                                                                                        |
|     Bit masking is a common programming technique which packs a number of Boolean      |
|     values into a single number, thus compacting a lot of information together and     |
|     saving storage space.  For example, a 8-bit integer could hold the TRUE or FALSE   |
|     values of 8 different flags, with the value 1 representing TRUE and 0 representing |
|     FALSE.                                                                             |
|                                                                                        |
|     Let's consider the Z80 microprocessor, which uses an 8-bit register F to hold      |
|     different Boolean values (called flags).  There are six flags as explained below:- |
|                                                                                        |
|     C    Carry         Set if an add is too great or a subtraction is less than 0.     |
|     P    Parity        set when the parity is odd and reset to 0 if the parity is even |
|     N                  indicates if the last instruction was an add or subtract        |
|     S    Sign          set to 1 if the result of an operation is between 0 and 127 and |
|                        reset to 0 if is between 128 and 255                            |
|     Z    Zero          set to 1 if the result is zero and set to 0 if the result is    |
|                        not zero                                                        |
|     H    Half Carry    used when converting hex values to BCD                          |
|                                                                                        |
|                                                                                        |
|                                                                                        |
|       The bit position of some of the flags are shown below:                           |
|                                                                                        |
|                                                                                        |
|                                                                                        |
|                         S       Z                       P            C                 |
|                         sign  zero                    parity       carry               |
|                                                                                        |
|     The bit flags in the field can have a 0 or 1 value and each bit represents the     |
|     state of something.  As an example, the zero bit indicates if the result of an     |
|     operation is zero or not.   So how can we extract the state of a particular bit in |
|     the filed?                                                                         |
|                                                                                        |
|     Setting and reading a bit field like the F register requires combining the value   |
|     of the field with a mask, using the logical operators, AND, OR, XOR and NOT.       |
|     These operate in what is called a bitwise fashion.  This means that each bit in a  |
|     register is matched against a corresponding bit in another register.  Using the    |
|     logical operators we can create a mask which either lets a pattern of bits through |
|     or blocks them.                                                                    |
|                                                                                        |
|     Thus, we can use AND to get the current state of a particular bit in the field, OR |
|     to set a bit in a bit field and XOR to flip the state of a specified bit.          |
|                                                                                        |
| -------------------------------------------------------------------------------------- |
|                                                                                        |
| Using AND Masking                                                                      |
|                                                                                        |
|     The AND mask is useful for extracting/getting the current state of particular      |
|     bits.  It may also used for setting particular bits to 0.                          |
|                                                                                        |
|     Extracting Bits Using AND                                                          |
|                                                                                        |
|     The value of a single bit within a series of bits can be obtained by using the AND |
|     operator with a mask to filter out single bit values from the rest of the bits.    |
|     Whatever bits you make 0 will be 0 when the AND is complete, and whatever bits are |
|     1 will make the corresponding bit in the CPU register stay the same (whether it be |
|     1 or 0).                                                                           |
|                                                                                        |
|     As an example let's see how we can extract a single bit value from the series of   |
|     bits 1011.                                                                         |
|                                                                                        |
|     Using the AND operator we can mask the particular bit we want to extract.  Say we  |
|     wish to extract the highest bit of the number 1011, then we need to set the        |
|     highest bit of the mask to 1 and set the rest to 0.                                |
|                                                                                        |
|                           Number          1      0      1      1                       |
|                           Bit Mask        1      0      0      0                       |
|                           AND Result      1      0      0      0                       |
|                                                                                        |
|     If the highest bit was a 0 we would have obtained the result 0000 instead of 1000. |
|                                                                                        |
|     Now suppose we wish to extract the value of the second highest bit .  In this case |
|     we would set the bit mask so that the second highest bit in the mask is set to 1   |
|     with the rest set to 0.                                                            |
|                                                                                        |
|                           Number          1      0      1      1                       |
|                           Bit Mask        0      1      0      0                       |
|                           AND Result      0      0      0      0                       |
|                                                                                        |
|     If the second highest bit happened to be a 1 we would have obtained the result     |
|     0100 instead of 0000.                                                              |
|                                                                                        |
|     It is often useful to mask more than one bit at a time.  For example, let's assume |
|     register A has the value 10101010 and we wish to mask the first 4 bits.  What mask |
|     should we use?                                                                     |
|                                                                                        |
|     Logical AND Example:        AND B               --> which means: A = A AND B       |
|                                                                                        |
|                                  1st operand in A accumulator                          |
|                               A      1   0   1   0   1   0   1   0                     |
|                                                                                        |
|                                   2nd operand in B register                            |
|                               B      0   0   0   0   1   1   1   1                     |
|                                                                                        |
|                                 Result is put in A accumulator                         |
|                               A      0   0   0   0   1   0   1   0                     |
|                                                                                        |
|     If you consider the contents of A to be the original pattern of bits and B to      |
|     contain the bit mask then the AND function has let the bottom four bits of the     |
|     original pattern through and reset the top four bits to 0.                         |
|                                                                                        |
|         Rule:--->  To get the value of a bit, set a 1 in an AND mask at the            |
|         corresponding bit position.                                                    |
|                                                                                        |
|     Setting Bits to 0 Using AND                                                        |
|                                                                                        |
|     We can use an AND mask to reset particular bits to zero.  Suppose we want to reset |
|     bits 3 and 7 in register A to 0. Then we could use the instruction:-               |
|                                                                                        |
|          AND 01110111                              --> which means: A = A AND 01110    |
|         111                                                                            |
|                                                                                        |
|     Note the underlined 0's.  The corresponding bits in A will be 0's, but everything  |
|     else will remain unchanged.                                                        |
|                                                                                        |
|         Rule:--->  To set a bit to 0, set a 0 in an AND mask at the corresponding bit  |
|         position.                                                                      |
|                                                                                        |
| -------------------------------------------------------------------------------------- |
|                                                                                        |
| Using OR Masking                                                                       |
|                                                                                        |
|     OR is useful for setting the value of a bit.                                       |
|                                                                                        |
|     Extracting Bits Using OR                                                           |
|                                                                                        |
|     The value of a single bit within a series of bits can be set by using the OR       |
|     operator with a mask.  Whatever bits you make 1 will be 1 when the OR is complete, |
|     and whatever bits are 0 will make the corresponding bit in the CPU register stay   |
|     the same (whether it be 1 or 0).                                                   |
|                                                                                        |
|     Logical OR Example:       OR B              --> which means: A = A OR B            |
|                                                                                        |
|                                  1st operand in A accumulator                          |
|                               A      1   0   1   0   1   0   1   0                     |
|                                                                                        |
|                                   2nd operand in B register                            |
|                               B      0   0   0   0   1   1   1   1                     |
|                                                                                        |
|                                 Result is put in A accumulator                         |
|                               A      1   0   1   0   1   1   1  1                      |
|                                                                                        |
|     If you consider the contents of A to be the original pattern of bits and B to      |
|     contain the bit mask then the OR function has let the top four bits of the         |
|     original pattern through and reset the bottom four bits to 1.                      |
|                                                                                        |
|     Setting Bits to 1 Using OR                                                         |
|                                                                                        |
|     We can use an OR mask to set particular bits to a 1.  The bits we don't want to    |
|     change, we OR with 0.  Suppose we want to reset bits 3 and 7 in register A to 1.   |
|     Then we could use the instruction:-                                                |
|                                                                                        |
|          OR 10001000                                  --> which means: A = A OR 10001  |
|         000                                                                            |
|                                                                                        |
|     Rule:--->  If you want to set a bit to 1, put a 1 in an OR mask in the             |
|     corresponding bit position.                                                        |
|                                                                                        |
| -------------------------------------------------------------------------------------- |
|                                                                                        |
| Using XOR Masking                                                                      |
|                                                                                        |
|     XOR is useful for comparing the values in two registers and also for flipping the  |
|     bits in a register.                                                                |
|                                                                                        |
|     Comparing Bits Using XOR                                                           |
|                                                                                        |
|     The XOR function can be useful for checking if the corresponding bits in two       |
|     registers are the same or different.  Let's try it.                                |
|                                                                                        |
|                           Number          1      0      1      1                       |
|                           Bit Mask        1      1      1      1                       |
|                           XOR Result      0      1      0      0                       |
|                                                                                        |
|     We can see that any bits that are the same give a result of 0.  So if we need to   |
|     compare two values for equality, then we would end up with a result of all 0's for |
|     a match and a result containing 1's for an inequality.                             |
|                                                                                        |
|     Now consider the example below.                                                    |
|                                                                                        |
|     Logical XOR Example:       XOR B              --> which means: A = A XOR B         |
|                                                                                        |
|                                  1st operand in A accumulator                          |
|                               A      1   0   1   0   1   0   1   0                     |
|                                                                                        |
|                                   2nd operand in B register                            |
|                               B      0   0   0   0   1   1   1   1                     |
|                                                                                        |
|                                 Result is put in A accumulator                         |
|                               A      1   0   1   0   0   1   0   1                     |
|                                                                                        |
|     If the corresponding bits in A and B are the same then the resulting bit is reset  |
|     to 0.  If they are different then the resulting bit is set to 1.  If A and B were  |
|     equal we would have expected a result of 00000000.                                 |
|                                                                                        |
|         Rule:--->  To test two bit fields for equality, use XOR.  A result of 0 means  |
|         the fields are equal.                                                          |
|                                                                                        |
|     Logical XOR Example 2:       XOR A              --> which means: A = A XOR A       |
|                                                                                        |
|                                  1st operand in A accumulator                          |
|                               A      1   0   1   0   1   0   1   0                     |
|                                                                                        |
|                                  2nd operand in A accumulator                          |
|                               A      1   0   1   0   1   0   1   0                     |
|                                                                                        |
|                                 Result is put in A accumulator                         |
|                               A      0   0   0   0   0   0   0   0                     |
|                                                                                        |
|     Carrying out an XOR operation on any two values that are the same results in all   |
|     zero's.  Thus when we XOR A with itself we reset all the bits to zero.  This is    |
|     also useful for clearing the carry bit in the flag register.                       |
|                                                                                        |
|         Rule:--->  If you want to reset a register to zero, XOR the register with      |
|         itself.                                                                        |
|                                                                                        |
|     Flipping Bits Using XOR                                                            |
|                                                                                        |
|     There are times when we may want to flip bits around. We can use XOR to accomplish |
|     this.  Groups of bits you XOR with a 1 will be flipped. Let's try it.              |
|                                                                                        |
|                           Number          1      0      1      1                       |
|                           Bit Mask        1      1      1      1                       |
|                           XOR Result      0      1      0      0                       |
|                                                                                        |
|     We can see that 1011 has been flipped to 0100.                                     |
|                                                                                        |
|     Logical XOR Example 3:       XOR B              --> which means: A = A XOR B       |
|                                                                                        |
|                                  1st operand in A accumulator                          |
|                               A      1   0   1   0   1   0   1   0                     |
|                                                                                        |
|                                   2nd operand in B register                            |
|                               B      1   1   1   1   1   1   1   1                     |
|                                                                                        |
|                                 Result is put in A accumulator                         |
|                               A      0   1   0   1   0   1   0   1                     |
|                                                                                        |
|     We can see that 10101010 has been flipped to 01010101.                             |
|                                                                                        |
|         Rule:--->  If you want to flip bits, use XOR with 1's in the bit mask.         |
|                                                                                        |
| -------------------------------------------------------------------------------------- |
|                                                                                        |
| Why Use Bit Masking?                                                                   |
|                                                                                        |
|     We have seen that bit masking is useful for many reasons. The introduction         |
|     explained the use of bit masking in getting and setting the values of bits in a    |
|     bit flag field.  The particular example used was the flag register in a Z80        |
|     microprocessor.                                                                    |
|                                                                                        |
|     Getting & Setting Bits                                                             |
|                                                                                        |
|     In may be that the input and output from/to hardware devices contains information  |
|     encoded in bit flags instead of normal integers. Each separate bit in a bit field  |
|     may contain information about something which is independent of the information    |
|     held by another bit in the filed.   When you'd wish to obtain particular           |
|     information out from this bit field, you'll need to extract the needed bits out    |
|     using bit masking.                                                                 |
|                                                                                        |
|     As an example: You get a data from a device and you store it in register A.        |
|     Suppose A = 00101100. However you only need the lower four bits (i.e. 1100). How   |
|     can we get rid of the unnecessary ones?   Yes, we would use an AND mask of         |
|     00001111.                                                                          |
|                                                                                        |
|          LD A, 00101100                                                                |
|          LD B, 00001111                                                                |
|          AND  B                           --> now A = 00001100                         |
|                                                                                        |
|     Yes, by doing this masking, you can extract bits out.                              |
|                                                                                        |
|     How do you suppose we put the bits back?                                           |
|                                                                                        |
|     Say register A = 00101100, which represents a current hardware status. Now, you'd  |
|     like to store the lower 4 bits of your data in C = 00000011 into the lower 4 bits  |
|     of A. In other words, we'd like to make A = 00100011. How can we do this?          |
|                                                                                        |
|     We can do it in two steps:                                                         |
|                                                                                        |
|     First of all, we could mask out the lower 4 bits of A using an AND mask, to set    |
|     the lower four bits to 0, keeping the higher bits unchanged.  I.e. this would give |
|     00100000                                                                           |
|                                                                                        |
|     Then we could do an OR with C, to keep all the 1's of both A and C.                |
|                                                                                        |
|          LD A 00101100                                                                 |
|          LD C, 00000011                                                                |
|          LD B, 11110000                                                                |
|          AND B                      --> now A = 00100000                               |
|          OR C                        --> now A = 00100011                              |
|                                                                                        |
|     What would have happened if some of the higher order bits of C had been set        |
|     though?                                                                            |
|                                                                                        |
|         ~Now try the activity~                                                         |
|                                                                                        |
|                 Activity C                                                             |
|                                                                                        |
|                  1. Suppose C has now changed to 10000011 and you want to              |
|                     store the lower four bits into the lower four bits of              |
|                     A again.  This time C has higher order bits set though             |
|                     which you don't want to be copied to A.  How would you             |
|                     change the code above so...                                        |
|                                                                                        |
|                      a. A = 00101100 becomes 00100011 like before                      |
|                                                                                        |
|                                      That's it!!                                       |
+----------------------------------------------------------------------------------------+



---
https://www.studytonight.com/post/masking-in-c-language


Masking in C Language
APRIL 11, 2023

What is Masking in C Language?
   Firstly, let us try to understand what a mask represents in terms of programming. What do masks mean
   in general term? Suppose there is a face mask. When a person wears a mask, his/her/their
   representation changes. They look different from the way they did before or we can say that their
   actual face is hidden and the usage of a mask introduces new changes. After wearing the mask, a
   person can choose to show whatever necessary details they want to show us like eyes and/or nose.

   In programming, we use masking in a similar way and call it bit masking because masking is performed
   on bits. This is because data is stored in the form of bits in the computer's memory. We can say that
   we use a mask of bits in masking. When we use this mask with our original value, we can show only the
   required data and rest of it is hidden. We know that some bits are set(1) and some are unset(0). We
   use bit masking to operate on such bits. We can also say that we use bit masking to store many layers
   of values in the same set of bits like our face has multiple layers when we use a mask.

   In C programming, we use Bitwise operators for bit masking. They are-
    1. & (bitwise AND) : The result of AND is 1 only if both of the bits are 1.
    2. | (bitwise OR) : The result of OR is 1 if either of the bits are 1.
    3. ^ (bitwise XOR) : The result of XOR is 1 if the bits are different (one 0 and the other 1), and 0
       if the bits are the same (both 0s or both 1s).
    4. << (left shift) : Left shifts the bits of the first operand by places specified in the second
       operand.
    5. >> (right shift) : Right shifts the bits of the first operand by places specified in the second
       operand.
    6. ~ (bitwise NOT) : The result is the opposite of the input value (1 -> 0, 0 -> 1).

Representation of Masks in C Language
   Suppose we have a set S = {2, 3, 6}. We represent this set as 100110. This sequence tells us which
   number is included in the set as follows-

   bit maksing

   The items present in the set are marked by 1 and the rest by 0.

   We can find all subsets of a set using bit masking but it takes exponential time.

How to perform Masking in C?
   Masking is done by setting all the bits except the one(s) we want to 0. Let's take a simple example.
   We know that we can check if a number if even or odd using modulo operator. If the number give
   remainder 0 when divided by 2, it is even otherwise it is odd. We can do this in another way-

   Perform bitwise AND with the number that we have to check. If it is odd, it will result in 1,
   otherwise 0 as follows-

   101 & 001 = 001

   110 & 001 = 000

   Here our mask is 001 which we use to check whether our given number is even or odd. We hide the
   unnecessary details and output only the result.

   Let's say we have a 8 bit variable and we want to check if the 3rd bit from the left is a 1. Let's
   say our value is 00101110. To mask all the other bits, we set all the bits except the 3rd one to 0
   using the & operator:

   00101110 & 00100000 = 00100000

   This tells use whether the 3rd bit was 0 or 1. Here, 00100000 is the mask.

   If we want to keep only middle four bits of our original value and set the rest to 0, here is how we
   can do it-

   Value = 11111111, mask = 00111100

   Using AND operation on them, 11101111 & 00111100 = 00101100 (the result we required)

   If we want to flip the middle four bits, we can perform XOR operation on the same value and mask.

   11101111 ^ 00111100 = 11010011 (middle 4 bits are flipped)

Some Applications of Bit Masking

1. Check whether given number is odd or even

#include <stdio.h>

int main() {
	int n = 5;
	if(n & 1)
		printf("%d is odd.", n);
	else
		printf("%d is odd.", n);
	return 0;
}

   5 is odd.

2. Flip bits of a number

#include <stdio.h>

int main() {
	unsigned int n = 31;
	n ^= 1 << 2;
	printf("After flipping the second bit from right: %d", n);
	//31 = 00011111, 27 = 00011011. So we can see that second bit(0 indexed) from the right has been flipped.
	return 0;
}

27

3. Setting and Unsetting bits of a number

#include <stdio.h>

int main() {
	unsigned int n = 24;
	n |= 1 << 5;
	printf("After setting the fifth bit from right to 1: %d", n);
	n = 24;
	n &= ~ (n << 1);
	printf("\nAfter unsetting the first bit from left to 0: %d", n);
	return 0;
}

   After setting the fifth bit from right to 1: 56
   After unsetting the first bit from left to 0: 8

   In the above code, 24 in binary is 00011000. So, when we set the fifth bit (counting from 0) to 1, it
   becomes 00111000 which is 56 in decimal. When we unset the first significant bit from the left to 0,
   00011000 becomes 00001000 which is 8 in decimal.

4. We can use AND operator to check or clear bits as shown in the examples in the introduction.

5. Multiply/divide a number by 2

#include <stdio.h>

int main() {
	unsigned int n = 24;
	printf("To divide a number by 2, right-shift it by one position: %d", n >> 1);
	printf("\nTo multiply a number by 2, left-shift it by one position: %d", n << 1);
	return 0;
}

   To divide a number by 2, right-shift it by one position: 12
   To multiply a number by 2, left-shift it by one position: 48

Use of Bit Masking
     * It is useful for storing certain types of data in a very efficient manner.
     * It can be used to solve problems where we need to deal with generating subsets of a set but this
       approach usually takes a lot of time.

Conclusion
   Masking is an important programming concept that helps extract and modify specific bits in a data
   block while hiding or masking the rest. Bit masking is a technique that involves performing bitwise
   operations on data blocks to extract the required bits. In C language, bitwise operators like AND,
   OR, XOR, left shift, right shift, and NOT are used for bit masking.

   We can represent sets and perform operations on them using masks. Masking can check whether a given
   number is odd or even, flip bits of a number, or set/unset specific bits in a number. Bit masking has
   various applications in various fields, including cryptography, computer graphics, and digital signal
   processing.


---
https://dev.to/somedood/bitmasks-a-very-esoteric-and-impractical-way-of-managing-booleans-1hlf

 Bitmasks: A very esoteric (and impractical) way of managing booleans
2024 July 20:


Six years and one computer science degree later, I have since changed my mind on most of the negative
sentiments in this article. See the embedded article below for my updated thoughts in the form of an
appreciation post for bitmasks.

Have you ever asked yourself what bitwise operators are for? Why would such a high-level language such as
JavaScript ever need such a low-level operator? For one, it actually has its use cases in JavaScript. Most are
just not as obvious as others. Actually, most are not even obvious at all unless you really try and squint
your eyes at the computer screen. Trust me, I have tried. I'm not even joking. Throughout my relatively short
experience with JavaScript (3 years as of writing this article), it has been so rare to find instances of
bitwise operators appear in average situations. I might not be looking deep enough, but it does seem pretty
clear to me why this is so. By the end of this article, you will see why this is the case.

Bitwise Operators
NOTE: I am not requiring an extensive knowledge on the subject, but I will assume that you are already at
least somehow familiar with binary number systems and bitwise operators. If not, I highly recommend that you
read up a bit (See what I did there?) before continuing with the rest of this article.

Bitwise operators allow us to manipulate the individual bits that make up a number in binary. For a quick
review, here is a "table" of what the common bitwise operators do.

// I will use the binary notation prefix ("0b") a lot in this article.
const num1 = 0b1010; // 10
const num2 = 0b1111; // 15

// NOT num1
~num1; // 0b0101 (complement) === -11

// num1 AND num2
num1 & num2; // 0b1010 === 10

// num1 OR num2
num1 | num2; // 0b1111 === 15

// num1 XOR num2
num1 ^ num2; // 0b0101 === 5

// Bit-shift to the left by 1
num1 << 1; // 0b10100 === 20

// Bit-shift to the right by 1
num >> 1; // 0b0101 === 5

I mean this is great and all for the sake of learning something new everyday, but when would you ever use this
knowledge? Is there a practical application for bitwise operators? Short answer, no. Although it can be useful
in code minification, memory optimization, and some other use cases, by using bitwise operators, you are
opting into less readable code. It is just more cryptic to read because you have to set your "Decimal Mode"
brain into "Binary Mode". Nonetheless, that doesn't stop us, right? We're all here to learn. So without
further ado, I present bitmasks.

Over-engineering a simple problem
Honestly, I don't have a simple definition for what a "bitmask" is. It's quite a strange monster if you'd ask
me. To me, a bitmask can be thought of as a query. Using a bitmask means to query the bits found in some
binary number. If you're confused by that definition, I don't blame you. I have to admit that it isn't the
best definition. If you can think of a better one, please do leave a comment below. I'd gladly update this
article to specifically include your definition.

Anyway, a definition is worthless without its complementary example. Let's say we have an object that stores
booleans corresponding to the configurations found in an app.

// Mock app settings
const config = {
	isOnline: true,
	isFullscreen: false,
	hasAudio: true,
	hasPremiumAccount: false,
	canSendTelemetry: true
};

Our job is done at this point. We can store that as is in a JSON file. That is the straightforward
implementation. However, we can use bitmasks to "over-engineer" this problem. In JavaScript, number types can
be explicitly converted (or coerced) into booleans by passing it into the Boolean function. Take note that in
this case, Boolean is not used as a constructor. It is simply a means to convert the number type (or any type
actually) into its equivalent boolean "truthiness". For example:

Boolean(-2); // true
Boolean(-1); // true
Boolean(0); // false
Boolean(1); // true
Boolean(2); // true
Boolean(Math.PI); // true
Boolean(Number.MAX_SAFE_INTEGER); // true

Since 0 is not exactly a "truthy" value per se, it evaluates to false. That relationship gives us an idea on
how to convert a bunch of booleans into a single number. Instead of storing the app settings as an object, we
can store it as a single number. Yup, you heard, or rather read, that right. First, we think of the booleans
as 1s and 0s, where 1 is true and 0 is false. These 1s and 0s correspond to each property in the config object
from left to right.

// For reference only
const config = {
	isOnline:          true,
	isFullscreen:      false,
	hasAudio:          true,
	hasPremiumAccount: false,
	canSendTelemetry:  true
};

// isOnline:          1
// isFullScreen:      0
// hasAudio:          1
// hasPremiumAccount: 0
// canSendTelemetry:  1
// Thus, we have the binary number 0b10101.
let configNumber = 0b10101; // 21

Bitmasks
NOTE: Here comes the weird part of the article. This is where I pull out the black magic. I hope you have
stretched those brain muscles enough because you'd be doing a strenuous workout with it from this point on.
Feel free to read some parts over and over again. This is a pretty difficult topic to say the least.

Now that we have reduced an entire object into a single number, we can use bitwise operators on it. But why,
do you ask? Well, this is the essence of bitmasking.

A bitmask is a way to "select" the bits you're interested in. When selecting a single particular bit, it is
always a power of 2 because any power of 2 corresponds to that particular bit that is "turned on". Since
bit-shifting to the left is essentially multiplying by 2 (analogous to raising 2 by a power), you can think of
bit-shifting to the left as a way to "select" the bit you are interested in.

// Selecting the 1st bit from the right
// 2 ** 0
// 1 << 0
0b00001 === 1;

// Selecting the 2nd bit from the right
// 2 ** 1
// 1 << 1
0b00010 === 2;

// Selecting the 3rd bit from the right
// 2 ** 2
// 1 << 2
0b00100 === 4;

// Selecting the 4th bit from the right
// 2 ** 3
// 1 << 3
0b01000 === 8;

// Selecting the 5th bit from the right
// 2 ** 4
// 1 << 4
0b10000 === 16;

If we want to select more than one bit, we can do that, too.

// Selecting the 1st and 5th bit from the right
0b10001 === 17;

// Selecting the 3rd and 4th bit from the right
0b01100 === 12;

// Selecting the 2nd, 4th, and 5th bit from the right
0b11010 === 26;

// Selecting the 1st, 2nd, and 4th bit from the right
0b01011 === 11;

// Selecting ALL the bits
0b11111 === 31;

Getting Values

Bitmasking allows us to extract the value of a single bit in the configNumber number. How do we do this? Let's
say we wanted to get the value of hasAudio. We know that the hasAudio property is located at the third bit
from the right of the configNumber.

let configNumber = 0b10101; // 21

// Shifting 0b1 to the left 2 times gives the 3rd bit from the right
const bitMask = 0b1 << 2; // 4

// Since we know that the 3rd bit from the right corresponds to the hasAudio property...
const query = configNumber & bitMask; // 4

// ...we can test its "truthiness" by using the AND operator.
const truthiness = Boolean(query); // true

// The truthiness IS the value we want to extract.
truthiness === config.hasAudio; // true

At this point, you may be asking...

    "So what if it returns 4?
    "So what if it's coerced to true?"
    "So what if it's 'truthy'?"

If you are asking that, then you just answered your own question. 4 has been coerced to true. That is the
exact value of the hasAudio property in the original config object. We have successfully extracted the value
of the hasAudio property through bitmasking.

Well, what happens if we try to query a "falsy" property such as isFullscreen? Would bitmasking reflect the
same value in the original config object? As a matter of fact, it does. We know that the isFullScreen property
is located at the fourth bit from the right in the configNumber.

let configNumber = 0b10101; // 21

// Shifting 0b1 to the left 3 times gives the 4th bit from the right
const bitMask = 0b1 << 3; // 8

// Since we know that the 4th bit from the right corresponds to the isFullscreen property...
const query = configNumber & bitMask; // 0

// ...we can test its "truthiness" by using the AND operator.
const truthiness = Boolean(query); // false

// The truthiness IS the value we want to extract.
truthiness === config.isFullscreen; // true

We can go even crazier by selecting multiple bits in our bitMask, but I'll leave that as an exercise for you
to ponder on.

You may be noticing a pattern here. The result of the AND bitwise operator determines the truthiness of a
query. The truthiness is essentially the actual value of the property we are trying to get in the first place.
Yes, I know; it's black magic. I had the same reaction. It was too clever for me to fully comprehend at the
time.

So now that we know how to extract a boolean out of a specific bit, how do we manipulate a bit?  Toggling
Values

The same logic follows when we want to toggle bits. We still use bitmasks to select the bits we're interested
in, but we use the XOR bitwise operator (^) instead of the AND bitwise operator (&) for our query.

Let's say we wanted to toggle the canSendTelemetry property. We know that it is located in the first bit from
the right.

let configNumber = 0b10101; // 21

// Shifting 0b1 to the left 0 times gives the 1st bit from the right,
// which corresponds to the canSendTelemetry property
const bitMask = 0b1 << 0; // 1

// Toggling the 1st bit from the right
const query = configNumber ^ bitMask; // 20

// Setting the query as the new configNumber
configNumber = query;

Now if we tried to extract the canSendTelemetry property from the new configNumber, we will find that it is no
longer set to true. We have successfully toggled the bit from true to false (or rather from 1 to 0).

All Together Now
This is definitely tedious to do over and over again. Since we all want to save a few keystrokes, let's create
some utility functions that does all this for us. First, we will write two utility functions that extracts the
"truthiness" of a bit: one extracts the "truthiness" if it's given a bitmask, while the other extracts the
"truthiness" if it's given the zero-indexed position (from the right) of the bit being extracted.

/**
 * Extracts the "truthiness" of a bit given a mask
 * @param {number} binaryNum - The number to query from
 * @param {number} mask - This is the bitmask that selects the bit
 * @returns {boolean} - "Truthiness" of the bit we're interested in
 */
function getBits(binaryNum, mask) {
	const query = binaryNum & mask;
	return Boolean(query);
}

/**
 * Extracts the "truthiness" of a bit given a position
 * @param {number} binaryNum - The number to query from
 * @param {number} position - This is the zero-indexed position of the bit from the right
 * @returns {boolean} - "Truthiness" of the bit we're interested in
 */
function getBitsFrom(binaryNum, position) {
	// Bit-shifts according to zero-indexed position
	const mask = 1 << position;
	const query = binaryNum & mask;
	return Boolean(query);
}

Finally, let's write a utility function for toggling one or multiple bits. The function returns the new
binaryNum that comes as a result of toggling the selected bits.

/**
 * Returns the new number as a result of toggling the selected bits
 * @param {number} binaryNum - The number to query from
 * @param {number} mask - This is the bitmask that selects the bits to be toggled
 * @returns {number} - New number as a result of toggling the selected bits
 */
function toggleBits(binaryNum, mask) {
	return binaryNum ^ mask;
}

We can now use these utility functions with the previous examples.

const config = {
	isOnline:          true,
	isFullscreen:      false,
	hasAudio:          true,
	hasPremiumAccount: false,
	canSendTelemetry:  true
};
let configNumber = 0b10101;

// Extracts hasPremiumAccount
getBits(configNumber, 1 << 1); // false
getBitsFrom(configNumber, 1); // false

// Toggles isOnline and isFullscreen
toggleBits(configNumber, (1 << 4) + (1 << 3)); // 0b01101 === 13

Conclusion: Why should I even bother with bitmasking?
That's a very good question. Frankly, I wouldn't recommend using this regularly, if at all. As clever as it
is, it is just too esoteric for common use. It is impractical and unreadable most of the time. Constant
documentation and awareness are required to make sure that the correct bits are being selected and
manipulated. Overall, there aren't many applications for this, especially in a high-level language like
JavaScript. However, that shouldn't discourage you from using it if the need arises. It is our job as
programmers to determine which algorithms are the best for both the user (for usability) and the developer
(for maintainability).

If that is so, then what is the point of me writing an entire article about this?

- This is for the hardcore computer scientists out there. They are the ones who will benefit the most from
  this article, especially those who are just beginning to dive deeper into the weird world of computer
  science. To put it more generally, one does not need to be a computer scientist to benefit from this
  article. Whoever is interested in such topics will see the value in all of this bitmasking chaos.
- For those who are not into computer science, you now have more tools under your belt. You can use bitmasks
  in the future if the time calls for it. I hope this article encourages you to think creatively.
  Over-engineering is a curse we all suffer eventually. It isn't entirely a bad thing, though.
  Over-engineering is just a negative connotation for thinking (too) creatively. Our brains tend to explore
  ideas even if it's impractical. Of course, we have to avoid it for productivity, but a little exploration
  now and then is always healthy. Get that brain working, and that brain would work for you.
- As for me, I wrote this article to test myself. I wanted to know how much I've learned so far. Besides that,
  I find pleasure in teaching others. One can learn so much by teaching others. This is the primary reason why
  I write articles for this site. It just has its rewards, you know? If you aren't already, go ahead and try
  to teach someone something new. It might surprise you to see how much it can help you as well.

Bitmask responsibly.


---
https://www.learncpp.com/cpp-tutorial/bit-manipulation-with-bitwise-operators-and-bit-masks/?utm_content=cmp-true

Bit manipulation with bitwise operators and bit masks
September 8, 2015

   In the previous lesson on bitwise operators ([**2] Bitwise operators), we discussed how the
   various bitwise operators apply logical operators to each bit within the operands. Now that we
   understand how they function, let's take a look at how they're more commonly used.

   Bit masks
   In order to manipulate individual bits (e.g. turn them on or off), we need some way to identify the
   specific bits we want to manipulate. Unfortunately, the bitwise operators don't know how to work with
   bit positions. Instead they work with bit masks.

   A bit mask is a predefined set of bits that is used to select which specific bits will be modified by
   subsequent operations.

   Consider a real-life case where you want to paint a window frame. If you're not careful, you risk
   painting not only the window frame, but also the glass itself. You might buy some masking tape and
   apply it to the glass and any other parts you don't want painted. Then when you paint, the masking
   tape blocks the paint from reaching anything you don't want painted. In the end, only the non-masked
   parts (the parts you want painted) get painted.

   A bit mask essentially performs the same function for bits -- the bit mask blocks the bitwise
   operators from touching bits we don't want modified, and allows access to the ones we do want
   modified.

   Let's first explore how to define some simple bit masks, and then we'll show you how to use them.

   Defining bit masks in C++14
   The simplest set of bit masks is to define one bit mask for each bit position. We use 0s to mask out
   the bits we don't care about, and 1s to denote the bits we want modified.

   Although bit masks can be literals, they're often defined as symbolic constants so they can be given
   a meaningful name and easily reused.

   Because C++14 supports binary literals, defining these bit masks is easy:
#include <cstdint>

constexpr std::uint8_t mask0{ 0b0000'0001 }; // represents bit 0
constexpr std::uint8_t mask1{ 0b0000'0010 }; // represents bit 1
constexpr std::uint8_t mask2{ 0b0000'0100 }; // represents bit 2
constexpr std::uint8_t mask3{ 0b0000'1000 }; // represents bit 3
constexpr std::uint8_t mask4{ 0b0001'0000 }; // represents bit 4
constexpr std::uint8_t mask5{ 0b0010'0000 }; // represents bit 5
constexpr std::uint8_t mask6{ 0b0100'0000 }; // represents bit 6
constexpr std::uint8_t mask7{ 0b1000'0000 }; // represents bit 7

   Now we have a set of symbolic constants that represents each bit position. We can use these to
   manipulate the bits (which we'll show how to do in just a moment).

   Defining bit masks in C++11 or earlier

   Because C++11 doesn't support binary literals, we have to use other methods to set the symbolic
   constants. There are two good methods for doing this.

   The first method is to use hexadecimal literals.

   Related content

   We talk about hexadecimal in lesson 5.2 -- Literals.

   Here's how hexadecimal converts to binary:

   Hexadecimal 0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
   Binary      0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111

   Therefore, we can define bit masks using hexadecimal like this:
constexpr std::uint8_t mask0{ 0x01 }; // hex for 0000 0001
constexpr std::uint8_t mask1{ 0x02 }; // hex for 0000 0010
constexpr std::uint8_t mask2{ 0x04 }; // hex for 0000 0100
constexpr std::uint8_t mask3{ 0x08 }; // hex for 0000 1000
constexpr std::uint8_t mask4{ 0x10 }; // hex for 0001 0000
constexpr std::uint8_t mask5{ 0x20 }; // hex for 0010 0000
constexpr std::uint8_t mask6{ 0x40 }; // hex for 0100 0000
constexpr std::uint8_t mask7{ 0x80 }; // hex for 1000 0000

   Sometimes leading hexadecimal 0s will be omitted (e.g. instead of 0x01 you'll just see 0x1). Either
   way, this can be a little hard to read if you're not familiar with hexadecimal to binary conversion.

   An easier method is to use the left-shift operator to shift a single bit into the proper location:
constexpr std::uint8_t mask0{ 1 << 0 }; // 0000 0001
constexpr std::uint8_t mask1{ 1 << 1 }; // 0000 0010
constexpr std::uint8_t mask2{ 1 << 2 }; // 0000 0100
constexpr std::uint8_t mask3{ 1 << 3 }; // 0000 1000
constexpr std::uint8_t mask4{ 1 << 4 }; // 0001 0000
constexpr std::uint8_t mask5{ 1 << 5 }; // 0010 0000
constexpr std::uint8_t mask6{ 1 << 6 }; // 0100 0000
constexpr std::uint8_t mask7{ 1 << 7 }; // 1000 0000

   Testing a bit (to see if it is on or off)

   Now that we have a set of bit masks, we can use these in conjunction with a bit flag variable to
   manipulate our bit flags.

   To determine if a bit is on or off, we use bitwise AND in conjunction with the bit mask for the
   appropriate bit:
#include <cstdint>
#include <iostream>

int main() {
	[[maybe_unused]] constexpr std::uint8_t mask0{ 0b0000'0001 }; // represents bit 0
	[[maybe_unused]] constexpr std::uint8_t mask1{ 0b0000'0010 }; // represents bit 1
	[[maybe_unused]] constexpr std::uint8_t mask2{ 0b0000'0100 }; // represents bit 2
	[[maybe_unused]] constexpr std::uint8_t mask3{ 0b0000'1000 }; // represents bit 3
	[[maybe_unused]] constexpr std::uint8_t mask4{ 0b0001'0000 }; // represents bit 4
	[[maybe_unused]] constexpr std::uint8_t mask5{ 0b0010'0000 }; // represents bit 5
	[[maybe_unused]] constexpr std::uint8_t mask6{ 0b0100'0000 }; // represents bit 6
	[[maybe_unused]] constexpr std::uint8_t mask7{ 0b1000'0000 }; // represents bit 7

	std::uint8_t flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags

	std::cout << "bit 0 is " << (static_cast<bool>(flags & mask0) ? "on\n" : "off\n");
	std::cout << "bit 1 is " << (static_cast<bool>(flags & mask1) ? "on\n" : "off\n");

	return 0;
}

   This prints:
bit 0 is on
bit 1 is off

   Let's examine how this works.

   In the case of flags & mask0, we have 0000'0101 & 0000'0001. Let's line these up:
0000'0101 &
0000'0001
---------
0000'0001

   We are then casting 0000'0001 to a bool. Since any non-zero number converts to true and this value
   has a non-zero digit, this evaluates to true.

   In the case of flags & mask1, we have 0000'0101 & 0000'0010. Let's line these up:
0000'0101 &
0000'0010
---------
0000'0000

   Since a zero value converts to false and this value has only zero digits, this evaluates to false.

   Setting a bit
   To set (turn on) a bit (to value 1), we use bitwise OR equals (operator |=) in conjunction with the
   bit mask for the appropriate bit:

#include <cstdint>
#include <iostream>

int main() {
	[[maybe_unused]] constexpr std::uint8_t mask0{ 0b0000'0001 }; // represents bit 0
	[[maybe_unused]] constexpr std::uint8_t mask1{ 0b0000'0010 }; // represents bit 1
	[[maybe_unused]] constexpr std::uint8_t mask2{ 0b0000'0100 }; // represents bit 2
	[[maybe_unused]] constexpr std::uint8_t mask3{ 0b0000'1000 }; // represents bit 3
	[[maybe_unused]] constexpr std::uint8_t mask4{ 0b0001'0000 }; // represents bit 4
	[[maybe_unused]] constexpr std::uint8_t mask5{ 0b0010'0000 }; // represents bit 5
	[[maybe_unused]] constexpr std::uint8_t mask6{ 0b0100'0000 }; // represents bit 6
	[[maybe_unused]] constexpr std::uint8_t mask7{ 0b1000'0000 }; // represents bit 7

	std::uint8_t flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags

	std::cout << "bit 1 is " << (static_cast<bool>(flags & mask1) ? "on\n" : "off\n");

	flags |= mask1; // turn on bit 1

	std::cout << "bit 1 is " << (static_cast<bool>(flags & mask1) ? "on\n" : "off\n");

	return 0;
}

   This prints:
bit 1 is off
bit 1 is on

   We can also turn on multiple bits at the same time using Bitwise OR:
flags |= (mask4 | mask5); // turn bits 4 and 5 on at the same time

   Resetting a bit
   To reset (clear) a bit (to value 0), we use Bitwise AND and Bitwise NOT together:

#include <cstdint>
#include <iostream>

int main() {
	[[maybe_unused]] constexpr std::uint8_t mask0{ 0b0000'0001 }; // represents bit 0
	[[maybe_unused]] constexpr std::uint8_t mask1{ 0b0000'0010 }; // represents bit 1
	[[maybe_unused]] constexpr std::uint8_t mask2{ 0b0000'0100 }; // represents bit 2
	[[maybe_unused]] constexpr std::uint8_t mask3{ 0b0000'1000 }; // represents bit 3
	[[maybe_unused]] constexpr std::uint8_t mask4{ 0b0001'0000 }; // represents bit 4
	[[maybe_unused]] constexpr std::uint8_t mask5{ 0b0010'0000 }; // represents bit 5
	[[maybe_unused]] constexpr std::uint8_t mask6{ 0b0100'0000 }; // represents bit 6
	[[maybe_unused]] constexpr std::uint8_t mask7{ 0b1000'0000 }; // represents bit 7

	std::uint8_t flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags

	std::cout << "bit 2 is " << (static_cast<bool>(flags & mask2) ? "on\n" : "off\n");

	flags &= ~mask2; // turn off bit 2

	std::cout << "bit 2 is " << (static_cast<bool>(flags & mask2) ? "on\n" : "off\n");

	return 0;
}

   This prints:
bit 2 is on
bit 2 is off

   We can turn off multiple bits at the same time:
flags &= ~(mask4 | mask5); // turn bits 4 and 5 off at the same time

   Key insight
   Some compilers may complain about a sign conversion with this line:
flags &= ~mask2;

   Because the type of mask2 is smaller than int, operator~ causes operand mask2 to undergo integral
   promotion to type int. Then the compiler complains that we're trying to use operator&= where the left
   operand is unsigned and the right operand is signed.

   If this is the case, try the following:
flags &= static_cast<std::uint8_t>(~mask2);

   We discuss this issue in lesson O.2 -- Bitwise operators.

   Flipping a bit
   To toggle (flip) a bit state (from 0 to 1 or from 1 to 0), we use Bitwise XOR:

#include <cstdint>
#include <iostream>

int main() {
	[[maybe_unused]] constexpr std::uint8_t mask0{ 0b0000'0001 }; // represents bit 0
	[[maybe_unused]] constexpr std::uint8_t mask1{ 0b0000'0010 }; // represents bit 1
	[[maybe_unused]] constexpr std::uint8_t mask2{ 0b0000'0100 }; // represents bit 2
	[[maybe_unused]] constexpr std::uint8_t mask3{ 0b0000'1000 }; // represents bit 3
	[[maybe_unused]] constexpr std::uint8_t mask4{ 0b0001'0000 }; // represents bit 4
	[[maybe_unused]] constexpr std::uint8_t mask5{ 0b0010'0000 }; // represents bit 5
	[[maybe_unused]] constexpr std::uint8_t mask6{ 0b0100'0000 }; // represents bit 6
	[[maybe_unused]] constexpr std::uint8_t mask7{ 0b1000'0000 }; // represents bit 7

	std::uint8_t flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags

	std::cout << "bit 2 is " << (static_cast<bool>(flags & mask2) ? "on\n" : "off\n");
	flags ^= mask2; // flip bit 2
	std::cout << "bit 2 is " << (static_cast<bool>(flags & mask2) ? "on\n" : "off\n");
	flags ^= mask2; // flip bit 2
	std::cout << "bit 2 is " << (static_cast<bool>(flags & mask2) ? "on\n" : "off\n");

	return 0;
}

   This prints:
bit 2 is on
bit 2 is off
bit 2 is on

   We can flip multiple bits simultaneously:
flags ^= (mask4 | mask5); // flip bits 4 and 5 at the same time

   Bit masks and std::bitset
   std::bitset supports the full set of bitwise operators. So even though it's easier to use the
   functions (test, set, reset, and flip) to modify individual bits, you can use bitwise operators and
   bit masks if you want.

   Why would you want to? The functions only allow you to modify individual bits. The bitwise operators
   allow you to modify multiple bits at once.

#include <bitset>
#include <iostream>

int main() {
	[[maybe_unused]] constexpr std::bitset<8> mask0{ 0b0000'0001 }; // represents bit 0
	[[maybe_unused]] constexpr std::bitset<8> mask1{ 0b0000'0010 }; // represents bit 1
	[[maybe_unused]] constexpr std::bitset<8> mask2{ 0b0000'0100 }; // represents bit 2
	[[maybe_unused]] constexpr std::bitset<8> mask3{ 0b0000'1000 }; // represents bit 3
	[[maybe_unused]] constexpr std::bitset<8> mask4{ 0b0001'0000 }; // represents bit 4
	[[maybe_unused]] constexpr std::bitset<8> mask5{ 0b0010'0000 }; // represents bit 5
	[[maybe_unused]] constexpr std::bitset<8> mask6{ 0b0100'0000 }; // represents bit 6
	[[maybe_unused]] constexpr std::bitset<8> mask7{ 0b1000'0000 }; // represents bit 7

	std::bitset<8> flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags
	std::cout << "bit 1 is " << (flags.test(1) ? "on\n" : "off\n");
	std::cout << "bit 2 is " << (flags.test(2) ? "on\n" : "off\n");

	flags ^= (mask1 | mask2); // flip bits 1 and 2
	std::cout << "bit 1 is " << (flags.test(1) ? "on\n" : "off\n");
	std::cout << "bit 2 is " << (flags.test(2) ? "on\n" : "off\n");

	flags |= (mask1 | mask2); // turn bits 1 and 2 on
	std::cout << "bit 1 is " << (flags.test(1) ? "on\n" : "off\n");
	std::cout << "bit 2 is " << (flags.test(2) ? "on\n" : "off\n");

	flags &= ~(mask1 | mask2); // turn bits 1 and 2 off
	std::cout << "bit 1 is " << (flags.test(1) ? "on\n" : "off\n");
	std::cout << "bit 2 is " << (flags.test(2) ? "on\n" : "off\n");

	return 0;
}

   This prints:
bit 1 is off
bit 2 is on
bit 1 is on
bit 2 is off
bit 1 is on
bit 2 is on
bit 1 is off
bit 2 is off

   Making bit masks meaningful
   Naming our bit masks "mask1" or "mask2" tells us what bit is being manipulated, but doesn't give us
   any indication of what that bit flag is actually being used for.

   A best practice is to give your bit masks useful names as a way to document the meaning of your bit
   flags. Here's an example from a game we might write:

#include <cstdint>
#include <iostream>

int main() {
	// Define a bunch of physical/emotional states
	[[maybe_unused]] constexpr std::uint8_t isHungry   { 1 << 0 }; // 0000 0001
	[[maybe_unused]] constexpr std::uint8_t isSad      { 1 << 1 }; // 0000 0010
	[[maybe_unused]] constexpr std::uint8_t isMad      { 1 << 2 }; // 0000 0100
	[[maybe_unused]] constexpr std::uint8_t isHappy    { 1 << 3 }; // 0000 1000
	[[maybe_unused]] constexpr std::uint8_t isLaughing { 1 << 4 }; // 0001 0000
	[[maybe_unused]] constexpr std::uint8_t isAsleep   { 1 << 5 }; // 0010 0000
	[[maybe_unused]] constexpr std::uint8_t isDead     { 1 << 6 }; // 0100 0000
	[[maybe_unused]] constexpr std::uint8_t isCrying   { 1 << 7 }; // 1000 0000

	std::uint8_t me{}; // all flags/options turned off to start
	me |= (isHappy | isLaughing); // I am happy and laughing
	me &= ~isLaughing; // I am no longer laughing

	// Query a few states
	// (we'll use static_cast<bool> to interpret the results as a boolean value)
	std::cout << std::boolalpha; // print true or false instead of 1 or 0
	std::cout << "I am happy? " << static_cast<bool>(me & isHappy) << '\n';
	std::cout << "I am laughing? " << static_cast<bool>(me & isLaughing) << '\n';

	return 0;
}

   Here's the same example implemented using std::bitset:

#include <bitset>
#include <iostream>

int main() {
	// Define a bunch of physical/emotional states
	[[maybe_unused]] constexpr std::bitset<8> isHungry   { 0b0000'0001 };
	[[maybe_unused]] constexpr std::bitset<8> isSad      { 0b0000'0010 };
	[[maybe_unused]] constexpr std::bitset<8> isMad      { 0b0000'0100 };
	[[maybe_unused]] constexpr std::bitset<8> isHappy    { 0b0000'1000 };
	[[maybe_unused]] constexpr std::bitset<8> isLaughing { 0b0001'0000 };
	[[maybe_unused]] constexpr std::bitset<8> isAsleep   { 0b0010'0000 };
	[[maybe_unused]] constexpr std::bitset<8> isDead     { 0b0100'0000 };
	[[maybe_unused]] constexpr std::bitset<8> isCrying   { 0b1000'0000 };


	std::bitset<8> me{}; // all flags/options turned off to start
	me |= (isHappy | isLaughing); // I am happy and laughing
	me &= ~isLaughing; // I am no longer laughing

	// Query a few states (we use the any() function to see if any bits remain set)
	std::cout << std::boolalpha; // print true or false instead of 1 or 0
	std::cout << "I am happy? " << (me & isHappy).any() << '\n';
	std::cout << "I am laughing? " << (me & isLaughing).any() << '\n';

	return 0;
}

   Two notes here: First, std::bitset doesn't have a nice function that allows you to query bits using a
   bit mask. So if you want to use bit masks rather than positional indexes, you'll have to use Bitwise
   AND to query bits. Second, we make use of the any() function, which returns true if any bits are set,
   and false otherwise to see if the bit we queried remains on or off.

   When are bit flags most useful?
   Astute readers may note that the above examples don't actually save any memory. 8 separate booleans
   values would normally take 8 bytes. But the examples above (using std::uint8_t) use 9 bytes -- 8
   bytes to define the bit masks, and 1 byte for the flag variable!

   Bit flags make the most sense when you have many identical flag variables. For example, in the
   example above, imagine that instead of having one person (me), you had 100. If you used 8 Booleans
   per person (one for each possible state), you'd use 800 bytes of memory. With bit flags, you'd use 8
   bytes for the bit masks, and 100 bytes for the bit flag variables, for a total of 108 bytes of memory
   -- approximately 8 times less memory.

   For most programs, the amount of memory saved using bit flags is not worth the added complexity. But
   in programs where there are tens of thousands or even millions of similar objects, using bit flags
   can reduce memory use substantially. It's a useful optimization to have in your toolkit if you need
   it.

   There's another case where bit flags and bit masks can make sense. Imagine you had a function that
   could take any combination of 32 different options. One way to write that function would be to use 32
   individual Boolean parameters:
void someFunction(bool option1, bool option2, bool option3, bool option4, bool option5, bool option6, \
bool option7, bool option8, bool option9, bool option10, bool option11, bool option12, bool option13, bool \
option14, bool option15, bool option16, bool option17, bool option18, bool option19, bool option20, bool \
option21, bool option22, bool option23, bool option24, bool option25, bool option26, bool option27, bool \
option28, bool option29, bool option30, bool option31, bool option32);

   Hopefully you'd give your parameters more descriptive names, but the point here is to show you how
   obnoxiously long the parameter list is.

   Then when you wanted to call the function with options 10 and 32 set to true, you'd have to do so
   like this:
someFunction(false, false, false, false, false, false, false, false, false, true, false, false, false, false, \
false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, \
false, true);

   This is ridiculously difficult to read (is that option 9, 10, or 11 that's set to true?), and also
   means you have to remember which argument corresponds to which option (is setting the "edit flag" the
   9th, 10th, or 11th parameter?).

   Instead, if you defined the function using bit flags like this:
void someFunction(std::bitset<32> options);

   Then you could use bit flags to pass in only the options you wanted:
someFunction(option10 | option32);

   This is much more readable.

   This is one of the reasons OpenGL, a well regarded 3d graphic library, opted to use bit flag
   parameters instead of many consecutive Boolean parameters.

   Here's a sample function call from OpenGL:
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the color and the depth buffer

   GL_COLOR_BUFFER_BIT and GL_DEPTH_BUFFER_BIT are bit masks defined as follows (in gl2.h):
#define GL_DEPTH_BUFFER_BIT               0x00000100
#define GL_STENCIL_BUFFER_BIT             0x00000400
#define GL_COLOR_BUFFER_BIT               0x00004000

   Bit masks involving multiple bits
   Although bit masks often are used to select a single bit, they can also be used to select multiple
   bits. Lets take a look at a slightly more complicated example where we do this.

   Color display devices such as TVs and monitors are composed of millions of pixels, each of which can
   display a dot of color. Each dot of color is the result of combining three beams of light: one red,
   one green, and one blue (RGB). The intensity of these lights are varied to produce different colors.

   Typically, the intensity of R, G, and B for a given pixel is represented by an 8-bit unsigned
   integer. For example, a red pixel would have R=255, G=0, B=0. A purple pixel would have R=255, G=0,
   B=255. A medium-grey pixel would have R=127, G=127, B=127.

   When assigning color values to a pixel, in addition to R, G, and B, a 4th value called A is often
   used. "A" stands for "alpha", and it controls how transparent the color is. If A=0, the color is
   fully transparent. If A=255, the color is opaque.

   R, G, B, and A are normally stored as a single 32-bit integer, with 8 bits used for each component:

   32-bit RGBA value
   bits 31-24 bits 23-16 bits 15-8 bits 7-0
   RRRRRRRR   GGGGGGGG   BBBBBBBB  AAAAAAAA
   red        green      blue      alpha

   The following program asks the user to enter a 32-bit hexadecimal value, and then extracts the 8-bit
   color values for R, G, B, and A.

#include <cstdint>
#include <iostream>

int main() {
	constexpr std::uint32_t redBits{ 0xFF000000 };
	constexpr std::uint32_t greenBits{ 0x00FF0000 };
	constexpr std::uint32_t blueBits{ 0x0000FF00 };
	constexpr std::uint32_t alphaBits{ 0x000000FF };

	std::cout << "Enter a 32-bit RGBA color value in hexadecimal (e.g. FF7F3300): ";
	std::uint32_t pixel{};
	std::cin >> std::hex >> pixel; // std::hex allows us to read in a hex value

	// use Bitwise AND to isolate the pixels for our given color,
	// then right shift the value into the lower 8 bits
	const std::uint8_t red{ static_cast<std::uint8_t>((pixel & redBits) >> 24) };
	const std::uint8_t green{ static_cast<std::uint8_t>((pixel & greenBits) >> 16) };
	const std::uint8_t blue{ static_cast<std::uint8_t>((pixel & blueBits) >> 8) };
	const std::uint8_t alpha{ static_cast<std::uint8_t>(pixel & alphaBits) };

	std::cout << "Your color contains:\n";
	std::cout << std::hex; // print the following values in hex

	// reminder: std::uint8_t will likely print as a char
	// we static_cast to int to ensure it prints as an integer
	std::cout << static_cast<int>(red)   << " red\n";
	std::cout << static_cast<int>(green) << " green\n";
	std::cout << static_cast<int>(blue)  << " blue\n";
	std::cout << static_cast<int>(alpha) << " alpha\n";

	return 0;
}

   This produces the output:
Enter a 32-bit RGBA color value in hexadecimal (e.g. FF7F3300): FF7F3300
Your color contains:
ff red
7f green
33 blue
0 alpha

   In the above program, we use a bitwise AND to query the set of 8 bits we're interested in, and then
   we right shift them into an 8-bit value so we can print them back as hex values.

   Summary
   Summarizing how to set, clear, toggle, and query bit flags:

   To query bit states, we use bitwise AND:
if (flags & option4) ... // if option4 is set, do something

   To set bits (turn on), we use bitwise OR:
flags |= option4; // turn option 4 on.
flags |= (option4 | option5); // turn options 4 and 5 on.

   To clear bits (turn off), we use bitwise AND with bitwise NOT:
flags &= ~option4; // turn option 4 off
flags &= ~(option4 | option5); // turn options 4 and 5 off

   To flip bit states, we use bitwise XOR:
flags ^= option4; // flip option4 from on to off, or vice versa
flags ^= (option4 | option5); // flip options 4 and 5


---
[**2]
https://www.learncpp.com/cpp-tutorial/bitwise-operators/

Bitwise operators
June 17, 2007

   The bitwise operators
   C++ provides 6 bit manipulation operators, often called bitwise operators:

   ----------------------------------------------------------------------
   Operator      Symbol    Form        Operation
   ----------------------------------------------------------------------
   left shift    <<        x << y      all bits in x shifted left y bits
   right shift   >>        x >> y      all bits in x shifted right y bits
   bitwise NOT   ~         ~x          all bits in x flipped
   bitwise AND   &         x & y       each bit in x AND each bit in y
   bitwise OR    |         x | y       each bit in x OR each bit in y
   bitwise XOR   ^         x ^ y       each bit in x XOR each bit in y
   ----------------------------------------------------------------------

   Author's note
   In the following examples, we will largely be working with 4-bit binary values. This is for the sake
   of convenience and keeping the examples simple. In actual programs, the number of bits used is based
   on the size of the object (e.g. a 2 byte object would store 16 bits).

   For readability, we'll also omit the 0b prefix outside of code examples (e.g. instead of 0b0101,
   we'll just use 0101).

   The bitwise operators are defined for integral types and std::bitset. We'll use std::bitset in our
   examples because it's easier to print the output in binary.

   Avoid using the bitwise operators with signed operands, as many operators will return
   implementation-defined results prior to C++20 or have other potential gotchas that are easily avoided
   by using unsigned operands (or std::bitset).

   Best practice
   To avoid surprises, use the bitwise operators with unsigned operands or std::bitset.

   Bitwise left shift (<<) and bitwise right shift (>>) operators

   The bitwise left shift (<<) operator shifts bits to the left. The left operand is the expression to
   shift the bits of, and the right operand is an integer number of bits to shift left by.

   So when we say x << 1, we are saying "shift the bits in the variable x left by 1 place". New bits
   shifted in from the right side receive the value 0.

   0011 << 1 is 0110
   0011 << 2 is 1100
   0011 << 3 is 1000

   Note that in the third case, we shifted a bit off the end of the number! Bits that are shifted off
   the end of the binary number are lost forever.

   The bitwise right shift (>>) operator shifts bits to the right.

   1100 >> 1 is 0110
   1100 >> 2 is 0011
   1100 >> 3 is 0001

   Note that in the third case we shifted a bit off the right end of the number, so it is lost.

   Here's an example of doing some bit shifting:

#include <bitset>
#include <iostream>

int main() {
	std::bitset<4> x { 0b1100 };

	std::cout << x << '\n';
	std::cout << (x >> 1) << '\n'; // shift right by 1, yielding 0110
	std::cout << (x << 1) << '\n'; // shift left by 1, yielding 1000

	return 0;
}

   This prints:
1100
0110
1000

   For advanced readers
   Bit-shifting in C++ is endian-agnostic. Left-shift is always towards the most significant bit,
   and right-shift towards the least significant bit.

   What!? Aren't operator<< and operator>> used for input and output?

   They sure are.

   Programs today typically do not make much use of the bitwise left and right shift operators to shift
   bits. Rather, you tend to see the bitwise left shift operator used with std::cout (or other stream
   objects) to output text. Consider the following program:

#include <bitset>
#include <iostream>

int main() {
	unsigned int x { 0b0100 };
	x = x << 1; // use operator<< for left shift
	std::cout << std::bitset<4>{ x } << '\n'; // use operator<< for output

	return 0;
}

   This program prints:
1000

   In the above program, how does operator<< know to shift bits in one case and output x in another
   case? The answer is that std::cout has overloaded (provided an alternate definition for) operator<<
   that does console output rather than bit shifting.

   When the compiler sees that the left operand of operator<< is std::cout, it knows that it should call
   the version of operator<< that std::cout overloaded to do output. If the left operand is an integral
   type, then operator<< knows it should do its usual bit-shifting behavior.

   The same applies for operator >>.

   Note that if you're using operator << for both output and left shift, parenthesization is required:

#include <bitset>
#include <iostream>

int main() {
	std::bitset<4> x{ 0b0110 };

	std::cout << x << 1 << '\n'; // print value of x (0110), then 1
	std::cout << (x << 1) << '\n'; // print x left shifted by 1 (1100)

	return 0;
}

   This prints:
01101
1100

   The first line prints the value of x (0110), and then the literal 1. The second line prints the value
   of x left-shifted by 1 (1100).

   We will talk more about operator overloading in a future chapter, including discussion of how to
   overload operators for your own purposes.

   Bitwise NOT
   The bitwise NOT operator (~) is perhaps the easiest to understand of all the bitwise operators. It
   simply flips each bit from a 0 to a 1, or vice versa. Note that the result of a bitwise NOT is
   dependent on what size your data type is.

   Flipping 4 bits:
   ~0100 is 1011

   Flipping 8 bits:
   ~0000 0100 is 1111 1011

   In both the 4-bit and 8-bit cases, we start with the same number (binary 0100 is the same as 0000
   0100 in the same way that decimal 7 is the same as 07), but we end up with a different result.

   We can see this in action in the following program:

#include <bitset>
#include <iostream>

int main() {
	std::cout << ~std::bitset<4>{ 0b0100 } << ' ' << ~std::bitset<8>{ 0b0100 } << '\n';

	return 0;
}

   This prints:
   1011 11111011

   Bitwise OR
   Bitwise OR (|) works much like its logical OR counterpart. However, instead of applying the OR to the
   operands to produce a single result, bitwise OR applies to each bit! For example, consider the
   expression 0b0101 | 0b0110.

   To do (any) bitwise operations, it is easiest to line the two operands up like this:
0 1 0 1 OR
0 1 1 0

   and then apply the operation to each column of bits.

   If you remember, logical OR evaluates to true (1) if either the left, right, or both operands are
   true (1), and 0 otherwise. Bitwise OR evaluates to 1 if either the left, right, or both bits are 1,
   and 0 otherwise. Consequently, the expression evaluates like this:
0 1 0 1 OR
0 1 1 0
-------
0 1 1 1

   Our result is 0111 binary.

#include <bitset>
#include <iostream>

int main() {
	std::cout << (std::bitset<4>{ 0b0101 } | std::bitset<4>{ 0b0110 }) << '\n';

	return 0;
}

   This prints:
0111

   We can do the same thing to compound OR expressions, such as 0b0111 | 0b0011 | 0b0001. If any of the
   bits in a column are 1, the result of that column is 1.

0 1 1 1 OR
0 0 1 1 OR
0 0 0 1
--------
0 1 1 1

   Here's code for the above:

#include <bitset>
#include <iostream>

int main() {
	std::cout << (std::bitset<4>{ 0b0111 } | std::bitset<4>{ 0b0011 } | std::bitset<4>{ 0b0001 }) << '\n';

	return 0;
}

   This prints:
0111

   Bitwise AND
   Bitwise AND (&) works similarly to the above. Logical AND evaluates to true if both the left and
   right operand evaluate to true. Bitwise AND evaluates to true (1) if both bits in the column are 1.
   Consider the expression 0b0101 & 0b0110. Lining each of the bits up and applying an AND operation to
   each column of bits:

0 1 0 1 AND
0 1 1 0
--------
0 1 0 0

#include <bitset>
#include <iostream>

int main() {
	std::cout << (std::bitset<4>{ 0b0101 } & std::bitset<4>{ 0b0110 }) << '\n';

	return 0;
}

   This prints:
0100

   Similarly, we can do the same thing to compound AND expressions, such as 0b0001 & 0b0011 & 0b0111. If
   all of the bits in a column are 1, the result of that column is 1.
0 0 0 1 AND
0 0 1 1 AND
0 1 1 1
--------
0 0 0 1

#include <bitset>
#include <iostream>

int main() {
	std::cout << (std::bitset<4>{ 0b0001 } & std::bitset<4>{ 0b0011 } & std::bitset<4>{ 0b0111 }) << '\n';

	return 0;
}

   This prints:
0001

   Bitwise XOR
   The last operator is the bitwise XOR (^), also known as exclusive or.

   When evaluating two operands, XOR evaluates to true (1) if one and only one of its operands is true
   (1). If neither or both are true, it evaluates to 0. Consider the expression 0b0110 ^ 0b0011:

0 1 1 0 XOR
0 0 1 1
-------
0 1 0 1

   It is also possible to evaluate compound XOR expression column style, such as 0b0001 ^ 0b0011 ^
   0b0111. If there are an even number of 1 bits in a column, the result is 0. If there are an odd
   number of 1 bits in a column, the result is 1.

0 0 0 1 XOR
0 0 1 1 XOR
0 1 1 1
--------
0 1 0 1

   Bitwise assignment operators
   Similar to the arithmetic assignment operators, C++ provides bitwise assignment operators in order to
   facilitate easy modification of variables.

   -----------------------------------------------------------------------
   Operator                 Symbol   Form          Operation
   -----------------------------------------------------------------------
   Left shift assignment    <<=      x <<= y       Shift x left by y bits
   Right shift assignment   >>=      x >>= y       Shift x right by y bits
   Bitwise OR assignment    |=       x |= y        Assign x | y to x
   Bitwise AND assignment   &=       x &= y        Assign x & y to x
   Bitwise XOR assignment   ^=       x ^= y        Assign x ^ y to x
   -----------------------------------------------------------------------

   For example, instead of writing x = x >> 1;, you can write x >>= 1;.

#include <bitset>
#include <iostream>

int main() {
	std::bitset<4> bits { 0b0100 };
	bits >>= 1;
	std::cout << bits << '\n';

	return 0;
}

   This program prints:
0010

   As an aside...
   There is no bitwise NOT assignment operator. This is because the other bitwise operators are binary,
   but bitwise NOT is unary (so what would go on the right-hand side of a ~= operator?). If you want to
   flip all of the bits, you can use normal assignment here: x = ~x;

   Bitwise operators perform integral promotion on smaller integral types Advanced

   If the operand(s) of a bitwise operator are an integral type smaller than an int, those operands will
   be promoted (converted) to int or unsigned int, and the result returned will also be an int or
   unsigned int. For example, if our operands are unsigned short, they will be promoted (converted) to
   unsigned int, and the result of the operation will be returned as an unsigned int.

   In many cases, this won't matter.

   However, when using bitwise operators on integral types narrower than int or unsigned int, there are
   two cases to watch out for:
     * operator~ and operator<< are width-sensitive and may produce different results depending on the
       width of the operand.
     * Initializing or assigning the result to a variable of the smaller integral type is a narrowing
       conversion (since converting an int or unsigned int to a smaller integral type may result in data
       loss). This is disallowed in list initialization, and your compiler may or may not complain about
       a narrowing assignment.

   The following program exhibits these issues (assuming 32-bit ints):
#include <bitset>
#include <cstdint>
#include <iostream>

int main() {
	std::uint8_t c { 0b00001111 };

	std::cout << std::bitset<32>(~c) << '\n';     // incorrect: prints 11111111111111111111111111110000
	std::cout << std::bitset<32>(c << 6) << '\n'; // incorrect: prints 0000000000000000001111000000
	std::uint8_t cneg { ~c };                     // error: narrowing conversion from unsigned int to std::uin
	t8_t
	c = ~c;                                       // possible warning: narrowing conversion from unsigned int
	to std::uint8_t

	return 0;
}

   These issues can be addressed by using static_cast to convert the result of your bitwise operation
   back to the narrower integral type. The following program produces the correct results:

#include <bitset>
#include <cstdint>
#include <iostream>

int main() {
	std::uint8_t c { 0b00001111 };

	std::cout << std::bitset<32>(static_cast<std::uint8_t>(~c)) << '\n';     // correct: prints 00000000000000
	000000000011110000
	std::cout << std::bitset<32>(static_cast<std::uint8_t>(c << 6)) << '\n'; // correct: prints 00000000000000
	00000011000000
	std::uint8_t cneg { static_cast<std::uint8_t>(~c) };                     // compiles
	c = static_cast<std::uint8_t>(~c);                                       // no warning

	return 0;
}

   Warning
   Bitwise operators will promote operands with narrower integral types to int or unsigned int.

   operator~ and operator<< are width-sensitive and may produce different results depending on the width
   of the operand.

   static_cast the result of such bitwise operations back to the narrower integral type before using to
   ensure correct results.

   Summary
   Summarizing how to evaluate bitwise operations utilizing the column method:
   When evaluating bitwise OR, if any bit in a column is 1, the result for that column is 1.
   When evaluating bitwise AND, if all bits in a column are 1, the result for that column is 1.
   When evaluating bitwise XOR, if there are an odd number of 1 bits in a column, the result for that
   column is 1.

   In the next lesson, we'll explore how these operators can be used in conjunction with bit masks to
   facilitate bit manipulation.


---
https://jameshfisher.com/2017/01/02/c-bitfields-masks/

How do I pack bits in C? (An answer using masks)

   An exercise in packing information into bits instead of bytes.
#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>

// Consider this struct
struct player_inefficient {
	bool is_male;
	bool is_cpu;
	int num_lives;  // out of 3
	int points; // in range 0-1000
};

// The information in this struct is packed inefficiently:
//
// - the booleans are only a single bit of information, not 8.
// - the num_lives only requires 2 bits.
// - the points only requires 10 bits.
//
// The player only requires 14 bits, but our compiler stores it in 96 bits!
// Let's pack the information more efficiently. It can all fit in 16 bits:

// Let's number our bits from 0 to 15:
//
//      1 1 1 1 1 1
//      5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     |        points         | L |M|C|
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     |       1       |       0       | bytes

typedef uint16_t player;

#define BIT(N) (1 << (N))
#define ANY_SET(F,B) ((F) & (B))
#define GET_BIT(F,N) ANY_SET((F), BIT(N))
#define SET_BITS(F,B) ((F) | (B))
#define UNSET_BITS(F,B) ((F) & ~(B))
#define N_BITS(N) (BIT(N)-1)
#define GET_N_BITS(F,N) ((F) & N_BITS(N))
#define N_BITS_ABOVE_OFFSET(N,O) (N_BITS(N) << (O))
#define GET_N_BITS_ABOVE_OFFSET(F,N,O) (((F) >> (O)) & N_BITS(N))
#define UNSET_N_BITS_ABOVE_OFFSET(F,N,O) UNSET_BITS((F), N_BITS_ABOVE_OFFSET((N),(O)))
#define SET_N_BITS_ABOVE_OFFSET(F,N,O,B) SET_BITS(UNSET_N_BITS_ABOVE_OFFSET((F),(N),(O)), (B) << (O))
#define GET_ALL_BITS_ABOVE_OFFSET(F,O) ((F) >> (O))
#define SET_ALL_BITS_ABOVE_OFFSET(F,O,B) (((B) << (O)) | GET_N_BITS((F), (O)))

// Our booleans are represented by bits 0 and 1.
#define player_IS_MALE BIT(0)
#define player_IS_CPU  BIT(1)

bool player_is_male(player p) { return GET_BIT(p, 0); }
player player_set_male(player p, bool is_male) {
	return is_male ? SET_BITS(p, BIT(0)) : UNSET_BITS(p, BIT(0));
}

bool player_is_cpu(player p)  { return GET_BIT(p, 1); }
player player_set_cpu(player p, bool is_cpu) {
	return is_cpu ? SET_BITS(p, BIT(1)) : UNSET_BITS(p, BIT(1));
}

// The num_lives is represented by bits 2 and 3.

unsigned char player_get_lives(player p) {
	return GET_N_BITS_ABOVE_OFFSET(p, 2, 2);
}

player player_set_lives(player p, unsigned char num_lives) {
	return SET_N_BITS_ABOVE_OFFSET(p, 2, 2, num_lives);
}

unsigned short player_get_points(player p) {
	return GET_ALL_BITS_ABOVE_OFFSET(p, 4);
}

player player_set_points(player p, unsigned short points) {
	return SET_ALL_BITS_ABOVE_OFFSET(p, 4, points);
}

int main(void) {
	printf("sizeof(struct player) = %zu (%ld bits)\n", sizeof(struct player), sizeof(struct player)*8);
	printf("sizeof(struct player) = %zu (%ld bits)\n", sizeof(struct player), sizeof(struct player)*8);

	player p = 0;
	p = player_set_male(p, true);
	p = player_set_cpu(p, false);
	p = player_set_lives(p, 2);
	p = player_set_points(p, 789);
	printf("p.is_male = %d, p.is_cpu = %d, p.num_lives = %d, p.points = %d\n", player_is_male(p), \
	player_is_cpu(p), player_get_lives(p), player_get_points(p));
	// Prints:
	//   p.is_male = 1, p.is_cpu = 0, p.num_lives = 2, p.points = 789

	return 0;
}


---
https://www.educba.com/bit-fields-in-c/

Bit fields in C

Introduction to Bit fields in C
   In C programming, bit fields emerge as a powerful feature facilitating efficient memory usage.
   They enable allocating specific numbers of bits to represent data, allowing precise control over
   storage. Unlike standard variables, bit fields can compactly structure data, conserving memory
   while enhancing code readability. By defining the number of bits each field occupies, developers gain
   granular control, optimizing storage for structures with space-sensitive requirements.

   For example, consider a structure representing configuration settings where individual bits control
   specific features. Using bit fields allows us to pack these settings into a smaller memory footprint,
   reducing overall memory usage.

   This nuanced approach to memory allocation and manipulation showcases the flexibility and precision
   that bit fields bring to C, contributing to more streamlined and resource-efficient code. However,
   it's essential to be mindful of potential trade-offs, such as increased code complexity and potential
   portability issues across different compilers and architecture.

Key Takeaways
     * Bit fields in C enable efficient memory utilization.
     * They allow precise control over individual bits within a data structure.
     * Ideal for optimizing storage in structures with space-sensitive requirements.
     * Enhance code readability by defining the number of bits each field occupies.
     * Provide a nuanced approach to memory allocation and manipulation in C programming.

   Syntax:
   In C, the syntax for defining a bit field within a structure is as follows:
struct struct_name {
	datatype var1: 1; // 1 bit field named 'var1'
	datatype var2: 2;  // 2 bit field named 'var2'
}

   For Example

#include
// Define a structure with bit fields
struct BitFieldExample {
	unsigned int var1 : 1;  // 1-bit field named 'var1'
	unsigned int var2 : 2;  // 2-bit field named 'var2'
	unsigned int var3 : 3;  // 3-bit field named 'var3'
};

int main() {
	// Declare the structure type as a variable.
	struct BitFieldExample EDUCBA;
	// Assign values to the bit fields
	EDUCBA.var1 = 1;
	EDUCBA.var2 = 2;
	EDUCBA.var3 = 5;
	// Print the values of the bit fields
	printf("var1: %u\n", EDUCBA.var1);
	printf("var2: %u\n", EDUCBA.var2);
	printf("var3: %u\n", EDUCBA.var3);
	return 0;
}

   Output:
var1: 1
var2: 2
var3: 5

   Explanation:
   The BitFieldExample structure contains three-bit fields (var1, var2, and var3), each with one, two,
   or three bits. After that, the program declares a variable of this structure type, populates the bit
   fields with values, and outputs those values.

Declaration and Initialization
   In C, declaring and initializing bit fields involves specifying their width within a structure.

   For example,
#include

// Define a structure with bit fields
struct StatusFlags {
    unsigned int errorFlag : 1;  // 1 bit for error status
    unsigned int mode : 2;        // 2 bits for operation mode
};
int main() {
// Create a structure-type variable.
    struct StatusFlags status;
    // Initialization using bit-wise operations
    status.errorFlag = 1;
    status.mode = 2;
    // Print the values of the bit fields
    printf("errorFlag: %u\n", status.errorFlag);
    printf("mode: %u\n", status.mode);

    return 0;
}

   Output
errorFlag: 1
mode: 2

   Explanation:
   The StatusFlags structure contains two-bit fields mode (two bits) and errorFlag (one bit). The
   program declares a structure type variable named "status," initializes its bit fields using bit-wise
   operations and then prints their values.

Structure Declaration

With Bit Field
   Bit fields in C provide an efficient means of compactly organizing and manipulating data within a
   structure's bit level.

   Consider a practical example:

   Code:

struct RGBColor {
	unsigned int red : 5;    // 5 bits for red intensity
	unsigned int green : 6;  // 6 bits for green intensity
	unsigned int blue : 5;   // 5 bits for blue intensity
};

struct RGBColor pixel = {31, 63, 31};  // Initializing RGB values using bit fields.

   Explanation:
   The RGBColor structure efficiently packs RGBcolor information into a compact form. Initializing the
   pixel instance with specific values for red, green, and blue intensities using the defined bit fields
   showcases the practicality of bit fields in managing structured data.

   Bit fields in C offer a streamlined approach to managing compact data structures. Consider a scenario
   using a hypothetical "SensorData" structure.

   Code:

struct SensorData {
	unsigned int temperature : 12;  // 12 bits for temperature
	unsigned int humidity : 10;     // 10 bits for humidity
	unsigned int status : 4;        // 4 bits for sensor status
};

struct SensorData sensor = {800, 500, 2};  // Initializing sensor data using bit fields.

   Explanation:
   The SensorData structure efficiently packs temperature, humidity, and status information in this
   example. The sensor instance is then initialized with specific values.

   The output demonstrates the compact representation of data, showcasing the power and precision of bit
   fields in C for managing structured information effectively.

Without Bit Field
   Data representation can become less efficient in scenarios without bit fields. For instance,

   Code:

struct DeviceStatusWithoutBitField {
	unsigned int powerOn;
	unsigned int operationMode;
	unsigned int errorCode;
};

struct DeviceStatusWithoutBitField device1 = {1, 3, 7};  // Initializing without bit fields.
struct DeviceStatusWithoutBitField device2 = {0, 2, 0};  // Another instance with different values.

   Explanation:
   In this structure, without the use of bit fields, each attribute occupies its own memory, leading to
   potential inefficiencies. The device1 instance represents a powered-on state, operating in mode 3 and
   reporting an error with code 7. Similarly, device 2 signifies a powered-off state, operating in mode
   2, with no reported errors.

   The absence of bit fields here underscores the clarity and efficiency that bit fields bring to
   compact data representation.

How Bit Fields Works?
     * Bit fields in C allocate specific bits for each variable within a structure.
     * To define a structure with bit fields, use the struct keyword.
     * A colon(:) is employed to designate each field's width or number of bits.
     * Bit fields enable efficient memory usage by packing multiple variables into a single memory
       location.
     * They streamline the manipulation of individual bits within a variable.
     * Initialization involves assigning values to each bit field, ensuring precise control over data
       representation.
     * Bit fields enhance code readability by expressing complex data structures concisely and in an
       organized fashion.
     * Operations on bit fields involve bitwise operators for efficient bit-level manipulation.

Bitwise Operation
   Bitwise operations play a pivotal role in low-level programming, providing a powerful mechanism
   for manipulating individual bits within binary data. Bitwise operations are fundamental for tasks
   like setting, clearing, and toggling specific bits, enabling intricate data manipulation at the
   binary level.
    1. AND (&) Operation: Performs a bitwise AND operation between corresponding bits, yielding 1 only
       if both bits are 1.
    2. OR (|) Operation: Executes a bitwise OR operation, producing 1 if at least one of the
       corresponding bits is 1.
    3. XOR (^) Operation: The bitwise XOR operation results in 1 if the corresponding bits are
       different, offering a means of toggling bits.
    4. NOT (~) Operation: Inverts the bits, turning 1s into 0s and vice versa, providing an unary
       bitwise complement.
    5. Left Shift (<<) and Right Shift (>>) Operations: Shift bits left or right by a specified number
       of positions, effectively multiplying or dividing by powers of 2.

Applications

   Device Register Manipulation
   In embedded systems, engineers often use microcontroller registers to control individual
   functions. Multiplying these bits, facilitated by the practical method of bit fields, provides an
   easy-to-read approach for configuring devices.

   Compression Algorithms
   Individual bits in compression algorithms can represent different encoding or compression techniques.
   Bit fields make it possible to specify different compression methods and options succinctly.

   Graphics Programming
   In graphics programming, developers can utilize bit fields to represent pixel values with specific
   color components. For instance, one could employ bit fields to independently represent the red,
   green, and blue components in a 16-bit color format.

   File Format
   Bit fields are useful in defining the structure of particular file sections when working with custom
   file formats. This is especially helpful when working with file formats that employ bit-level
   encoding for compact representation.

   Protocol Flags
   Bit fields are frequently used in communication protocols to indicate flags or options. Each bit
   offers a concise and expressive method of communicating information, which can represent a particular
   option or condition.

Practical Example
   Let's look at an actual example of configuring a register in an embedded system, namely, using C-bit
   fields for a microcontroller's GPIO (General Purpose Input/Output) port.

   Code:

#include

struct GPIOConfig {
	unsigned int mode : 2;          // 2 bits for pin mode (input, output, etc.)
	unsigned int pullUpDown : 1;    // 1 bit for pull-up/pull-down resistor
	unsigned int interruptEnable : 1; // 1 bit for interrupt enable/disable
};
void configureGPIO(struct GPIOConfig *config) {
	// Assuming there is a GPIO register in the microcontroller
	// Perform bitwise operations to set or clear individual bits based on the configuration
	printf("Configuring GPIO:\n");
	// Set or clear bits based on the configuration
	printf("Mode: %d\n", config->mode);
	printf("Pull-up/Pull-down: %s\n", config->pullUpDown ? "Enabled" : "Disabled");
	printf("Interrupt: %s\n", config->interruptEnable ? "Enabled" : "Disabled");
}
int main() {
	// Create an instance of the GPIOConfig structure
	struct GPIOConfig gpioConfig;
	// Set the configuration options
	gpioConfig.mode = 2;            // Set mode to 2 (output)
	gpioConfig.pullUpDown = 1;      // Enable pull-up resistor
	gpioConfig.interruptEnable = 0; // Disable interrupts
	configureGPIO(&gpioConfig);
	return 0;
}

   Output:
Configuring GPIO:
Mode: 2
Pull-up/Pull-down: Enabled
Interrupt: Disabled

   Explanation:
     * The GPIOConfig structure uses bit fields to represent GPIO pin configuration options.
     * Using a pointer to a GPIOConfig structure, the configureGPIO function sets or clears specific
       bits in the GPIO register bitwise in accordance with the supplied configuration.
     * Configuration options are set, and an instance of the GPIOConfig structure is created in the main
       function.
     * After that, the configured structure is passed to the configureGPIO function.

Common Use Cases
   Bit fields offer a versatile solution for compactly representing and managing information,
   contributing to more efficient algorithms and streamlined data structures.
    1. Data Compression Algorithms: Bit fields are integral to data compression algorithms where space
       optimization is critical. Huffman coding, for example, employs variable-length bit fields to
       represent different characters with shorter codes for more frequent occurrences, reducing overall
       data size. In scenarios like lossless compression, bit fields contribute to efficient storage and
       transmission of compressed data, crucial for applications with limited bandwidth.
    2. Security Flags and Permissions: Bit fields are commonly used in representing security flags and
       permissions within access control systems. Individual bits can denote permissions such as read,
       write, and execute in user authentication structures. Efficiently managing the status of features
       such as account lockout or password expiration is often done using bit fields for security flags.
       This application ensures a concise representation of access control attributes, simplifying
       security implementations and reducing memory overhead.
    3. Audio Signal Processing: In digital audio processing, developers use bit fields to represent
       various attributes of audio samples, encoding parameters such as sample precision, audio
       channels, and compression status within the audio data structure. This allows for efficient
       manipulation and processing of audio data, a crucial element in applications ranging from
       multimedia systems to telecommunications.

Benefits and Limitations
1. Benefits

   Bit fields offer several advantages in programming, enhancing efficiency and readability.
     * Memory Optimization: They allow for compact data storage by efficiently packing multiple
       variables within a single memory location, reducing memory consumption. Bit fields enable the
       efficient usage of memory by allowing the grouping of variables within a struct, minimizing
       storage and wastage. This approach is particularly helpful for handling constrained environments,
       enhancing both performance and resource utilization.
     * Code Readability: Bit fields enhance code clarity by expressing complex data structures concisely
       and organized, making the code more readable and maintainable. Careful naming conventions and
       clear documentation are essential to ensure that others can easily comprehend and maintain the
       code.
     * Precision Control: Bit fields provide precise control over individual bits, allowing developers
       to manipulate specific flags or attributes within a data structure. By specifying the width of
       each field, developers can balance memory efficiency with precise data representation.

2. Limitations
   While beneficial, bit fields come with certain limitations.
     * Portability Issues: Bit fields may exhibit different behaviors on various platforms, affecting
       code portability. The limited width of bit fields restricts the range of values they can
       represent, potentially leading to data overflow or underflow.
     * Limited Width: Architectural design constrains the width of a bit field, thereby restricting the
       range of values that can be represented as the allocated bit field is fixed. When dealing with a
       larger numerical range, this becomes a crucial constraint as there might come a potential loss of
       precision.
     * Endianness Challenges: Byte order differences (endianness) across architectures can impact the
       interpretation of bit fields, posing challenges in cross-platform development. A multibyte bit
       field may vary in memory storage depending on the system, causing inconsistencies in data
       representation.

Comparison with other Memory Optimization Techniques
--------------------------------------------------------------------------------------------------------------
Memory
Optimization     Advantages        Limitations        Suitability for Bit Fields
Techniques
--------------------------------------------------------------------------------------------------------------
                 Great control    Limited by the    Highly suitable as bit fields rely on bit
Bit Manipulation over individual   machine word size. manipulation for efficient storage and
                 bits.                                retrieval.
--------------------------------------------------------------------------------------------------------------
                 Minimizes padding May lead to        Complementary to bit fields, struct packing
Struct Packing   between structure inefficient memory optimizes the overall structure layout, while
                 members.          alignment.         bit fields provide precise bit-level control.
--------------------------------------------------------------------------------------------------------------
                 Efficient for     Requires careful   Bit masking is a fundamental technique often
Bit Masking      enabling or       management of      used in conjunction with bit fields for various
                 checking specific masks.             operations.
                 bits.
--------------------------------------------------------------------------------------------------------------
                                   May not yield
Run- Length     Effective for     significant        Complementary to bit fields when dealing with
Encoding (RLE)   compressing       benefits for       data patterns suitable for run-length encoding.
                 repetitive data.  non-repetitive
                                   data.
--------------------------------------------------------------------------------------------------------------
                 Reduces memory    Limited to certain While applicable in specific scenarios, less
Pointer Packing  overhead by       data types and     common in conjunction with bit fields due to
                 packing data      architectures.     their distinct purposes.
                 within pointers.
--------------------------------------------------------------------------------------------------------------

Best practices
   Efficient utilization of bit fields requires adherence to certain best practices to ensure code
   clarity, maintainability, and portability.
     * Document Clearly: Provide comprehensive comments to document the purpose and layout of each bit
       field, enhancing code understanding for future developers.
     * Consider Endianness: Be mindful of endianness differences across platforms, as they can impact
       the interpretation of bit fields. Write platform-independent code or explicitly handle endianness
       concerns.
     * Avoid Non-Portable Constructs: Minimize reliance on constructs that may exhibit
       platform-dependent behavior, ensuring portability across different systems.
     * Use Unambiguous Names: Employ descriptive and unambiguous names for bit fields, contributing to
       self-documenting code and reducing the likelihood of errors during maintenance.
     * Avoid Mixing Types: Stick to a single data type within a structure to prevent unintended behavior
       due to type mismatches.
     * Careful with Width Specifiers: Be cautious with the width specifier, ensuring it aligns with the
       intended storage requirements without causing overflow or wasting memory.

Performance Considerations
   While bit fields offer memory efficiency, careful consideration is essential for optimal performance.
     * Bit fields might introduce overhead due to their non-contiguous storage, impacting access speed.
     * Additionally, compilers may generate extra instructions to manipulate bit fields, potentially
       affecting execution time. Assessing the trade-off between memory savings and potential speed
       implications is crucial for performance-critical applications.
     * Profiling tools can help identify bottlenecks, and in cases where bit-level manipulation is
       intense, alternative memory optimization techniques may be explored.
     * Balancing memory efficiency with performance considerations is key to leveraging bit fields
       effectively in high-performance computing environments.

Conclusion
   Bit fields in C offer a powerful mechanism for memory-efficient data representation and manipulation.
   While providing granular control over individual bits, judicious use, documentation, and
   consideration of performance implications are vital for harnessing their benefits effectively in
   diverse programming scenarios.



---
https://www.quora.com/How-do-you-combine-multiple-bitmasks-in-C-I-e-if-I-need-to-apply-mask-1-then-mask-2-etc\
-to-some-value-how-can-I-combine-the-masks-to-apply-them-all-at-once

How do you combine multiple bitmasks in C? I.e., if I need to apply mask 1, then mask 2, etc., to some value,
how can I combine the masks to apply them all at once?

***
If they're AND masks, meaning that they have 0s where you want to clear bits to 0, and 1s elsewhere, just AND
them together.

If they're OR masks, meaning that they have 1s where you want to force bits to 1, and zeros elsewhere, just OR
them together.

If they're XOR masks, meaning that they have a 1 wherever you want to toggle a bit, and zeros elsewhere, just
XOR them together.

These three relationships fall directly out of the fact that each of these operations is associative:

(A.B).C=A.(B.C)
(A+B)+C=A+(B+C)
(AB)C=A(BC)

Now, if you have inverted AND masks, meaning that it has a 1 wherever you have a bit you want to clear, and 0
elsewhere, then OR them together. This comes straight out of DeMorgan's Theorem.
_   _   _____
A . B = A + B

This should all look very familiar to you. These are all your favorite basic Boolean identities. They work
just the same with masks.

Try it!

Now, if you are combining right masks to create field masks, then you want to AND the larger mask (the one
with more bits) with the inverse of the smaller one (the one with fewer bits).

A right mask is a mask that has n 1 bits aligned to the right. A field mask for the field in bits [msb:lsb]
has 1 bits in bit positions msb down to lsb, and zeros elsewhere.

In my previous posts, I specified my bit-field intervals as half-open on the MSB side. Thus, the bit-field
[msb:lsb] is equivalent to the half-open interval [lsb,msb+1).

The half-open interval corresponds nicely to our right-mask primitive.

For example, if we want a mask that isolates the field [5:3], the half-open interval is [3,6).

These two terms, 3 and 6, tell us what right masks to generate: A 6 bit right mask and a 3 bit right mask. We
then combine them as follows:

    6-bit rmask:      00111111
    3-bit rmask:      00000111
    Inv. 3-bit rmask: 11111000
    6 and inv 3:      00111000

***
Re "How can I combine masks?": For a complete (if a bit abstract) answer, read what Joe Zbiciak said in his
Answer.

But if you want a simple explanation with a concrete example and some C code, read on.

The answer to your question depends on what you mean by "combine". Let's say you have two 8-bit "bit select"
masks, that is, masks which select which bits to keep set to "1", with all non-masked bits reset to "0":

Mask #1: 00110100
Mask #2: 00001010

Then, if by "combine" you mean that you want to keep all bits which correspond to either mask and set the rest
to 0, then "combine" is bitwise "OR" (C "|" operator).

Whereas, if by "combine" you meant that you want to keep only bits which are set in both masks, then "combine"
is bitwise "AND" (C "&" operator).

Let's say that you meant the "either" version of "combine". Then you'd OR the two masks using "|", which would
yield:
Mask #3 = 00110100 | 00001010 = 00111110

Then you would AND Mask #3 with the number being "masked" by using "&", and print the result.

A C program that does this would look like this:

// combine-either-test.c

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

void print_binary (uint8_t x) {
	for ( int i = 7 ; i >= 0 ; --i ) {
		printf("%01d", (x >> i)%2);
	}
	return;
}

int main (int Beren, char * Luthien[]) {
	// Declare the variables we'll need:
	uint8_t mask1 = 0b00110100;    // First  mask.
	uint8_t mask2 = 0b00001010;    // Second mask.
	uint8_t mask3 = mask1 | mask2; // Third  mask (00111110).
	uint8_t number;                // Number to be masked.
	uint8_t result;                // Result.

	// Bail-out if number of CL args is not 1:
	if (2 != Beren) // (Beren will always be #-of-args + 1)
		exit(EXIT_FAILURE);

	// Get the number to be "masked":
	number = (uint8_t)strtol(Luthien[1], NULL, 10);

	// Get the result of "masking" (AND-ing) number with mask:
	result = number & mask3;

	// Print the results:

	printf("mask1  = ");
	print_binary(mask1);
	printf("\n");

	printf("mask2  = ");
	print_binary(mask2);
	printf("\n");

	printf("mask3  = ");
	print_binary(mask3);
	printf("\n");

	printf("number = ");
	print_binary(number);
	printf("\n");

	printf("result = ");
	print_binary(result);
	printf("\n");

	// We're done, so exit:
	exit(EXIT_SUCCESS);
}

And the results of running that program on the integer 231 would look like this:

    %combine-either-test.exe 231
    mask1  = 00110100
    mask2  = 00001010
    mask3  = 00111110
    number = 11100111
    result = 00100110

Note that each bit of mask3 is "1" if-and-only-if at least one of the corresponding bits in mask1 and mask 2
are "1". This is what "bitwise OR" means.

Each bit of the result is "1" if-and-only-if the corresponding bits of number and mask3 are both "1". This is
what "bitwise AND" means.

---
https://opensource.com/article/21/8/binary-bit-fields-masks

Write a chess game using bit-fields and masks
August 23, 2021

   Using bit-fields and masks is a common method to combine data without using structures.

   Let's say you were writing a chess game in C. One way to track the pieces on the board is by defining
   a structure that defines each possible piece on the board, and its color, so every square contains an
   element from that structure. For example, you might have a structure that looks like this:

struct chess_pc {
	int piece;
	int is_black;
}

   With this programming structure, your program will know what piece is in every square and its color.
   You can quickly identify if the piece is a pawn, rook, knight, bishop, queen, or king-and if the
   piece is black or white. But there's a more straightforward way to track the same information while
   using less data and memory. Rather than storing a structure of two int values for every square on a
   chessboard, we can store a single int value and use binary bit-fields and masks to identify the
   pieces and color in each square.

Bits and binary
   When using bit-fields to represent data, it helps to think like a computer. Let's start by listing
   the possible chess pieces and assigning a number to each. I'll help us along to the next step by
   representing the number in its binary form, the way the computer would track it. Remember that binary
   numbers are made up of bits, which are either zero or one.
     * 00000000: empty (0)
     * 00000001: pawn (1)
     * 00000010: rook (2)
     * 00000011: knight (3)
     * 00000100: bishop (4)
     * 00000101: queen (5)
     * 00000110: king (6)

   To list all pieces on a chessboard, we only need the three bits that represent (from right to left)
   the values 1, 2, and 4. For example, the number 6 is binary 110. All of the other bits in the binary
   representation of 6 are zeroes.

   And with a bit of cleverness, we can use one of those extra always-zero bits to track if a piece is
   black or white. We can use the number 8 (binary 00001000) to indicate if a piece is black. If this
   bit is 1, it's black; if it's 0, it's white. That's called a bit-field, which we can pull out later
   using a binary mask.

Storing data with bit-fields
   To write a chess program using bit-fields and masks, we might start with these definitions:
/* game pieces */

#define EMPTY 0
#define PAWN 1
#define ROOK 2
#define KNIGHT 3
#define BISHOP 4
#define QUEEN 5
#define KING 6

/* piece color (bit-field) */

#define BLACK 8
#define WHITE 0

/* piece only (mask) */

#define PIECE 7

   When you assign a value to a square, such as when initializing the chessboard, you can assign a
   single int value to track both the piece and its color. For example, to store a black rook in
   position 0,0 of an array, you would use this code:

  int board[8][8];
..
  board[0][0] = BLACK | ROOK;

   The | is a binary OR, which means the computer will combine the bits from two numbers. For every bit
   position, if that bit from either number is 1, the result for that bit position is also 1. Binary OR
   of the value BLACK (8, or binary 00001000) and the value ROOK (2, or binary 00000010) is binary
   00001010, or 10:
    00001000 = 8
 OR 00000010 = 2
    --------
    00001010 = 10

   Similarly, to store a white pawn in position 6,0 of the array, you could use this:
  board[6][0] = WHITE | PAWN;

   This stores the value 1 because the binary OR of WHITE (0) and PAWN (1) is just 1:
    00000000 = 0
 OR 00000001 = 1
    --------
    00000001 = 1

Getting data out with masks
   During the chess game, the program will need to know what piece is in a square and its color. We can
   separate the piece using a binary mask.

   For example, the program might need to know the contents of a specific square on the board during the
   chess game, such as the array element at board[5][3]. What piece is there, and is it black or white?
   To identify the chess piece, combine the element's value with the PIECE mask using the binary AND:

  int board[8][8];
  int piece;
..
  piece = board[5][3] & PIECE;

   The binary AND operator (&) combines two binary values so that for any bit position, if that bit
   in both numbers is 1, then the result is also 1. For example, if the value of board[5][3] is 11
   (binary 00001011), then the binary AND of 11 and the mask PIECE (7, or binary 00000111) is binary
   00000011, or 3. This is a knight, which also has the value 3.
    00001011 = 11
AND 00000111 = 7
    --------
    00000011 = 3

   Separating the piece's color is a simple matter of using binary AND with the value and the BLACK
   bit-field. For example, you might write this as a function called is_black to determine if a piece is
   either black or white:

int is_black(int piece) {
	return (piece & BLACK);
}

   This works because the value BLACK is 8, or binary 00001000. And in the C programming language, any
   non-zero value is treated as True, and zero is always False. So is_black(board[5][3]) will return a
   True value (8) if the piece in array element 5,3 is black and will return a False value (0) if it is
   white.

Bit fields
   Using bit-fields and masks is a common method to combine data without using structures. They are
   worth adding to your programmer's "tool kit." While data structures are a valuable tool for ordered
   programming where you need to track related data, using separate elements to track single On or Off
   values (such as the colors of chess pieces) is less efficient. In these cases, consider using
   bit-fields and masks to combine your data more efficiently.


---
https://heasarc.gsfc.nasa.gov/fitsio/c/c_user/node102.html

10.11.2 Bit Masks

   Bit masks can be used to select out rows from bit columns (TFORMn = #X) in FITS files. To represent
   the mask, binary, octal, and hex formats are allowed:

                 binary:   b0110xx1010000101xxxx0001
                 octal:    o720x1 -> (b111010000xxx001)
                 hex:      h0FxD  -> (b00001111xxxx1101)

   In all the representations, an x or X is allowed in the mask as a wild card. Note that the x
   represents a different number of wild card bits in each representation. All representations are case
   insensitive. Although bitmasks may be of arbitrary length and contain a wildcard, they may only be
   used in logical expressions, unlike integer constants (see above) which may be used in any arithmetic
   expression.

   To construct the boolean expression using the mask as the boolean equal operator described above on a
   bit table column. For example, if you had a 7 bit column named flags in a FITS table and wanted all
   rows having the bit pattern 0010011, the selection expression would be:

                            flags == b0010011
    or
                            flags .eq. b10011

   It is also possible to test if a range of bits is less than, less than equal, greater than and
   greater than equal to a particular boolean value:

                            flags <= bxxx010xx
                            flags .gt. bxxx100xx
                            flags .le. b1xxxxxxx

   Notice the use of the x bit value to limit the range of bits being compared.

   It is not necessary to specify the leading (most significant) zero (0) bits in the mask, as shown in
   the second expression above.

   Bit wise AND, OR and NOT operations are also possible on two or more bit fields using the '&'(AND),
   '|'(OR), and the '!'(NOT) operators. All of these operators result in a bit field which can then be
   used with the equal operator. For example:

                          (!flags) == b1101100
                          (flags & b1000001) == bx000001

   Bit fields can be appended as well using the '+' operator. Strings can be concatenated this way, too.


---
https://www.delftstack.com/howto/c/bit-masking-in-c/


Bit Masking in C

   This article will demonstrate multiple methods about how to use bit masking in C.

Use the struct Keyword to Define Bitmask Data in C
   Bitmasks are usually used for bitwise operations to access or set individual sections of the bit
   field style data structures. On the other hand, Bit fields are utilized to store data efficiently and
   reduce the memory footprint.

   Bitwise operations are also relatively faster to execute in hardware rather than common arithmetic
   operations. In the following example, we demonstrate the bit field's implementation using the struct
   keyword.

   Note that this is a special notation to construct the object where the given bit regions can be
   retrieved using the conventional member access operator. Bitfield structure stores a single unsigned
   integer occupying 32 bits in memory, but it can also be accessed in 3 different sections of size -
   23-bit, 5-bit, and 4-bit values named as year, day and month respectively. As a result, the Bitfield
   represents the abstraction of date implemented efficiently in the memory.

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

struct {
	uint32_t year : 23;
	uint32_t day : 5;
	uint32_t month : 4;
} typedef Bitfield;

int main() {
	Bitfield date = {2020, 13, 12};

	printf("sizeof Bitfield: %lu bytes\n", sizeof(date));
	printf("date: %d/%d/%d \n", date.day, date.month, date.year);

	return EXIT_SUCCESS;
}

   Output:
sizeof Bitfield: 4 bytes
date: 13/12/2020

Use struct Combined With union to Define Bitmask Data in C
   Alternatively, we can add the union keyword to the previous structure so that it's possible to access
   the whole 32-bit number separately. Since accessing the bit-field members is slower than accessing
   the member of struct, we will assign the date value using the bitwise operations to the separate ydm
   integer member.

   Note that decimal numbers representing the given date are logically OR-ed with each other, but before
   that, the day and month values are shifted left by 23 and 28 places, respectively. The latter numbers
   are taken based on the corresponding bit positions these members occupy in the bit field. Notice that
   each member can still be accessed separately when needed to print the output.

#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>

union {
	struct {
		uint32_t year:23;
		uint32_t day:5;
		uint32_t month:4;
	};
	uint32_t ydm;
} typedef BitfieldFast;

int main() {

	BitfieldFast date_f;
	date_f.ydm = 2020 | (13 << 23) | (12 << 28);

	printf("sizeof BitfieldFast: %lu bytes\n", sizeof(date_f));
	printf("date_f: %d/%d/%d \n", date_f.day, date_f.month, date_f.year);

	return EXIT_SUCCESS;
}

   Output:
sizeof BitfieldFast: 4 bytes
date_f: 13/12/2020

   Another typical example of bitmask usage is IP addresses in networking. Namely, IP addresses are
   provided with the network mask, which determines which network the given address belongs. The
   calculation of the network address is done by logically AND-ing the IP address and its network mask.

   In this case, we defined the bit field struct to store the IP address and netmask separately. Note
   that logical AND-ing is done on the whole 32-bit values, but when we print the addresses as the four
   8-bit sections, the member access operator is used.

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

union {
	struct {
		uint8_t first : 8;
		uint8_t second : 8;
		uint8_t third : 8;
		uint8_t fourth : 8;
	};
	uint32_t ip;
} typedef IPAddress;

int main() {
	IPAddress ip1 = {10, 127, 5, 1};
	IPAddress mask = {255, 255, 240, 0};
	printf("ip1: %d.%d.%d.%d\n", ip1.first, ip1.second, ip1.third, ip1.fourth);
	ip1.ip = ip1.ip & mask.ip;
	printf("net: %d.%d.%d.%d\n", ip1.first, ip1.second, ip1.third, ip1.fourth);

	return EXIT_SUCCESS;
}

   Output:
ip1: 10.127.5.1
net: 10.127.0.0


---
https://wiki.purduesigbots.com/software/general/bit-mask

Bit Mask

   A bit mask is an operation which selects certain bits to be manipulated (or not manipulated) from a
   binary number.

   Bit masks are most commonly associated with bitwise AND and bitwise OR operations to remove unwanted
   bits while leaving the desired bits behind. Bitwise XOR operations can also be used with bit masks to
   selectively toggle bits of a number.

   Principles

   Bit masks are nothing more than specially selected constants with binary values appropriate to their
   use. There are two principal types:
     * A positive bit mask has a 1 in the position of the desired bits, and a 0 in the position of bits
       to leave unaffected.
     * A negative bit mask has a 0 in the position of the bits to be changed, and a 1 in all other
       positions. A negative bit mask is the binary complement of the matching positive bit mask, and
       vice versa.

   Positive bit masks are used with bitwise OR operations to selectively set bits in a number and leave
   others unchanged. To create a positive mask, compose a hexadecimal constant with a binary value
   containing 1 in each location that must be changed, and a 0 in all other locations. This can be done
   more clearly by bitwise ORing several shifted values to indicate exactly which positions are being
   set, as the compiler should optimize this at compile time into an equivalent constant. After the mask
   is created, using bitwise OR (| or |= in C) on the desired quantity and the mask will set those bits
   and leave all others unchanged.

   Negative bit masks are typically created by taking the bitwise complement (~) of a positive bit mask
   with the desired bits set. Negative bit masks must be used with bitwise AND (& or &=) to have the
   proper effect. Mismatching positive and negative masks with the wrong operation will cause unintended
   results, so comment clearly and check carefully.

   Examples
   Clear all bits in the number 00111001 except for the 3rd and 4th bit from the right (bit positions 2
   and 3, or (1 << 3) | (1 << 2)):
   ##(1 << 3)

   (1 << 2) = 00001100##

   00111001 AND 00001000 = 00001000

   Set bit position 1 in the number 00111001:
   (1 << 1) = 00000010

   00111001 OR 00000010 = 00111011

   Clear bit position 4 in the number 00111001 using a negative bit mask:
   NOT (1 << 4) = 11101111

   00111001 AND 11101111 = 00101011

   Applications
     * Register manipulation - A typical low-level task might be to set or clear certain bits in a
       register while leaving all others unchanged. By appropriately masking the current register value
       (positive mask to set bits, negative mask to clear bits), this operation can be performed
       quickly. Beware - most processors will not do this atomically, and changes to the register value
       between the initial value read and masked value write will ruin the result.
     * Force value in range - Comparing a value to an upper limit involves a slow branch instruction,
       and modulus is often slow as well. If the upper limit is a power of two, and the input is
       unsigned (or negative values are also disallowed), mask off all of the bits more significant than
       the desired bits. Items such as GPIO pins usually come in groups of eight or sixteen to use this
       feature to maximum advantage.
     * Add or subtract - In some circumstances, bit masks can substitute for addition or subtraction. If
       a value known to be between 0 and 7 (inclusive) needs to be incremented by 8, one can
       positive-mask the value with 0x08, which will set the known-to-be-clear 3rd bit and therefore
       increase the number's magnitude by 8.
     * Test bit - To see if a particular bit is set (another common register task), mask the value with
       an appropriately selected positive bit mask containing only that position and pass it straight
       into if (which will generate a fast condition-code check for zero on most processors).
     * Enforce type conversion - C's type conversions can sometimes produce unexpected results,
       especially when switching between signed and unsigned types. Negative masking can often alleviate
       the problem by dictating exactly which bits in the result should keep their values from the
       conversion and which bits should be reset.


---
https://wiki.sei.cmu.edu/confluence/display/c/CON32-C.+Prevent+data+races+when+accessing+bit-fields+from+multiple+threads

CON32-C. Prevent data races when accessing bit-fields from multiple threads
Nov 12, 2024

   When accessing a bit-field, a thread may inadvertently access a separate bit-field in adjacent
   memory. This is because compilers are required to store multiple adjacent bit-fields in one storage
   unit whenever they fit. Consequently, data races may exist not just on a bit-field accessed by
   multiple threads but also on other bit-fields sharing the same byte or word.  A similar problem
   is discussed in CON43-C. Do not allow data races in multithreaded code, but the issue described
   by this rule can be harder to diagnose because it may not be obvious that the same memory location is
   being modified by multiple threads.

   One approach for preventing data races in concurrent programming is to use a mutex. When properly
   observed by all threads, a mutex can provide safe and secure access to a shared object. However,
   mutexes provide no guarantees with regard to other objects that might be accessed when the mutex is
   not controlled by the accessing thread. Unfortunately, there is no portable way to determine which
   adjacent bit-fields may be stored along with the desired bit-field.

   Another approach is to insert a non-bit-field member between any two bit-fields to ensure that each
   bit-field is the only one accessed within its storage unit. This technique effectively guarantees
   that no two bit-fields are accessed simultaneously.

Noncompliant Code Example (Bit-field)
   Adjacent bit-fields may be stored in a single memory location. Consequently, modifying adjacent
   bit-fields in different threads is undefined behavior, as shown in this noncompliant code
   example:

struct multi_threaded_flags {
	unsigned int flag1 : 2;
	unsigned int flag2 : 2;
};

struct multi_threaded_flags flags;

int thread1(void *arg) {
	flags.flag1 = 1;
	return 0;
}

int thread2(void *arg) {
	flags.flag2 = 2;
	return 0;
}

   The C Standard, 3.17, paragraph 3 [ISO/IEC 9899:2024], states
     Note 2 to entry: A bit-field and an adjacent non-bit-field member are in separate memory
     locations. The same applies to two bit-fields, if one is declared inside a nested structure
     declaration and the other is not, or if the two are separated by a zero-length bit-field
     declaration, or if they are separated by a non-bit-field member declaration. It is not safe to
     concurrently update two non-atomic bit-fields in the same structure if all members declared
     between them are also (nonzero-length) bit-fields, no matter what the sizes of those intervening
     bit-fields happen to be.

   For example, the following instruction sequence is possible:
Thread 1: register 0 = flags
Thread 1: register 0 &= ~mask(flag1)
Thread 2: register 0 = flags
Thread 2: register 0 &= ~mask(flag2)
Thread 1: register 0 |= 1 << shift(flag1)
Thread 1: flags = register 0
Thread 2: register 0 |= 2 << shift(flag2)
Thread 2: flags = register 0

Compliant Solution (Bit-field, C11, Mutex)

   This compliant solution protects all accesses of the flags with a mutex, thereby preventing any data
   races:

#include <threads.h>

struct multi_threaded_flags {
	unsigned int flag1 : 2;
	unsigned int flag2 : 2;
};

struct mtf_mutex {
	struct multi_threaded_flags s;
	mtx_t mutex;
};

struct mtf_mutex flags;

int thread1(void *arg) {
	if (thrd_success != mtx_lock(&flags.mutex)) {
		/* Handle error */
	}
	flags.s.flag1 = 1;
	if (thrd_success != mtx_unlock(&flags.mutex)) {
		/* Handle error */
	}
	return 0;
}

int thread2(void *arg) {
	if (thrd_success != mtx_lock(&flags.mutex)) {
		/* Handle error */
	}
	flags.s.flag2 = 2;
	if (thrd_success != mtx_unlock(&flags.mutex)) {
		/* Handle error */
	}
	return 0;
}

Compliant Solution (C11)
   In this compliant solution, two threads simultaneously modify two distinct non-bit-field members of a
   structure. Because the members occupy different bytes in memory, no concurrency protection is
   required.

struct multi_threaded_flags {
	unsigned char flag1;
	unsigned char flag2;
};

struct multi_threaded_flags flags;

int thread1(void *arg) {
	flags.flag1 = 1;
	return 0;
}

int thread2(void *arg) {
	flags.flag2 = 2;
	return 0;
}

   Unlike C99, C11 and C23 explicitly define a memory location and provides the following note in
   subclause 3.17 paragraph 2 [ISO/IEC 9899:2024]:

     Note 1 to entry: Two threads of execution can update and access separate memory locations without
     interfering with each other.

   It is almost certain that flag1 and flag2 are stored in the same word. Using a compiler that conforms
   to C99 or earlier, if both assignments occur on a thread-scheduling interleaving that ends with both
   stores occurring after one another, it is possible that only one of the flags will be set as
   intended. The other flag will contain its previous value because both members are represented by the
   same word, which is the smallest unit the processor can work on. Before the changes were made to the
   C Standard for C11, there were no guarantees that these flags could be modified concurrently.


---
https://stackoverflow.com/questions/56957720/bitfields-vs-bitmasks


Bitfields VS. Bitmasks

   I've had some experience in C before, however I have never seen the bitfields feature before. I know
   one can use bitmasks to isolate certain bits in a data structure, but why then bother with bitfields?

   For example, say the bits we want to isolate are the first 3 least significant bits. Then we can
   write:

/* our bitmasks */
#define FIELD_A (1 << 0)
#define FIELD_B (1 << 1)
#define FIELD_C (1 << 2)

int main(void) {
	/* the data structure that contains our three fields */
	uint8_t flags;

	/* accessing field A (as a boolean) */
	int bool_a = !!(flags & FIELD_A);

	/* accessing field B (as a boolean) */
	int bool_b = !!(flags & FIELD_B);

	/* accessing field C (as a boolean) */
	int bool_c = !!(flags & FIELD_C);

	return 0;
}

   Why would we choose to write this as:

static struct fields {
	int field_a : 1;
	int field_b : 1;
	int field_c : 1;
};

int main(void) {
	/* the data structure that contains our three fields */
	struct fields flags;

	/* accessing field A */
	int bit_a = flags.a;

	/* accessing field B */
	int bit_b = flags.b;

	/* accessing field C */
	int bit_c = flags.c;

	return 0;
}

***
   Bitfields are more handy to use than explicit bit masks, especially for lengths greater than 1. Hand
   coded bit twiddling is quite often broken in subtle ways.

   The main problem with bitfields is the imprecise specification:
     * whether int typed bitfields are signed or unsigned is implementation defined.
     * the order and position of the bitfields in memory is implementation defined, which makes hardware
       mapping more risky. Even for a given endianness, the positions and order of bitfields are not
       specified precisely, which is a major shortcoming.

   Note in particular that int field_a : 1; is actually problematic: an int bitfield with a single bit
   might be read as -1 instead of 1 if set. You should use unsigned int field_a : 1; etc.

***
     I know one can use bitmasks to isolate certain bits in a data structure, but why then bother with
     bitfields?

   One uses bitfields either to map a data structure whose field sizes do not all match your C
   implementation's built-in types, such as a TCP header, or simply to shrink the size of your data
   structure.

   You can indeed pack and unpack data manually by using masks and shifting, but bitfields provide a
   more convenient syntax for that. In addition to just hiding the shifting and masking, bitfield access
   transparently handles sign extension issues and the special characteristics of _Bool, where
   appropriate.

   The tradeoff is a loss of control over the details. If you pack and unpack manually, then you can
   have complete confidence and control of the layout, with great portability. If you use bitfields, on
   the other hand, and you care about the details of how the bits are arranged, then you need to rely on
   implementation details or on extensions to ensure that you have the layout you want, if that's even
   possible from your implementation at all.


---
https://systems-encyclopedia.cs.illinois.edu/articles/bitfields/

Bit Fields

   In C and C++, the smallest primitive types consist of a single byte that can store 256 (2^8) unique
   values. However, you may encounter situations where even 256 far exceeds the number of values you
   need to represent with a variable. One of the most common of these situations arises when you have a
   struct or class that contains several boolean variables, which only have 2 meaningful values (true or
   false).

   Suppose we an animal struct wherein each animal has a name and possesses some combination of
   attributes.
   One way we might represent such an animal is as follows:

typedef struct _animal {
	const char* name;  //our name
	bool quadruped = false; //whether we have four lege
	bool tail      = false; //whether we have a tail
	bool shell     = false; //whether we have a shell
	bool herbivore = false; //whether we are herbivorous
	bool green     = false; //whether we are green
	bool fast      = false; //whether we are fast
	bool aquatic   = false; //whether we live in the water
	bool audible   = false; //whether we make audible sounds
} animal;

   Now suppose we wish to create a new animal using some combination of the above attributes. We might
   set these attributes directly when creating the animal, one-by-one after creating the animal, or
   through a helper function:

// direct
animal a = {"cat",true,false,false,false,false,true,false,true};
// one-by-one
animal a;
a.name      = "cat";
a.quadruped = true;
a.tail      = true;
a.fast      = true;
a.audible   = true;
// helper function
animal makeAnimal(const char* name, bool quadruped, bool tail,
		bool shell, bool herbivore, bool green, bool fast,
		bool aquatic, bool audible) {
	animal a;
	a.name      = name;
	a.quadruped = quadruped;
	a.tail      = tail;
	a.shell     = shell;
	a.herbivore = herbivore;
	a.green     = green;
	a.fast      = fast;
	a.aquatic   = aquatic;
	a.audible   = audible;
	return a;
}

   The direct method and helper functions are straightforward, but respectively requires us to remember
   the position of each attribute in the struct or the order of the parameters to the function, which
   are highly error prone.
   The one-by-one method is cleaner and more explicit than the other methods, but still require us to
   individually set each true value, which may be cumbersome if we need to manually construct several
   animals.

   Finally, suppose we want to determine whether a given animal shares the same attributes as a refernce
   animal. We could accomplish this with a series of if statements, as follows:

//8 if statements and up to 8 comparisons
bool isACat(animal &a) {
	if (a.quadruped) {
		if (a.tail) {
			if (!a.shell) {
				if (!a.herbivore) {
					if (!a.green) {
						if (a.fast) {
							if (!a.aquatic) {
								if (a.audible) {
									return true;
								}
							}
						}
					}
				}
			}
		}
	}
	return false;
}

   The above code is very cumbersome. The code could be made much more readable using boolean logical
   operators, but ultimately we may still end up performing up to 8 comparisons in the worst case:

//looks much cleaner, but still performing up to 8 comparisons
bool isACat(animal &a) {
	return a.quadruped
		&& a.tail
		&& (!a.shell)
		&& (!a.herbivore)
		&& (!a.green)
		&& a.fast
		&& (!a.aquatic)
		&& a.audible;
}

   Additionally, while our animal struct has only 8 boolean variables, many structs and classes created
   in practice may have dozens of boolean variables, with increasingly complex constructors and
   mechanisms for comparing these variables as a result.

Using bit fields
   A bit field is a data structure used to address and manipulate individual bits of data in memory.
   While bit fields do not exist as a separate primitive type in C or C++, these languages do provide us
   with bitwise operators that allow us to address and manipulate the individual bits of other primitive
   types (generally, unsigned integer types between 8-64 bits in length). (N.b.: the C and C++ standards
   do provide built-in implementations of bit fields, but they are not necessarily portable [see
   Further Reading section at end].)

   By using bit fields, we are able to solve several of the issues identified in the above section. To
   begin, we must first define one or more bit masks, which are variables in which a single bit is set
   and the rest are unset. We will need a separate bitmask for each boolean variable we wish to
   represent in our bit field. For our animal struct, our bit masks might look something like this:

const char quadruped = 0b10000000; //whether we have four lege
const char tail      = 0b01000000; //whether we have a tail
const char shell     = 0b00100000; //whether we have a shell
const char herbivore = 0b00010000; //whether we are herbivorous
const char green     = 0b00001000; //whether we are green
const char fast      = 0b00000100; //whether we are fast
const char aquatic   = 0b00000010; //whether we live in the water
const char audible   = 0b00000001; //whether we make audible sounds

   While we use chars above to describe each bit mask, larger bitfields might use 16-bit, 32-bit, or
   64-bit data types when working with larger bitfields.
   Using the above bitmasks, we can greatly simplify the fields in our animal struct:

typedef struct _animal {
	const char* name;      //our name
	char        stats = 0; //our attributes
} animal;

   Note that the previous bool variables have been replaced by a single char we have named stats. We
   will be accessing the 8 individual bits of this variable to accomplish what we previously
   accomplished using 8 separate boolean values. Continuing our rewrite of our code in the first
   section, we are able to reimplment our three techniques for creating an animal as follows:
   
// direct
animal a = {"cat",tail|fast|quadruped|audible};
// one-by-one
animal a;
a.name      = "cat";
// EITHER
a.stats     = audible|fast|tail|quadruped;
// OR
a.stats     = quadruped;
a.stats    |= tail;
a.stats    |= fast;
a.stats    |= audible;
// helper function
animal makeAnimal(const char* name, char stats) {
	return {name,stats};
}

   Much shorter!
   We can see that in the direct and helper function methods, we no longer have to remember the order of
   all of our boolean attributes, and can instead use the bitwise OR operator to set all of the
   necessary bitmasks in any order, while the remaining bit masks are unset by default.
   Moreover, the one-by-one method now looks very similar to the direct method, but should we so desire,
   we can retain similar syntax to what we had before simply using the |= operator.

   Perhaps the most noticeable improvement comes from our isACat() function. While we previously
   required up to 8 separate comparisons to determine whether an animal matched a reference animal, we
   can now rewrite our function using a single comparison!

bool isACat(animal &a) {
	const char CATSTATS = quadruped|tail|fast|audible;
	return a.stats == CATSTATS;
}

   Voila! Through the magic of bit fields, we have rewrriten our isACat() function to be shorter and
   cleaner while using fewer comparisons and bytes of memory!

Summary of reasons to use bit fields over other primitive types:
     * Lower memory usage (can store 8 boolean values in a single char!)
     * Fewer comparisons (a single bitmask using a long unsigned int can replace up to 64 if
       statements!)
     * Fewer parameters to pass to functions and less need to remember parameter ordering!
     * Shorter, cleaner, more readable code in many cases!

Reference sheet for some common bit field usages
uint8_t FLAGS = 0b10101001;  //can also be uint16_t, uint32_t, or uint64_t
uint8_t foo   = 0b00010111;  //can also be uint16_t, uint32_t, or uint64_t

//Check if all set bits in FLAGS are also set in foo
bool allset1s = (foo & FLAGS) == FLAGS;

//Check if any set bits in FLAGS are also set in foo
bool anyset1s = (foo & FLAGS) > 0;

//Check if no set bits in FLAGS are also set in foo
bool noset1s = !(foo & FLAGS);

//Check if all unset bits in FLAGS are also unset in foo
bool allset0s = !(foo & (~FLAGS));

//Check if set and unset bits match exactly in foo and FLAGS
bool exactmatch = foo == FLAGS;

//Make sure all set bits in FLAGS are also set in foo
foo |= FLAGS;

//Make sure all unset bits in FLAGS are set in foo
foo |= (~FLAGS);

//Make sure all unset bits in FLAGS are also unset in foo
foo &= FLAGS;

//Make sure all set bits in FLAGS are unset in foo
foo &= (~FLAGS);

//Flip all bits in foo
foo = ~foo;

//Flip all bits in foo that are set in FLAGS
foo ^= FLAGS;

//Flip all bits in foo that are unset in FLAGS
foo ^= (~FLAGS);

//Directly set nth bit of foo (n = 0-indexed, starting from right)
foo |= (1 << n);

//Directly unset nth bit of foo
foo &= (~(1 << n));

//Directly flip nth bit of foo
foo ^= (1 << n);

//Directly test if nth bit of foo is set
bool isnthbitset(foo,n) { return foo & (1 << n); }


---
