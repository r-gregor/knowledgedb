filename: c_intro-multyf_20211016.txt 
https://www.cs.swarthmore.edu/~newhall/cs31/resources/C-intro.php

Introduction to C Programming for CS31 Students

Part 1: variables, functions, arrays, strings

Contents:
	1. Getting Started simple program, compiling
	2. Variables
	3. Input/Output
	4. Branching
	5. Loops
	6. Functions
	7. Arrays
	8. Strings
	9. Intro to Structs

   Part 2 contains information about structs and pointers (it will be covered later in the
   semester)

Overview and Resources
   This page includes a brief overview to C programming for students who have taken CS21 or an
   equivalent introductory CS course. We will start with some of the C basics, which is much
   of the C programming language, and then will add more C programming features as the
   semester progresses. As you are implementing C programs for lab assignments, make use of:
	1. The information on this page
	2. My C programming Documentation and C Programming Resources. This contains all kinds
	   of C programming documentation including:
		  + How to compile and run C programs on our system
		  + The C Code Style Guide (read this and follow it)
		  + Documentation about different C types and C data structures (char, strings, file
			I/O, pointers, arrays, linked lists, ...).
		  + Links to C programming tutorials and C language documentation.
		  + How to use C debugging tools: gdb and valgrind
	3. Example C code that I give you in class and weekly lab.

   Code examples on this page can be copied over from my public/cs31/C_examples directory:
   # if you don't have a cs31 subdirectory, create one first:
   mkdir cs31
   # copy over my C example files into your cs31 subdirecory:
   cd cs31
   cp -r /home/newhall/public/cs31/C_examples  .
   # cd into your copy, run make to compile
   cd C_examples
   ls
   make

Getting Started Programming in C
   Below is the hello world program in C with a lot of comments. I would put it in a file
   named hello.c (.c is the suffix convention used for C source code files).
/*
	The Hello World Program in C
	(this is also an example of a multi-line comment)
*/
#include <stdio.h>	 // include the C standard I/O library

// Any executable program must have exactly one function called main
int main() {
	printf("Hello World\n");
	return 0;
}

   Note the following features of the basic program:
	 * C statements end with a semicolon ;.
	 * blocks (e.g. function, loop, and branch bodies) start with a { and end with a }.
	 * Single line comments begin with //
	 * Multi-line comments begin with /* and end with */
	 * C library functionality can be included (imported) using #include
	   All #include statements appear at the top of the program, outside of function bodies.
	 * All functions must have a return type. If nothing is returned, the return type is void.
	   main's return type is always int.
	 * All C statements must be within a function body (main in this example).

   To run a program, we must first save the code using vim or another editor on our
   system, then compile the source to an executable form and run the executable form of our
   program. The syntax for compiling is
$> gcc -o <output_executable_file> <input_source_file>

   for example, gcc compiles hello.c into an executable file named hello:
$> gcc -o hello hello.c

   We run the executable program using ./hello:
$> ./hello

   If we change the source (hello.c file), we must recompile with gcc before running ./hello.
   If there are any errors, the ./hello file will not be created/recreated (but beware, an
   older version of the file from a previous successful compile may still exist). If you do
   not include the -o outputfile, gcc creates the executable in a file named a.out.

Variables
   Variables are named containers for holding data. In C all variables must be declared before
   use. To declare a variable, use the following syntax:
type_name variable_name;

   A variable can only have a single type. Valid basic types include int, float, double, char.
   Examples for declaring variables are shown below. In C, variables must be declared at the
   beginning of their scope (top of a { } block) before any C statements in that scope (this
   is not true in C++, so if you are coming from CS35, be sure to follow C variable
   declaration convention).
{
	/* DECLARE ALL VARIABLES OF THIS SCOPE AT THE TOP OF THE BLOCK { */
	int x;          // declaring x to be an int type variable
	int i,j,k;      // can declare multiple variables of the same type on one line
	char letter;    // a char stores a single ASCII value
                    // a char in C is a different type that a string in C
	float winpct;   // winpct is declared to be a float type
	double pi;      // the double type is more precise than float

	/* AFTER DECLARING ALL VARIABLES YOU CAN USE THEM IN C STATEMENTS */
	x = 7;          // x stores 7, initialize all variables before using them
	k = x + 2;      // use x's value in an expression

	letter = 'A';          // a single quote is used for single character value
	letter = letter+1;     // letter stores 'B' (its ascii value is one more than 'A's)

	double pi = 3.1415926; // the double type is more precise than float

	winpct = 11/2;  // winpct gets 5.5, winpct is a float type
	j = 11/2;       // j gets 5: int division truncates anything after the decimal
	x = k%2;        // % is C's mod operator, so x gets 9 mod 2 (1)
}

   Note the semicolons galore. C expects one after every statement. You'll forget them. gcc
   almost never says "You missed a semicolon" even though that might be the only thing wrong
   with your program. As you program more in C, you will learn to translate gcc errors to the
   error in your program.

   On most variable types, you may use the following operators. Some may not apply depending
   on the operand type.
	 * multiply, divide, mod *, /, %
	 * add, subtract +, -
	 * assignment =
	 * update and assignment +=, -=, *=, /=, %=
	   (e.g. x+=3 is shorthand for x=x+3).
	 * increment, decrement ++, --
	   (e.g. x++ is shorthand for x=x+1).
	   ++x and x++ are both valid, but are evaluated slightly differently:
  ++x: increment x first, then use it value
  x++: use x's value first, then increment it

	   In many cases it doesn't matter which you use because the value of the incremented or
	   decremented variable is not being used in the statement. For example, these two
	   statements have an equivalent effect:
  x++;
  ++x;

	   But in some cases it does (when the value of the incremented or decremented variable IS
	   being used in the statement):
  x = 6;
  y = ++x;	// x gets 7, y gets 7
  x = 6;
  y = x++;	// y gets 6, x gets 7

Input/Output (printf and scanf)
   C uses the printf function for printing to standard out (the terminal), and scanf is one
   function for reading in values (usually from the keyboard). scanf is similar to printf, and
   it is the first way we will do program input. However, it is not very resilient to users
   entering bad values, so later we will learn better ways to read in values.

   printf and scanf are part of the stdio.h library that needs to be #included at the top of
   the .c file using them.

   printf is very similar to formatted print statements in Python, where you provide a format
   string to print and then values to fill the placeholders in the format string. Here are
   some printf examples:
  int x = 5, y = 10;
  float pi = 3.14;

  // print the values of x and y followed by a newline character:
  printf("x is %d and y is %d\n", x, y);

  // print a float value (%g) a string value (%s) and an int value (%d)
  // separated by tab characters (\t) followed by a new line character (\n):
  printf("%g \t %s \t %d\n", pi, "hello", y);

   Different types in C are different numbers of bytes, and there are signed and unsigned
   versions of the "integer" types.
 1 byte:          char          unsigned char
 2 bytes:         short         unsigned short
 4 bytes:         int           unsigned int           float
 4 or 8 bytes*:   long          unsigned long
 8 bytes:         long long     unsigned long long     double

 *number of bytes for long depends on the architecture

   printf formatting placeholders:
Placeholders for specifying different types
--------------------------------------------
 %f,%g:  placeholders for a float or double value
 %d:	 placeholder for a decimal value (for printing char, short, int values)
 %u:	 placeholder for an unsigned decimal
 %c:	 placeholder for a single character
 %s:	 placeholder for a string value
 %p:	 placeholder to print an address value

 To print out long type values need to use l prefix:
   %lu: print an unsigned long value
   %lld: print a long long	value

Placeholders for specifying the numeric representation
-------------------------------------------------------
 %x:	 print value in hexidecimal (base 16)
 %o:	 print value in octal (base 8)
 %d:	 print value in signed decimal	(base 10)
 %u:	 print value in unsigned decimal (unsigned base 10)
 %e:	 print float or double in scientific notation
 (there is no formatting option to display the value in binary)

The following are special formatting characters:
-----------------------------------------------
\t: print a tab character
\n: print a newline character

You can also specify field width for the values:
------------------------------------------------
%5.3f: print float value in space 5 chars wide, with 3 places beyond decimal
%20s:  print the string value in a field of 20 chars wide, right justified
%-20s: print the string value in a field of 20 chars wide, left justified
%8d:   print the int value in a field of 8 chars wide, right justified
%-8d:  print the int value in a field of 8 chars wide, left justified


   Here is an example full program using a lot of formatting:
#include <stdio.h> // library needed for printf

int main() {
	float x=4.50001;
	float y=5.199999;
	char ch = 'a';
	printf("%.1f %.1f\n", x, y); // prints out x and y with single precision
	// nice tabular output
	printf("%6.1f \t %6.1f \t %c\n", x, y, ch);
	printf("%6.1f \t %6.1f \t %c\n", x+1, y+1, ch+1);
	printf("%6.1f \t %6.1f \t %c\n", x*20, y*20, ch+2);
	return 0;
}

scanf
   scanf is one way in which your program can read in input values entered by a user. It is
   very picky about the exact format in which the user enters data, which makes it not very
   robust to badly formed user input. For now we will use it, later we will use a more robust
   way of reading input values from the user. For now, just remember that if your program gets
   into an infinite loop due to badly formed user input you can always type CNTRL-C to kill
   it.

   A scanf call looks a lot like a printf call, it has a format string followed by variable
   locations into which the values read in should be stored. To specify the location of a
   variable, you need to use the & operator, which evaluates to "the memory location (or
   address) of the associated variable". Here are some examples:
  int x;
  float pi;

  // read in an int value followed by a float value ("%d%g")
  // store the int value at the memory location of x (&x)
  // store the float value at the memory location of pi (&pi)
  scanf("%d%g", &x, &pi);

   The scanf will skip over leading and trailing whitespace characters (e.g. ' ', '\t', '\n')
   as it finds the start and end of each numeric literal. Thus, a user could enter the value 8
   and 3.4 in any of the three ways listed below and the call to scanf above would assign 8 to
   x and 3.4 to pi:
8 3.4
		 8			   3.4
8
3.4

   The format string for scanf is a bit different than for printf in that you often do not
   need to specify white space chars in the format string for reading in consecutive numeric
   values:
// reads in an int and a float separated by at least one white space character
  scanf("%d%g",&x, &pi);

   scanf can seem to behave very strangely for format string with different type placeholders,
   so if you get some odd behavior play around with the format string a bit and try different
   types. My documentation about file I/O has some example scanf format strings.
   Branching with if/else
   The syntax for branching in C is very similar to in Python. The main difference is that
   where Python uses indenting to indicate "body" statements, C used curly braces (but you
   should also use good indenting to in your C code). Here is the basic if-else syntax (the
   else part is optional):
//a one way branch
if ( <Boolean expression> ){
	<true body>
}

// a two way branch
if ( <Boolean expression> ){
	<true body>
}
else{
	<false body>
}

// a multibranch:
if ( <Boolean expression 1> ){
	<true body>
}
else if( <Boolean expression  2>){
	//first expression is false, second is true
	<true 2 body>
}
// can have more else if's here
// ...
else{
	// if all previous experessions are false
	<false body>
}

Boolean Values in C
   C does not have a Boolean type with true or false values, instead int values are used to
   represent true or false in conditional statements:
	 * 0: evaluates to false when used in a boolean expression
	 * non-zero (any positive or negative int value): evaluates to true when used in a boolean
	   expression

   The set of operators you can use in constructing boolean expressions are the following
   (listed in precedence order):
	 * Relational Operators: operands of same type, evaluate to 0:false or non-zero:true
		  + equality ==, inequality (not equal) !=, and comparison <, <=, >, >=
	 * Logical Operators: "boolean" operands evaluate to 0:false or non-zero:true
		  + logical negation !
		  + logical and && (stops at first false expression)
		  + logical or || (stops at first true expression)

   Here is an example conditional statement in C (it is always good to use parens around
   complex boolean expressions to make them easy to read):
if (y == 10)) {
	printf("y is 10");
} else if((x > 10) && (y > x)) {
	printf("y is bigger than x and 10\n");
	x = 13;
} else if ((x == 10) || (y > x+20)) {
	printf("y might be bigger than x\n");
	x = y*x;
} else {
	printf("I have no idea what the relationship between x and y is\n");
}

Loops

for loops
   For loops are different in C than they are in Python. In python for loops are iterations
   over sequences, in C for loops are more general looping constructs. The C for loop syntax
   is:
for( <initialization>; <boolean expression>; <step> ){
	<body>
}

   The rules for evaluation are:
	1. Evaluate initialization one time when first evaluate the for loop.
	2. Evaluate the boolean expression, if it is false (0), then drop out of the for loop (you
	   are done repeating the loop body statements).
	3. Evaluate the statements inside the loop body
	4. Evaluate the step expression
	5. goto step (2).

   Here is a simple example for loop to print out the values 0 through 9:
for (int i=0; i<10; i++){
	printf("%d\n", i);
}

   See forLoop1.c and forLoop2.c for more examples.

while loops
   While loop syntax in C is similar to in Python, and is evaluated similarly:
while ( <Boolean expression> ){
	<true body>
}

   The while loop checks the Boolean expression first and executes the body if true. A similar
   do-while loop executes the body first, then checks a condition and runs the loop again if
   the condition is true:
do{
	<body>
} while ( <Boolean expression> );

   In C, for loops and while loops are equivalent in power (this is not true in Python), thus
   C would only need to provide one of these looping constructs. However, for loops tend to be
   a more natural language construct for definite loops (like iterating over values in a
   list), and while loops tend to be more natural language construct for indefinite loops
   (like repeating until the user enters an even number). Therefore, C provides both.

   See whileLoop1.c and whileLoop2.c for examples.

Functions
   Use functions to break code into manageable pieces and reduce code duplication. Functions
   may take parameters as input and return a single value of a specific type. A function
   declaration specifies the function's name, return type, and the parameter list (the number
   and type of all parameters). A function definition includes the code to be executed when
   the function is called. All functions in C must be declared before they are called. This is
   typically done using a function prototype, but it can also be acomplished by having the
   function definition appear before it is called in a file.
function definition format:
---------------------------
<return type> <function name> (<parameter list>) {
	<function body>
}

parameter list format:
---------------------
<type> <parm1 name>, <type> <parm2 name>, ...,	<type> <last parm name>

   A function that does not return a value has a void return type.

   Arguments are passed to C functions by value. Thus a copy of the variables value is made
   before the body of the function executes. Any modifications to the parameters in the
   function are not visible to the callee.

   Here is an example function definition followed by a call to it:
int max(int x, int y) {
	int bigger;
	bigger = x;
	if(y > x) {
		bigger = y;
	}
	return bigger;
}

int main() {
	int a, b;
	printf("Enter two integer values: ");
	scanf("%d%d", &a, &b);
	printf("The larger value is %d\n", max(a,b));
}

   See function1.c for this and another example.

   Exercise: Implement and test a power function (for positive integer exponents only).

Arrays
   Arrays are like C's version of lists. Python provides a high-level list interface to the
   programmer that hides much of the low-level implementation details. In C, however, the
   programmer has to implement this low-level list functionality; arrays are just the
   low-level data storage without higher-level functionality like size, insert, append, etc.

   Arrays can store multiple items of the same type. For now, we will use only statically
   declared arrays, meaning we must know the total capacity (number of buckets) of the array
   at compile time, and we declare the array to be of that capacity. We cannot shrink or grow
   the array at run time (at least not yet).

   To declare an array, specify its type, name and total capacity (number of buckets):
int  arr[10];  // an array of 10 ints
char str[20];  // an array of 20 char...could be a C-style string

   Individual array elements may be accessed by indexing:
int i, num;

num = 5;
for(i=0; i < num; i++) {  // initialize the first 5 buckets of arr
	arr[i] = i;
}
arr[5] = 100;
num++;

   Notice that we declared the array to have 10 buckets, but we are only using 6 of them (our
   current list is of size 6 not 10). It is often the case when using statically declared
   arrays that there is unused capacity. Thus, we need to have a program variable that keeps
   track of the actual size of the list (num in this example).

Arrays and Functions
   To declare an array function parameter we must use the syntax int a[] (or int *a, but we
   will use this syntax later). Note we do not specify the capacity of the array parameter in
   the parameter list (the function can accept an int array of any capacity). Arrays also do
   not know their size, so if we want the function to know how many buckets are in use, we
   should also pass the size value as a parameter. For example:

void printArray(int a[], int size) {
	int i;
	for(i=0; i < size; i++) {
		printf("%d\n", a[i]);
	}
}

   To call a function with an array parameter, pass only the name of the array as the
   argument, omitting the brackets. For example:
printArray(arr, num);

   The name of the array variable is equivalent to the base address of the array (the memory
   location of its 0th bucket). This means that the argument's array buckets are NOT passed by
   value to the function (i.e. the function's parameter DOES NOT get a copy of every array
   bucket of its argument). Instead, the parameter gets the value of the memory location of
   the first bucket in the argument array (the base address of the array). The implications of
   this are that when array buckets are modified inside the called function (e.g. a[2] = 8),
   they also modify the contents of the corresponding bucket in the argument (i.e. arr[2] is
   now 8). This is becuase the parameter REFERS TO the same array storage locations as its
   argument.

   Question:What happens if you go beyond the bounds of an array in C?
int array[10];
array[10] = 100;  // 10 is not a valid index into the array of 10 int buckets

   Answer: Unexpected program behavior. It could lead to your program crashing, it could
   change another variable's value, or it could have no effect on your program's behavior; it
   is a program bug that may or may not show up as buggy program behavior. It is up to the C
   programmer to ensure that index values are valid and to avoid accessing array buckets
   beyond the bounds of an array.

   The files array1.c and array2.c have some example uses of arrays.

   Exercise: complete and test the function minimum in array2.c.

   Example: Here [**1] is an example function call and a stack drawing showing an example of an
   array parameter.
--------------------------------------------------------------------------------------------------------------
[**1]
Below is an example of passing a statically declared array, to a function. All arguments are passed by value
to the function. However, becasue the value of the array name argument is the base address of the array
argument, the parameter refers to the same array buckets as the argument. Thus, the function can modify the 
bucket values in the passed array, whereas it cannot modify any values of the struct or int arguments.

After the example code is a drawing of the stack right before the return from kooky.

The program:

#include <stdio.h>
#include <string.h>

// a function prototype:
void kooky(int a[], int n);

/**********************************************************
 * main function:
 */
int main() {

	int x, i;
	int arr[5];

	for(i=0; i < 5; i++) {
	   arr[i] = i;
	}
	for(i=0; i < 5; i++) {
	   printf("arr[%d] = %d\n", i, arr[i]);  // bucket values: 0 1 2 3 4 
	}

	kooky(arr, 5);	 // array argument: passes value of base address of array

	for(i=0; i < 5; i++) {
	   printf("arr[%d] = %d\n", i, arr[i]);   // bucket values: 0 1 4 9 16
	}
}

/**********************************************************
 * kooky function definition:  what does this function do?
 *	 a: an array of int values
 *	 n: size of the array
 */
void kooky(int a[], int n) {
	int i;

	for(i=0; i < n; i++) {
	   a[i] = a[i]*a[i];
	}
	//**** THE STACK IS DRAWN RIGHT BEFORE THE return STATMENT IS EXECUTED
	return;
}
/**********************************************************/

The stack right before kooky returns:


                |===========================================|     
kooky:          |        -------                            |
                |     i |    5  |                           |
                |        -------                            | 
                |         -------                           |  
                |     n  |    5  |                          | 
                |         -------                           |
                |         ---------                         |
                |      a |    *    |                        |
                |         ----|----                         |
                ==============|=============================|
main:           |             |                             |
                |             |                             | 
                |             |                             | 
                |             |                             | 
                |             \/                            |
                |             -----------------------       |
                |         arr | 0 | 1 |  4 | 9 | 16 |       |
                |             -----------------------       |
                |             -------                       |
                |           x | 10  |                       |
                |             -------                       |
                |             -------                       |
                |         i  |    5  |                      |
                |             -------                       | 
                |===========================================| 
                                  STACK 
--------------------------------------------------------------------------------------------------------------

Strings
   Strings in C are just arrays of characters terminated by a special null character value
   '\0'. Not every array of char is used as a C string, but every string is an array of char.
   C has a string library that contains functions for manipulating C strings. One thing to
   keep in mind as you use the string library is that you are responsible for allocating the
   space for the underlying char array, and that the terminating '\0' character needs to be
   included in that space. For example, to store the string "hi", you need an array of at
   least 3 chars (one to store 'h', one to store 'i', and one to store '\0'). The string
   library functions will determine the end of a string by searching for the '\0' character,
   they also will add that character to the end of any string they initialize for you (e.g.
   strcpy will null terminate the destination string). Here is a very simple example:
#include <string.h>

int main() {
	char str1[10];
	char str2[10];
	str1[0] = 'h';
	str1[1] = 'i';
	str1[2] = '\0';
	printf("%s %d\n", str1, strlen(str1));	// prints hi 2 to stdout
	strcpy(str2, str1); // strcpy copies the contents of str1 to str2
	printf("%s\n", str2);  // prints hi to stdout
}

   See my Strings in C[**2] documentation for more string and string library examples. In
   particular look at the string library functions strlen, strcpy and strcmp. (note: some of
   the example code here use dynamically allocated strings, which we have not yet learned).
--------------------------------------------------------------------------------------------------------------
[**2]
Strings in C
A string in C is an array of char values terminated by a special null character value '\0'. For example, here
is a statically declared string that is initialized to "hi":

	char str[3];	// need space for chars in str, plus for terminating '\0' char
	str[0] = 'h';
	str[1] = 'i';
	str[2] = '\0';
	printf("%s\n", str);   // prints hi to stdout 

C library functions for strings (string.h)
C provides a library for strings. C string library functions do not allocate space for the strings they
manipulate, nor do they check that you pass in valid strings; it is up to your program to allocate space for
the strings that the C string library will use. Calling string library functions with bad address values will
cause a segfault or "strange" memory access errors.

Here is a description of some of the functions in the Stardard C string libarary (string.h) for manipulating 
strings:

#include <string.h>

int strlen(char *s);   // returns the length of the string 
                       // not including the null character

char *strcpy(char *dst, char *src);  // copies string src to string dst up 
                                     // unitl first '\0' character in src
                                     // returns a ptr to the destination string
                                     // it adds '\0' to end of the copy

char *strncpy(char *dst, char *src, int size);  // copies up to first '\0' or size characters 
                                                // from src to dst

int strcmp(char *s1, char *s2);  // returns 0 if s1 and s2 are the same strings
                                 // a value < 0 if s1 is less than s2 
                                 // a value > 0 if s1 is greater than s2 

char *strcat(char *dst, char *src)  // append chars from src to end of dst 
                                    // returns ptr to dst, it adds '\0' to end
char *strncat(char *dst, char *src, int size);

char *strstr(char *string, char *substr);  // locates a substering inside a string
                                           // returns a pointer to the begining of substr in string
                                           // returns NULL if substr not in string

char *strchr(const char *s, int c);        // locate a character in a string
char *strtok(char *s, const char *delim);  // extract tokens from strings

In addition there are some functions in stdlib.h for converting between strings and other C types:

#include <stdlib.h>

int atoi(const char *nptr);                // convert a string to an integer  
                                           // "1234" to int value 1234
double atof(const char *nptr);

To get on-line documentation of C functions, use Unix's man utility:

		% man strcpy

Using strings in C programs
One thing to keep in mind when allocating space for strings is that you need to allocate one more space than
the number of characters in the string so that you can store the terminating '\0' character.

Here are some examples of using these functions:

int main() {
	int size;
	char *static_str = "hello there";	
	char *new_str = NULL;
	char *ptr = NULL;

	printf("%s\n", static_str);  // prints "hello there"
	size = strlen(static_str);
	new_str = malloc(sizeof(char)*(size+1)); // need space for '\0'
	if(new_str == NULL) { 
		Error("malloc failed\n"); 
	}
	strncpy(new_str, static_str, 6);
	strcat(new_str, "yo");
	printf("%s\n", new_str);	// prints "hello yo"
	if((ptr = strstr(new_str, "yo")) != NULL) {
		printf("%s\n", ptr);	// prints "yo"
	}
	free(new_str);
}
--------------------------------------------------------------------------------------------------------------

Structs Part 1
   C is not an object-oriented language, and thus does not have support for classes. It does,
   however, have support for defining structured types (like the data part of classes).

   A struct is a type used to represent a heterogeneous collection of data; it is a mechanism
   for treating a set of different types as a single, coherent unit. For example, a student
   may have a name, age, gpa, and graduation year. A struct type can be defined to store these
   four different types of data associated with a student.

   In general, there are three steps to using structured types in C programs:
	1. Define a new struct type representing the structure.
	2. Declare variables of the struct type
	3. Use DOT notation to access individual field values

Defining a struct type
   struct type definitions should appear near the top of a program file, outside of any
   function definition. There are several different ways to define a struct type but we will
   use the following:
struct <struct name> {
	<field 1 type> <field 1 name>;
	<field 2 type> <field 2 name>;
	<field 3 type> <field 3 name>;
	...
};

   Here is an example of defining a new type 'struct studentT' for storing student data:
struct studentT {
	char name[64];
	int age;
	int grad_yr;
	float gpa;
};

// with structs, we often use typedef to define a shorter type name
// for the struct; typedef defines an alias for a defined type
// ('studentT' is an alias for 'struct studentT')
typedef struct studentT studentT;

Declaring variables of struct types
   Once the type has been defined, you can declare variables of the structured type:
struct studentT  student1;   // student1 is a struct studentT
studentT  student2;          // student2 is also a struct studentT
                             // (we are just using the typedef alias name)

studentT cs31[50];           // an array of studentT structs: each bucket
                             // stores a studentT struct

Accessing field values
   To access field values in a struct, use dot notation:
<variable name>.<field name>

   It is important to think very carefully about type when you use structs to ensure you are
   accessing field values correctly based on their type. Here are some examples:
student1.grad_yr = 2017;
student1.age = 18 + 2;
strcpy(student1.name, "Joseph Schmoe");
student2.grad_yr = student1.grad_yr;
cs31[0].age = student1.age;
cs31[5].gpa = 3.56;

   structs are lvalues, meaning that you can use them on the left-hand-side of an assignment
   statement, and thus, can assign field values like this:
student2 = student1;  // student2 field values initialized to the value of
					  // student1's corresponding field values
cs31[i] = student2;

   Question: For each expression below, what is its type? Are any invalid? (here are the
   [16]answers)
   (1) student1
   (2) student1.grad_yr
   (3) student1.name
   (4) student1.name[2]
   (5) cs31
   (6) cs31[4]
   (7) cs31[4].name
   (8) cs31[4].name[5]
--------------------------------------------------------------------------------------------------------------
[16]answers
       Expression                      Type
       ----------                      ----
   (1) student1                        struct studentT  
   (2) student1.grad_yr                int
   (3) student1.name                   array of char
   (4) student1.name[2]                char
   (5) cs31                            array of struct studentT
   (6) cs31[4]                         struct studentT
   (7) cs31[4].name                    array of char 
   (8) cs31[4].name[5]                 char
--------------------------------------------------------------------------------------------------------------

Passing structs to functions
   When structs are passed to functions, they are passed BY VALUE. That means that the
   function will receive a COPY OF the struct, and that copy is what is manipulated from
   within the function. All field values in the copy will have the exact same values as the
   field values of the original struct - but the original struct and the copy occupy different
   locations in memory. As such, changing a field value within the function will NOT change
   the corresponding field value in the original struct that was passed in.

   If one of the fields in a struct is a statically declared array (like the name field in the
   studentT struct), the parameter gets a copy of the entire array (every bucket value). This
   is because the complete statically declared array resides within the struct, and the entire
   struct is copied over as a unit. You can think of the struct as a chunk of memory (0's and
   1's) that is copied over to the parameter without anything being added to it or taken out.
   So, a function passed student1 CANNOT change any of the contents of the student1 variable
   (because the function is working with a COPY of student1, and thus the student.name array
   in the copy starts at a different memory location than the student.name array of the
   original struct). This may seem odd given how arrays are passed to functions (an array
   parameter does not get a copy of every array bucket of its argument, instead it REFERS to
   the same array as the argument array). This seemingly different behavior is actually
   consistent with the rule that a parameter gets THE VALUE of its argument. It is just that
   the value of an array argument (the base address of the array) is different than the value
   of an int, float, struct, ..., argument. For example, here are some expressions and their
   values:

Argument Expression      Expression's Value (Parameter gets this value)
--------------------     --------------------------------------------
student1                 {"Joseph Schmoe", 20, 2017, 3.56}
student1.gpa             3.56
cs31                     base address of the cs31 array
student1.name            base address of the name field array
student1.name[2]         's'

   Only when the value passed to a function is an address of a memory location can the
   function modify the contents of the memory location at that address: a function passed
   student1 (a struct value) CANNOT change any of the contents of the student1 variable; but a
   function passed student1.name (the base address of an array) CAN change the contents of the
   buckets of the name field - because when student1.name is passed in, what is being passed
   in is the memory location of the array, NOT a copy of the entire array.

   Example: [17]Here is an example function call with a stack drawing showing how different
   types are passed.
-------------------------------------------------------------------------------------------------------------
[17]Stacj:

Below is an example of passing a struct, a statically declared array, and two ints to a function. All 
arguments are passed by value to the function. However, becasue the value of the array name argument is the 
base address of the array argument, the parameter refers to the same array buckets as the argument. Thus, the
function can modify the bucket values in the passed array, whereas it cannot modify any values of the struct
or int arguments.

After the example code is a drawing of the stack right before the return from crazy_function.

The program:

#include <stdio.h>
#include <string.h>

struct personT {
	char name[32];
	int  age;
};

// a function prototype:
void crazy_function(int i_val, struct personT per, int a[], int n);

//
// main function:
//
int main() {

	struct personT person;
	int x, i;
	int arr[5];

	for(i=0; i < 5; i++) {
	   arr[i] = i;
	}
	for(i=0; i < 5; i++) {
		printf("arr[%d] = %d\n", i, arr[i]);  // bucket values: 0 1 2 3 4
	}
	x = 10;
	strcpy(person.name, "Tia");
	person.age = 21;

	crazy_function(x, person, arr, 5);

	for(i=0; i < 5; i++) {
		printf("arr[%d] = %d\n", i, arr[i], 5); // bucket values: 0 1 4 9 16
	}
	printf("x = %d age = %d name = %s\n", x, person.age, person.name);	// values:	10 21 Tia
}
//
// crazy function definition:
//
void crazy_function(int i_val, struct personT per, int a[], int n) {
	int i;

	for(i=0; i < n; i++) {
		a[i] = a[i]*a[i];
	}
	strcpy(per.name, "Ace");
	per.age = 18;
	i_val = 100;

	//**** THE STACK IS DRAWN RIGHT BEFORE THE return STATMENT IS EXECUTED
	return;
}

The stack right before crazy_function returns:

                                      STACK

                |=====================================================|   
crazy_function: |         -------                                     |
                |       i |  5  |                                     |
                |         -------                                     | 
                |         -------                                     |
                |   i_val | 100 |                                     |
                |         -------                                     |
                |        ------------------------------------------   |
                |    per | name : |'A'| 'c'| 'e' |'\0'|  ...  |   |   |
                |        ------------------------------------------   |
                |        |  age : |            18                 |   |
                |        ------------------------------------------   |
                |        ---------                                    |
                |      a |   *-- |--------------------------------------------
                |        ---------                                    |      |
                |         -------                                     |      |
                |      n  |  5  |                                     |      |
                |         -------                                     |      |
                |=====================================================|      |
      main:     |                                                     |      |
                |                                                     |      | 
                |         --------------------------------------------------- 
                |         |                                           | 
                |        \/                                           |
                |        -----------------------                      |
                |    arr | 0 | 1 |  4 | 9 | 16 |                      |
                |        -----------------------                      |
                |         -------                                     |
                |       x | 10  |                                     |
                |         -------                                     |
                |         -------                                     |
                |       i |  5  |                                     |
                |         -------                                     | 
                |        ------------------------------------------   |
                | person | name : |'T'| 'i'| 'a' |'\0'|  ...  |   |   |
                |        ------------------------------------------   |
                |        |  age : |            21                 |   |
                |        ------------------------------------------   |
                |                                                     |
                |=====================================================| 

--------------------------------------------------------------------------------------------------------------

   See struct.c for more examples.
   Exercise: implement and test two functions in this file: printStudent and initStudent.

lvalues
   An lvalue is an expression that can appear on the left hand side of an assignment
   statement. In C, single variables or array elements are lvalues. The following example
   illustrates valid and invalid C assignment statements based on lvalue status:
struct studentT  student1;
studentT  student2;
int x;
char arr[10], ch;

x = 10;                         // valid C: x is an lvalue
ch = 'm';                       // valid C: ch is an lvalue
student1 = student2;            // valid C: student1 is an lvalue
arr[3] = ch;                    // valid C: arr[3] is an lvalue
x + 1 = 8;                      // invalid C: x+1 is not an lvalue
arr = "hello there";            // invalid C: arr is not an lvalue
arr = student1.name;            // invalid C: arr is not an lvalue
student1.name = student2.name;  // invalid C: name (an array of char) is not an lvalue



---
https://www.cs.swarthmore.edu/~newhall/cs31/resources/C-structs_pointers.php

Intro to C for CS31 Students

Part 2: structs & pointers

Contents:
	1. Structs
	2. Pointers
	3. Pointers and Functions C style "pass by referece"
	4. Dynamic Memory Allocation (malloc and free)
	5. Pointers to Structs

   Part 1 contains C basics, including functions, static arrays, I/O
   Links to other C programming Resources

C Stucts and Pointers
   This is the second part of a two part introduction to the C programming language. It is
   written specifically for CS31 students. The first part covers C programs, compiling and
   running, variables, types, operators, loops, functions, arrays, parameter passing (basic
   types and arrays), standard I/O (printf, scanf), and file I/O. It also includes links to
   other C programming resources:
   Introduction to C programming for CS31 students Part 1

   Code examples on this page can be copied over from my public/cs31/C_examples directory:
   # if you don't have a cs31 subdirectory, create one first:
   mkdir cs31
   # copy over my C example files into your cs31 subdirectory:
   cd cs31
   cp -r /home/newhall/public/cs31/C_examples  .
   # cd into your copy, run make to compile
   cd C_examples
   make
   ls

Structs
   C is not an object-oriented language, and thus does not have support for classes. It does,
   however, have support for defining structured types (like the data part of classes).

   A struct is a type used to represent a heterogeneous collection of data; it is a mechanism
   for treating a set of different types as a single, coherent unit. For example, a student
   may have a name, age, gpa, and graduation year. A struct type can be defined to store these
   four different types of data associated with a student.

   In general, there are three steps to using structured types in C programs:
	1. Define a new struct type representing the structure.
	2. Declare variables of the struct type
	3. Use DOT notation to access individual field values

Defining a struct type
   struct type definitions should appear near the top of a program file, outside of any
   function definition. There are several different ways to define a struct type but we will
   use the following:
struct <struct name> {
	<field 1 type> <field 1 name>;
	<field 2 type> <field 2 name>;
	<field 3 type> <field 3 name>;
	...
};

   Here is an example of defining a new type 'struct studentT' for storing student data:
struct studentT {
	char name[64];
	int age;
	int grad_yr;
	float gpa;
};

// with structs, we often use typedef to define a shorter type name
// for the struct; typedef defines an alias for a defined type
// ('studentT' is an alias for 'struct studentT')
typedef struct studentT studentT;

Declaring variables of struct types
   Once the type has been defined, you can declare variables of the structured type:
struct studentT  student1;   // student1 is a struct studentT
studentT  student2;          // student2 is also a struct studentT
                             // (we are just using the typedef alias name)

studentT cs31[50];           // an array of studentT structs: each bucket
                             // stores a studentT struct

Accessing field values
   To access field values in a struct, use dot notation:
<variable name>.<field name>

   It is important to think very carefully about type when you use structs to ensure you are
   accessing field values correctly based on their type. Here are some examples:
student1.grad_yr = 2017;
student1.age = 18 + 2;
strcpy(student1.name, "Joseph Schmoe");
student2.grad_yr = student1.grad_yr;
cs31[0].age = student1.age;
cs31[5].gpa = 3.56;

   structs are lvalues, meaning that you can use them on the left-hand-side of an assignment
   statement, and thus, can assign field values like this:
student2 = student1;  // student2 field values initialized to the value of
                      // student1's corresponding field values
cs31[i] = student2;

   Question: For each expression below, what is its type? Are any invalid? (here are the
   [9]answers)
   (1) student1
   (2) student1.grad_yr
   (3) student1.name
   (4) student1.name[2]
   (5) cs31
   (6) cs31[4]
   (7) cs31[4].name
   (8) cs31[4].name[5]
--------------------------------------------------------------------------------------------------------------
[9]answers

       Expression                      Type
       ----------                      ----
   (1) student1                        struct studentT
   (2) student1.grad_yr                int
   (3) student1.name                   array of char
   (4) student1.name[2]                char
   (5) cs31                            array of struct studentT
   (6) cs31[4]                         struct studentT
   (7) cs31[4].name                    array of char
   (8) cs31[4].name[5]                 char
--------------------------------------------------------------------------------------------------------------
Passing structs to functions
   When structs are passed to functions, they are passed BY VALUE. That means that the
   function will receive a COPY OF the struct, and that copy is what is manipulated from
   within the function. All field values in the copy will have the exact same values as the
   field values of the original struct - but the original struct and the copy occupy different
   locations in memory. As such, changing a field value within the function will NOT change
   the corresponding field value in the original struct that was passed in.

   If one of the fields in a struct is a statically declared array (like the name field in the
   studentT struct), the parameter gets a copy of the entire array (every bucket value). This
   is because the complete statically declared array resides within the struct, and the entire
   struct is copied over as a unit. You can think of the struct as a chunk of memory (0's and
   1's) that is copied over to the parameter without anything being added to it or taken out.
   So, a function passed student1 CANNOT change any of the contents of the student1 variable
   (because the function is working with a COPY of student1, and thus the student.name array
   in the copy starts at a different memory location than the student.name array of the
   original struct). This may seem odd given how arrays are passed to functions (an array
   parameter does not get a copy of every array bucket of its argument, instead it REFERS to
   the same array as the argument array). This seemingly different behavior is actually
   consistent with the rule that a parameter gets THE VALUE of its argument. It is just that
   the value of an array argument (the base address of the array) is different than the value
   of an int, float, struct, ..., argument. For example, here are some expressions and their
   values:

Argument Expression      Expression's Value (Parameter gets this value)
--------------------     --------------------------------------------
student1                 {"Joseph Schmoe", 20, 2017, 3.56}
student1.gpa             3.56
cs31                     base address of the cs31 array
student1.name            base address of the name field array
student1.name[2]         's'

   Only when the value passed to a function is an address of a memory location can the
   function modify the contents of the memory location at that address: a function passed
   student1 (a struct value) CANNOT change any of the contents of the student1 variable; but a
   function passed student1.name (the base address of an array) CAN change the contents of the
   buckets of the name field - because when student1.name is passed in, what is being passed
   in is the memory location of the array, NOT a copy of the entire array.

   Example: [10]Here is an example function call with a stack drawing showing how different
   types are passed.
--------------------------------------------------------------------------------------------------------------
[10]Stack:

Below is an example of passing a struct, a statically declared array, and two ints to a function. All 
arguments are passed by value to the function. However, becasue the value of the array name argument is the 
base address of the array argument, the parameter refers to the same array buckets as the argument. Thus, the
function can modify the bucket values in the passed array, whereas it cannot modify any values of the struct
or int arguments.

After the example code is a drawing of the stack right before the return from crazy_function.

The program:

#include <stdio.h>
#include <string.h>

struct personT {
	char name[32];
	int  age;
};

// a function prototype:
void crazy_function(int i_val, struct personT per, int a[], int n);

//
// main function:
//
int main() {

	struct personT person;
	int x, i;
	int arr[5];

	for(i=0; i < 5; i++) {
	   arr[i] = i;
	}
	for(i=0; i < 5; i++) {
		printf("arr[%d] = %d\n", i, arr[i]);  // bucket values: 0 1 2 3 4
	}
	x = 10;
	strcpy(person.name, "Tia");
	person.age = 21;

	crazy_function(x, person, arr, 5);

	for(i=0; i < 5; i++) {
		printf("arr[%d] = %d\n", i, arr[i], 5); // bucket values: 0 1 4 9 16
	}
	printf("x = %d age = %d name = %s\n", x, person.age, person.name);	// values:	10 21 Tia
}
//
// crazy function definition:
//
void crazy_function(int i_val, struct personT per, int a[], int n) {
	int i;

	for(i=0; i < n; i++) {
		a[i] = a[i]*a[i];
	}
	strcpy(per.name, "Ace");
	per.age = 18;
	i_val = 100;

	//**** THE STACK IS DRAWN RIGHT BEFORE THE return STATMENT IS EXECUTED
	return;
}

The stack right before crazy_function returns:

                                      STACK

                |=====================================================|   
crazy_function: |         -------                                     |
                |       i |  5  |                                     |
                |         -------                                     | 
                |         -------                                     |
                |   i_val | 100 |                                     |
                |         -------                                     |
                |        ------------------------------------------   |
                |    per | name : |'A'| 'c'| 'e' |'\0'|  ...  |   |   |
                |        ------------------------------------------   |
                |        |  age : |            18                 |   |
                |        ------------------------------------------   |
                |        ---------                                    |
                |      a |   *-- |--------------------------------------------
                |        ---------                                    |      |
                |         -------                                     |      |
                |      n  |  5  |                                     |      |
                |         -------                                     |      |
                |=====================================================|      |
      main:     |                                                     |      |
                |                                                     |      | 
                |         --------------------------------------------------- 
                |         |                                           | 
                |        \/                                           |
                |        -----------------------                      |
                |    arr | 0 | 1 |  4 | 9 | 16 |                      |
                |        -----------------------                      |
                |         -------                                     |
                |       x | 10  |                                     |
                |         -------                                     |
                |         -------                                     |
                |       i |  5  |                                     |
                |         -------                                     | 
                |        ------------------------------------------   |
                | person | name : |'T'| 'i'| 'a' |'\0'|  ...  |   |   |
                |        ------------------------------------------   |
                |        |  age : |            21                 |   |
                |        ------------------------------------------   |
                |                                                     |
                |=====================================================| 

-------------------------------------------------------------------------------------------------------------
lvalues
   An lvalue is an expression that can appear on the left hand side of an assignment
   statement. In C, single variables or array elements are lvalues. The following example
   illustrates valid and invalid C assignment statements based on lvalue status:
struct studentT  student1;
studentT  student2;
int x;
char arr[10], ch;

x = 10;                         // valid C: x is an lvalue
ch = 'm';                       // valid C: ch is an lvalue
student1 = student2;            // valid C: student1 is an lvalue
arr[3] = ch;                    // valid C: arr[3] is an lvalue
x + 1 = 8;                      // invalid C: x+1 is not an lvalue
arr = "hello there";            // invalid C: arr is not an lvalue
arr = student1.name;            // invalid C: arr is not an lvalue
student1.name = student2.name;  // invalid C: name (an array of char) is not an lvalue

   See struct.c for more examples.
   Exercise: implement and test two functions in this file: printStudent and initStudent.

C pointer variables
   A pointer variable stores the address of a memory location that stores a value of the type
   to which it points ("a level of indirection"). Here is a picture of a pointer variable ptr
   pointing to a memory storage location that stores value an int value 12:
         -----          -----
     ptr | *-|--------->| 12 |
         -----          -----

   Through a pointer variable (ptr) the value stored in the location it points to (12) can be
   indirectly be accessed.

   Pointer variables are used most often in C programs for:
	1. "pass-by-reference" function parameters: to write functions that can modify an
	   argument's value.
	2. Dynamic Memory Allocation (for arrays in particular): to write programs that allocate
	   space (or re-allocate space) as the program runs. This is useful when sizes of data
	   structures like arrays are not known at compile time, and to support growing the size
	   of data structures as the program runs.

Rules for using pointer variables
   The rules for using pointer variable are similar to regular variables, you just need to
   think about two types: (1) the type of the pointer variable; and (2) the type stored in the
   memory address to which it points.
	1. First, declare a pointer variable using type_name *var_name:
int *ptr;	// stores the memory address of an int (ptr "points to" an int)
char *cptr; // stores the memory address of a char (cptr "points to" a char)

	   Think about Type
	   ptr and cptr are both pointers but their specific type is different:
		  + ptr's type is "pointer to int". It can point to a memory location that stores an
			int value.
		  + cptr's type is "pointer to char" It can point to a memory location that stores an
			char value, and through cptr we can indirectly access that char value.
	2. Next, initialize the pointer variable (make it point to something). Pointer variables
	   store addresses. Initialize a pointer to the address of a storage location of the type
	   to which it points. One way to do this is to use the ampersand operator on regular
	   variable to get its address value:
int x;
char ch;
ptr = &x;	 // ptr get the address of x, pointer "points to" x
              ------------          ------
          ptr | addr of x|--------->| ?? |  x
              ------------          ------
cptr = &ch;  // ptr get the address of ch, pointer "points to" ch
cptr = &x;	// ERROR!  cptr can hold a char address only (it's NOT a pointer to an int)


	   All pointer variable can be set to a special value NULL. NULL is not a valid address
	   but it is useful for testing a pointer variable to see if it points to a valid memory
	   address before we access what it points to:
ptr = NULL;             ------                    ------ 
cptr = NULL;       ptr | NULL |-----|       cptr | NULL |----|
                        ------                    ------ 
	3. Use the pointer variable:
		  + make it point to a location (and you can change which location it points to)
		  + Use *var_name to dereference the pointer to access the value in the location that
			it points to.
	   Some examples:
int *ptr1, *ptr2, x, y;
x = 8;
ptr1 = NULL;
ptr2 = &x;           ------------           ------
                ptr2 | addr of x|--------->|  8  |  x
                     ------------           ------
*ptr2 = 10;    // dereference ptr2: "what ptr2 points to gets 10"
                     ------------           ----- 
                ptr2 | addr of x|--------->| 10  |  x
                     ------------           ----- 

y = *ptr2 + 3;  // dereference ptr2: "y gets what ptr2 points to plus 3"
                   ----- 
                   ----- 

ptr1 = ptr2;   // ptr1 gets address value stored in ptr2
                     ------------            ----- 
                ptr2 | addr of x |--------->| 10  |  x
                     ------------            ----- 
                                              /\ 
                     ------------              | 
                ptr1 | addr of x |--------------
                     ------------             

// TODO: finish tracing through this code and  show what is printed
*ptr1 = 100;
ptr1 = &y;
*ptr1 = 80;
printf("x = %d y = %d\n", x, y);
printf("x = %d y = %d\n", *ptr2, *ptr1);

   Be careful about type when using pointer variables (drawing pictures helps):
ptr = 20;        // ERROR?  this assigns ptr to point to address 20
*ptr = 20;       // this assigns 20 the value pointed to by ptr

   What happens if you dereference an pointer variable that does not contain a valid address:
ptr = NULL;
*ptr = 6;	 // CRASH!	your program crashes with a segfault (a memory fault)

ptr = 20;
*ptr = 6;	 // CRASH!	segfault (20 is not a valid address)

   This is one reason to initialize pointer variables to NULL: you can test for NULL and not
   dereference in your program:
if(ptr != NULL) {
	*ptr = 6;
}

Pointers and Functions "pass by reference"
   Pointers allow a way to write functions that can modify their arguments' values: the C way
   of implementing Pass by Reference. We have actually already seen this with array
   parameters: the function parameter gets the value of the base address of the array (it
   points to the same array as its argument) and thus the function can modify the values
   stored in the array buckets. We can use this same idea in general to write a function that
   can modify its argument's value. The steps are:
	1. declare the function parameter to be a pointer to the variable type
   int change_value(int *input) {

	2. pass in the address of the argument
	int x;
	change_value(&x);

	3. in the function, dereference the parameter to change the argument's value
	*input = 100;  // what input points to (x's location) gets 100

   Try out:
	1. Look at a program that does C style pass by reference:
vim passbyreference.c

	   Try running it and see if you understand what is happening and why.
	   Draw the call stack for the first call to this function:
		  + where are variables a and b located on the stack?
		  + where are the parameter values located?
		  + what values does each parameter get?
		  + and what does this mean with respect to the value of each argument after the call?
	2. Implement a program with a swap function that swaps the values stored in its two
	   arguments. Make some calls to it in main to test it out.

--------------------------------------------------------------------------------------------------------------
[12]Here are the answers

 passbyreference.c Stack diagram

                             STACK

                |==============================|   
  arg_modifier: |                              |
                |         ---------            |
                |       y |   *-- |--------------------
                |         ---------            |      |
                |         -------              |      |
                |       x | 10 |               |      |
                |         -------              |      |
                |==============================|      |
   main:        |                              |      |
                |                              |      | 
                |          ---------------------------- 
                |          |                   | 
                |         \/                   |
                |         ------               |
                |       b | 5  |               |
                |         ------               |
                |          -----               |
                |       a | 2  |               |
                |          -----               |
                |==============================| 

	a and b are located in main's stack frame
	in arg_modifier's stack from
	y gets the address of the second argument, x gets the value of the first
	the value of the first argument cannot be modified by the function. the value of the second argument can. 

Here is a swap function: try it out if you do not understand how it works:

// do you understand why swap is a void function?
void swap(int *v1, int *v2) {
	ent temp;
	temp = *v1;
	*v1 = *v2;
	*v2 = temp;
}

int main() {
	int x, y;
	x = 10;
	y = 50;
	printf("x = %d y = %d\n", x, y);  // prints x = 10 y = 50
	swap(&x, &y);
	printf("x = %d y = %d\n", x, y);  // prints x = 50 y = 10
	return 0;
}

--------------------------------------------------------------------------------------------------------------

   (note: technically, everything in C is passed by value; C-style pass-by-reference is just
   passing the value of an address (a pointer) to a function as opposed to passing the value
   of an int or float or ...)

Dynamic Memory Allocation
   A common uses of pointer variables is to use them to point to memory that your program
   allocates at runtime. This is very useful for writing programs where the size of an array
   or other data structure is not know until runtime, or that may grow or shrink over the
   lifetime of a run of a program.

malloc and free
   malloc and free are functions for allocating and deallocating memory in the Heap. The Heap
   is a portion of program memory that is separate from the stack. No variables are allocated
   in the heap, but chunks of anonymous memory can be allocated and its address can be
   assigned to a global or local pointer variable.

   Heap memory must be explicitly allocated and deallocated by your program.

	 * To allocate Heap memory, call malloc passing in the total number of bytes of contiguous
	   heap memory you want to allocate. malloc returns the base address of this heap memory
	   to the caller or NULL on error.
int *p;
p = (int *)malloc(4);  // allocate 4 bytes of heap memory and assign addr to p
*p = 6;   // the heap memory p points to gets the value 6

	   malloc's return type is a bit odd. It is a void * which means it is a pointer to a
	   non-specific type (or to any type). Because of this, we re-cast the return type to be a
	   pointer to the specific type we are using (int *) in the example above.
	 * Sometimes malloc fails, so you should always test its return value for NULL before
	   dereferencing the pointer value:
p = (int *)malloc(4);
if(p == NULL) {
   printf("Bad malloc error\n");
   exit(1);   // or return from this function or ...
}
*p = 6;

	 * Instead of passing the exact number of bytes to malloc, use the sizeof function in an
	   expression instead (sizeof([type name])):
p = (int *)malloc(sizeof(int));

	 * malloc is often used to allocate an array of some type on the heap, by specifying the
	   total number of bytes in the array using an expression of (size of the type of each
	   bucket and the number of buckets:
int *arr;
char *c_arr;

// allocate an array of 20 ints on the heap:
arr = (int *)malloc(sizeof(int)*20);

// allocate an array of 10 chars on the heap:
c_arr = (char *)malloc(sizeof(char)*10);

	 * Because the pointer variable stores the base address of the array allocated in the
	   heap, you can use array syntax to access its buckets:
arr[0] = 8;  // these two statements are identical: both put 8 in bucket 0
*arr = 8;
arr[3] = 10;  // puts 10 in bucket 3 of the array pointed to by arr

	   [13]Here is a picture of what this looks like in memory. Note that the Stack and the
	   Heap are separate parts of memory.
--------------------------------------------------------------------------------------------------------------
[13]Here is a picture ...

Heap Memory Example
For the execution of this program fragment:

int *p, *arr;
char *c_arr;

p = (int *)malloc(sizeof(int));
arr = (int *)malloc(sizeof(int)*20);
c_arr = (char *)malloc(sizeof(char)*10);

if((p == NULL) || (arr == NULL) || (c_arr == NULL)) {
	printf("malloc error\n");
	exit(1);
}

*p = 6;
*arr = 8;
arr[3] = 10;
strcpy(c_arr, "He");
c_arr[1] = 'i';

The contents of memory will look like this:

            STACK                                    HEAP

      |===============|                |====================================|
main: |               |                |                                    |
      |       ----    |                |    ----                            |
      |    p | *-------------------------->| 6 |                            |
      |       ----    |                |    ----                            |
      |      ----     |                |    -------------------------       |
      |  arr | *-------------------------->| 8 | ? | ? | 10 | ? |...|       |
      |      ----     |                |    -------------------------       |
      |       ----    |                |    -------------------------       |
      | c_arr | *-------------------------->| 'H' | 'i' | '\0' | ...|       | 
      |       ----    |                |    -------------------------       |
      |===============|                |====================================|  

--------------------------------------------------------------------------------------------------------------

	 * When you are done using the memory you allocated with malloc, you need to explicitly
	   deallocate it by calling the free function (it is also good to set the pointer's value
	   to NULL after calling free:
free(p);
free(arr);
free(c_arr);
p = NULL;
arr = NULL;
c_arr = NULL;

   See my [14]Strings in C page for some examples of dynamically allocated strings and the
   string library (when dynamically allocating space for strings it is important to allocate
   enough space to store all chars in the string including the terminating null char)

Pointers, the Heap, and Functions
   Passing a pointer value to a function has the same semantics as passing the address of a
   variable to a function: the function can modify the value pointed to.

   As you write functions that take pointer values as parameters, it if very important to
   think about the type of argument you are passing. This will help you figure out the syntax
   for how to pass the argument value and the correct matching function parameter type.

   Here is an example of passing a malloc'ed array to a function:
int main() {
	int *arr1;
	arr1 = malloc(sizeof(int)*10);
	if(!arr1) {
		printf("malloc error\n");
		exit(1);
	}
	init_array(arr1, 10);
	...
}

void init_array(int *arr, int size) {
	int i;
	for(i=0; i< size; i++) {
		arr[i] = i;
	}
}

   Here is a picture of what this looks like in memory. This should look very familiar to
   passing statically declared arrays, just notice the difference in which part of memory the
   array is located.

Try out:

   Given the following program:
	1. Trace through the execution and draw the stack at the location shown in function blah.
	2. what are main's arr bucket values at the point the stack is drawn?
	3. What is the output of this program when run?

   Note how the argument values are passed to functions foo and blah as you step through this.
#include <stdio.h>
#include <stdlib.h>

void foo(int *b, int c, int *arr, int n) ;
void blah(int *r, int s);

int main() {
	int x, y, *arr;
	arr = (int *)malloc(sizeof(int)*5);
	if(arr == NULL) {
		exit(1);   // should print out nice error msg first
	}
	x = 10;
	y = 20;
	printf("x = %d y = %d\n", x, y);
	foo(&x, y, arr, 5);
	printf("x = %d y = %d arr[0] = %d arr[3] = %d\n",
		x, y, arr[0],arr[3]);
	free(arr);
	return 0;
}

void foo(int *b, int c, int *arr, int n) {
	int i;
	c = 2;
	for(i=0; i<n; i++) {
		arr[i] = i + c;
	}
	*arr = 13;
	blah(b, c);
}

void blah(int *r, int s) {
	*r = 3;
	s = 4;
	// STACK DRAWN HERE
}

   Here are the [16]Answers
   Pointers and Structs
   Given the following struct definition:
struct student {
	char name[50];
	int  age;
	int  year;
	float  gpa;
};

   In your program, you can declare variables whose type is struct student or struct student *
   (a pointer to a struct student). To access individual fields in a struct, use dot "."
   notation if the variable's type is "struct student" and right arrow notation "->" if a
   variable's type is a "struct student *". Here are some examples:
struct student s;
struct student *sptr;

// you need to think very carefully about the type of each field
// when you access it (name is an array of char, age is an int ...
strcpy(s.name, "Freya");
s.age = 18;
s.year = 2016;
s.gpa = 4.0;

// malloc up a struct student for sptr to point to:
sptr = malloc(sizeof(struct student));
if(!sptr) {
	// error handling code ...
}
sptr->age = 19;		// the age field of what sptr points to gets 20
sptr->year = 2015;
sptr->gpa = 3.2;
strcpy(sptr->name, "Lars");

(*sptr).age = 20;   // this also access the age field of what sptr points to
                    // (*sptr).age and sptr->age synonyms for the same memory location

   Here is what the variables s and sptr may look like in memory (malloced space is always in
   heap memory, and variables are either allocated on the stack (local variables and
   parameters) or in global memory (global variables):

ON THE STACK                               ON THE HEAP
=============                              ===========
   -----------
s  | "Freya" |
   |  18     |
   |  2016   |
   |  4.0    |
   -----------

     -----                                   ----------- 
sptr | *-|---------------------------------> | "Lars"  |
     -----                                   |  20     |
                                             |  2015   |
                                             |  3.2    |
                                             ----------- 
	 
	 You can also have field values that are pointers:
struct personT {
	char *name;
	int  age;
};

int main() {
	struct personT me, *you;

	me.name = malloc(sizeof(char)*10);
	strcpy(me.name,"Tia");
	me.age = 50;

	you = malloc(sizeof(struct personT));
	you->name = malloc(sizeof(char)*10);
	strcpy(you->name, "Elmo");
	you->age = 40;
}

   Answer these questions:
	1. Draw a picture of the contents of memory (the stack and the heap) showing the effects
	   of executing the instructions in main above on the variables you and me.
	2. What is the type and value of each of the following expressions (and are they all
	   valid?):
1.	me
2.	you
3.	me.name
4.	you.name
5.	me.name[2]
6.	you->name[2]

-------------------------------------------------------------------------------------------------------------
   [17]Here are the answers.


struct personT {
  char *name;
  int  age;
};

int main() {
  struct personT me, *you;

  me.name = malloc(sizeof(char)*10);
  strcpy(me.name,"Tia");
  me.age = 50;

  you = malloc(sizeof(struct personT));
  you->name = malloc(sizeof(char)*10);
  strcpy(you->name, "Elmo");
  you->age = 40;
}

The contents of memory at the end of main:

ON THE STACK                               ON THE HEAP
=============                              ===========
     --------                              ----------------
 me  |   *--|---------------------------->| "Tia"         |
     |  50  |                              ----------------
     --------

     ------                                --------        ----------------
you  |  *-|------------------------------->|   *--|------->| "Elmo"       |
     ------                                |  40  |        ----------------
                                           --------


What is the type and value of each of the following expressions (and are they all valid?):


EXPRESSION                    TYPE                 VALUE 
----------                    ----                 ------
1.  me                        struct personT       (base address of "Tia" string in heap, 50)
2.  you                       struct personT *     base address of personT struct in heap
3.  me.name                   char *               base address of "Tia" string in heap
4.  you.name                  INVALID              INVALID (you is a pointer not a struct)
5.  me.name[2]                char                 'a'
6.  you->name[2]              char                 'm'

-------------------------------------------------------------------------------------------------------------

	 You can also declare static or dynamic arrays of structs or arrays of pointers to structs
   or ... (you need to think very carefully about type). Here are some examples:
struct student students[36];    // an array of 36 student structs
struct student *students2;      // a pointer to a struct student
                                // (will be used to store the base address
                                //  of a dynamically allocated array of student
                                // structs (each bucket holds a struct student)
struct student *students3[36];  // statically declared array of student struct*
                                // (each bucket holds a (struct student *))

   Examples of their use:
students[i].age = 21;   // the ith bucket stores a student struct
                        // use dot notation to access its fields

// dynamically allocate array of student structs
// (the array buckets are allocated in heap memory)
students2 = malloc(sizeof(struct student)*10);

students2[3].year = 2013;   // each bucket in this array is a student struct
                            // use dot notation to access its fields

// each bucket of students3 stores a pointer to a student struct
students3[0] = malloc(sizeof(struct student));

students3[0]->age = 21;   // dereference the pointer to the struct in bucket 0

Linked Lists in C
   You can also define self-referential structs in C (structs with fields whose type is a
   pointer to the struct type). This is how you would define a node for a linked list for
   example:
struct node {
	int data;
	struct node *next;
};

   Then you could use instances of this struct type to create a linked-list:
struct node *head, *temp;

head = NULL;  // an empty linked list

head = malloc(sizeof(struct node));
if(!head) { // some error handling code ... }	// !head is == (head != NULL)
head->data = 10;
head->next = NULL;

// add 5 nodes to the head of the list:
for(i = 0; i < 5 i++) {
	temp = malloc(sizeof(struct node));
	if(temp == NULL) {	// some error handling code ... }
	temp->data = i;
	temp->next = head;
	head = temp;
}

   We likely will not write any linked list code in this class, but if you are curious about
   this topic, you can look at my linked lists in C reference for more information about
   linked lists in C.



---

