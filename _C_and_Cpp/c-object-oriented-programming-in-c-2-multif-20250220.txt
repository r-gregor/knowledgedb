filename: c_object-oriented-programming-in-c-2-multif_20250220.txt
https://www.ionos.co.uk/digitalguide/websites/web-development/oop-in-c/

How to implement object-oriented programming (OOP) in C
19/07/2023

   How to implement object-oriented programming (OOP) in C ESB ProfessionalShutterstock

   Unlike the OOP languages C++ and Objective-C, C does not include object-oriented features. However,
   since the language has become widely used and object-oriented programming has gained widespread
   popularity, strategies for implementing OOP in C have been created.

Is OOP in C possible?
   The programming language C is not intended for object-oriented programming and is a prime example
   of the structured programming style in imperative programming. However, it is possible to
   replicate object-oriented approaches in C. In fact, C has all the components needed for it and
   contributed to forming the basis for object-oriented programming in Python.

   Individual abstract data types (ADT) can be defined with OOP. An ADT can be thought of as a set of
   possible values with functions operating on them. It is important that the externally visible
   interface and the internal implementation are decoupled from each other. This ensures that the type's
   objects behave according to description.

   Object-oriented languages such as Python, Java and C++ use the class concept to model abstract data
   types. Classes serve as a template for creating similar objects, which is also referred to as
   instantiation. C does not have classes, and these cannot be modelled within the language. However,
   there are several approaches for implementing OOP features in C.

How does OOP work in C?
   Understanding how OOP works in C requires first asking, 'What exactly is object-oriented
   programming (OOP)?' OOP is a programming style that is commonly seen in the imperative
   programming paradigm. This sets OOP apart from declarative programming and its
   specialisation, functional programming.

   The basic idea of object-oriented programming is to model objects and let them interact with each
   other. The program flow is a result of the objects interacting and is only fixed at runtime. OOP
   covers three characteristics:
    1. Objects encapsulate their internal state.
    2. Objects receive messages through their methods.
    3. The methods are assigned dynamically at runtime.

   An object in a pure OOP language such as Java is a self-contained unit. This includes a random
   complex data structure and methods (functions) that operate on it. The object's internal state, which
   is represented in the data it contains, can only be read and changed through the methods. The
   language feature 'garbage collector' is usually used for the objects' memory management.

   Connecting a data structure and functions to objects is not available in C. The user must put
   together a manageable system of data structures, type definitions, pointers and functions. The
   programmer is responsible for allocating and releasing memory in C.

   The resulting object-based C code doesn't look quite like what you're probably used to in other OOP
   languages. Nevertheless, it does work. Below is an overview of the main OOP concepts with their
   equivalents in C:

   ---------------------------------------------------------------------------------
   OOP concept                     Equivalent in C
   ---------------------------------------------------------------------------------
   Class                           Struct type
   Class instance                  Struct instance
   Instance method                 Function that accepts pointers to Struct variable
   this/self variable              Pointer to Struct variable
   Instantiation                   Allocation and reference through pointer
   new keyword                     Call malloc
   ---------------------------------------------------------------------------------

How to model objects as data structures
   Let's look at how an object's data structure can be modelled in C in a way that is similar to OOP
   languages. C is a compact language that doesn't work with many language constructs. Structs are used
   to create random complex data structures, with the name 'struct' being derived from the term 'data
   structure'.

   A struct in C defines a data structure that hasfields which are referred to as 'members'. This type
   of construct is called a 'record' in other languages. A struct can be thought of as a row in a
   database table, like a composite with several fields and different types.

   The syntax for a struct declaration in C is very simple:
struct struct_name;

   We can also define the struct by specifying the members' name and type. Let's consider a point in a
   two-dimensional space with x and y coordinates as an example. We'll outline the struct definition:
struct point {
	/*X-coordinate*/
	int x;

	/*Y-coordinate*/
	int y;
};

   This is followed by the struct variable's instantiation in conventional C code. We'll create the
   variable and initialise both fields with 0:

struct point origin = {0, 0};

   Subsequently, the values in the fields can be read and reset. The member access is done using the
   syntax origin.x and origin.y which you may know from other languages:

/*Read struct member*/
origin.x == 0

/*Assign struct member*/
origin.y = 42

   However, this violates the encapsulation requirement. The object's internal state may only be
   accessed using methods defined for this purpose. This means that our approach is still missing
   something.

How to define types for creating objects
   As mentioned before, C does not have class concepts. Instead, types can be defined with a typedef
   statement. We'll give the data type a new name with typedef:
typedef <old-type-name> <new-type-name>

   This allows us to define a point type for our point struct:
typedef struct point Point;

   The combination of typedef with a struct definition is like a class definition in Java:

typedef struct point {
	/*X-coordinate*/
	int x;

	/*Y-coordinate*/
	int y;
} Point;

   Note
   In the example, 'point' is the name of the struct and 'Point' is the name of the defined type.

   This would be the corresponding class definition in Java:

class Point {
	private int x;
	private int y;
};

   Using typedef allows us to create a point variable without using the struct keyword:

Point origin = {0, 0}

/*Instead of*/
struct point origin = {0, 0}

   The internal state's encapsulation is still missing.

How to encapsulate the internal state
   Objects display their internal state in their data structure. In other OOP languages, such as Java,
   the keywords 'private', 'protected', etc. are used to restrict access to object data. This prevents
   unauthorised access and ensures that the interface and implementation are separated.

   To implement OOP in C, a different mechanism is used. A forward declaration in the header file serves
   as an interface, resulting in an 'Incomplete type':

/*In C header file*/
struct point;

/*Incomplete type*/
typedef struct point Point;

   The point struct's implementation is in a separate C source code file. This embeds the header using
   include macro. This approach prevents the creation of static variables of the point type. It is still
   possible to use pointers from this type. Objects are dynamically created data structures, so they are
   referenced with pointers anyway. Pointers to struct instances correspond roughly to the object
   references used in Java.

How to replace methods with functions
   In OOP languages such as Java and Python, objects include the functions that operate on them in
   addition to their data. These are called methods and instance methods. We use functions that take a
   pointer to a struct instance when OOP code is written in C:

/*Pointer to `Point` struct*/
Point * point;

   C does not have classes. This makes it impossible to group functions belonging to a type under a
   common name. Instead, we provide the function names with a prefix containing the type's name. The
   corresponding function signatures are declared in the C header file:

/*In C header file*/
/*Function to move update a point's coordinates*/
void Point_move(Point * point, int new_x, int new_y);

   It is necessary to implement the function in the C source code file:

/*In C source file*/
void Point_move(Point * point, int new_x, int new_y) {
	point->x = new_x;
	point->y = new_y;
};

   The approach has similarities to Python methods, which are normal functions that take self as the
   first parameter. Furthermore, the pointer to a struct instance is roughly equivalent to the variable
   in Java or JavaScript. However, the pointer is passed explicitly when the C function is called in
   this case:

/*Call function with pointer argument*/
Point_move(point, 42, 51);

   The point object is available in the method as a variable in the Java function call:
// Call instance method from outside of class
point.move(42, 51)

// Call instance method from within class
this.move(42, 51)

   Methods can be called as functions with an explicit self-argument in Python:

# Call instance method from outside or from within class
self.move(42, 51)

# Function call from within class
move(self, 42, 51)

How to instantiate objects
   One of C's defining characteristics is manual memory management. Programmers must allocate memory for
   data structures. This is not required in object-oriented and dynamic languages such as Java and
   Python. In Java, the new keyword is used to instantiate an object. Memory is allocated automatically
   in the background:

// Create new Point instance
Point point = new Point();

   We define a special constructor function for instantiation when we write OOP code in C. This
   allocates memory for our struct instance, initialises it and returns a pointer to it:

Point * Point_new(int x, int y) {
	/*Allocate memory and cast to pointer type*/
	Point *point = (Point*) malloc(sizeof(Point));

	/*Initialize members*/
	Point_init(point, x, y);

	// return pointer
	return point;
};

   Our example decouples the struct members' initialisation from the instantiation. A function with the
   point prefix is used again:

void Point_init(Point * point, int x, int y) {
	point->x = x;
	point->y = y;
};

How can a C project be rewritten in an object-oriented manner?
   Rewriting an existing project in C using OOP techniques is recommended only in exceptional cases. The
   following approaches would be more worthwhile:
    1. Rewrite project in a language like C with OOP features and use the existing C code base as a
       specification.
    2. Rewrite parts of the project in an OOP language and keep specific C components.

   The second approach should be the most efficient provided the C code base is clean. It is common
   practice to implement performance-critical program parts in C and access them from other languages.
   There probably isn't another language better suited to this than C. But which languages are suitable
   for rebuilding an existing C project using OOP principles?

Object-oriented languages like C
   There is a wide selection of languages like C with built-in object orientation. C++ is probably the
   most well-known. However, the language is notoriously complex, which has led many to move away from
   it in recent years. C code is relatively easy to incorporate into C++ due to major similarities in
   the basic language constructs.

   Objective-C is more lightweight than C++. The C dialect, which is based on the original OOP language
   Smalltalk, was primarily used for programming applications on Mac and early iOS operating systems. It
   was later followed by Apple's development of its own Swift language. Functions written in C can be
   called from both languages.

Object-oriented languages based on C
   There are other OOP programming languages that are suitable for rewriting a C project but are not
   related to C's syntax. Standard approaches for including C code exist for Python, Rust, and Java.

   Python bindings allow for the inclusion of C code. Python data types may have to be translated into
   the corresponding ctypes. The C Foreign Function Interface (CFFI) also automates type translation.

   Rust also supports calling C functions. The external keyword can be used to define a Foreign Function
   Interface (FFI). Rust functions that access external functions must be declared unsafe:

external "C" {
	fn abs(input: i32) -> i32;
}

fn main() {
	unsafe {
		println!("Absolute value of -3 according to C: {}", abs(-3));
	}
}


---
https://thecloudstrap.com/chapter-15-object-oriented-programming-in-c/#google_vignette

Chapter 15: Navigating Object-Oriented Programming in C

   Welcome to Chapter 15, intrepid coders! Today, we're stepping into a new frontier of our coding
   journey as we venture into the enigmatic but exciting realm of Object-Oriented Programming (OOP) in
   C.

   Wait, what? Object-Oriented Programming in C? You might be scratching your head here. After all,
   isn't C traditionally a procedural language? Yes, you're right, but that doesn't mean we can't apply
   some of the principles of OOP in C. This chapter is all about showing you how. Buckle up!

The Odd Couple: OOP and C
   Object-Oriented Programming is a paradigm centred on the concept of "objects" - data structures
   consisting of data fields and methods together. It's a way of structuring and organizing code that
   allows you to think about problems in terms of real-world objects and their interactions.

   C, on the other hand, is fundamentally a procedural language, focusing on the process rather than
   data, with functions and structured control commands like if-else and for loops at its heart.

   Despite this apparent mismatch, we can mimic OOP in C by being creative with how we use its existing
   features.

Data Abstraction: Structs to the Rescue!
   The most straightforward approach to object-oriented programming in C is by using structures
   (struct). While C does not inherently support classes like C++ or Java, struct can serve as a
   reasonable substitute.

   A struct can group related variables under one name, much like how an object in OOP has properties.
   We can define struct types that encapsulate data fields and simulate methods through function
   pointers within these structures. This encapsulation brings us a step closer to true object-oriented
   design.

Encapsulation and Information Hiding
   In OOP, the principle of encapsulation ensures that an object's internal state is shielded from
   outside interference. While C does not provide direct support for private and public class members,
   we can achieve similar effects through careful struct design and the disciplined use of static
   functions and variables in our .c files.

Inheritance and Polymorphism: The Creative Use of Pointers
   C does not directly support inheritance and polymorphism, two pillars of OOP. However, we can
   simulate these features by exploiting the language's powerful pointer system. By using pointers to
   base struct types and embedding struct types within each other, we can model a form of inheritance.
   Polymorphism can be achieved through function pointers and carefully designed interfaces.

Navigating the Challenges
   Implementing OOP in C is not for the faint of heart. It requires a deep understanding of the language
   and careful, disciplined coding. It can be easy to make mistakes, and debugging can be challenging.
   However, the reward is a design methodology that can lead to code that is easier to understand,
   maintain, and extend.

Embrace the Adventure
   In the end, using OOP principles in C is like creating a sculpture with a chisel and hammer. It's
   more labour-intensive than using modern power tools, and it requires skill and patience. But with
   perseverance, the resulting work is a testament to your craftsmanship.

   In the next few posts, we'll delve deeper into the techniques and tricks of implementing OOP in C. So
   stick around, fellow coding adventurers, as we boldly go where few C programmers have gone before!

   So, keep coding, keep exploring, and most importantly, keep learning! Object-Oriented Programming in
   C is not a myth but a challenging adventure, ready for those daring enough to embark on the journey.

Example - 1
   Object-Oriented Programming (OOP) is not inherently supported in C, unlike languages like C++ or
   Java, but certain aspects of OOP can be simulated. The example below demonstrates the concept of
   encapsulation, and it will mimic a class object with methods using C's structs and function pointers.

   Here's a simple example of a "Car" object:
#include<stdio.h>

// Car "class"
typedef struct {
	int speed;
	int (*speedUp)(int);
	int (*applyBrake)(int);
} Car;

// Method definitions
int speedUp(int increment) {
	// Accessing the speed variable directly won't be possible in this case
	// Assume there's a way to access the specific Car instance's speed here
	return speed + increment;
}

int applyBrake(int decrement) {
	// Assume there's a way to access the specific Car instance's speed here
	return speed - decrement;
}

int main() {
	// Instantiate a Car object
	Car myCar;

	// Initialize properties
	myCar.speed = 0;

	// Link methods
	myCar.speedUp = &speedUp;
	myCar.applyBrake = &applyBrake;

	// Use methods
	myCar.speed = myCar.speedUp(20);
	printf("The car speed after speeding up: %d\n", myCar.speed);

	myCar.speed = myCar.applyBrake(10);
	printf("The car speed after applying brake: %d\n", myCar.speed);

	return 0;
}

   Please note that, due to the nature of C, we can't directly access the object's data (speed in this
   case) inside the function as we would do in true OOP languages. There are ways around this, such as
   passing the object itself as a parameter to the function, but this starts to make the code more
   complex and less intuitive from an OOP perspective.

Example - 2
   In an aerospace context, we can imagine a simplified scenario where we have an "Aircraft" object.
   This object might have properties like "altitude" and "speed", and methods like "climb" and
   "descend".

   Here is how we might model this using C:

#include <stdio.h>

// Define the Aircraft "class"
typedef struct {
	int altitude;
	int speed;
	void (*climb)(struct Aircraft*, int);
	void (*descend)(struct Aircraft*, int);
} Aircraft;

// Method definitions
void climb(Aircraft* aircraft, int increase) {
	aircraft->altitude += increase;
}

void descend(Aircraft* aircraft, int decrease) {
	if(aircraft->altitude > decrease) {
		aircraft->altitude -= decrease;
	}
	else {
		aircraft->altitude = 0; // Can't go below ground level!
	}
}

int main() {
	// Instantiate an Aircraft object
	Aircraft myAircraft;

	// Initialize properties
	myAircraft.altitude = 0;
	myAircraft.speed = 0;

	// Link methods
	myAircraft.climb = &climb;
	myAircraft.descend = &descend;

	// Use methods
	myAircraft.climb(&myAircraft, 10000);
	printf("The aircraft altitude after climbing: %d feet\n", myAircraft.altitude);

	myAircraft.descend(&myAircraft, 5000);
	printf("The aircraft altitude after descending: %d feet\n", myAircraft.altitude);

	return 0;
}

   This program creates an "Aircraft" struct, with altitude and speed as properties, and climb and
   descend as methods. The methods adjust the altitude of the aircraft. It's a very simplistic model and
   doesn't account for many of the factors a real aircraft would have to deal with, but it serves to
   illustrate how you might use C to write code in an object-oriented style.

   Note how we had to pass the object itself (the Aircraft struct) as a parameter to the methods in
   order to modify its properties. This is a key difference between C and languages with built-in OOP
   support, and can make the code somewhat more difficult to read and write.

Conclusion
   These examples are greatly simplified and may not fully demonstrate the true advantages of OOP. It's
   also important to note that C was not designed with OOP in mind, and while it can mimic certain
   OOP features, it lacks the full power and integration of OOP concepts that languages like C++, Java,
   or Python provide. For projects that would truly benefit from OOP, it might be more advantageous to
   use a language that natively supports OOP.

   That said, understanding how to implement these structures in C can give you a deeper
   appreciation of how OOP works under the hood and can provide additional tools for solving problems in
   C.


---
https://joelkp.frama.io/tech/c-struct-inherit.html

Simple and terse C object-oriented programming for single inheritance designs
2022-11-28

   Loosely based on a 2012 article of mine, which I had on an older personal website in the early 2010s.
   Extended based on both an old project and a fresh look at it.

   In 2013, I put the fanciest implementation of these ideas I had into a C library named 'SCOOP' for
   this kind of simple C OOP. As of 2022 I think there's more to be said about and done with the
   preprocessor; newer variations on these things may appear in some new software of mine.

   This article is more about what's possible than about what should be done - possible in terms of
   bending pure C towards being able to write some types of object-oriented code in a terse and
   streamlined way. But the use of the preprocessor shown here is fairly simple (though unconventional)
   - more can be done using C99 and later features.

   In plain C, to implement object-oriented type inheritance (of C struct members), functionally similar
   to how it works for C++ classes, can be done using the preprocessor - with inherited members of a
   superclass becoming "direct" members of the derived class, and accessed with the same syntax as
   members unique to (i.e. added in) that subclass - as long as only single inheritance is done. Though
   as with many other tricks, there's drawbacks and things to keep in mind.

   With some additional elaboration on top of the basic approach, mainly adding information about each
   class, a virtual function table, and some code to handle basic tasks for all classes, this
   preprocessor-centered approach makes for the most concise way of writing single inheritance "C with
   classes" in plain C (rather than e.g. C++) that I've so far seen. This is a special-purpose solution
   rather than a general-purpose solution, originally for working on a particular C library; the main
   ideas or basic approach may be useful if the structure of some particular piece of software (usually
   not a whole program) can be shoehorned painlessly into its mold.

   Object oriented design in C is often done when different things are needed. And for a more thorough
   and conventional look at the virtual functions part of the picture, I'd recommend reading
   Christopher Wellons's article.

Aggregation and prefixing
   Before looking at how to use the preprocessor to "inherit" structs, here's a look at the more common
   and gotcha-free alternative, which is to include an instance of the supertype at the very beginning
   of its subtype - accomplishing two things:
    1. The ability to access inherited members, albeit through an added prefix - the name of the
       included instance of the supertype.
    2. Type-cast compatibility from type to supertype and back.

   A very simple example showing the first point is below.

typedef struct TypeA {
	int x;
} TypeA;

typedef struct TypeB {
	TypeA a;
	int y;
} TypeB;

TypeB *b;
...
b->a.x = 10; /* access x through prefix */
b->y = 5;

   There is nothing wrong with this approach, and in some ways it remains "the cleanest" solution.
   Alternatives which get rid of such an access prefix for inherited members have their own quirks and
   subtle uglinesses. However, whenever more than one level of type inheritance is done, it becomes
   rather nice to get rid of those prefixes which otherwise add up. (It's also when there's several
   levels of inheritance that it becomes trickier to handle other things well, e.g. type identification
   and runtime checks, so that there's more of a point to more elaborate OOP schemes in general.)

   It makes sense to stick to aggregation when simple aggregation rather than an object-oriented
   hierarchy is wanted. Aggregation can also be combined with the below single inheritance approach for
   a touch of multiple inheritance, though I think that's only good design when the aggregation is a
   natural fit rather than a clunky complication added to work around a lack of multiple inheritance.

Defining with shared macros
   In various C codebases, there's one or another set of types which have a little something in common -
   such as a pointer or two - while there isn't really more in the way of any object-oriented hierarchy.
   For that purpose, it works very well to list the members common to the types in a macro definition
   and then use it at the beginning of each struct. For example...

#define LIST_MEMBERS \
        struct List *next, *prev;

typedef struct List { LIST_MEMBERS } List;

typedef struct TypeWithList {
	LIST_MEMBERS
	int value;
} TypeWithList;

   Each type with the members of List included at the beginning can then be used by functions or macros
   for List. As long as the members included in this way are simply pointers, or of the same size as
   pointers, there's little to worry about.

   This trick can however be used to include data of smaller sizes as well, in ways which do not line up
   with how struct sizes are padded at the end (with inserted extra bytes) by the compiler at compile
   time. How such padding is done may vary between systems. If a char c; were added to the end of
   LIST_MEMBERS, for example, then the type List may technically end up as large as TypeWithList, if
   pointers are 8 bytes large and both List and TypeWithList are padded to the next multiple of 8 bytes,
   say. Most things would still work the same regardless, but some things wouldn't; if code then used
   sizeof(List) to decide how much to read from or write to an object which happens to be of type
   TypeWithList, some data used by the derived type would also be read or written to.

   This is a safety problem with what is otherwise a straightforward way to get rid of the need to use a
   prefix to access members of an inherited type. This problem can be solved using the C11 feature of
   anonymous structs, by wrapping the list of inherited members in an anonymous struct when defining the
   list, or at least when using it. (This problem can also be non-portably solved by disabling padding
   when compilers support that, but that would result in different problems, as padding is used for a
   reason.) With that said, below is the example which used aggregation again, rewritten to use this
   style, both with and without the use of an anonymous struct.

#define TYPE_A_MEMBERS \
        int x;

typedef struct TypeA {
	TYPE_A_MEMBERS
} TypeA;

typedef struct TypeB {
	TYPE_A_MEMBERS
		int y;
} TypeB;

typedef struct TypeB_C11 {
	struct { TYPE_A_MEMBERS };
	int y;
} TypeB_C11;

TypeB *b;
...
b->x = 10; /* access x directly */
b->y = 5;

   This works for accessing members by name; the prefix is removed. As for the quirk described above,
   with the non-C11 version sometimes padding at the end of TypeA will not be included in TypeB, which
   in practice means that there is only almost type cast compatibility. Taking the safer C11 pattern a
   step further may look like the below.

#define TYPE_B_MEMBERS struct { TYPE_A_MEMBERS }; \
        int y;

typedef struct TypeB {
	TYPE_B_MEMBERS
} TypeB;

typedef struct TypeC {
	struct { TYPE_B_MEMBERS };
	int z;
} TypeC;

   Either version can be repeated many levels. But compared to simple aggregation, this approach becomes
   somewhat more verbose and messy to use when defining types (as opposed to when using them), probably
   part of why it's not so often seen used for more than two levels of types.

   Proceeding along this path, however, terseness can be brought using the C preprocessor more fully to
   define types, and deciding on a naming convention for macros providing information about types. (This
   technique could be used for more elaborate collections of related struct types, but I have yet to
   find it useful to use by itself, without elaborating it further.) For each type Name, if its members
   are listed in a macro Name_, for example, then the convenience macro below can be used to define the
   type.

#define structdef(Name) \
        typedef struct Name { Name##_ } Name

   Following this convention, with the basic idea of listing the members of each type of a hierarchy in
   a macro, the resulting code is terser, albeit a bit different-looking:

#define TypeA_ \
        int x;
structdef(TypeA);

#define TypeB_ TypeA_ \
        int y;
structdef(TypeB);

#define TypeB_C11_ struct { TypeA_ }; \
        int y;
structdef(TypeB_C11);

   There's now an additional, smaller catch, in the form of slightly worse diagnostics from the compiler
   if something is wrong with the list of members used for such a type. The contents of a macro
   definition always all end up on one single line, as the compiler sees it - both when defined and when
   referenced - so the line and character numbers in any warnings or errors when compiling that piece of
   code will be less useful.

Elaborating a real type system
   This is a summary of what my old SCOOP library contains and does, written roughly a decade later.
   Keep in mind that the approach builds on the "unsafe" (non-C11) version of the above, which means
   that data added in derived class structs may overlap with padding at the end of a base class struct.
   This is not a problem if OOP APIs are used as they typically are, but the caveat applies to fiddling
   with "class" structs using e.g. memcpy() and sizeof(). (Fixing this corner case for the below or
   similar is possible using a combination of anonymous struct and union, but it's not done below; the
   below version uses C89 features.)

   The above is too simple for when features such as virtual functions and run-time type identification
   are wanted, but can be extended to also support that. At the core, a more elaborate version of the
   convenience macro for defining a type can insert an extra pointer to a meta-type instance at the
   start of each class struct, before it uses the macro with the list of normal members. Each class
   requires only one extra pointer, and in each class the pointer will go to a struct of a different
   type - the unique meta-type of that class.

#define classtype(Name) \
        typedef struct Name { const struct Name##_Meta *meta; Name##_ } Name

   The meta-type can be defined by the same use of a class-defining convenience macro. Its struct can
   hold a pointer to the supertype meta-type, pointers for virtual functions, etc. Function pointers for
   virtual function use can be listed in another macro named after the type, similarly to the one for
   normal class members, allowing more of them to be added at each step of the inheritance chain.

   Below, enough is defined to allow defining the main and meta types of Class by writing
   classdef(Class);, and to allow defining a (global) meta-type instance describing the class by writing
   metainst(Class, ...). Constructor and "new"-function pairs can also be added using ctordef() (and
   optionally ctordec()). Together, this is basically a stripped-down core of what SCOOP's Object.h
   provides (it also has extensive comments).

typedef void (*Dtor)(void *o);
typedef void (*Vtinit)(void *o);

#define metatype(Class) \
typedef struct Class##_Virt { Dtor dtor; Class##__ } Class##_Virt; \
typedef struct Class##_Meta { \
        const struct Object_Meta *super; \
        size_t size; \
        unsigned short vnum; \
        unsigned char done; \
        const char *name; \
        Vtinit vtinit; /* virtual table init function, passed meta */ \
        Class##_Virt virt; \
} Class##_Meta

#define classdef(Class) \
        classtype(Class); \
        metatype(Class); \
        extern Class##_Meta _##Class##_meta

// global meta type instance
#define metaof(Class) (&(_##Class##_meta))

// universal Object and Object_Meta structs, for type cast use only
#define Object_
#define Object__
classtype(Object);
metatype(Object);

#define metainst(Class, Superclass, dtor, vtinit) \
struct Class##_Meta _##Class##_meta = { \
        (Object_Meta*) metaof(Superclass), \
        sizeof(Class), \
        (sizeof(Class##_Virt) / sizeof(void (*)())), \
        0, \
        #Class, \
        (Vtinit)vtinit, \
        {(Dtor)dtor} \
}

// allow "None" to be used as a (super)class name with NULL meta type instance
#define _None_meta (*(Object_Meta*)(0))

// declare "new" and constructor function pair, end with ;
#define ctordec(Class, FunctionName, Parlist) \
Class* FunctionName##_new Parlist; \
unsigned char FunctionName##_ctor Parlist

// define "new" and constructor function pair, end with { ... }
#define ctordef(Class, FunctionName, Parlist, Arglist, o) \
unsigned char FunctionName##_ctor Parlist; \
Class* FunctionName##_new Parlist \
{ \
        void *ctordef__mem = (o); \
        (o) = raw_new(ctordef__mem, metaof(Class)); \
        if ((o) && !FunctionName##_ctor Arglist) { \
                ((Object*)(o))->meta = metaof(None); \
                if (!ctordef__mem) free(o); \
                return 0; \
        } \
        return (o); \
} \
unsigned char FunctionName##_ctor Parlist

   If each meta-type is given a global instance named after the type, then the need to add and use
   boilerplate code along with each type defined can be reduced greatly. Most of the work can be done by
   a few functions common to all types, for handling generic allocation given a passed meta-type,
   meta-type initialization (when the global instance used isn't already all-set), run-time type checks,
   etc. Terse and simple use along with the types, and for defining things like constructors making use
   of supertype constructors, etc., simply requires more convenience macros. With such a framework,
   there's no need to require any explicit registering of types before being able to create and destroy
   instances, as used in some object-oriented C designs, nor any need for clean-up de-registration.

   Below is minimal runtime code which can be used by all types. It's a somewhat simplified version of
   the code in SCOOP's Object.c.

void pure_virtual(void *o) {
	fputs("error: pure virtual function called", stderr);
	exit(EXIT_FAILURE);
}

/* recursively fills in blank parts of meta type instance chain */
void init_meta(Object_Meta *o) {
	void (**virt)() = (void (**)()) &o->virt,
	(**super_virtab)() = 0;
	unsigned int i = 1, max; /* skip dtor */
	if (o->super) {
		if (!o->super->done)
			init_meta((Object_Meta*)o->super);
		super_virtab = (void (**)()) &o->super->virt;
		for (max = o->super->vnum; i < max; ++i)
			if (!virt[i]) virt[i] = super_virtab[i];
	}
	if (o->vtinit)
		o->vtinit(o);
	for (max = o->vnum; i < max; ++i)
		if (!virt[i]) virt[i] = pure_virtual;
	o->done = 1;
}

void *raw_new(void *mem, void *_meta) {
	Object_Meta *meta = _meta;
	if (!mem) {
		if (!(mem = calloc(1, meta->size)))
			return 0;
	} else {
		memset(mem, 0, meta->size);
	}
	if (!meta->done) init_meta(meta);
	((Object*)mem)->meta = meta;
	return mem;
}

void delete(void *o) {
	const Object_Meta *meta = ((Object*)o)->meta;
	do {
		if (meta->virt.dtor) meta->virt.dtor(o);
		meta = meta->super;
	} while (meta);
	free(o);
}

void finalize(void *o) {
	const Object_Meta *meta = ((Object*)o)->meta;
	do {
		if (meta->virt.dtor) meta->virt.dtor(o);
		meta = meta->super;
	} while (meta);
	((Object*)o)->meta = metaof(None);
}

/* core of type comparison */
int rtticheck(const void *submeta, const void *meta) {
	const Object_Meta *subclass = submeta, *class = meta;
	if (subclass == class)
		return 0;
	do {
		subclass = subclass->super;
		if (subclass == class)
			return 1;
	} while (subclass);
	return -1;
}

   The above code allows simply allocating zero-filled instances of any class - both new heap
   allocations, and the (re-)using of other memory for allocations. The delete() function fully handles
   clean-up when it should include a free(), while finalize() is for other cases. But unlike the use of
   destructors for clean-up, the use of constructors for further initialization is not included in the
   automation, because they can take varied forms - and sometimes it's good, or necessary, to be able to
   define several versions for one class. Making that simpler is possible e.g. using the macros which
   define pairs of functions where a Class_new() calls a Class_ctor() (the names can be varied) with the
   return value from the raw_new() function above for Class.

   On delete() and destructors, the above code ensures all destructors in a class hierarchy are
   automatically called, instead of giving a subclass destructor the responsibility of calling the
   destructor of its superclass. More generally, there's a good reason to treat the destructor of each
   class in a special way, instead of lumping it together with the rest of the virtual functions.
   Allowing a destructor function to be NULL reduces boilerplate code when defining simple types. The
   same is true for the function a class may use for setting the vtable members added or changed by the
   class; it can be allowed to be NULL if there's no such virtual functions (virtual destructors don't
   count).

   The disadvantage of coupling all destructor calls to delete() is that there's always some checking
   done for each object to finalize it. Decoupling it instead would make it easier to write code where,
   for example, a large container object can register the destructors of allocated sub-objects,
   performing all checking ahead of the eventual clean-up in one step and later only doing what is
   strictly needed. That would matter most if implementing a memory pool, the destroying of which is
   intended to free all memory for contained objects with the bare minimum of operations.

   Run-time type identification logic can use the above rtticheck() function for most basic things, as
   very simple macros can use it to implement checks to see if an object is of_class(), of_subclass(),
   or to compare class names passed to metaof(), etc.

  Revisiting the example types

   Redefining the two trivial types "TypeA" and "TypeB" from earlier using this framework can be done as
   follows. The second part below, which unlike the first is not suitable to place in a header file, is
   needed to create the global instances of the meta types. That's just one line per class, though,
   since these classes don't need destructors, nor functions to fill in the vtables.

#define TypeA_ \
        int x;
#define TypeA__
classdef(TypeA);

#define TypeB_ TypeA_ \
        int y;
#define TypeB__ TypeA__
classdef(TypeB);

metainst(TypeA, None, NULL, NULL);
metainst(TypeB, TypeA, NULL, NULL);

   The above leaves out the declaring and defining of constructor and class-specific "new" functions.
   Let's try again and include them. (The lazy alternative would be to simply allocate an instance of
   TypeB using the call raw_new(NULL, metaof(TypeB));. All fields other than meta will then be filled
   with zero bytes.)

   Below, I follow the simple convention of naming the object pointer variable for a method o (it would
   be called this in C++). Whatever its name and place in the parameter list, the ctordef() macro
   requires it to be named as the last argument so that the boilerplate "new" code inserted can assign
   it before passing it to the constructor, done using the argument list passed as the next-to-last
   argument.

#define TypeA_ \
        int x;
#define TypeA__
classdef(TypeA);
ctordec(TypeA, TypeA, (TypeA* o));

#define TypeB_ TypeA_ \
        int y;
#define TypeB__ TypeA__
classdef(TypeB);
ctordec(TypeB, TypeB, (TypeB* o));

metainst(TypeA, None, NULL, NULL);

ctordef(TypeA, TypeA, (TypeA* o), (o), o) {
	o->x = 10;
	return 1; /* non-zero for success */
}

metainst(TypeB, TypeA, NULL, NULL);
ctordef(TypeB, TypeB, (TypeB* o), (o), o) {
	TypeA_ctor((TypeA*) o);
	o->y = 5;
	return 1; /* non-zero for success */
}

   An instance of TypeB can now be allocated from the heap using TypeB_new(NULL); - or from the stack by
   passing an address.

   In the SCOOP tests/ directory, there's a simple demonstration of adding constructors and using
   virtual functions, for types declared and defined in separate files (as is common in old-style
   "modular" pre-module C++ code, and C code imitating such structure). SCOOP also includes some extra
   preprocessor logic which can optionally be used to reduce the need to insert type casts, such as the
   cast above in the text TypeA_ctor((TypeA*) o);, when types are placed in different compilation units.

Background and thoughts on uses
   I began experimenting with this in 2010. I had been working on and off on a fork of the C++ GUI
   library FLTK 2.0 for some years, FLPTK - the added "P" for "Plugin" (as I'd made a reworked
   version of the GUI toolkit more suitable for my audio DSP plugin purposes back then). Now it's
   long-abandoned, but before I put it all aside, back in 2010 I began to work on a replacement for it
   in C, based on porting a mixture of my old code, the new (FLTK versioning is messy) FLTK 1.3, and
   some things from eFLTK (another FLTK 2.0 fork). It was a large project, which I found interesting at
   first but which after a time didn't seem practically worthwhile.

   The next year I lost motivation to complete that project, but I kept the little C framework I worked
   out for the conversion (and which would in principle fully allow it), adding it to FLPTK, and then in
   2013 splitting it out into the separate C library SCOOP. In 2022 I've reworked SCOOP to use C99
   macro features (generally also available in C++) a little; further changes move away from the old
   SCOOP more, and a new fork of its code seems to be ending up in my newer code for the audio synthesis
   SAU language (implemented in C from the start).

   Later in the 2010s, I toyed with the idea of trying to do a similar project to the old C++-to-C GUI
   toolkit effort, but then basing a C port on the FLTK 1.3 fork NTK instead, for better Cairo-based
   graphics rendering. (The FLTK project then went on to work on FLTK 1.4, and they more recently seemed
   to plan further graphics changes in newer work...) The SCOOP library seems to contain everything
   needed for such endeavors, given the particular form of the code to be converted, which is single
   inheritance C++ restricted in its use of features. (I wouldn't suggest using it for more general
   C++-to-C purposes! As of the early 2020s, I've also been thinking that modern C++ is getting more
   interesting, and in any case it seems best to simply use that when fancier C++ features are wanted.)

   For adding OO organization to existing C projects - particularly when a collection of types would
   genuinely fit neatly into single inheritance hierarchies (I think OO is best in such cases, and
   usually overrated outside of them) - I think it can be worthwhile to extract some ideas from SCOOP.
   This article is available under Creative Commons BY-SA 4.0.


---
https://blog.devgenius.io/crafting-object-like-magic-in-c-d8342a9213c6


Crafting Object-Like Magic in C
Jan 8, 2024

   C is associated with high performance, low level capabilities, its proximity to hardware and
   simplicity. It may seem like an unlikely candidate for embracing the concepts of encapsulation,
   polymorphism, and inheritance. However object-like structures can be created, making the code more
   modular and maintainable.

   The way to do it is by using function pointers. While C does not have built-in support for
   inheritance, we can create structures that contain function pointers, allowing us to implement a
   basic form of method overriding and polymorphism and, to some extent, emulate aspects of inheritance.

   An example follows:
#include <stdio.h>
#include <stdlib.h>

   first we will need these header files in order to be able to print to the terminal and allocate
   memory.

struct Shape {
	void (*display)(void *);
};

struct Circle {
	struct Shape base;
	int radius;
};

struct Square {
	struct Shape base;
	int sideLength;
};

   then we define a Shape struct with a function pointer as its member and we also define 2 more structs
   that will be our "derived classes".

// Method implementation for the base class
void shapeDisplay(void* obj) {
	printf("Displaying a shape.\n");
}

// Method implementation for the Circle class
void circleDisplay(void* obj) {
	Circle* circle = (Circle*)obj;
	printf("Displaying a circle with radius %d.\n", circle->radius);
}

// Method implementation for the Square class
void squareDisplay(void* obj) {
	Square* square = (Square*)obj;
	printf("Displaying a square with side length %d.\n", square->sideLength);
}

   Then we define three functions. Basically they will be our "methods" implementations.

struct Circle *createCircle(int radius) {
	struct Circle *circle = (struct Circle *)malloc(sizeof(struct Circle));
	circle->base.display = &circleDisplay;
	circle->radius = radius;
	return circle;
}

struct Square *createSquare(int sideLength) {
	struct Square *square = (struct Square *)malloc(sizeof(struct Square));
	square->base.display = &squareDisplay;
	square->sideLength = sideLength;
	return square;
}

   Then we define the functions that will allocate memory for our "objects" .

   Both functions allocate memory for their structures and initialize the base class by assigning the
   display function pointer in the base member of the Square or Circle structure. This enables the
   object to exhibit polymorphic behavior by pointing to the specific implementation of the display
   function.

int main() {
	// Creating instances of Circle and Square using createCircle and createSquare functions
	struct Shape *circle1 = (struct Shape *)createCircle(10);
	struct Shape *circle2 = (struct Shape *)createCircle(20);
	struct Shape *square1 = (struct Shape *)createSquare(50);
	struct Shape *square2 = (struct Shape *)createSquare(45);

	// Displaying the shapes using polymorphism
	circle1->display(circle1);
	circle2->display(circle2);
	square1->display(square1);
	square2->display(square2);

	// Freeing allocated memory
	free(circle1);
	free(circle2);
	free(square1);
	free(square2);

	return 0;
}

     * Four pointers to the base class struct Shape are declared (circle1, circle2, square1, square2).
     * Memory is allocated and instances of Circle and Square are created using the createCircle and
       createSquare functions.
     * The casting (struct Shape *) is used to treat the pointers as instances of the base class struct
       Shape.
     * The specific version of the display method depends on the type of the object (circle or square) ,
       so polymorphism is achieved
     * Then we free the allocated memory to avoid memory leaks.

Another approach
   Another approach to achieve polymorphic behavior in C, although less idiomatic, is to use a vtable
   (virtual function table). This approach, while creative, may be considered less idiomatic due to the
   introduction of vtables in a language not traditionally associated with them.

struct ShapeVTable {
	void (*display)(void *);
};

   This structure defines a vtable containing function pointers. Each function pointer represents a
   method that can be overridden by derived classes.

// Base class
struct Shape {
	struct ShapeVTable *vtable;
};

// Derived class - Circle
struct Circle {
	struct Shape base;
	int radius;
};

// Derived class - Square
struct Square {
	struct Shape base;
	int sideLength;
};

   Here we define the base struct "Shape" which contains a pointer to the vtable, and our "derived
   classes" Circle and Square.

// Method implementation for the base class
void shapeDisplay(void *obj) {
	struct Shape *shape = (struct Shape *)obj;
	shape->vtable->display(obj);
}

// Method implementation for the Circle class
void circleDisplay(void *obj) {
	struct Circle *circle = (struct Circle *)obj;
	printf("Displaying a circle with radius %d.\n", circle->radius);
}

// Method implementation for the Square class
void squareDisplay(void *obj) {
	struct Square *square = (struct Square *)obj;
	printf("Displaying a square with side length %d.\n", square->sideLength);
}

   The shapeDisplay function serves as the default implementation for the display method in the base
   class. It calls the corresponding method in the vtable, allowing for polymorphic behavior.

   The circleDisplay and squareDisplay functions provide specific implementations for the display method
   in the derived classes.

// Vtable for Shape
struct ShapeVTable shapeVtable = {.display = &shapeDisplay};

// Vtable for Circle
struct ShapeVTable circleVtable = {.display = &circleDisplay};

// Vtable for Square
struct ShapeVTable squareVtable = {.display = &squareDisplay};

   These are instances of ShapeVTable containing function pointers to the respective implementations of
   the display method for each class.

// Function to create a new circle object
struct Circle *createCircle(int radius) {
	struct Circle *circle = (struct Circle *)malloc(sizeof(struct Circle));
	circle->base.vtable = &circleVtable;
	circle->radius = radius;
	return circle;
}

// Function to create a new square object
struct Square *createSquare(int sideLength) {
	struct Square *square = (struct Square *)malloc(sizeof(struct Square));
	square->base.vtable = &squareVtable;
	square->sideLength = sideLength;
	return square;
}

These functions allocate memory for the Circle and Square structs and set the vtable pointer to the
appropriate vtable

int main() {
	// Using polymorphism
	struct Shape *shape1 = (struct Shape *)createCircle(5);
	struct Shape *shape2 = (struct Shape *)createSquare(8);
	shape1->vtable->display(shape1);  // Calls circleDisplay for the first circle
	shape2->vtable->display(shape2);  // Calls squareDisplay for the square
                                      // Clean up
	free(shape1);
	free(shape2);
	return 0;
}

   And finally the main function. Here the polymorphism shines. Instances of Circle and Square using the
   base class pointer (Shape *) are created, allowing us to call the display method without knowing the
   specific type.

   We have embarked on a quest to bring a touch of Object-Oriented Programming (OOP) to a language not
   traditionally associated with such paradigms. Through the creative fusion of function pointers,
   structure composition, and the introduction of virtual function tables (vtables), we've woven a
   tapestry of modularity and extensibility.

   In C's simplicity lies the potential for abstraction and encapsulation. The function pointer
   approach, direct and idiomatic, has allowed us to achieve polymorphism, inheritance, and
   encapsulation in a way that befits the C programming landscape.

   On the other hand, the vtable approach, inspired by the principles of OOP from languages like C++ and
   java, has shown us the power of abstraction, enabling dynamic method dispatch and a semblance of
   class hierarchy. While less conventional in the realm of C, it serves as a testament to the
   language's adaptability.

   So, C is efficient and expressive. And with it we can create solutions that have the spirit of OOP.
   Programming


---

