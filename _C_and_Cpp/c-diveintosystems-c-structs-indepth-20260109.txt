filename: c-diveintosystems-c-structs-indepth-20260109.txt
https://diveintosystems.org/book/C2-C_depth/structs.html

2.7. C Structs
   In the previous chapter we introduced
   [**1][https://diveintosystems.org/book/C1-C_intro/structs.html#_structs]C struct types. In this chapter we
   dive deeper into C structs, examine statically and dynamically allocated structs, and combine structs and
   pointers to create more complex data types and data structures.

   We begin with a quick overview of statically declared structs. See the previous chapter for more
   details.

2.7.1. Review of the C struct Type
   A struct type represents a heterogeneous collection of data; it's a mechanism for treating a set of
   different types as a single, coherent unit.

   There are three steps to defining and using struct types in C programs:
    1. Define a struct type that defines the field values and their types.
    2. Declare variables of the struct type.
    3. Use dot notation to access individual field values in the variable.

   In C, structs are lvalues (they can appear on the left-hand side of an assignment statement).
   The value of a struct variable is the contents of its memory (all of the bytes making up its field
   values). When calling functions with struct parameters, the value of the struct argument (a copy of
   all of the bytes of all of its fields) gets copied to the struct function parameter.

   When programming with structs, and in particular when combining structs and arrays, it's critical to
   carefully consider the type of every expression. Each field in a struct represents a specific type,
   and the syntax for accessing field values and the semantics of passing individual field values to
   functions follow those of their specific type.

   The following full example program demonstrates defining a struct type, declaring variables of
   that type, accessing field values, and passing structs and individual field values to functions. (We
   omit some error handling and comments for readability).

#include <stdio.h>
#include <string.h>

/* define a new struct type (outside function bodies) */
struct studentT {
	char  name[64];
	int   age;
	float gpa;
	int   grad_yr;
};

/* function prototypes */
int checkID(struct studentT s1, int min_age);
void changeName(char *old, char *new);

int main(void) {
	int can_vote;
	// declare variables of struct type:
	struct studentT student1, student2;

	// access field values using .
	strcpy(student1.name, "Ruth");
	student1.age = 17;
	student1.gpa = 3.5;
	student1.grad_yr = 2021;

	// structs are lvalues
	student2 = student1;
	strcpy(student2.name, "Frances");
	student2.age = student1.age + 4;

	// passing a struct
	can_vote = checkID(student1, 18);
	printf("%s %d\n", student1.name, can_vote);

	can_vote = checkID(student2, 18);
	printf("%s %d\n", student2.name, can_vote);

	// passing a struct field value
	changeName(student2.name, "Kwame");
	printf("student 2's name is now %s\n", student2.name);

	return 0;
}

int checkID(struct studentT s, int min_age) {
	int ret = 1;

	if (s.age < min_age) {
		ret = 0;
		// changes age field IN PARAMETER COPY ONLY
		s.age = min_age + 1;
	}
	return ret;
}

void changeName(char *old, char *new) {
	if ((old == NULL) || (new == NULL)) {
		return;
	}
	strcpy(old,new);
}

   When run, the program produces:
Ruth 0
Frances 1
student 2's name is now Kwame

   When working with structs, it's particularly important to think about the types of the struct and its
   fields. For example, when passing a struct to a function, the parameter gets a copy of the struct's
   value (a copy of all bytes from the argument). Consequently, changes to the parameter's field values
   do not change the argument's value. This behavior is illustrated in the preceding program in the call
   to checkID, which modifies the parameter's age field. The changes in checkID have no effect on the
   corresponding argument's age field value.

   When passing a field of a struct to a function, the semantics match the type of the field (the type
   of the function's parameter). For example, in the call to changeName, the value of the name field
   (the base address of the name array inside the student2 struct) gets copied to the parameter old,
   meaning that the parameter refers to the same set of array elements in memory as its argument. Thus,
   changing an element of the array in the function also changes the element's value in the argument;
   the semantics of passing the name field match the type of the name field.

2.7.2. Pointers and Structs
   Just like other C types, programmers can declare a variable as a pointer to a user-defined struct
   type. The semantics of using a struct pointer variable resemble those of other pointer types such as
   int *.

   Consider the struct studentT type introduced in the previous program example:

struct studentT {
	char  name[64];
	int   age;
	float gpa;
	int   grad_yr;
};

   A programmer can declare variables of type struct studentT or struct studentT * (a pointer to a
   struct studentT):

struct studentT s;
struct studentT *sptr;

// think very carefully about the type of each field when
// accessing it (name is an array of char, age is an int ...)
strcpy(s.name, "Freya");
s.age = 18;
s.gpa = 4.0;
s.grad_yr = 2020;

// malloc space for a struct studentT for sptr to point to:
sptr = malloc(sizeof(struct studentT));
if (sptr == NULL) {
	printf("Error: malloc failed\n");
	exit(1);
}

   Note that the call to malloc initializes sptr to point to a dynamically allocated struct in heap
   memory. Using the sizeof operator to compute malloc's size request (e.g., `sizeof(struct studentT))
   ensures that malloc allocates space for all of the field values in the struct.

   To access individual fields in a pointer to a struct, the pointer variable first needs to be
   dereferenced. Based on the rules for pointer dereferencing, you may be tempted to access struct
   fields like so:

// the grad_yr field of what sptr points to gets 2021:
(*sptr).grad_yr = 2021;

// the age field of what sptr points to gets s.age plus 1:
(*sptr).age = s.age + 1;

   However, because pointers to structs are so commonly used, C provides a special operator (->) that
   both dereferences a struct and accesses one of its field values. For example, sptr->year is equivalent
   to (*sptr).year. Here are some examples of accessing field values using this notation:

// the gpa field of what sptr points to gets 3.5:
sptr->gpa = 3.5;

// the name field of what sptr points to is a char *
// (can use strcpy to init its value):
strcpy(sptr->name, "Lars");

   Figure 1 sketches what the variables s and sptr may look like in memory after the code above executes.
   Recall that malloc allocates memory from the heap, and local variables are allocated on the stack.

                 Stack                                      Heap
         +----------------------+                      +-------------+
    main | sptr: [addr in heap]------------------------->[  "Lars" ] |
         |                      |                      | [    19   ] |
         |    s: [   "Freya"  ] |                      | [   3.5   ] |
         |       [     10     ] |                      | [  2021   ] |
         |       [    4.5     ] |                      |             |
         |       [   2020     ] |                      |             |
         +----------------------+                      +-------------+

   All the fields of struct s (Freya) are stored on the stack. The sptr pointer on the stack stores the
   heap address of another student struct (Lars).
   Figure 1. The differences in memory layout between a statically allocated struct (data on the stack)
   and a dynamically allocated struct (data on the heap).

2.7.3. Pointer Fields in Structs
   Structs can also be defined to have pointer types as field values. For example:

struct personT {
	char *name;     // for a dynamically allocated string field
	int  age;
};

int main(void) {
	struct personT p1, *p2;

	// need to malloc space for the name field:
	p1.name = malloc(sizeof(char) * 8);
	strcpy(p1.name, "Zhichen");
	p1.age = 22;


	// first malloc space for the struct:
	p2 = malloc(sizeof(struct personT));

	// then malloc space for the name field:
	p2->name = malloc(sizeof(char) * 4);
	strcpy(p2->name, "Vic");
	p2->age = 19;
	...

	// Note: for strings, we must allocate one extra byte to hold the
	// terminating null character that marks the end of the string.
}

   In memory, these variables will look like Figure 2 (note which parts are allocated on the stack
   and which are on the heap).

                Stack                                              Heap
          +--------------------+                +-------------------------------------------+
    main: | p1: [addr in heap]-------------------->[ Z ][ h ][ i ][ c ][ h ][ e ][ n ][ \0] |
          |     [     22     ] |                |                                           |
          | p2: [addr in heap]-------------------->[addr in heap]----->[ v ][ i ][ c ][ \0] |
          +--------------------+                +-------------------------------------------+
   Example struct with a pointer field type
   Figure 2. The layout in memory of a struct with a pointer field.

   As structs and the types of their fields increase in complexity, be careful with their syntax. To
   access field values appropriately, start from the outermost variable type and use its type syntax to
   access individual parts. For example, the types of the struct variables shown in Table 1 govern
   how a programmer should access their fields.

   Table 1. Struct field access examples
   -----------------------------------------------------------------
   Expression           Type Field                 Access Syntax
   -----------------------------------------------------------------
   p1                   struct personT             p1.age, p1.name
   p2                   struct personT *           p2->age, p2->name
   -----------------------------------------------------------------

   Further, knowing the types of field values allows a program to use the correct syntax in accessing
   them, as shown by the examples in Table 2.

   Table 2. Accessing different struct field types
   -------------------------------------------------------
   Expression           Type       Example Access Syntax
   -------------------------------------------------------
   p1.age               int        p1.age = 18;
   p2->age              int        p2->age = 18;
   p1.name              char *     printf("%s", p1.name);
   p2->name             char *     printf("%s", p2->name);
   p1.name[2]           char       p1.name[2] = 'a';
   p2->name[2]          char       p2->name[2] = 'a';
   -------------------------------------------------------

   In examining the last example, start by considering the type of the outermost variable (p2 is a
   pointer to a struct personT). Therefore, to access a field value in the struct, the programmer needs
   to use -> syntax (p2->name). Next, consider the type of the name field, which is a char *, used in this
   program to point to an array of char values. To access a specific char storage location through the
   name field, use array indexing notation: p2->name[2] = 'a'.

2.7.4. Arrays of Structs
   Arrays, pointers, and structs can be combined to create more complex data structures. Here are some
   examples of declaring variables of different types of arrays of structs:

struct studentT classroom1[40];   // an array of 40 struct studentT

struct studentT *classroom2;      // a pointer to a struct studentT
                                  // (for a dynamically allocated array)

struct studentT *classroom3[40];  // an array of 40 struct studentT *
                                  // (each element stores a (struct studentT *))

   Again, thinking very carefully about variable and field types is necessary for understanding the
   syntax and semantics of using these variables in a program. Here are some examples of the correct
   syntax for accessing these variables:

// classroom1 is an array:
//    use indexing to access a particular element
//    each element in classroom1 stores a struct studentT:
//    use dot notation to access fields
classroom1[3].age = 21;

// classroom2 is a pointer to a struct studentT
//    call malloc to dynamically allocate an array
//    of 15 studentT structs for it to point to:
classroom2 = malloc(sizeof(struct studentT) * 15);

// each element in array pointed to by classroom2 is a studentT struct
//    use [] notation to access an element of the array, and dot notation
//    to access a particular field value of the struct at that index:
classroom2[3].year = 2013;

// classroom3 is an array of struct studentT *
//    use [] notation to access a particular element
//    call malloc to dynamically allocate a struct for it to point to
classroom3[5] = malloc(sizeof(struct studentT));

// access fields of the struct using -> notation
// set the age field pointed to in element 5 of the classroom3 array to 21
classroom3[5]->age = 21;

   A function that takes an array of type struct studentT as a parameter might look like this:

void updateAges(struct studentT *classroom, int size) {
	int i;

	for (i = 0; i < size; i++) {
		classroom[i].age += 1;
	}
}

   A program could pass this function either a statically or dynamically allocated array of struct
   studentT:

updateAges(classroom1, 40);
updateAges(classroom2, 15);

   The semantics of passing classroom1 (or classroom2) to updateAges match the semantics of passing a
   statically declared (or dynamically allocated) array to a function: the parameter refers to the same
   set of elements as the argument, and thus changes to the array's values within the function affect
   the argument's elements.

   Figure 3 shows what the stack might look like for the second call to the updateAges function
   (showing the passed classroom2 array with example field values for the struct in each of its
   elements).

                         Stack                                        Heap
               +---------------------------+        +-----------------------------------------+
   updateAges: |                           |        |     0       1        2    ...     14    |
               | classroom: [addr in heap]----------->["Lars"][ "Ruth"][ "leo"] ... ["ViJay"] |
               |      size: [15]  i: [   ] |        / [  19  ][   20  ][   18 ] ... [   21  ] |
               +---------------------------+       /| [  3.0 ][  3.8  ][  3.2 ] ... [  3.4  ] |
         main: |                           |      / | [ 2021 ][ 2020  ][ 2021 ] ... [ 2019  ] |
               | classrom2: [addr in heap]-------+  |                                         |
               +---------------------------+        +-----------------------------------------+

   Main's classroom2 variable points to an array of studentT structs on the heap. When classroom2 gets
   passed to updateAges, it makes a copy of the pointer, yielding another pointer that points to the
   same heap array.
   Figure 3. The memory layout of an array of struct studentT passed to a function.

   As always, the parameter gets a copy of the value of its argument (the memory address of the array in
   heap memory). Thus, modifying the array's elements in the function will persist to its argument's
   values (both the parameter and the argument refer to the same array in memory).

   The updateAges function cannot be passed the classroom3 array because its type is not the same as the
   parameter's type: classroom3 is an array of struct studentT *, not an array of struct studentT.

2.7.5. Self-Referential Structs
   A struct can be defined with fields whose type is a pointer to the same struct type. These
   self-referential struct types can be used to build linked implementations of data structures, such as
   linked lists, trees, and graphs.

   The details of these data types and their linked implementations are beyond the scope of this book.
   However, we briefly show one example of how to define and use a self-referential struct type to
   create a linked list in C. Refer to a textbook on data structures and algorithms for more information
   about linked lists.

   A linked list is one way to implement a list abstract data type. A list represents a sequence of
   elements that are ordered by their position in the list. In C, a list data structure could be
   implemented as an array or as a linked list using a self-referential struct type for storing
   individual nodes in the list.

   To build the latter, a programmer would define a node struct to contain one list element and a link
   to the next node in the list. Here's an example that could store a linked list of integer values:

struct node {
	int data;           // used to store a list element's data value
	struct node *next;  // used to point to the next node in the list
};

   Instances of this struct type can be linked together through the next field to create a linked list.

   This example code snippet creates a linked list containing three elements (the list itself is
   referred to by the head variable that points to the first node in the list):

struct node *head, *temp;
int i;

head = NULL;  // an empty linked list

head = malloc(sizeof(struct node));  // allocate a node
if (head == NULL) {
	printf("Error malloc\n");
	exit(1);
}
head->data = 10;    // set the data field
head->next = NULL;  // set next to NULL (there is no next element)

// add 2 more nodes to the head of the list:
for (i = 0; i < 2; i++) {
	temp = malloc(sizeof(struct node));  // allocate a node
	if (temp == NULL) {
		printf("Error malloc\n");
		exit(1);
	}
	temp->data = i;     // set data field
	temp->next = head;  // set next to point to current first node
	head = temp;        // change head to point to newly added node
}

   Note that the temp variable temporarily points to a malloc'ed node that gets initialized and then
   added to the beginning of the list by setting its next field to point to the node currently pointed
   to by head, and then by changing the head to point to this new node.

   The result of executing this code would look like Figure 4 in memory.

        Stack                            Heap
   +-------------+         +-----------------------------------+
   | head: [   ]------+----->[  1  ] :->[  0  ]  :->[  10 ]    |
   |             |   /     | [     ]-:  [     ] -:  [     ]--| |
   | temp: [   ]----+      |                                   |
   |             |         |                                   |
   |    i: [ 2 ] |         |                                   |
   +-------------+         +-----------------------------------+
   Figure 4. The layout in memory of three example linked list nodes.

   Two stack variables, head and temp, contain the address of the first node on the heap. The first
   node's next field points to the second node, whose next field points to the third. The third node's
   next pointer is null, indicating the end of the list.


---
[**1]https://diveintosystems.org/book/C1-C_intro/structs.html#_structs

1.6. Structs
   Arrays and structs are the two ways in which C supports creating collections of data elements. Arrays
   are used to create an ordered collection of data elements of the same type, whereas structs are used
   to create a collection of data elements of different types. A C programmer can combine array and
   struct building blocks in many different ways to create more complex data types and structures. This
   section introduces structs, and in the next chapter we characterize structs in more detail and
   show how you can combine them with arrays.

   C is not an object-oriented language; thus, it doesn't support classes. It does, however, support
   defining structured types, which are like the data part of classes. A struct is a type used to
   represent a heterogeneous collection of data; it's a mechanism for treating a set of different types
   as a single, coherent unit. C structs provide a level of abstraction on top of individual data
   values, treating them as a single type. For example, a student has a name, age, grade point average
   (GPA), and graduation year. A programmer could define a new struct type to combine those four data
   elements into a single struct student variable that contains a name value (type char [], to hold a
   string), an age value (type int), a GPA value (type float), and a graduation year value (type int). A
   single variable of this struct type can store all four pieces of data for a particular student; for
   example, ("Freya", 19, 3.7, 2021).

   There are three steps to defining and using struct types in C programs:
    1. Define a new struct type that represents the structure.
    2. Declare variables of the new struct type.
    3. Use dot (.) notation to access individual field values of the variable.

1.6.1. Defining a Struct Type
   A struct type definition should appear outside of any function, typically near the top of the
   program's .c file. The syntax for defining a new struct type is the following (struct is a reserved
   keyword):

struct <struct_name> {
	<field 1 type> <field 1 name>;
	<field 2 type> <field 2 name>;
	<field 3 type> <field 3 name>;
	...
};

   Here's an example of defining a new struct studentT type for storing student data:

struct studentT {
	char name[64];
	int age;
	float gpa;
	int grad_yr;
};

   This struct definition adds a new type to C's type system, and the type's name is struct studentT.
   This struct defines four fields, and each field definition includes the type and name of the field.
   Note that in this example, the name field's type is a character array, for use as a string.

1.6.2. Declaring Variables of Struct Types
   Once the type has been defined, you can declare variables of the new type, struct studentT. Note that
   unlike the other types we've encountered so far that consist of just a single word (for example, int,
   char, and float), the name of our new struct type is two words, struct studentT.
struct studentT student1, student2; // student1, student2 are struct studentT

1.6.3. Accessing Field Values
   To access field values in a struct variable, use dot notation:
<variable name>.<field name>

   When accessing structs and their fields, carefully consider the types of the variables you're using.
   Novice C programmers often introduce bugs into their programs by failing to account for the types of
   struct fields. Table 1 shows the types of several expressions surrounding our struct studentT
   type.

   Table 1. The Types Associated with Various Struct studentT Expressions
   -----------------------------------------------------------------------------------------
   Expression           C type
   -----------------------------------------------------------------------------------------
   student1             struct studentT
   student1.age         integer (int)
   student1.name        array of characters (char [])
   student1.name[3]     character (char), the type stored in each position of the name array
   -----------------------------------------------------------------------------------------

   Here are some examples of assigning a struct studentT variable's fields:

// The 'name' field is an array of characters, so we can use the 'strcpy'
// string library function to fill in the array with a string value.
strcpy(student1.name, "Kwame Salter");

// The 'age' field is an integer.
student1.age = 18 + 2;

// The 'gpa' field is a float.
student1.gpa = 3.5;

// The 'grad_yr' field is an int
student1.grad_yr = 2020;
student2.grad_yr = student1.grad_yr;

   Figure 1 illustrates the layout of the student1 variable in memory after the field assignments
   in the preceding example. Only the struct variable's fields (the areas in boxes) are stored in
   memory. The field names are labeled on the figure for clarity, but to the C compiler, fields are
   simply storage locations or offsets from the start of the struct variable's memory. For example,
   based on the definition of a struct studentT, the compiler knows that to access the field named gpa,
   it must skip past an array of 64 characters (name) and one integer (age). Note that in the figure,
   the name field only depicts the first six characters of the 64-character array.

                field
                names            stored values (memoty space)
   student1:    name: [ 'K' ][ 'w' ][ 'a' ][ 'm' ][ 'e' ][ ' ' ][ ... ]
                 age: [                    20                         ]
                 gpa: [                   3.5                         ]
             grad_yr: [                  2020                         ]
   Figure 1. The student1 variable's memory after assigning each of its fields
   The layout of student1's memory: the name field is a character array containing 'k' 'w' 'a' 'm' 'e'
   ... The age field holds 20, the gpa field stores 3.5, and grad_yr contains 2020.

   C struct types are lvalues, meaning they can appear on the left side of an assignment statement.
   Thus, a struct variable can be assigned the value of another struct variable using a simple
   assignment statement. The field values of the struct on the right side of the assignment statement
   are copied to the field values of the struct on the left side of the assignment statement. In other
   words, the contents of memory of one struct are copied to the memory of the other. Here's an example
   of assigning a struct's values in this way:

student2 = student1;  // student2 gets the value of student1
                      // (student1's field values are copied to
                      //  corresponding field values of student2)

strcpy(student2.name, "Frances Allen");  // change one field value

   Figure 2 shows the values of the two student variables after the assignment statement and call
   to strcpy have executed. Note that the figure depicts the name fields as the string values they
   contain rather than the full array of 64 characters.

   student1: [ "Kwame Talter" ]         student2: [ "Frances Allen" ]
             [       20       ]                   [       20        ]
             [      3.5       ]                   [      3.5        ]
             [     2020       ]                   [     2020        ]
   Figure 2. Layout of the student1 and student2 structs after executing the struct assignment and strcpy call
   Struct Values and Assignment: the field values of the struct on the right hand side are assigned to
   corresponding field values of the struct on the left hand side of the assignment statement.

   C provides a sizeof operator that takes a type and returns the number of bytes used by the type. The
   sizeof operator can be used on any C type, including struct types, to see how much memory space a
   variable of that type needs. For example, we can print the size of a struct studentT type:

// Note: the '%lu' format placeholder specifies an unsigned long value.
printf("number of bytes in student struct: %lu\n", sizeof(struct studentT));

   When run, this line should print out a value of at least 76 bytes, because 64 characters are in the
   name array (1 byte for each char), 4 bytes for the int age field, 4 bytes for the float gpa field,
   and 4 bytes for the int grad_yr field. The exact number of bytes might be larger than 76 on some
   machines.

   Here's a full example program that defines and demonstrates the use of our struct studentT type:

#include <stdio.h>
#include <string.h>

// Define a new type: struct studentT
// Note that struct definitions should be outside function bodies.
struct studentT {
	char name[64];
	int age;
	float gpa;
	int grad_yr;
};

int main(void) {
	struct studentT student1, student2;

	strcpy(student1.name, "Kwame Salter");  // name field is a char array
	student1.age = 18 + 2;                  // age field is an int
	student1.gpa = 3.5;                     // gpa field is a float
	student1.grad_yr = 2020;                // grad_yr field is an int

	/* Note: printf doesn't have a format placeholder for printing a
	* struct studentT (a type we defined).  Instead, we'll need to
	* individually pass each field to printf. */
	printf("name: %s age: %d gpa: %g, year: %d\n",
			student1.name, student1.age, student1.gpa, student1.grad_yr);

	/* Copy all the field values of student1 into student2. */
	student2 = student1;

	/* Make a few changes to the student2 variable. */
	strcpy(student2.name, "Frances Allen");
	student2.grad_yr = student1.grad_yr + 1;

	/* Print the fields of student2. */
	printf("name: %s age: %d gpa: %g, year: %d\n",
			student2.name, student2.age, student2.gpa, student2.grad_yr);

	/* Print the size of the struct studentT type. */
	printf("number of bytes in student struct: %lu\n", sizeof(struct studentT));

	return 0;
}

   When run, this program outputs the following:
name: Kwame Salter age: 20 gpa: 3.5, year: 2020
name: Frances Allen age: 20 gpa: 3.5, year: 2021
number of bytes in student struct: 76

   lvalues
   An lvalue is an expression that can appear on the left side of an assignment statement. It's an
   expression that represents a memory storage location. As we introduce C pointer types and examples of
   creating more complicated structures that combine C arrays, structs, and pointers, it's important to
   think carefully about types and to keep in mind which C expressions are valid lvalues (which can be
   used on the left side of an assignment statement).

   From what we know about C so far, single variables of base types, array elements, and structs are all
   lvalues. The name of a statically declared array is not an lvalue (you cannot change the base address
   of a statically declared array in memory). The following example code snippet illustrates valid and
   invalid C assignment statements based on the lvalue status of different types:

struct studentT {
	char name[32];
	int  age;
	float gpa;
	int  grad_yr;
};

int main(void) {
	struct studentT  student1, student2;
	int x;
	char arr[10], ch;
	
	x = 10;                 // Valid C: x is an lvalue
	ch = 'm';               // Valid C: ch is an lvalue
	student1.age = 18;      // Valid C: age field is an lvalue
	student2 = student1;    // Valid C: student2 is an lvalue
	arr[3] = ch;            // Valid C: arr[3] is an lvalue
	
	x + 1 = 8;       // Invalid C: x+1 is not an lvalue
	arr = "hello";   // Invalid C: arr is not an lvalue
	                 //  cannot change base addr of statically declared array
	                 //  (use strcpy to copy the string value "hello" to arr)
	
	student1.name = student2.name;  // Invalid C: name field is not an lvalue
	                                // (the base address of a statically
	                                //  declared array cannot be changed)

1.6.4. Passing Structs to Functions
   In C, arguments of all types are passed by value to functions. Thus, if a function has a struct type
   parameter, then when called with a struct argument, the argument's value is passed to its parameter,
   meaning that the parameter gets a copy of its argument's value. The value of a struct variable is the
   contents of its memory, which is why we can assign the fields of one struct to be the same as another
   struct in a single assignment statement like this:

student2 = student1;

   Because the value of a struct variable represents the full contents of its memory, passing a struct
   as an argument to a function gives the parameter a copy of all the argument struct's field values. If
   the function changes the field values of a struct parameter, the changes to the parameter's field
   values have no effect on the corresponding field values of the argument. That is, changes to the
   parameter's fields only modify values in the parameter's memory locations for those fields, not in
   the argument's memory locations for those fields.

   Here's a full example program using the checkID function that takes a struct parameter:

#include <stdio.h>
#include <string.h>

/* struct type definition: */
struct studentT {
	char name[64];
	int  age;
	float gpa;
	int  grad_yr;
};

/* function prototype (prototype: a declaration of the
 *    checkID function so that main can call it, its full
 *    definition is listed after main function in the file):
 */
int checkID(struct studentT s1, int min_age);

int main(void) {
	int can_vote;
	struct studentT student;

	strcpy(student.name, "Ruth");
	student.age = 17;
	student.gpa = 3.5;
	student.grad_yr = 2021;

	can_vote = checkID(student, 18);
	if (can_vote) {
		printf("%s is %d years old and can vote.\n",
				student.name, student.age);
	} else {
		printf("%s is only %d years old and cannot vote.\n",
				student.name, student.age);
	}

	return 0;
}

/*  check if a student is at least the min age
 *    s: a student
 *    min_age: a minimum age value to test
 *    returns: 1 if the student is min_age or older, 0 otherwise
 */
int checkID(struct studentT s, int min_age) {
	int ret = 1;  // initialize the return value to 1 (true)

	if (s.age < min_age) {
		ret = 0;  // update the return value to 0 (false)

		// let's try changing the student's age
		s.age = min_age + 1;
	}

	printf("%s is %d years old\n", s.name, s.age);

	return ret;
}

   When main calls checkID, the value of the student struct (a copy of the memory contents of all its
   fields) is passed to the s parameter. When the function changes the value of its parameter's age
   field, it doesn't affect the age field of its argument (student). This behavior can be seen by
   running the program, which outputs the following:

Ruth is 19 years old
Ruth is only 17 years old and cannot vote.

   The output shows that when checkID prints the age field, it reflects the function's change to the age
   field of the parameter s. However, after the function call returns, main prints the age field of
   student with the same value it had prior to the checkID call. Figure 3 illustrates the contents
   of the call stack just before the checkID function returns.

            +------------------------+
   CheckID: |       s: [ "Ruth" ]    |
            |          [   19   ]    |
            |          [  3.5   ]    |
            |          [ 2021   ]    |
            |                        |
            | min_age: [18] ret: [0] |
            +------------------------+
      main: |       s: [ "Ruth" ]    |
            |          [   17   ]    |
            |          [  3.5   ]    |
            |          [ 2021   ]    |
            |                        |
            |     ret: [?]           |
            +------------------------+
   Figure 3. The contents of the call stack before returning from the checkID function
   As the student struct is passed to checkID, the parameter gets a copy of its contents. When checkID
   modifies the age field to 19, the change only applies to its local copy. The student struct's age
   field in main remains at 17.

   Understanding the pass-by-value semantics of struct parameters is particularly important when a
   struct contains a statically declared array field (like the name field in struct studentT). When such
   a struct is passed to a function, the struct argument's entire memory contents, including every array
   element in the array field, is copied to its parameter. If the parameter struct's array contents are
   changed by the function, those changes will not persist after the function returns. This behavior
   might seem odd given what we know about how arrays are passed to functions, but it's consistent
   with the struct-copying behavior described earlier.


---

