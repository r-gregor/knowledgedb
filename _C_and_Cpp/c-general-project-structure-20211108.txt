filename: c_general-project-structure_20211108.txt
https://www.linkedin.com/pulse/what-general-c-project-structure-like-herbert-elwood-gilliland-iii

What is a general C++ project structure like?
Jan 10, 2020

   On Quora, my answer received 21,100 views by 1/10/20. I first answered the question in 2017.

     What is a general C++ project structure like? I've been reading through some C++ open
     source projects on GitHub and there's a number of strange things like bin, docs, lib, obj, src
     and etc. I plowed through them and finally came across some .cpp files. Which one should I open?
     How should I understand the overall relation of separate parts?

   The bin / include / lib / doc / src / build / data / config et cetera ad infinitum list of
   folders are a hodge-podge of things from a variety of places. It grew over time and became what it
   is. Since developers are free to roll-their-own, it really depends on the type of project or language
   or platform or IDE that they are working with.

   Most notably, GNU Linux, which created structures for its packages and has a lot of bureaucracy
   about what's supposed to be in them. These in turn influenced others, and some of it has just made
   good sense so people have kept up with it. Notably, Microsoft C++ developers don't adhere to this,
   you generally see .sln (Solution Files created by Visual Studio) and the like, however if the authors
   also develop for Linux, you might see some borrowing from the way Linux is organized due to their
   habits and familiarity with this folder structure. As far as "include" and "bin" and "lib" folders,
   this sort of organization is also generally true of DLLs and the entire "lib" thing is basically
   plagiarized / borrowed / copied by Microsoft from Linux / Unix (just like how DOS or Command Shell is
   basically borrowed / copied / plagiarized from the CP/M OS).

   Generally on the topic of project folders, it goes like this:
     * bin/ a folder that contains the compiled .DLL file or (sometimes) a .lib or the executable
       application or .exe file - the "binary"
     * include/ a folder that contains the publicly distributed .h (header files) for a library to be
       included in another application, required to use a library or DLL
     * lib/ a folder that contains statically linkable ,lib files (precompiled code) and is part of a
       library
     * doc/ all those nifty manuals programmers hate to write, or generated ones from the output of a
       source documentation utility like Doxygen, or a README file, or the .man files for Linux "man"
       command, or an offline website so you would see .html files
     * build/ a folder that is sometimes there for holding onto build scripts, half-built code, other
       stuff related to the compilation process, usually its generated by a utility or the compiler, you
       might see .objs here but you might not. There are other names for this folder on each platform,
       and sometimes you might find online documentation describing its structure, like for
       Android
     * src/ this is where the source code is, people edit this stuff, and it may have sub-folders
     * data/ some applications come with "sample data" or "test data" that usually sits in here and is
       accessed by the application in the bin/ folder
     * examples/ some libraries come with a set of applications that test out various "units" of the
       "system" and also demonstrate usage
     * contrib/ this used to mean "user-contributed snippets" or source code given to the primary author
       or authors for use or to extend an open-source project (or even a closed source one),
       though the "contrib" idea hit its popularity peak a long time ago, in a time when not everyone
       had a source versioning control utility like git
     * This is not the all-inclusive list. You might see something else, oh my!

   In C++ there are also the various file types, and the compiler related files, with specific
   extensions (though the idea of a file "extension" has eroded over time, we're talking MIME/types at
   this point I guess) in any given project:
     * .cpp & .h go together, .h being the "header" - designed this way to allow programmers to
       release libs and .h files without source code, to create proprietary or closed source libraries
       that can be distributed without source.
     * .hpp is a combination of the two files.  I've seen a lot of differing opinions as to why
       an .hpp and the .h / .cpp combination are picked over each other. It comes back to the age-old
       question of "where is the line drawn between C++ and C?" - on the Mac, you can't use .h in older
       xCode versions, and had to use .hpp with an associated .cpp - guess those arrogant Apple managers
       had to deal with the JIRA ticket when someone complained about this, because newer xCode can use
       .h just fine - plus, they knew Objective-C quite well but apparently didn't know this nuance of
       C++.

   See, C++ doesn't require you to use a .cpp anymore, so if you see an .hpp you are basically seeing
   the combination of the .cpp and .h file in a single file. Generally what would appear, in the .cpp,
   is at the end of an .hpp file, and the .h part is at the beginning of an .hpp file. Generally an .hpp
   is purely C++ because it doesn't allow for C-style functions (generally...)
     * Makefile (means its probably for Linux, though maybe not anymore) - this file, while it can be
       hand-written, is usually generated by autoconf and may be related to the "configure"
       command - a whole world in and of itself and unrelated to Microsoft Visual Studio - is used to
       "build" the application (automating compilation and linking) usually using compilers like gpp,
       g++ or gcc (all essentially the same compiler) and the associated GNU linker. Microsoft
       Visual Studio has another world and another compiler/linker/set of options to worry about. In
       later years, Linux developers have made versions of autoconf that also generate Visual Studio
       build scripts.
     * You might see other things, but these are the main bits of evidence from the source code. There
       is a .suo file that is entirely optional with Visual Studio (it contains the intellisense
       database). On both Linux and Windows, there is a series of .obj files (compiled source that has
       not yet been linked), there are .make and .bat and .sh and .doc and .html and a bunch of other
       files that are specific to different platforms, for example on Windows you might see a ".pdb"
       file which is the debug symbol information for an application - and on Linux there are usually
       scripts that have no specific file extension, or they would have the .sh extension - and if you
       see other files, they could be configuration files, or they could be documentation, or test data.
       Other files may be other things (see the footnote regarding Linux packages).
     * Generally a .pro file means the application is written in QT and QT has its own folder
       structures, which can also be customized. The .pro file is the file you load in QT Creator. You
       might see other files like ".qmake", ".ui", ".qc" and such, all for QT, which is now owned,
       through the acquisition of Nokia who acquired The Qt Company, by Microsoft.

   To go through a project you need:
    1. An IDE that lets you "go to definition" reliably, preferably you want to use the exact
       configuration the original author used - and hopefully some other editor or IDE that lets you
       search entire projects worth of files, and use intellisense or equivalent code navigation
       technologies, like Komodo Edit and/or Notepad++
    2. You need to know in advance if you are looking at a library, or you are looking at an
       application, if you don't know in advance, then the lack of an application entry point - most
       commonly a function defined as int main() that has been defined (and not declared), usually, in a
       file called main.cpp - lack of this is a definite indicator that it's not an application.

   FOR A LIBRARY:
     * Look for the most prominent file to start with, usually named after the most major concept or the
       library itself.

   FOR AN APPLICATION:
     * Locate your int main() and start exploring #include and symbols until you understand what it is
       you are looking at and how it is structured.


---

