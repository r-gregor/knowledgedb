filename: c_makefiles-different-source-target-dirs-multif_20221010.txt
https://riptutorial.com/makefile/example/21376/building-from-different-source-folders-to-different-target-folders

makefile Advanced Makefile Building from different source folders to different target folders

Example

   Main features of this Makefile :
	 * Automatic detection of C sources in specified folders
	 * Multiple source folders
	 * Multiple corresponding target folders for object and dependency files
	 * Automatic rule generation for each target folder
	 * Creation of target folders when they don't exist
	 * Dependency management with gcc : Build only what is necessary
	 * Works on Unix and DOS systems
	 * Written for GNU Make

   This Makefile can be used to build a project with this kind of structure :
=============================================================================================================
\---Project
	+---Sources
	|	+---Folder0
	|	|		main.c
	|	|
	|	+---Folder1
	|	|		file1_1.c
	|	|		file1_1.h
	|	|
	|	\---Folder2
	|			file2_1.c
	|			file2_1.h
	|			file2_2.c
	|			file2_2.h
	\---Build
		|	Makefile
		|	myApp.exe
		|
		+---Folder0
		|		main.d
		|		main.o
		|
		+---Folder1
		|		file1_1.d
		|		file1_1.o
		|
		\---Folder2
				file2_1.d
				file2_1.o
				file2_2.d
				file2_2.o
=============================================================================================================

   Makefile
# Set project directory one level above of Makefile directory. $(CURDIR) is a GNU make variable containing the
 path to the current working directory
PROJDIR := $(realpath $(CURDIR)/..)
SOURCEDIR := $(PROJDIR)/Sources
BUILDDIR := $(PROJDIR)/Build

# Name of the final executable
TARGET = myApp.exe

# Decide whether the commands will be shwon or not
VERBOSE = TRUE

# Create the list of directories
DIRS = Folder0 Folder1 Folder2
SOURCEDIRS = $(foreach dir, $(DIRS), $(addprefix $(SOURCEDIR)/, $(dir)))
TARGETDIRS = $(foreach dir, $(DIRS), $(addprefix $(BUILDDIR)/, $(dir)))

# Generate the GCC includes parameters by adding -I before each source folder
INCLUDES = $(foreach dir, $(SOURCEDIRS), $(addprefix -I, $(dir)))

# Add this list to VPATH, the place make will look for the source files
VPATH = $(SOURCEDIRS)

# Create a list of *.c sources in DIRS
SOURCES = $(foreach dir,$(SOURCEDIRS),$(wildcard $(dir)/*.c))

# Define objects for all sources
OBJS := $(subst $(SOURCEDIR),$(BUILDDIR),$(SOURCES:.c=.o))

# Define dependencies files for all objects
DEPS = $(OBJS:.o=.d)

# Name the compiler
CC = gcc

# OS specific part
ifeq ($(OS),Windows_NT)
	RM = del /F /Q
	RMDIR = -RMDIR /S /Q
	MKDIR = -mkdir
	ERRIGNORE = 2>NUL || true
	SEP=\\
else
	RM = rm -rf
	RMDIR = rm -rf
	MKDIR = mkdir -p
	ERRIGNORE = 2>/dev/null
	SEP=/
endif

# Remove space after separator
PSEP = $(strip $(SEP))

# Hide or not the calls depending of VERBOSE
ifeq ($(VERBOSE),TRUE)
	HIDE =
else
	HIDE = @
endif

# Define the function that will generate each rule
define generateRules
$(1)/%.o: %.c
	@echo Building $$@
	$(HIDE)$(CC) -c $$(INCLUDES) -o $$(subst /,$$(PSEP),$$@) $$(subst /,$$(PSEP),$$<) -MMD
endef

.PHONY: all clean directories

all: directories $(TARGET)

$(TARGET): $(OBJS)
	$(HIDE)echo Linking $@
	$(HIDE)$(CC) $(OBJS) -o $(TARGET)

# Include dependencies
-include $(DEPS)

# Generate rules
$(foreach targetdir, $(TARGETDIRS), $(eval $(call generateRules, $(targetdir))))

directories:
	$(HIDE)$(MKDIR) $(subst /,$(PSEP),$(TARGETDIRS)) $(ERRIGNORE)

# Remove all objects, dependencies and executable files generated during the build
clean:
	$(HIDE)$(RMDIR) $(subst /,$(PSEP),$(TARGETDIRS)) $(ERRIGNORE)
	$(HIDE)$(RM) $(TARGET) $(ERRIGNORE)
	@echo Cleaning done !

   How to use this Makefile To adapt this Makefile to your project you have to :
	1. Change the TARGET variable to match your target name
	2. Change the name of the Sources and Build folders in SOURCEDIR and BUILDDIR
	3. Change the verbosity level of the Makefile in the Makefile itself or in make call
	4. Change the name of the folders in DIRS to match your sources and build folders
	5. If required, change the compiler and the flags



---
https://rotadev.com/makefiles-with-source-files-in-different-directories-dev/

Makefiles with source files in different directories - Dev

   The best answers to the question "Makefiles with source files in different directories" in the
   category Dev.
   QUESTION:

   I have a project where the directory structure is like this:

                         $projectroot
                              |
              +---------------+----------------+
              |               |                |
            part1/          part2/           part3/
              |               |                |
       +------+-----+     +---+----+       +---+-----+
       |      |     |     |        |       |         |
     data/  src/  inc/  src/      inc/    src/      inc/

   How should I write a makefile that would be in part/src (or wherever really) that could comple/link
   on the c/c++ source files in part?/src ?

   Can I do something like
   -I$projectroot/part1/src -I$projectroot/part1/inc -I$projectroot/part2/src ...

   If that would work, is there an easier way to do it. I've seen projects where there is a makefile in
   each of the corresponding part? folders. [in this post I used the question mark like in bash syntax]

   ANSWER:
   If you have code in one subdirectory dependent on code in another subdirectory, you are probably
   better off with a single makefile at top-level.

   See Recursive Make Considered Harmful for the full rationale, but basically you want make to have the
   full information it needs to decide whether or not a file needs to be rebuilt, and it won't have that
   if you only tell it about a third of your project.

   The link above seems to be not reachable. The same document is reachable here:
	 * aegis.sourceforge.net (archived)
	 * lcgapp.cern.ch

   ANSWER:
   The traditional way is to have a Makefile in each of the subdirectories (part1, part2, etc.) allowing
   you to build them independently. Further, have a Makefile in the root directory of the project which
   builds everything. The "root" Makefile would look something like the following:
all:
	+$(MAKE) -C part1
	+$(MAKE) -C part2
	+$(MAKE) -C part3

   Since each line in a make target is run in its own shell, there is no need to worry about traversing
   back up the directory tree or to other directories.

   I suggest taking a look at the GNU make manual section 5.7; it is very helpful.

   ANSWER:
   You can add rules to your root Makefile in order to compile the necessary cpp files in other
   directories. The Makefile example below should be a good start in getting you to where you want to
   be.
CC=g++
TARGET=cppTest
OTHERDIR=../../someotherpath/in/project/src

SOURCE = cppTest.cpp
SOURCE = $(OTHERDIR)/file.cpp

## End sources definition
INCLUDE = -I./ $(AN_INCLUDE_DIR)
INCLUDE = -I.$(OTHERDIR)/../inc
## end more includes

VPATH=$(OTHERDIR)
OBJ=$(join $(addsuffix ../obj/, $(dir $(SOURCE))), $(notdir $(SOURCE:.cpp=.o)))

## Fix dependency destination to be ../.dep relative to the src dir
DEPENDS=$(join $(addsuffix ../.dep/, $(dir $(SOURCE))), $(notdir $(SOURCE:.cpp=.d)))

## Default rule executed
all: $(TARGET)
	@true

## Clean Rule
clean:
	@-rm -f $(TARGET) $(OBJ) $(DEPENDS)


## Rule for making the actual target
$(TARGET): $(OBJ)
	@echo "============="
	@echo "Linking the target [17][email protected]"
	@echo "============="
	@$(CC) $(CFLAGS) -o [18][email protected] $^ $(LIBS)
	@echo -- Link finished --

## Generic compilation rule
%.o : %.cpp
	@mkdir -p $(dir [19][email protected])
	@echo "============="
	@echo "Compiling $<"
	@$(CC) $(CFLAGS) -c $< -o [20][email protected]


## Rules for object files from cpp files
## Object file for each file is put in obj directory
## one level up from the actual source directory.
../obj/%.o : %.cpp
	@mkdir -p $(dir [21][email protected])
	@echo "============="
	@echo "Compiling $<"
	@$(CC) $(CFLAGS) -c $< -o [22][email protected]

# Rule for "other directory"  You will need one per "other" dir
$(OTHERDIR)/../obj/%.o : %.cpp
	@mkdir -p $(dir [23][email protected])
	@echo "============="
	@echo "Compiling $<"
	@$(CC) $(CFLAGS) -c $< -o [24][email protected]

## Make dependancy rules
../.dep/%.d: %.cpp
	@mkdir -p $(dir [25][email protected])
	@echo "============="
	@echo Building dependencies file for $*.o
	@$(SHELL) -ec '$(CC) -M $(CFLAGS) $< | sed "s^$*.o^../obj/$*.o^" > [26][email protected]'

## Dependency rule for "other" directory
$(OTHERDIR)/../.dep/%.d: %.cpp
	@mkdir -p $(dir [27][email protected])
	@echo "============="
	@echo Building dependencies file for $*.o
	@$(SHELL) -ec '$(CC) -M $(CFLAGS) $< | sed "s^$*.o^$(OTHERDIR)/../obj/$*.o^" > [28][email protected]'

## Include the dependency files
-include $(DEPENDS)


   ANSWER:
   The VPATH option might come in handy, which tells make what directories to look in for source code.
   You'd still need a -I option for each include path, though. An example:
CXXFLAGS=-Ipart1/inc -Ipart2/inc -Ipart3/inc
VPATH=part1/src:part2/src:part3/src

OutputExecutable: part1api.o part2api.o part3api.o

   This will automatically find the matching partXapi.cpp files in any of the VPATH specified
   directories and compile them. However, this is more useful when your src directory is broken into
   subdirectories. For what you describe, as others have said, you are probably better off with a
   makefile for each part, especially if each part can stand alone.



---
https://www.appsloveworld.com/cplus/100/25/how-to-write-a-makefile-with-separate-source-and-header-directories

How to write a Makefile with separate source and header directories?-C++

   The simple Makefile definitions seem OK to me as they appear in your question. Try specifying the
   compiler options before the file names:
$(ODIR)/%.o: %.c $(DEPS)
	$(CC) $(CFLAGS) -c -o $@ $<

hellomake: $(OBJ)
	gcc $(CFLAGS) -o $@ $^

   You need to run make from the source directory.

***
   When you got this error"
*gcc: fatal error: no input files
compilation terminated.*

   ", that means you do not have object files,

   just check out that line "${OBJS} := " in Makefile.

   Hi, bro!

   If your project "helloFunc" 's architecture are just liking this:

helloFunc
|
|__Makefile
|__build
|__include
|	  |__hellomake.h
|__src
	 |__hellofunc.cpp
	 |__hellomake.cpp


   your Makefile should be just like this:
# This is a Makefile for separated multiple sources to build with VSCode on mac
# Thanks, Job Vranish.
# (https://spin.atomicobject.com/2016/08/26/makefile-c-projects/)
# Reference: Makefile Tutorial
# (https://makefiletutorial.com/)
# Reference: @yagiyuki from Qiita
# (https://qiita.com/yagiyuki/items/ff343d381d9477e89f3b)
# Reference: simonsso from Github
# (https://github.com/simonsso/empty-cpp-project/blob/master/Makefile)
# Reference: Chinese Website blogger CDNS
# (https://blog.csdn.net/qq_22073849/article/details/88893201)

# (1)Compiler
# clang++
CXX = clang++
# (2)Compile options
# -Wall -Wextra -std=c++11 -g
CXX_FLAGS = -Wall -Wextra -std=c++11 -g
# (3)Build task directory path
# I do care about out-of-source builds
# ./build
BUILD_DIR ?= ./build
# (4)Source files directory path
# ./src
SRC_DIRS ?= ./src
# (5)Library files directory path
LIBDIR :=
# (6)Add library files
LIBS :=
# (7)Target file, excutable file.
# main
TARGET ?= main
# (8)Source files(code), to be compiled
# Find source files we want to compile
# *expression must around by single quotos
# ./src/bank.cpp ./src/main.cpp
SRCS := $(shell find $(SRC_DIRS) -name '*.cpp' -or -name '*.c' -or -name '*.s')
# (9)Object files
# String substituion for every C/C++ file
# e.g: ./src/bank.cpp turns into ./build/bank.cpp.o
# ./build/bank.cpp.o  ./build/main.cpp.o
OBJS := $(patsubst %.cpp, ${BUILD_DIR}/%.cpp.o, $(notdir $(SRCS)))
# (10)Dependency files
# which will generate a .d file next to the .o file. Then to use the .d files,
# you just need to find them all:
#
DEPS := $(OBJS:.o=.d)
# (11)Include files directory path
# Every folder in ./src find include files to be passed via clang
# ./include
INC_DIRS := ./include
# (12)Include files add together a prefix, clang make sense that -I flag
INC_FLAGS := $(addprefix -I,$(INC_DIRS))
# (13)Make Makefiles output Dependency files
# That -MMD and -MP flags together to generate Makefiles
# That generated Makefiles will take .o as .d to the output
# That "-MMD" and "-MP" To generate the dependency files, all you have to do is
# add some flags to the compile command (supported by both Clang and GCC):
CPP_FLAGS ?= $(INC_FLAGS) -MMD -MP
# (14)Link: Generate executable file from object file
# make your target depend on the objects files:
${BUILD_DIR}/${TARGET} : $(OBJS)
	$(CXX) $(OBJS) -o $@
# (15)Compile: Generate object files from source files
# $@ := {TARGET}
# $< := THE first file
# $^ all the dependency
# C++ Sources
$(BUILD_DIR)/%.cpp.o: $(SRC_DIRS)/%.cpp
	$(MKDIR_P) $(dir $@)
	$(CXX) $(CPP_FLAGS) $(CXX_FLAGS) -c $< -o $@

#(16)Delete dependence files, object files, and the target file
.PHONY: all clean
all: ${BUILD_DIR}/${TARGET}


clean:
	$(RM) $(DEPS) $(OBJS) ${BUILD_DIR}/${TARGET}

-include $(DEPS)

MKDIR_P ?= mkdir -p

   Changing that Makefile to your needed Linux version:
# (1)Compiler
# g++
CXX = g++
# (2)Compile options
# -Wall -Wextra -std=c++11 -g
CXX_FLAGS = -Wall -Wextra -std=c++11 -g
# (3)Build task directory path
# I do care about out-of-source builds
# ./build
BUILD_DIR ?= ./build
# (4)Source files directory path
# ./src
SRC_DIRS ?= ./src
# (5)Library files directory path
LIBDIR :=
# (6)Add library files
LIBS :=
# (7)Target file, excutable file.
# main
TARGET ?= main
# (8)Source files(code), to be compiled
# Find source files we want to compile
# *expression must around by single quotos
# ./src/bank.cpp ./src/main.cpp
SRCS := $(shell find $(SRC_DIRS) -name '*.cpp' -or -name '*.c' -or -name '*.s')
# (9)Object files
# String substituion for every C/C++ file
# e.g: ./src/bank.cpp turns into ./build/bank.cpp.o
# ./build/bank.cpp.o  ./build/main.cpp.o
OBJS := $(patsubst %.cpp, ${BUILD_DIR}/%.cpp.o, $(notdir $(SRCS)))
# (10)Dependency files
# which will generate a .d file next to the .o file. Then to use the .d files,
# you just need to find them all:
#
DEPS := $(OBJS:.o=.d)
# (11)Include files directory path
# Every folder in ./src find include files to be passed via clang
# ./include
INC_DIRS := ./include
# (12)Include files add together a prefix, gcc make sense that -I flag
INC_FLAGS := $(addprefix -I,$(INC_DIRS))
# (13)Make Makefiles output Dependency files
# That -MMD and -MP flags together to generate Makefiles
# That generated Makefiles will take .o as .d to the output
# That "-MMD" and "-MP" To generate the dependency files, all you have to do is
# add some flags to the compile command (supported by both Clang and GCC):
CPP_FLAGS ?= $(INC_FLAGS) -MMD -MP
# (14)Link: Generate executable file from object file
# make your target depend on the objects files:
${BUILD_DIR}/${TARGET} : $(OBJS)
	$(CXX) $(OBJS) -o $@
# (15)Compile: Generate object files from source files
# $@ := {TARGET}
# $< := THE first file
# $^ all the dependency
# C++ Sources
$(BUILD_DIR)/%.cpp.o: $(SRC_DIRS)/%.cpp
	$(MKDIR_P) $(dir $@)
	$(CXX) $(CPP_FLAGS) $(CXX_FLAGS) -c $< -o $@

#(16)Delete dependency files, object files and the target file
.PHONY: all clean
all: ${BUILD_DIR}/${TARGET}
clean:
	$(RM) $(DEPS) $(OBJS) ${BUILD_DIR}/${TARGET}

-include $(DEPS)

MKDIR_P ?= mkdir -p

   What you need to notice is that your "Makefile" file is the same directory of the include files and
   sources files,

   so you need to change your "IDIR:=../include" to "IDIR:=./include" in your "Makefile".

   END!

***
   the make utility, with no specific 'target' will make the first target in the file.

   The first target is usually named 'all'

   For the posted file, will make the object files and will not continue to make the executable when the
   target is not given in the command line

   Suggest the following:
SHELL := /bin/sh

# following so could define executable name on command line
# using the '-D' parameter
#ifndef $(NAME)
	NAME := hellomake
#endif

# use ':=' so macros only evaluated once


MAKE    :=    /usr/bin/make
CC      :=    /usr/bin/gcc

CFLAGS  := -g -Wall -Wextra -pedantic
LFLAGS  :=

ODIR    := obj
IDIR    := ../include
LIBS    :=
LIBPATH := ../lib

DEPS    := $(wildcard $(IDIR)/*.h)
SRCS    := $(wildcard *.c)
OBJS    := $(SRCS:.c=.o)

.PHONY: all
all: $(NAME) $(OBJS)

$(ODIR)/%.o: %.c $(DEPS)
	$(CC) $(CFLAGS) -c -o $@ $< -I$(DEPS)

$(NAME): $(OBJS)
	$(CC) $(LFLAGS) -o $@ $^ -L$(LIBPATH) -l$(LIBS)

.PHONY: clean
clean:
	rm -f $(ODIR)/*.o
	rm -f $(NAME)


however, in your proposed project,
not every source file needs every header file
so should use either gcc or sed to generate the dependency files
then use makefile rules similar to the following,
which may need a little 'tweaking' for your project
because the include files are not in the same directory
as the source files:

DEP := $(SRCS:.c=.d)

#
#create dependency files
#
%.d: %.c
	#
	# ========= START $< TO $@ =========
	$(CC) -M $(CPPFLAGS) $< > $@.$$$$;						\
	sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@;		\
	rm -f $@.$$$$
	# ========= END $< TO $@ =========

#
# compile the .c files into .o files using the compiler flags
#
%.o: %.c %.d
	 #
	 # ========= START $< TO $@ =========
	 $(CC) $(CCFLAGS) -c $< -o $@ -I$(IDIR)
	 # ========= END $< TO $@ =========
	 #

# include the contents of all the .d files
# note: the .d files contain:
# <filename>.o:<filename>.c plus all the dependencies for that .c file
# I.E. the #include'd header files
# wrap with ifneg... so will not rebuild *.d files when goal is 'clean'
#
ifneq "$(MAKECMDGOALS)" "clean"
-include $(DEP)
endif

***
   Your tutorial promotes old and bad practices, you should avoid it IMHO.

   In your rule here:
$(ODIR)/%.o: %.c $(DEPS)

   You're telling make to look for sources in the current directory while they actually reside in the
   src directory, thus this pattern is never used and you have no suitable one.
	 ________________________________________________________________________________________________

   Make sure you organize your project directory like this :
root
+-- include/
|	+-- all .h files here
+-- lib/
|	+-- all third-party library files (.a/.so files) here
+-- src/
|	+-- all .c files here
+-- Makefile

   Then let's take the process step by step, using good practices.

   Firstly, don't define anything if you don't need to. Make has a lot of predefined variables and
   functions that you should use before trying to do it manually. In fact, he has so many that you can
   compile a simple file without even having a Makefile in the directory at all!
	1. List your source and build output directories:
 SRC_DIR := src
 OBJ_DIR := obj
 BIN_DIR := bin # or . if you want it in the current directory

	2. Name your final target, that is, your executable:
 EXE := $(BIN_DIR)/hellomake

	3. List your source files:
 SRC := $(wildcard $(SRC_DIR)/*.c)

	4. From the source files, list the object files:
 OBJ := $(SRC:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)
 # You can also do it like that
 OBJ := $(patsubst $(SRC_DIR)/%.c, $(OBJ_DIR)/%.o, $(SRC))

	5. Now let's handle the flags
 CPPFLAGS := -Iinclude -MMD -MP   # -I is a preprocessor flag, not a compiler flag
 CFLAGS   := -Wall                # some warnings about bad code
 LDFLAGS  := -Llib                # -L is a linker flag
 LDLIBS   := -lm                  # Left empty if no libs are needed

   (CPP stands for C PreProcessor here, not CPlusPlus! Use CXXFLAGS for C++ flags and CXX for C++
   compiler.)

   The -MMD -MP flags are used to generate the header dependencies automatically. We will use this
   later on to trigger a compilation when only a header changes.

   Ok, time to roll some recipes now that our variables are correctly filled.

   It is widely spread that the default target should be called all and that it should be the first
   target in your Makefile. Its prerequisites shall be the target you want to build when writing only
   make on the command line:
all: $(EXE)

   One problem though is Make will think we want to actually create a file or folder named all, so let's
   tell him this is not a real target:
.PHONY: all

   Now list the prerequisites for building your executable, and fill its recipe to tell make what to do
   with these:
$(EXE): $(OBJ)
	$(CC) $(LDFLAGS) $^ $(LDLIBS) -o $@

   (CC stands for C Compiler.)

   Note that your $(BIN_DIR) might not exist yet so the call to the compiler might fail. Let's tell make
   that you want it to check for that first:
$(EXE): $(OBJ) | $(BIN_DIR)
	$(CC) $(LDFLAGS) $^ $(LDLIBS) -o $@

$(BIN_DIR):
	mkdir -p $@

   Some quick additional notes:
	 * $(CC) is a built-in variable already containing what you need when compiling and linking in C
	 * To avoid linker errors, it is strongly recommended to put $(LDFLAGS) before your object files and
	   $(LDLIBS) after
	 * $(CPPFLAGS) and $(CFLAGS) are useless here, the compilation phase is already over, it is the
	   linking phase here

   Next step, since your source and object files don't share the same prefix, you need to tell make
   exactly what to do since its built-in rules don't cover your specific case:
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
	$(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@

   Same problem as before, your $(OBJ_DIR) might not exist yet so the call to the compiler might fail.
   Let's update the rules:
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c | $(OBJ_DIR)
	$(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@

$(BIN_DIR) $(OBJ_DIR):
	mkdir -p $@

   Ok, now the executable should build nicely. We want a simple rule to clean the build artifacts
   though:
clean:
	@$(RM) -rv $(BIN_DIR) $(OBJ_DIR) # The @ disables the echoing of the command

   (Again, clean is not a target that needs to be created, so add it to the .PHONY special target!)

   Last thing. Remember about the automatic dependency generation? GCC and Clang will create .d files
   corresponding to your .o files, which contains Makefile rules for us to use, so let's include that in
   here:
-include $(OBJ:.o=.d) # The dash silences errors when files don't exist (yet)
	 ________________________________________________________________________________________________

   Final result:
SRC_DIR := src
OBJ_DIR := obj
BIN_DIR := bin

EXE := $(BIN_DIR)/hellomake
SRC := $(wildcard $(SRC_DIR)/*.c)
OBJ := $(SRC:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)

CPPFLAGS := -Iinclude -MMD -MP
CFLAGS	 := -Wall
LDFLAGS  := -Llib
LDLIBS	 := -lm

.PHONY: all clean

all: $(EXE)

$(EXE): $(OBJ) | $(BIN_DIR)
	$(CC) $(LDFLAGS) $^ $(LDLIBS) -o $@

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c | $(OBJ_DIR)
	$(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@

$(BIN_DIR) $(OBJ_DIR):
	mkdir -p $@

clean:
	@$(RM) -rv $(BIN_DIR) $(OBJ_DIR)

-include $(OBJ:.o=.d)



---
https://spin.atomicobject.com/2016/08/26/makefile-c-projects/

A Super-Simple Makefile for Medium-Sized C/C++ Projects

   I've used Make for a lot for small projects, but for larger ones, it was just too tedious. Until
   recently, there were four things I wanted my build system to do for me that I hadn't figured out how
   to do in Make:
	 * Out-of-source builds (object files get dumped in a separate directory from the source)
	 * Automatic (and accurate!) header dependencies
	 * Automatic determination of list of object/source files
	 * Automatic generation of include directory flags

   Here is a simple Makefile that will do all these things and works with C, C++, and assembly:

TARGET_EXEC ?= a.out

BUILD_DIR ?= ./build
SRC_DIRS ?= ./src

SRCS := $(shell find $(SRC_DIRS) -name *.cpp -or -name *.c -or -name *.s)
OBJS := $(SRCS:%=$(BUILD_DIR)/%.o)
DEPS := $(OBJS:.o=.d)

INC_DIRS := $(shell find $(SRC_DIRS) -type d)
INC_FLAGS := $(addprefix -I,$(INC_DIRS))

CPPFLAGS ?= $(INC_FLAGS) -MMD -MP

$(BUILD_DIR)/$(TARGET_EXEC): $(OBJS)
	$(CC) $(OBJS) -o $@ $(LDFLAGS)

# assembly
$(BUILD_DIR)/%.s.o: %.s
	$(MKDIR_P) $(dir $@)
	$(AS) $(ASFLAGS) -c $< -o $@

# c source
$(BUILD_DIR)/%.c.o: %.c
	$(MKDIR_P) $(dir $@)
	$(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@

# c++ source
$(BUILD_DIR)/%.cpp.o: %.cpp
	$(MKDIR_P) $(dir $@)
	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $< -o $@


.PHONY: clean

clean:
	$(RM) -r $(BUILD_DIR)

-include $(DEPS)

MKDIR_P ?= mkdir -p


   Not too bad!
   Also, if you don't care about out-of-source builds, you can use this even simpler Makefile, which
   takes advantage of the built-in implicit rules:


TARGET ?= a.out
SRC_DIRS ?= ./src

SRCS := $(shell find $(SRC_DIRS) -name *.cpp -or -name *.c -or -name *.s)
OBJS := $(addsuffix .o,$(basename $(SRCS)))
DEPS := $(OBJS:.o=.d)

INC_DIRS := $(shell find $(SRC_DIRS) -type d)
INC_FLAGS := $(addprefix -I,$(INC_DIRS))

CPPFLAGS ?= $(INC_FLAGS) -MMD -MP

$(TARGET): $(OBJS)
	$(CC) $(LDFLAGS) $(OBJS) -o $@ $(LOADLIBES) $(LDLIBS)

.PHONY: clean
clean:
	$(RM) $(TARGET) $(OBJS) $(DEPS)

-include $(DEPS)


   To use one of them, put the Make code in a file call Makefile (make sure the TAB characters get
   copied! Make is very picky about those) and all of your source and headers in the directory or a
   subdirectory of ./src (you can change this directory by changing SRC_DIRS). Then make sure you have
   CC and CFLAGS set to what you need for your project or just use the Make defaults.
   Then type make.

   If you run into issues, running make -d can be helpful.

   Here's an overview of how it works:

Out-of-Source Builds
   I want all the artifacts from a build to end up in some directory (I usually name it "./build")
   that's separate from the source. This makes is easy to do a clean (just rm -rf ./build) even if other
   artifacts besides the ones generated via Make end up there. It also makes a lot of other things, such
   as grep'ing the source, a lot nicer.

   To do this in Make, you mostly just need to prepend your output directory to the beginning of your
   pattern rules. For example, instead of a pattern like: %.o: %.c, which would map your .c files for .o
   files in the same directory, you can use $(BUILD_DIR)%.o: %.c.

Automatic Header Dependencies
   Handling the header dependencies is perhaps the most tedious thing about using the classic Make
   technique. Especially since, if you mess it up, you don't get any explicit errors-things just don't
   get re-compiled when they ought to be. This can lead to .o files having different ideas about what
   types or prototypes look like.

   There is documentation for this here. However, the docs seem to assume that the dependency files
   are generated in a separate step from the compile step, which complicates things.

   If you generate the dependency files as part of the compilation step, things get much simpler. To
   generate the dependency files, all you have to do is add some flags to the compile command (supported
   by both Clang and GCC):
	 * -MMD -MP
	   which will generate a .d file next to the .o file. Then to use the .d files, you just need to
	   find them all:
	 * DEPS := $(OBJS:.o=.d)
	   and then -include them:
	 * -include $(DEPS)

Automatic Determination of List of Object/Source Files
   First, find all of the source files in the given source directories. The simplest and fastest way I
   found to do this was to just shell out and use find.
	 * SRCS := $(shell find $(SRC_DIRS) -name *.cpp -or -name *.c -or -name *.s)
	   But because Make works backward from the object files to the source, we need to compute all the
	   object files we want from our source files. I basically just prepend a $(BUILD_DIR)/ and append a
	   .o to every source file path:
	 * OBJS := $(SRCS:%=$(BUILD_DIR)/%.o)
	   And then you can make your target depend on the objects files:
	 *
$(BUILD_DIR)/$(TARGET_EXEC): $(OBJS)
  $(CC) $(OBJS) -o $@ $(LDFLAGS)

Automatic Generation of Include Directory Flags

   I used a similar technique to generate include directory flags. Find all the directories under the
   given source directories:
	 * INC_DIRS := $(shell find $(SRC_DIRS) -type d)
	   And then prefix them with a -I:
	 * INC_FLAGS := $(addprefix -I,$(INC_DIRS))



---
https://cs.colby.edu/maxwell/courses/tutorials/maketutor/

A Simple Makefile Tutorial

Makefiles are a simple way to organize code compilation. This tutorial does not even scratch the surface of
what is possible using make, but is intended as a starters guide so that you can quickly and easily create
your own makefiles for small to medium-sized projects.

A Simple Example
Let's start off with the following three files, hellomake.c, hellofunc.c, and hellomake.h, which would
represent a typical main program, some functional code in a separate file, and an include file, respectively.

+------------------------+------------------------------------+--------------------------------+
|  hellomake.c           |  hellofunc.c                       |  hellomake.h                   |
+------------------------+------------------------------------+--------------------------------+
| #include <hellomake.h> |   #include <stdio.h>               |   /*                           |
|                        |   #include <hellomake.h>           |   example include file         |
| int main() {           |                                    |   */                           |
| 	// call a function   |   void myPrintHelloMake(void) {    |                                |
| 	// in another file   |   	printf("Hello makefiles!\n"); |   void myPrintHelloMake(void); |
|   myPrintHelloMake();  |   	return;                       |                                |
| 	return(0);           |   }                                |                                |
| }                      |                                    |                                |
|                        |                                    |                                |
+------------------------+------------------------------------+--------------------------------+

Normally, you would compile this collection of code by executing the following command:
$> gcc -o hellomake hellomake.c hellofunc.c -I.

This compiles the two .c files and names the executable hellomake. The -I. is included so that gcc will look
in the current directory (.) for the include file hellomake.h. Without a makefile, the typical approach to
the test/modify/debug cycle is to use the up arrow in a terminal to go back to your last compile command so
you don't have to type it each time, especially once you've added a few more .c files to the mix.

Unfortunately, this approach to compilation has two downfalls. First, if you lose the compile command or
switch computers you have to retype it from scratch, which is inefficient at best. Second, if you are only
making changes to one .c file, recompiling all of them every time is also time-consuming and inefficient.
So, it's time to see what we can do with a makefile.

The simplest makefile you could create would look something like:
Makefile 1

hellomake: hellomake.c hellofunc.c
	 gcc -o hellomake hellomake.c hellofunc.c -I.

If you put this rule into a file called Makefile or makefile and then type make on the command line it will
execute the compile command as you have written it in the makefile. Note that make with no arguments
executes the first rule in the file. Furthermore, by putting the list of files on which the command depends
on the first line after the :, make knows that the rule hellomake needs to be executed if any of those files
change. Immediately, you have solved problem #1 and can avoid using the up arrow repeatedly, looking for
your last compile command. However, the system is still not being efficient in terms of compiling only the
latest changes.

One very important thing to note is that there is a tab before the gcc command in the makefile. There must
be a tab at the beginning of any command, and make will not be happy if it's not there.

In order to be a bit more efficient, let's try the following:
Makefile 2

CC=gcc
CFLAGS=-I.

hellomake: hellomake.o hellofunc.o
	 $(CC) -o hellomake hellomake.o hellofunc.o

So now we've defined some constants CC and CFLAGS. It turns out these are special constants that communicate
to make how we want to compile the files hellomake.c and hellofunc.c. In particular, the macro CC is the C
compiler to use, and CFLAGS is the list of flags to pass to the compilation command. By putting the object
files--hellomake.o and hellofunc.o--in the dependency list and in the rule, make knows it must first compile
the .c versions individually, and then build the executable hellomake.

Using this form of makefile is sufficient for most small scale projects. However, there is one thing missing:
dependency on the include files. If you were to make a change to hellomake.h, for example, make would not
recompile the .c files, even though they needed to be. In order to fix this, we need to tell make that all .c
files depend on certain .h files. We can do this by writing a simple rule and adding it to the makefile.

Makefile 3

CC=gcc
CFLAGS=-I.
DEPS = hellomake.h

%.o: %.c $(DEPS)
	$(CC) -c -o $@ $< $(CFLAGS)

hellomake: hellomake.o hellofunc.o 
	$(CC) -o hellomake hellomake.o hellofunc.o 

This addition first creates the macro DEPS, which is the set of .h files on which the .c files depend. Then
we define a rule that applies to all files ending in the .o suffix. The rule says that the .o file depends
upon the .c version of the file and the .h files included in the DEPS macro. The rule then says that to
generate the .o file, make needs to compile the .c file using the compiler defined in the CC macro. The -c
flag says to generate the object file, the -o $@ says to put the output of the compilation in the file named
on the left side of the :, the $< is the first item in the dependencies list, and the CFLAGS macro is
defined as above.

As a final simplification, let's use the special macros $@ and $^, which are the left and right sides of the :,
respectively, to make the overall compilation rule more general. In the example below, all of the include
files should be listed as part of the macro DEPS, and all of the object files should be listed as part of
the macro OBJ.

Makefile 4

CC=gcc
CFLAGS=-I.
DEPS = hellomake.h
OBJ = hellomake.o hellofunc.o 

%.o: %.c $(DEPS)
	$(CC) -c -o $@ $< $(CFLAGS)

hellomake: $(OBJ)
	$(CC) -o $@ $^ $(CFLAGS)

So what if we want to start putting our .h files in an include directory, our source code in a src directory,
and some local libraries in a lib directory? Also, can we somehow hide those annoying .o files that hang
around all over the place? The answer, of course, is yes. The following makefile defines paths to the
include and lib directories, and places the object files in an obj subdirectory within the src directory. It
also has a macro defined for any libraries you want to include, such as the math library -lm. This makefile
should be located in the src directory. Note that it also includes a rule for cleaning up your source and
object directories if you type make clean. The .PHONY rule keeps make from doing something with a file named
clean.

Makefile 5

IDIR =../include
CC=gcc
CFLAGS=-I$(IDIR)

ODIR=obj
LDIR =../lib

LIBS=-lm

_DEPS = hellomake.h
DEPS = $(patsubst %,$(IDIR)/%,$(_DEPS))

_OBJ = hellomake.o hellofunc.o 
OBJ = $(patsubst %,$(ODIR)/%,$(_OBJ))


$(ODIR)/%.o: %.c $(DEPS)
	$(CC) -c -o $@ $< $(CFLAGS)

hellomake: $(OBJ)
	$(CC) -o $@ $^ $(CFLAGS) $(LIBS)

.PHONY: clean

clean:
	rm -f $(ODIR)/*.o *~ core $(INCDIR)/*~ 

So now you have a perfectly good makefile that you can modify to manage small and medium-sized software
projects. You can add multiple rules to a makefile; you can even create rules that call other rules. For
more information on makefiles and the make function, check out the GNU Make Manual, which will tell you more
than you ever wanted to know (really).



---
https://www.oreilly.com/library/view/managing-projects-with/0596006101/ch06.html

Managing Projects with GNU Make, 3rd Edition by Robert Mecklenburg

Chapter 6. Managing Large Projects
   What do you call a large project? For our purposes, it is one that requires a team of developers, may
   run on multiple architectures, and may have several field releases that require maintenance. Of
   course, not all of these are required to call a project large. A million lines of prerelease C++ on a
   single platform is still large. But software rarely stays prerelease forever. And if it is
   successful, someone will eventually ask for it on another platform. So most large software systems
   wind up looking very similar after awhile.

   Large software projects are usually simplified by dividing them into major components, often
   collected into distinct programs, libraries, or both. These components are often stored under their
   own directories and managed by their own makefiles. One way to build an entire system of components
   employs a top-level makefile that invokes the makefile for each component in the proper order. This
   approach is called recursive make because the top-level makefile invokes make recursively on each
   component's makefile. Recursive make is a common technique for handling componentwise builds. An
   alternative suggested by Peter Miller in 1998 avoids many issues with recursive make by using a
   single makefile that includes information from each component directory.^[[21]12]

   Once a project gets beyond building its components, it eventually finds that there are larger
   organizational issues in managing builds. These include handling development on multiple versions of
   a project, supporting several platforms, providing efficient access to source and binaries, and
   performing automated builds. We will discuss these problems in the second half of this chapter.

Recursive make
   The motivation behind recursive make is simple: make works very well within a single directory (or
   small set of directories) but becomes more complex when the number of directories grows. So, we can
   use make to build a large project by writing a simple, self-contained makefile for each directory,
   then executing them all individually. We could use a scripting tool to perform this execution, but it
   is more effective to use make itself since there are also dependencies involved at the higher level.

   For example, suppose I have an mp3 player application. It can logically be divided into several
   components: the user interface, codecs, and database management. These might be represented by three
   libraries: libui.a, libcodec.a, and libdb.a. The application itself consists of glue holding these
   pieces together. A straightforward mapping of these components onto a file structure might look like
   Figure 6-1.
   File layout for an MP3 player
   Figure 6-1. File layout for an MP3 player

   A more traditional layout would place the application's main function and glue in the top directory
   rather than in the subdirectory app/player. I prefer to put application code in its own directory to
   create a cleaner layout at the top level and allow for growth of the system with additional modules.
   For instance, if we choose to add a separate cataloging application later it can neatly fit under
   app/catalog.

   If each of the directories lib/db, lib/codec, lib/ui, and app/player contains a makefile, then it is
   the job of the top-level makefile to invoke them.
lib_codec   := lib/codec
lib_db      := lib/db
lib_ui      := lib/ui
libraries   := $(lib_ui) $(lib_db) $(lib_codec)
player      := app/player

.PHONY: all $(player) $(libraries)
all: $(player)

$(player) $(libraries):
	$(MAKE) --directory=$@

$(player): $(libraries)
$(lib_ui): $(lib_db) $(lib_codec)

   The top-level makefile invokes make on each subdirectory through a rule that lists the subdirectories
   as targets and whose action is to invoke make:
$(player) $(libraries):
	$(MAKE) --directory=$@

   The variable MAKE should always be used to invoke make within a makefile. The MAKE variable is
   recognized by make and is set to the actual path of make so recursive invocations all use the same
   executable. Also, lines containing the variable MAKE are handled specially when the command-line
   options --touch (-t), --just-print (-n), and --question (-q) are used. We'll discuss this in detail
   in the section Command-Line Options later in this chapter.

   The target directories are marked with .PHONY so the rule fires even though the target may be up to
   date. The --directory (-C) option is used to cause make to change to the target directory before
   reading a makefile.

   This rule, although a bit subtle, overcomes several problems associated with a more straightforward
   command script:
all:
	for d in $(player) $(libraries); \
	do                               \
		$(MAKE) --directory=$$d;     \
	done

   This command script fails to properly transmit errors to the parent make. It also does not allow make
   to execute any subdirectory builds in parallel. We'll discuss this feature of make in Chapter 10.

   As make is planning the execution of the dependency graph, the prerequisites of a target are
   independent of one another. In addition, separate targets with no dependency relationships to one
   another are also independent. For example, the libraries have no inherent relationship to the
   app/player target or to each other. This means make is free to execute the app/player makefile before
   building any of the libraries. Clearly, this would cause the build to fail since linking the
   application requires the libraries. To solve this problem, we provide additional dependency
   information.
$(player): $(libraries)
$(lib_ui): $(lib_db) $(lib_codec)

   Here we state that the makefiles in the library subdirectories must be executed before the makefile
   in the player directory. Similarly, the lib/ui code requires the lib/db and lib/codec libraries to be
   compiled. This ensures that any generated code (such as yacc/lex files) have been generated before
   the ui code is compiled.

   There is a further subtle ordering issue when updating prerequisites. As with all dependencies, the
   order of updating is determined by the analysis of the dependency graph, but when the prerequisites
   of a target are listed on a single line, GNU make happens to update them from left to right. For
   example:
all: a b c
all: d e f

   If there are no other dependency relationships to be considered, the six prerequisites can be updated
   in any order (e.g., "d b a c e f"), but GNU make uses left to right within a single target line,
   yielding the update order: "a b c d e f" or "d e f a b c." Although this ordering is an accident of
   the implementation, the order of execution appears correct. It is easy to forget that the correct
   order is a happy accident and fail to provide full dependency information. Eventually, the dependency
   analysis will yield a different order and cause problems. So, if a set of targets must be updated in
   a specific order, enforce the proper order with appropriate prerequisites.

   When the top-level makefile is run, we see:
$> make
make --directory=lib/db
make[1]: Entering directory `/test/book/out/ch06-simple/lib/db'
Update db library...
make[1]: Leaving directory `/test/book/out/ch06-simple/lib/db'
make --directory=lib/codec
make[1]: Entering directory `/test/book/out/ch06-simple/lib/codec'
Update codec library...
make[1]: Leaving directory `/test/book/out/ch06-simple/lib/codec'
make --directory=lib/ui
make[1]: Entering directory `/test/book/out/ch06-simple/lib/ui'
Update ui library...
make[1]: Leaving directory `/test/book/out/ch06-simple/lib/ui'
make --directory=app/player
make[1]: Entering directory `/test/book/out/ch06-simple/app/player'
Update player application...
make[1]: Leaving directory `/test/book/out/ch06-simple/app/player'

   When make detects that it is invoking another make recursively, it enables the --print-directory (-w)
   option, which causes make to print the Entering directory and Leaving directory messages. This option
   is also enabled when the --directory (-C) option is used. The value of the make variable MAKELEVEL is
   printed in square brackets in each line as well. In this simple example, each component makefile
   prints a simple message about updating the component.

Command-Line Options
   Recursive make is a simple idea that quickly becomes complicated. The perfect recursive make
   implementation would behave as if the many makefiles in the system are a single makefile. Achieving
   this level of coordination is virtually impossible, so compromises must be made. The subtle issues
   become more clear when we look at how command-line options must be handled.

   Suppose we have added comments to a header file in our mp3 player. Rather than recompiling all the
   source that depends on the modified header, we realize we can instead perform a make --touch to bring
   the timestamps of the files up to date. By executing the make --touch with the top-level makefile, we
   would like make to touch all the appropriate files managed by sub-makes. Let's see how this works.

   Usually, when --touch is provided on the command line, the normal processing of rules is suspended.
   Instead, the dependency graph is traversed and the selected targets and those prerequisites that are
   not marked .PHONY are brought up to date by executing touch on the target. Since our subdirectories
   are marked .PHONY, they would normally be ignored (touching them like normal files would be
   pointless). But we don't want those targets ignored, we want their command script executed. To do the
   right thing, make automatically labels any line containing MAKE with the + modifier, meaning make
   runs the sub-make regardless of the --touch option.

   When make runs the sub-make it must also arrange for the --touch flag to be passed to the
   sub-process. It does this through the MAKEFLAGS variable. When make starts, it automatically appends
   most command-line options to MAKEFLAGS. The only exceptions are the options --directory (-C), --file
   (-f), --old-file (-o), and --new-file (-W). The MAKEFLAGS variable is then exported to the
   environment and read by the sub-make as it starts.

   With this special support, sub-makes behave mostly the way you want. The recursive execution of
   $(MAKE) and the special handling of MAKEFLAGS that is applied to --touch (-t) is also applied to the
   options --just-print (-n) and --question (-q).

Passing Variables
   As we have already mentioned, variables are passed to sub-makes through the environment and
   controlled using the export and unexport directives. Variables passed through the environment are
   taken as default values, but are overridden by any assignment to the variable. Use the
   --environment-overrides (-e) option to allow environment variables to override the local assignment.
   You can explicitly override the environment for a specific assignment (even when the
   --environment-overrides option is used) with the override directive:
override TMPDIR = ~/tmp

   Variables defined on the command line are automatically exported to the environment if they use legal
   shell syntax. A variable is considered legal if it uses only letters, numbers, and underscores.
   Variable assignments from the command line are stored in the MAKEFLAGS variable along with
   command-line options.

Error Handling
   What happens when a recursive make gets an error? Nothing very unusual, actually. The make receiving
   the error status terminates its processing with an exit status of 2. The parent make then exits,
   propagating the error status up the recursive make process tree. If the --keep-going (-k) option is
   used on the top-level make, it is passed to sub-makes as usual. The sub-make does what it normally
   does, skips the current target and proceeds to the next goal that does not use the erroneous target
   as a prerequisite.

   For example, if our mp3 player program encountered a compilation error in the lib/db component, the
   lib/db make would exit, returning a status of 2 to the top-level makefile. If we used the
   --keep-going (-k) option, the top-level makefile would proceed to the next unrelated target,
   lib/codec. When it had completed that target, regardless of its exit status, the make would exit with
   a status of 2 since there are no further targets that can be processed due to the failure of lib/db.

   The --question (-q) option behaves very similarly. This option causes make to return an exit status
   of 1 if some target is not up to date, 0 otherwise. When applied to a tree of makefiles, make begins
   recursively executing makefiles until it can determine if the project is up to date. As soon as an
   out-of-date file is found, make terminates the currently active make and unwinds the recursion.

Building Other Targets
   The basic build target is essential for any build system, but we also need the other support targets
   we've come to depend upon, such as clean, install, print, etc. Because these are .PHONY targets, the
   technique described earlier doesn't work very well.

   For instance, there are several broken approaches, such as:
clean: $(player) $(libraries)
	$(MAKE) --directory=$@ clean

   or:
$(player) $(libraries):
	$(MAKE) --directory=$@ clean

   The first is broken because the prerequisites would trigger a build of the default target in the
   $(player) and $(libraries) makefiles, not a build of the clean target. The second is illegal because
   these targets already exist with a different command script.

   One approach that works relies on a shell for loop:
clean:
	for d in $(player) $(libraries);   \
	do                                 \
		$(MAKE) --directory=$$d clean; \
	done

   A for loop is not very satisfying for all the reasons described earlier, but it (and the preceding
   illegal example) points us to this solution:
$(player) $(libraries):
	$(MAKE) --directory=$@ $(TARGET)

   By adding the variable $(TARGET) to the recursive make line and setting the TARGET variable on the
   make command line, we can add arbitrary goals to the sub-make:
$> make TARGET=clean

   Unfortunately, this does not invoke the $(TARGET) on the top-level makefile. Often this is not
   necessary because the top-level makefile has nothing to do, but, if necessary, we can add another
   invocation of make protected by an if:
$(player) $(libraries):
	$(MAKE) --directory=$@ $(TARGET)
	$(if $(TARGET), $(MAKE) $(TARGET))

   Now we can invoke the clean target (or any other target) by simply setting TARGET on the command
   line.

Cross-Makefile Dependencies
   The special support in make for command-line options and communication through environment variables
   suggests that recursive make has been tuned to work well. So what are the serious complications
   alluded to earlier?

   Separate makefiles linked by recursive $(MAKE) commands record only the most superficial top-level
   links. Unfortunately, there are often subtle dependencies buried in some directories.

   For example, suppose a db module includes a yacc-based parser for importing and exporting music data.
   If the ui module, ui.c, includes the generated yacc header, we have a dependency between these two
   modules. If the dependencies are properly modeled, make should know to recompile our ui module
   whenever the grammar header is updated. This is not difficult to arrange using the automatic
   dependency generation technique described earlier. But what if the yacc file itself is modified? In
   this case, when the ui makefile is run, a correct makefile would recognize that yacc must first be
   run to generate the parser and header before compiling ui.c. In our recursive make decomposition,
   this does not occur, because the rule and dependencies for running yacc are in the db makefile, not
   the ui makefile.

   In this case, the best we can do is to ensure that the db makefile is always executed before
   executing the ui makefile. This higher-level dependency must be encoded by hand. We were astute
   enough in the first version of our makefile to recognize this, but, in general, this is a very
   difficult maintenance problem. As code is written and modified, the top-level makefile will fail to
   properly record the intermodule dependencies.

   To continue the example, if the yacc grammar in db is updated and the ui makefile is run before the
   db makefile (by executing it directly instead of through the top-level makefile), the ui makefile
   does not know there is an unsatisfied dependency in the db makefile and that yacc must be run to
   update the header file. Instead, the ui makefile compiles its program with the old yacc header. If
   new symbols have been defined and are now being referenced, then a compilation error is reported.
   Thus, the recursive make approach is inherently more fragile than a single makefile.

   The problem worsens when code generators are used more extensively. Suppose that the use of an RPC
   stub generator is added to ui and the headers are referenced in db. Now we have mutual reference to
   contend with. To resolve this, it may be required to visit db to generate the yacc header, then visit
   ui to generate the RPC stubs, then visit db to compile the files, and finally visit ui to complete
   the compilation process. The number of passes required to create and compile the source for a project
   is dependent on the structure of the code and the tools used to create it. This kind of mutual
   reference is common in complex systems.

   The standard solution in real-world makefiles is usually a hack. To ensure that all files are up to
   date, every makefile is executed when a command is given to the top-level makefile. Notice that this
   is precisely what our mp3 player makefile does. When the top-level makefile is run, each of the four
   sub-makefiles is unconditionally run. In complex cases, makefiles are run repeatedly to ensure that
   all code is first generated then compiled. Often this iterative execution is a complete waste of
   time, but occasionally it is required.

Avoiding Duplicate Code
   are very similar. This makes sense because the three libraries serve different purposes in the final
   application but are all built with similar commands. This kind of decomposition is typical of large
   projects and leads to many similar makefiles and lots of (makefile) code duplication.

   Code duplication is bad, even makefile code duplication. It increases the maintenance costs of the
   software and leads to more bugs. It also makes it more difficult to understand algorithms and
   identify minor variations in them. So we would like to avoid code duplication in our makefiles as
   much as possible. This is most easily accomplished by moving the common pieces of a makefile into a
   common include file.

   For example, the codec makefile contains:
lib_codec       := libcodec.a
sources         := codec.c
objects         := $(subst .c,.o,$(sources))
dependencies    := $(subst .c,.d,$(sources))

include_dirs := .. ../../include
CPPFLAGS     += $(addprefix -I ,$(include_dirs))
vpath %.h $(include_dirs)

all: $(lib_codec)

$(lib_codec): $(objects)
	$(AR) $(ARFLAGS) $@ $^

.PHONY: clean
clean:
	$(RM) $(lib_codec) $(objects) $(dependencies)

ifneq "$(MAKECMDGOALS)" "clean"
	include $(dependencies)
endif

%.d: %.c
	$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $< |		\
	sed 's,\($*\.o\) *:,\1 $@: ,' > $@.tmp
	mv $@.tmp $@

   Almost all of this code is duplicated in the db and ui makefiles. The only lines that change for each
   library are the name of the library itself and the source files the library contains. When duplicate
   code is moved into common.mk, we can pare this makefile down to:
library := libcodec.a
sources := codec.c

include ../../common.mk

   See what we have moved into the single, shared include file:
MV             := mv -f
RM             := rm -f
SED            := sed

objects      := $(subst .c,.o,$(sources))
dependencies := $(subst .c,.d,$(sources))
include_dirs := .. ../../include
CPPFLAGS     += $(addprefix -I ,$(include_dirs))

vpath %.h $(include_dirs)

.PHONY: library
library: $(library)

$(library): $(objects)
	$(AR) $(ARFLAGS) $@ $^

.PHONY: clean
clean:
	$(RM) $(objects) $(program) $(library) $(dependencies) $(extra_clean)

ifneq "$(MAKECMDGOALS)" "clean"
	-include $(dependencies)
endif

%.c %.h: %.y
	$(YACC.y) --defines $<
	$(MV) y.tab.c $*.c
	$(MV) y.tab.h $*.h

%.d: %.c
	$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $< |		\
	$(SED) 's,\($*\.o\) *:,\1 $@: ,' > $@.tmp
	$(MV) $@.tmp $@

   The variable include_dirs, which was different for each makefile, is now identical in all makefiles
   because we reworked the path source files use for included headers to make all libraries use the same
   include path.

   The common.mk file even includes the default goal for the library include files. The original
   makefiles used the default target all. That would cause problems with nonlibrary makefiles that need
   to specify a different set of prerequisites for their default goal. So the shared code version uses a
   default target of library.

   Notice that because this common file contains targets it must be included after the default target
   for nonlibrary makefiles. Also notice that the clean command script references the variables program,
   library, and extra_clean. For library makefiles, the program variable is empty; for program
   makefiles, the library variable is empty. The extra_clean variable was added specifically for the db
   makefile. This makefile uses the variable to denote code generated by yacc. The makefile is:
library        := libdb.a
sources        := scanner.c playlist.c
extra_clean    := $(sources) playlist.h

.SECONDARY: playlist.c playlist.h scanner.c

include ../../common.mk

   Using these techniques, code duplication can be kept to a minimum. As more makefile code is moved
   into the common makefile, it evolves into a generic makefile for the entire project. make variables
   and user-defined functions are used as customization points, allowing the generic makefile to be
   modified for each directory.

Nonrecursive make
   Multidirectory projects can also be managed without recursive makes. The difference here is that the
   source manipulated by the makefile lives in more than one directory. To accommodate this, references
   to files in subdirectories must include the path to the file-either absolute or relative.

   Often, the makefile managing a large project has many targets, one for each module in the project.
   For our mp3 player example, we would need targets for each of the libraries and each of the
   applications. It can also be useful to add phony targets for collections of modules such as the
   collection of all libraries. The default goal would typically build all of these targets. Often the
   default goal builds documentation and runs a testing procedure as well.

   The most straightforward use of nonrecursive make includes targets, object file references, and
   dependencies in a single makefile. This is often unsatisfying to developers familiar with recursive
   make because information about the files in a directory is centralized in a single file while the
   source files themselves are distributed in the filesystem. To address this issue, the Miller paper on
   nonrecursive make suggests using one make include file for each directory containing file lists and
   module-specific rules. The top-level makefile includes these sub-makefiles.

   Example 6-1 shows a makefile for our mp3 player that includes a module-level makefile from each
   subdirectory. Example 6-2 shows one of the module-level include files.
   Example 6-1. A nonrecursive makefile
# Collect information from each module in these four variables.
# Initialize them here as simple variables.
programs     :=
sources      :=
libraries    :=
extra_clean  :=

objects      = $(subst .c,.o,$(sources))
dependencies = $(subst .c,.d,$(sources))

include_dirs := lib include
CPPFLAGS     += $(addprefix -I ,$(include_dirs))
vpath %.h $(include_dirs)

MV  := mv -f
RM  := rm -f
SED := sed

all:

include lib/codec/module.mk
include lib/db/module.mk
include lib/ui/module.mk
include app/player/module.mk

.PHONY: all
all: $(programs)

.PHONY: libraries
libraries: $(libraries)

.PHONY: clean
clean:
	$(RM) $(objects) $(programs) $(libraries) \
		  $(dependencies) $(extra_clean)

ifneq "$(MAKECMDGOALS)" "clean"
	include $(dependencies)
endif

%.c %.h: %.y
	$(YACC.y) --defines $<
	$(MV) y.tab.c $*.c
	$(MV) y.tab.h $*.h

%.d: %.c
	$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $< | \
	$(SED) 's,\($(notdir $*)\.o\) *:,$(dir $@)\1 $@: ,' > $@.tmp
	$(MV) $@.tmp $@

   Example 6-2. The lib/codec include file for a nonrecursive makefile
local_dir  := lib/codec
local_lib  := $(local_dir)/libcodec.a
local_src  := $(addprefix $(local_dir)/,codec.c)
local_objs := $(subst .c,.o,$(local_src))

libraries  += $(local_lib)
sources    += $(local_src)

$(local_lib): $(local_objs)
	$(AR) $(ARFLAGS) $@ $^

   Thus, all the information specific to a module is contained in an include file in the module
   directory itself. The top-level makefile contains only a list of modules and include directives.
   Let's examine the makefile and module.mk in detail.

   Each module.mk include file appends the local library name to the variable libraries and the local
   sources to sources. The local_ variables are used to hold constant values or to avoid duplicating a
   computed value. Note that each include file reuses these same local_ variable names. Therefore, it
   uses simple variables (those assigned with :=) rather than recursive ones so that builds combining
   multiple makefiles hold no risk of infecting the variables in each makefile. The library name and
   source file lists use a relative path as discussed earlier. Finally, the include file defines a rule
   for updating the local library. There is no problem with using the local_ variables in this rule
   because the target and prerequisite parts of a rule are immediately evaluated.

   In the top-level makefile, the first four lines define the variables that accumulate each module's
   specific file information. These variables must be simple variables because each module will append
   to them using the same local variable name:
local_src  := $(addprefix $(local_dir)/,codec.c)
...
sources    += $(local_src)

   If a recursive variable were used for sources, for instance, the final value would simply be the last
   value of local_src repeated over and over. An explicit assignment is required to initialize these
   simple variables, even though they are assigned null values, since variables are recursive by
   default.

   The next section computes the object file list, objects, and dependency file list from the sources
   variable. These variables are recursive because at this point in the makefile the sources variable is
   empty. It will not be populated until later when the include files are read. In this makefile, it is
   perfectly reasonable to move the definition of these variables after the includes and change their
   type to simple variables, but keeping the basic file lists (e.g., sources, libraries, objects)
   together simplifies understanding the makefile and is generally good practice. Also, in other
   makefile situations, mutual references between variables require the use of recursive variables.

   Next, we handle C language include files by setting CPPFLAGS. This allows the compiler to find the
   headers. We append to the CPPFLAGS variable because we don't know if the variable is really empty;
   command-line options, environment variables, or other make constructs may have set it. The vpath
   directive allows make to find the headers stored in other directories. The include_dirs variable is
   used to avoid duplicating the include directory list.

   Variables for mv, rm, and sed are defined to avoid hard coding programs into the makefile. Notice the
   case of variables. We are following the conventions suggested in the make manual. Variables that are
   internal to the makefile are lowercased; variables that might be set from the command line are
   uppercased.

   In the next section of the makefile, things get more interesting. We would like to begin the explicit
   rules with the default target, all. Unfortunately, the prerequisite for all is the variable programs.
   This variable is evaluated immediately, but is set by reading the module include files. So, we must
   read the include files before the all target is defined. Unfortunately again, the include modules
   contain targets, the first of which will be considered the default goal. To work through this
   dilemma, we can specify the all target with no prerequisites, source the include files, then add the
   prerequisites to all later.

   The remainder of the makefile is already familiar from previous examples, but how make applies
   implicit rules is worth noting. Our source files now reside in subdirectories. When make tries to
   apply the standard %.o: %.c rule, the prerequisite will be a file with a relative path, say
   lib/ui/ui.c. make will automatically propagate that relative path to the target file and attempt to
   update lib/ui/ui.o. Thus, make automagically does the Right Thing.

   There is one final glitch. Although make is handling paths correctly, not all the tools used by the
   makefile are. In particular, when using gcc, the generated dependency file does not include the
   relative path to the target object file. That is, the output of gcc -M is:
ui.o: lib/ui/ui.c include/ui/ui.h lib/db/playlist.h

   rather than what we expect:
lib/ui/ui.o: lib/ui/ui.c include/ui/ui.h lib/db/playlist.h

   This disrupts the handling of header file prerequisites. To fix this problem we can alter the sed
   command to add relative path information:
$(SED) 's,\($(notdir $*)\.o\) *:,$(dir $@)\1 $@: ,'

   Tweaking the makefile to handle the quirks of various tools is a normal part of using make. Portable
   makefiles are often very complex due to vagarities of the diverse set of tools they are forced to
   rely upon.

   We now have a decent nonrecursive makefile, but there are maintenance problems. The module.mk include
   files are largely similar. A change to one will likely involve a change to all of them. For small
   projects like our mp3 player it is annoying. For large projects with several hundred include files it
   can be fatal. By using consistent variable names and regularizing the contents of the include files,
   we position ourselves nicely to cure these ills. Here is the lib/codec include file after
   refactoring:
local_src := $(wildcard $(subdirectory)/*.c)

$(eval $(call make-library, $(subdirectory)/libcodec.a, $(local_src)))

   Instead of specifying source files by name, we assume we want to rebuild all .c files in the
   directory. The make-library function now performs the bulk of the tasks for an include file. This
   function is defined at the top of our project makefile as:
# $(call make-library, library-name, source-file-list)
define make-library
  libraries += $1
  sources	+= $2

  $1: $(call source-to-object,$2)
	$(AR) $(ARFLAGS) $$@ $$^
endef

   The function appends the library and sources to their respective variables, then defines the explicit
   rule to build the library. Notice how the automatic variables use two dollar signs to defer actual
   evaluation of the $@ and $^ until the rule is fired. The source-to-object function translates a list
   of source files to their corresponding object files:
source-to-object = $(subst .c,.o,$(filter %.c,$1)) \
                   $(subst .y,.o,$(filter %.y,$1)) \
                   $(subst .l,.o,$(filter %.l,$1))

   In our previous version of the makefile, we glossed over the fact that the actual parser and scanner
   source files are playlist.y and scanner.l. Instead, we listed the source files as the generated .c
   versions. This forced us to list them explicitly and to include an extra variable, extra_clean. We've
   fixed that issue here by allowing the sources variable to include .y and .l files directly and
   letting the source-to-object function do the work of translating them.

   In addition to modifying source-to-object, we need another function to compute the yacc and lex
   output files so the clean target can perform proper clean up. The generated-source function simply
   accepts a list of sources and produces a list of intermediate files as output:
# $(call generated-source, source-file-list)
generated-source = $(subst .y,.c,$(filter %.y,$1)) \
                   $(subst .y,.h,$(filter %.y,$1)) \
                   $(subst .l,.c,$(filter %.l,$1))

   Our other helper function, subdirectory, allows us to omit the variable local_dir.
subdirectory = $(patsubst %/makefile,%,                            \
                 $(word                                            \
                   $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST)))

   As noted in the section String Functions in Chapter 4, we can retrieve the name of the
   current makefile from MAKEFILE_LIST. Using a simple patsubst, we can extract the relative path from
   the top-level makefile. This eliminates another variable and reduces the differences between include
   files.

   Our final optimization (at least for this example), uses wildcard to acquire the source file list.
   This works well in most environments where the source tree is kept clean. However, I have worked on
   projects where this is not the case. Old code was kept in the source tree "just in case." This
   entailed real costs in terms of programmer time and anguish since old, dead code was maintained when
   it was found by global search and replace and new programmers (or old ones not familiar with a
   module) attempted to compile or debug code that was never used. If you are using a modern source code
   control system, such as CVS, keeping dead code in the source tree is unnecessary (since it resides in
   the repository) and using wildcard becomes feasible.

   The include directives can also be optimzed:
modules := lib/codec lib/db lib/ui app/player
 . . .
include $(addsuffix /module.mk,$(modules))

   For larger projects, even this can be a maintenance problem as the list of modules grows to the
   hundreds or thousands. Under these circumstances, it might be preferable to define modules as a find
   command:
modules := $(subst /module.mk,,$(shell find . -name module.mk))
 . . .
include $(addsuffix /module.mk,$(modules))

   We strip the filename from the find output so the modules variable is more generally useful as the
   list of modules. If that isn't necessary, then, of course, we would omit the subst and addsuffix and
   simply save the output of find in modules. Example 6-3 shows the final makefile.
   Example 6-3. A nonrecursive makefile, version 2
# $(call source-to-object, source-file-list)
source-to-object = $(subst .c,.o,$(filter %.c,$1)) \
                   $(subst .y,.o,$(filter %.y,$1)) \
                   $(subst .l,.o,$(filter %.l,$1))

# $(subdirectory)
subdirectory = $(patsubst %/module.mk,%,                        \
                 $(word                                         \
                   $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST)))

# $(call make-library, library-name, source-file-list)
define make-library
	libraries += $1
	sources	+= $2

	  $1: $(call source-to-object,$2)
		$(AR) $(ARFLAGS) $$@ $$^
endef

# $(call generated-source, source-file-list)
generated-source = $(subst .y,.c,$(filter %.y,$1))        \
                   $(subst .y,.h,$(filter %.y,$1))        \
                   $(subst .l,.c,$(filter %.l,$1))

# Collect information from each module in these four variables.
# Initialize them here as simple variables.
modules      := lib/codec lib/db lib/ui app/player
programs     :=
libraries    :=
sources      :=

objects      =    $(call source-to-object,$(sources))
dependencies =    $(subst .o,.d,$(objects))

include_dirs := lib include
CPPFLAGS     += $(addprefix -I ,$(include_dirs))
vpath %.h $(include_dirs)

MV  := mv -f
RM  := rm -f
SED := sed

all:

include $(addsuffix /module.mk,$(modules))

.PHONY: all
all: $(programs)

.PHONY: libraries
libraries: $(libraries)

.PHONY: clean
clean:
	$(RM) $(objects) $(programs) $(libraries) $(dependencies)        \
			$(call generated-source, $(sources))

ifneq "$(MAKECMDGOALS)" "clean"
  include $(dependencies)
endif

%.c %.h: %.y
	$(YACC.y) --defines $<
	$(MV) y.tab.c $*.c
	$(MV) y.tab.h $*.h

%.d: %.c
	$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $< | \
	$(SED) 's,\($(notdir $*)\.o\) *:,$(dir $@)\1 $@: ,' > $@.tmp
	$(MV) $@.tmp $@

   Using one include file per module is quite workable and has some advantages, but I'm not convinced it
   is worth doing. My own experience with a large Java project indicates that a single top-level
   makefile, effectively inserting all the module.mk files directly into the makefile, provides a
   reasonable solution. This project included 997 separate modules, about two dozen libraries, and half
   a dozen applications. There were several makefiles for disjoint sets of code. These makefiles were
   roughly 2,500 lines long. A common include file containing global variables, user-defined functions,
   and pattern rules was another 2,500 lines.

   Whether you choose a single makefile or break out module information into include files, the
   nonrecursive make solution is a viable approach to building large projects. It also solves many
   traditional problems found in the recursive make approach. The only drawback I'm aware of is the
   paradigm shift required for developers used to recursive make.

Components of Large Systems
   For the purposes of this discussion, there are two styles of development popular today: the free
   software model and the commercial development model.

   In the free software model, each developer is largely on his own. A project has a makefile and a
   README and developers are expected to figure it out with only a small amount of help. The principals
   of the project want things to work well and want to receive contributions from a large community, but
   they are mostly interested in contributions from the skilled and well-motivated. This is not a
   criticism. In this point of view, software should be written well, and not necessarily to a schedule.

   In the commercial development model, developers come in a wide variety of skill levels and all of
   them must be able to develop software to contribute to the bottom line. Any developer who can't
   figure out how to do their job is wasting money. If the system doesn't compile or run properly, the
   development team as a whole may be idle, the most expensive possible scenario. To handle these
   issues, the development process is managed by an engineering support team that coordinates the build
   process, configuration of software tools, coordination of new development and maintenance work, and
   the management of releases. In this environment, efficiency concerns dominate the process.

   It is the commercial development model that tends to create elaborate build systems. The primary
   reason for this is pressure to reduce the cost of software development by increasing programmer
   efficiency. This, in turn, should lead to increased profit. It is this model that requires the most
   support from make. Nevertheless, the techniques we discuss here apply to the free software model as
   well when their requirements demand it.

   This section contains a lot of high-level information with very few specifics and no examples. That's
   because so much depends on the language and operating environment used. In Chapter 8 and
   Chapter 9, I will provide specific examples of how to implement many of these features.

Requirements
   Of course requirements vary with every project and every work environment. Here we cover a wide range
   that are often considered important in many commercial development environments.

   The most common feature desired by development teams is the separation of source code from binary
   code. That is, the object files generated from a compile should be placed in a separate binary tree.
   This, in turn, allows many other features to be added. Separate binary trees offer many advantages:
	 * It is easier to manage disk resources when the location of large binary trees can be specified.
	 * Many versions of a binary tree can be managed in parallel. For instance, a single source tree may
	   have optimized, debug, and profiling binary versions available.
	 * Multiple platforms can be supported simultaneously. A properly implemented source tree can be
	   used to compile binaries for many platforms in parallel.
	 * Developers can check out partial source trees and have the build system automatically "fill in"
	   the missing files from a reference source and binary trees. This doesn't strictly require
	   separating source and binary, but without the separation it is more likely that developer build
	   systems would get confused about where binaries should be found.
	 * Source trees can be protected with read-only access. This provides added assurance that the
	   builds reflect the source code in the repository.
	 * Some targets, such as clean, can be implemented trivially (and will execute dramatically faster)
	   if a tree can be treated as a single unit rather than searching the tree for files to operate on.

   Most of the above points are themselves important build features and may be project requirements.

   Being able to maintain reference builds of a project is often an important system feature. The idea
   is that a clean check-out and build of the source is performed nightly, typically by a cron job.
   Since the resulting source and binary trees are unmodified with respect to the CVS source, I refer to
   these as reference source and binary trees. The resulting trees have many uses.

   First, a reference source tree can be used by programmers and managers who need to look at the
   source. This may seem trivial, but when the number of files and releases grows it can be unwieldy or
   unreasonable to expect someone to check-out the source just to examine a single file. Also, while CVS
   repository browsing tools are common, they do not typically provide for easy searching of the entire
   source tree. For this, tags tables or even find/grep (or grep -R) are more appropriate.

   Second, and most importantly, a reference binary tree indicates that the source builds cleanly. When
   developers begin each morning, they know if the system is broken or whole. If a batch-oriented
   testing framework is in place, the clean build can be used to run automated tests. Each day
   developers can examine the test report to determine the health of the system without wasting time
   running the tests themselves. The cost savings is compounded if a developer has only a modified
   version of the source because he avoids spending additional time performing a clean check-out and
   build. Finally, the reference build can be run by developers to test and compare the functionality of
   specific components.

   The reference build can be used in other ways as well. For projects that consist of many libraries,
   the precompiled libraries from the nightly build can be used by programmers to link their own
   application with those libraries they are not modifying. This allows them to shorten their develoment
   cycle by omiting large portions of the source tree from their local compiles. Of course, easy access
   to the project source on a local file server is convenient if developers need to examine the code and
   do not have a complete checked out source tree.

   With so many different uses, it becomes more important to verify the integrity of the reference
   source and binary trees. One simple and effective way to improve reliability is to make the source
   tree read-only. Thus, it is guaranteed that the reference source files accurately reflect the state
   of the repository at the time of check out. Doing this can require special care, because many
   different aspects of the build may attempt to causally write to the source tree. Especially when
   generating source code or writing temporary files. Making the source tree read-only also prevents
   casual users from accidentally corrupting the source tree, a most common occurrence.

   Another common requirement of the project build system is the ability to easily handle different
   compilation, linking, and deployment configurations. The build system typically must be able to
   manage different versions of the project (which may be branches of the source repository).

   Most large projects rely on significant third-party software, either in the form of linkable
   libraries or tools. If there are no other tools to manage configurations of the software (and often
   there are not), using the makefile and build system to manage this is often a reasonable choice.

   Finally, when software is released to a customer, it is often repackaged from its development form.
   This can be as complex as constructing a setup.exe file for Windows or as simple as formatting an
   HTML file and bundling it with a jar. Sometimes this installer build operation is combined with the
   normal build process. I prefer to keep the build and the install generation as two separate stages
   because they seem to use radically different processes. In any case, it is likely that both of these
   operations will have an impact on the build system.

Filesystem Layout
   Once you choose to support fmultiple binary trees, the question of filesystem layout arises. In
   environments that require multiple binary trees, there are often a lot of binary trees. To keep all
   these trees straight requires some thought.

   A common way to organize this data is to designate a large disk for a binary tree "farm." At (or
   near) the top level of this disk is one directory for each binary tree. One reasonable layout for
   these trees is to include in each directory name the vendor, hardware platform, operating system, and
   build parameters of the binary tree:
$ ls
hp-386-windows-optimized
hp-386-windows-debug
sgi-irix-optimzed
sgi-irix-debug
sun-solaris8-profiled
sun-solaris8-debug

   When builds from many different times must be kept, it is usually best to include a date stamp (and
   even a timestamp) in the directory name. The format yymmdd or yymmddhhmm sorts well:
$ ls
hp-386-windows-optimized-040123
hp-386-windows-debug-040123
sgi-irix-optimzed-040127
sgi-irix-debug-040127
sun-solaris8-profiled-040127
sun-solaris8-debug-040127

   Of course, the order of these filename components is up to your site. The top-level directory of
   these trees is a good place to hold the makefile and testing logs.

   This layout is appropriate for storing many parallel developer builds. If a development team makes
   "releases," possibly for internal customers, you can consider adding an additional release farm,
   structured as a set of products, each of which may have a version number and timestamp as shown in
   Figure 6-2.
   Example of a release tree layout
   Figure 6-2. Example of a release tree layout

   Here products might be libraries that are the output of a development team for use by other
   developers. Of course, they may also be products in the traditional sense.

   Whatever your file layout or environment, many of the same criteria govern the implementation. It
   must be easy to identify each tree. Cleanup should be fast and obvious. It is useful to make it easy
   to move trees around and archive trees. In addition, the filesystem layout should closely match the
   process structure of the organization. This makes it easy for nonprogrammers such as managers,
   quality assurance, and technical publications to navigate the tree farm.

Automating Builds and Testing
   It is typically important to be able to automate the build process as much as possible. This allows
   reference tree builds to be performed at night, saving developer time during the day. It also allows
   developers themselves to run builds on their own machines unattended.

   For software that is "in production," there are often many outstanding requests for builds of
   different versions of different products. For the person in charge of satisfying these requests, the
   ability to fire off several builds and "walk away" is often critical to maintaining sanity and
   satisfying requests.

   Automated testing presents its own issues. Many nongraphical applications can use simple scripting to
   manage the testing process. The GNU tool dejaGnu can also be used to test nongraphical utilities that
   require interaction. Of course, testing frameworks like JUnit (http://www.junit.org) also provide
   support for nongraphical unit testing.

   Testing of graphical applications presents special problems. For X11-based systems, I have
   successfully performed unattended, cron-based testing using the virtual frame buffer, Xvfb. On
   Windows, I have not found a satisfactory solution to unattended testing. All approaches rely on
   leaving the testing account logged in and the screen unlocked.
	 ________________________________________________________________________________________________




---
