filename: c_howto-make-global-constant-for-multiple-files_20211105.txt
https://stackoverflow.com/questions/8304619/how-to-make-global-constant-work-across-multiple-files-in-c-program

How to make global constant (work across multiple files) in C program?

I have an ANSI C program comprising two files. The first file contains the main() function, and the
second file contains other functions that the first file calls. Before the main() function definition,
I've placed the following code:

#define PI 3.14159265358979323846

but the 2nd file didn't see this variable. The first file sees it fine. Then, I placed this same line
in the second file (while keeping it in the first file as above), before the function definitions,
but still the second file doesn't see it. Things always compile fine, but when tracing the variable PI
in gdb, it shows "No symbol "PI" in current context."

How to make PI a global constant viewable across all files compiled in the application?

EDIT / UPDATE:
Based on the response so far, I've created the following file:

myheader.h

#ifndef my_header_stuff
#define my_header_stuff
#define PI 3.1415926535897932384626433832795
#endif

and in the two files I want to see this constant PI, I've included this file as follows:

file1.c

#include <stdio.h>
#include <stdlib.h>
#include "myheader.h"
int main(void) {
	etc...
}

and file2.c

#include <stdio.h>
#include <stdlib.h>
#include "myheader.h"
double interesting_function(void) {
	etc...
}

Questions:
    When I use GDB to debug, b PI returns (in both files, same result) "No symbol "PI" in current
    context". However, the math depending on PI is computed correctly. Is there a way to view PI in gdb?

    Can I also include the two lines for stdio and stdlib in the myheader.h file?

    Can I also include any function prototypes in the myheader.h file? If I do, and then let's say I
    create a file3.c that doesn't require any of these prototypes because it doesn't use those functions,
    is any harm done?

***
    Always put all definitions in .c files and declarations (including macros) in .h files. That should
    solve the problem 99% of the time. -

***
    It's normal that a macro definition doesn't show up in GDB. It's because GCC replaces each PI with
    the actual pi value.

    Yes. In your case, it doesn't hurt. If the .h file contains a prototype(they are typically called
    declarations) that uses a type that are defined in somewhere else, you can simply #include in your
    header files

    Yes. You can declare what ever function prototype you want and it won't do any harm in terms of the
    functionality of your program. Compiler won't even check the existence of the definitions of those
    functions unless you actually call them from somewhere else.

***
    Another question... I originally placed the #define directly in each file, which
    seemed to work fine in file1.c but not file2.c (no compile errors, but math produced wildly wrong
    result). Using #include is just like cut-and-paste contents into file, right? Why does the myheader.h
    approach produce different results--aren't both solutions just relying on #define NAME value? Or,
    if you can't explain it, maybe it was my debugging confusion. -

***
A macro isn't a variable, and it won't appear in gdb as a variable. Things are compiling fine because
they're working fine; you just have the wrong expectations for gdb.

In general, a macro that's needed in more than one place should be defined in a header file that's
included everywhere it's needed; for instance, the macro M_PI is already defined to be pi in the standard
include math.h.

The other thing that you can do is to have const int PI = 3.14159etcetc; in one file and extern const
int PI; in all of the others, but this is a pain because it requires the definition of the value to
exist in exactly one compilation unit.

***
I'd declare PI in the header file and include this header file to all source files

You should place function declarations, macros in your header file (and maybe some simple inline functions)
Implementation should be placed in .c files

***
You could create a global variable.

//file1.c
int my_global;


//file2.c
extern int my_global;
//code using my_global...

Note that usage of preprocessor is mostly discouraged.

Also note that M_PI define suggested by others is not available in the latest C standard (C99) so you
cannot rely on it.

***
If you are working only with standard math definitions, the standard header file math.h has some good ones:

 #include <math.h>
  ...
 double area = radius * radius * M_PI;

***
It would be very nice if you create a header file for the file that's included in the main source file,
and It is a good pratice too and you will improve your C Language skills. Imagine that we have a source
file with a functions, global variables and constants that we will need in the main source file, we
could create a header file for that file and put those functions there:

 #ifndef _FILE_H
 #define _FILE_H

 #include "file.h"
 #define PI 3.14
 /**
  *functions protypes here or other constants or globlal variables
  */
  void do_something(char **param1, int *param2);

 #endif

In your "file.c" file you should do the folowing:

#inlcude "file.h"

void do_something(char **param1, int *param2) {

	/**
	*do something
	*/
}

In your "main.c" file you should do :

 #include "file.h"

 /**
  *Now you can use "PI"
  */

***
the preprocessor direct will replace by actual code before compile, so in your case your first file's
PI will replace by 3.14... and there is not PI symbol in symbol table of first translate unit. so the
gdb will say no 'PI' symbol.

if you want use #define and don't want use header file, you need #deine PI at the beginning of each file.


---
https://pretagteam.com/question/how-do-i-share-a-global-variable-between-multiple-files

How do I share a global variable between multiple files?
2021-10-02

Use extern keyword in another .c file.,Use the extern keyword to declare the variable in the other .c
file. E.g.:,If you want to use global variable i of file1.c in file2.c, then below are the points to
remember:,In the second .c file use extern keyword with the same variable name.

file 1:

int x = 50;


file 2:

extern int x;

printf("%d", x);

Use the extern keyword to declare the variable in the other .c file. E.g.:

extern int counter;

Do same as you did in file1.c In file2.c:

#include <stdio.h>

extern int i; /*This declare that i is an int variable which is defined in some other file*/

int main(void) {
	/* your code*/

***
Global variables are used in programming to share memory between different sections of an application,
this allows for a range of functionality such as keeping track of resource use between classes, storing
statistics about an application and much more. In Python, they are mainly used to share values between
classes and functions., In Python, a conventional global variable is only used to share a value within
classes and functions. A variable- once declared as a global within a function or class can then be
modified within the segment.,As you can see, once we've initialized the global variable in globals.py,
we can then access 'num' as a property from any other module within the application and it will retain
its value.,For example, let's create a function similar to the example above that will increment a
global variable. For this we'll need 3 classes to prove the concept; a main class, a class containing
our increment function and a class containing the globals.


num = 1

def increment():
   global num
num += 1


import test

num = 1

test.increment()


def increment():
	global num
num += 1 # num here would still be undefined


def initialize():
	global num
num = 1


import globals
import test

if __name__ == "__main__":
	globals.initialize()
print(globals.num) # print the initial value
test.increment()
print(globals.num) # print the value after being modified within test.py


import globals

def increment():
	globals.num += 1


1
2

***
Best way to declare and define global variables, can I do the opposite?like define a variable globally
in .cc file and then use it in header file? - Nidhi Jha Mar 20 '20 at 1:37 ,Although there are other
ways of doing it, the clean, reliable way to declare and define global variables is to use a header file
file3.h to contain an extern declaration of the variable. The header is included by the one source file
that defines the variable and by all the source files that reference the variable. For each program,
one source file (and only one source file) defines the variable. Similarly, one header file (and only
one header file) should declare the variable.,This is related to sharing variables across source files,
but how does that work precisely? Where do I use extern?

file3.h

extern int global_variable; /* Declaration of the variable */

file1.c

#include "file3.h"	/* Declaration made available here */

/* Variable defined here */

int increment(void) {
	return global_variable++;
}

file2.c

#include "file3.h"
#include <stdio.h>

void use_it(void) {
	printf("Global variable: %d\n", global_variable++);
}

prog1.h

extern void use_it(void);
extern int increment(void);

prog1.c

#include "file3.h"
#include "prog1.h"
#include <stdio.h>

int main(void) {
	use_it();
	global_variable += 19;
	use_it();
	printf("Increment: %d\n", increment());
	return 0;
}

the answer is wrong, please change it. see below for the correct file1.c from the really long answer:

#include "file3.h"  /* Declaration made available here */

#include "prog1.h"  /* Function declarations */

/* Variable defined here */
int global_variable = 37; /* Definition checked against declaration */

int increment(void) {
	return global_variable++;
}

Register variables causing compiler error in strcpy and strncpy , What is the idea of using MCC for
Harmony projects instead of MHC ,Location: Second star on the right, straight on till morning, XC8,
interrupt and temporary variables

struct BOARD {
	char type;
	char size;
	char number;
};
extern struct BOARD myBoard;

#include "main.h"struct BOARD myBoard;...// Use myBoard for whatever......
#include "main.h"...// Use myBoard for whatever......

Lines starting with a hash # are called pre-processor directives and the system uses them to create an
edited version of the C  file to be given to the compiler. , Then if the preprocessor later encounters:
,NB: for clarity we have used an option to the C preprocessor that preserves comments, when compiling
they are replaced by spaces. ,Finally, we create the variable inside one source file:

int somenumber = 7;

// myfun() can now use the variable somenumber:
void myfun(int i) {
	somenumber = i * i;
}

// so can main(), if it is inside the same file:
int main() {
	int k;

	myfun(3);
	k = 6 + somenumber;

	return 0;
}

Step through this code

   x = fun1(arg1, arg2);

The answer is to put our function prototypes inside a header file and #include it in all our source files.

#include "mydefs.h"

Source file: alloc.c

#include <stdlib.h>
#include "alloc.h"
void *xmalloc(size_t n) {
	void *p = malloc(n);
	if (p == NULL) {
		fprintf(stderr, "Out of memory!\n");
		exit(1);
	}
	return p;
}

void *xrealloc(void *old, size_t n) {
	void *p = realloc(old, n);
	if (p == NULL && n != 0) {
		fprintf(stderr, "Out of memory!\n");
		exit(1);
	}
	return p;
}

Header file: alloc.h

void * xmalloc(size_t n);
void * xrealloc(void * old, size_t n);

We saw above that variables defined outside of a function are called external variables and can be used by
any function in the file, provided only that the function definition follows the variable definition. Just
like functions, external variables can be prefixed with the word static to restrict them just to functions
in the same source file:

double globalval; // Available to any function in any file
static int somenumber; // Available only to functions in this file

void myfun1(int i) {
	/* myfun1 can now use the variables globalval and somenumber */
}

void myfun2(int i) {
	/* so can myfun2 */
}

However, we can't just put the statement:

double globalval;

To solve this problem we "properly" declare a global variable in just one file and then tell the other
files it exists, using a new keyword "extern":

extern double globalval;

Here is a typical include file which we have called food.h . It defines a Food structure suitable for
a linked list, declares some function protoypes and then declares an extern (global) variable for the
first member of the liked list:

// Contents of food.h
#define MAXLEN 256
typedef struct food {
	char name[MAXLEN];
	float calories;
	struct food * next;
}
Food;

void new_food(void);
void calculate_calories(void);

extern Food * firstfood;

Now every .c file will know of that this variable exists, although we have not yet created it. For example,
the following code uses the variable firstfood on the assumption it has been declared somewhere else:

#include "food.h"
#include <stdlib.h>
#include <stdio.h>

void new_food(void) {
	Food *new = NULL;

	new = xmalloc(sizeof *new);
	new->next = firstfood;
	firstfood = new;

	printf("Name of food?\n");
	scanf("%255s", new->name);
	printf("Calories per gramme?\n");
	scanf("%f", &new->calories);
}


void calculate_calories(void) {
	Food *tmp;
	float calories = 0, grammes;

	for(tmp = firstfood; tmp != NULL; tmp = tmp->next) {
		printf("How many grammes of %s?\n", tmp->name);
		scanf("%f", &grammes);
		calories += grammes * tmp->calories;
	}
	printf("Your food contains %.2f calories\n", calories);
}

Finally, we create the variable inside one source file:

#include <stdio.h>
#include "food.h"
#include <stdio.h>

Food * firstfood;

int main(void) {
	int choice;

	do {
		printf("\nChoice?\n\n"
		"0. Quit\n"
		"1. Add new food\n"
		"2. Calculate calories\n");
		scanf("%d", &choice);

		switch(choice) {
		case 0:
		break;

		case 1:
		new_food();
		break;

		case 2:
		calculate_calories();
		break;

		default:
		fprintf(stderr, "Input out of range\n");
		}

	} while(choice);

	return 0;
}

Here is a typical include file which we have called food.h . It defines a Food structure suitable for
a linked list, declares some function protoypes and then declares an extern (global) variable for the
first member of the liked list:

// Contents of food.h
#define MAXLEN 256
typedef struct food {
	char name[MAXLEN];
	float calories;
	struct food * next;
}
Food;

void new_food(void);
void calculate_calories(void);

extern Food * firstfood;

A global variable is accessible to all functions in every source file where it is declared.  To avoid
problems:,Initialization - if a global variable is declared in more than one source file in a library,
it should be initialized in only one place or you will get a compiler error. ,Functions in Same File
Sharing Variables,Functions in Multiple Files Sharing Variables

	Open ... Documents\SimpleIDE\Learn\Simple Libraries\My Libraries\libawesome\libawesome.side.
	Click Project and Select Add Tab to Project.
	Set the File name to timer.c, paste in the code below, and save.

/*
  timer.c

  Track time since the last awesome call.
*/

#include "simpletools.h"

#include "awesome.h"

static int cog = 0;
static int stack[60];
static volatile int seconds = 0;

void secondCtr(void * par);
int awesome_startTimer(void) {
	if (cog == 0)
		cog = 1 + cogstart( & secondCtr, NULL, stack, sizeof stack);
}

void awesome_stopTimer(void) {
	if (cog > 0) {
		cogstop(cog - 1);
		cog = 0;
	}
}

int awesome_secondsSince(void) {
	return seconds;
}

int awesome_secondsReset(void) {
	seconds = 0;
}

void secondCtr(void * par) {
	int dt = CLKFREQ;
	int t = CNT;
	while (1) {
		waitcnt(t += dt);
		seconds++;
	}
}

	Click the libawesome.c tab and update your test harness as shown here.
	Run and verify that the application correctly displays the time since the last call (2 seconds in
	this case).

/*
libawesome.c

Test harness for libawesome library.
*/

#include "simpletools.h"            // Include simple tools

#include "awesome.h"                // Include awesome header

int main()                          // Main function {
	int cog = awesome_startTimer(); // Test the start
	print("cog = %d\n", cog);       // Print cog value

	for (int n = 1; n <= 10; n++)   // Call awesome certain number of times {
		print("Nick");              // Print a name
		awesome();                  // Append with " is awesome!\n"
	}

	int callCount = awesome_getCount();   // Test awesome_getcount
	print("callCount = %d\n", callCount);

	pause(2000);
	int seconds = awesome_secondsSince(); // Test seconds since
	print("seconds = %d\n", seconds);

	awesome_secondsReset();               // Test seconds reset
	seconds = awesome_secondsSince();
	print("seconds = %d\n", seconds);

	print("Jessica");                     // Print another name
	epic();                               // Append with " is epic!\n

	pause(2000);
	awesome_stopTimer();                  // Test stop timer
	seconds = awesome_secondsSince();

	print("seconds = %d\n", seconds);     // Make sure timer stopped counting
	pause(1000);
	seconds = awesome_secondsSince();
	print("seconds = %d\n", seconds);
}

	Modify timer.c as shown here.  We we removed the static keyword from the the seconds variable
	declaration, and renamed it to awesome_cog_seconds in both the declaration and in the secondCtr
	function. We also removed awesome_secondsSince and awesome_secondsReset - those are going into
	their own source files.

/*
  timer.c

  Track time since the last awesome call.
*/

#include "simpletools.h"
#include "awesome.h"

static int cog = 0;
static int stack[60];
volatile int awesome_cog_seconds = 0;
void secondCtr(void * par);

int awesome_startTimer(void) {
	if (cog == 0)
		cog = 1 + cogstart( & secondCtr, NULL, stack, sizeof stack);
}

void awesome_stopTimer(void) {
	if (cog > 0) {
		cogstop(cog - 1);
		cog = 0;
	}
}

void secondCtr(void * par) {
	int dt = CLKFREQ;
	int t = CNT;
	while (1) {
		waitcnt(t += dt);
		awesome_cog_seconds++;
	}
}

	If needed, review the Add Tab to Project Steps from Reducing Program Size with a Simple Library.
	Repeat the Add Tab to Project steps with seconds_since.c.

/*
  seconds_since.c

  Track time since the last awesome call.
*/

#include "simpletools.h"
#include "awesome.h"

volatile int awesome_cog_seconds;

int awesome_secondsSince(void) {
	return awesome_cog_seconds;
}

	Repeat the Add Tab to Project steps with seconds_reset.c.

/*
  seconds_reset.c

  Track time since the last awesome call.
*/

#include "simpletools.h"
#include "awesome.h"

volatile int awesome_cog_seconds;

int awesome_secondsReset(void) {
	awesome_cog_seconds = 0;
}



---
https://www.microchip.com/forums/m801638.aspx

Global variables across multiple files

   This is a generic C programming question. I have some projects with multiple C source files. I want
   to define some global variables to be accessed within each source file, but to do this they have to
   have their definitions. What I had done previously was to use a header file to be included with each.
   In it would be statements similar to the following:

struct BOARD {
	char type;
	char size;
	char number;
};

#ifdef  MAIN
struct BOARD myBoard;
#else
extern struct BOARD myBoard;
#endif

   Then in the main C file I would insert #define MAIN to allow the variable to be declared - all the
   others would refer to it with an extern keyword.

   The question is would there be another way to do this? It seems to work, I was just wondering how
   everyone else does it.

   Thanks.

***
   I guess I've always declared the var in my .h file using extern, and instantiated the var at the top
   of whichever .c file went with that header. Then I just include the header wherever I need it. I've
   also used globals.c and globals.h files before for this purpose.  It seems cleaner to me than using
   #ifdef like you're doing, but I guess either one would work.

***
   It can be simpler:
   You don't need #ifdef MAIN anywhere.

   Declare the struct extern in a header that is included in all files that need myBoard:

   Could be in a file named main.h or any other file that you will include anywhere you need myBoard:

struct BOARD {
	char type;
	char size;
	char number;
};

extern struct BOARD myBoard;


   Then in main.c
#include "main.h"
struct BOARD myBoard;
.
.
// Use myBoard for whatever...
.
.

   All other files that need to access myBoard:
#include "main.h"
.
.
// Use myBoard for whatever...
.
.

   Some people would use a typedef, and the procedure would be the same:
   1.
   Give a definition of the struct and declare a variable of that type to be extern in a header file
   2.
   Define the particular variable of that type in exactly one of the C files.  If necessary, you can
   declare a "local" variable of that type (with a different name) in any file or function within any
   file that needs such a thing.
   3. Include the header file everywhere you need to use that variable.

***
   I just read that you can use "extern" declarations in addition to the original defines - that was one
   that I missed. I like the file names globals.c and globals.h - very useful.

   I always get stuck with projects that E X P A N D. Now I'm adding a UART interface, which should mean
   a new file to segment it. Things start out small, then before you know it you're bigger than Windows
   7.

***
   "globals.c and globals.h"
   I very personal opinoin is, that is a bad start.
   all are in scope everywhere.
   it makes it easier to just use globals instead of passing parameters.
   As Projects get bigger and change hands more get added until it is a fragile mess.
   The globals for the UART should be in Uart.h, and only those that needed should include it.

***
   I use global.h for all global definitions, eg structs, vars and always used h files like <string.h>.
   It is like precompiled header in VisualStudio -StdAfx.h
   Globaly visible defs related to some peripheral must be in peripheral.h. Eg, UARTSend() must be only
   defined in uart.h. Private "global" vars, eg some UART buffer, must be static and only in uart.c.
   I usually declare global vars in main.c. Those are project global vars, eg settings struct init to
   default values. Globals related to some functionality are put in their c file. Eg I always put config
   bits in config.c, this way I know where is some functionality.
   Also, I create project folders for different funcs. Eg, USB stack files go into .USB (in source and
   header). Notice . in front -> places folder first and dot is not so visible :)



---
https://www.dummies.com/programming/c/how-to-share-variables-between-modules-when-programming-in-c/

How to Share Variables between Modules When Programming in C

The best way to share a variable between several functions in a huge C programming project is to make that
variable global. The global variable needs to be declared in only one module, usually the main module. For the
other modules to access that variable, they must employ the extern keyword.

The extern keyword doesn't declare a global variable. It merely tells the compiler that somewhere, in some
other module, a global variable is to be found. That way, the compiler doesn't freak out. Here's the extern
keyword's format:

extern type name

type is a variable type, the same type as the global variable being referenced. name is the global variable's
name. Getting both the type and name correct is what keeps the compiler happy.

Like a global variable, the extern statement is generally found at the top of the source code, not within any
specific function.

Code for main.c and a Global Variable shows the main module, with the second() function prototyped at Line 4.
The prototype is required because the second() function is called at Line 11. You don't need to prototype all
functions in another module, only those referenced or called.

CODE FOR MAIN.C AND A GLOBAL VARIABLE

#include 
#include 

void second(void);
int count;

int main() {
	for(count=0;count<5;count++)
		second();
	return 0;
}

Global variable count is declared at Line 6. It's used in the for loop at Line 10, but it's also used in the
second.c source code file.

CODE FOR SECOND.C USING THE GLOBAL VARIABLE

#include 
extern int count;

void second(void) {
	printf("%dn",count+1);
}

The second.c source code file uses the global variable count, which is declared in the main.c file.
To properly access that global variable, Line 3 identifies the variable as an external int. The count
variable is then used in the second() function - specifically, at Line 7.

Exercise 1: Create a new project in Code::Blocks that incorporates both source code files shown.
Build and run.



---
https://users.cs.duke.edu/~raw/cps149s/L7.html

L7 Multi-File C Programs

The procedures and global variables of a C program can be split across multiple files.	Each of the files
can be compiled separately, into a *.o file.  Later, all the *.o files can be linked together (still using
gcc) into a running program, an executable object program.	Each file can have access to a set of names
that are private to that file, and to other names that are shared across all the files of the complete
program.  This allows the program to be built and modified in pieces, often called "modules", which can be
tested separately, and later combined into the final product.

The programmer determines which names are local to each file, and which are shared, and indicates his/her
decisions by constructing declarations appropriately.  The storage class specifiers extern and static play
a role in this, as does the position of each declaration, and whether a declaration is in fact a
"definition".

A declaration announces to the compiler that a certain name is "known", and usable in some area of the
code.  The declaration also gives the name's "type".  A "definition" is a declaration accompanied by an
initialization (for variables), or a function body (for functions).

A declaration can appear inside a function or other set of "{}".  Such a declaration declares a name usable
only within the innermost enclosing "{}".  Such a declaration is termed :local".  If a local declaration
begins with the keyword "static", space is reserved for the name in "global memory", and preserved across
calls to the function - the next time this function is called, the name's previous value will still be
preserved.	Note that this name is still usable only within this function - if another function declares
the same name the two function each get their own version of the variable.	If "static" is omitted from a
local declaration, space for the name is reserved on the function's Activation Record (on the stack).  Each
time the function is called, a new area of memory (completely uninitialized) is reserved for this variable.

Declarations appearing outside functions are termed "external".  The names they declare are known within
the current file, in any program text which FOLLOWS the declaration.  In addition, the name will be shared
across files UNLESS the declaration includes the word "static".  A static, external declaration defines
names which are local to one file.

The word "extern" can appear in an external declaration, but seems to be ignored.  (In the original C, an
"extern" external declaration allocated no storage, but linked the declared name to the storage allocated
for the same name in another file.)

A general rule states that all declarations for a given name must have matching types.	However, it is
legal for some of these declarations to be "incomplete" - the most specific declaration is used.  Further,
at most one DEFINITION for a given name can occur.	These rules apply to each "name scope", that
is: within
a file, for names local to the file, within a function for names local to the function, and within the
whole program for global names.

A special rule applies to global variables which have NO definitions.  In this case, a single copy of the
variable is made, and it is initialized to 0.  Note that the "single definition" rule applies to both
functions and variables, so a function can have many prototypes (headers), if they all agree, but the
function body can only appear once.

Chapter 4 of Kernighan and Ritchie discusses these issues.	However, their discussion seems to be
based on the ORIGINAL C.  Modern C has somewhat more relaxed rules.	In particular, K+R state that if one
file wants to reference a variable declared in another, the first file MUST place the word "extern" on the
external declaration for the shared variable.  That does NOT seem to be what the "reference manual"
(Appendix A of K+R) says.	I've tried the following example in gcc, and it seems to work:

Example

File set.h:
int x;

void set(int i);


File  set.c:

#include "set.h"

void set(int i) {
	x=i;
 }


File main.c:

#include <stdio.h>

#include "set.h"


int main() {

	set(1);
	printf("x=%d\n", x);
	set(5);
	printf("x=%d\n", x);

}

The command:

$> gcc set.c main.c

compiles the *.c files, and links them together into file a.out, which then can be run.  (This program is
intended as illustration only.	Avoid use of global variables unless using them simplifies the program
significantly.	See the example in Chap 4 of a global "stack" for evaluating arithmetic expressions in
Polish Postfix notation.)

Using the rules
Large C programs are usually built by grouping the important functions into files, with "related" functions
placed into the same file.	The functions of one file might serve to define a "package" of some kind - say,
one for manipulating a specific kind of list.  In addition, a header file is built for each program file.
Traditionally, the header file for program file P.c is called P.h.	The header includes definitions of
structures, macros and enums that are important for the file, along with prototypes for each global
function in the file, and declarations for each global variable in the file.  The header file is
#include'ed in the program file, and in each file that needs to use functions from that program file.

The header file technique allows the program file's functions to call any function in that file, even
functions that are defined late in the file (without the header, that wouldn't work).  It allows any file
that includes the header to access the global variables declared in the header, and to call functions
defined in the program file.  The program file can contain additional declarations for some of the global
variables which initialize those variables.  (These declarations become definitions.)

It is common for header files to include other header files.  If this is done extensively, it could lead to
a situation in which the same header declarations are included multiple times.	This is probably OK for
function prototypes, and for variable declarations, but it produces illegal C programs if enums, structs,
or unions are repeated, since the member names and enum constants defined by these declarations become
multiply defined.  The C preprocessor is usually used to avoid this problem.



---
https://riptutorial.com/c/example/3251/using-a-global-variable

Using a Global Variable

Example
Use of global variables is generally discouraged. It makes your program more difficult to understand, and
harder to debug. But sometimes using a global variable is acceptable.

global.h

#ifndef GLOBAL_DOT_H    /* This is an "include guard" */
#define GLOBAL_DOT_H

/**
 * This tells the compiler that g_myglobal exists somewhere.
 * Without "extern", this would create a new variable named
 * g_myglobal in _every file_ that included it. Don't miss this!
 */
extern int g_myglobal; /* _Declare_ g_myglobal, that is promise it will be _defined_ by
                        * some module. */

#endif /* GLOBAL_DOT_H */

global.c

#include "global.h" /* Always include the header file that declares something
                     * in the C file that defines it. This makes sure that the
                     * declaration and definition are always in-sync.
                     */
                       
int g_myglobal;     /* _Define_ my_global. As living in global scope it gets initialised to 0 
                     * on program start-up. */

main.c

#include "global.h"

int main(void) {
	g_myglobal = 42;
	return 0;
}




---
https://learn.parallax.com/propeller-c-library-studies/functions-multiple-files-sharing-variables

Functions in Multiple Files Sharing Variables

   Remember from Multicore Example that a function launched into another cog using the CMM or LMM
   memory model needs to exchange information with volatile global variables.  Sometimes a library
   launches functions into other cogs, and the same rules will apply.  Let's recap some global variable
   vocabulary, and look at some rules for using them in library source files.

Global Variables in Library Source Files
   A global variable is accessible to all functions in every source file where it is declared.	To avoid
   problems:

   Initialization - if a global variable is declared in more than one source file in a library, it
   should be initialized in only one place or you will get a compiler error.

   Static - use the static keyword to make a global variable visible only to functions within the same
   source file whenever possible. This removes any potential for conflict with variables of the same
   name in any other library source files or user application code. You can use static and volatile
   together.

   Volatile - Use the volatile keyword for global variables that need to be used by functions running in
   different cogs. This keeps the C compiler's size optimizer from removing code that affects other
   functions' ability to read or write to that variable from another cog.  You can use static and
   volatile together.

   Naming - if a programmer happens to give a global variable in their application code the same name as
   a non-static global variable in a library, the names will conflict and give unexpected results.	To
   help avoid this, name your variables in a  libName_varName format. If you run into a mystery bug when
   writing an application, it is worth checking the documentation for the libraries you are using to see
   if you have a variable name conflict.


More Functions for the Awesome Library
   This activity starts by adding a new set of functions to the awesome library, in a source file named
   timer.c.   Since all the variables are in the same file, they are declared static to prevent other
   files using the same variable names from corrupting this file's data.	 Later, we'll move some of
   the functions to separate source files, with care to set up the global variables for multi-cog use.
	 * Open ... Documents\SimpleIDE\Learn\Simple Libraries\My Libraries\libawesome\libawesome.side.
	 * Click Project and Select Add Tab to Project.
	 * Set the File name to timer.c, paste in the code below, and save.

/*
  timer.c

  Track time since the last awesome call.
*/

#include "simpletools.h"
#include "awesome.h"

static int cog = 0;
static int stack[60];
static volatile int seconds = 0;

void secondCtr(void *par);

int awesome_startTimer(void) {
	if(cog == 0)
		cog = 1 + cogstart(&secondCtr, NULL, stack, sizeof stack);
}

void awesome_stopTimer(void) {
	if(cog > 0) {
		cogstop(cog - 1);
		cog = 0;
	}
}

int awesome_secondsSince(void) {
	return seconds;
}

int awesome_secondsReset(void) {
	seconds = 0;
}

void secondCtr(void *par) {
	int dt = CLKFREQ;
	int t = CNT;

	while(1) {
		waitcnt(t += dt);
		seconds++;
	}
}

   You have added more functions to the library, so:
	 * Click the Show Project Manager button in the bottom-left corner of SimpleIDE.
	 * Click awesome.h and update as shown here.

   After adding this to the library, make sure to test it.	The easiest way to do this is to modify the
   test harness so that it uses the new functions, and verify that each one runs as expected.

   In the example below, we want to verify that start awesome_startTimer returns nonzero, and
   awesome_secondsSince() reports the correct seconds count after the start function was called.

   The modified test harness also checks to make sure that awesome_secondsReset can reset the seconds
   counter to zero, and awesome_stopTimer stops the counting process.  There are two calls to
   awesome_secondsSince that follow the stop call to make sure it really has stopped counting.
	 * Click the libawesome.c tab and update your test harness as shown here.
	 * Run and verify that the application correctly displays the time since the last call (2 seconds in
	   this case).

/*
libawesome.c

Test harness for libawesome library.
*/

#include "simpletools.h"                      // Include simple tools
#include "awesome.h"                          // Include awesome header

int main() {                                  // Main function
	int cog = awesome_startTimer();           // Test the start
	print("cog = %d\n", cog);                 // Print cog value

	for(int n = 1; n <= 10; n++) {            // Call awesome certain number of times
		print("Nick");                        // Print a name
		awesome();                            // Append with "
		is awesome!\n"
	}

	int callCount = awesome_getCount();       // Test awesome_getcount
	print("callCount = %d\n", callCount);

	pause(2000);
	int seconds = awesome_secondsSince();     // Test seconds since
	print("seconds = %d\n", seconds);

	awesome_secondsReset();                   // Test seconds reset
	seconds = awesome_secondsSince();
	print("seconds = %d\n", seconds);

	print("Jessica");                         // Print another name
	epic();                                   // Append with " is epic!\n

	pause(2000);
	awesome_stopTimer();                      // Test stop timer
	seconds = awesome_secondsSince();

	print("seconds = %d\n", seconds);         // Make sure timer stopped counting
	pause(1000);
	seconds = awesome_secondsSince();
	print("seconds = %d\n", seconds);
}

Did You Know?
   Library-Only Functions - Forward declarations for all the functions were added to awesome.h with one
   exception: secondCtr.  This function is not one that we want the user's application to call, so we
   didn't advertise it in the header file.	 Instead, the timer.c file just has a forward declaration
   letting the compiler know that it will find the code for it eventually.

Try This - Move Functions to Other Files and Give them Global Variable Access
   Now, imagine that there are 26 more functions in the timer.c source file (yikes!).  In that case, it
   would be better to move functions to separate files whenever possible so your application code does
   not get stuffed with code for unneeded functions if you only call one or two.  Not all functions
   would have to be separated.	For example, if two or more functions always work together, or if the
   functions are small and interrelated, it's okay to leave them in the same file.

   With these guidelines in mind, we'll keep awesome_startTimer and awesome_stopTimer functions in the
   same file with secondCtr.  An advantage here is that the cog and stack variables can remain static
   and keep their generic names.

   In contrast, awesome_secondsSince and awesome_secondsReset should be moved to separate files.  Since
   they share the seconds variable, it should be made global to the application (no static modifier).
   Its name should also be changed from seconds to something like awesome_cog_seconds.	That way if a
   user makes a global variable named seconds in their application code, it won't interfere with this
   library's seconds value.

   The result is the three files shown below.  All three files have to share the awesome_cog_seconds
   variable, so all three declare it without the static modifier.  Remember, only one source file should
   optionally initialize the variable, and that is already done in timer.c.
	 * Modify timer.c as shown here.  We we removed the static keyword from the the seconds variable
	   declaration, and renamed it to awesome_cog_seconds in both the declaration and in the secondCtr
	   function. We also removed awesome_secondsSince and awesome_secondsReset - those are going into
	   their own source files.

/*
  timer.c

  Track time since the last awesome call.
*/

#include "simpletools.h"
#include "awesome.h"

static int cog = 0;

static int stack[60];

volatile int awesome_cog_seconds = 0;

void secondCtr(void *par);

int awesome_startTimer(void) {
	if(cog == 0)
		cog = 1 + cogstart(&secondCtr, NULL, stack, sizeof stack);
}

void awesome_stopTimer(void) {
	if(cog > 0) {
		cogstop(cog - 1);
		cog = 0;
	}
}

void secondCtr(void *par) {
	int dt = CLKFREQ;
	int t = CNT;
	while(1) {
		waitcnt(t += dt);
		awesome_cog_seconds++;
	}
}

   Next, we need to make a source file for the awesome_secondsSince function removed from timer.c	Note
   that the awesome_cog_seconds variable that is still in timer.c is also needed here.	 So, it needs to
   be declared (but not initialized!) as a global volatile variable in this source file as well. Don't
   forget to update the variable name in the function!
	 * If needed, review the Add Tab to Project Steps from Reducing Program Size with a Simple
	   Library.
	 * Repeat the Add Tab to Project steps with seconds_since.c.

/*
  seconds_since.c

  Track time since the last awesome call.
*/

#include "simpletools.h"
#include "awesome.h"

volatile int awesome_cog_seconds;

int awesome_secondsSince(void) {
	return awesome_cog_seconds;
}

   A source file for awesome_secondsReset also needs to be added to the library project.  It too
   accesses the awesome_timer_seconds variable. So, so again we will need to declare the variable, and
   update the variable name used in the function call.
	 * Repeat the Add Tab to Project steps with seconds_reset.c.

/*
  seconds_reset.c

  Track time since the last awesome call.
*/

#include "simpletools.h"
#include "awesome.h"

volatile int awesome_cog_seconds;

int awesome_secondsReset(void) {
	awesome_cog_seconds = 0;
}


Your Turn
   At this point, the test harness code in libawesome.c should run the same as it did the last time.
   The only difference is that the library is arranged so that calling seconds_since will not bring in
   the code for seconds_reset if the application never calls it.
	 * Re-run the libawesome test harness code, and verify that it behaves the same as before.
	 * If needed, review the steps for building a library in How to Create a Simple Library.
	 * Build the modified library for the CMM and LMM memory models.




---


