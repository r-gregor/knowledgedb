ilename: c-bitwise-operators-use-multif-20250812.txt
https://www.geeksforgeeks.org/c/bitwise-operators-in-c-cpp/

Bitwise Operators in C
23 Jul, 2025

   In C, bitwise operators are used to perform operations directly on the binary representations of
   numbers. These operators work by manipulating individual bits (0s and 1s) in a number.

   The following 6 operators are bitwise operators (also known as bit operators as they work at the
   bit-level). They are used to perform bitwise operations in C.
    1. The & (bitwise AND) in C takes two numbers as operands and does AND on every bit of two numbers.
       The result of AND is 1 only if both bits are 1.
    2. The | (bitwise OR) in C takes two numbers as operands and does OR on every bit of two numbers.
       The result of OR is 1 if any of the two bits is 1.
    3. The ^ (bitwise XOR) in C takes two numbers as operands and does XOR on every bit of two numbers.
       The result of XOR is 1 if the two bits are different.
    4. The << (left shift) in C takes two numbers, the left shifts the bits of the first operand, and
       the second operand decides the number of places to shift.
    5. The >> (right shift) in C takes two numbers, right shifts the bits of the first operand, and the
       second operand decides the number of places to shift.
    6. The ~ (bitwise NOT) in C takes one number and inverts all bits of it.

   Bitwise operators allow precise manipulation of bits, giving you control over hardware operations.

   Let's look at the truth table of the bitwise operators.

       ----------------------------------------
       'X'   'Y'    'X & Y'   'X | Y'   'X ^ Y'
       ----------------------------------------
       0      0      0         0         0
       0      1      0         1         1
       1      0      0         1         1
       1      1      1         1         0
       ----------------------------------------

Example of Bitwise Operators in C
   The following program uses bitwise operators to perform bit operations in C.

#include <stdio.h>

int main() {

	// a = 5 (00000101 in 8-bit binary)
	// b = 9 (00001001 in 8-bit binary)
	unsigned int a = 5, b = 9;

	// The result is 00000001
	printf("a&b = %u\n", a & b);

	// The result is 00001101
	printf("a|b = %u\n", a | b);

	// The result is 00001100
	printf("a^b = %u\n", a ^ b);

	// The result is 11111111111111111111111111111010
	// (assuming 32-bit unsigned int)
	printf("~a = %u\n", a = ~a);

	// The result is 00010010
	printf("b<<1 = %u\n", b << 1);

	// The result is 00000100
	printf("b>>1 = %u\n", b >> 1);
	return 0;
}

   Output
a&b = 1
a|b = 13
a^b = 12
~a = 4294967290
b<<1 = 18
b>>1 = 4

Interesting Facts About Bitwise Operators
   1. The left-shift and right-shift operators should not be used for negative numbers.

   If the second operand (which decides the number of shifts) is a negative number, it results in
   undefined behavior in C. For example, results of both 1 <<- 1 and 1 >> -1 are undefined. Also, if the
   number is shifted more than the size of the integer, the behavior is undefined. For example, 1 << 33
   is undefined if integers are stored using 32 bits. Another thing is NO shift operation is performed
   if the additive expression (operand that decides no of shifts) is 0.

   2. The bitwise OR of two numbers is simply the sum of those two numbers if there is no carry
   involved; otherwise, you add their bitwise AND.

   Let's say, we have a=5(101) and b=2(010), since there is no carry involved, their sum is just a|b.
   Now, if we change 'b' to 6 which is 110 in binary, their sum would change to a|b + a&b since there is
   a carry involved.

   3. The bitwise XOR operator is the most useful operator from a technical interview perspective.

   It is used in many problems. A simple example could be "Given a set of numbers where all elements
   occur an even number of times except one number, find the odd occurring number" This problem can be
   efficiently solved by doing XOR to all numbers.

   Example
   Below program demonstrates the use XOR operator to find odd occcuring elements in an array.

#include <stdio.h>

int main(void) {

	int arr[] = { 12, 12, 14, 90, 14, 14, 14 };
	int n = sizeof(arr) / sizeof(arr[0]);
	int res = 0, i;
	for (int i = 0; i < n; i++)
		res ^= arr[i];
	printf("%d", res);
	return 0;
}

   Output
90

   The following are many other interesting problems using the XOR operator.
    1. [**1]Find the Missing Number
    2. [**2]Swap two numbers without using a temporary variable
    3. A Memory-Efficient Doubly Linked List
    4. Find the two non-repeating elements
    5. Find the two numbers with odd occurrences in an unsorted array
    6. Add two numbers without using arithmetic operators.
    7. [**3]Swap bits in a given number
    8. [**4]Count the number of bits to be flipped to convert a to b
    9. Find the element that appears once
   10. [**5]Detect if two integers have opposite signs

   4. The Bitwise operators should not be used in place of logical operators.
   The result of logical operators (&&, || and !) is either 0 or 1, but bitwise operators return an
   integer value. Also, the logical operators consider any non-zero operand as 1. For example, consider
   the following program, the results of & and && are different for the same operands.

   Example:

#include <stdio.h>

int main() {
	int x = 2, y = 5;
	(x & y) ? printf("True ") : printf("False ");
	(x && y) ? printf("True ") : printf("False ");
	return 0;
}

   Output
False True

   5. The left-shift and right-shift operators are equivalent to multiplication and division by 2
   respectively.

   As mentioned in point 1, it works only if numbers are positive.

   Example:

#include <stdio.h>

int main() {
	int x = 19;
	printf("x << 1 = %d\n", x << 1);
	printf("x >> 1 = %d", x >> 1);
	return 0;
}

   Output
x << 1 = 38
x >> 1 = 9

   6. The & operator can be used to quickly check if a number is odd or even.

   The value of the expression (x & 1) would be non-zero only if x is odd, otherwise, the value would be
   zero.

   Example:

   The below example demonstrates the use bitwise & operator to find if the given number is even or odd.

#include <stdio.h>

int main() {
	int x = 19;
	(x & 1) ? printf("Odd") : printf("Even");
	return 0;
}

   Output
Odd

     Time Complexity: O(1)
     Auxiliary Space: O(1)

   7. The ~ operator should be used carefully.
   The result of the ~ operator on a small number can be a big number if the result is stored in an
   unsigned variable. The result may be a negative number if the result is stored in a signed variable
   (assuming that the negative numbers are stored in 2's complement form where the leftmost bit is the
   sign bit).

   Example:

#include <stdio.h>

int main() {
	unsigned int x = 1;
	printf("Signed Result %d \n", ~x);
	printf("Unsigned Result %u", ~x);
	return 0;
}

   Output
Signed Result -2
Unsigned Result 4294967294

     Note The output of the above program is compiler dependent

---
[**1]
https://www.geeksforgeeks.org/dsa/find-the-missing-number/

Find the Missing Number
19 Apr, 2025

   Given an array arr[] of size n-1 with distinct integers in the range of [1, n]. This array represents
   a permutation of the integers from 1 to n with one element missing. Find the missing element in the
   array.

   Examples:

     Input: arr[] = [8, 2, 4, 5, 3, 7, 1]
     Output: 6
     Explanation: All the numbers from 1 to 8 are present except 6.

     Input: arr[] = [1, 2, 3, 5]
     Output: 4
     Explanation: Here the size of the array is 4, so the range will be [1, 5]. The missing number
     between 1 to 5 is 4

   Table of Content
     * [Naive Approach] Linear Search for Missing Number - O(n^2) Time and O(1) Space
     * [Better Approach] Using Hashing - O(n) Time and O(n) Space
     * [Expected Approach 1] Using Sum of n terms Formula - O(n) Time and O(1) Space
     * [Expected Approach 2] Using XOR Operation - O(n) Time and O(1) Space

[Naive Approach] Linear Search for Missing Number - O(n^2) Time and O(1) Space
     This approach iterates through each number from 1 to n (where n is the size of the array + 1) and
     checks if the number is present in the array. For each number, it uses a nested loop to search the
     array. If a number is not found, it is returned as the missing number.

   C++
#include <iostream>
#include <vector>
using namespace std;

int missingNum(vector<int>& arr) {
	int n = arr.size() + 1;

	// Iterate from 1 to n and check
	// if the current number is present
	for (int i = 1; i <= n; i++) {
		bool found = false;
		for (int j = 0; j < n - 1; j++) {
			if (arr[j] == i) {
				found = true;
				break;
			}
		}

		// If the current number is not present
		if (!found)
			return i;
	}
	return -1;
}

int main() {
	vector<int> arr = {8, 2, 4, 5, 3, 7, 1};
	cout << missingNum(arr) << endl;
	return 0;
}

   Java
public class GfG {
	public static int missingNum(int[] arr) {
		int n = arr.length + 1;

		// Iterate from 1 to n and check
		// if the current number is present
		for (int i = 1; i <= n; i++) {
			boolean found = false;
			for (int j = 0; j < n - 1; j++) {
				if (arr[j] == i) {
					found = true;
					break;
				}
			}

			// If the current number is not present
			if (!found)
				return i;
		}
		return -1;
	}

	public static void main(String[] args) {
		int[] arr = {8, 2, 4, 5, 3, 7, 1};
		System.out.println(missingNum(arr));
	}
}

   Python
def missingNum(arr):
	n = len(arr) + 1

	# Iterate from 1 to n and check
	# if the current number is present
	for i in range(1, n + 1):
		found = False
		for j in range(n - 1):
			if arr[j] == i:
				found = True
				break

		# If the current number is not present
		if not found:
			return i
	return -1

if __name__ == '__main__':
	arr = [8, 2, 4, 5, 3, 7, 1]
	print(missingNum(arr))

   C#
using System;

class GfG {
	static int missingNum(int[] arr) {
		int n = arr.Length + 1;

		// Iterate from 1 to n and check
		// if the current number is present
		for (int i = 1; i <= n; i++) {
			bool found = false;
			for (int j = 0; j < n - 1; j++) {
				if (arr[j] == i) {
					found = true;
					break;
				}
			}

			// If the current number is not present
			if (!found)
				return i;
		}
		return -1;
	}

	static void Main() {
		int[] arr = { 8, 2, 4, 5, 3, 7, 1 };
		Console.WriteLine(missingNum(arr));
	}
}

   JavaScript
function missingNum(arr) {
	const n = arr.length + 1;

	// Iterate from 1 to n and check
	// if the current number is present
	for (let i = 1; i <= n; i++) {
		let found = false;
		for (let j = 0; j < n - 1; j++) {
			if (arr[j] === i) {
				found = true;
				break;
			}
		}

		// If the current number is not present
		if (!found)
			return i;
	}
	return -1;
}

// drvier code
const arr = [8, 2, 4, 5, 3, 7, 1];
console.log(missingNum(arr));

   Output
6

[Better Approach] Using Hashing - O(n) Time and O(n) Space
     This approach uses a hash array (or frequency array) to track the presence of each number from 1
     to n in the input array. It first initializes a hash array to store the frequency of each element.
     Then, it iterates through the hash array to find the number that is missing (i.e., the one with a
     frequency of 0).

   C++
#include <iostream>
#include <vector>
using namespace std;

int missingNum(vector<int> &arr) {

	int n = arr.size() + 1;

	// Create hash array of size n+1
	vector<int> hash(n + 1, 0);

	// Store frequencies of elements
	for (int i = 0; i < n - 1; i++) {
		hash[arr[i]]++;
	}

	// Find the missing number
	for (int i = 1; i <= n; i++) {
		if (hash[i] == 0) {
			return i;
		}
	}
	return -1;
}

int main() {
	vector<int> arr = {8, 2, 4, 5, 3, 7, 1};
	int res = missingNum(arr);
	cout << res << endl;
	return 0;
}

   Java
import java.util.Arrays;

public class GfG {
	public static int missingNum(int[] arr) {
		int n = arr.length + 1;

		// Create hash array of size n+1
		int[] hash = new int[n + 1];

		// Store frequencies of elements
		for (int i = 0; i < n - 1; i++) {
			hash[arr[i]]++;
		}

		// Find the missing number
		for (int i = 1; i <= n; i++) {
			if (hash[i] == 0) {
				return i;
			}
		}
		return -1;
	}

	public static void main(String[] args) {
		int[] arr = {8, 2, 4, 5, 3, 7, 1};
		int res = missingNum(arr);
		System.out.println(res);
	}
}

   Python
def missingNum(arr):
	n = len(arr) + 1

	# Create hash array of size n+1
	hash = [0] * (n + 1)

	# Store frequencies of elements
	for i in range(n - 1):
		hash[arr[i]] += 1

	# Find the missing number
	for i in range(1, n + 1):
		if hash[i] == 0:
			return i
	return -1

if __name__ == '__main__':
	arr = [8, 2, 4, 5, 3, 7, 1]
	res = missingNum(arr)
	print(res)

   C#
using System;

class GfG {
	public static int missingNum(int[] arr) {
		int n = arr.Length + 1;

		// Create hash array of size n+1
		int[] hash = new int[n + 1];

		// Store frequencies of elements
		for (int i = 0; i < n - 1; i++) {
			hash[arr[i]]++;
		}

		// Find the missing number
		for (int i = 1; i <= n; i++) {
			if (hash[i] == 0) {
				return i;
			}
		}
		return -1;
	}

	static void Main() {
		int[] arr = {8, 2, 4, 5, 3, 7, 1};
		int res = missingNum(arr);
		Console.WriteLine(res);
	}
}

   JavaScript
function missingNum(arr) {
	let n = arr.length + 1;

	// Create hash array of size n+1
	let hash = new Array(n + 1).fill(0);

	// Store frequencies of elements
	for (let i = 0; i < n - 1; i++) {
		hash[arr[i]]++;
	}

	// Find the missing number
	for (let i = 1; i <= n; i++) {
		if (hash[i] === 0) {
			return i;
		}
	}
	return -1;
}

// driver code
const arr = [8, 2, 4, 5, 3, 7, 1];
const res = missingNum(arr);
console.log(res);

   Output
6

[Expected Approach 1] Using Sum of n terms Formula - O(n) Time and O(1) Space
     The sum of the first n natural numbers is given by the formula (n * (n + 1)) / 2. The idea is to
     compute this sum and subtract the sum of all elements in the array from it to get the missing
     number.

   C++
#include <iostream>
#include <vector>
using namespace std;

int missingNum(vector<int> &arr) {
	int n = arr.size() + 1;

	// Calculate the sum of array elements
	int sum = 0;
	for (int i = 0; i < n - 1; i++) {
		sum += arr[i];
	}

	// Calculate the expected sum
	long long expSum = (n *1LL* (n + 1)) / 2;

	// Return the missing number
	return expSum - sum;
}

int main() {
	vector<int> arr = {8, 2, 4, 5, 3, 7, 1};
	cout << missingNum(arr);
	return 0;
}

   Java
import java.util.*;

public class GfG {
   public static int missingNum(int[] arr) {
		long n = arr.length + 1;

		// Calculate the sum of array elements
		long sum = 0;
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
		}

		// Use long for expected sum to avoid overflow
		long expSum = n * (n + 1) / 2;

		// Return the missing number
		return (int)(expSum - sum);
	}

	public static void main(String[] args) {
		int[] arr = {8, 2, 4, 5, 3, 7, 1};
		System.out.println(missingNum(arr));
	}
}

   Python
def missingNum(arr):
	n = len(arr) + 1

	# Calculate the sum of array elements
	totalSum = sum(arr)

	# Calculate the expected sum
	expSum = n * (n + 1) // 2

	# Return the missing number
	return expSum - totalSum

if __name__ == '__main__':
	arr = [8, 2, 4, 5, 3, 7, 1]
	print(missingNum(arr))

   C#
using System;
using System.Linq;

class GfG {
	static int missingNum(int[] arr) {
	  int n = arr.Length + 1;

	// Calculate the sum of array elements
	int sum = arr.Sum();

	// Calculate the expected sum using long to avoid overflow
	long expSum = (long)n * (n + 1) / 2;

	// Return the missing number
	return (int)(expSum - sum);

	}

	static void Main() {
		int[] arr = {8, 2, 4, 5, 3, 7, 1};
		Console.WriteLine(missingNum(arr));
	}
}

   JavaScript
function missingNum(arr) {
	let n = arr.length + 1;

	// Calculate the sum of array elements
	let sum = 0;
	for (let i = 0; i < n - 1; i++) {
		sum += arr[i];
	}

	// Calculate the expected sum
	let expSum = (n * (n + 1)) / 2;

	// Return the missing number
	return expSum - sum;
}

// driver code
let arr = [8, 2, 4, 5, 3, 7, 1];
console.log(missingNum(arr));

   Output
6

[Expected Approach 2] Using XOR Operation - O(n) Time and O(1) Space
     XOR of a number with itself is 0 i.e. x ^ x = 0 and the given array arr[] has numbers in range [1,
     n]. This means that the result of XOR of first n natural numbers with the XOR of all the array
     elements will be the missing number. To do so, calculate XOR of first n natural numbers and XOR of
     all the array arr[] elements, and then our result will be the XOR of both the resultant values.

   C++
#include <iostream>
#include <vector>
using namespace std;

int missingNum(vector<int>& arr) {
	int n = arr.size() + 1;
	int xor1 = 0, xor2 = 0;

	// XOR all array elements
	for (int i = 0; i < n - 1; i++) {
		xor2 ^= arr[i];
	}

	// XOR all numbers from 1 to n
	for (int i = 1; i <= n; i++) {
		xor1 ^= i;
	}

	// Missing number is the XOR of xor1 and xor2
	return xor1 ^ xor2;
}

int main() {
	vector<int> arr = {8, 2, 4, 5, 3, 7, 1};
	int res = missingNum(arr);
	cout << res << endl;
	return 0;
}

   Java
import java.util.Arrays;

public class GfG {
	public static int missingNum(int[] arr) {
		int n = arr.length + 1;
		int xor1 = 0, xor2 = 0;

		// XOR all array elements
		for (int i = 0; i < n - 1; i++) {
			xor2 ^= arr[i];
		}

		// XOR all numbers from 1 to n
		for (int i = 1; i <= n; i++) {
			xor1 ^= i;
		}

		// Missing number is the XOR of xor1 and xor2
		return xor1 ^ xor2;
	}

	public static void main(String[] args) {
		int[] arr = {8, 2, 4, 5, 3, 7, 1};
		int res = missingNum(arr);
		System.out.println(res);
	}
}

   Python
def missingNum(arr):
	n = len(arr) + 1
	xor1 = 0
	xor2 = 0

	# XOR all array elements
	for i in range(n - 1):
		xor2 ^= arr[i]

	# XOR all numbers from 1 to n
	for i in range(1, n + 1):
		xor1 ^= i

	# Missing number is the XOR of xor1 and xor2
	return xor1 ^ xor2

if __name__ == '__main__':
	arr = [8, 2, 4, 5, 3, 7, 1]
	res = missingNum(arr)
	print(res)

   C#
using System;

class GfG {
	static int missingNum(int[] arr) {
		int n = arr.Length + 1;
		int xor1 = 0, xor2 = 0;

		// XOR all array elements
		for (int i = 0; i < n - 1; i++) {
			xor2 ^= arr[i];
		}

		// XOR all numbers from 1 to n
		for (int i = 1; i <= n; i++) {
			xor1 ^= i;
		}

		// Missing number is the XOR of xor1 and xor2
		return xor1 ^ xor2;
	}

	static void Main() {
		int[] arr = { 8, 2, 4, 5, 3, 7, 1 };
		int res = missingNum(arr);
		Console.WriteLine(res);
	}
}

   JavaScript
function missingNum(arr) {
	const n = arr.length + 1;
	let xor1 = 0, xor2 = 0;

	// XOR all array elements
	for (let i = 0; i < n - 1; i++) {
		xor2 ^= arr[i];
	}

	// XOR all numbers from 1 to n
	for (let i = 1; i <= n; i++) {
		xor1 ^= i;
	}

	// Missing number is the XOR of xor1 and xor2
	return xor1 ^ xor2;
}

// driver code
const arr = [8, 2, 4, 5, 3, 7, 1];
const res = missingNum(arr);
console.log(res);

   Output
6

---
[**2]
https://www.geeksforgeeks.org/dsa/swap-two-numbers-without-using-temporary-variable/

Swap Two Numbers Without Using Third Variable
23 Jul, 2025

   Given two variables a and y, swap two variables without using a third variable.

   Examples:

     Input: a = 2, b = 3
     Output: a = 3, b = 2

     Input: a = 20, b = 0
     Output: a = 0, b = 20

     Input: a = 10, b = 10
     Output: a = 10, b = 10

   Table of Content
     * Using Arithmetic Operators
     * Using Bitwise XOR
     * Built-in Swap

Using Arithmetic Operators
     * Store the sum of a and b in a (a = a + b).
     * Get the original value of a, that is (sum - original value of b)and store it in b (b = a - b).
     * Get the original value of b, that is (sum - original value of a)and store it in a (a = a - b).

   C++
// C++ Code to swap two numbers using arithmetic operators

#include <iostream>
using namespace std;

int main() {
	int a = 2, b = 3;
	cout << "a = " << a << " b = " << b << endl;

	a = a + b;
	b = a - b;
	a = a - b;

	cout << "a = " << a << " b = " << b << endl;
	return 0;
}

   C
// C Code to swap two numbers using arithmetic operators

#include <stdio.h>
int main() {
	int a = 2, b = 3;
	printf("a = %d b = %d\n", a, b);

	a = a + b;
	b = a - b;
	a = a - b;

	printf("a = %d b = %d\n", a, b);
	return 0;
}

   Java
// Java Code to swap two numbers using arithmetic operators

class GfG {
	public static void main(String[] args) {
		int a = 2, b = 3;
		System.out.println("a = " + a + " b = " + b);

		a = a + b;
		b = a - b;
		a = a - b;

		System.out.println("a = " + a + " b = " + b);
	}
}

   Python
# Python Code to swap two numbers using arithmetic operators

if __name__ == "__main__":
		a = 2
		b = 3
		print("a =", a, " b =", b)

		a = a + b
		b = a - b
		a = a - b

		print("a =", a, " b =", b)

   C#
// C# Code to swap two numbers using arithmetic operators

using System;

class GfG {
	static void Main() {
		int a = 2, b = 3;
		Console.WriteLine("a = " + a + " b = " + b);

		// Swap a and b using arithmetic operators
		a = a + b;
		b = a - b;
		a = a - b;

		Console.WriteLine("a = " + a + " b = " + b);
	}
}

   JavaScript
// JavaScript Code to swap two numbers using arithmetic operators

let a = 2, b = 3;
console.log("a = " + a + " b = " + b);

a = a + b;
b = a - b;
a = a - b;

console.log("a = " + a + " b = " + b);

   Output
a = 2 b = 3
a = 3 b = 2

   Time Complexity: O(1)
   Auxiliary Space: O(1)

Using Bitwise XOR
   The idea is to use the properties of XOR to swap the two variables.
     * a = a ^ b: Store the Bitwise XOR of a and b in a. Now, a holds the result of (a ^ b).
     * b = a ^ b: Bitwise XOR the new value of a with b to get the original value of a. This gives us, b
       = (a ^ b) ^ b = a.
     * a = a ^ b: Bitwise XOR the new value of a with the new value of b (which is the original a) to
       get the original value of b. This gives us, a = (a ^ b) ^ a = b.

   Finally, a and b hold the swapped values.
   C++
// C++ Code to swap two numbers using bitwise XOR

#include <iostream>
using namespace std;

int main() {
	int a = 2, b = 3;
	cout << "a = " << a << " b = " << b << endl;

	a = a ^ b;
	b = a ^ b;
	a = a ^ b;

	cout << "a = " << a << " b = " << b << endl;
	return 0;
}

   C
// C Code to swap two numbers using bitwise XOR

#include <stdio.h>
int main() {
	int a = 2, b = 3;
	printf("a = %d b = %d\n", a, b);

	a = a ^ b;
	b = a ^ b;
	a = a ^ b;

	printf("a = %d b = %d\n", a, b);
	return 0;
}

   Java
// Java Code to swap two numbers using bitwise XOR

class GfG {
	public static void main(String[] args) {
		int a = 2, b = 3;
		System.out.println("a = " + a + " b = " + b);

		a = a ^ b;
		b = a ^ b;
		a = a ^ b;

		System.out.println("a = " + a + " b = " + b);
	}
}

   Python
# Python Code to swap two numbers using bitwise XOR

if __name__ == "__main__":
		a = 2
		b = 3
		print("a =", a, " b =", b)

		a = a ^ b
		b = a ^ b
		a = a ^ b

		print("a =", a, " b =", b)

   C#
// C# Code to swap two numbers using bitwise XOR

using System;

class GfG {
	static void Main() {
		int a = 2, b = 3;
		Console.WriteLine("a = " + a + " b = " + b);

		// Swap a and b using arithmetic operators
		a = a ^ b;
		b = a ^ b;
		a = a ^ b;

		Console.WriteLine("a = " + a + " b = " + b);
	}
}

   JavaScript
// JavaScript Code to swap two numbers using bitwise XOR

let a = 2, b = 3;
console.log("a = " + a + " b = " + b);

a = a ^ b;
b = a ^ b;
a = a ^ b;

console.log("a = " + a + " b = " + b);

   Output
a = 2 b = 3
a = 3 b = 2

   Time Complexity: O(1)
   Auxiliary Space: O(1)

Built-in Swap
   We can also swap using built-in functionalities like swap method in C++, tuple unpacking in Python,
   destructuring assignment in JavaScript. To know more about the implementation, please refer [53]Swap
   Two Numbers.


---
[**3]
https://www.geeksforgeeks.org/dsa/swap-bits-in-a-given-number/

Swap bits in a given number
23 Jul, 2025

   Given a number x and two positions (0 based from the right side) in the binary representation of x,
   write a function that swaps n bits at the given two positions and returns the result. It is also
   given that the two sets of bits do not overlap.

   Examples:

     Input:
     x = 47 (00101111)
     p1 = 1 (Start from the second bit from the right side)
     p2 = 5 (Start from the 6th bit from the right side)
     n = 3 (No of bits to be swapped)
     Output:
     227 (11100011)
     Explanation:
     The 3 bits starting from the second bit (from the right side) are
     swapped with 3 bits starting from 6th position (from the right side)

     Input:
     x = 28 (11100)
     p1 = 0 (Start from first bit from right side)
     p2 = 3 (Start from 4th bit from right side)
     n = 2 (No of bits to be swapped)
     Output:
     7 (00111)
     Explanation:
     The 2 bits starting from 0th position (from right side) are
     swapped with 2 bits starting from 4th position (from right side)

Using XOR - O(1) time and O(1) space
   We need to swap two sets of bits. XOR can be used in a similar way as it is used to [50]swap 2
   numbers using XOR.

     The idea is to swap n bits at positions p1 and p2 in a number x by isolating these bit sets,
     XORing them to find the differences, and then selectively flipping only the bits that need to
     change, using the property that XOR marks differing bits and applying a second XOR operation
     restores the correct values in their swapped positions.

   Step by step approach:
    1. Extract the first set of n bits from position p1 by right-shifting and masking with an n-bit mask
    2. Extract the second set of n bits from position p2 using the same technique
    3. XOR these two sets to identify which corresponding bits differ between them
    4. Position these XOR differences back at their original locations (p1 and p2)
    5. XOR the original number with these positioned differences to selectively flip only the bits that
       need to change

   C++
// C++ Program to swap bits
// in a given number
#include <bits/stdc++.h>
using namespace std;

// Function to swap bits in a given number
int swapBits(int x, int p1, int p2, int n) {

	// Move all bits of first set to rightmost side
	int set1 = (x >> p1) & ((1 << n) - 1);

	// Move all bits of second set to rightmost side
	int set2 = (x >> p2) & ((1 << n) - 1);

	// Xor the two sets
	int xorVal = (set1 ^ set2);

	// Put the Xor bits back to their original positions
	xorVal = (xorVal << p1) | (xorVal << p2);

	// Xor the 'Xor' with the original number so that the
	// two sets are swapped
	int result = x ^ xorVal;

	return result;
}

int main() {
	int res = swapBits(28, 0, 3, 2);
	cout << res;
	return 0;
}

   Java
// Java Program to swap bits
// in a given number

class GfG {

	// Function to swap bits in a given number
	static int swapBits(int x, int p1, int p2, int n) {

		// Move all bits of first set to rightmost side
		int set1 = (x >> p1) & ((1 << n) - 1);

		// Move all bits of second set to rightmost side
		int set2 = (x >> p2) & ((1 << n) - 1);

		// Xor the two sets
		int xorVal = (set1 ^ set2);

		// Put the Xor bits back to their original positions
		xorVal = (xorVal << p1) | (xorVal << p2);

		// Xor the 'Xor' with the original number so that the
		// two sets are swapped
		int result = x ^ xorVal;

		return result;
	}

	public static void main(String[] args) {
		int res = swapBits(28, 0, 3, 2);
		System.out.println(res);
	}
}

   Python
# Python Program to swap bits
# in a given number

# Function to swap bits in a given number
def swapBits(x, p1, p2, n):

	# Move all bits of first set to rightmost side
	set1 = (x >> p1) & ((1 << n) - 1)

	# Move all bits of second set to rightmost side
	set2 = (x >> p2) & ((1 << n) - 1)

	# Xor the two sets
	xorVal = (set1 ^ set2)

	# Put the Xor bits back to their original positions
	xorVal = (xorVal << p1) | (xorVal << p2)

	# Xor the 'Xor' with the original number so that the
	# two sets are swapped
	result = x ^ xorVal

	return result

if __name__ == "__main__":
	res = swapBits(28, 0, 3, 2)
	print(res)

   C#
// C# Program to swap bits
// in a given number
using System;

class GfG {

	// Function to swap bits in a given number
	static int swapBits(int x, int p1, int p2, int n) {

		// Move all bits of first set to rightmost side
		int set1 = (x >> p1) & ((1 << n) - 1);

		// Move all bits of second set to rightmost side
		int set2 = (x >> p2) & ((1 << n) - 1);

		// Xor the two sets
		int xorVal = (set1 ^ set2);

		// Put the Xor bits back to their original positions
		xorVal = (xorVal << p1) | (xorVal << p2);

		// Xor the 'Xor' with the original number so that the
		// two sets are swapped
		int result = x ^ xorVal;

		return result;
	}

	static void Main(string[] args) {
		int res = swapBits(28, 0, 3, 2);
		Console.WriteLine(res);
	}
}

   JavaScript
// JavaScript Program to swap bits
// in a given number

// Function to swap bits in a given number
function swapBits(x, p1, p2, n) {

	// Move all bits of first set to rightmost side
	let set1 = (x >> p1) & ((1 << n) - 1);

	// Move all bits of second set to rightmost side
	let set2 = (x >> p2) & ((1 << n) - 1);

	// Xor the two sets
	let xorVal = (set1 ^ set2);

	// Put the Xor bits back to their original positions
	xorVal = (xorVal << p1) | (xorVal << p2);

	// Xor the 'Xor' with the original number so that the
	// two sets are swapped
	let result = x ^ xorVal;

	return result;
}

let res = swapBits(28, 0, 3, 2);
console.log(res);

   Output
7

Checking Each bit - O(1) time and O(1) space
     The idea is to perform a bit-by-bit swap by iterating through each of the n positions, checking if
     the corresponding bits at the two positions differ, and if they do, flipping both bits to
     effectively swap their values - this approach handles the swap one bit at a time rather than
     operating on the entire bit sequences in a single operation.

   Step by step approach:
    1. For each of the n positions, create masks to isolate individual bits at both locations.
    2. Check if the bits at the two positions are different (one is 0 and one is 1).
    3. If they differ, flip both bits by clearing the set bit and setting the unset bit.
    4. If the bits are identical (both 0 or both 1), no action is needed.
    5. Increment both position pointers and continue until all n bits are processed.

   C++
// C++ Program to swap bits
// in a given number
#include <bits/stdc++.h>
using namespace std;

int swapBits(int x, int p1, int p2, int n) {
	int shift1, shift2, value1, value2;
	while (n--) {

		// Setting bit at p1 position to 1
		shift1 = 1 << p1;
		// Setting bit at p2 position to 1
		shift2 = 1 << p2;

		// value1 and value2 will have 0 if num
		// at the respective positions - p1 and p2 is 0.
		value1 = ((x & shift1));
		value2 = ((x & shift2));

		// check if value1 and value2 are different
		// i.e. at one position bit is set and other it is not
		if ((!value1 && value2) || (!value2 && value1)) {

			// if bit at p1 position is set
			if (value1) {

				// unset bit at p1 position
				x = x & (~shift1);

				// set bit at p2 position
				x = x | shift2;
			}
			// if bit at p2 position is set
			else {

				// set bit at p2 position
				x = x & (~shift2);

				// unset bit at p2 position
				x = x | shift1;
			}
		}
		p1++;
		p2++;
	}

	// return final result
	return x;
}

int main() {
	int res = swapBits(28, 0, 3, 2);
	cout << res;
	return 0;
}

   Java
// Java Program to swap bits
// in a given number

class GfG {

	static int swapBits(int x, int p1, int p2, int n) {
		int shift1, shift2, value1, value2;
		while (n > 0) {

			// Setting bit at p1 position to 1
			shift1 = 1 << p1;
			// Setting bit at p2 position to 1
			shift2 = 1 << p2;

			// value1 and value2 will have 0 if num
			// at the respective positions - p1 and p2 is 0.
			value1 = (x & shift1);
			value2 = (x & shift2);

			// check if value1 and value2 are different
			// i.e. at one position bit is set and other it is not
			if ((value1 == 0 && value2 != 0) ||
			(value2 == 0 && value1 != 0)) {

				// if bit at p1 position is set
				if (value1 != 0) {

					// unset bit at p1 position
					x = x & (~shift1);

					// set bit at p2 position
					x = x | shift2;
				}
				// if bit at p2 position is set
				else {

					// set bit at p2 position
					x = x & (~shift2);

					// unset bit at p2 position
					x = x | shift1;
				}
			}
			p1++;
			p2++;
			n--;
		}

		// return final result
		return x;
	}

	public static void main(String[] args) {
		int res = swapBits(28, 0, 3, 2);
		System.out.println(res);
	}
}

   Python
# Python Program to swap bits
# in a given number

def swapBits(x, p1, p2, n):
	shift1 = shift2 = value1 = value2 = 0
	while n > 0:

		# Setting bit at p1 position to 1
		shift1 = 1 << p1
		# Setting bit at p2 position to 1
		shift2 = 1 << p2

		# value1 and value2 will have 0 if num
		# at the respective positions - p1 and p2 is 0.
		value1 = x & shift1
		value2 = x & shift2

		# check if value1 and value2 are different
		# i.e. at one position bit is set and other it is not
		if (not value1 and value2) or (not value2 and value1):

			# if bit at p1 position is set
			if value1:

				# unset bit at p1 position
				x = x & (~shift1)

				# set bit at p2 position
				x = x | shift2

			# if bit at p2 position is set
			else:

				# set bit at p2 position
				x = x & (~shift2)

				# unset bit at p2 position
				x = x | shift1

		p1 += 1
		p2 += 1
		n -= 1

	# return final result
	return x

if __name__ == "__main__":
	res = swapBits(28, 0, 3, 2)
	print(res)

   C#
// C# Program to swap bits
// in a given number
using System;

class GfG {

	static int swapBits(int x, int p1, int p2, int n) {
		int shift1, shift2, value1, value2;
		while (n-- > 0) {

			// Setting bit at p1 position to 1
			shift1 = 1 << p1;
			// Setting bit at p2 position to 1
			shift2 = 1 << p2;

			// value1 and value2 will have 0 if num
			// at the respective positions - p1 and p2 is 0.
			value1 = (x & shift1);
			value2 = (x & shift2);

			// check if value1 and value2 are different
			// i.e. at one position bit is set and other it is not
			if ((!Convert.ToBoolean(value1) && value2 != 0) ||
			(!Convert.ToBoolean(value2) && value1 != 0)) {

				// if bit at p1 position is set
				if (value1 != 0) {

					// unset bit at p1 position
					x = x & (~shift1);

					// set bit at p2 position
					x = x | shift2;
				}
				// if bit at p2 position is set
				else {

					// set bit at p2 position
					x = x & (~shift2);

					// unset bit at p2 position
					x = x | shift1;
				}
			}
			p1++;
			p2++;
		}

		// return final result
		return x;
	}

	static void Main(string[] args) {
		int res = swapBits(28, 0, 3, 2);
		Console.WriteLine(res);
	}
}

   JavaScript
// JavaScript Program to swap bits
// in a given number

function swapBits(x, p1, p2, n) {
	let shift1, shift2, value1, value2;
	while (n--) {

		// Setting bit at p1 position to 1
		shift1 = 1 << p1;
		// Setting bit at p2 position to 1
		shift2 = 1 << p2;

		// value1 and value2 will have 0 if num
		// at the respective positions - p1 and p2 is 0.
		value1 = x & shift1;
		value2 = x & shift2;

		// check if value1 and value2 are different
		// i.e. at one position bit is set and other it is not
		if ((!value1 && value2) || (!value2 && value1)) {

			// if bit at p1 position is set
			if (value1) {

				// unset bit at p1 position
				x = x & (~shift1);

				// set bit at p2 position
				x = x | shift2;
			}
			// if bit at p2 position is set
			else {

				// set bit at p2 position
				x = x & (~shift2);

				// unset bit at p2 position
				x = x | shift1;
			}
		}
		p1++;
		p2++;
	}

	// return final result
	return x;
}

let res = swapBits(28, 0, 3, 2);
console.log(res);

   Output
7


---
[**4]
https://www.geeksforgeeks.org/dsa/count-number-of-bits-to-be-flipped-to-convert-a-to-b/

Minimum Bit Flips to convert A to B
10 Apr, 2025

   Given two numbers A and B. Write a program to count the number of bits needed to be flipped to
   convert A to B.

   Examples:

     Input: A = 10, B = 20
     Output: 4
     Explanation: Binary representation of A is 00001010
     Binary representation of B is 00010100
     We need to flip highlighted four bits in A to make it B.

     Input: A = 7, B = 10
     Output: 3
     Explanation: Binary representation of A is 00000111
     Binary representation of B is 00001010
     We need to flip highlighted three bits in A to make it B.

Count the number of bits to be flipped to convert A to B using the XOR operator:
   To solve the problem follow the below idea:

     Calculate (A XOR B), since 0 XOR 1 and 1 XOR 0 is equal to 1. So calculating the number of set
     bits in A XOR B will give us the count of the number of unmatching bits in A and B, which needs to
     be flipped

   Follow the given steps to solve the problem:
     * Calculate the XOR of A and B
     * Count the set bits in the above-calculated XOR result
     * Return the count

   Below is the implementation of the above approach:
   C++
// C++ program for the above approach
#include <bits/stdc++.h>
using namespace std;

// Function that count set bits
int countSetBits(int n) {
	int count = 0;
	while (n > 0) {
		count++;
		n &= (n - 1);
	}
	return count;
}

// Function that return count of
// flipped number
int FlippedCount(int a, int b) {
	// Return count of set bits in
	// a XOR b
	return countSetBits(a ^ b);
}

// Driver code
int main() {
	int a = 10;
	int b = 20;

	  // Function call
	cout << FlippedCount(a, b) << endl;
	return 0;
}

// This code is contributed by Sania Kumari Gupta
// (kriSania804)

   C
// C program for the above approach
#include <stdio.h>

// Function that count set bits
int countSetBits(int n) {
	int count = 0;
	while (n > 0) {
		count++;
		n &= (n - 1);
	}
	return count;
}

// Function that return count of flipped number
int FlippedCount(int a, int b) {
	// Return count of set bits in a XOR b
	return countSetBits(a ^ b);
}

// Driver code
int main() {
	int a = 10;
	int b = 20;

	// Function call
	printf("%d\n", FlippedCount(a, b));
	return 0;
}

// This code is contributed by Sania Kumari Gupta
// (kriSania804)

   Java
// Java program for the above approach
import java.util.*;

class Count {

	// Function that count set bits
	public static int countSetBits(int n) {
		int count = 0;
		while (n != 0) {
			count++;
			n &= (n - 1);
		}
		return count;
	}

	// Function that return count of
	// flipped number
	public static int FlippedCount(int a, int b) {
		// Return count of set bits in
		// a XOR b
		return countSetBits(a ^ b);
	}

	// Driver code
	public static void main(String[] args) {
		int a = 10;
		int b = 20;

		  // Function call
		System.out.print(FlippedCount(a, b));
	}
}

// This code is contributed by rishabh_jain

   Python
# Python3 program for the above approach

# Function that count set bits


def countSetBits(n):
	count = 0
	while n:
		count += 1
		n &= (n-1)
	return count

# Function that return count of
# flipped number


def FlippedCount(a, b):

	# Return count of set bits in
	# a XOR b
	return countSetBits(a ^ b)


# Driver code
if __name__ == "__main__":
  a = 10
  b = 20

  # Function call
  print(FlippedCount(a, b))

# This code is contributed by "Sharad_Bhardwaj".

   C#
// C# program for the above approach

using System;

class Count {

	// Function that count set bits
	public static int countSetBits(int n) {
		int count = 0;
		while (n != 0) {
			count++;
			n &= (n - 1);
		}
		return count;
	}

	// Function that return
	// count of flipped number
	public static int FlippedCount(int a, int b) {
		// Return count of set
		// bits in a XOR b
		return countSetBits(a ^ b);
	}

	// Driver code
	public static void Main() {
		int a = 10;
		int b = 20;

		  // Function call
		Console.WriteLine(FlippedCount(a, b));
	}
}

// This code is contributed by vt_m.

   JavaScript
// Count number of bits to be flipped
// to convert A into Bclass Count {

	// Function that count set bits
	function countSetBits(n) {
		var count = 0;
		while (n != 0) {
			count++;
			n &= (n - 1);
		}
		return count;
	}

	// Function that return count of
	// flipped number
	function FlippedCount(a , b) {
		// Return count of set bits in
		// a XOR b
		return countSetBits(a ^ b);
	}

	// Driver code
		var a = 10;
		var b = 20;
		document.write(FlippedCount(a, b));

// This code is contributed by shikhasingrajput

   PHP
<?php
// php program for the above approach

// Function that count set bits
function countSetBits($n) {
	$count = 0;
	while($n)
	{
		$count += 1;
		$n &= (n-1);
	}
	return $count;
}

// Function that return
// count of flipped number
function FlippedCount($a, $b) {
	// Return count of set
	// bits in a XOR b
	return countSetBits($a ^ $b);
}

// Driver code
$a = 10;
$b = 20;

// Function call
echo FlippedCount($a, $b);

// This code is contributed by mits
?>

   Output
4

   Time Complexity: O(K) where K is the number of bits
   Auxiliary Space: O(1)

	 Note: Set bits in (a XOR b) can also be computer using built in function __builtin_popcount() in
	 C/C++

   Below is the implementation of the above approach:
   C++
// C++ program to Count number of bits to be flipped
// to convert A into B
#include <iostream>
using namespace std;

// Driver code
int main() {
	int a = 10;
	int b = 20;

	  // Function call
	cout <<__builtin_popcount(a^b) << endl;
	return 0;
}

// This code is contributed by Suruchi Kumari

   C
//C program to Count number of bits to be flipped
// to convert A into B
#include <stdio.h>

// Driver code
int main() {
	int a = 10;
	int b = 20;

	  // Function call
	printf("%d\n",__builtin_popcount(a^b));
	return 0;
}

// This code is contributed by Suruchi Kumari

   Java
//java code

public class Main {
	public static void main(String[] args) {
		int a = 10;
		int b = 20;

		// Function call
		System.out.println(Integer.bitCount(a ^ b));
	}
}
//code by ksam24000

   Python
# Python program to Count number of bits to be flipped
# to convert A into B

# Driver code
if __name__ == '__main__':
	a = 10
	b = 20

	# Function call
	# Converting int to binary and counting number of bits
	result = bin(a ^ b).count("1")
	print(result)

   C#
using System;
class Program
{
  static void Main(string[] args)
  {
	int a = 10;
	int b = 20;

	// Function call
	Console.WriteLine(BitCount(a ^ b));
  }

  static int BitCount(int value)
  {
	int count = 0;
	while (value != 0)
	{
	  count += value & 1;
	  value >>= 1;
	}
	return count;
  }
}

   JavaScript
// Function to count number of bits to be flipped
// to convert A into B
function countBits(a, b) {
	return (a ^ b).toString(2).split('1').length-1;
}

// Driver code
let a = 10;
let b = 20;
console.log(countBits(a, b));

// This code is contributed by Potta Lokesh

   Output
4

   Time Complexity: O(K) where K is the number of bits
   Auxiliary Space: O(1)

Count the number of bits to be flipped to convert A to B using the AND operator:

   To solve the problem follow the below idea:

     Start comparing the bits in A and B, starting from the least significant bit and if (A & 1) is not
     equal to (B & 1) then the current bit needs to be flipped, as the value of bits is different at
     this position in both the numbers

   Follow the given steps to solve the problem:
     * Declare variable flips equal to zero
     * Run a loop, while a is greater than zero and b is also greater than zero
          + Calculate values of (A AND 1) and (B AND 1)
          + If these values are not equal then increase the flip value by 1
          + Right shift a and b by 1
     * Return flips

   Below is the implementation of the above approach:
   C++
// C++ program for the above approach
#include <iostream>
using namespace std;

int countFlips(int a, int b) {

	// initially flips is equal to 0
	int flips = 0;

	// & each bits of a && b with 1
	// and store them if t1 and t2
	// if t1 != t2 then we will flip that bit

	while (a > 0 || b > 0) {

		int t1 = (a & 1);
		int t2 = (b & 1);

		if (t1 != t2) {
			flips++;
		}
		// right shifting a and b
		a >>= 1;
		b >>= 1;
	}

	return flips;
}

int main() {
	int a = 10;
	int b = 20;
	cout << countFlips(a, b);
}

// this code is contributed by shivanisinghss2110

   Java
// Java program for the above approach

// CONTRIBUTED BY PRAVEEN VISHWAKARMA

import java.io.*;

class GFG {

	public static int countFlips(int a, int b)
	{
		// initially flips is equal to 0
		int flips = 0;

		// & each bits of a && b with 1
		// and store them if t1 and t2
		// if t1 != t2 then we will flip that bit

		while (a > 0 || b > 0) {

			int t1 = (a & 1);
			int t2 = (b & 1);

			if (t1 != t2) {
				flips++;
			}
			// right shifting a and b
			a >>>= 1;
			b >>>= 1;
		}

		return flips;
	}

	// Driver code
	public static void main(String[] args)
	{
		int a = 10;
		int b = 20;

		  // Function call
		System.out.println(countFlips(a, b));
	}
}

   Python
# Python3 program for the above approach


def countFlips(a, b):

	# initially flips is equal to 0
	flips = 0

	# & each bits of a && b with 1
	# and store them if t1 and t2
	# if t1 != t2 then we will flip that bit
	while(a > 0 or b > 0):
		t1 = (a & 1)
		t2 = (b & 1)
		if(t1 != t2):
			flips += 1

		# right shifting a and b
		a >>= 1
		b >>= 1

	return flips


# Driver code
if __name__ == "__main__":
  a = 10
  b = 20

  # Function call
  print(countFlips(a, b))

# This code is contributed by shivanisinghss2110

   C#
// C# program for the above approach
using System;

class GFG {

	public static int countFlips(int a, int b)
	{

		// initially flips is equal to 0
		int flips = 0;

		// & each bits of a && b with 1
		// and store them if t1 and t2
		// if t1 != t2 then we will flip that bit
		while (a > 0 || b > 0) {

			int t1 = (a & 1);
			int t2 = (b & 1);

			if (t1 != t2) {
				flips++;
			}
			// right shifting a and b
			a >>= 1;
			b >>= 1;
		}

		return flips;
	}

	// Driver code
	public static void Main(String[] args)
	{
		int a = 10;
		int b = 20;

		  // Function call
		Console.Write(countFlips(a, b));
	}
}

// This code is contributed by shivanisinghss2110

   JavaScript
/*package whatever //do not write package name here */

function countFlips(a, b){
		  // initially flips is equal to 0
		var flips = 0;

		  // & each bits of a && b with 1
		  // and store them if t1 and t2
		// if t1 != t2 then we will flip that bit

		  while(a>0 || b>0){

			var t1 = (a&1);
			  var t2 = (b&1);

			  if(t1!=t2){
				flips++;
			}
			  // right shifting a and b
			  a>>>=1;
			  b>>>=1;
		}

	  return flips;
	}

		  var a = 10;
		  var b = 20;
		  document.write(countFlips(a, b));

// This code is contributed by shivanisinghss2110

   Output
4

   Time Complexity: O(K) where K is the number of bits
   Auxiliary Space: O(1)

Count the number of bits to be flipped to convert A to B:-
   To solve this we just need to do a few simple steps. To know more follow the below steps:-

Approach:
     * Convert A and B to binary numbers.
     * Compare using 'equal to' operator if equal then return 0 otherwise iterate and
     * compare the ith of A to ith of B and count the operations
     * print the count.

   C++
// C++ program for the above approach
#include <bits/stdc++.h>
using namespace std;

string binary(int num) {
	string str = "";
	while (num) {
		if (num & 1) // 1
			str += '1';
		else // 0
			str += '0';
		num >>= 1; // Right Shift by 1
	}
	reverse(str.begin(), str.end());
	return str;
}

int main() {
	int a = 10;
	int b = 20;
	string astr = binary(a);
	string bstr = binary(b);
	// size of the binary strings.
	int na = astr.size(), nb = bstr.size();
	int cnt = 0;
	// difference between the size of the both a and b
	// string
	//	 int maxi = max(na, nb);
	int diff = abs(na - nb);

	// if a size is greater then check it has 1 upto diff
	// then cnt++;

	if (na > nb) {
		for (int i = 0; i < diff; i++) {
			if (astr[i] == '1') {
				cnt++;
			}
		}
	}
	// do the same as above
	else if (na < nb) {
		for (int i = 0; i < diff; i++) {
			if (bstr[i] == '1') {
				cnt++;
			}
		}
	}
	na = na - 1;
	nb = nb - 1;
	// check from the last if has not equal characters and
	// cnt++;
	while (na >= 0 and nb >= 0) {
		if (astr[na] != bstr[nb]) {
			cnt++;
		}
		na--;
		nb--;
	}
	// print the cnt
	cout << cnt << endl;
	return 0;
}

// this code is contributed by ksam24000

   Java
import java.util.*;

public class Main {

  public static String binary(int num) {
	String str = "";
	while (num > 0) {
	  if ((num & 1) == 1) // 1
		str += '1';
	  else // 0
		str += '0';
	  num >>= 1; // Right Shift by 1
	}
	return new StringBuilder(str).reverse().toString();
  }

  public static void main(String[] args) {
	int a = 10;
	int b = 20;
	String astr = binary(a);
	String bstr = binary(b);

	// size of the binary strings.
	int na = astr.length(), nb = bstr.length();
	int cnt = 0;

	// difference between the size of the both a and b
	int diff = Math.abs(na - nb);

	// if a size is greater then check it has 1 upto diff
	// then cnt++;
	if (na > nb) {
	  for (int i = 0; i < diff; i++) {
		if (astr.charAt(i) == '1') {
		  cnt++;
		}
	  }
	}

	// do the same as above
	else if (na < nb) {
	  for (int i = 0; i < diff; i++) {
		if (bstr.charAt(i) == '1') {
		  cnt++;
		}
	  }
	}
	na = na - 1;
	nb = nb - 1;

	// check from the last if has not equal characters and
	// cnt++;
	while (na >= 0 && nb >= 0) {
	  if (astr.charAt(na) != bstr.charAt(nb)) {
		cnt++;
	  }
	  na--;
	  nb--;
	}

	// print the cnt
	System.out.println(cnt);
  }
}

// This code is contributed by divyansh2212

   Python
def binary(num):
	str = ""
	while num:
		if num & 1: # 1
			str += '1'
		else: # 0
			str += '0'
		num >>= 1 # Right Shift by 1
	return str[::-1]

a = 10
b = 20
astr = binary(a)
bstr = binary(b)

# size of the binary strings.
na, nb = len(astr), len(bstr)
cnt = 0

# difference between the size of the both a and b string
diff = abs(na - nb)

# if a size is greater then check it has 1 upto diff then cnt++
if na > nb:
	for i in range(diff):
		if astr[i] == '1':
			cnt += 1
# do the same as above
elif na < nb:
	for i in range(diff):
		if bstr[i] == '1':
			cnt += 1

na -= 1
nb -= 1
# check from the last if has not equal characters and cnt++
while na >= 0 and nb >= 0:
	if astr[na] != bstr[nb]:
		cnt += 1
	na -= 1
	nb -= 1

# print the cnt
print(cnt)

   C#
using System;

public class Program
{
	static string Binary(int num)
	{
		string str = "";
		while (num != 0)
		{
			if ((num & 1) == 1) // 1
				str += '1';
			else // 0
				str += '0';
			num >>= 1; // Right Shift by 1
		}
		char[] charArray = str.ToCharArray();
		Array.Reverse(charArray);
		return new string(charArray);
	}

	public static void Main()
	{
		int a = 10;
		int b = 20;
		string astr = Binary(a);
		string bstr = Binary(b);
		// size of the binary strings.
		int na = astr.Length, nb = bstr.Length;
		int cnt = 0;
		// difference between the size of the both a and b
		// string
		int diff = Math.Abs(na - nb);

		// if a size is greater then check it has 1 upto diff
		// then cnt++;

		if (na > nb)
		{
			for (int i = 0; i < diff; i++)
			{
				if (astr[i] == '1')
				{
					cnt++;
				}
			}
		}
		// do the same as above
		else if (na < nb)
		{
			for (int i = 0; i < diff; i++)
			{
				if (bstr[i] == '1')
				{
					cnt++;
				}
			}
		}
		na = na - 1;
		nb = nb - 1;
		// check from the last if has not equal characters and
		// cnt++;
		while (na >= 0 && nb >= 0)
		{
			if (astr[na] != bstr[nb])
			{
				cnt++;
			}
			na--;
			nb--;
		}
		// print the cnt
		Console.WriteLine(cnt);
	}
}

// ksam24000

   JavaScript
function binary(num) {
  let str = '';
  while (num) {
	if (num & 1) str += '1';
	else str += '0';
	num >>= 1;
  }
  return str.split('').reverse().join('');
}

let a = 10;
let b = 20;
let astr = binary(a);
let bstr = binary(b);
let na = astr.length;
let nb = bstr.length;
let cnt = 0;
let diff = Math.abs(na - nb);

if (na > nb) {
  for (let i = 0; i < diff; i++) {
	if (astr[i] === '1') cnt++;
  }
} else if (na < nb) {
  for (let i = 0; i < diff; i++) {
	if (bstr[i] === '1') cnt++;
  }
}

na--;
nb--;

while (na >= 0 && nb >= 0) {
  if (astr[na] !== bstr[nb]) cnt++;
  na--;
  nb--;
}

console.log(cnt);

// THIS CODE IS CONTRIBUTED BY CHANDAN AGARWAL

   Output
4

   Time complexity- O(log N)
   Auxiliary Space - O(N)

   Thanks to Sahil Rajput for providing the above implementation.


---
[**5]
https://www.geeksforgeeks.org/dsa/detect-if-two-integers-have-opposite-signs/

Detect if two integers have opposite signs
12 Mar, 2025

   Given two integers a and b, the task is to determine whether they have opposite signs. Return true if
   the signs of the two numbers are different and false otherwise.

   Examples:

     Input: a = -5, b = 10
     Output: true
     Explanation: One number is negative and the other is positive, so their signs are different.

     Input: a = 7, b = 15
     Output: false
     Explanation: Both numbers are positive, so their signs are the same.

     Input: a = 99, b = -112
     Output: true
     Explanation: One number is negative and the other is positive, so their signs are different.

   Table of Content
     * Using XOR Operator - O(1) Time and O(1) Space
     * Using Relational Operator - O(1) Time and O(1) Space
     * Using XOR + Right Shift Operator - O(1) Time and O(1) Space
     * Using Multiplication Operator - O(1) Time and O(1) Space

Using XOR Operator - O(1) Time and O(1) Space
     The idea is that XOR (^) between two numbers with opposite signs will always have its leftmost
     (sign) bit set to 1. This means that if (a ^ b) < 0, then a and b have opposite signs.

   C++
// C++ program to check if two integers have opposite signs
#include <bits/stdc++.h>
using namespace std;

// Function to check if two numbers have opposite signs
bool haveOppositeSigns(int a, int b) {

	// Using XOR to check if signs are different
	return (a ^ b) < 0;
}

int main() {

	int a = -5, b = 10;

	if (haveOppositeSigns(a, b)) {
		cout << "true" << endl;
	} else {
		cout << "false" << endl;
	}

	return 0;
}

   Java
// Java program to check if two integers have opposite signs
class GfG {

	// Function to check if two numbers have opposite signs
	static boolean haveOppositeSigns(int a, int b) {

		// Using XOR to check if signs are different
		return (a ^ b) < 0;
	}

	public static void main(String[] args) {

		int a = -5, b = 10;

		if (haveOppositeSigns(a, b)) {
			System.out.println("true");
		} else {
			System.out.println("false");
		}
	}
}

   Python
# Python program to check if two integers have opposite signs

# Function to check if two numbers have opposite signs
def haveOppositeSigns(a, b):

	# Using XOR to check if signs are different
	return (a ^ b) < 0

if __name__ == "__main__":

	a, b = -5, 10

	if haveOppositeSigns(a, b):
		print("true")
	else:
		print("false")

   C#
// C# program to check if two integers have opposite signs
using System;

class GfG {

	// Function to check if two numbers have opposite signs
	static bool haveOppositeSigns(int a, int b) {

		// Using XOR to check if signs are different
		return (a ^ b) < 0;
	}

	public static void Main() {

		int a = -5, b = 10;

		if (haveOppositeSigns(a, b)) {
			Console.WriteLine("true");
		} else {
			Console.WriteLine("false");
		}
	}
}

   JavaScript
// JavaScript program to check if two integers have opposite signs

// Function to check if two numbers have opposite signs
function haveOppositeSigns(a, b) {

	// Using XOR to check if signs are different
	return (a ^ b) < 0;
}

let a = -5, b = 10;

if (haveOppositeSigns(a, b)) {
	console.log("true");
} else {
	console.log("false");
}

   Output
true

Using Relational Operator - O(1) Time and O(1) Space
     The idea is to use a ternary condition to explicitly check whether one number is negative and the
     other is non-negative. If a is negative, we check if b is non-negative; otherwise, we check if b
     is negative.

   C++
// C++ program to check if two integers have opposite signs
#include <bits/stdc++.h>
using namespace std;

// Function to check if two numbers have opposite signs
bool haveOppositeSigns(int a, int b) {

	// Checking signs using relational operator
	return (a < 0) ? (b >= 0) : (b < 0);
}

int main() {

	int a = -5, b = 10;

	if (haveOppositeSigns(a, b)) {
		cout << "true" << endl;
	} else {
		cout << "false" << endl;
	}

	return 0;
}

   Java
// Java program to check if two integers have opposite signs
class GfG {

	// Function to check if two numbers have opposite signs
	static boolean haveOppositeSigns(int a, int b) {

		// Checking signs using relational operator
		return (a < 0) ? (b >= 0) : (b < 0);
	}

	public static void main(String[] args) {

		int a = -5, b = 10;

		if (haveOppositeSigns(a, b)) {
			System.out.println("true");
		} else {
			System.out.println("false");
		}
	}
}

   Python
# Function to check if two numbers have opposite signs
def haveOppositeSigns(a, b):

	# Checking signs using relational operator
	return (a < 0) if (b >= 0) else (b < 0)

if __name__ == "__main__":

	a, b = -5, 10

	if haveOppositeSigns(a, b):
		print("true")
	else:
		print("false")

   C#
// C# program to check if two integers have opposite signs
using System;

class GfG {

	// Function to check if two numbers have opposite signs
	static bool haveOppositeSigns(int a, int b) {

		// Checking signs using relational operator
		return (a < 0) ? (b >= 0) : (b < 0);
	}

	public static void Main() {

		int a = -5, b = 10;

		if (haveOppositeSigns(a, b)) {
			Console.WriteLine("true");
		} else {
			Console.WriteLine("false");
		}
	}
}

   JavaScript
// Function to check if two numbers have opposite signs
function haveOppositeSigns(a, b) {

	// Checking signs using relational operator
	return (a < 0) ? (b >= 0) : (b < 0);
}

let a = -5, b = 10;

if (haveOppositeSigns(a, b)) {
	console.log("true");
} else {
	console.log("false");
}

   Output
true

Using XOR + Right Shift Operator - O(1) Time and O(1) Space
     The idea is to first compute a ^ b, which results in a negative number if a and b have opposite
     signs. Then, we right shift it by 31 (for 32-bit integers) to check the sign bit. If the result is
     1, it means the numbers have opposite signs; otherwise, they do not.

   C++
// C++ program to check if two integers have opposite signs
#include <bits/stdc++.h>
using namespace std;

// Function to check if two numbers have opposite signs
bool haveOppositeSigns(int a, int b) {

	// Checking signs using bitwise XOR and right shift
	return ((a ^ b) >> 31);
}

int main() {

	int a = -5, b = 10;

	if (haveOppositeSigns(a, b)) {
		cout << "true" << endl;
	} else {
		cout << "false" << endl;
	}

	return 0;
}

   Java
// Java program to check if two integers have opposite signs
class GfG {

	// Function to check if two numbers have opposite signs
	static boolean haveOppositeSigns(int a, int b) {

		// Checking signs using bitwise XOR and right shift
		return ((a ^ b) >> 31) != 0;
	}

	public static void main(String[] args) {

		int a = -5, b = 10;

		if (haveOppositeSigns(a, b)) {
			System.out.println("true");
		} else {
			System.out.println("false");
		}
	}
}

   Python
# Python Program to check if two numbers have
# opposite signs
def haveOppositeSigns(a, b):

	# Checking signs using bitwise XOR and right shift
	return ((a ^ b) >> 31) != 0

if __name__ == "__main__":

	a, b = -5, 10

	if haveOppositeSigns(a, b):
		print("true")
	else:
		print("false")

   C#
// C# program to check if two integers have opposite signs
using System;

class GfG {

	// Function to check if two numbers have opposite signs
	static bool haveOppositeSigns(int a, int b) {

		// Checking signs using bitwise XOR and right shift
		return ((a ^ b) >> 31) != 0;
	}

	public static void Main() {

		int a = -5, b = 10;

		if (haveOppositeSigns(a, b)) {
			Console.WriteLine("true");
		} else {
			Console.WriteLine("false");
		}
	}
}

   JavaScript
// Javascript Program  to check if two numbers
// have opposite signs
function haveOppositeSigns(a, b) {

	// Checking signs using bitwise XOR and right shift
	return ((a ^ b) >> 31) !== 0;
}

let a = -5, b = 10;

if (haveOppositeSigns(a, b)) {
	console.log("true");
} else {
	console.log("false");
}

   Output
true

Using Multiplication Operator - O(1) Time and O(1) Space
     The idea is to use multiplication to check the signs of two integers. The product of two numbers
     will be negative if and only if one number is positive and the other is negative. By casting the
     integers to a larger data type (long long, long, BigInt, etc.), we avoid overflow issues. If the
     product is less than zero, it means the numbers have opposite signs; otherwise, they have the same
     sign.

   C++
// C++ program to check if two integers have opposite signs
#include <bits/stdc++.h>
using namespace std;

// Function to check if two numbers have opposite signs
bool haveOppositeSigns(int a, int b) {

	// Checking signs using multiplication and type casting
	long long product = (long long) a * b;
	return (product < 0);
}

int main() {

	int a = -5, b = 10;

	if (haveOppositeSigns(a, b)) {
		cout << "true" << endl;
	} else {
		cout << "false" << endl;
	}

	return 0;
}

   Java
// Java program to check if two integers have opposite signs
class GfG {

	// Function to check if two numbers have opposite signs
	static boolean haveOppositeSigns(int a, int b) {

		// Checking signs using multiplication and type casting
		long long product = (long long) a * b;
		return (product < 0);
	}

	public static void main(String[] args) {

		int a = -5, b = 10;

		if (haveOppositeSigns(a, b)) {
			System.out.println("true");
		} else {
			System.out.println("false");
		}
	}
}

   Python
# Python program to check if two integers
# have opposite signs

def haveOppositeSigns(a, b):

	# Checking signs using multiplication and type casting
	product = int(a) * int(b)
	return product < 0

if __name__ == "__main__":

	a, b = -5, 10

	if haveOppositeSigns(a, b):
		print("true")
	else:
		print("false")

   C#
// C# program to check if two integers have opposite signs
using System;

class GfG {

	// Function to check if two numbers have opposite signs
	static bool haveOppositeSigns(int a, int b) {

		// Checking signs using multiplication and type casting
		long product = (long) a * b;
		return (product < 0);
	}

	public static void Main() {

		int a = -5, b = 10;

		if (haveOppositeSigns(a, b)) {
			Console.WriteLine("true");
		} else {
			Console.WriteLine("false");
		}
	}
}

   JavaScript
// Javscript program to check if two
// integers have opposite signs

function haveOppositeSigns(a, b) {

	// Checking signs using multiplication and type casting
	let product = BigInt(a) * BigInt(b);
	return product < 0;
}

let a = -5, b = 10;

if (haveOppositeSigns(a, b)) {
	console.log("true");
} else {
	console.log("false");
}

   Output
true


---

