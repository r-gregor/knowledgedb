https://c-for-dummies.com/blog/?p=2568

Wide Characters and Unicode, Part I
June 24, 2017

   At the dawn of the microcomputer era, lowercase text was considered a big deal. That's
   because many home computers at the time displayed only uppercase letters. Memory was tight.
   Full-ASCII character generators added to the system's cost. Yes, a microcomputer that
   displayed lowercase text was a big deal.
   Eventually microcomputers hosted the entire gamut of ASCII text. Beyond the 32 control
   codes, ASCII provides symbols for all the keyboard characters, which is what most early
   computer users wanted - and lowercase, naturally.

   A microcomputer byte held 256 values, but ASCII defines only 128 characters. So many
   microcomputer manufacturers offered extra characters and symbols in the "upper" or
   "extended" 128 codes. (These codes weren't defined by the ASCII standard.) IBM offered its
   Extended ASCII character set, as well as code pages you could swap in or out. These
   features provided users with foreign characters, line-drawing characters, and other symbols
   that are today called wingdings.

   A C programmer back in the day could use Extended ASCII characters to create interesting
   output, but the characters were inconsistent across computer platforms. To provide
   consistency, as well as to create a code system for all the world's languages and symbols,
   people wearing white lab coats and safety goggles developed the Unicode standard.

   Unlike ASCII, Unicode defines thousands of character codes. The Unicode Character Table
   web page presents them all in a useful format.

   As a programmer, your question might be, "How can I display Unicode text in my C program's
   text output?"

   A better question might be, "How can I use C's char output functions with a string of what
   are obviously int character values?"

   The actual question I've received over the years is, "How do I output the Yen character?"
   That's because one of my early programming books featured a program that output the Yen
   sign, ¥. That character was available on the IBM "extended ASCII" code page, but that
   system is no longer used so the character no longer appears as coded.

   Today, if you want to print the Yen sign in a terminal window program's output, you might
   think to send its Unicode value, 0x00A5, to standard output. What you see displayed,
   however, is not the Yen sign unless the program is configured to output wide characters.

	 On the PC, I see the character Ñ displayed for code 0x00A5, which is probably the active
	 code page character. On my Mac terminal, the ? is displayed. On my Ubuntu Linux system,
	 the ⍰ symbol appears.

   A wide character occupies more than a single byte of storage; it's (probably) an unsigned
   int, not a char. The standard C library features wide-character functions and has a wide
   character header file, wchar.h. But using those functions isn't enough: You must set the
   proper locale.

   Locale settings include region and language specific details for a computer program. Items
   such as the language, time and date format, and character set are included in the locale
   details. Unless you set the locale to support wide characters, your C program outputs only
   standard, boring, ASCII text.

   In C, you use the setlocale() function to check or set locale information. The function is
   defined in the locale.h header file and it requires two arguments: a locale constant and
   its string value. The function also returns the current local settings.

   In the following code, the current locale setting is returned and displayed:
#include <stdio.h>
#include <locale.h>

int main() {
	char *locale;

	locale = setlocale(LC_ALL,"");
	printf("The current locale is %s\n",locale);

	return(0);
}

   The LC_ALL constant checks all locale details. The program's output might look like this:
The current locale is en_US.UTF-8

   You might see something else output. Whatever the case, to output wide characters, you must
   set a specific environment. I address that topic in next week's Lesson.


---
https://c-for-dummies.com/blog/?p=2578

Wide Characters and Unicode, Part II
July 1, 2017

   After you set the necessary locale for your program, you're free to use the wide character
   functions defined in the wchar.h header file. For some reason, this process is
   poorly-documented on the Internet, which is probably why you're here.
   From last week's Lesson, you learned of the setlocale() function, which is key to
   creating a program environment capable of outputting wide character. The setlocale()
   function features two arguments: a category constant and a locale string.

   You'll find several category constants, each of which relates to a specific locale element,
   such as number formatting, date and time, monetary symbols, and so on. The two often used
   when playing with wide characters are LC_ALL and LC_CTYPE.

   The LC_ALL constant sets the program's entire locale. LC_CTYPE is specific to text, so it's
   the one I use.

   For the locale string, you must specify the proper character set. What you're after for
   wide characters/Unicode is the UTF-8 standard. The string to use is "UTF-8" and the
   full statement is:

   setlocale(LC_CTYPE,"UTF-8");

   Also acceptable is the specific language tag for your region, such as:

   setlocale(LC_CTYPE,"en_us.UTF-8");

   Where en_us is American English.

   Once the locale is set, you can employ the wide character functions defined in wchar.h in
   your code. For example, the putwchar() function is the wide-character counterpart to the
   putchar() function. Its argument is wchar_t value, a Unicode character.

   The following code displays several Unicode characters to standard output.

#include <locale.h>
#include <wchar.h>

int main() {
	wchar_t hello[7] = {
		0x41f, 0x440, 0x438, 0x432, 0x435, 0x442, 0x021
	};
	int x;

	setlocale(LC_CTYPE,"UTF-8");
	for(x=0;x<7;x++)
		putwchar(hello[x]);
	putchar('\n');

	return(0);
}

   Only the locale.h and wchar.h headers are required; the wchar.h header includes stdio.h, so
   you don't need to specify it again. (This inclusion may not hold for every C compiler, so
   if you get an error, include the stdio.h header.)

   An array of wchar_t characters is defined at Line 6. It's not a string. It doesn't end with
   a null character.

   Line 11 sets the locale to output UTF-8 characters.

   The for loop at Line 12 sends the hello[] array's Unicode/wchar_t characters to standard
   output courtesy of the putwchar() function.

   The putchar() function at Line 14 adds a newline, which could have been part of the hello[]
   array, but I wanted to show that you can mix text-output methods. (ASCII code 0x21 is part
   of the array.)

   Here's the output:
Привет!

   To create more string-like output, you can modify the hello[] array to include a null
   character and instead of looping through the elements, use the fputws() output function:

#include <locale.h>
#include <wchar.h>

int main() {
	wchar_t hello[] = {
		0x41f, 0x440, 0x438, 0x432, 0x435,
		0x442, '!', '\n', '\0'
	};

	setlocale(LC_CTYPE,"UTF-8");
	fputws(hello,stdout);

	return(0);
}

   The hello[] array now includes the ASCII characters !, newline, and null. The fputws()
   function at Line 12 sends that wide-character string to standard output. (An equivalent
   putws() macro doesn't exist.)

   As you might guess, a wide-character version of the printf() statement is available,
   wprintf(), along with its various sisters for different types of formatted wide-character
   output. It's not a straightforward version of printf(), as you're dealing with wide (long)
   characters. I'll explore the quirks in next week's Lesson.


---
https://c-for-dummies.com/blog/?p=2593

Wide Characters and Unicode, Part III
July 8, 2017

   Programming is a fun hobby because once you unlock and open a door, you immediately find
   another locked door. Normal humans would experience frustration, but a good programmer
   enjoys a challenge and even sees the humor in the situation. A case in point is learning
   how to program wide characters in C: Once you think you've cleared a huge hurdle, you find
   another, taller one right behind it.
   For example, you think you understand wide characters and use the putwchar() function with
   ease. (See last week's Lesson.) Then you try using the printf() equivalent, wprintf(),
   and you're back to square one.

   Don't worry, I've been there, too.

   The issue with the wprintf() function, as well as the wide-character input function
   wscanf(), is that all the text in the function must be specified as wide characters. Unless
   you work with wide characters all the time, the solution isn't apparent, and the error
   message doesn't help.

	 Just tell me the solution!

   You must specify wide-character strings and wide-character placeholders to make the
   wide-character input and output functions work. A wide-character string is prefixed by the
   letter L:

   L"I am a wide string"

   Prefixing an L (for long) before a quoted string converts it into unsigned integer values -
   wide characters.

   The placeholder for a wide character is %lc, with a lowercase L before lowercase C. This
   placeholder is used in both the wprintf() and wscanf() functions.
#include <locale.h>
#include <wchar.h>

int main() {
	wchar_t suits[4] = {
		0x2660, 0x2665, 0x2663, 0x2666
	};
	wchar_t s;
	int x;

	setlocale(LC_CTYPE,"UTF-8");

	printf("Enter suit: ( ");
	for(x=0;x<4;x++) {
		wprintf(L"%lc ",suits[x]);
	}
	printf("): ");

	wscanf(L"%lc",&s);
	wprintf(L"Suit set to %lc\n",s);

	return(0);
}

   The wprintf() function at Line 17 uses the formatting string "%lc" to output the wide
   characters stored in array suits[]. The array is defined at Line 6 as the type wchar_t,
   wide characters. The formatting string must be composed of wide-characters, so it's
   prefixed with an L.

   The wscanf() function at Line 21 reads input for a wide character, though you can also type
   plain ASCII text. Again, the input format string is prefixed with an L, and the %lc
   placeholder is used. Input variable s is of the wchar_t type.

   Finally, Line 22 should make sense by now, with the wprintf() function using various
   wide-character doodads.

   The sample run:
Enter suit: ( ♠ ♥ ♣ ♦ ): ♠
Suit set to ♠

   Above, I copied and pasted the spade character because the keyboard lacks a spade character
   key and I don't know any other ways to type a wide character in a terminal window.

   In next week's Lesson, I cover wide-character input functions beyond wscanf().


---
https://c-for-dummies.com/blog/?p=2605

Wide Characters and Unicode, Part IV
July 15, 2017

   String input is a weird thing when it comes to wide characters, mostly because how the heck
   do you type wide characters in a terminal window beyond copy-and-paste?
   For single character input, the wchar.h header defines three functions: fgetwc(), getwc(),
   and getwchar().

   The fgetwc() and getwc() functions both read one wint_t character (wide-character int type)
   from a named file stream. The getwchar() function (actually a macro) reads wide characters
   from standard input. This is the function I prefer.

	 The wint_t wide-character integer type is larger (wider) than the wchar_t "character"
	 type. The primary reason is to accommodate the end-of-file character, WEOF, which is
	 defined outside the bounds of a wchar_t variable. You can use plain old wchar_t
	 variables with the functions, but when you're hunting for the end-of-file marker with
	 fgetwc() or getwc(), use wint_t instead.

   The following code uses the getwchar() function to read wide characters one-at-a-time from
   standard input. The getwstring() function reads up to count characters or stops at the
   newline ('\n'), storing the result in the wchar_t string input:

#include <locale.h>
#include <wchar.h>

void getwstring(wchar_t *ws,int count) {
	int x = 0;
	wchar_t *a,wch;

	a = ws;
	while(x<count-1) {
		wch = getwchar();
		if( wch=='\n')
			break;
		*a = wch;
		a++;
		x++;
	}
	*a = '\0';
}

int main() {
	wchar_t input[10];

	setlocale(LC_CTYPE,"UTF-8");

	wprintf(L"Type some fancy text: ");
	getwstring(input,10);
	wprintf(L"You typed: %ls!\n",input);

	return(0);
}

   The getwstring() function uses the getwchar() macro at Line 12 to read wide-characters from
   standard input. The characters are read until the newline is input or the buffer is full.
   Then the string is capped at Line 19.

   For the sample run, I copied and pasted text from a web page:
Type some fancy text: 你好，世界
You typed: 你好，世界!

   On the Mac terminal, you can press Control+Command+Space to see the Emoji and Symbols
   palette, which you can use to pluck out one character at a time, as shown in Figure 1.

   Figure 1. The weirdo character palette in the OS X Terminal program.

   Instead of writing your own getwstring() function to read a wide-character string, you can
   use the fgetws() function. This function is the wide-character equivalent to my old pal
   fgets(). Here's the updated code:

#include <locale.h>
#include <wchar.h>

int main() {
	wchar_t input[10];

	setlocale(LC_CTYPE,"UTF-8");

	wprintf(L"Type some fancy text: ");
	fgetws(input,10,stdin);
	wprintf(L"You typed: %ls!\n",input);

	return(0);
}

   As with fgets(), the arguments for fgetws() are a buffer, input size, and the file handle.
   For standard input, stdin is used, as shown in the code.

   The code's output is almost the same:
Type some fancy text: 你好，世界
You typed: 你好，世界
!

   The fgetws() function, like its fgets() twin, reads and retains the newline character. You
   can view my quickie solution for this effect here [**1], if you want to eliminate the
   newline. I'll present another solution in a future Lesson.

   One more note: The terminal window assumes that every character displayed has the same
   width. Historically, terminals play with only ASCII text. In a GUI, the terminal assumes a
   monospaced font. A few Unicode characters, especially emojis, are wider than a single
   character position in the terminal window. The result is overlap, which you can kind of see
   in Figure 1.

   The wcwidth() function returns the number of column positions for a wide character, though
   it's not particularly useful. For example, the pizza slice shown in Figure 1 is more than 1
   column wide, though the wcwidth() function returns a character width value of 1, which
   isn't correct. My advice is to be cautious when showing such characters. If you plan on
   using a specific character, then you can eyeball the width and plan accordingly.
---
[**1]
https://c-for-dummies.com/blog/?p=24

Fixing fgets() for Input
June 1, 2013

The fgets() function is a marvelous tool for reading chunks of text from the keyboard or standard input. One
problem I have with it is that it also reads the Enter key press, sticking a \n into the string. That’s not
a big issue, however, because you can easily pull out that character.

The newline is a required character for breaking standard input into chunks. It makes sense that fgets()
would accept it and store it. Often times, however, you don’t want the newline stored as part of the input.

The solution is to code a function that modifies fgets()‘s behavior. The function needs to be passed the
address of an input buffer and a length, similar to the original arguments for fgets(). The only thing you
don’t need to pass is the file handle; for purposes of standard input, the stdin handle can be assumed.

I’ve named by substitute function input(), as shown in this code:

#include <stdio.h>

void input(char *string,int length);

int main() {
	char firstname[32],lastname[32];

	printf("What is your first name? ");
	input(firstname,32);
	printf("What is your last name? ");
	input(lastname,32);
	printf("Please to meet you %s %s.\n",
		firstname,
		lastname);

	return(0);
}

void input(char *string,int length) {
	int x;

	fgets(string,length,stdin);

	for(x=0;x<=length;x++) {
		if( string[x] == '\n') {
			string[x] = '\0';
			break;
		}
	}
}

The input() function at Line 20 serves as the surrogate for fgets(). In fact, fgets() is called immediately
within the function, at Line 24. Then a for loop plows through input searching for the newline. Once found,
it’s replaced with a null character, \0, at Line 29.

Remember: It’s possible that the input string may not contain a newline, which is why I chose to use a for
loop and work through all of the input buffer.

Also see this[**2] post.
---
[**2]
https://c-for-dummies.com/blog/?p=2631

Other Ways to Fix fgets() Input
August 5, 2017

The C language string-input function was once gets(). That function has become Chernobyl in that it exists
but you go there only when you don’t care about your health.

The problem with gets() was that it lacked bounds-checking; you could input an infinite number of character
, overflowing the buffer. This process is how various trojans and worms were created long ago. So instead of
gets(), I recommend using the fgets() function, which features bounds-checking.

Alas, the fgets() function also retains the newline character at the end of input, which is often not what
you want. So further processing is necessary when you must peel off the trailing newline.

A solution I offered in a blog post from 2013 uses fgets() in an input() function that strips away the
newline. Here is that function:

void input(char *string,int length) {
	int x;

	fgets(string,length,stdin);

	for(x=0;x<=length;x++) {

		if( string[x] == '\n') {
			string[x] = '\0';
			break;
		}
	}
}

The input() function gathers text from standard input, up to the value set by variable length, then it
churns through the buffer, replacing the newline ('\n') with a null character ('\0'). The code works, but I
wrote it to be illustrative so it’s clunkier than what I’d normally code.

Recently, I had to craft the input() function for another program. After I was done, I compared what I wrote
today with the input() function from four years ago. Here’s my newer version:

void input(char *string,int length) {
	fgets(string,length,stdin);
	while(*string != '\n') {
		string++;
	}
	*string = '\0';
}

The difference is how I located the newline and replaced it with the null character. Instead of a for loop,
I used while. Instead of array notation, I used pointers. Otherwise, the code has the same result: The
newline is gone, replaced by a null character.

I could make the loop tighter, but at this point it becomes obfuscated:

void input(char *string,int length) {
	fgets(string,length,stdin);
	while(*string++ != '\n') {
		;
	}
	*--string = '\0';
}

Incrementing the string variable takes place in the while loop’s condition. The ++ operator is suffixed,
which means that the pointer is incremented after its value is fetched.

Because the pointer is post-incremented, it must be decremented after the loop to replace '\n' with '\0'. S,
in the final statement, the -- is prefixed to the string pointer variable; its location is decremented
before the value is assigned.

Yeah, the condensed code can be confusing. Not only does it use pointers, but unless you use these
techinques all the time, prefixing and suffixing operators causes most programmers to stop and think about
the order of operations.

Is there a reason to go one way or the other?

No. I prefer readable code, so when I compose a program I typically code a function as illustrated in the
first example. The same process holds true with the ternary operator (?:): I write the code the long way,
then reduce it down later. Still, as long as the program does what you want, you’re good.

Here is the full program, the modified version of the one I presented originally back in June, 2013:

#include <stdio.h>

/* This function has a flaw; see the comments to this post */
void input(char *string,int length) {
	fgets(string,length,stdin);
	while(*string++ != '\n') {
		;
	}
	*--string = '\0';
}

int main() {
	char firstname[32],lastname[32];

	printf("What is your first name? ");
	input(firstname,32);
	printf("What is your last name? ");
	input(lastname,32);
	printf("Please to meet you %s %s.\n",
			firstname,
			lastname);

	return(0);
}


---
https://www.gnu.org/software/libc/manual/html_node/Extended-Char-Intro.html

6.1 Introduction to Extended Characters

   A variety of solutions are available to overcome the differences between character sets
   with a 1:1 relation between bytes and characters and character sets with ratios of 2:1 or
   4:1. The remainder of this section gives a few examples to help understand the design
   decisions made while developing the functionality of the C library.

   A distinction we have to make right away is between internal and external representation.
   Internal representation means the representation used by a program while keeping the text
   in memory. External representations are used when text is stored or transmitted through
   some communication channel. Examples of external representations include files waiting in a
   directory to be read and parsed.

   Traditionally there has been no difference between the two representations. It was equally
   comfortable and useful to use the same single-byte representation internally and
   externally. This comfort level decreases with more and larger character sets.

   One of the problems to overcome with the internal representation is handling text that is
   externally encoded using different character sets. Assume a program that reads two texts
   and compares them using some metric. The comparison can be usefully done only if the texts
   are internally kept in a common format.

   For such a common format (= character set) eight bits are certainly no longer enough. So
   the smallest entity will have to grow: wide characters will now be used. Instead of one
   byte per character, two or four will be used instead. (Three are not good to address in
   memory and more than four bytes seem not to be necessary).

   As shown in some other part of this manual, a completely new family has been created of
   functions that can handle wide character texts in memory. The most commonly used character
   sets for such internal wide character representations are Unicode and ISO 10646 (also known
   as UCS for Universal Character Set). Unicode was originally planned as a 16-bit character
   set; whereas, ISO 10646 was designed to be a 31-bit large code space. The two standards are
   practically identical. They have the same character repertoire and code table, but Unicode
   specifies added semantics. At the moment, only characters in the first 0x10000 code
   positions (the so-called Basic Multilingual Plane, BMP) have been assigned, but the
   assignment of more specialized characters outside this 16-bit space is already in progress.
   A number of encodings have been defined for Unicode and ISO 10646 characters: UCS-2 is a
   16-bit word that can only represent characters from the BMP, UCS-4 is a 32-bit word than
   can represent any Unicode and ISO 10646 character, UTF-8 is an ASCII compatible encoding
   where ASCII characters are represented by ASCII bytes and non-ASCII characters by sequences
   of 2-6 non-ASCII bytes, and finally UTF-16 is an extension of UCS-2 in which pairs of
   certain UCS-2 words can be used to encode non-BMP characters up to 0x10ffff.

   To represent wide characters the char type is not suitable. For this reason the ISO C
   standard introduces a new type that is designed to keep one character of a wide character
   string. To maintain the similarity there is also a type corresponding to int for those
   functions that take a single wide character.

   Data type: wchar_t
		  This data type is used as the base type for wide character strings. In other words,
		  arrays of objects of this type are the equivalent of char[] for multibyte character
		  strings. The type is defined in stddef.h.

		  The ISO C90 standard, where wchar_t was introduced, does not say anything specific
		  about the representation. It only requires that this type is capable of storing all
		  elements of the basic character set. Therefore it would be legitimate to define
		  wchar_t as char, which might make sense for embedded systems.

		  But in the GNU C Library wchar_t is always 32 bits wide and, therefore, capable of
		  representing all UCS-4 values and, therefore, covering all of ISO 10646. Some Unix
		  systems define wchar_t as a 16-bit type and thereby follow Unicode very strictly.
		  This definition is perfectly fine with the standard, but it also means that to
		  represent all characters from Unicode and ISO 10646 one has to use UTF-16 surrogate
		  characters, which is in fact a multi-wide-character encoding. But resorting to
		  multi-wide-character encoding contradicts the purpose of the wchar_t type.

   Data type: wint_t
		  wint_t is a data type used for parameters and variables that contain a single wide
		  character. As the name suggests this type is the equivalent of int when using the
		  normal char strings. The types wchar_t and wint_t often have the same representation
		  if their size is 32 bits wide but if wchar_t is defined as char the type wint_t must
		  be defined as int due to the parameter promotion.

		  This type is defined in wchar.h and was introduced in Amendment 1 to ISO C90.

   As there are for the char data type macros are available for specifying the minimum and
   maximum value representable in an object of type wchar_t.

   Macro: wint_t WCHAR_MIN
		  The macro WCHAR_MIN evaluates to the minimum value representable by an object of
		  type wint_t.

		  This macro was introduced in Amendment 1 to ISO C90.

   Macro: wint_t WCHAR_MAX
		  The macro WCHAR_MAX evaluates to the maximum value representable by an object of
		  type wint_t.

		  This macro was introduced in Amendment 1 to ISO C90.

   Another special wide character value is the equivalent to EOF.

   Macro: wint_t WEOF
		  The macro WEOF evaluates to a constant expression of type wint_t whose value is
		  different from any member of the extended character set.

		  WEOF need not be the same value as EOF and unlike EOF it also need not be negative.
		  In other words, sloppy code like

{
	int c;
	...
	while ((c = getc (fp)) < 0) {
		...
	}
}

		  has to be rewritten to use WEOF explicitly when wide characters are used:

{
  wint_t c;
  ...
  while ((c = getwc (fp)) != WEOF) {
		...
	}
}

		  This macro was introduced in Amendment 1 to ISO C90 and is defined in wchar.h.

   These internal representations present problems when it comes to storage and transmittal.
   Because each single wide character consists of more than one byte, they are affected by
   byte-ordering. Thus, machines with different endianesses would see different values when
   accessing the same data. This byte ordering concern also applies for communication
   protocols that are all byte-based and therefore require that the sender has to decide about
   splitting the wide character in bytes. A last (but not least important) point is that wide
   characters often require more storage space than a customized byte-oriented character set.

   For all the above reasons, an external encoding that is different from the internal
   encoding is often used if the latter is UCS-2 or UCS-4. The external encoding is byte-based
   and can be chosen appropriately for the environment and for the texts to be handled. A
   variety of different character sets can be used for this external encoding (information
   that will not be exhaustively presented here–instead, a description of the major groups
   will suffice). All of the ASCII-based character sets fulfill one requirement: they are
   "filesystem safe." This means that the character '/' is used in the encoding only to
   represent itself. Things are a bit different for character sets like EBCDIC (Extended
   Binary Coded Decimal Interchange Code, a character set family used by IBM), but if the
   operating system does not understand EBCDIC directly the parameters-to-system calls have to
   be converted first anyhow.
	 * The simplest character sets are single-byte character sets. There can be only up to 256
	   characters (for 8 bit character sets), which is not sufficient to cover all languages
	   but might be sufficient to handle a specific text. Handling of a 8 bit character sets
	   is simple. This is not true for other kinds presented later, and therefore, the
	   application one uses might require the use of 8 bit character sets.
	 * The ISO 2022 standard defines a mechanism for extended character sets where one
	   character can be represented by more than one byte. This is achieved by associating a
	   state with the text. Characters that can be used to change the state can be embedded in
	   the text. Each byte in the text might have a different interpretation in each state.
	   The state might even influence whether a given byte stands for a character on its own
	   or whether it has to be combined with some more bytes.
	   In most uses of ISO 2022 the defined character sets do not allow state changes that
	   cover more than the next character. This has the big advantage that whenever one can
	   identify the beginning of the byte sequence of a character one can interpret a text
	   correctly. Examples of character sets using this policy are the various EUC character
	   sets (used by Sun's operating systems, EUC-JP, EUC-KR, EUC-TW, and EUC-CN) or Shift_JIS
	   (SJIS, a Japanese encoding).
	   But there are also character sets using a state that is valid for more than one
	   character and has to be changed by another byte sequence. Examples for this are
	   ISO-2022-JP, ISO-2022-KR, and ISO-2022-CN.
	 * Early attempts to fix 8 bit character sets for other languages using the Roman alphabet
	   lead to character sets like ISO 6937. Here bytes representing characters like the acute
	   accent do not produce output themselves: one has to combine them with other characters
	   to get the desired result. For example, the byte sequence 0xc2 0x61 (non-spacing acute
	   accent, followed by lower-case 'a') to get the "small a with acute" character. To get
	   the acute accent character on its own, one has to write 0xc2 0x20 (the non-spacing
	   acute followed by a space).
	   Character sets like ISO 6937 are used in some embedded systems such as teletex.
	 * Instead of converting the Unicode or ISO 10646 text used internally, it is often also
	   sufficient to simply use an encoding different than UCS-2/UCS-4. The Unicode and
	   ISO 10646 standards even specify such an encoding: UTF-8. This encoding is able to
	   represent all of ISO 10646 31 bits in a byte string of length one to six.
	   There were a few other attempts to encode ISO 10646 such as UTF-7, but UTF-8 is today
	   the only encoding that should be used. In fact, with any luck UTF-8 will soon be the
	   only external encoding that has to be supported. It proves to be universally usable and
	   its only disadvantage is that it favors Roman languages by making the byte string
	   representation of other scripts (Cyrillic, Greek, Asian scripts) longer than necessary
	   if using a specific character set for these scripts. Methods like the Unicode
	   compression scheme can alleviate these problems.

   The question remaining is: how to select the character set or encoding to use. The answer:
   you cannot decide about it yourself, it is decided by the developers of the system or the
   majority of the users. Since the goal is interoperability one has to use whatever the other
   people one works with use. If there are no constraints, the selection is based on the
   requirements the expected circle of users will have. In other words, if a project is
   expected to be used in only, say, Russia it is fine to use KOI8-R or a similar character
   set. But if at the same time people from, say, Greece are participating one should use a
   character set that allows all people to collaborate.

   The most widely useful solution seems to be: go with the most general character set, namely
   ISO 10646. Use UTF-8 as the external encoding and problems about users not being able to
   use their own language adequately are a thing of the past.

   One final comment about the choice of the wide character representation is necessary at
   this point. We have said above that the natural choice is using Unicode or ISO 10646. This
   is not required, but at least encouraged, by the ISO C standard. The standard defines at
   least a macro __STDC_ISO_10646__ that is only defined on systems where the wchar_t type
   encodes ISO 10646 characters. If this symbol is not defined one should avoid making
   assumptions about the wide character representation. If the programmer uses only the
   functions provided by the C library to handle wide character strings there should be no
   compatibility problems with other systems.



---
https://www.ibm.com/docs/en/i/7.2?topic=lf-fwprintf-format-data-as-wide-characters-write-stream

fwprintf() — Format Data as Wide Characters and Write to a Stream
2021-04-14

Format
#include <stdio.h>
#include <wchar.h>
int fwprintf(FILE *stream, const wchar_t *format, argument-list);

Language Level
ANSI

Threadsafe
Yes

Locale Sensitive
The behavior of this function might be affected by the LC_CTYPE and LC_NUMERIC categories of the current
locale, and might also be affected by the LC_UNI_CTYPE and LC_UNI_NUMERIC categories of the current locale
if LOCALETYPE(*LOCALEUCS2) or LOCALETYPE(*LOCALEUTF) is specified on the compilation command. This function
is not available when LOCALETYPE(*CLD) is specified on the compilation command. For more information, see
Understanding CCSIDs and Locales.

Integrated File System Interface
This function is not available when SYSIFCOPT(*NOIFSIO) is specified on the compilation command.

Wide Character Function
See Wide Characters for more information.

Description
The fwprintf() function writes output to the stream pointed to by stream, under control of the wide string
pointed to by format. The format string specifies how subsequent arguments are converted for output.

The fwprintf() function converts each entry in argument-list according to the corresponding wide-character
format specifier in format.

If insufficient arguments exist for the format, the behavior is undefined. If the format is exhausted while
arguments remain, the fwprintf() function evaluates the excess arguments, but otherwise ignores them. The
fwprintf() function returns when it encounters the end of the format string.

The format comprises zero or more directives: ordinary wide characters (not %) and conversion specification
. Conversion specifications are processed as if they were replaced in the format string by wide-character
strings. The wide-character strings are the result of fetching zero or more subsequent arguments and then
converting them, if applicable, according to the corresponding conversion specifier. The fwprintf() function
then writes the expanded wide-character format string to the output stream.

The format for the fwprintf() function has the same form and function as the format string for printf(),
with the following exceptions:
	%c (without an l prefix) converts an integer argument to wchar_t, as if by calling the btowc() function.
	%s (without an l prefix) converts an array of multibyte characters to an array of wchar_t, as if by calling
	the mbrtowc() function. The array is written up to, but not including, the terminating null character,
	unless the precision specifies a shorter output.

	%ls and %S write an array of wchar_t. The array is written up to, but not including, the ending null
	character, unless the precision specifies a shorter output.
	Any width or precision specified for %c, %s, %ls, and %S indicates the number of characters rather than the
	number of bytes.

If a conversion specification is invalid, the behavior is undefined.

If any argument is, or points to, a union or an aggregate (except for an array of char type using %s
conversion, an array of wchar_t type using %ls conversion, or a pointer using %p conversion), the behavior
is undefined.

In no case does a nonexistent, or small field width, cause truncation of a field; if the conversion result
is wider than the field width, the field is expanded to contain the conversion result.

Note: When you write wide characters, the file should be opened in binary mode, or opened with the o_ccsid
or codepage parameters. This ensures that no conversions occur on the wide characters.

Return Value
The fwprintf() function returns the number of wide characters transmitted. If an output error occurred, it
returns a negative value.

Example

#include <stdio.h>
#include <wchar.h>
#include <locale.h>
int count [10] = {1, 5, 8, 3, 0, 3, 5, 6, 8, 10};

int main(void) {
	int i,j;
	FILE *stream;                       /* Open the stream for writing */ 
	if (NULL == (stream = fopen("/QSYS.LIB/LIB.LIB/WCHAR.FILE/WCHAR.MBR","wb")))
		perror("fopen error"); 
		
	for (i=0; i < sizeof(count) / sizeof(count[0]); i++) {
		for (j = 0; j < count[i]; j++) {
			fwprintf(stream, L"*");     /* Print asterisk */ 
			fwprintf(stream, L"\n");    /* Move to the next line */ 
		}
	}
	fclose (stream);
}

/* The member WCHAR of file WCHAR will contain:
   *
   *****
   ********
   ***
   ***
   *****
   ******
   ********
   **********
 */

Unicode example

#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
/* This program is compile LOCALETYPE(*LOCALEUCS2) and             */
/* SYSIFCOPT(*IFSIO)                                               */

int main(void) {
	FILE *stream;
	wchar_t wc = 0x0058;        /* UNICODE X */
	char c1 = 'c';
	char *s1 = "123";
	wchar_t ws[4];
	setlocale(LC_ALL,
	 "/QSYS.LIB/EN_US.LOCALE"); /* a CCSID 37 locale */
	ws[0] = 0x0041;             /* UNICODE A   */
	ws[1] = (wchar_t)0x0042;    /* UNICODE B   */
	ws[2] = (wchar_t)0x0043;    /* UNICODE C   */
	ws[3] = (wchar_t)0x0000;

	stream = fopen("myfile.dat", "wb+");

	/* lc and ls take wide char as input and just copies then  */
	/* to the file.  So the file would look like this          */
	/* after the below fwprintf statement:                     */
	/* 0058002000200020004100420043                            */
	/* 0020 is UNICODE blank                                   */

	fwprintf(stream, L"%lc %ls",wc,ws);
	/* c and s take multibyte as input and produce UNICODE   */
	/* In this case c1 and s1 are CCSID 37 characters based  */
	/* on the setlocale above.  So the characters are        */
	/* converted from CCSID 37 to UNICODE and will look      */
	/* like this in hex after the following fwprintf         */
	/* statement:   0063002000200020003100320033             */
	/* 0063 is a UNICODE c  0031 is a UNICODE 1 and so on    */

	fwprintf(stream, L"%c %s",c1,s1);

	/* Now lets try width and precision.  6ls means write  */
	/* 6 wide characters so we will pad with 3 UNICODE     */
	/* blanks and %.2s means write no more then 2 wide     */
	/* characters. So we get an output that looks like     */
	/* this:  00200020002000410042004300310032             */

	fwprintf(stream, L"%6ls%.2s",ws,s1);
}
 

Related Information
	fprintf() — Write Formatted Data to a Stream
	printf() — Print Formatted Characters
	vfprintf() — Print Argument Data to Stream
	vprintf() — Print Argument Data
	btowc() — Convert Single Byte to Wide Character
	mbrtowc() — Convert a Multibyte Character to a Wide Character (Restartable)
	vfwprintf() — Format Argument Data as Wide Characters and Write to a Stream
	vswprintf() — Format and Write Wide Characters to Buffer
	wprintf() — Format Data as Wide Characters and Print
	<stdarg.h>
	<wchar.h>



---
https://www.ibm.com/docs/en/i/7.3?topic=functions-wctomb-convert-wide-character-multibyte-character

wctomb() — Convert Wide Character to Multibyte Character
2021-04-14

Format
#include <stdlib.h>
int wctomb(char *string, wchar_t character);

Language Level
ANSI

Threadsafe
No
Use wcrtomb() instead.

Locale Sensitive
The behavior of this function might be affected by the LC_CTYPE category of the current locale. The behavior
might also be affected by the LC_UNI_CTYPE category of the current locale if LOCALETYPE(*LOCALEUCS2) or
LOCALETYPE(*LOCALEUTF) is specified on the compilation command. For more information, see Understanding
CCSIDs and Locales.

Wide Character Function
See Wide Characters for more information.

Description
The wctomb() function converts the wchar_t value of character into a multibyte array pointed to by string.
If the value of character is 0, the function is left in the initial shift state. At most, the wctomb()
function stores MB_CUR_MAX characters in string.

The conversion of the wide character is the same as described in wcstombs(). See this function for a Unicode
example.

Return Value
The wctomb() function returns the length in bytes of the multibyte character. The value -1 is returned if
character is not a valid multibyte character. If string is a NULL pointer, the wctomb() function returns
nonzero if shift-dependent encoding is used, or 0 otherwise.

If a conversion error occurs, errno may be set to ECONVERT.

Example
This example converts the wide character c to a multibyte character.

#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
 
#define SIZE 40
 
int main(void) {
	static char  buffer[ SIZE ];
	wchar_t wch = L'c';
	int length;
	
	length = wctomb( buffer, wch );
	printf( "The number of bytes that comprise the multibyte "
				"character is %i\n", length );
	printf( "And the converted string is \"%s\"\n", buffer );
}
 
/****************  Output should be similar to:  ******************
 
The number of bytes that comprise the multibyte character is 1
And the converted string is "c"
*/

Related Information

	mbtowc() — Convert Multibyte Character to a Wide Character
	wcslen() — Calculate Length of Wide-Character String
	wcrtomb() — Convert a Wide Character to a Multibyte Character (Restartable)
	wcstombs() — Convert Wide-Character String to Multibyte String
	wcsrtombs() — Convert Wide Character String to Multibyte String (Restartable)
	<stdlib.h>



---
https://www.gnu.org/software/libc/manual/html_node/Converting-Strings.html

6.3.4 Converting Multibyte and Wide Character Strings

   The functions described in the previous section only convert a single character at a time.
   Most operations to be performed in real-world programs include strings and therefore the
   ISO C standard also defines conversions on entire strings. However, the defined set of
   functions is quite limited; therefore, the GNU C Library contains a few extensions that can
   help in some important situations.

   Function: size_t mbsrtowcs (wchar_t *restrict dst, const char **restrict src, size_t len,
		  mbstate_t *restrict ps)
		  Preliminary: | MT-Unsafe race:mbsrtowcs/!ps | AS-Unsafe corrupt heap lock dlopen |
		  AC-Unsafe corrupt lock mem fd | See POSIX Safety Concepts.

		  The mbsrtowcs function ("multibyte string restartable to wide character string")
		  converts the NUL-terminated multibyte character string at *src into an equivalent
		  wide character string, including the NUL wide character at the end. The conversion
		  is started using the state information from the object pointed to by ps or from an
		  internal object of mbsrtowcs if ps is a null pointer. Before returning, the state
		  object is updated to match the state after the last converted character. The state
		  is the initial state if the terminating NUL byte is reached and converted.

		  If dst is not a null pointer, the result is stored in the array pointed to by dst;
		  otherwise, the conversion result is not available since it is stored in an internal
		  buffer.

		  If len wide characters are stored in the array dst before reaching the end of the
		  input string, the conversion stops and len is returned. If dst is a null pointer,
		  len is never checked.

		  Another reason for a premature return from the function call is if the input string
		  contains an invalid multibyte sequence. In this case the global variable errno is
		  set to EILSEQ and the function returns (size_t) -1.

		  In all other cases the function returns the number of wide characters converted
		  during this call. If dst is not null, mbsrtowcs stores in the pointer pointed to by
		  src either a null pointer (if the NUL byte in the input string was reached) or the
		  address of the byte following the last converted multibyte character.

		  Like mbstowcs the dst parameter may be a null pointer and the function can be used
		  to count the number of wide characters that would be required.

		  mbsrtowcs was introduced in Amendment 1 to ISO C90 and is declared in wchar.h.

   The definition of the mbsrtowcs function has one important limitation. The requirement that
   dst has to be a NUL-terminated string provides problems if one wants to convert buffers
   with text. A buffer is not normally a collection of NUL-terminated strings but instead a
   continuous collection of lines, separated by newline characters. Now assume that a function
   to convert one line from a buffer is needed. Since the line is not NUL-terminated, the
   source pointer cannot directly point into the unmodified text buffer. This means, either
   one inserts the NUL byte at the appropriate place for the time of the mbsrtowcs function
   call (which is not doable for a read-only buffer or in a multi-threaded application) or one
   copies the line in an extra buffer where it can be terminated by a NUL byte. Note that it
   is not in general possible to limit the number of characters to convert by setting the
   parameter len to any specific value. Since it is not known how many bytes each multibyte
   character sequence is in length, one can only guess.

   There is still a problem with the method of NUL-terminating a line right after the newline
   character, which could lead to very strange results. As said in the description of the
   mbsrtowcs function above, the conversion state is guaranteed to be in the initial shift
   state after processing the NUL byte at the end of the input string. But this NUL byte is
   not really part of the text (i.e., the conversion state after the newline in the original
   text could be something different than the initial shift state and therefore the first
   character of the next line is encoded using this state). But the state in question is never
   accessible to the user since the conversion stops after the NUL byte (which resets the
   state). Most stateful character sets in use today require that the shift state after a
   newline be the initial state–but this is not a strict guarantee. Therefore, simply
   NUL-terminating a piece of a running text is not always an adequate solution and,
   therefore, should never be used in generally used code.

   The generic conversion interface (see Generic Charset Conversion) does not have this
   limitation (it simply works on buffers, not strings), and the GNU C Library contains a set
   of functions that take additional parameters specifying the maximal number of bytes that
   are consumed from the input string. This way the problem of mbsrtowcs's example above could
   be solved by determining the line length and passing this length to the function.

   Function: size_t wcsrtombs (char *restrict dst, const wchar_t **restrict src, size_t len,
		  mbstate_t *restrict ps)
		  Preliminary: | MT-Unsafe race:wcsrtombs/!ps | AS-Unsafe corrupt heap lock dlopen |
		  AC-Unsafe corrupt lock mem fd | See POSIX Safety Concepts.

		  The wcsrtombs function ("wide character string restartable to multibyte string")
		  converts the NUL-terminated wide character string at *src into an equivalent
		  multibyte character string and stores the result in the array pointed to by dst. The
		  NUL wide character is also converted. The conversion starts in the state described
		  in the object pointed to by ps or by a state object local to wcsrtombs in case ps is
		  a null pointer. If dst is a null pointer, the conversion is performed as usual but
		  the result is not available. If all characters of the input string were successfully
		  converted and if dst is not a null pointer, the pointer pointed to by src gets
		  assigned a null pointer.

		  If one of the wide characters in the input string has no valid multibyte character
		  equivalent, the conversion stops early, sets the global variable errno to EILSEQ,
		  and returns (size_t) -1.

		  Another reason for a premature stop is if dst is not a null pointer and the next
		  converted character would require more than len bytes in total to the array dst. In
		  this case (and if dst is not a null pointer) the pointer pointed to by src is
		  assigned a value pointing to the wide character right after the last one
		  successfully converted.

		  Except in the case of an encoding error the return value of the wcsrtombs function
		  is the number of bytes in all the multibyte character sequences which were or would
		  have been (if dst was not a null) stored in dst. Before returning, the state in the
		  object pointed to by ps (or the internal object in case ps is a null pointer) is
		  updated to reflect the state after the last conversion. The state is the initial
		  shift state in case the terminating NUL wide character was converted.

		  The wcsrtombs function was introduced in Amendment 1 to ISO C90 and is declared in
		  wchar.h.

   The restriction mentioned above for the mbsrtowcs function applies here also. There is no
   possibility of directly controlling the number of input characters. One has to place the
   NUL wide character at the correct place or control the consumed input indirectly via the
   available output array size (the len parameter).

   Function: size_t mbsnrtowcs (wchar_t *restrict dst, const char **restrict src, size_t nmc,
		  size_t len, mbstate_t *restrict ps)
		  Preliminary: | MT-Unsafe race:mbsnrtowcs/!ps | AS-Unsafe corrupt heap lock dlopen |
		  AC-Unsafe corrupt lock mem fd | See POSIX Safety Concepts.

		  The mbsnrtowcs function is very similar to the mbsrtowcs function. All the
		  parameters are the same except for nmc, which is new. The return value is the same
		  as for mbsrtowcs.

		  This new parameter specifies how many bytes at most can be used from the multibyte
		  character string. In other words, the multibyte character string *src need not be
		  NUL-terminated. But if a NUL byte is found within the nmc first bytes of the string,
		  the conversion stops there.

		  Like mbstowcs the dst parameter may be a null pointer and the function can be used
		  to count the number of wide characters that would be required.

		  This function is a GNU extension. It is meant to work around the problems mentioned
		  above. Now it is possible to convert a buffer with multibyte character text piece by
		  piece without having to care about inserting NUL bytes and the effect of NUL bytes
		  on the conversion state.

   A function to convert a multibyte string into a wide character string and display it could
   be written like this (this is not a really useful example):

void showmbs (const char *src, FILE *fp) {
	mbstate_t state;
	int cnt = 0;
	memset (&state, '\0', sizeof (state));

	while (1) {
		wchar_t linebuf[100];
		const char *endp = strchr (src, '\n');
		size_t n;

		/* Exit if there is no more line.  */
		if (endp == NULL)
			break;

		n = mbsnrtowcs (linebuf, &src, endp - src, 99, &state);
		linebuf[n] = L'\0';
		fprintf (fp, "line %d: \"%S\"\n", linebuf);
	}
}

   There is no problem with the state after a call to mbsnrtowcs. Since we don't insert
   characters in the strings that were not in there right from the beginning and we use state
   only for the conversion of the given buffer, there is no problem with altering the state.

   Function: size_t wcsnrtombs (char *restrict dst, const wchar_t **restrict src, size_t nwc,
		  size_t len, mbstate_t *restrict ps)
		  Preliminary: | MT-Unsafe race:wcsnrtombs/!ps | AS-Unsafe corrupt heap lock dlopen |
		  AC-Unsafe corrupt lock mem fd | See POSIX Safety Concepts.

		  The wcsnrtombs function implements the conversion from wide character strings to
		  multibyte character strings. It is similar to wcsrtombs but, just like mbsnrtowcs,
		  it takes an extra parameter, which specifies the length of the input string.

		  No more than nwc wide characters from the input string *src are converted. If the
		  input string contains a NUL wide character in the first nwc characters, the
		  conversion stops at this place.

		  The wcsnrtombs function is a GNU extension and just like mbsnrtowcs helps in
		  situations where no NUL-terminated input strings are available.


---
https://en.wikibooks.org/wiki/C_Programming/wchar.h

C Programming/wchar.h

   wchar.h is a header file in the C standard library. It is a part of the extension to the
   C programming language standard done in 1995. It contains extended multibyte and wide
   character utilities. The standard header <wchar.h> is included to perform input and output
   operations on wide streams. It can also be used to manipulate the wide strings.

Wide Characters
   C is a programming language that was developed in an environment where the dominant
   character set was the 7-bit ASCII code. Hence since then the 8-bit byte is the most common
   unit of encoding. However when a software is developed for an international purpose, it has
   to be able to represent different characters. For example character encoding schemes to
   represent the Indian, Chinese, Japanese writing systems should be available. The
   inconvenience of handling such varied multibyte characters can be eliminated by using
   characters that are simply a uniform number of bytes. ANSI C provides a type that allows
   manipulation of variable width characters as uniform sized data objects called wide
   characters. The wide character set is a superset of already existing character sets,
   including the 7-bit ASCII.

Declarations and Definitions

Macros
   The standard header wchar.h contains the definitions or declarations of some constants.

		  NULL
		  It is a null pointer constant. It never points to a real object.

		  WCHAR_MIN
		  It indicates the lower limit or the minimum value for the type wchar_t.

		  WCHAR_MAX
		  It indicates the upper limit or the maximum value for the type wchar_t.

		  WEOF
		  It defines the return value of the type wint_t but the value does not correspond to
		  any member of the extended character set. WEOF indicates the end of a character
		  stream, the end of file (EOF) or an error case.

Data Types
		  mbstate_t
		  A variable of type mbstate_t contains all the information about the conversion state
		  required from one call to a function to the other.

		  size_t
		  It is a size/count type, that stores the result or the returned value of the sizeof
		  operator.

		  wchar_t
		  An object of type wchar_t can hold a wide character. It is also required for
		  declaring or referencing wide characters and wide strings.

		  wint_t
		  This type is an integer type that can hold any value corresponding to the members of
		  the extended character set. It can hold all values of the type wchar_t as well as
		  the value of the macro WEOF. This type is unchanged by integral promotions.


Functions

Wide-character string functions
   ----------------------------------------------------------------------------------------------------------
   Name                                                       Notes
   ----------------------------------------------------------------------------------------------------------
   wchar_t *wcscat(wchar_t *s1, const wchar_t *s2);           copies wide string that s2 points to, to
                                                              the end of the wide string hat s1 points to.
   ----------------------------------------------------------------------------------------------------------
   wchar_t *wcschr(const wchar_t *s, wchar_t c);              searches the wide string s for the wide
                                                              character c.
   ----------------------------------------------------------------------------------------------------------
   int wcscmp(const wchar_t *s1, const wchar_t *s2);          compares two wide strings that s1 and s2
                                                              point to.
   ----------------------------------------------------------------------------------------------------------
   int wcscoll(const wchar_t *s1, const wchar_t *s2);         compares two wide strings s1 and s2
                                                              using current locale's collating order.
   ----------------------------------------------------------------------------------------------------------
   wchar_t *wcscpy(wchar_t *s1, const wchar_t s2);            copies the wide string that s2 points to ,
                                                              to the location that s1 points to.
   ----------------------------------------------------------------------------------------------------------
   size_t wcscspn(const wchar_t *s1, const wchar_t *s2);      searches for the very first element
                                                              of s1 that equals any one of the elements of s2.
   ----------------------------------------------------------------------------------------------------------
   size_t wcslen(const wchar_t *s);                           returns the number of wide characters(excluding
                                                              the terminating null wide character) in the wide
                                                              string that s points to.
   ----------------------------------------------------------------------------------------------------------

Wide-character array functions
   ----------------------------------------------------------------------------------------------------------
   Name                                                         Notes
   ----------------------------------------------------------------------------------------------------------
   wchar_t *wmemchr(const wchar_t *s, wchar_t c, size_t n);     searches for the first element of the array of
                                                                size n and that s points to, that equals c.
   ----------------------------------------------------------------------------------------------------------
   int wmemcmp(const wchar_t *s1, const wchar_t *s2, size_t n); compares the successive elements from two
                                                                arrays that s1 and s2 point to, until it finds
                                                                elements that are not equal.
   ----------------------------------------------------------------------------------------------------------
   wchar_t *wmemcpy(wchar_t *s1, const wchar_t *s2, size_t n);  copies n wide characters from the array
                                                                pointed to by s2 to the wide characters in an
                                                                array pointed to by s1. If objects in s1 and s2
                                                                overlap, the behavior is undefined.
   ----------------------------------------------------------------------------------------------------------
   wchar *wmemmove(wchar_t *s1, const wchar_t *s2, size_t n);   works like wmemcpy function even if objects in
                                                                arrays s1 and s2 overlap.
   ----------------------------------------------------------------------------------------------------------
   wchar_t *wmemset(wchar_t *s, wchar_t c, size_t n)            sets the first n elements of the array that s
                                                                points to, to the wide character c.
   ----------------------------------------------------------------------------------------------------------
   

Conversion Functions
   ----------------------------------------------------------------------------------------------------------
   Name                                         Notes
   ----------------------------------------------------------------------------------------------------------
   wint_t btowc(int c);                         returns the result after converting c into its wide character
                                                equivalent and on error returns WEOF.
   ----------------------------------------------------------------------------------------------------------
   int wctob(wint_t c);                         returns the one byte or multibyte equivalent of c and on error
                                                returns WEOF.
   ----------------------------------------------------------------------------------------------------------

Wide-Character I/O Functions
   ----------------------------------------------------------------------------------------------------------
   Name                                                         Notes
   ----------------------------------------------------------------------------------------------------------
   wint_t fgetwc(FILE *stream);                                 reads a wide character from a file.
   ----------------------------------------------------------------------------------------------------------
   wchar_t *fgetws(wchar_t *s, int n, FILE *stream);            reads a wide character string from a file.
   ----------------------------------------------------------------------------------------------------------
   wint_t fputwc(wchar_t *c, FILE *stream);                     writes a wide character to a file.
   ----------------------------------------------------------------------------------------------------------
   int fputws(const wchar_t *s, FILE *stream);                  writes a wide string to a file.
   ----------------------------------------------------------------------------------------------------------
   int fwprintf(FILE *stream, const wchar_t format,...);        first generates a formatted text and then
                                                                writes it to the file.
   ----------------------------------------------------------------------------------------------------------
   int fwscanf(FILE *stream, const wchar_t format,...);         reads formatted text from a file.
   ----------------------------------------------------------------------------------------------------------
   wint_t getwc(FILE*stream);                                   reads a wide character from a file.
   ----------------------------------------------------------------------------------------------------------
   wint_t getwchar()                                            reads a wide character from stdin.
   ----------------------------------------------------------------------------------------------------------
   wint_t putwc(wchar_t c, FILE *stream);                       writes a wide character to a file.
   ----------------------------------------------------------------------------------------------------------
   wint_t putwchar(wchar_t c);                                  writes a wide character to stdout.
   ----------------------------------------------------------------------------------------------------------


---

