filename: c-example-of-array-of-struct-pointers-5pp-20260121.txt
https://www.quora.com/Can-someone-give-an-example-of-an-array-of-struct-pointers-in-C

Can someone give an example of an array of struct pointers in C?

***
The best is to do this step by step. First define a new structure

struct abc {
	int field1;
	int field2;
};

Then, a pointer to this structure
typedef struct abc *abc_pointer;

and finally, an array of such pointers
abc_pointer my_array[100];

You can also do all in one statement, but it is less readable
struct { int field1; int field2 } *my_array[100];

***
Sure. Neat thing is, the structure type doesn't even need to be a complete type.

// Forward declaration of incomplete type:
struct ure;

// An array of 10 pointers to struct ure.
struct ure *array[10];

***
The First advantage of storing struct pointers instead of structs themselves in only that the array can be
made before the structs are and contain null pointers.

It is like you have to buy a box of envelopes with nothing in them before writing and sending a bunch of
letters. Except that you only need to put the address of the letter in the envelope ..
(analogies break down ..)

C and C++ can generate pointers all day long. An array of them is the same size as an array of any other
pointers which is 8 bytes each.

A struct in C and in C++ have the same data region. They are compatible. C++ has associated class functions
for structs, but the data portion is the same format as C structs which are passive contiguous structures.

The second advantage to storing struct pointers in an array instead of the structs themselves is moving them
around without copying, which may be complicated and/or expensive to do in bulk. Sorting strucks, for
instance, or swapping them between arrays is much faster and somewhat simpler to do by pointer, and often is
much faster due to CPU caching and storing addresses in registers.

The third advantage is that you may have no idea the max and min number of structs that will be needed, so you
create them on the fly with malloc (C) or new (C++). A pointer array gives you flexibility in size, as you may
extend the size of the pointer array if you are going to run out, or leave the remaining slots as null
pointers if you have a lot of extra.

It helps to create functions that internalize the nuts and bolts of array management and gets it correct every
time.

/* C */
struct X; // defined somewhere or just declared externally.

/* C must have the struct keyword
   or typedef the struct as a type.
   so either  */
struct X *array[100]; // 100 pointers */

// or

typedef struct X;
typedef X *X_t;  // pointer type X_t is  X*
                 // but no confusion with asterisk

X_t array[100];

// or dynamically
X_t *array = (X_t *)malloc(100 * sizeof(X_t));

/* you only have pointers, not storage for structs */
X_t Xp = calloc(100, sizeof(X));  // actual structs

// connect them up
size_t i = 0; // size_t compatible with pointer arithmetic

while(i < 100) {
	array[i] = (Xp + i);  // copy pointers into array
	i++;
}

Now you have each structs address in each slot of array.  Why do it that way?  Because you have only 2
allocations to free later.

free(Xp);    // frees all structs
free(array); // frees pointer array

Put that mess in a function and call it good.

X_t *make_array(size_t n) {
	X_t *array = (X_t *)calloc(n, sizeof(X_t));
	X_t Xp = calloc(n, sizeof(X));
	size_t i = 0; // size_t compatible with pointer arithmetic

	while(i < 100) {
		array[i] = (Xp + i);  // copy pointers into array
		i++;
	}
	return array;
}

void delete_array(X_t *array) {
	free(array[0]);
	free(array);
}

Of course if you don't use dynamic allocation you don't have to go to all that.

typedef struct X;
typedef X *X_t;  // pointer type X_t is  X*
                  // but no confusion with asterisk

X_t  array[100];
X Xarr[100];

for (int i = 0; i <100' i++)
    array[i] = Xarr + i;

X xx =  *(array[22]);  // copies X out of array


// swapping pointers is easy
static inline void swapX_t(X_t const a,  X_t const  b) {
  X_t tmp = *a;
  *a = *b;
  *b = tmp;
}


// sorting is easy as well
// VAL is whatever type you sort structs with.

void X_selection_sort(X_t *arr, size_t n) {
	size_t i, j;
	for (i = 0; i < n; i++) {
		int min = i;

		for (j=i+1; j<n; j++) {
			VAL x =  *arr[j].val;
			VAL y =  *arr[min].val;
			if (x < y)  min = j;
		}

		if(min != i) {
			swapX_t(arr[i], arr[min]);
		}
	}
}

If you run out of space in the array for new structs, you either delete some (by overwriting them), or extend
the array of pointers.

X_t *extend_array(X_t array[], size_t oldsz, size_t newsz) {

	X_t *tmp = (X_t *) realloc(newsz , sizeof(X_t));

	if(tmp == NULL) // failure
	{
		fprintf(stderr, "ERROR resize to %d failed\n", newsz);
		exit(-1);
	}
	X_t xp = array[0];
	X_t xtmp = (X_t) realloc(newsz * sizeof(X));

	if (xtmp == NULL) {
		fprintf(stderr, "ERROR resize to %d failed\n", newsz);
		exit(-1);
	}

	size_t added = newsz - oldsize;
	while(added < newsz) {
		memset(xp, 0, sizeof(X));
		array[added-1] = xp;
		added++;
		xp++;
	}

	return array;
}

Why do it this way? Because you still only have the pointer array and the X struct array to free.

X_t *array = make_array(100);
/*
...
*/

array = extend_array(array, 100, 1000);
/*
...
*/

free (array[0]);
free (array);

It helps to screw up royally a few times to understand how it should work.  Later on you will find it helpfull
to write really good documentary comments to see what you were on about at the time.

C++ dispenses with most all of that.

struct X;
using X_t = X*;

X_t  xp_array = new X_t(100);  // 100 X pointers
X    x_array = new X(100);     // 100 X structs

for (auto i = 0; i < 100; i++) {
	xp_array[i] = x_array + i; // pointer assignment.
}

// ...

 delete[] x_array;
 delete[] xp_array;

// use STL
std::array<X_t, 100> X_array; // 100 pointers
for (X_t xt : X_array) xt = new X; // 100 allocations
// ...

for (X_t xt : X_array) delete xt;
delete[] X_array;

// vector
std::vector<X_t> X_vector(100);  // start with 100
for (X_t xt : Xvector) {
	xt = new X;
}

Xvector.resize(1000);

for (auto i = 100; i<1000; i++) {
	Xvector[i] = new X;
}

for (X_t xt : Xvector)  delete xt;

// Xvector deletes all its pointers automatically.

***
Below is a compact, practical example showing how to declare, allocate, initialize, and use an array of
pointers to structs in C, with cleanup. It demonstrates both static and dynamic allocation patterns and common
operations (access, iterate, free).

Code example (C99):

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Define a struct */
typedef struct Person {
	char *name;
	int age;
} Person;

/* Helper to create a Person (allocates both struct and name) */
Person *person_create(const char *name, int age) {
	Person *p = malloc(sizeof *p);
	if (!p) return NULL;
	p->name = malloc(strlen(name) + 1);
	if (!p->name) { free(p); return NULL; }
	strcpy(p->name, name);
	p->age = age;
	return p;
}

/* Helper to destroy a Person */
void person_destroy(Person *p) {
	if (!p) return;
	free(p->name);
	free(p);
}

int main(void) {
	/* ---- Option A: Static array of pointers (fixed size) ---- */
	Person *arr_static[3];        /* array that holds 3 Person * */
	arr_static[0] = person_create("Alice", 30);
	arr_static[1] = person_create("Bob", 25);
	arr_static[2] = person_create("Carol", 28);

	for (size_t i = 0; i < 3; ++i) {
		printf("static[%zu]: %s, %d\n", i, arr_static[i]->name, arr_static[i]->age);
		person_destroy(arr_static[i]);
	}

	/* ---- Option B: Dynamic array of pointers (resizable) ---- */
	size_t capacity = 2;
	size_t count = 0;
	Person **arr = malloc(capacity * sizeof *arr); /* Person** */
	if (!arr) return 1;

	/* push helper (simple reallocation growth) */
	Person *p;
	p = person_create("Dave", 40);
	if (count == capacity) {
		capacity *= 2;
		arr = realloc(arr, capacity * sizeof *arr);
		if (!arr) return 1;
	}
	arr[count++] = p;

	p = person_create("Eve", 35);
	if (count == capacity) {
		capacity *= 2;
		arr = realloc(arr, capacity * sizeof *arr);
		if (!arr) return 1;
	}
	arr[count++] = p;

	for (size_t i = 0; i < count; ++i) {
		printf("dynamic[%zu]: %s, %d\n", i, arr[i]->name, arr[i]->age);
		person_destroy(arr[i]);
	}

	free(arr);
	return 0;
}

Key points:
 - Declaration: Person *arr[3]; creates an array of 3 pointers to Person (no Person instances allocated yet).
 - Dynamic array: Person *arr = malloc(n * sizeof arr); allocates storage for pointers (not the structs
   themselves).
 - Each pointer must point to a valid Person (stack object, malloc, or string literal) before dereferencing.
 - Free both the pointed-to structs and any internal heap allocations, then free the pointer array when
   dynamically allocated.
 - Use realloc to resize a dynamic array of pointers; remember to check realloc's result.

***
I prefer to define it with typedef so i write less.

typedef struct_typ {
	... the definition of the struct here
} struct_obj, *struct_ptr;

struct_ptr myStructArrayOfPointers[arraySize];

where clearly you just replace "struct" by the struct name everywhere but as you can see the struct_ptr
encapsulates its already a pointer to struct_typ (which is best to not have to retype it all over again). can
also be place as

struct_obj *myStructArrayOfPointers[arraySize]; // (but its kind of more confusing in my opinion)

***
"Struct" not surprisingly is short for "structure".

A struct is a collection of one or more types that are aggregated and become a new type of their own.

struct _node {
	size_t length;
	char str[1024];
	_node *next;
} Node;

So above is a declaration of a struct that breaks down to:

the struct keyword followed by an optional
 - forwardly declared type name.
 - An opening brace
 - an unsigned integer (4 bytes)
 - a character array (1024 bytes)
 - a pointer to another struct of the same type. (It uses the struct _node forward definition of itself,
   because the struct is not fully defined yet until the final semicolon is read). A quirky C idiom. (8 bytes)
 - A closing brace
 - A type name for the struct.
 - A semicolon telling the parser to generate a struct template and call it "struct Node".

So now a struct Node can be created, populated with data, destroyed, sent around, etc. The above is a basic
singly-linked list node that could hold a string of up to 1024 bytes. The struct takes up most likely 1036
bytes (structs are aligned on 16 byte boundaries so there is likely an extra 4 bytes between a struct Node
and another data variable in memory, but that is internal and not usually worried about for normal coding.)

To create a struct Node, you can do so either statically or dynamically.

/* [static allocation] */
size_t i = 0;   // counting var
struct Node N;  /* creates - does not initialize a struct Node */

/* initialize a struct
 A static structure members are accessed with period(.) */
N.length = 0;
for (i = 0 ; i < 1024; i++) N.str[i] = '\0';
N.next = (struct Node*)NULL;

/* N will be copied if sent into a function by value */

/* [Dynamic allocation] */
/* A pointer to a struct needs  an arrow (->)
   to access its members */
struct Node *N = (struct Node *) malloc(sizeof(struct Node));
memset(N, '\0', sizeof(struct Node)); // clear memory

strncpy(N->str, "abcdefghij", 11);
N->length = 11;  /* must count '\0' at end of string */

/* N will NOT be copied if sent into a function by reference. */
free(N); /* dynamic memory must be freed explicitly */

So that is one struct, not much use by itself. But it provides by its structure a means to link Nodes together
into a singly-linked list.

For brevity's sake, you can use the typedef keyword to elevate the word Node to a full-blown type, primarily
so you don't need to use the struct keyword all the time, but also so you can alias the word "LList" to a
struct Node Pointer.

typedef struct _node {
	size_t length;
	char str[1024];
	_node *next;
} Node, *LList;

/* now Node is a type, and LList is a Node *  */

Now we can do things with our structure.

LList make_LList(size_t length) {
	if (length < 1) return NULL; /* sanity check */

	size_t node_size = sizeof(Node); // 1036
	size_t i = 0;

	/* make an initial Node */
	LList l = calloc(1, node_size); // makes all 0 data
	Node *tmp = l;

	for(i = 1; i < length; i++) {
		Node *newnode = calloc(1, node_size);  /* new Node */
		tmp->next = newnode; /* attach to next pointer */
		tmp = tmp=->next;    /* advance tmp pointer */
	}

	tmp->next = (Node *) NULL; /* end of LList */
	return l;
}

/* recover memory
   (check my logic please! This is easy to mess up.)
   Note since the string is copied into the array
   it gets recovered when the struct is freed. That
   is why it is not just a char*. It could be but
   then you need to worry about freeing the string or
   not if it was not a dynamically allocated string.
   So we take the time and space to copy it into a
   huge buffer in the struct, just in case. In reality
   about 55% of strings in programs are static & read-only,
   Another 30% are "immediate strings" that are stored
   in a part of memory that is read-only.  So in any given
   program only about 15% are editable strings, mostly user
   input.
*/
void delete_LList(LList l) {
	Node *last = l;
	Node *tmp;
	while(last->next) {
		tmp = last;
		last = last->next;
		free(tmp);
	}
}

/* try insert into the first empty spot.
   return 1 for success, 0 for failure. */
int insert(LList list, char *str) {
	Node *m = list;
	size_t n;
	if(str == (char *)NULL) return 0;
	n = strlen(str) + 1;

	while(m->next) {
		if(m->length == 0) {
			strncpy(m->str, str, n);
			m->length = n;
			return 1;
		}
		m = m->next;
	}
	return 0;
}


/* traverse list and print */
void print_LList(LList list) {
	Node *n = list;
	while(n->next) {
		printf("%s\n" , n->str);
	}
}

/* put it all together */
int main(int argc, char** argv) {
	LList myList = make_LList(10);
	Node *m = myList;

	char *stringzing = "A string is a thing that goes zing.";
	char *parrots    = "Parrots got carrots where tots fought bots.";
	char *sheiks     = "Sheiks streak freak week;";
	char *fleek      = "they are on fleek, dancing cheek to cheek.";

	if (insert(myList, stringzing))  m = m->next;
	if (insert(myList, parrots)   )  m = m->next;
	if (insert(myList, sheiks)    )  m = m->next;
	if (insert(myList, fleek)     )  m = m->next;

	print_LList(myList);
	delete(myList);

	return 0;
}

OUTPUT:
    A string is a thing that goes zing.
    Parrots got carrots where tots fought bots.
    Sheiks streak freak week;
    they are on fleek, dancing cheek to cheek.

***
If you use C, I believe it is not bad at all try and understand a bit how a computer works, and notably it's
memory.

The RAM memory of a computer, at least as seen from the C program in most cases, is a huge array of bytes.
Whatever part of memory you need is a contiguous block of memory bytes.

A variable of yours is a struct? It will occupy in most if not all cases a continuous number of bytes in this
big array we call RAM. You malloc'ate an array of structs? Then a chunck of contiuous bytes of this array
called RAM will contain all the elements.

In most computer architectures that run C programs, RAM is a huge array of bytes. In some architectures you
cannot address a single byte, but normally the logic of RAM is: a huge array of bytes.

You already know what an array is, isn't it? It is a sequence of homogeneous elements (all char's, all int's
all structs) that you can access (read or write its content) using an index.

In the case of RAM this index is called 'address'.

So imagine the following snippet.
int var;

int main(int argc, char *argv[]) {
	int *pi = &var;
}

What happens here? We have a variable called var. We are using a 32 bit computer so this variable will occupy
4 contiguous bytes starting from a specific address that in this case is decided by the linker at compile
time.

Look now at the local variable pi inside the function main. It is a pointer to an int and it is initialized
with ampersand var. Ampersand is an operator that returns the address in memory of the following variable, in
this case the variable called var.

So?

Evident: a pointer contains a value that directly is or is connected to the address of a contiguous chunk of
memory.

You could say: so a pointer is just an index. Why not an integer? Indexes are Integers in arrays.

Well because the pointer in many current architectures is an integer variable, but there were times when
things were a bit more complicated in the PC world. When the mainstream OS was DOS (eighties and early
nineties) a programmer could choose, depending on some compiler switches, one out of four memory models. The
small memory model had only 64K (not mega, sixtyfourkilobytes of contiguous memory cells) and the pointer was
exaclty a 16 bit integer value that represented indirectly the address inside the data segments.

With different compiler switches you could use the so called Huge memory model that was able to address a full
megabytes (In most computers only 640K though) of memory (WOW) but used a strange way to map the segment
registers and the data pointer to extend the address range. In that case a pointer was represented by two 16
bit registers manipulated in a (poor and slow) way to reach a full megabytes instead of 64K only.

So in a nutshell, a C pointer is some form of (abstract) representation of the address of a block of memory
cells.

OK, pointers are addresses in memory right? So if you increment a pointer, it just goes to the following
address, so it goes to the following byte right?

Wrong.

Pointers are a bit more than addresses. In C you do not only say: this variable is a pointer. You say this
variable is a pointer to int's, doubles, another pointer so what?

Consider this snippet.

struct  furniture {
	int len;
	int width;
	double weight;
}

struct furniture cupboard;
struct furniture *pcupboard = &cupboard;

Somewhere, for instant at address 0x8C001230, in my RAM the memory area composed by 24 contiguous bytes
contains the size and weight of my cupboard, pcupboard points to it.

What can now be the meaning of pcupboard++ ?

Can it be 0x8C001231? If we did this, and there is a way to make C work this way, the incremented pointer will
be something inside the integer representing the lenght of my cupboard. Meaningless. If you increment a
pointer, the address it refers to will be incremented of a number of bytes equalling the size of the variable
pointed to. So, the incremented pointer will point to the first free memory byte after our cupboard.

Does it make sense?

In this case no. After the variable cupboard there is nothing, so incrementing this variable makes no sense in
this case. But if the variable cupboard was an array of furniture, it would make sense: it would point to the
following element in the array.

This is why pointers are dangerous in C. Pointers refer to RAM memory but they know nothing or almost nothing
about the validity of the Ram they point to. If they point to valid address, then OK, otherwise..
Segmentation Fault.


*** (5+)
In computer programming, an array of pointers is an indexed set of variables in which the variables are
pointers (a reference to a location in memory).

Pointers are an important tool in computer science for creating, using and destroying all types of data
structures. An array of pointers is useful for the same reason that all arrays are useful: it allows you to
numerically index a large set of variables.

Below is an array of pointers in C that sets each pointer in one array to point to an integer in another and
then print the values of the integers by dereferencing the pointers. In other words, this code prints the
value in the memory of where the pointers point.

#include <stdio.h>

const int ARRAY_SIZE = 5;

int main () {
	/* first, declare and set an array of five integers:    */
	int array_of_integers[] = {5, 10, 20, 40, 80};

	/* next, declare an array of five pointers-to-integers: */
	int i, *array_of_pointers[ARRAY_SIZE];

	for (i = 0; i < ARRAY_SIZE; i++) {
		/* for indices 1 through 5, set a pointer to
		point to a corresponding integer:                 */
		array_of_pointers[i] = &array_of_integers[i];
	}

	for (i = 0; i < ARRAY_SIZE; i++) {
		/* print the values of the integers pointed to
		by the pointers:                                  */
		printf("array_of_integers[%d] = %d\n", i, *array_of_pointers[i]);
	}

	return 0;
}


***
Well, I use those to provide controlled userspace access to model-specific registers.

struct msr_batch_op {
	__u16 cpu; // In: CPU to execute {rd/wr}msr instruction
	__u16 isrdmsr; // In: 0=wrmsr, non-zero=rdmsr
	__s32 err; // Out: set if error occurred with this operation
	__u32 msr; // In: MSR Address to perform operation
	__u64 msrdata; // In/Out: Input/Result to/from operation
	__u64 wmask; // Out: Write mask applied to wrmsr
};

struct msr_batch_array {
	__u32 numops; // In: # of operations in operations array
	struct msr_batch_op *ops; // In: Array[numops] of operations
};

Each individual operation on a model-specific register is described in a struct msr_batch_op. We amortize the
overhead of getting in and out of the kernel by batching up operations, the array (and count) of which is
contained in msr_batch_array.


***
A struct is a set of one or more typed fields defined in struct definition. I normally also make the struct a
type by defining it in a typedef construct

typedef struct _SpaceShip {
	UWORD Id;
	UWORD Energy;
	FP X;
	FP Y;
} SPACE_SHIP;

I could now assign a pointer of type SPACE_SHIP * or create an array of type SPACE_SHIP if I wanted loads if
them. Or I could create an array of pointers to spaceships. C is really flexible.

I could create a spaceship struct like this St thectop of the module.
SPACE_SHIP ShipPlayer = {1,109,10,10};

Or alloc some memory for one or more like this at runtime.
SPACE_SHIP *pShip1; //the pointer
pShip1 = (SPACE_SHIP *) malloc(sizeof(SPACE_SHIP));


***
Array of pointers : (let's assume it's data type is int)

int *array_of_pointers[4];

We know that pointer holds a address of int data type variable. So the above mentioned array_of_pointers can
store four different or same int data type address i.e. array_of_pointers[0], array_of_pointers[1],
array_of_pointers[2] array_of_pointers[3] each can hold a int data type address.

For example:

int variable_one;
int variable_two;
int variable_three;
int variable_four;

So we have four different variable which are of type int so we can assign these to the above declared
array_of_pointers i.e. array_of_pointers[0] = &variable_one This is similar to declaring four different int
pointers but instead we used an array to hold these four pointers.

Pointer to array:

int[4] *pointer_to_array;    // or
int (*pointer_to_array)[4];

In simple language the pointer_to_array is a single variable that holds the address of the array.
Example:
int simple_array[4];

Now we can assign:
pointer_to_array = simple_array;          // or
pointer_to_array = &simple_array[0];

Hope you get the difference.

Edit 1:
In pointer to an integer if pointer is incremented then it goes next address which differs by integer size.
For example consider pointer ptr holds 22 as address and integer size is 2 then after ptr++ we get:
22+2(int size) = 24 as next address.

in array of pointers if pointer is incremented it jumps to next address which differs by size of array. For
example consider pointer ptr holds 22 as address and integer array size is 4 elements, we already assumed int
size is 2 then after ptr++ we get 22+4*2 (total size of array) = 30 as next address.


***
Q: Can you explain how to create an array using pointers and arrays in C programming?

A:
An array of what? because this does not say it, will assume is an array of integers so you just do this
int *arrayOfIntegers=(int *)malloc(sizeof(int) * SIZE_OF_ARRAY);

done

Now arrayOfIntegers is an array and works exactly the same as if you have done

int arrayOfIntegers[SIZE_OF_ARRAY];

With some very big differences.

1) sizeof(arrayOfIntegers) is just a pointer size (not the array)
2) SIZE_OF_ARRAY can be defined in real time not in compilation time.
3) SIZE_OF_ARRAY can be as big as the malloc functions allows, and that is more than what the second example
   allows sometimes.

So is this arrayOfIntegers defined as int * an array? not truly but, you cannot define arrays in any other way
in C that are "variable in run time".

also you cannot either "pass by parameter" the second type either so nothing is gained from using them unless
you use them as global. (which is very wrong normally)


---

