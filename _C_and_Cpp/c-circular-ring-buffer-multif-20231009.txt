filename: c_circular-ring-buffer-multif_20231009.txt
https://medium.com/@charlesdobson/how-to-implement-a-simple-circular-buffer-in-c-34b7e945d30e

How To Implement A Simple Circular Buffer In C

A guide to implementing a circular buffer of integers, programmed in C
Feb 12, 2019

What Is A Circular Buffer?

   A circular buffer is a data structure that uses a fixed-size buffer as if it were connected
   end-to-end (in a circle). We're going to be using an array of integers for this guide.

   Here's a simple visual representation of an array of integers:

   Notice how I added in the read and write positions? We'll come back to those later. Here's a visual
   representation of that same array as a circular buffer:

   All I did was connect the end back to the beginning.

What Are We Implementing?
   We'll be creating a program to demonstrate an 8 location circular buffer of integers. We'll be
   implementing a FIFO (First In First Out) buffer. We'll be able to input (write) and output (read)
   values from the buffer. If the buffer is full, we won't be able to write any more values. If the
   buffer is empty, we won't be able to read any more values.

What Variables Do We Need?
   NOTE: Always remember to initialize your variables to 0

   First, we need to store the size of the circular buffer that we're implementing. A good way to store
   this information is in a constant.
#define SIZE_OF_BUFFER 8

   Next, we'll need a variable to store the buffer length. The buffer length is the current number of
   filled elements (elements we've written to). Each time we write a new value, we'll increment the
   buffer length by 1. Each time we read a value, we'll decrement the buffer length by 1.
int bufferLength = 0;

   We also need an integer to store the index position to write to and an integer to store the index
   position to read from.
int readIndex = 0;
int writeIndex = 0;

How Can We Get User Input?
   There are a lot of methods to get an integer value through user input in C. I'll be using a little
   function called getNumber() in this guide. It takes in a pointer to an int as a parameter, gets user
   input using fgets(), parses the integer from that input using sscanf() and stores it in the address
   the parameter is pointing to.

Let's Input Some Values!
   The first thing we need to do is check if the buffer is full. If it is, we can't write to it!
   Remember that bufferLength variable we're using to keep track of how many elements we have? All we
   need to do is make sure that doesn't equal the number of locations we have. We can compare our
   bufferLength variable and our SIZE_OF_BUFFER constant. If they're equal, we'll print an error
   message.

if (bufferLength == SIZE_OF_BUFFER) {
   printf("Buffer is full!");
}

   We won't be writing the full code in this guide, but if you are, always remember to prompt the user
   for the input! Remember, our getNumber() function takes in a pointer to an int. To input (write) a
   value, we need to pass in the address in memory of the index we want to write to into the getNumber()
   function.
getNumber(&circularBuffer[writeIndex]);

   That will write a value to the 0th position in the circular buffer. Let's say we input the number 5.
   Here's a visual representation:

   Now that we've written our first value, we need to update our bufferLength variable to keep track of
   how many values we have.
bufferLength++;

   Now we need to move our write position to the next location in the circular buffer. We just need to
   increment our writeIndex variable by 1.
writeIndex++;

   We're almost there! Now we have to figure out what to do if we've written to the last location and
   our write position needs to be incremented. Here's a visual representation:

   Remember, we're implementing a circular buffer. The last location attaches to the first location. If
   our writeIndex variable is equal to the number of locations we have (circularBuffer[7]), we simply
   need to set it back to location 0 (circularBuffer[0]).

if (writeIndex == SIZE_OF_BUFFER) {
	writeIndex = 0;
}

   Now our write index is right back to the start! Our check to make sure that our bufferLength variable
   is less than our SIZE_OF_BUFFER is preventing us from writing over any data.

   Put it all together and it looks something like this:

if (bufferLength == SIZE_OF_BUFFER) {
	printf("Buffer is full!");
}

getNumber(&circularBuffer[writeIndex]);
bufferLength++;writeIndex++;

if (writeIndex == SIZE_OF_BUFFER) {
	writeIndex = 0;
}

   Pretty simple, right?

Let's Output Some Values!
   We couldn't write a value if the buffer was full and we can't read a value if the buffer is empty!
   Let's use the same check we used before, but we'll check if our bufferLength variable is equal to 0
   this time.

if (bufferLength == 0) {
	printf("Buffer is empty!");
}

   Now, let's read our first value! We'll just be displaying this value on the screen as our way of
   "outputting" it. Our readIndex variable is still at index 0 in the array, since we haven't done
   anything with it. Let's print that 0th element.
printf("The output value is %d", circularBuffer[readIndex]);

   Now that we've read our first value, we need to update our bufferLength variable to keep track of how
   many values we have left.
bufferLength--;

   We also need to move our read position to the next location. We just need to increment our readIndex
   variable by 1.
readIndex++;

   Here's a visual representation (assuming we have input 5 values and just read our first value):

   Almost there! All we have left to do is check if our read position is at the last position
   (circularBuffer[7]) and move it back to the first position (circularBuffer[0]) if it is, just like we
   did with the write position.

if (readIndex == SIZE_OF_BUFFER) {
	readIndex = 0;
}

   Put it all together and it looks something like this:

if (bufferLength == 0) {
	printf("Buffer is empty!");
}

bufferLength--;
readIndex++;

if (readIndex == SIZE_OF_BUFFER) {
	readIndex = 0;
}

How Does the Program Work?
   Of course, this isn't the full program. We'd need to include our libraries (#include <stdio.h>) and
   it'd be nice to display a menu to the user that has a write option and a read option. These options
   could be placed in a simple while loop (make sure to add a continue; if the buffer is full or empty
   so you don't execute the code anyway). We would need our getNumber() function as well, which might
   look something like this:

#define SUCCESS 0
#define FAILURE -1

int getNumber(int* pNumber) {
	char userInput[MAX_LENGTH_OF_STRING] = { 0 };
	fgets(userInput, MAX_LENGTH_OF_STRING, stdin);

	 if (sscanf(userInput, "%d", pNumber) != 1) {
		return FAILURE;
	}
	return SUCCESS;
}

That's It!

   That's all there is to it!

   If you want to take a look at a sample implementation, here's a link to my GitHub repo:



---
https://embedjournal.com/implementing-circular-buffer-embedded-c/

Implementing Circular Buffer in C
May 2014

   Embedded software often involves state machines, circular buffers and queues. This article will give
   you an overview of the data structure and walks you through the steps involved in implementing
   circular buffers in low memory devices. If you are already familiar with the basics of such data
   structures, feel free to jump into the implementation section from the below table of contents.

Theoretical Background
   Choice of a good data structure or algorithm for a given problem comes after a deep understanding of
   the underlying theory. In this section we will go over some of the key aspects and problems of a
   circular buffer implementation. Hopefully, this will allow you to make informed decisions on the
   choice of data structure.

What is a circular buffer?
   Circular buffer is a FIFO data structure that treats memory to be circular; that is, the read/write
   indices loop back to 0 after it reaches the buffer length. This is achieved by two pointers to the
   array, the "head" pointer and the "tail" pointer. As data is added (write) to the buffer, the head
   pointer is incremented and likewise, when the data is being removed (read) the tail pointer is
   incremented. The definition of head, tail, their movement direction and write and read location are
   all implementation dependent but the idea/goal remains the same.

   So, for the sake of this discussion, we will consider, that a write is done at head and read at tail.
   Here is a nice GIF from Wikipedia:,

   The picture says it all. The animation is very fast and may take some iterations before you notice
   all the cases involved. Do spend the time with this image as it gives a visual representation of the
   memory and pointers that will be used in later parts of this post.

Need for circular buffers
   Circular buffers are excessively used to solve the single produce-consumer problem. That is, one
   thread of execution is responsible for data production and another for consumption. In the very low
   to medium embedded devices, the producer is often an Interrupt Service Routine (ISR) - perhaps data
   produced from sensors - and consumer is the main event loop.

   But why does it have to be circular? why not a regular array? one might wonder. It is a very common
   question that pops out when you hear about circular buffers for the first time. Though the course of
   this article, the need for these data structures will be made very clear.

Synchronization and race conditions
   I'm sure you have come across a race condition due to lack of synchronization in your programming
   career. Most people seem to think they don't apply to the low memory embedded world (which is in
   verge of extinction) where there is only one thread of execution. On the contrary, they exist there
   too (think of ISRs here), in fact, more predominantly there.

   The nice thing about circular buffers is its elegance. The down side is its not easy to implement it
   without race conditions. Another good thing is that they can be implemented without the need for
   locks for a single producer and single consumer environment. It may not sound like much but, don't be
   too quick to judge, single producer-consumer needs account for a large portion overall circular
   buffer applications.

   This makes it an ideal data structure for bare-metal embedded programs. The bottom line is that it
   has to be implemented correctly to be free of a race.

The full vs empty problem
   The big pain point in circular buffers is that there is no clean way to differentiate the buffer full
   vs empty cases. This is because in both the cases, head is equal to tail. That is, initially head and
   tail pointed point to the same location; when data is filled into the buffer, head is incremented and
   eventually it wraps around (more on this later) and catches tail when you fill the N^th element
   (note: not 0 indexed) into the N element buffer. At this point, head will point to the same location
   as tail but now the buffer is actually full, not empty.

   There are a lot of ways/workarounds to deal with this but most of them introduce a lot of complexity
   and hinders readability. This article presents a method that gives importance to elegance in design.

   In this method, we deliberately use only N-1 elements in the N element buffer. The last element is
   used (think of this more like a flag) to differentiate between empty and full cases. By this logic,
     * if head is equal to tail -> the buffer is empty
     * if (head + 1) is equal to tail -> the buffer is full

   In essence, every push checks the is_buffer_full condition and every pop, checks the is_buffer_empty.

Overwrite or discard when full?
   This is the last question that pops up regarding circular buffers. Whether new data has to be
   discarded or should it overwrite existing data when the buffer is full. The answer is, there is no
   clear advantage of one over the other, and most of the time its implementation/usage specific. If the
   most recent data makes more sense to your application, then go with the overwrite approach. On the
   other hand, if data has to processed on a first-come first-serve mode discard.

   The following implementation will discard new data when the buffer is full.

Implementation in C
   Now that we have dealt with the theory, let's proceed with the implementation by defining the data
   types and subsequently the core, push and pop methods.

   In push and pop routines, we will compute the 'next' offset points to the location that the current
   write-to/read-from will happen. As discussed earlier, if the next location points to the location
   pointed by the tail then we know that the buffer is full, and we don't write data into the buffer
   (return an error). Similarly, when the head is equal to tail we know that buffer is empty and nothing
   can be read from it.

Data structure definition

typedef struct {
	uint8_t * const buffer;
	int head;
	int tail;
	const int maxlen;
} circ_bbuf_t;

   There goes our primary structure to handle the buffer and its pointers. Notice that buffer is uint8_t
   * const buffer. const uint8_t * is a pointer to a byte array of constant elements, that is the value
   being pointed to can't be changed but the pointer itself can. On the other hand uint8_t * const is a
   constant pointer to an array of bytes in which the value being pointed to can changed but not the
   pointer.

   This is done so that you will be able to make changes to the buffer but you will not be able to
   accidentally orphan the pointer. This is a very good safety measure that I strongly suggest you keep
   as-is.

Push data into the circular buffer
   In majority of the use case scenarios, you will be calling this from within an ISR. Hence, a push
   should be as small and the whole routine should be enclosed within critical sections to make it
   synchronized in multi threaded environments.

   Data has to be loaded before the head pointer is incremented to ensure that only valid data is read
   by the consumer thread (one which calls pop. See below).

   Also, if you notice, we hold one byte as reserved space in the buffer. On first glance it may appear
   as an off by one but if you thing about it, you will realize its an engineering trade off. If I were
   to use that one extra byte, detection of full and empty cases becomes slightly complex and writing
   code that will handle all corner cases is time consuming and hard to debug if it comes to it.

   So, in conclusion, for small and fixed size data units, just reserve one byte while you can still
   keep your sanity.

int circ_bbuf_push(circ_bbuf_t *c, uint8_t data) {
	int next;

	next = c->head + 1;  // next is where head will point to after this write.
	if (next >= c->maxlen)
		next = 0;

	if (next == c->tail)  // if the head + 1 == tail, circular buffer is full
		return -1;

	c->buffer[c->head] = data;  // Load data and then move
	c->head = next;             // head to next data offset.
	return 0;  // return success to indicate successful push.
}

Pop data from the circular buffer
   Pop routine is called by the application process to pull data off the buffer. This also has to be
   enclosed in critical sections if more than one threads are reading off this buffer (although that's
   not how it is usually done)

   Here, the tail can be moved to the next offset before the data has been read since each data unit is
   one byte and we reserve one byte in the buffer when we are fully loaded. But in more advanced
   circular buffer implementations, data units does not need to be of the same size. In such cases, we
   try to save even the last byte adding more check and bounds.

   In such implementations, if tail is moved before read, the data to be read can potentially be
   overwritten by a newly pushed data. So its a general best practice to the read data and then move the
   tail pointer.

int circ_bbuf_pop(circ_bbuf_t *c, uint8_t *data) {
	int next;

	if (c->head == c->tail)  // if the head == tail, we don't have any data
		return -1;

	next = c->tail + 1;  // next is where tail will point to after this read.
	if(next >= c->maxlen)
		next = 0;

	*data = c->buffer[c->tail];  // Read data and then move
	c->tail = next;              // tail to next offset.
	return 0;  // return success to indicate successful push.
}

Typical use case
   I think its pretty obvious that you have to define a buffer of a certain length and then create an
   instance of circ_bbuf_t and assign the pointer to buffer and its maxlen. It also goes without saying
   that the buffer has to be global or it has to be in stack so long as you need to use it.

   To make maintenance a little easier, you could use this macro but compromises code readability for
   new users.

#define CIRC_BBUF_DEF(x,y)         \
	uint8_t x##_data_space[y];     \
	circ_bbuf_t x = {              \
		.buffer = x##_data_space,  \
		.head = 0,                 \
		.tail = 0,                 \
		.maxlen = y                \
	}

   So for example if you need a circular buffer of length 32 bytes, you would do something like this in
   your application,

CIRC_BBUF_DEF(my_circ_buf, 32);

int your_application() {
	uint8_t out_data=0, in_data = 0x55;

	if (circ_bbuf_push(&my_circ_buf, in_data)) {
		printf("Out of space in CB\n");
		return -1;
	}

	if (circ_bbuf_pop(&my_circ_buf, &out_data)) {
		printf("CB is empty\n");
		return -1;
	}

	// here in_data = in_data = 0x55;
	printf("Push: 0x%x\n", in_data);
	printf("Pop:  0x%x\n", out_data);
	return 0;
}

   You can find a complete implementation of the above at goToMain/c-utils in files
   circular-byte-buffer.c and circular-byte-buffer.h.

   I hope this post was of some help in understanding circular buffers. We will see more such data
   structures and an advanced extensions to this circular buffer that allows push/pop of non just bytes
   but any data type (even user defined data types) with type checking and other niceness in a future
   post.

Edit History:
04 Aug 2018 - Reworded to clarify need for unused byte in buffer
05 Aug 2018 - Refactor code; Added reference to EmbedJournal/c-utils.git
01 Feb 2019 - Modify post heading; some rewording/restructuring
31 Oct 2019 - Fix broken github link



---
https://embeddedartistry.com/blog/2017/05/17/creating-a-circular-buffer-in-c-and-c/

Creating a Circular Buffer in C and C++
December 2022

   Due to the resource constrained nature of embedded systems, circular buffer data structures can
   be found in most projects.

   Circular buffers (also known as ring buffers) are fixed-size buffers that work as if the memory is
   contiguous & circular in nature. As memory is generated and consumed, data does not need to be
   reshuffled - rather, the head/tail pointers are adjusted. When data is added, the head pointer
   advances. When data is consumed, the tail pointer advances. If you reach the end of the buffer, the
   pointers simply wrap around to the beginning.

   For a more detailed summary of circular buffer operation, please refer to the Wikipedia article.
   The rest of the article assumes you have an understanding of how circular buffers work.

Why Use A Circular Buffer?
   Circular buffers are often used as fixed-sized queues. The fixed size is beneficial for embedded
   systems, as developers often try to use static data storage methods rather than dynamic allocations.

   Circular buffers are also useful structures for situations where data production and consumption
   happen at different rates: the most recent data is always available. If the consumer cannot keep up
   with production, the stale data will be overwritten with more recent data. By using a circular
   buffer, we can ensure that we are always consuming the most recent data.

C Implementation
   We will start with a C implementation, as this exposes us to some of the design challenges and
   tradeoffs when creating a circular buffer library.

Using Encapsulation
   Since we are creating a circular buffer library, we want to make sure users work with our library
   APIs instead of modifying the structure directly. We also want to keep the implementation contained
   within our library so we can change it as needed, without requiring end users to update their code.
   The user doesn't need to know any details about our structure, only that it exists.

   In of our library header, we will forward declare the structure:
// Opaque circular buffer structure
typedef struct circular_buf_t circular_buf_t;

   We don't want users to work with a circular_buf_t pointer directly, as they might get the impression
   that they can dereference the value. We will create a handle type that they can use instead.

   The simplest approach for our handle is to typedef the cbuf_handle_t as a pointer to the circular
   buffer. This will prevent us from needing to cast the pointer within our function implementation.
// Handle type, the way users interact with the API
typedef circular_buf_t* cbuf_handle_t;

   An alternative approach would be to make the handle a uintptr_t or void* value. Inside of our
   interface, we would handle the translation to the appropriate pointer type. We keep the circular
   buffer type hidden from users, and the only way to interact with the data is through the handle.

   We're going to stick with the simple handle implementation to keep our example code simple and
   straightforward.

API Design
   First, we should think about how users will interact with a circular buffer:
     * They need to initialize the circular buffer container with a buffer and size
     * They need to destroy a circular buffer container
     * They need to reset the circular buffer container
     * They need to be able to add data to the buffer
     * They need to be able to get the next value from the buffer
     * They need to know whether the buffer is full or empty
     * They need to know the current number of elements in the buffer
     * They need to know the max capacity of the buffer

   Using this list, we can put together an API for our library. Users will interact with the
   circular buffer library using our opaque handle type, which is created during initialization.

   I have chosen uint8_t as the underlying data type in this implementation. You can use any particular
   type that you like - just be careful to handle the underlying buffer and number of bytes
   appropriately.
/// Pass in a storage buffer and size
/// Returns a circular buffer handle
cbuf_handle_t circular_buf_init(uint8_t* buffer, size_t size);

/// Free a circular buffer structure.
/// Does not free data buffer; owner is responsible for that
void circular_buf_free(cbuf_handle_t me);

/// Reset the circular buffer to empty, head == tail
void circular_buf_reset(cbuf_handle_t me);

/// Put version 1 continues to add data if the buffer is full
/// Old data is overwritten
void circular_buf_put(cbuf_handle_t me, uint8_t data);

/// Put Version 2 rejects new data if the buffer is full
/// Returns 0 on success, -1 if buffer is full
int circular_buf_put2(cbuf_handle_t me, uint8_t data);

/// Retrieve a value from the buffer
/// Returns 0 on success, -1 if the buffer is empty
int circular_buf_get(cbuf_handle_t me, uint8_t * data);

/// Returns true if the buffer is empty
bool circular_buf_empty(cbuf_handle_t me);

/// Returns true if the buffer is full
bool circular_buf_full(cbuf_handle_t me);

/// Returns the maximum capacity of the buffer
size_t circular_buf_capacity(cbuf_handle_t me);

/// Returns the current number of elements in the buffer
size_t circular_buf_size(cbuf_handle_t me);

Determining if a Buffer is Full
   Before we proceed, we should take a moment to discuss the method we will use to determine whether or
   buffer is full or empty.

   Both the "full" and "empty" cases of the circular buffer look the same: head and tail pointer are
   equal. There are two approaches to differentiating between full and empty:
    1. "Waste" a slot in the buffer:
          + Full state is head + 1 == tail
          + Empty state is head == tail
    2. Use a bool flag and additional logic to differentiate states::
          + Full state is full
          + Empty state is (head == tail) && !full

   We should also consider thread safety. By using a single empty cell to detect the "full" case, we can
   support a single producer and single consumer without a lock (as long as put and get don't modify the
   same variables). The queue is thread-safe because the producer will only modify the head index, and
   the consumer will only modify the tail index. While either index might be slightly out-of-date in a
   given context, this will not impact the thread safety of the queue. Using the full flag, however,
   creates a requirement for mutual exclusion. This is because the full flag is shared by both the
   producer and consumer.

   Of course, the decision has its tradeoffs. If your buffer element has a large memory footprint (such
   as a buffer that is sized for a camera i-frame), wasting a slot may not be reasonable on your system.
   If you have multiple producers/consumers interacting with a queue, you will need a lock anyway, so
   wasting a slot doesn't make sense. If you do not have mutual exclusion available (e.g., because
   you're not using an OS) but you are using interrupts, then you will want to use the version
   without the full flag. The memory model used on your system may also have an impact on your
   decision to go without a lock.

   The implementation below uses the bool flag. Using the flag requires additional logic in the get and
   put routines to update the flag. I will also describe how to make the modifications for a single
   producer/consumer that does not use the full flag.

Circular Buffer Container Type
   Now that we have a grasp on the operations we'll need to support, we can design our circular buffer
   container.

   We use the container structure for managing the state of the buffer. To preserve encapsulation,
   the container structure is defined inside of our library .c file, rather than in the header.

   We will need to keep track of:
     * The underlying data buffer
     * The maximum size of the buffer
     * The current "head" position (incremented when elements are added)
     * The current "tail" (incremented when elements are removed)
     * A flag indicating whether the buffer is full or not

// The hidden definition of our circular buffer structure
struct circular_buf_t {
	uint8_t * buffer;
	size_t head;
	size_t tail;
	size_t max; //of the buffer
	bool full;
};

   Now that our container is designed, we are ready to implement the library functions.

Implementation
   One important detail to note is that each of our APIs requires an initialized buffer handle. Rather
   than litter our code with conditional statements, we will utilize assertions to enforce our API
   requirements in the "Design by Contract" style.

   If the interfaces are improperly used, the program will fail immediately rather than requiring the
   user to check and handle the error code.

   For example:
circular_buf_reset(NULL);

   Produces:
=== C Circular Buffer Check ===
Assertion failed: (me), function circular_buf_reset, file ../../circular_buffer.c, line 35.
Abort trap: 6

   Another important note is that the implementation shown below is not thread-safe. No locks have been
   added to the underlying circular buffer library.

Initialize and Reset
   Let's start at the beginning: initializing a circular buffer. Our API has clients provide the
   underlying buffer and buffer size, and we return a circular buffer handle to them. The reason we want
   our users to provide the buffer is that this allows for a statically allocated buffer. If our API
   created the buffer under the hood, we would need to make use of dynamic memory allocation, which is
   often disallowed in embedded systems programs.

   We are required to provide a circular buffer structure instance within the library so that we can
   return a pointer to the user. I have used malloc for simplicity. Systems which cannot use dynamic
   memory simply need to modify the init function to use a different method, such as allocation from a
   static pool of pre-allocated circular buffer structures.

   Another approach would be to break encapsulation, allowing users to statically declare circular
   buffer container structures outside of the library. In this case, circular_buf_init needs to be
   updated to take a struct pointer. We could also have our init function create a container structure
   on the stack and return it wholesale. However, since encapsulation is broken, users will be able to
   modify the structure without using the library routines. If you want to preserve encapsulation, you
   need to work with pointers instead of concrete structure instances.
// User provides struct
void circular_buf_init(circular_buf_t* me, uint8_t* buffer,
        size_t size);

// Return a concrete struct
circular_buf_t circular_buf_init(uint8_t* buffer, size_t size);

// Return a pointer to a struct instance - preferred approach
cbuf_handle_t circular_buf_init(uint8_t* buffer, size_t size);

   We will be returning a handle to a structure that is allocated inside of the library. Once we've
   created our container, we need populate the values and call reset on it. Before we return from init,
   we ensure that the buffer container has been created in an empty state.

cbuf_handle_t circular_buf_init(uint8_t* buffer, size_t size) {
	assert(buffer && size);

	cbuf_handle_t cbuf = malloc(sizeof(circular_buf_t));
	assert(cbuf);

	cbuf->buffer = buffer;
	cbuf->max = size;
	circular_buf_reset(cbuf);

	assert(circular_buf_empty(cbuf));

	return cbuf;
}

   The purpose of the reset function is to put the buffer into an "empty" state, which requires updating
   head, tail, and full:

void circular_buf_reset(cbuf_handle_t me) {
	assert(me);

	me->head = 0;
	me->tail = 0;
	me->full = false;
}

   Since we have a method to create a circular buffer container, we need an equivalent method for
   destroying the container. In this case, we call free on our container. We do not attempt to free the
   underlying buffer, since we do not own it.

void circular_buf_free(cbuf_handle_t me) {
	assert(me);
	free(me);
}

State Checks
   Next, we'll implement the functions related to the state of the buffer container.

   The full function is the easiest to implement, since we have a flag representing the state:

bool circular_buf_full(cbuf_handle_t me) {
	assert(me);

	return me->full;
}

   Since we have the full flag to differentiate between full or empty state, we combine the flag with a
   check that head == tail:

bool circular_buf_empty(cbuf_handle_t me) {
	assert(me);

	return (!me->full && (me->head == me->tail));
}

   The capacity of our buffer was supplied during initialization, so we just return that value to the
   user:

size_t circular_buf_capacity(cbuf_handle_t me) {
	assert(me);

	return me->max;
}

   Calculating the number of elements in the buffer was a trickier problem than I expected. Many
   proposed size calculations use modulo, but I ran into strange corner cases when testing that out. I
   opted for a simplified calculation using conditional statements.

   If the buffer is full, we know that our capacity is at the maximum. If head is
   greater-than-or-equal-to the tail, we simply subtract the two values to get our size. If tail is
   greater than head, we need to offset the difference with max to get the correct size.

size_t circular_buf_size(cbuf_handle_t me) {
	assert(me);

	size_t size = me->max;

	if(!me->full) {
		if(me->head >= me->tail) {
			size = (me->head - me->tail);
		} else {
			size = (me->max + me->head - me->tail);
		}
	}

	return size;
}

Adding and Removing Data
   With the bookkeeping functions out of the way, it's time to dig into the meat: adding and removing
   data from the queue.

   Adding and removing data from a circular buffer requires manipulation of the head and tail pointers.
   When adding data to the buffer, we insert the new value at the current head location, then we advance
   head. When we remove data from the buffer, we retrieve the value of the current tail pointer and then
   advance tail.

   Adding data to the buffer requires a bit more thought, however. If the buffer is full, we need to
   advance our tail pointer as well as head. We also need to check whether inserting a value triggers
   the full condition.

   We are going to implement two versions of the put function, so let's extract our pointer advancement
   logic into a helper function. If our buffer is already full, we advance tail. We always advance head
   by one. After the pointer has been advanced, we populate the full flag by checking whether head ==
   tail.

   Note the use of the modulo operator (%) below. Modulo will cause the head and tail values to reset to
   0 when the maximum size is reached. This ensures that head and tail are always valid indices of the
   underlying data buffer.

static void advance_pointer(cbuf_handle_t me) {
	assert(me);

	if(me->full) {
		me->tail = (me->tail + 1) % me->max;
	}

	me->head = (me->head + 1) % me->max;
	me->full = (me->head == me->tail);
}

   As Miro Samek helpfully pointed out, this is an expensive computational operation. Instead, we can
   use conditional logic to reduce the total number of instructions. Miro's recommended approach is:

if (++(me->head) == me->max) {
	me->head = 0;
}

   Now, advance_pointer will look like this:

static void advance_pointer(cbuf_handle_t me) {
	assert(me);

	if(me->full) {
		if (++(me->tail) == me->max) {
			me->tail = 0;
		}
	}

	if (++(me->head) == me->max) {
		me->head = 0;
	}
	me->full = (me->head == me->tail);
}

   We can make a similar helper function which is called when removing a value from the buffer. When we
   remove a value, the full flag is set to false, and the tail pointer is advanced.

static void retreat_pointer(cbuf_handle_t me) {
	assert(me);

	me->full = false;

	if (++(me->tail) == me->max) {
		me->tail = 0;
	}
}

   We'll create two versions of the put function. The first version inserts a value into the buffer and
   advances the pointer. If the buffer is full, the oldest value will be overwritten. This is the
   standard use case for a circular buffer

void circular_buf_put(cbuf_handle_t me, uint8_t data) {
	assert(me && me->buffer);

	me->buffer[me->head] = data;

	advance_pointer(me);
}

   The second version of the put function returns an error if the buffer is full. This is provided for
   demonstration purposes, but we do not use this variant in our systems.

int circular_buf_put2(cbuf_handle_t me, uint8_t data) {
	int r = -1;

	assert(me && me->buffer);

	if(!circular_buf_full(me)) {
		me->buffer[me->head] = data;
		advance_pointer(me);
		r = 0;
	}

	return r;
}

   To remove data from the buffer, we access the value at the tail and then update the tail pointer. If
   the buffer is empty we do not return a value or modify the pointer. Instead, we return an error to
   the user.

int circular_buf_get(cbuf_handle_t me, uint8_t * data) {
	assert(me && data && me->buffer);

	int r = -1;

	if(!circular_buf_empty(me)) {
		*data = me->buffer[me->tail];
		retreat_pointer(me);

		r = 0;
	}

	return r;
}

   That completes the implementation of our circular buffer library.

Usage
   When using the library, the client is responsible for creating the underlying data buffer to
   circular_buf_init, and a cbuf_handle_t is returned:

uint8_t * buffer  = malloc(EXAMPLE_BUFFER_SIZE * sizeof(uint8_t));
cbuf_handle_t me = circular_buf_init(buffer,
        EXAMPLE_BUFFER_SIZE);

   This handle is used to interact with all remaining library functions:
bool full = circular_buf_full(me);
bool empty = circular_buf_empty(me);
printf("Current buffer size: %zu\n", circular_buf_size(me);

   Don't forget to free both the underlying data buffer and the container when you are done:
free(buffer);
circular_buf_free(me);

   A [https://github.com/embeddedartistry/embedded-resources/blob/master/examples/c/circular_buffer_test.c]test
   program which uses the circular buffer library can be found in the
   [https://github.com/embeddedartistry/embedded-resources/]embedded-resources repository.

Modifications for Removing the full flag
   If you wanted to ditch the full flag, you would instead check that the head is one position behind
   the tail to determine if the buffer is full:

bool circular_buf_full(circular_buf_t* me) {
	// We determine "full" case by head being one position behind the tail
	// Note that this means we are wasting one space in the buffer
	return ((me->head + 1) % me->size) == me->tail;
}

   Now, if we wanted to avoid the modulo operation, we can use conditional logic instead:

bool circular_buf_full(circular_buf_t* me) {

	// We need to handle the wraparound case
	size_t head = me->head + 1;

	if(head == me->max) {
		head = 0;
	}

	return head == me->tail;
}

   The empty case is then that head and tail are the same:

bool circular_buf_empty(circular_buf_t* me) {
	// We define empty as head == tail
	return (me->head == me->tail);
}

   When getting data from the buffer, we will advance the tail pointer, wrapping around if necessary:

int circular_buf_get(circular_buf_t * me, uint8_t * data) {
	int r = -1;

	if(me && data && !circular_buf_empty(me)) {
		*data = me->buffer[me->tail];
		me->tail = (me->tail + 1) % me->size;

		r = 0;
	}

	return r;
}

   When adding data to the buffer, we will store the data and advance the head pointer, wrapping around
   if necessary:

int circular_buf_put(circular_buf_t * me, uint8_t data) {
	int r = -1;

	if(me && !circular_buf_full(me)) {
		me->buffer[me->head] = data;
		me->head = (me->head + 1) % me->size;

		r = 0;
	}

	return r;
}

   Other references to full can be eliminated.


Putting it All Together

   Example implementations can be found in [https://github.com/embeddedartistry/embedded-resources/]the
   embedded-resources Github repository.
     * [https://github.com/embeddedartistry/embedded-resources/blob/master/examples/c/circular_buffer_test.c]
	    C circular buffer test program
          + [https://github.com/embeddedartistry/embedded-resources/blob/master/examples/c/circular_buffer/\
		     circular_buffer.c]C circular buffer library
     * [https://github.com/embeddedartistry/embedded-resources/blob/master/examples/cpp/circular_buffer.cpp]
	    C++ circular buffer example

   If you are looking to extend this library, a useful exercise is to add additional APIs to enable
   users to add/remove multiple elements with a single operation. You can also make the C implementation
   thread-safe.

Thread Safety with the Lookahead Method
   One approach for thread-safety without a mutex is the "lookahead" method. This method supports a
   single producer thread and single consumer thread; multiple producers or consumers will require a
   lock.

   Instead of using the boolean flag to differentiate between the full and empty cases, we will always
   leave one cell empty. By using a single empty cell to detect the "full" case, we can support a single
   producer and single consumer without a lock (as long as put and get don't modify the same variables).

   You may be concerned about wasting a slot, but this tradeoff is often much cheaper than the cost of
   using an OS lock primitive.



---
https://towardsdatascience.com/circular-queue-or-ring-buffer-92c7b0193326
Circular Queue or Ring Buffer

Python and C Implementation.
Apr 30, 2020

Introduction
   There are many different implementations of the circular queue all of which may be better suited for
   specific applications. This blog post is to help understand how a circular queue works along with its
   uses and advantages.

Circular Queue
   A Queue is a simple data structure that implements the FIFO (First-In-First-Out) ordering. This
   simply means that the first item added to your queue is the first one out. Just like a line or queue
   of customers at the deli, the first customer in line is the first to be served. A circular queue is
   essentially a queue with a maximum size or capacity which will continue to loop back over itself in a
   circular motion.

Applications
   Ring Buffers are common data structures frequently used when the input and output to a data stream
   occur at different rates.
     * Buffering Data Streams
     * Computer Controlled Trafficking signal systems
     * Memory Management
     * CPU scheduling

Advantages
   Circular Queues offer a quick and clean way to store FIFO data with a maximum size.
     * Doesn't use dynamic memory → No memory leaks
     * Conserves memory as we only store up to our capacity (opposed to a queue which could continue to
       grow if input outpaces output.)
     * Simple Implementation → easy to trust and test
     * Never has to reorganize / copy data around
     * All operations occur in constant time O(1)

Disadvantages
   Circular Queues can only store the pre-determined maximum number of elements.
     * Have to know the max size beforehand

How Does it Work? (Array Implementation)
   There are two primary operations on a circular Queue :

   1: Enqueue(item) : add item to the Queue.
if Queue.isfull()
	print "Queue is Full"
else
	increase tail by 1
	Queue[tail] = item
	size++

   2: Dequeue(): return the item at the front (head) of the line and remove it.
if Queue.isEmpty()
	print "Queue is Empty"
else
	tmp = Queue[head]
	increase head by 1
	size--
	return tmp

   Note: We aren't actually removing anything from the array, we are just increasing the head to point
   at the next item "in line".

   Let's take a Look at how these operations look on an Array of size 6:
     * Notice how the tail wraps back around to zero as we enqueue our seventh item (35).
     * Notice how the head increases as we dequeue, but no values are removed from the array, they are
       only over-written as Enqueue() reaches that location in the array.

The Modulo Operator
   If we're supposed to be increasing the head and the tail by 1 spot in the array how do we set it back
   to zero when we get to the end to ensure we keep looping through the array?

   We could do something like this:
if (head + 1) = capacity
	head = 0
else
	head = head + 1

   There's really nothing wrong with that, however, there's a much more elegant method using the modulo
   operator. The modulo operator (%) gives the remainder after division. When looking at the
   relationship between two integers a and b; a will be the product of b times some integer q plus some
   integer r :
a = b x q + r
	q : quotient = a div b
	r : remainder = a mod b

   Let's look at some quick examples:
a = b x q + r                    a % b = r
5 = 3 x 1 + 2                    5 % 3 = 2
2 = 5 x 0 + 2                    2 % 5 = 2
9 = 3 x 3 + 0                    9 % 3 = 0
9 = 2 X 4 + 1                    9 % 2 = 1

   Note: This is the basis of Euclid's Algorithm for determining GCD.

   Let's apply it to our circular queue implementation:
self.head = (self.head + 1) % self.capacity
     * Now every time we get to the end of the array we will automatically start back at zero.
       Beautiful! Let's see what this would look like with a circular queue of size 6 :

0 % 6 = 0
1 % 6 = 1
2 % 6 = 2
3 % 6 = 3
4 % 6 = 4
5 % 6 = 5
6 % 6 = 0
...

Python Implementation
   This is a simple implementation where we only have the two primary methods, Enqueue(item), Dequeue(),
   as well as a display() method which I think is helpful in understanding. Many other
   implementations might also include :
     * isFull(): true if queue is full, false otherwise.
     * isEmpty(): true if queue is empty, false otherwise.
     * peek() : see what is at the head of the queue without "removing" it.
     * etc..

   Many other implementations won't store the current size and will determine isFull() and isEmpty()
   by simply comparing the head and tail. I think storing the size makes it easier to follow exactly
   what is going on.

C Implementation
   You can see the C implementation is very similar to the Python implementation with the addition of
   the fun C stuff like structs and memory allocation. Here we also need a create_queue() function as
   we are using structs. We also use some helper functions that we talked about earlier like isFull(),
   isEmpty(), etc..

Thinkers
     * What are some boundary cases?
     * What assumptions are we making?
     * How would we implement the circular queue to have the ability to change capacity on the fly? How
       would this affect our advantages and disadvantages of the circular queue?
     * Both of these implementations won't allow you to enqueue a new item if the queue is full. Can you
       think of some applications of a circular queue where this might be bad? How would we change the
       implementations to allow for over-writing?

Conclusion
   I would encourage anyone reading this to look at other implementations around the web and compare
   them as well as think about different applications of the circular queue. I am still a student myself
   and still have a lot to learn. Nevertheless, I hope this might have been helpful for some of you
   learning about circular queues for the first time. Thanks for reading!



---
https://www.tutorialandexample.com/circular-buffer-in-c

Circular Buffer in C

   A round queue is a form of records structure that makes storing and retrieving entries quickly
   viable, often known as a round buffer. It is carried out as a self-wrapping fixed-length array. The
   oldest detail is overwritten while the buffer is complete, and a new detail is introduced, central to
   round behavior.

   A single, fixed-size buffer with some programming logic to behave as though the components are
   connected end-to-end is known as a circular buffer, circular queue, cyclic buffer, or ring buffer.
   With a fixed-size array frequently employed in device drivers and systems with minimal memory
   footprints, a circular buffer offers a buffering and queueing method.

   A dynamic array with a fixed size or a static array can implement a circular buffer. It never calls
   dynamic memory allocation methods like alloc, free, or resize during operation. It manages queue
   elements' addition and deletion in a circular, rotating method.

Properties of Round Buffer:
   Fixed Size: In C, a circular buffer has a fixed size that is predetermined when created. This fixed
   size determines the buffer's maximum amount of elements. In addition to ensuring that the buffer
   stays constrained, it enables the underlying array structure to allocate memory effectively.

   Efficient memory usage:Circular buffers in C use a fixed array to store elements, which optimizes
   memory use. Unlike dynamic data structures like linked lists, circular buffers reduce the requirement
   for frequent memory allocation or reallocation during buffer operations. It prevents potential memory
   fragmentation problems and results in effective memory management.

   Wraparound Behaviour:Circular buffers' wraparound behavior is one of their most essential
   characteristics. When the buffer is complete and a new element is added, the oldest element is
   overwritten circularly. By removing the oldest elements, this behavior ensures that the buffer's size
   remains constant while admitting new ones. The buffer can continue to accept and store data because
   it establishes a cyclic flow of elements.

   Index-based Access: Circular buffers in C are frequently implemented as arrays and use indices to
   access their elements. A front index and a rear index are both kept in the buffer. The rear index
   denotes the following empty location for element insertion, while the front index denotes the oldest
   element in the buffer. These indices change as elements are enqueued or dequeued from the buffer,
   making retrieval and storage more practical.

   Efficient Insertion and Removal: Circular buffers in the C programming language enable efficient
   insertion and removal operations. The rear index is where enqueue, which adds an element to the
   buffer, happens. At the front index, an element is dequeued, which eliminates it. No buffer size,
   enqueue, and dequeue operations may be carried out constantly since circular buffers use indices to
   handle their elements. Because of this property, circular buffers are advantageous in situations
   demanding quick insertion and removal, such as real-time systems or data streaming applications.

   Constant Time Complexity: For enqueue and dequeue operations, circular buffers offer constant time
   complexity (O(1)). The direct access to the front and rear indices, which enables effective insertion
   and removal regardless of the buffer's size, causes the constant time complexity. Circular buffers
   can handle a continuous workload without sacrificing efficiency, making them an essential component
   of time-critical applications that demand consistent and predictable performance.

   Oldest Elements Are rewritten: The oldest element in a circular buffer is rewritten when the buffer
   is complete, and a new element is enqueued. By removing older elements to make place for newer ones,
   this behavior makes sure that the buffer always maintains a fixed size. The circular buffer can
   continually accept incoming data by overwriting the oldest elements, negating the need for human
   memory management or resizing. It's important to understand that once overwritten parts are replaced,
   they lose their accessibility.

   Efficient Buffer Overflow Handling:Circular buffers effectively handle buffer overflow situations.
   When an element is enqueued, and the buffer reaches its limit, it overwrites the oldest element
   rather than throwing an error or necessitating resize actions. This attribute simplifies buffer
   management because developers can rely on the cyclic behavior to automatically handle overflow
   problems without explicitly checking for buffer capacity.

   Sequential Data Storage: Circular buffers hold elements sequentially based on the sequence in which
   they were inserted. The underlying array's contiguous storage of elements makes it easier to process
   and traverse data sequentially. This sequential storage makes simple iteration of the elements based
   on their relative positions within the buffer possible. Sequential access may be helpful for tasks
   like data processing or transferring data in the order it was received.

   Flexible implementation options:Arrays, pointers, or a combination can be used to build circular
   buffers in C. The particular requirements and limitations of the application determine the
   implementation to be used. While pointer-based solutions can be more adaptable regarding dynamic
   resizing or dynamic memory allocation as necessary, array-based versions provide direct access to
   items through indices. The required trade-offs between memory utilization, efficiency, and
   flexibility should be considered while selecting an implementation strategy.

Implementation of Circular Buffer in C:

#include <stdio.h>
#include <stdlib.h>
#define BUFFER_SIZE 5

typedef struct {
	int* buffer;
	int front;
	int rear;
	int count;
} CircularBuffer;

CircularBuffer* createCircularBuffer() {
	// Allocate memory for the circular buffer structure
	CircularBuffer* cb = (CircularBuffer*)malloc(sizeof(CircularBuffer));

	// Allocate memory for the buffer array
	cb->buffer = (int*)malloc(BUFFER_SIZE * sizeof(int));

	// Initialize buffer properties
	cb->front = 0;
	cb->rear = -1;
	cb->count = 0;
	return cb;
}

void destroyCircularBuffer(CircularBuffer* cb) {
	// Free the memory allocated for the buffer array
	free(cb->buffer);

	// Free the memory allocated for the circular buffer structure
	free(cb);
}

int is buffer empty(CircularBuffer* cb) {
	// Check if the buffer count is zero
	return cb->count == 0;
}

int isBufferFull(CircularBuffer* cb) {
	// Check if the buffer count is equal to the buffer size
	return cb->count == BUFFER_SIZE;
}

void enqueue(CircularBuffer* cb, int data) {
	if (isBufferFull(cb)) {
		printf("Buffer is full. Cannot enqueue.\n");
		return;
	}

	// Update the rear index, wrapping around if necessary
	cb->rear = (cb->rear + 1) % BUFFER_SIZE;

	// Add the data to the buffer at the rear index
	cb->buffer[cb->rear] = data;

	// Increment the buffer count
	cb->count++;
}

int dequeue(CircularBuffer* cb) {
	if (is buffer empty(cb)) {
		printf("Buffer is empty. Cannot dequeue.\n");
		return -1;
	}

	// Retrieve the data at the front index
	int data = cb->buffer[cb->front];

	// Update the front index, wrapping around if necessary
	cb->front = (cb->front + 1) % BUFFER_SIZE;

	// Decrement, the buffer count
	cb->count--;

	// Return the dequeued data
	return data;
}

void displayBuffer(CircularBuffer* cb) {
	if (isBufferEmpty(cb)) {
		printf("Buffer is empty.\n");
		return;
	}

	printf("Circular Buffer: ");

	int i;
	for (i = 0; i < cb->count; i++) {
		// Calculate the actual index based on the front index and the current iteration
		int index = (cb->front + i) % BUFFER_SIZE;
		// Print the data at the calculated index
		printf("%d ", cb->buffer[index]);
	}
	printf("\n");
}

int main() {
	// Create a circular buffer
	CircularBuffer* cb = createCircularBuffer();
	
	// Enqueue some elements
	enqueue(cb, 10);
	enqueue(cb, 20);
	enqueue(cb, 30);

	// Display the buffer contents
	displayBuffer(cb);

	// Dequeue an element
	int data = dequeue(cb);
	printf("Dequeued element: %d\n", data);

	// Display the updated buffer contents
	displayBuffer(cb);

	// Enqueue more elements, including one that overwrites the oldest element
	enqueue(cb, 40);
	enqueue(cb, 50);
	enqueue(cb, 60);

	// Display the final buffer contents
	displayBuffer(cb);

	// Destroy the circular buffer
	destroyCircularBuffer(cb);
	return 0;
}

   Output:
Circular Buffer: 10 20 30
Dequeued element: 10
Circular Buffer: 20 30
Circular Buffer: 20 30 40 50 60

Complexity Analysis:
   Space Complexity: The circular buffer has an O(N) space complexity, where N is the BUFFER_SIZE. It is
   due to the circular buffer structure's continuous memory requirements and the buffer array's size N
   memory allocation requirements.

   Other variables used in the program, including loop counters and temporary variables, can need more
   room. However, these are constant spaces and only use a small amount of memory compared to the buffer
   size.

   Time Complexity: Most operations in the circular buffer implementation have constant time complexity
   since their time complexity is O(1). The display operation is the lone exception with an O(N) time
   complexity, where N is the number of elements in the buffer.

   Explanation:

Establishing the Circular Buffer:
     * The createCircularBuffer method is used to generate a circular buffer.
     * Malloc is used to allocate memory for the circular buffer structure.
     * The BUFFER_SIZE constant determines the buffer array's size, and memory is allocated for it using
       the malloc program.
     * Initial values for the count, rear, and front index are zero.
     * The circular buffer that was constructed is returned.

Destroying the circular buffer:
     * The circular buffer is destroyed by calling the CircularBuffer function.
     * Using free, memory allotted for the buffer array is released.
     * Using free, memory allotted for the circular buffer structure is released.

Examining the Buffer for Emptiness:
     * The isBufferEmpty feature is used to decide whether the buffer is empty.
     * If the remember of entries within the buffer is zero, indicating an empty buffer, it returns 1
       (true).
     * If not, it gives lower back 0 (false).

Verifying whether the buffer is full
     * The isBufferFull characteristic is used to decide whether the buffer is complete.
     * If the number of entries inside the buffer equals the dimensions of the buffer, it returns 1
       (true), indicating that the buffer is complete.
     * If no longer, it offers returned 0 (false).

Enqueueing an Element:
     * The enqueue characteristic is used to consist of an element inside the buffer.
     * IsBufferFull is used to decide whether the buffer is full.
     * It prints a message indicating that the enqueue motion can't be finished if the buffer is full.
     * If the buffer is not complete:
     * The rear index is updated by wrapping around and incrementing the rear index, using the
       modulooperator (%) and the buffer length.
     * The buffer's rear index receives the addition of the fact.
     * There is an increase in the buffer's element count.

Dequeueing an Element:
     * The dequeue feature is used when an element wishes to be removed from the buffer.
     * Using isBufferEmpty determines if the buffer is empty.
     * It prints a message mentioning that the dequeue operation cannot be accomplished if the buffer is
       empty.
     * If the buffer is not empty:
     * The front index data is retrieved.
     * The front index is updated using the modulo operator (%) and the buffer size to wrap around and
       increment the front index.
     * The buffer decrements the number of elements in it.
     * Data from the dequeue is returned.

How to Display the Buffer:
     * The displayBuffer function is used to print the buffer's contents.
     * Using isBufferEmpty determines if the buffer is empty.
     * It prints a message stating that the buffer is empty if it is empty.
     * If the buffer is not empty:
     * The buffer's factors are iterated using a for loop, starting at 0 and increasing to their general
       number.
     * The front index is extended with the aid of the cutting-edge iteration index to determine the
       actual index of each detail, which is then wrapped around the usage of the modulo operator% and
       the buffer size.
     * The records are printed at the calculated index.

Main Function:
     * The primary action is finished.
     * CreateCircularBuffer produces a round buffer.
     * Enqueue is used to enqueue elements with 10, 20, and 30 values.
     * DisplayBuffer is used to display the contents of the buffer.
     * Dequeue is used to dequeue an element, and the dequeued

Applications of Circular Buffer:
   There are various uses for circular buffers across numerous industries. The following are some
   typical uses for circular buffers:

   Data Streaming:Circular buffers are frequently employed in data streaming applications, which require
   the processing or transmitting of a steady stream of data. For instance, circular buffers can hold a
   fixed-size window of the incoming data in audio and video streaming, enabling continuous playback or
   processing.

   Communication Systems:Circular buffers store incoming and outgoing data packets in communication
   systems. They are frequently employed in serial communication, network protocols, and data
   transmission systems to manage data flow effectively.

   Device Drivers: Implementations of device drivers use circular buffers. Before the driver processes
   data from input/output devices like keyboards, mice, or sensors, they might be utilized to buffer
   information. This makes it possible to handle intermittent or sporadic data streams effectively.

   Audio Processing:Circular buffers are widely used in applications for audio processing, including
   real-time audio effects, mixing, and signal processing. They make it possible to buffer and process
   audio samples continuously and seamlessly.

   Embedded Systems: Circular buffers are frequently used in embedded systems with constrained processor
   and memory resources. They offer a productive method for cyclically managing and processing data,
   enabling continuous operation with less memory utilization.

   Producer-Consumer Scenarios: Circular buffers are perfect in settings with numerous producers and
   consumers. Offering a synchronized and thread-safe buffer makes transferring data between other
   threads or processes easier.

   Sensor Data Acquisition: Systems for capturing and processing data from various sensors in real-time
   employ circular buffers. They aid in effectively storing and processing incoming sensor data.

   Circular buffers are very helpful when a fixed-size data window needs to be maintained, such as in
   real-time applications or resource-constrained systems. They provide a smooth and cyclic storage
   system that effectively administers various producers, consumers, and data streams.

   Developers can create reliable and effective methods for regulating data flow, buffering, and
   processing by utilizing circular buffers, enabling the smooth operation of applications in various
   industries.

Merits of circular Buffer:
   Additional benefits or virtues of circular buffers include the following:

   Performance Predictability:Circular buffers have predictable performance characteristics,
   particularly for enqueuing and dequeuing processes. No matter how many elements are in the buffer,
   the execution time is the same because the temporal complexity of these operations is constant. This
   predictability is advantageous in real-time systems or applications where reliable performance is
   essential.

   Low Overhead: Circular buffers have low overhead regarding memory use and computational complexity.
   The elements must generally be stored in a fixed-size array, and a few variables are needed to keep
   track of the indices. Because buffer operations are so straightforward, there is little computational
   complexity and little memory overhead.

   Reduced Memory Fragmentation: Compared to dynamic data structures like linked lists or dynamic
   arrays, circular buffers reduce memory fragmentation. Circular buffers don't require frequent memory
   allocation and deallocation operations because they have a fixed size, which prevents memory
   fragmentation. This benefit is especially significant in contexts or systems with limited resources
   when effective memory utilization is essential.

   Cache Friendly:Circular buffers frequently display strong cache locality, which can enhance speed on
   contemporary computer systems. Contiguous element storage in the buffer enables effective CPU cache
   utilization, lowering the incidence of cache misses during access operations. Reduced memory access
   latency and increased overall performance can both be obtained from this cache-friendliness.

   Simpleness and Usability:Circular buffers have an intuitive design that makes them simple to
   comprehend and use. Circular buffers are approachable even for novice developers due to the simple
   implementation and precise semantics of enqueueing and dequeuing operations. This simplicity helps
   make the code more readable, maintainable, and less likely to introduce bugs or errors.

   Deterministic Resource Allocation: Circular buffers offer deterministic resource allocation. It is
   particularly useful in embedded systems or real-time applications. The memory needed for the buffer
   is known and is allocated upfront during initialization because the buffer size is fixed. The
   unpredictability and potential resource conflicts that can result from dynamic memory allocation or
   deallocation procedures are avoided by this deterministic allocation.

Demerits of Circular Buffer:
   The following are some potential drawbacks or restrictions of using circular buffers in C:

   Fixed Size Limitation:Circular buffers have a fixed size set during setup, which might be a problem
   when the buffer needs to hold a variety of elements or when the size of the buffer needs to be
   dynamically changed depending on runtime circumstances.

   Data Overwriting: The oldest element in a circular buffer is overwritten when the buffer is complete,
   and a new element is enqueued. While this behavior may occasionally be desired, if the rewritten data
   is crucial or required for further processing, it may result in data loss or inaccurate results.

   Sequential Access: It can be challenging to access non-sequential elements in a circular buffer (for
   instance, through random access or looking for a particular element). Comparatively, it involves
   iterating through the elements sequentially to other data structures intended for random access,
   which could lead to higher temporal complexity.

   Inefficient Space Utilisation: If the buffer size is within the typical amount of elements stored,
   circular buffers may experience efficient space utilization. A significant chunk of the buffer
   remains unused, which may lead to memory waste.

   Thread Synchronization Complexity: Implementing thread-safe circular buffers in multi-threaded
   environments can be complicated and have potential performance overhead because appropriate
   synchronization mechanisms, like locks or semaphores, are required to ensure thread safety when
   accessing and changing the buffer.

   Lack of Dynamic Memory Management: When initialized circular buffers, memory is allocated for the
   buffer array. It is released once the buffer is deleted. This absence of dynamic memory management
   can be problematic when memory use needs to be optimized, or the buffer needs to be dynamically
   enlarged based on runtime conditions.

   Inefficient for Large Buffers: There may be more effective options for huge buffers with a
   disproportionately high element than Circular buffers. The time needed for wraparound operations
   (incrementing and modulo computations) might become more apparent and affect overall performance as
   the buffer grows.



---

