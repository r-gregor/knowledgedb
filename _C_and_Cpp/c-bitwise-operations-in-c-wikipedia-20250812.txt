filename: c-bitwise-operations-in-c-wikipedia-20250812.txt
https://en.wikipedia.org/wiki/Bitwise_operations_in_C

Bitwise operations in C

In the C programming language, operations can be performed on a bit level using bitwise operators.

Bitwise operations are contrasted by byte-level operations which characterize the bitwise operators' logical
counterparts, the AND, OR, NOT operators. Instead of performing on individual bits, byte-level operators
perform on strings of eight bits (known as bytes) at a time. The reason for this is that a byte is normally
the smallest unit of addressable memory (i.e. data with a unique memory address).

This applies to bitwise operators as well, which means that even though they operate on only one bit at a
time they cannot accept anything smaller than a byte as their input.

All of these operators are also available in C++, and many C-family languages.

Bitwise operators

C provides six operators for bit manipulation.
------------------------------------------------
Symbol    Operator
------------------------------------------------
&         bitwise AND
|         bitwise inclusive OR
^         bitwise XOR (exclusive OR)
<<        left shift
>>        right shift
~         bitwise NOT (ones' complement) (unary)
------------------------------------------------

Bitwise AND &
---------------------------------
bit a    bit b    a & b (a AND b)
---------------------------------
0        0        0
0        1        0
1        0        0
1        1        1
---------------------------------

The bitwise AND operator is a single ampersand: &. It is just a representation of AND which does its work on
the bits of the operands rather than the truth value of the operands. Bitwise binary AND performs logical
conjunction (shown in the table above) of the bits in each position of a number in its binary form.

For instance, working with a byte (the char type):

     11001000
   & 10111000
     --------
   = 10001000

The most significant bit of the first number is 1 and that of the second number is also 1 so the most
significant bit of the result is 1; in the second most significant bit, the bit of second number is zero, so
we have the result as 0. 

Bitwise OR |
--------------------------------
bit a    bit b    a | b (a OR b)
--------------------------------
0        0        0
0        1        1
1        0        1
1        1        1
--------------------------------

Similar to bitwise AND, bitwise OR performs logical disjunction at the bit level. Its result is a 1 if either
of the bits is 1 and zero only when both bits are 0. Its symbol is | which can be called a pipe.

      11001000
    | 10111000
      --------
    = 11111000


Bitwise XOR ^
---------------------------------
bit a    bit b    a ^ b (a XOR b)
---------------------------------
0        0        0
0        1        1
1        0        1
1        1        0
---------------------------------

The bitwise XOR (exclusive or) performs an exclusive disjunction, which is equivalent to adding two bits and
discarding the carry. The result is zero only when we have two zeroes or two ones. XOR can be used to
toggle the bits between 1 and 0. Thus i = i ^ 1 when used in a loop toggles its values between 1 and 0.

      11001000
    ^ 10111000
      --------
    = 01110000

Shift operators
There are two bitwise shift operators. They are
  * Right shift (>>)
  * Left shift (<<)

Right shift >>
The symbol of right shift operator is >>. For its operation, it requires two operands. It shifts each bit in
its left operand to the right. The number following the operator decides the number of places the bits are
shifted (i.e. the right operand). Thus by doing ch >> 3 all the bits will be shifted to the right by three
places and so on.

However, do note that a shift operand value which is either a negative number or is greater than or equal to
the total number of bits in this value results in undefined behavior. For example, when shifting a 32 bit
unsigned integer, a shift amount of 32 or higher would be undefined.

Example:
    If the variable ch contains the bit pattern 11100101, then ch >> 1 will produce the result 01110010, and
    ch >> 2 will produce 00111001.

Here blank spaces are generated simultaneously on the left when the bits are shifted to the right. When
performed on an unsigned type or a non-negative value in a signed type, the operation performed is a logical
shift, causing the blanks to be filled by 0s (zeros). When performed on a negative value in a signed type,
the result is technically implementation-defined (compiler dependent), however most compilers will
perform an arithmetic shift, causing the blank to be filled with the set sign bit of the left operand.

Right shift can be used to divide a bit pattern by 2 as shown:
i = 14; // Bit pattern 00001110
j = i >> 1; // here we have the bit pattern shifted by 1 thus we get 00000111 = 7 which is 14/2

Right shift operator usage
Typical usage of a right shift operator in C can be seen from the following code.

Example:
#include <stdio.h>

void showbits( unsigned int x ) {
	int i=0;
	for (i = (sizeof(int) * 8) - 1; i >= 0; i--)
	{
	   putchar(x & (1u << i) ? '1' : '0');
	}
	printf("\n");
}

int main( void ) {
	int j = 5225;
	printf("%d in binary \t\t ", j);
	showbits(j);

	/* the loop for right shift operation */
	for (int m = 0; m <= 5; m++)
	{
		int n = j >> m;
		printf("%d right shift %d gives ", j, m);
		showbits(n);
	}
	return 0;
}

The output of the above program will be

5225 in binary           00000000000000000001010001101001
5225 right shift 0 gives 00000000000000000001010001101001
5225 right shift 1 gives 00000000000000000000101000110100
5225 right shift 2 gives 00000000000000000000010100011010
5225 right shift 3 gives 00000000000000000000001010001101
5225 right shift 4 gives 00000000000000000000000101000110
5225 right shift 5 gives 00000000000000000000000010100011

Left shift <<
The symbol of left shift operator is <<. It shifts each bit in its left-hand operand to the left by the
number of positions indicated by the right-hand operand. It works opposite to that of right shift operator.
Thus by doing ch << 1 in the above example (11100101) we have 11001010. Blank spaces generated are filled up
by zeroes as above.

However, do note that a shift operand value which is either a negative number or is greater than or equal to
the total number of bits in this value results in undefined behavior. This is defined in the standard at ISO
9899:2011 6.5.7 Bit-wise shift operators. For example, when shifting a 32 bit unsigned integer, a shift
amount of 32 or higher would be undefined.

Left shift can be used to multiply an integer by powers of 2 as in

int i = 7;    // Decimal 7 is Binary (2^2) + (2^1) + (2^0) = 0000 0111
int j = 3;    // Decimal 3 is Binary         (2^1) + (2^0) = 0000 0011
k = (i << j); // Left shift operation multiplies the value by 2 to the power of j in decimal
              // Equivalent to adding j zeros to the binary representation of i
              // 56 = 7 * 2^3
              // 0011 1000 = 0000 0111 << 0000 0011

Example: a simple addition program

The following program adds two operands using AND, XOR and left shift (<<).

#include <stdio.h>

int main( void ) {
	unsigned int x = 3, y = 1, sum, carry;
	sum = x ^ y; // x XOR y
	carry = x & y; // x AND y
	while (carry != 0)
	{
		carry = carry << 1; // left shift the carry
		x = sum; // initialize x as sum
		y = carry; // initialize y as carry
		sum = x ^ y; // sum is calculated
		carry = x & y; /* carry is calculated, the loop condition is
		                  evaluated and the process is repeated until
		                  carry is equal to 0.
		                */
	}
	printf("%u\n", sum); // the program will print 4
	return 0;
}

Bitwise assignment operators
C provides a compound assignment operator for each binary arithmetic and bitwise operation. Each operator
accepts a left operand and a right operand, performs the appropriate binary operation on both and stores the
result in the left operand.

The bitwise assignment operators are as follows.

-----------------------------------------
Symbol    Operator
-----------------------------------------
&=        bitwise AND assignment
|=        bitwise inclusive OR assignment
^=        bitwise exclusive OR assignment
<<=       left shift assignment
>>=       right shift assignment
-----------------------------------------

Logical equivalents
Four of the bitwise operators have equivalent logical operators. They are equivalent in that they have the
same truth tables. However, logical operators treat each operand as having only one value, either true or
false, rather than treating each bit of an operand as an independent value. Logical operators consider zero
false and any nonzero value true. Another difference is that logical operators perform short-circuit
evaluation.

The table below matches equivalent operators and shows a and b as operands of the operators.
-----------------
Bitwise   Logical
-----------------
a & b     a && b
a | b     a || b
a ^ b     a != b
~a        !a
-----------------

!= has the same truth table as ^ but unlike the true logical operators, by itself != is not strictly speaking
a logical operator. This is because a logical operator must treat any nonzero value the same. To be used as a
logical operator != requires that operands be normalized first. A logical not applied to both operands will
not change the truth table that results but will ensure all nonzero values are converted to the same value
before comparison. This works because ! on a zero always results in a one and ! on any nonzero value always
results in a zero.

Example:

/* Equivalent bitwise and logical operator tests */
#include <stdio.h>

void testOperator(char* name, unsigned char was, unsigned char expected);

int main( void ) {
	// -- Bitwise operators -- //

	//Truth tables packed in bits
	const unsigned char operand1    = 0x0A; //0000 1010
	const unsigned char operand2    = 0x0C; //0000 1100
	const unsigned char expectedAnd = 0x08; //0000 1000
	const unsigned char expectedOr  = 0x0E; //0000 1110
	const unsigned char expectedXor = 0x06; //0000 0110

	const unsigned char operand3    = 0x01; //0000 0001
	const unsigned char expectedNot = 0xFE; //1111 1110

	testOperator("Bitwise AND", operand1 & operand2, expectedAnd);
	testOperator("Bitwise  OR", operand1 | operand2, expectedOr);
	testOperator("Bitwise XOR", operand1 ^ operand2, expectedXor);
	testOperator("Bitwise NOT", ~operand3, expectedNot); 
	printf("\n");

	// -- Logical operators -- //

	const unsigned char F = 0x00; //Zero
	const unsigned char T = 0x01; //Any nonzero value

	// Truth tables packed in arrays

	const unsigned char operandArray1[4]    = {T, F, T, F};
	const unsigned char operandArray2[4]    = {T, T, F, F};
	const unsigned char expectedArrayAnd[4] = {T, F, F, F};
	const unsigned char expectedArrayOr[4]  = {T, T, T, F};
	const unsigned char expectedArrayXor[4] = {F, T, T, F};

	const unsigned char operandArray3[2]    = {F, T};
	const unsigned char expectedArrayNot[2] = {T, F};

	int i;
	for (i = 0; i < 4; i++)
	{
		testOperator("Logical AND", operandArray1[i] && operandArray2[i], expectedArrayAnd[i]);
	}
	printf("\n");

	for (i = 0; i < 4; i++)
	{
		testOperator("Logical  OR", operandArray1[i] || operandArray2[i], expectedArrayOr[i]);
	}
	printf("\n");

	for (i = 0; i < 4; i++)
	{
		//Needs ! on operand's in case nonzero values are different
		testOperator("Logical XOR", !operandArray1[i] != !operandArray2[i], expectedArrayXor[i]);
	}
	printf("\n");

	for (i = 0; i < 2; i++)
	{
		testOperator("Logical NOT", !operandArray3[i], expectedArrayNot[i]);
	}
	printf("\n");

	return 0;
}

void testOperator( char* name, unsigned char was, unsigned char expected ) {
	char* result = (was == expected) ? "passed" : "failed";
	printf("%s %s, was: %X expected: %X \n", name, result, was, expected);
}

The output of the above program will be

 Bitwise AND passed, was: 8 expected: 8
 Bitwise  OR passed, was: E expected: E
 Bitwise XOR passed, was: 6 expected: 6
 Bitwise NOT passed, was: FE expected: FE

 Logical AND passed, was: 1 expected: 1
 Logical AND passed, was: 0 expected: 0
 Logical AND passed, was: 0 expected: 0
 Logical AND passed, was: 0 expected: 0

 Logical  OR passed, was: 1 expected: 1
 Logical  OR passed, was: 1 expected: 1
 Logical  OR passed, was: 1 expected: 1
 Logical  OR passed, was: 0 expected: 0

 Logical XOR passed, was: 0 expected: 0
 Logical XOR passed, was: 1 expected: 1
 Logical XOR passed, was: 1 expected: 1
 Logical XOR passed, was: 0 expected: 0

 Logical NOT passed, was: 1 expected: 1
 Logical NOT passed, was: 0 expected: 0


---

