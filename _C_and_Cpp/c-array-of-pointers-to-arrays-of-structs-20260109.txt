filename: c-array-of-pointers-to-arrays-of-structs-20260109.txt
https://www.reddit.com/r/C_Programming/comments/vsa20a/an_array_of_pointers_to_arrays_of_structs/

An array of pointers to arrays of structs

So I have struct called Pixel:

struct Pixel {
	unsigned int r;
	unsigned int g;
	unsigned int b;
};

... and letters defined as arrays of pixels

struct Pixel A [25] = {
	{255,255,255},{255,255,255},{0,0,0},{255,255,255},{255,255,255},
	{255,255,255},{0,0,0},{255,255,255},{0,0,0},{255,255,255},
	{255,255,255},{0,0,0},{255,255,255},{0,0,0},{255,255,255},
	{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
	{0,0,0},{255,255,255},{255,255,255},{255,255,255},{0,0,0}
};

Now I need an array of pointers to the letters. I understand how to create pointers to array of pixels.
struct Pixel (*Ascii) [25];

But not how to create a array of those pointers?

***
Something I noticed about your code. If you only plan to have values from 0 to 255 inside the pixel structure,
you could use the type unsigned char instead, which would reduce the amount of memory used by about 75%.
unsigned char has a range from 0 to 255, while unsigned int has a range from 0 to about 4 billion.

***
#include <stddef.h>

struct Pixel {
	unsigned int r;
	unsigned int g;
	unsigned int b;
};

struct Pixel font_table[26][25] = {\
	// A
	{
		{255,255,255},{255,255,255},{0,0,0},{255,255,255},{255,255,255},
		{255,255,255},{0,0,0},{255,255,255},{0,0,0},{255,255,255},
		{255,255,255},{0,0,0},{255,255,255},{0,0,0},{255,255,255},
		{0,0,0},{0,0,0},{0,0,0},{0,0,0}, // {0,0,0},   /// 6??????????
		{0,0,0},{255,255,255},{255,255,255},{255,255,255},{0,0,0}
	},

	// B
	{
		{0},
		//... etc ...
	},

	// C
	{
		{0}, //.. etc
	},
};

int whatever() {
	for (size_t letter_index = 0; letter_index < 26; letter_index++) {
		struct Pixel *letter = font_table[letter_index];
		for (size_t pixel_index = 0; pixel_index < (5*5); pixel_index++) {
			// pPixel is probably better as you're not "copying"
			// the data into a local struct instance
			struct Pixel pixel = letter[pixel_index];
			struct Pixel *pPixel = &letter[pixel_index];
			// do stuff with your pixel
		}
	}

	return 0;
}

***
It seems like your "Pixel" type for declaring the letters could be a single bit.

And then I got bored and did the following. I still don't know why... I'll just post it in case you find it
inspirational. Hopefully I didn't take it too far from your own idea, I tried not to.

#include <stdio.h>
#include <stdint.h>
#include <assert.h>
#include <string.h>

#define LETTER_WIDTH    5
#define LETTER_HEIGHT   5

const uint8_t letters_mask[][LETTER_HEIGHT][LETTER_WIDTH] = {
	{ // A
		{ 0, 0, 1, 0, 0},
		{ 0, 1, 0, 1, 0},
		{ 0, 1, 0, 1, 0},
		{ 1, 1, 1, 1, 1},
		{ 1, 0, 0, 0, 1},
	},

	{ // B
		{ 1, 1, 1, 0, 0},
		{ 1, 0, 0, 1, 0},
		{ 1, 1, 1, 0, 0},
		{ 1, 0, 0, 1, 0},
		{ 1, 1, 1, 0, 0},
	},
	// ...
};

struct Pixel {
	uint8_t r;
	uint8_t g;
	uint8_t b;
};

#define SCREEN_WIDTH    12
#define SCREEN_HEIGHT   10
struct Pixel screen[SCREEN_HEIGHT][SCREEN_WIDTH];

void draw_letter(int x, int y, char letter, const struct Pixel * fg_color, const struct Pixel * bg_color) {
	assert(letter >= 'A');
	uint8_t letter_ix = letter - 'A';
	assert(letter_ix < (sizeof(letters_mask)/LETTER_HEIGHT/LETTER_WIDTH));

	for (int py=0; py<LETTER_HEIGHT; py++) {
		for (int px=0; px<LETTER_WIDTH; px++) {
			if (py > SCREEN_HEIGHT || px > SCREEN_WIDTH) continue;
			if (letters_mask[letter_ix][py][px]) {
				screen[y + py][x + px].r = fg_color->r;
				screen[y + py][x + px].g = fg_color->g;
				screen[y + py][x + px].b = fg_color->b;
			} else {
				screen[y + py][x + px].r = bg_color->r;
				screen[y + py][x + px].g = bg_color->g;
				screen[y + py][x + px].b = bg_color->b;
			}
		}
	}
}

void draw_string(int x, int y, const char * str, const struct Pixel * fg_color, const struct Pixel * bg_color) {
	while (*str != 0) {
		draw_letter(x, y, *(str++), fg_color, bg_color);
		x += LETTER_WIDTH + 1;
	}
}

void print_screen(void) {
	for (int y = 0; y < SCREEN_HEIGHT; y++) {
		for (int x = 0; x < SCREEN_WIDTH; x++) {
			printf("%02X%02X%02X ", screen[y][x].r, screen[y][x].g, screen[y][x].b);
		}
		printf("\n");
	}
}

const struct Pixel black = { 0x00, 0x00, 0x00 };
const struct Pixel white = { 0xFF, 0xFF, 0xFF };

int main() {
	memset(screen, 0xFF, sizeof(screen));
	print_screen();
	printf("\n\n");
	draw_string(1, 2, "AB", &black, &white);
	print_screen();

	return 0;
}

***
Arrays are pointers, basically. So if one letter is an array of pixels, then it's a struct Pixel * letter. An
array of letters would be a pointer to a pointer: struct Pixel ** letters. So, one letter (a pointer to a
bunch of pixels) can be retrieved like this: struct Pixel * letter = letters[0];.

***
No, arrays are arrays. They just freely convert to pointers to their first element.

***
Thank's ... solved it with struct Pixel ((*Ascii) [25]) [128];

***
Here (*Ascii)[25] denotes an array of 25 elements, each element being of type struct Pixel [128]. Thus Ascii
itself is a pointer to an array of 25 elements, but each such element is not a letter, it is a struct
Pixel[128].

Are you certain this is the requirement? Because as per your question, each letter is of type struct Pixel
[25], and it seems you need an array of size 128 where each element is a letter.

It seems to me that the solution required here is struct Pixel * letters[128]. Here letters is an array of
size 128, each element of type struct Pixel *. As arrays decay into pointers, you can do the following:
struct Pixel a[25] = {...}; letters[0] = a.

Another distinct (and possibly roundabout) approach is to use typedef, as shown below.

typedef struct Pixel letter_t[25];
letter_t a = { /* pixels */ }; // pixels for lowercase a
/* more letters */
letter_t *letters[128]; // array of 128 "pointer to letter_t"
letters[0] = &a; // first element is pointer to letter_t a
*letters[0]; // a itself, i.e. array of 25 pixels
(*letters[0])[0]; // first pixel of letter a
(*letters[0])[0].r; // r value of first pixel of letter a

You can use the one which seems conceptually simpler or clearer (I'd myself prefer the first approach though).

***
struct Pixel ((*Ascii) [25]) [128]; didn't actually work I thought it did because the compiler didn't say
there were any syntax errors but when I tried accessing something other than Ascii[0] there was a seg fault.
although

struct Letter {struct Pixel (*CHAR) [25];};
struct Letter CHARSET [128] {};

seems to solve the issue.


---

