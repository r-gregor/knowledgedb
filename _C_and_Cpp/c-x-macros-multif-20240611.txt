filename: c_x-macros-multif_20240611.txt
https://www.geeksforgeeks.org/x-macros-in-c/

X-Macros in C
16 Apr, 2019

   X-Macros are based on the property of nested macros and the ability to define macros inside other
   macros. X-Macros are very powerful pre-processor technique in the sense that it can create a
   self-maintaining and inter-dependent piece of code. When the change of one part of a program leads to
   a change in another part, then the code is said to be inter-dependent.

   Syntax:
   An X macro application consists of two parts:
	 * The definition of the list's elements:
#define VARIABLES \
	X(value1, 1)  \
	.
	.
	.  \
	X(valueN, N)

	 * Expansion(s) of the list to generate fragments of declarations or statements:
#define X(name) int name;
	VARIABLES
#undef X

   The list is defined by a macro or header file (named, VARIABLES) which generates no code by itself,
   but merely consists of a sequence of invocations of a macro (classically named "X") with the
   elements' data. Each expansion of VARIABLES is preceded by a definition of X with the syntax for a
   list element. The invocation of VARIABLES expands X for each element in the list.

   Implementations:
	 * Example 1: Following Code explains the working of X-Macros:

#include <stdio.h>
// Defines four variables.

#define VARIABLES    \
	   X(value1, 1)  \
	   X(value2, 2)  \
	   X(value3, 3)  \
	   X(value4, 4)


// driver program.
int main(void) {
	// Declaration of every variable
	// is done through macro.
	#define X(value, a) char value[10];
		VARIABLES
	#undef X

	// String values are accepted
	// for all variables.
	#define X(value, a) scanf("\n%s", value);
		VARIABLES
	#undef X

	// Values are printed.
	#define X(value, a) printf("%d) %s\n", a, value);
		VARIABLES
	#undef X

	return 0;
}


Output:
1) geeks
2) for
3) geeks
4) geeksforgeeks

   In the above code addition of one or more variables in the Macro "VARIABLES" will lead to its
   automatic declaration, scanning as well as printing. This simple example clears the working and
   power of X-Macros. After expansion the above code will look like the code below:

#include <stdio.h>


int main(void) {
	char value1[10];
	char value2[10];
	char value3[10];
	char value4[10];

	scanf("\n%s", value1);
	scanf("\n%s", value2);
	scanf("\n%s", value3);
	scanf("\n%s", value4);

	printf("%d) %s\n", 1, value1);
	printf("%d) %s\n", 2, value2);
	printf("%d) %s\n", 3, value3);
	printf("%d) %s\n", 4, value4);

	return 0;
}


Output:
1) geeks
2) for
3) geeks
4) geeksforgeeks

   Although the above code simply explains the power of X-Macros, such use is rare and not
   recommended because it makes the code less readable. A more practical example is with enum or
   jump tables.

* Example 2: Following code explains the working of X-Macros with enum:

#include <stdio.h>

// Defining a macro
// with the values of colors.

#define COLORS \
	X(RED)     \
	X(BLACK)   \
	X(WHITE)   \
	X(BLUE)

// Creating an enum of colors
// by macro expansion.
enum colors {
	#define X(value) value,
		COLORS
	#undef X
};


// A utility that takes the enum value
// and returns corresponding string value

char* toString(enum colors value) {
	switch (value) {
		#define X(color) \
			case color:  \
				return #color;
				COLORS
		#undef X
	}
}


// driver program.

int main(void) {
	enum colors color = WHITE;
	printf("%s", toString(color));

	return 0;
}


	   Output:
WHITE

    In the above code, any addition or removal of any constant from the COLORS macro will
    automatically reflect in the definition of enum as well as toString() function. Which is why
    X-Macros are used to produce self-maintaining codes. After macro expansion above code will look
    like the code below:

#include <stdio.h>

// Creating an enum of colors.

enum colors {
	RED,
	BLACK,
	WHITE,
	BLUE
};

/* A utility that takes the enum value and returns corresponding string value */

char* toString(enum colors value) {

	switch (value) {
		case RED:
			return "RED";

		case BLACK:
			return "BLACK";

		case WHITE:
			return "WHITE";

		case BLUE:
			return "BLUE";
	}
}


// driver program.

int main(void) {

	enum colors color = WHITE;
	printf("%s", toString(color));

	return 0;
}


    Output:
WHITE

   Advantages of X-Macros
     * X-Macros are extensively used in Operating System development by creating separate header files
       for maintainability as well as readability
     * Helps to maintain complex programming easily
     * it can create a self-maintaining and inter-dependent piece of code

   Disadvantages of X-Macros
     * The code becomes less readable
     * Code is complex to understand
     * Commonly used for internal programming only, like OS programming.

   Reference: https://en.wikipedia.org/wiki/X_Macro



---
https://quuxplusone.github.io/blog/2021/02/01/x-macros/

What are X-macros?

   "X-macros" is a neat C and C++ technique that doesn't get enough advertisement. Here's the basic
   idea:

   Suppose we have a table of similar records, each with the same schema. In games, this might be our
   collection of monster types (each with a display name, a representative icon, a dungeon level, a
   bitmask of special attack types, etc). In networking, this might be our collection of error codes
   (each with an integer value, a message string, etc).

   We could encode that information into a data structure that we traverse at runtime to produce
   interesting effects - for example, an array of structs that we index into or loop over to answer a
   question like "What is the error string for this enumerator?" or "How many monsters have dungeon
   level 3?".

   But the "X-macros" technique is to encode that information in source code, which can be manipulated
   at compile time. We encode the information generically, without worrying about how it might be
   "stored" at runtime, because we're not going to store it - it's just source code! We encode it
   something like this:

// in file "errorcodes.h"
X(EPERM,  1, "Operation not permitted")
X(ENOENT, 2, "No such file or directory")
X(ESRCH,  3, "No such process")
X(EINTR,  4, "Interrupted system call")

// in file "monsters.h"
X(dwarf,      'h', 2, ATK_HIT,  0)
X(kobold,     'k', 2, ATK_HIT,  IMM_POISON)
X(elf,        '@', 3, ATK_HIT,  0)
X(centipede,  'c', 3, ATK_BITE, 0)
X(orc,        'o', 4, ATK_HIT,  IMM_POISON)

   Now we've got a header file that encodes in source code all the data you might want about your error
   codes, or monsters, or whatever. If you need an enumeration type for your monsters, that's easy to
   whip up:

enum Monster {
	#define X(name,b,c,d,e) MON_##name,
	#include "monsters.h"
	#undef X
};

Monster example = MON_centipede;

   Instead of array indexing, X-macros push you toward switch as your fundamental building block:

bool is_immune_to_poison(Monster m) {
	switch (m) {
		#define X(name,b,c,d,imm) case MON_##name: return (imm == IMM_POISON);
		#include "monsters.h"
		#undef X
	}
}

   Instead of looping over the whole collection (say, from MON_first to MON_last), X-macros push you
   toward writing straight-line code that unrolls the loop:

int count_monsters_of_level(int target_level) {
	int sum = 0;
	#define X(a,b,level,d,e) sum += (level == target_level);
	#include "monsters.h"
	#undef X
	return sum;
}

   Or even this:
int number_of_monster_types() {
	return 0
	#define X(a,b,c,d,e) +1
	#include "monsters.h"
	#undef X
	;
}

Variations, upsides, downsides
   The name "X-macros" comes from the stereotypical name of the macro in question; but of course the
   macro doesn't have to be named X. In fact, at least two of the examples below use multiple macros
   (for different kinds of data records) intermixed in the same file.

   A few commenters on this post have shown a variation on this technique, which is also reproduced
   (more or less) on the relatively low-quality Wikipedia page on X-macros:
// in file "monsters.h"
#pragma once
#define LIST_OF_MONSTERS(X)                \
X(dwarf, 'h', 2, ATK_HIT, 0)               \
X(kobold, 'k', 2, ATK_HIT, IMM_POISON)     \
X(elf, '@', 3, ATK_HIT, 0)                 \
X(centipede, 'c', 3, ATK_BITE, 0)          \
X(orc, 'o', 4, ATK_HIT, IMM_POISON)

// in the caller's code
#include "monsters.h"
#define X_IMM_POISON(name,b,c,d,imm) case MON_##name: return (imm == IMM_POISON);
bool is_immune_to_poison(Monster m) {
	switch (m) {
		LIST_OF_MONSTERS(X_IMM_POISON)
	}
}

   I suppose one advantage of this variation is that it makes "monsters.h" idempotent. This lets you
   put the #include directive up at the top of the caller's file, next to #include <stdio.h> and so on.
   A big disadvantage (or so I would think) is that by putting the whole list into the macro expansion
   of LIST_OF_MONSTERS, you're probably harming the quality of error messages and debug info you'll get,
   and may even overwhelm your compiler's internal limit on the size of a macro expansion. You also have
   to come up with a name for the macro LIST_OF_MONSTERS, and make sure it never collides with anything
   in the entire rest of your codebase. (In the original, there are no global names: the name X never
   leaks outside the immediate context of "monsters.h"). You also have to remember to type all those
   backslashes in "monsters.h". Personally, I would avoid this variation.

   It occurs to me that this variation is to my preferred variation more or less as a named function is
   to a lambda-expression.

   A downside of the technique (either variation) is that each user of "monsters.h" must know the arity
   of X. If we decide that each monster also needs a boolean flag for intelligence, then not only do we
   have to change "monsters.h" to set that flag for each monster-

// in file "monsters.h"
X(dwarf,     'h', 2, ATK_HIT,  0,           true)
X(kobold,    'k', 2, ATK_HIT,  IMM_POISON, true)
X(elf,       '@', 3, ATK_HIT,  0,           true)
X(centipede, 'c', 3, ATK_BITE, 0,           false)
X(orc,       'o', 4, ATK_HIT,  IMM_POISON, true)

   -but we also have to change every single call-site to add a sixth parameter to the definition of X,
   even if it's irrelevant to most callers:

bool is_immune_to_poison(Monster m) {
	switch (m) {
#define X(name,b,c,d,imm,f) case MON_##name: return (imm == IMM_POISON);
#include "monsters.h"
#undef X
	}
}

   If this had used a lookup in a runtime data structure, like return (monsters[m].imm == IMM_POISON),
   then we could have added an "intelligence" field to the monster schema without needing a source-code
   change here.

   Another downside is that if you have a lot - say, thousands - of data records, then X-macros will
   lead you to write a lot of "unrolled loops" consisting of thousands of C++ statements. The compiler
   might struggle to deal with these. See for example "The surprisingly high cost of static-lifetime
   constructors" (2018-06-26).

Examples of X-macros in real code
   My (incomplete) port of Luckett & Pike's Adventure II uses X-macros in "locs.h", included three
   times from "adv440.c". This was a hack to get the game to fit into the Z-machine's memory, which
   has very little space for native C data such as arrays of char, but essentially infinite space for
   text if all you're doing is printing it out. So I used X-macros here to rewrite a few trivial but
   space-hogging functions of the form

puts(places[loc].short_desc);

   into tedious-looking, but extremely space-efficient, switch tables of the form

switch (loc) {
	case R_ROAD: puts("You're at the end of the road again."); break;
	case R_HILL: puts("You're at the hill in road."); break;
	case R_HOUSE: puts("You're inside the building."); break;
	...
}

   NetHack uses a variation on X-macros in "artilist.h"; the variation is that "artilist.h"
   itself

   checks to see where it's being included from and will define A appropriately for that includer,
   instead of making the includer define A themselves.

   HyperRogue uses X-macros for its monsters, items, and terrain, in "content.cpp"; you can see some
   of the ways it's included from "classes.cpp" and "landlock.cpp".



---
https://www.embedded.com/reduce-c-language-coding-errors-with-x-macros-part-1/

Reduce C-language coding errors with X macros - Part 1
January 1, 2013

Editor's note: Andrew Lucas describes how to use X macros to take advantage of the C-language pre-processor
to eliminate several classes of common bugs. He also describes how to use X macros to improve developer
productivity through automatic code generation.

X macros are a powerful coding technique that makes extensive use of the C-language pre-processor . This
technique has the capability to eliminate several classes of common bugs.

It seems to me that the C preprocessor gets a bad rap. Granted, there are ways to use the preprocessor
inappropriately, but to limit its use because of that constrains a valuable tool that can reduce coding
errors and improve developer productivity though automatic code generation.

Code Ordering Dependencies
I discovered X macros a few years ago when I started making use of function pointers in my code. Frequently
I would write code like this:

/* declare an enumeration of state codes */
enum{STATE_0, STATE_1, STATE_2, ... , STATE_N, NUM_STATES};

/* declare a table of function pointers */
p_func_t jumptable[NUM_STATES] = {func_0, func_1, func_2, ... , func_N};

The issue with this type of code is maintainability. The ordering of the array initializers has to
match the ordering of the state code enumeration exactly. Historically I would comment this type of code
liberally to warn future users about this dependency, but protection based on commenting is really no
protection at all. What I needed was a tool that would automatically enforce the dependency.

I began investigating solutions for this problem and discovered that in the C99 standard there was a
new way to initialize arrays. An improved way to write the above code is as follows:

/* declare an enumeration of state codes */
enum{STATE_0, STATE_1, STATE_2, ... , STATE_N, NUM_STATES}

/* declare a table of function pointers */
p_func_t jumptable[NUM_STATES] = {
	[STATE_1] = func_1,
	[STATE_0] = func_0,
	[STATE_2] = func_2,
	... ,
	[STATE_N] = func_N
};

Now even if I change the ordering of the enumeration, the jumptable logic doesn't break. Much better. My
only problem was that the C compiler I was working with was not compliant with the C99 standard. Back
to square one.

X macros to the Rescue
One day while talking shop with a friend of mine, I explained my problem and he suggested using the C
preprocessor to enforce the ordering. He explained the basic concept: Use preprocessor directives to
define a table in the form of a macro and then redefine how the macro is expanded, as required.
Here's how this technique enforces my code ordering dependency:

#define STATE_TABLE
	ENTRY(STATE_0, func_0)
	ENTRY(STATE_1, func_1)
	ENTRY(STATE_2, func_2)
	...
	ENTRY(STATE_X, func_X)

/* declare an enumeration of state codes */
enum{
#define ENTRY(a,b) a,
	STATE_TABLE
#undef ENTRY
	NUM_STATES
};

/* declare a table of function pointers */
p_func_t jumptable[NUM_STATES] = {
#define ENTRY(a,b) b,
	STATE_TABLE
#undef ENTRY
};

In the case of the enumeration the table expands to 'a' which is the first column of the state table;
the state code. In the case of the array, the table expands to 'b' which is the second column,
the name of the function pointer.

The code based on the X macro table is expanded in the same order for both the enumeration and the
array. The preprocessor now enforces the dependency!

Cleaning up the code
One thing I don't like about this implementation is the presence of #define and #undef throughout the code,
which to me is ugly and makes the code less readable. Let's look at a technique for getting rid of them.

You will notice that in my definition of the STATE_TABLE macro I don't take any parameters. There is
nothing to prevent me from passing the definition of ENTRY directly to the STATE_TABLE macro instead of
defining it separately:

#define EXPAND_AS_ENUMERATION(a,b) a,
#define EXPAND_AS_JUMPTABLE(a,b) b,
#define STATE_TABLE(ENTRY)
	ENTRY(STATE_0, func_0)
	ENTRY(STATE_1, func_1)
	ENTRY(STATE_2, func_2)
	...
	ENTRY(STATE_X, func_X)

/* declare an enumeration of state codes */
enum{
	STATE_TABLE(EXPAND_AS_ENUMERATION)
	NUM_STATES
}

/* declare a table of function pointers */
p_func_t jumptable[NUM_STATES] = {
	STATE_TABLE(EXPAND_AS_JUMPTABLE)
}:

Much better, but is there anything else that we could use the X macro table for? Since every function
pointer corresponds to an actual function, we could use the table to generate function prototypes for us:

#define EXPAND_AS_PROTOTYPES(a,b) static void b(void);
STATE_TABLE(EXPAND_AS_PROTOTYPES) ;

Now I no longer need to remember to add a prototype when I add new states. The preprocessor can take
care of it and will expand the table into the following code automatically:

static void func_0(void);
static void func_1(void);
static void func_2(void);
...
static void func_X(void);

Register Initialization
That's not the only way X macros can be used. In my code I commonly have to interface to custom
FPGAs. These devices usually have many memory mapped registers that need initialization. It's easy to
forget to initialize a newly defined register, but using X macros, this is another task we can automate.

#define EXPAND_AS_INITIALIZER(a,b) a = b;
#define REGISTER_TABLE(ENTRY)
	ENTRY(reg_0, 0x11)
	ENTRY(reg_1, 0x55)
	ENTRY(reg_2, 0x1b)
	...
	ENTRY(reg_X, 0x33)
static void init_registers(void){
	REGISTER_TABLE(EXPAND_AS_INITIALIZER)
}

Simple; and as new registers are added, no code needs to be updated to initialize it - we just add
a row to the table and the preprocessor does the rest. We can further improve this code to take into
account not only the initialization, but the declaration of the registers:

#define FPGA_ADDRESS_OFFSET (0x8000)
#define EXPAND_AS_INITIALIZER(a,b,c) a = c;
#define EXPAND_AS_DECLARATION(a,b,c) volatile uint8_t a _at_ b;
#define REGISTER_TABLE(ENTRY)
	ENTRY(reg_0, FPGA_ADDRESS_OFFSET + 0, 0x11)
	ENTRY(reg_1, FPGA_ADDRESS_OFFSET + 1, 0x55)
	ENTRY(reg_2, FPGA_ADDRESS_OFFSET + 2, 0x1b)
	...
	ENTRY(reg_X, FPGA_ADDRESS_OFFSET + X, 0x33)

/* declare the registers */
REGISTER_TABLE(EXPAND_AS_DECLARATION)

This code uses a compiler specific directive _at_ to place the variables at absolute addresses. This may
not be possible with other compilers. Secondly, more than one table may be required to take into account
different types of register declarations. You may need to have a read-only register table, a write-only
register table, an uninitialized register table, etc.

I hope that this introduction to X macros has provided a glimpse into the power of this coding technique. In
Part 2 I dig a little deeper and show some more advanced uses of X macros to facilitate automatic code
generation.

X macros are a powerful coding technique that makes extensive use of the C-language pre-processor
(http://en.wikipedia.org/wiki/C_preprocessor). This technique has the capability to eliminate several
classes of common bugs.

It seems to me that the C preprocessor gets a bad rap. Granted, there are ways to use the preprocessor
inappropriately, but to limit its use because of that constrains a valuable tool that can reduce coding
errors and improve developer productivity though automatic code generation.

Code Ordering Dependencies
I discovered X macros a few years ago when I started making use of function pointers in my code. Frequently
I would write code like this:

/* declare an enumeration of state codes */
enum{STATE_0, STATE_1, STATE_2, ... , STATE_N, NUM_STATES};

/* declare a table of function pointers */
p_func_t jumptable[NUM_STATES] = {func_0, func_1, func_2, ... , func_N};

The issue with this type of code is maintainability. The ordering of the array initializers has to
match the ordering of the state code enumeration exactly. Historically I would comment this type of code
liberally to warn future users about this dependency, but protection based on commenting is really no
protection at all. What I needed was a tool that would automatically enforce the dependency.

I began investigating solutions for this problem and discovered that in the C99 standard there was a
new way to initialize arrays. An improved way to write the above code is as follows:

/* declare an enumeration of state codes */
enum{STATE_0, STATE_1, STATE_2, ... , STATE_N, NUM_STATES};

/* declare a table of function pointers */
p_func_t jumptable[NUM_STATES] = {
	[STATE_1] = func_1,
	[STATE_0] = func_0,
	[STATE_2] = func_2,
	... ,
	[STATE_N] = func_N
};

Now even if I change the ordering of the enumeration, the jumptable logic doesn't break. Much better. My
only problem was that the C compiler I was working with was not compliant with the C99 standard. Back
to square one.

X macros to the Rescue
One day while talking shop with a friend of mine, I explained my problem and he suggested using the C
preprocessor to enforce the ordering. He explained the basic concept: Use preprocessor directives to
define a table in the form of a macro and then redefine how the macro is expanded, as required.
Here's how this technique enforces my code ordering dependency:

#define STATE_TABLE
	ENTRY(STATE_0, func_0)
	ENTRY(STATE_1, func_1)
	ENTRY(STATE_2, func_2)
	...
	ENTRY(STATE_X, func_X)

/* declare an enumeration of state codes */
enum{
#define ENTRY(a,b) a,
	STATE_TABLE
#undef ENTRY
	NUM_STATES
};

/* declare a table of function pointers */
p_func_t jumptable[NUM_STATES] = {
#define ENTRY(a,b) b,
	STATE_TABLE
#undef ENTRY
};

In the case of the enumeration the table expands to 'a' which is the first column of the state table;
the state code. In the case of the array, the table expands to 'b' which is the second column,
the name of the function pointer.

The code based on the x-macro table is expanded in the same order for both the enumeration and the
array. The preprocessor now enforces the dependency!

Cleaning up the code
One thing I don't like about this implementation is the presence of #define and #undef throughout the code,
which to me is ugly and makes the code less readable. Let's look at a technique for getting rid of them.

You will notice that in my definition of the STATE_TABLE macro I don't take any parameters. There is
nothing to prevent me from passing the definition of ENTRY directly to the STATE_TABLE macro instead of
defining it separately:

#define EXPAND_AS_ENUMERATION(a,b) a,
#define EXPAND_AS_JUMPTABLE(a,b) b,
#define STATE_TABLE(ENTRY)
	ENTRY(STATE_0, func_0)
	ENTRY(STATE_1, func_1)
	ENTRY(STATE_2, func_2)
	...
	ENTRY(STATE_X, func_X)

/* declare an enumeration of state codes */
enum{
	STATE_TABLE(EXPAND_AS_ENUMERATION);
	NUM_STATES
};

/* declare a table of function pointers */
p_func_t jumptable[NUM_STATES] = {
	STATE_TABLE(EXPAND_AS_JUMPTABLE);
};

Much better, but is there anything else that we could use the x-macro table for? Since every function
pointer corresponds to an actual function, we could use the table to generate function prototypes for us:

#define EXPAND_AS_PROTOTYPES(a,b) static void b(void);
STATE_TABLE(EXPAND_AS_PROTOTYPES);

Now I no longer need to remember to add a prototype when I add new states. The preprocessor can take
care of it and will expand the table into the following code automatically:

static void func_0(void);
static void func_1(void);
static void func_2(void);
...
static void func_X(void);

Register Initialization
That's not the only way X macros can be used. In my code I commonly have to interface to custom
FPGAs. These devices usually have many memory mapped registers that need initialization. It's easy to
forget to initialize a newly defined register, but using X macros, this is another task we can automate.

#define EXPAND_AS_INITIALIZER(a,b) a = b;
#define REGISTER_TABLE(ENTRY)
	ENTRY(reg_0, 0x11)
	ENTRY(reg_1, 0x55)
	ENTRY(reg_2, 0x1b)
	...
	ENTRY(reg_X, 0x33)

static void init_registers(void){
	REGISTER_TABLE(EXPAND_AS_INITIALIZER);
};

Simple; and as new registers are added, no code needs to be updated to initialize it - we just add
a row to the table and the preprocessor does the rest. We can further improve this code to take into
account not only the initialization, but the declaration of the registers:

#define FPGA_ADDRESS_OFFSET (0x8000)
#define EXPAND_AS_INITIALIZER(a,b,c) a = c;
#define EXPAND_AS_DECLARATION(a,b,c) volatile uint8_t a _at_ b;
#define REGISTER_TABLE(ENTRY)
	ENTRY(reg_0, FPGA_ADDRESS_OFFSET + 0, 0x11)
	ENTRY(reg_1, FPGA_ADDRESS_OFFSET + 1, 0x55)
	ENTRY(reg_2, FPGA_ADDRESS_OFFSET + 2, 0x1b)
	...
	ENTRY(reg_X, FPGA_ADDRESS_OFFSET + X, 0x33)

/* declare the registers */
REGISTER_TABLE(EXPAND_AS_DECLARATION);

This code uses a compiler specific directive _at_ to place the variables at absolute addresses. This may
not be possible with other compilers. Secondly, more than one table may be required to take into account
different types of register declarations. You may need to have a read-only register table, a write-only
register table, an uninitialized register table, etc.

I hope that this introduction to X macros has provided a glimpse into the power of this coding technique. In
a future article I plan to dig a little deeper and show some more advanced uses of X macros to facilitate
automatic code generation.


---
https://www.embedded.com/reduce-c-language-coding-errors-with-x-macros-part-2/

Reduce C- language coding errors with X-macros - Part 2
January 20, 2013

This article continues the discussion in Part 1 regarding the use of X macros. Here I will examine
several more uses of X macros that relieve the programmer from having to manually enforce dependencies
and perform data structure sizing calculations.

Counting Entries
Consider  the following use case for populating enumerations and jump tables:

/* declare an enumeration of state codes */
enum{
	STATE_TABLE(EXPAND_AS_ENUMERATION)
	NUM_STATES
}

/* declare a table of function pointers */
p_func_t jumptable[NUM_STATES] = {
	STATE_TABLE(EXPAND_AS_JUMPTABLE)
}

There is one thing that I still don't like about this implementation; the NUM_STATES hack. I call it a
hack because although a common technique for defining a count of items, NUM_STATES does not belong inside
the enumeration. We could define it as a separate macro, but this requires the developer to remember to
update it whenever the enumeration changes.

We can use X macros to place the NUM_STATES macro outside of the enumeration, while at the same time
have the pre-processor update it automatically. We start off by declaring a struct as follows:

#define EXPAND_AS_STRUCT(a,b) uint8_t b,
/* declare a struct with a 1-byte field for every entry */
typedef struct{
	STATE_TABLE(EXPAND_AS_STRUCT)
} size_struct_t ;

Now if we apply the size of operator to this struct, the compiler will calculate the number of states, since
each state is represented by a one-byte field and the sizeof operator returns the total number of bytes:

#define NUM_STATES sizeof(size_struct_t)

The concept is that there are valid reasons to define a struct but not instantiate it. We don't need
to create a variable of type size_struct_t for it to be useful.
A little more verbose perhaps than the previous hack, but we succeeded in having the preprocessor
automatically generate a NUM_STATES macro without having to pollute the enumeration. A note of caution;
this method depends on the compiler not inserting any padding bytes into size_struct_t , so understand
your compiler.

Communication Handlers
In my mind this is the "killer app" when it comes to X macro usage. The benefit it provides to the
programmer is significant. Here is the general technique:
First create a table containing command names and codes. For our purposes we will ensure that command
codes are contiguous:

/* -- NAME --- FUNCTION - CODE - */
	#define COMMAND_TABLE
	ENTRY(COMMAND0,    command0,     0x00)
	ENTRY(COMMAND1,    command1,     0x01)
	ENTRY(COMMAND2,    command2,     0x02)
	...
	ENTRY(COMMANDX,    commandX,     0x0X

Both uppercase and lowercase names are in the table, because the upper case names will be used for
enumerations while the lowercase will be used for function names.

Next define the command code enumeration:

#define  EXPAND_AS_COMMAND_CODE_ENUM(a,b,c) a##_CMD = c,
enum{
	COMMAND_TABLE(EXPAND_AS_COMMAND_CODE_ENUM)
};

If you are not familiar with token concatenation syntax, the '## ' simply appends '_CMD ' onto
the end of each enumeration name. In this case the table would be expanded as follows:

enum{
	COMMAND0_CMD,
	COMMAND1_CMD,
	COMMAND2_CMD,
	...
	COMMANDX_CMD,
};

Next define structs for each command and response:

typedef  struct {uint8_t command; ...}command1_cmd_t;
typedef struct {uint8_t command; ...}command2_cmd_t;
etc...

typedef struct {uint8_t command; ...}command1_resp_t;
typedef struct {uint8_t command; ...}command2_resp_t;
etc...

Only the command code fields are shown, but presumably there will be other fields defined for each command
(length field, optional data fields, crc field etc.).

Now use X macros to define an enumeration of command and response lengths by applying the sizeof operator
to the structs. These enumerations will be used in the message handler functions to verify that incoming
message lengths are correct and to populate potential length fields in outgoing messages:

#define  EXPAND_AS_COMMAND_LEN_ENUM(a,b,c)
	a##_CMD_LEN = sizeof(b##_cmd_t),
enum{
	COMMAND_TABLE(EXPAND_AS_COMMAND_LEN_ENUM)
};
#define  EXPAND_AS_RESPONSE_LEN_ENUM(a,b,c)
	a##_RESP_LEN = sizeof(b##_resp_t),
enum{
	COMMAND_TABLE(EXPAND_AS_RESPONSE_LEN_ENUM)
};

As previously explained, determine how many commands there are:

#define  EXPAND_AS_STRUCT(a,b,c) uint8_t b,
typedef  struct{
	COMMAND_TABLE(EXPAND_AS_STRUCT)
} size_struct_t;

#define NUMBER_OF_COMMANDS sizeof(size_struct_t)

Finally generate the table of function pointers and prototypes. As a reminder, the jumptable will only
be correct if the command codes are contiguous.

#define  EXPAND_AS_JUMPTABLE(a,b,c) process_##b,
#define EXPAND_AS_PROTOTYPES(a,b,c) void process_##b(void);
p_func_t jump_table[NUMBER_OF_COMMANDS] = {
	COMMAND_TABLE(EXPAND_AS_JUMPTABLE)
}

COMMAND_TABLE(EXPAND_AS_PROTOTYPES)

With this implementation, when a new command needs to be added the following three steps should be followed.

    Add a new row to COMMAND_TABLE .
    Define the structure of the command and response messages called commandX_cmd_t and commandX_resp_t .
    Write a function to handle the new command called "process_commandX() ".

The beauty of this is that even though there are three steps, if any are forgotten we will get warnings
or errors when attempting to compile. If the structures are not defined, the compile will fail during
creation of the enumeration of data lengths. If the command handler function is not written, depending
on the compiler it may fail during compilation, but if not it should provide a warning during linking
that there is an unresolved external.

One More Thing
Every comms handler is going to have buffers it uses to hold the sent and received messages. The question is,
how big should the buffers be? Here is yet another instance where X macros can do the heavy lifting for us.

Since we have defined the format of every command and response, what we want is for the compiler to
determine what the largest message is so we can size the buffers appropriately. Here is how you can do that.

#define  EXPAND_AS_BUFFERS(a,c,b) uint8_t b##_buf[sizeof(b##_cmd_t)];

typedef union{
	COMMAND_TABLE(EXPAND_AS_BUFFERS)
}tx_buf_t

In this case we are using a union, because by definition the size of a union is as large as its largest
member. Inside the union we drop via X macros an array of bytes for each command, where the size of
the array is the size of the command's struct . This union is like the size struct - it is not
instantiated. Instead we can use the sizeof operator to declare our transmit buffer size.

/* declare transmit buffer */
uint8_t tx_buf[sizeof(tx_buf_t)];

Now my transmit buffer tx_buf is the optimal size and as I add commands to the comms handler table,
my buffer will always be adjusted to the perfect size.

Next Time
In my next article I will discuss how to handle a case where command codes are not contiguous. I will
also examine a memory optimization technique where we can use X macros to save valuable memory when jump
tables are sparsely populated.


---
https://www.embedded.com/reduce-c-language-coding-errors-with-x-macros-part-3/

Reduce C language coding errors with X macros: Part 3
March 2, 2013

Editor's note: This article, last in a series of discussions of x macro usage, examines how to use x
macros to automate the task of configuring jump tables and lookup tables used by communication handlers.

Part 2 in this series showed how to develop the following x macro table with the caveat that the command
codes needed to be contiguous:

/* -- NAME --- FUNCTION - CODE - */
  #define COMMAND_TABLE
  ENTRY(COMMAND0,     command0,       0x00)
  ENTRY(COMMAND1,     command1,       0x01)
  ENTRY(COMMAND2,     command2,       0x02)
  ...
  ENTRY(COMMANDX,     commandX,       0x0X)

One  nice thing about having contiguous codes is that the test for index validity is simple:

  ASSERT(command < N_COMMANDS);
  command_jump_table[command]();

When command codes are not contiguous, you need to ensure that you don't jump to a non-existing
function. The simplest way to do this is to make the jump table large enough to support every possible
index. However, this is at the expense of memory. You will need 512 bytes (assuming an 8-bit command
code size) if the architecture uses 16-bit pointers or 1024 bytes if it uses 32-bit pointers.

With this implementation, instead of the simple ASSERT statement, define an error handling function that
can be embedded into the jump table for all invalid commands.

Here is how to do that with x macros, together with some other preprocessor trickery:

  #define INIT_X1      process_reserved,
  #define INIT_X2      INIT_X1    INIT_X1
  #define INIT_X4      INIT_X2    INIT_X2
  #define INIT_X8      INIT_X4    INIT_X4
  #define INIT_X16     INIT_X8   INIT_X8
  #define INIT_X32     INIT_X16  INIT_X16
  #define INIT_X64     INIT_X32  INIT_X32
  #define INIT_X128    INIT_X64  INIT_X64
  #define INIT_X256    INIT_X128 INIT_X128

  #define EXPAND_JUMP_TABLE(a,b,c) [c] = process_##b,

static const p_func_t command_jump_table[256] = {
	/* initialize all pointer to the  reserved function */
	INIT_X256,
	/* overwrite pointers to valid  functions */
	COMMAND_TABLE(EXPAND_AS_JUMP_TABLE)
};

This requires the use of a C99 compiler for the designated initializer syntax, furthermore the compiler
may warn you that you are overriding a previously initialized value. If a C99 compiler is not available,
then the valid function pointers can be updated at run time, at the expense of not being able to place
the jump table in ROM. Here's how to this:

#define EXPAND_JUMP_TABLE(a,b,c)
command_jump_table[c] = process_##b;
/* during run-time initialization */
COMMAND_TABLE(EXPAND_AS_JUMP_TABLE)

Optimizing jump tables
For many applications where memory is limited, this implementation is not practical. What can be done
instead is to add an extra level of indirection as follows:

command_jump_table[command_offset_table[command]]();

In this case a second table is utilized that has one entry for every possible command code. Each entry
contains an offset into the actual jump table. The memory requirements for this implementation are
significantly less than the initial implementation. We need 256 bytes for our offset table, but only 2
or 4 bytes for each function pointer in the jump table. Therefore implementing a communications handler
with a dozen commands would need 280/304 bytes instead of 512/1024.

One side-effect of this implementation is that we need to reserve one of the command codes since invalid
commands need to resolve to a valid offset so that the correct error handler can be called. The most logical
offset value to use is zero (simplifies initialization) and thus the new command table looks like this:

/* -- NAME --- FUNCTION - CODE - */
  #define COMMAND_TABLE
  ENTRY(RESERVED,     reserved,       0x00)
  ENTRY(COMMANDA,     commandA,       0x02)
  ENTRY(COMMANDB,     commandB,       0x09)
  ...
  ENTRY(COMMANDZ,     commandZ,       0xef)

A nice side-effect of this implementation is that it is actually easier to automate the creation of
these two separate tables than it is to automate the creation of the single jump table.

The creation of the jump table has not changed from our original example with contiguous command codes. The
caveat being that we can no longer use the table directly via the command code.

#define EXPAND_AS_JUMP_TABLE(a,b,c) process_##b,
static const p_func_t command_jump_table[N_COMMANDS] = {
	COMMAND_TABLE(EXPAND_AS_JUMP_TABLE)
};

The creation of the offset table is as follows (recall the following struct from last month):

#define EXPAND_AS_STRUCT(a,b,c) uint8_t b,

typedef struct{
	COMMAND_TABLE(EXPAND_AS_STRUCT)
} size_struct_t;

#define N_COMMANDS sizeof(size_struct_t)

This struct can be used for multiple purposes. In addition to taking the size of the struct, we can
calculate the offsets of each element in the struct to use when initializing the offset table:

#define EXPAND_AS_OFFSET_TABLE_INITIALIZER(a,b,c)
	[c] = (uint8_t) offsetof(size_struct_t,  b);

...where offsetof() is a standard library macro defined in "stddef.h". If the reader is unfamiliar
with the offsetof() macro I highly recommend reading the article by Nigel Jones, Learn a new trick with
the offsetof() macro. Use this new x macro do the following:

/* statically declare our offset table, valid commands	initialized to the correct offsets and invalid
command initialized to 0 */
uint8_t command_offset_table[256] = {
  COMMAND_TABLE(EXPAND_AS_OFFSET_TABLE_INITIALIZER)
};

As before, this macro expansion relies on a C99 compiler. If a C99 is not available, do the following:

uint8_t command_offset_table[256] = {0};

#define EXPAND_AS_OFFSET_TABLE_INITIALIZER(a,b,c)
	command_offset_table[c] = (uint8_t)  offsetof(size_struct_t, b);

/* during run-time initialization */
	COMMAND_TABLE(EXPAND_AS_OFFSET_TABLE_INITIALIZER)

A nice side-effect of the offset table implementation is that if we need to implement a function which
identifies if a given code is a valid command; the resulting function is a one-liner:

bool command_is_valid(uint8_t command){
	return command_offset_table[command];
}

Timeout Tables
Another common table that can be similarlyinitialized is a timeout table. In the case of a master
processorinstead of a slave processor, you need to allow a set period of time forthe slave to respond
before determining that a communications fault hasoccurred. Usually different commands will have differing
requirementsfor this time, so implementing a look-up table for each command isnecessary. Modifying the
x macro table, we can add this functionalityeasily:

/* -- NAME --- FUNCTION - CODE - TIMEOUT(ms) -*/
  #define COMMAND_TABLE
  ENTRY(RESERVED,     reserved,       0x00,      0)
  ENTRY(COMMANDA,     commandA,       0x02,    100)
  ENTRY(COMMANDB,     commandB,       0x09,    500)
  ...
  ENTRY(COMMANDZ,     commandZ,       0xef,     20)

#define EXPAND_AS_TIMEOUT_TABLE_INITIALIZER(a,b,c,d) d,

uint16_t timeout_table[N_COMMANDS] = {
	COMMAND_TABLE(EXPAND_AS_TIMEOUT_TABLE_ININTIALIZER)
};

Here is how I would use this table:

int get_command_timeout(uint8_t command) {
	return timeout_table[command_offset_table[command]];
};

GPIO Configuration
Onefinal area is the use of x macros to allow for code reuse by making itsimple to change what gpio pins
are used by a module. As an exampleconsider the following table:

#define SWITCHES_GPIO_TABLE(ENTRY)
  ENTRY(SWITCHA,      GPIOE,         GPIO_Pin_0)
  ENTRY(SWITCHB,      GPIOA,         GPIO_Pin_0)
  ENTRY(SWITCHC,      GPIOC,         GPIO_Pin_5)
  ENTRY(SWITCHD,      GPIOE,         GPIO_Pin_1)

I will leave it to the reader as an exercise, but from this table, aslong as the supporting code follows a
few conventions, all you have todo is change the port and pin name in the table and all of theinitialization
code adjusts accordingly, making it easy to port over to anew design.

Final Thoughts
I hope you have enjoyedthis overview of x macros and that you have learned something new in
theprocess. Though an advanced technique, once in place the use of xmacros can reduce errors and make
the embedded programmer's lifeeasier. I would love to read in the comments how readers are using xmacros
in their designs.



---
https://www.codeproject.com/Articles/1116877/X-Macros-in-C

X Macros in C

How to enhance C/C++ language with macro to auto generate some code

Introduction
In this article, I want to explain what are X macros and how they work.

I know that this is not a new idea, but I have not found a lot of documentation over the web. You can
find below a list of articles talking or using X Macros:

	http://www.codeproject.com/Articles/25541/C-C-macros-programming
	http://stackoverflow.com/questions/147267/easy-way-to-use-variables-of-enum-types-as-string-in-c
	http://www.drdobbs.com/the-new-c-x-macros/184401387

The idea here is to describe this technique as simply as possible. I will not tell you how to use them,
but simply describe them with simple examples and I am sure you will find utilities for your projects.

I have discovered X Macros a few years ago and I found them extremely powerful and useful.

Description

Basics Behind
The concept behind X Macros is based on the possibility to pass macro as parameter to another macro.

Let's look at the below macro declaration:
#define APPLY_A_MACRO_ON_SECOND_PARAMETER(PARAM_MACRO, parameter) PARAM_MACRO(parameter)

As it is declared, the macro APPLY_A_MACRO_ON_SECOND_PARAMETER will expand as:
PARAM_MACRO(parameter)

Nothing complicated here. But now, you can ask what is PARAM_MACRO?

A First Example
At this time, PARAM_MACRO is nothing because it is not declared yet. And that is what makes this technique
very powerful.

Now, we can declare different kind of macros that apply on only one parameter and pass them to
APPLY_A_MACRO_ON_SECOND_PARAMETER.

// Let's declare two different macros

// first one will declare one integer with parameterized name
#define PARAMETER_TO_INT_DECL(parameter) int parameter;

// second one will create a getter function that will return the variable
#define PARAMETER_TO_GETTER_FUNC(parameter) int get_##parameter() { return parameter; }

Now, we can call APPLY_A_MACRO_ON_SECOND_PARAMETER with those two macros.

Starting with PARAMETER_TO_INT_DECL:
APPLY_A_MACRO_ON_SECOND_PARAMETER(PARAMETER_TO_INT_DECL, width)

APPLY_A_MACRO_ON_SECOND_PARAMETER expands like this:
PARAM_MACRO(parameter)

Let's now replace with the parameters values:
PARAMETER_TO_INT_DECL(width)

PARAMETER_TO_INT_DECL expands like this:
int parameter;

Let's now replace with the parameter value for the last expansion:
int width;

Let's look at the expansion with PARAMETER_TO_GETTER_FUNC now:
APPLY_A_MACRO_ON_SECOND_PARAMETER(PARAMETER_TO_GETTER_FUNC, width)

APPLY_A_MACRO_ON_SECOND_PARAMETER expands like this:
PARAM_MACRO(parameter)

Let's now replace with the parameters values:
PARAMETER_TO_GETTER_FUNC(width)

PARAMETER_TO_GETTER_FUNC expands like this:
int get_##parameter() { return parameter; }

Let's now replace with the parameter value for the last expansion:
int get_width() { return width; }

To sum up:
APPLY_A_MACRO_ON_SECOND_PARAMETER(PARAMETER_TO_INT_DECL, width)
APPLY_A_MACRO_ON_SECOND_PARAMETER(PARAMETER_TO_GETTER_FUNC, width)

// will turn into
int width;
int get_width() { return width; }

This example may not impress you much. I stayed basic but here is what we can say: we have created a
way to automatically standardize the getters function.

It remains a bit complicated to use, so we can declare a new macro like this one:
#define INT_VAR_PLUS_GETTER(variable_name)\
	APPLY_A_MACRO_ON_SECOND_PARAMETER(PARAMETER_TO_INT_DECL, variable_name)   \
	APPLY_A_MACRO_ON_SECOND_PARAMETER(PARAMETER_TO_GETTER_FUNC, variable_name)

Now, let's call INT_VAR_PLUS_GETTER:
INT_VAR_PLUS_GETTER(width)

// will turn into
int width;
int get_width() { return width; }

Now, we have a macro library that permits in one call to declare both variable and getter. Everything
is standardized.

At this point, I am sure most of you are still not impressed.
What is the point of all this complexity to such a simple (and maybe unuseful) result?

Let's move to a more complex and useful example.
Useful Example: enum to string

Motivations
As I said in the introduction, I found X macros technique a few years ago. At that time, I was working
on maintaining the code of a big C project.

On this project, there were a lot of enums used and I wanted to add logs in order to trace what were
the enum values when some bugs happened.

In the first place, I was logging like that:
printf("enum value : %d\n", enum_value);

But the problem with this is when the enum type of enum_value has more than a hundred entries.

Let's say then that you have this log to interpret : "enum value : 57".

Then you have to find the enum declaration, and count the entries till you reach the 57th entry. This
is painful. Furthermore, 57 is not an informative enough data regarding the enum type. We just want to
have an enum that allows to transform 57 into a readable string.
Let's Do It Without Macros

First, we will implement such a function without macro help in order to see how X macros will help us
in automatizing work and avoiding errors.

Let's start with a simple enum declaration:
typedef enum IceCreamFlavors {
	CHOCOLATE = 56,
	VANILLA = 27,
	PISTACHIO = 72,
}
IceCreamFlavors;

Now, let's define the function that will turn the enum values into strings:

const char* IceCreamFlavors_toString(IceCreamFlavors flavor) {
	switch(flavor) {
	case CHOCOLATE:
		return "CHOCOLATE";
	case VANILLA:
		return "VANILLA";
	case PISTACHIO:
		return "PISTACHIO";
	default:
		// the error handling might seem a bit too strict !
		return 0;
		// you can also return something like:
		return "## unknown IceCreamFlavors value ##";
	}
}

Creating and maintaining this _toString function is a bit repetitive. You can easily make copy/paste
errors or forget one entry. Furthermore, when you update the enum, you have to ensure that the _toString
function is properly updated. This is potentially a source of errors.
Now, Let's See How X Macros Will Help Us

What we want is a single location in the code where to store the enum values. And we want that the
_toString function exists and is updated automatically according to enum values.

Storing the Enum Values
First, we create a macro that stores the enum values:
#define SMART_ENUM_IceCreamFlavors(_) \
	_(CHOCOLATE, 56) \
	_(VANILLA, 27) \
	_(PISTACHIO, 72)

Remember the description chapter. What we have done here is to declare a macro SMART_ENUM_IceCreamFlavors
that takes another macro (_) as parameters. This will allow us to do what we want with the parameters
given to _.

Enum Declaration
First, we want to declare the enum the C way.

We first need a macro that will turn the SMART_ENUM_IceCreamFlavors entries (lines under) into C enum
entries.
#define SMART_ENUM_ENTRY(entry_name, entry_value) entry_name = entry_value,

Then, we need a macro to build the entire C enum:
// the macro takes the enum macro definition as parameter
// (in our case we will pass SMART_ENUM_IceCreamFlavors)
#define SMART_ENUM_DECLARE_ENUM(MACRO_DEFINITION, enum_name) \
typedef enum enum_name \
{ \
	MACRO_DEFINITION(SMART_ENUM_ENTRY) \
} \
enum_name;

Now, let's call this macro and see the expansion:
// the first parameter is the macro definition of the enum,
// the second one is the name we want to give to the enum
SMART_ENUM_DECLARE_ENUM(SMART_ENUM_IceCreamFlavors, IceCreamFlavors)

SMART_ENUM_DECLARE_ENUM expands like this:
typedef enum enum_name \
{ \
   MACRO_DEFINITION(SMART_ENUM_ENTRY) \
} \
enum_name;

Replacing with the macro parameters:

typedef enum IceCreamFlavors {
	SMART_ENUM_IceCreamFlavors(SMART_ENUM_ENTRY)
}
IceCreamFlavors;

Expanding SMART_ENUM_IceCreamFlavors:

typedef enum IceCreamFlavors {
	_(CHOCOLATE, 56) \
	_(VANILLA, 27) \
	_(PISTACHIO, 72)
}
IceCreamFlavors;

and replacing with macro in parameter:

typedef enum IceCreamFlavors {
	SMART_ENUM_ENTRY(CHOCOLATE, 56)
	SMART_ENUM_ENTRY(VANILLA, 27)
	SMART_ENUM_ENTRY(PISTACHIO, 72)
}
IceCreamFlavors;

SMART_ENUM_ENTRY expands like:
entry_name = entry_value,

So the final result is:
typedef enum IceCreamFlavors {
	CHOCOLATE = 56,
	VANILLA = 27,
	PISTACHIO = 72,
}
IceCreamFlavors;

And here we are!

_toString Function Creation
Now, we want to create such a similar macro in order to create the _toString function with the same
macro definition of the enum. Thus, we will have only one location where the enum values are stored !

Let's start with the macro that will turn each entry of the macro definition into a case statement for
the function:

// the macro takes two parameters as the macro definition use macro that takes two
// so entry value is not use, but it is not a big deal
#define SMART_ENUM_TOSTRING_CASE(entry_name, entry_value) case entry_name: return #entry_name;

Now, let's write the macro that will build the entire _toString function:
// the macro takes the enum macro definition as parameter
// (in our case we will pass SMART_ENUM_IceCreamFlavors)
#define SMART_ENUM_DEFINE_TOSTRING_FUNCTION(MACRO_DEFINITION, enum_name) \
const char* enum_name##_toString(enum_name enum_value) \
{ \
	switch(enum_value) \
	{ \
	MACRO_DEFINITION(SMART_ENUM_TOSTRING_CASE) \
	default: \
		// the error handling might seem a bit too strict ! \
		return 0; \
		// you can also return something like: \
		return "## unknown enum_name value ##"; \
	} \
}

Now, let's call this macro and see the expansion:
// the first parameter is the macro definition of the enum,
// the second one is the name we want to give to the enum
SMART_ENUM_DEFINE_TOSTRING_FUNCTION(SMART_ENUM_IceCreamFlavors, IceCreamFlavors)

SMART_ENUM_DEFINE_TOSTRING_FUNCTION expands like this:

const char* enum_name##_toString(enum_name enum_value) \
{ \
	switch(enum_value) \
	{ \
	MACRO_DEFINITION(SMART_ENUM_TOSTRING_CASE) \
	default: \
		// the error handling might seem a bit too strict ! \
		return 0; \
		// you can also return something like: \
		return "## unknown enum_name value ##"; \
	} \
}

Replacing with the macro parameters:

const char* IceCreamFlavors_toString(IceCreamFlavors enum_value) {
	switch(enum_value) {
		SMART_ENUM_IceCreamFlavors(SMART_ENUM_TOSTRING_CASE)
		default:
			// the error handling might seem a bit too strict !
			return 0;
			// you can also return something like:
			return "## unknown IceCreamFlavors value ##";
	}
}

Expanding SMART_ENUM_IceCreamFlavors:

const char* IceCreamFlavors_toString(IceCreamFlavors enum_value) {
	switch(enum_value) {
		_(CHOCOLATE, 56) \
		_(VANILLA, 27) \
		_(PISTACHIO, 72)
		default:
			// the error handling might seem a bit too strict !
			return 0;
			// you can also return something like:
			return "## unknown IceCreamFlavors value ##";
	}
}

and replacing with macro in parameter:

const char* IceCreamFlavors_toString(IceCreamFlavors enum_value) {
	switch(enum_value) {
		SMART_ENUM_TOSTRING_CASE(CHOCOLATE, 56)
		SMART_ENUM_TOSTRING_CASE(VANILLA, 27)
		SMART_ENUM_TOSTRING_CASE(PISTACHIO, 72)
		default:
			// the error handling might seem a bit too strict !
			return 0;
			// you can also return something like:
			return "## unknown IceCreamFlavors value ##";
	}
}

SMART_ENUM_TOSTRING_CASE expands like:

case entry_name: return #entry_name;

So finally, by expanding it, we got:
const char* IceCreamFlavors_toString(IceCreamFlavors enum_value) {
	switch(enum_value) {
		case CHOCOLATE: return "CHOCOLATE";
		case VANILLA: return "VANILLA";
		case PISTACHIO: return "PISTACHIO";
		default:
			// the error handling might seem a bit too strict !
			return 0;
			// you can also return something like:
			return "## unknown IceCreamFlavors value ##";
   }
}

And here we are again! We have built the _toString function with the same macro definition that served
to create the enum declaration.

Final Macro
Now we have all the tools, let's create the last macro:

#define DEFINE_SMART_ENUM(MACRO_DECLARATION, enum_name) \
	SMART_ENUM_DECLARE_ENUM(MACRO_DECLARATION, enum_name) \
	SMART_ENUM_DEFINE_TOSTRING_FUNCTION(MACRO_DECLARATION, enum_name)

Now, if we call the macro:

// I rewrite the macro declaration here to remember
#define SMART_ENUM_IceCreamFlavors(_) \
	_(CHOCOLATE, 56) \
	_(VANILLA, 27) \
	_(PISTACHIO, 72)

// we call the builder
DEFINE_SMART_ENUM(SMART_ENUM_IceCreamFlavors, IceCreamFlavors)

// the result will be...
typedef enum IceCreamFlavors {
	CHOCOLATE = 56,
	VANILLA = 27,
	PISTACHIO = 72,
}
IceCreamFlavors;

const char* IceCreamFlavors_toString(IceCreamFlavors enum_value) {
	switch(enum_value) {
		case CHOCOLATE: return "CHOCOLATE";
		case VANILLA: return "VANILLA";
		case PISTACHIO: return "PISTACHIO";
		default:
			// the error handling might seem a bit too strict !
			return 0;
			// you can also return something like:
			return "## unknown IceCreamFlavors value ##";
	}
}

We now have a beautiful and powerful one line builder to:
	ensure a deep linkage between the enum declaration and the _toString function
	reduce the coding time
	avoid stupid errors

Of course, each update on the macro definition will have an impact on both enum declaration and _toString
function.

Conclusion
I hope this article is clear enough and not too boring. I tried to make it as clear as possible, so
that explains its size. The macro expansions can be hard to follow. It happens frequently that I have
to mentally re expand macros in order to understand what they do.

This said, I truly think that X macros is a wonderful tool.
I have read a lot of criticism against that technique because it uses macros that are considered unsafe.
I totally agree that using macros is touchy and I don't recommend to use them for everything.
But I see that as a language extension, that can't be achieved in another way.

If you look at the "Enum to string" example, the built code is always pretty simple. Macros are not
hiding some critical code that we will need to be debugged. It should be used to automate well known
simple mechanisms that have been tested before macro-izing them.


---

