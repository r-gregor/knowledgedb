filename: fzf-becoming-fzf-master-5p-multif-20251127.txt
https://thevaluable.dev/practical-guide-fzf-example/

1. A Practical Guide to fzf: Building a File Explorer
27 Jan 2023

This article is the first part of a series about fzf:

Becoming a fzf master
 1. A Practical Guide to fzf: Building a File Explorer
 2. A Practical Guide to fzf: Shell Integration
 3. A Practical Guide to fzf: Vim Integration
 4. A Practical Guide to fzf: Building a Git Explorer

It's again a sunny day! Desperate, you're looking through the windows. You're locked up in the offices of
MegaCorpMoneyMaker, the company you're working for.

While Davina, your colleague developer, explains quietly to one of her colleague the power of the terminal,
Dave, another colleague developer, suddenly stands up and interjects:

"What you're saying is not true! The terminal is an old, clunky tool. It's difficult to manage files and
directories only using a terminal, for example. Using GUIs (Graphical User Interfaces) is often the best
idea!"

Davina acknowledges that GUIs might seem more powerful and easier to use than a terminal. But graphical
interfaces don't often have the power to be customized for the specific needs of a developer.

"For example, she continues, the CLI (Command Line Interface) fzf is powerful enough to create ourselves
simple but useful TUIs (Terminal User Interface). When you have a specific workflow, CLIs can be combined to
support this workflow. Personally, the shell is the keystone of my own development environment."

She pauses a moment, thinking. Then, she continues:

"I have an idea: let's try to create a simple file explorer using fzf!"

Many, including you, join the group, decided to help them in this endeavor. Quickly, you decide that the file
explorer should have two modes:

 1. A "file" mode: for searching, previewing, and opening files.
 2. A "directory" mode: for searching, previewing, and opening directories.

This article is the result of the Dave's and Davina's journey at MegaCorpMoneyMaker. You'll find some small
exercises throughout, to build this file explorer step by step. I recommend you to try to solve them; it
doesn't matter if you succeed. You'll remember more easily if you only try.

In the same spirit, I encourage you to try out the different shell commands described in this article. To
follow along, you can download the
[**1][https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/guide-fzf]companion project and run the
different commands from there.

We'll see, in this article:

  * The basics of fzf.
  * How to enable multi-selection to select more than one entry.
  * The special metacharacters we can use for our queries.
  * How to limit the fuzzy search to some specific fields for each entry.
  * How to customize fzf's TUI.
  * How to preview the different entries.
  * How to bind keystrokes or event to some actions.
  * How to build our complete file explorer.
  * How to fix potential performance issues.

This article also exists as a video you can find on my YouTube channel.

In this article, we'll only look at fzf as an independent CLI. We won't discuss the different fzf
integrations (with the shell or with Vim, for example). If you want me to write about that, don't hesitate to
contact me by answering one of my newsletter, or by writing a comment down below.

Many examples from this article are inspired from fzf's manual (man fzf). It's where you'll find the most
complete guide you'll ever need; I definitely recommend you to look at it if you need something specific.

Enough rambling! Let's now dive deep in the labyrinth of fuzzy searching with the fantastic fzf.

The Basics of fzf

A Fuzzy Finder
The CLI fzf is a fuzzy finder, an interactive filter which can be used to easily match plain text entries
separated with newlines.

To fuzzy find, you can type a query directly in fzf's TUI. This query is not a regex pattern, but only plain
text trying to match fzf's input, using an approximate string matching algorithm (also called fuzzy search).

For example, you can try to run the following in your shell:
$> echo "hello\nbonjour\nbonsoir" | fzf

We give here a string to fzf's input, creating three entries all separated with a newline \n: hello, bonjour,
and bonsoir. The TUI of fzf will then be displayed, allowing us to type our query to fuzzy search the entry
we want.

For example, the query "bon" will only match "bonjour" and "bonsoir"; everything else will disappear. You can
then select the entry you want with one of the following keystrokes:

------------------------------------------------------
Keystroke                   Description
------------------------------------------------------
UP, CTRL-P, or CTRL-K       Select the previous entry.
DOWN, CTRL-N, or CTRL-J     Select the next entry.
------------------------------------------------------

If you press the ENTER key after making your choice, the selection is simply spit back using the standard out
put (STDOUT).

It wouldn't be super useful if we weren't in the shell; but since we are, we can redirect STDOUT to anything
we want. A file, another pipe (to pass the selection as input to another command), a command substitution&
mldr; you name it.

Default Behavior
If you run fzf without giving it any input, it will run a default command (with the CLI find) to get all the
files and subdirectories of the working directory by default. All hidden files will be skipped.

The Default Command
You can overwrite the default command fzf uses under the hood with the environment variable
FZF_DEFAULT_COMMAND. For example:

# Use the CLI find to get all files, excluding any filepath
# containing the string "git".
export FZF_DEFAULT_COMMAND='find . -type f ! -path "*git*"'

# Use the CLI fd to respect ignore files (like '.gitignore'),
# display hidden files, and exclude the '.git' directory.
export FZF_DEFAULT_COMMAND='fd . --hidden --exclude ".git"'

# Use the CLI ripgrep to respect ignore files (like '.gitignore'),
# display hidden files, and exclude the '.git' directory.
export FZF_DEFAULT_COMMAND='rg --files --hidden --glob "!.git"'

For the two last examples to work, you need respectively fd and ripgrep installed on your system.

Remember: fzf will use this default command if and only if you don't give any input.

The Default Options
Like many other CLIs, the behavior of fzf can be significantly altered thanks to its option. If you want to
always use the same options without specifying them each time, you can set fzf's default options with the
environment variable FZF_DEFAULT_OPTS. For example:
export FZF_DEFAULT_OPTS='-i --height=50%'

We'll describe the most interesting options below in the article.

With the proper defaults in place, you can use a command substitution (for example) to edit any file from
your filesystem. For instance, to fuzzy search a file (or a directory) and edit it in Vim, you can do:
$> vim $(fzf)

When I run this command in our [**1]companion project, here's what I get:
using fzf to select a file and edit it in Vim

You can of course combine command substitutions and pipes if you want to:
$> vim $(find . -type f | fzf)

Since we feed fzf's input, FZF_DEFAULT_COMMAND is not used, but FZF_DEFAULT_OPTS is. I'd recommend not to add
too many options for specific entries in there (like options which can only work when the entries are
filepath, for example). The aim of fzf is to be as general as possible, to fuzzy find any kind of plain text.

Default Query
By default, fzf will start without any query; everything will be matched. You can change that by using the
--query option. For example:
$> vim $(find . -type f | fzf --query "mouseless")

Here's the result if I run the above in the [**1]companion project:
Launching fzf with a default query

Creating a List of Directory
Let's begin to create our file explorer. As we said above, it will have two modes: one only displaying files,
the other one only displaying directories.

Let's look at this second mode. We want to create here the list of subdirectories for the working directory,
and feed that to fzf's standard input (STDIN).

We want then to give the selection we make (fzf's STDOUT) to the command "cd" (as argument), to move to the
directory selected.
$> cd $(find . -type d | fzf)

We use the expression -type with the value d to only display directories. As you might have guessed, if we
wanted to only display files, we would have given the value "f".

We then use a command substitution to give the output of our command to "cd" as argument.

Selecting More Entries with Multi-Selection
By default, we can only select one entry in fzf's TUI. To select multiple of them, we can run fzf with the
following option:
---------------------------------------
Option           Description
---------------------------------------
--multi or -m    Allow multi-selection.
---------------------------------------

We can then use these keystrokes in fzf's TUI:
---------------------------------------------------------------------------------
Keystroke    Description
---------------------------------------------------------------------------------
TAB          Toggle the selection of the current entry and move the pointer up.
SHIFT+TAB    Toggle the selection of the current entry and move the pointer down.
---------------------------------------------------------------------------------

Here's what it looks like with multiple entries selected:
Selecting multiple entries in fzf

When we then hit ENTER, all selected entries will be spit back to STDOUT, separated with newlines.

Here's a little exercise: in our [**1]companion project, how would you edit all the files in the "headers"
directory using Vim?

You need first to launch Vim with the selection you're making using fzf:
$> vim $(find -type f | fzf -m)

You can then use the query "headers" to match all the files in the "headers" directory. To select them all,
hit SHIFT-TAB to move your pointer up to the top of the list.

Finally, hit the ENTER key to edit all these files in Vim.

There is no keystroke to select all entries (or unselect them) by default. We'll see how we can configure
that in another section below.

Search Syntax
We saw earlier that we can type a query in fzf to reduce the matches and select more easily what we want. I
also wrote that these queries are not regex patterns, only plain text queries used in a fuzzy search
algorithm.

Yet, fzf's query system allows us to use a couple of metacharacters similar to most common regex engines,
thanks to fzf's extended search mode. It's enabled by default; if you don't want to use it, you can disable
it with the option --no-extended (or the equivalent +x).

We'll try to edit different files from our [**1]companion project in this section, always using the following
command:
$> vim $(find . -type f | fzf)

Let's focus now on these queries.

Beginning and End of Line
Let's say that we only want to match and edit one of our LaTeX file with the extension ".tex". To do so,
after running our command above, we can use this query:
.tex$

The dollar $ is a metacharacter in that case; it doesn't match the dollar character, but it has a meaning.
For fzf, it means "end of line", like most regex engines out there.

With our query, we basically want to match filepaths finishing with .tex. Here's the result:

Using fzf metacharacter end-of-line
We can also match the beginning of line with a caret ^. For example, if we want to match filepaths beginning
with "./explorer", we can write the following query:
^./explorer

The OR operator
If we want to match at least one query among many, we can use a bar | between them. For example, if we want
to match files with the extensions ".yml", ".xml", and ".tex", we can use the following query:
.xml$ | .yml$ | .tex$

Here's the result:
Using fzf metacharacter end-of-line

Remember that these bars have nothing to do with shell pipes.

The AND operator
We can also try to match multiple queries at once: we just have to separate our queries with a space.

For example, if we want to match all the files with extension ".tex", and also the filepaths containing "/
headers/", we can write the following query:
.tex$ /headers/

The result:
Using fzf metacharacter end-of-line

The NOT operator
What about using a query to exclude some entries? To do so, we can use the bang ! as prefix.

Let's say that we want to match the files with extensions ".yml", ".xml", or ".tex", but not the files in the
"headers" directory. We can write this query:
.yml$ | .xml$ | .tex$ !/headers/

We could translate the above by: "I want to match YAML, XML, or LaTeX files, and not the ones in the
'headers' directory".

The result:
Using fzf metacharacter end-of-line

Exact Match
There is a last metacharacter we can use as a prefix to our queries: the single quote ', to get an exact
match.

For example, if you type the query ti in fzf, you'll match any entry including the letter 't' and 'i', even
if they are not following one another. If you add a single quote to the query as prefix ('ti), it will only
exactly match a 't' followed with an 'i'.

You can also use the option -e when running fzf to exactly match all your queries, without the need to use
the single quote ' for each of them.

Case Sensitive Search
By default, fzf's search algorithm use "smart-case": the match will only be case-sensitive if we use one or
more uppercase in the query. Otherwise, it will be case-insensitive.

To change this, we can use one of the following options:
-------------------------------------------
Option    Description
-------------------------------------------
-i        All queries are case-insensitive.
+i        All queries are case-sensitive.
-------------------------------------------

Limiting the Search
Until now, our queries try to match every single character of each entry. What if we only want to match a
part of each of these entries?

We can use these options to limit the search scope by entry:
-----------------------------------------------------------------------
Option          Description
-----------------------------------------------------------------------
--nth           Limit the scope to the nth field of the entry.
--delimiter     Regex to change the field delimiter (space by default).
-----------------------------------------------------------------------

Let's say that we want to display a number before each entry. To accomplish this miracle, we could use the
CLI nl, for number of lines). But we don't want our queries to match these numbers. Here's how to do that:
$> vim $(find . -type f | nl | fzf --nth=2)

The result:
Limiting the match using fields

As you can see, there are two fields separated with a space in each entry:
 1. The number (created by nl).
 2. The filepath.

We only want to match the filepath with our query, so we give "2" to the option --nth. As a result, if you
type the query "2" for example, nothing will be matched.

What if we want to use another delimiter? A comma ,, for example? To do so, we can use the --delimiter option
to specify this new separator. For example:
$> vim $(find . -type f | nl -s ',' | fzf --nth=2 --delimiter=',')

Here's the result:
Limiting the match using fields and comma separator

Again, querying for "2" (for example) won't match anything.

Here are some examples of the possible values we can give to the --nth option:
----------------------------------------------------------------------
Example of value     Description
----------------------------------------------------------------------
2                    Only match the 2nd field.
-1                   Only match the last field.
-2                   Only match the 2nd to last field.
3..5                 Only match from the 3rd to the 5th field.
2..                  Only match from the 2nd to the last field.
..-3                 Only match from the 1st to the 3rd to last field.
..                   Match all the fields.
----------------------------------------------------------------------

In the fzf manual (man fzf), this is called the FIELD INDEX EXPRESSION ways of selecting fields. These values
can also be used for the placeholder in fzf's preview; we'll see that in another section of this article.

Customizing fzf Display
Now that we have a good grasp of fzf's basics, let's see how we can customize its display. We can do a lot in
that regard; for example, here are a couple of options we can use, to give you an overview:
$> fzf --multi \
--height=50% \
--margin=5%,2%,2%,5% \
--layout=reverse-list \
--border=double \
--info=inline \
--prompt='$>' \
--pointer='→' \
--marker='♡' \
--header='CTRL-c or ESC to quit' \
--color='dark,fg:magenta'

Here's the resulting masterpiece of colors and forms:
fzf with custom display

Let's look now at each of these options. If you're not interested to customize fzf's TUI, you can pass the
whole section. You're the reader, you decide.

Height
You don't want fzf to take all the height of your terminal? Here are the options you can use to accommodate
your sophisticated tastes:
--------------------------------------------------------------------------------------
Option           Description                                                   Default
--------------------------------------------------------------------------------------
--height         Height of fzf (rows or percentage). Can be prefixed by ~      100%
                 to adapt the height depending on the number of entries.
--min-height     Minimum height when --height is used with percentage.         10
--------------------------------------------------------------------------------------

Here's how you can use these options:
# Height of 10 rows
fzf --height=10

# Height of 10%
fzf --height=10%

# Height around 10%, depending on the number of entries
fzf --height=~10%

# Height of 30%, minimum height of 8 rows
fzf --height=30% --min-height=8

Margins and Padding
We can also add margin and padding to fzf's TUI:
--------------------------------------------------------------------------------------------------
Option       Description                                                                   Default
--------------------------------------------------------------------------------------------------
--margin     Comma separated margin (similar to CSS) in absolute number or percentage.     0
--padding    Comma separated padding (similar to CSS) in absolute number or percentage.    0
--------------------------------------------------------------------------------------------------

Here are some examples for adding a margin:
# Margin of 10
fzf --margin=10

# Margin of 10%
fzf --margin=10%

# Margin of 10% on top and bottom, 5% on left and right
fzf --margin=10%,5%

# Margin of 10% on top, 5% on left and right, 8% on bottom
fzf --margin=10%,5%,8%

# Margin of 10% on top, 3% on right, 8% on bottom, 5% on left
fzf --margin=10%,3%,8%,5%

The padding works similarly. Keep in mind that if you don't have any border, there won't be any visual
difference between adding a margin and adding a padding.

Layout
We can change the general layout with the option --layout (how surprising!). Here are the possible values:
--------------------------------------------------------
Value           Prompt's position    List
--------------------------------------------------------
default         Bottom               From bottom to top.
reverse         Top                  From top to bottom.
reverse-list    Bottom               From top to bottom.
--------------------------------------------------------

You can also use the option --reverse instead of --layout=reverse. Both are equivalent.

Borders
We can also display borders around fzf's TUI, thanks to these magical options:
-----------------------------------------------------------------------------------------------------
Option                     Description                                                     Default
-----------------------------------------------------------------------------------------------------
--border                   Display a border.                                               none
-----------------------------------------------------------------------------------------------------
--border-label             Label to display on the horizontal line of the border.          None
                           Only some types of borders can have a label.
-----------------------------------------------------------------------------------------------------
--border-label-position    Position of the border label. Positive numbers mean number      0 (center)
                           of columns from
                           the left (left-align), negative ones for number of columns
                           from the right (right-align). Can add :bottom to put the
                           label on the bottom line of the border.
-----------------------------------------------------------------------------------------------------

Here are the value we can use for the option --border:
----------------------------------------------------
Border         Description
----------------------------------------------------
rounded        Rounded corners.
sharp          Sharp corners.
bold           Bold lines.
double         Double lines.
horizontal     Horizontal lines above and below.
vertical       Vertical lines on the left and right.
top            Only one border at the top.
bottom         Only one border at the bottom.
left           Only one border on the left.
right          Only one border on the right.
none           No border.
----------------------------------------------------

As always, here are a couple of examples:
# Top border and centered label
fzf --border=top --border-label="| My Cool Label |"

# Bold border and label 5 columns from the left
fzf --border=bold --border-label="| My Cool Label |" \
--border-label-pos=5

# Horizontal border and label 5 columns from the right
fzf --border=horizontal --border-label="| My Cool Label |" \
--border-label-pos=-5

The Info Line
If you open fzf, you'll notice that there is an info line just between the matched entries and the prompt. By
default, it displays the number of matched entries and the total number of entries. If you allowed
multi-selection like a boss, the count of selected entries will also be displayed in parentheses.

We can display this info line in three different ways, thanks to the value of the option --info. Here are the
possible ones:
---------------------------------------------------------------------------------------
Value      Description
---------------------------------------------------------------------------------------
default    The info line is just above the prompt (or below if the layout is reversed).
inline     The info line is at the same level as the prompt.
hidden     The info line doesn't appear at all.
---------------------------------------------------------------------------------------

Do you want some examples?
# Inline the info line with the prompt
fzf --info=inline

# Hide the info line
fzf --info=hidden

Prompt, Pointer, and Multi-Marker
By now I'm sure you're realizing how much we can customize fzf's display, to make the most beautiful fuzzy
finder in the galaxy. The prompt, pointer (the pointer pointing to the current entry), and multi-markers (the
characters marking the selections, if multi-selection is enabled) are no exceptions: we can change them
following our craziest artistic inspirations.

Here are the options allowing us to do exactly what I just wrote:
---------------------------------------------------------------------------
Option      Description                          Default Character    limit
---------------------------------------------------------------------------
--prompt    Change the prompt's character.       >                    None
--pointer   Change the pointer's character.      >                    2
--marker    Change the multi-markers' character. >                    2
---------------------------------------------------------------------------

Here's an example:

fzf -m --prompt='▶' --pointer='→' --marker='♡'

How lovely!

Adding a Header
What about adding a header to our TUI? This can be useful to give some information to the user, especially
when we'll begin to create keystrokes for fzf; again, we'll see that later in this article.

The header will appear near the prompt, above or below, depending on the layout. Here are the options you can
use to craft the header of your dreams:
-------------------------------------------------------------------------------------------------
Option             Description
-------------------------------------------------------------------------------------------------
--header           The header's content.
--header-lines     When given a positive number N, the first N lines of input are used as header.
--header-first     Display the header before the prompt.
-------------------------------------------------------------------------------------------------

Some inspiration:
# The header is above the prompt
fzf --header="Use CTRL-C to cancel" --header-first --reverse

# Display the first line of output from the command "lsblk" as header.
# It won't be possible to fuzzy search for this line anymore.
$> lsblk | fzf --header-lines=1

Colors
We have now a good understanding on how to configure fzf's display. Let's finish this section beautifully, by
looking at the colors we can give to our favorite fuzzy finder.

Colorful Options
Here are the options available to manipulate fzf's color scheme:
-------------------------------------------------------------------
Option         Description
-------------------------------------------------------------------
--ansi         Allow the processing of ANSI color code.
--color        Change colors for the different elements of the TUI.
--no-color     Don't use any color (black & white).
-------------------------------------------------------------------

Here's the general pattern to change the color of specific elements:
--color=[BASE_SCHEME][,COLOR_NAME[:ANSI_COLOR][:ANSI_ATTRIBUTES]]...

Keep in mind that the notation you can use for your colors depends on your terminal; more specifically, if it
can display 16, 256 colors, or 24-bit colors.

Here are the usual examples:
# Use ANSI color code (bright red)
# The first '^[' is an ESC character - you can spit it with 'CTRL-v ESC'
$> echo "^[[1;31mHello" | fzf --ansi

# The text of the current entry is red on a "dark" base scheme (ANSI 256 colors).
$> fzf --color='dark,fg+:red'

# The text of the current entry is red, and the other entries are blue (ANSI 256 colors).
$> fzf --color='fg+:red,fg:117'

# The text of the current line is red, and the other entries are blue (24 bits colors).
$> fzf --color='fg+:#ff0000,fg:#0000ff'

You can also use the ANSI color -1 to use the background color of your terminal.

Note that the base scheme is not specified for the two last examples; in that case, it will fallback to the
default one. But, you might wonder: what's this base scheme? I'm happy you ask the question.

Base Scheme
The base scheme gives you some default colors you can then overwrite as you see fit. Here are the ones you
can use:
-----------------------------------------------------------------------------------------
Scheme    Description
-----------------------------------------------------------------------------------------
dark      Dark color scheme for 256-color terminals (default for any 256 color terminal).
light     Light color scheme for light 256-color terminal.
16        Color scheme for 16-color terminal.
bw        Black and white (equivalent to --no-color).
-----------------------------------------------------------------------------------------

For example, if you want to use the light base scheme, you can run:
$> fzf --color=light

Colors&mldr; But for What?
All of that is great, but on what elements can we apply these new colors? Here's the complete list:
--------------------------------------------------------------------------
Element       Description
--------------------------------------------------------------------------
fg            Text of the entries (except the current line).
fg+           Text of the current line.
bg            General background (except the current line).
bg+           Current's line background.
preview-fg    Preview window's text.
preview-bg    Preview window's background.
hl            Highlighted substrings.
hl+           Highlighted substrings for the current line.
gutter        Gutter on the left (get the value of bg+ if not specified).
query         Query string.
disabled      Query string when search is disabled.
info          Info line.
separator     Horizontal separator of the info line.
border        Border around the window (used by --border and --preview).
label         Border's label (used by --border-label and --preview-label)
prompt        Prompt.
pointer       Pointer.
marker        Multi-select markers.
spinner       Loading input indicator.
header        Header.
--------------------------------------------------------------------------

For example, here are the colors I'm using:
$> fzf --color="bg+:-1,\
fg:gray,\
fg+:white,\
border:black,\
spinner:0,\
hl:yellow,\
header:blue,\
info:green,\
pointer:red,\
marker:blue,\
prompt:gray,\
hl+:red"

As you can see, some elements are related to some preview. What's that?

Preview in fzf
We can preview the current entry in fzf using a command of our choice. Let's see how.

Displaying a Preview
Here are all the different options we can use to display a preview in fzf:
-------------------------------------------------------------------------------------------------------------
Option               Description
-------------------------------------------------------------------------------------------------------------
--preview            Execute the given command for the current line, and display the result in the preview
                     window. The placeholder {} is replaced in the command by the current entry
                     (single-quoted).
-------------------------------------------------------------------------------------------------------------
--preview-window     General display of the preview window, including position, border&mldr;
-------------------------------------------------------------------------------------------------------------
--preview-label      Label to display on the horizontal line of the preview window. Can only be used when a
                     border is present (using the --preview-window option).
                     Position of the border's label on the preview window. Positive numbers represent the
-------------------------------------------------------------------------------------------------------------
--preview-label-pos  number of columns on the left (left-align), negative numbers the number of columns on the
                     right (right-align). 0 (the default) for center. Can add :bottom to put the label on the
                     bottom line of the border.
-------------------------------------------------------------------------------------------------------------

These options are not very intuitive; let's try some examples:
# Display the stats of each directory using the CLI "stat"
# For example, if the current entry is "./home", the preview command will be "stat './home'"
$> find . -type d | fzf --preview='stat {}'

# Display the preview window with a label centered on top.
$> find . -type d | fzf --preview='stat {}' \
--preview-label='[ Directory stats ]'

# Display the preview window with a label at the bottom, 3 rows from the left.
$> find . -type d | fzf --preview='stat {}' \
--preview-label='[ Directory stats ]' \
--preview-label-pos='3:bottom'

Using our [**1]companion project, here's the result for the last example:
Adding a preview to fzf's TUI
If the preview window is too small to display everything, you can still scroll through thanks to these
default keystrokes:
-----------------------------------------------
Keystroke     Description
-----------------------------------------------
SHIFT-UP      Scroll the preview one line up.
SHIFT-DOWN    Scroll the preview one line down.
-----------------------------------------------

Preview's Placeholder
If the placeholder {} as an integer N between the curly bracket, it will be replaced by the Nth field of the
preview's command output. By default, the field delimiter is space (AWK style).

For example, let's say that you want to add a number on each line to select them more easily (by just
querying the number you want, instead of the directory itself). We already saw how to do that above, using
the CLI "nl":
$> find . -type d | nl | fzf --preview='stat {}' \
--preview-label='[ Directory stats ]'

If you run the above, you'll notice that&mldr; it doesn't work! The placeholder will be replaced by the whole
entry line, including the prefixed number. If you want to replace the placeholder with only the second field
of your entry, you can do:
$> find . -type d | nl | fzf --preview='stat {2}' \
--preview-label='[ Directory stats ]'

This is similar to the option --nth (see the above section Limiting the Search). You can also use the option
--delimiter to use a different delimiter instead of space. For example, if we have a comma , as delimiter:
$> find . -type d | nl -s ',' | fzf --delimiter=',' --preview='stat {2}' \
--preview-label='[ Directory stats ]'

We can also put some flags between the curly brackets {} of the placeholder for different effects:
------------------------------------------------------------------------------------------------------------
Placeholder    Description
------------------------------------------------------------------------------------------------------------
{+}            Display the preview for all entries selected if you can select more than one (multi-selection
               enabled).
{s}            Keep leading and trailing whitespace if you use a specific field instead of the whole entry.
{q}            Replace the placeholder with the query string.
{n}            Replace the placeholder by the line number (zero-based).
------------------------------------------------------------------------------------------------------------

You can combine integers (to select different fields) and flags. For example, {+1} or {+n}

$> find . -type d | fzf \
--preview='echo "File(s) with index(es) {+n} and query {q} \n" && ls -l {-1}' \
--preview-label='[ Directory stats ]'

The result:
Using different preview placehoders with fzf with different flags

Here's a question which will help us build our file explorer: how to display all directories and the first 50
lines of their file trees in the preview? You can use the CLI "tree" and "head" to do so. It should give you
something like this:

Using fzf and a preview generated with the CLI tree
$> find . -type d | fzf --preview='tree -C {} | head -n 50'

The CLI tree normally displays files and directories of the directory given as argument. With the option -C,
it only displays directories.

What about modifying the display of the preview window thanks to the --preview-window option?

Layout of the Preview Window
Here's the general pattern you can use with the option --preview-window to modify its display:

--preview-window='[POSITION][,SIZE[%]][,border-BORDER_OPT][,[no]wrap][,[no]follow][,[no]cycle][,[no]hidden]\
[,+SCROLL[OFFSETS][/DENOM]][,~HEADER_LINES][,default]'

That's a lot of different values in there! Let's look at each of them:
---------------------------------------------------------------------------------------------------
Value               Description                                                      Default
---------------------------------------------------------------------------------------------------
POSITION            Position of the window; left, right, top, or bottom.             right
---------------------------------------------------------------------------------------------------
SIZE                Height of the window, in rows or percentage.                     50%
---------------------------------------------------------------------------------------------------
border-BORDER_OPT   Add a border. The placeholder BORDER_OPT can be replaced         border-rounded
                    with one of the borders seen above.
---------------------------------------------------------------------------------------------------
wrap or nowrap      Wrap the line                                                    nowrap
---------------------------------------------------------------------------------------------------
follow or nofollow  Automatically scroll to the bottom of the preview window.        nofollow
---------------------------------------------------------------------------------------------------
cycle or nocycle    Enable cyclic scroll (come back to the beginning when the        nocycle
                    end is reached)
---------------------------------------------------------------------------------------------------
hidden or nohidden  Hide the preview window. Can only be shown when keybinding the   nohidden
                    toggle-preview action (see below).
---------------------------------------------------------------------------------------------------
+SCROLL[OFFSETS][/  Set an offset for the preview's window scroll. See the man       * 
DENOM]              page for more details.
---------------------------------------------------------------------------------------------------
~HEADER_LINES       Always keep the N lines of the preview on top of the preview     * 
                    window.
---------------------------------------------------------------------------------------------------
default             Reset any option set before to the default.                      * 
---------------------------------------------------------------------------------------------------

You can use these values in any order. For example:
$> find . -type d | fzf \
--preview='tree -C {} | head -n 50' \
--preview-window=70%,border-double,top

The result you've been waiting for all your life:
Using fzf and a preview generated with the CLI tree and a custom display

Binding Keystrokes or Events to Actions
We can now create a custom file explorer, even with a preview window if we want to. But we're missing an
important feature: being able to bind keystrokes to different commands. It would be nice, for example, to be
able to refresh the list of files or directories, in case some were created after opening the file explorer
itself.

The Bind Option
Here's the option we'll use a lot below:
-------------------------------------------------------------------------------
Option    Description
-------------------------------------------------------------------------------
--bind    Comma-separated list of pairs of keybindings (or events) and actions.
-------------------------------------------------------------------------------

For example, to reload a directory list:
$> find . -type d | fzf \
--bind='ctrl-r:reload(find -type d)' \
--header='CTRL-r to refresh the list'

To test if it works as expected, you can try to:
 1. Run the command above.
 2. Create another directory in another shell.
 3. Refresh fzf's entry list with `CTRL-r.
 4. The directory you've created should appear programagically.

As you can see, the pair of keybinding (ctrl-r) and action (reload(find -type d)) is separated by a colon :.
We can add more of these pairs; for example, if we want to delete the current directory (with a prompt asking
if we really want to to that), we can do the following:
$> find . -type d | fzf  \
--bind 'ctrl-r:reload(find -type d),del:execute(rm -ri {})' \
--header='CTRL-R to refresh the list | CTRL-P to toggle the preview | DEL to delete the current directory'

The action execute is very useful: it can execute any arbitrary command in a subshell; the placeholder {} is
replaced with the value of the current entry. This placeholder works exactly like the preview's placeholder
we've discussed above.

It would also be nice to automatically reload the list after deleting a directory, for it not to appear as an
entry in fzf. To chain different actions to the same keystroke, we can use the + separator, as follows:
$> find . -type d | fzf \
--bind='ctrl-r:reload(find -type d)' \
--bind='del:execute(rm -ri {})' \
--bind='del:+reload(find -type d)' \
--header='CTRL-R to refresh the list | CTRL-P to toggle the preview | DEL to delete the current directory'

As you can see, our command to create fzf's entries (find . -type d) begins to be repeated all over the
place. We can create a variable for that and use it everywhere:

FZF_EXPLORER_CMD="find . -type d" && \
eval $FZF_EXPLORER_CMD | fzf
--bind "ctrl-r:reload($FZF_EXPLORER_CMD)" \
--bind 'del:execute(rm -ri {})' \
--bind "del:+reload($FZF_EXPLORER_CMD)" \
--header='CTRL-R to refresh the list | CTRL-P to toggle the preview | DEL to delete the current directory'

Remember FZF_DEFAULT_COMMAND? It's the default command used by fzf under the hood when we don't give any
input. If you don't mind overwriting this environment variable the time of a command, you can do the
following:

FZF_DEFAULT_COMMAND="find . -type d" fzf \
--preview='tree -C {}' \
--bind='ctrl-r:reload(eval $FZF_DEFAULT_COMMAND)' \
--bind='del:execute(rm -ri {})' \
--bind='del:+reload(eval $FZF_DEFAULT_COMMAND)' \
--header='CTRL-R to refresh the list | CTRL-P to toggle the preview | DEL to delete the current directory'

Using Events and Actions
We've bound keystrokes and actions until now, but there are also a couple of events we can use instead of
these keystrokes. Here's the complete list:
---------------------------------------------------------------------------------------------------------
Event           Description
---------------------------------------------------------------------------------------------------------
start           Triggered when fzf starts.
change          Triggered when the query is changed.
backward-eof    Triggered when the query is empty but the user still tries to delete characters backward.
---------------------------------------------------------------------------------------------------------

Taking back our example above, we could refresh the list of directory each time we change our query:

FZF_DEFAULT_COMMAND="find . -type d" fzf \
--bind='change:reload(eval $FZF_DEFAULT_COMMAND)' \
--bind='del:execute(rm -ri {})' \
--bind='del:+reload(eval $FZF_DEFAULT_COMMAND)' \
--header='CTRL-R to refresh the list | CTRL-P to toggle the preview | DEL to delete the current directory'

Be careful if you use the start event: fzf creates the list of entries asynchronously, which means that you
might not have all entries when the event is triggered. In that case, use the fzf option --sync to build the
list synchronously, only displaying the TUI (and triggering the start event) after all entries have been
generated. The downside: it might feel slower, because you won't see the TUI until the list is fully built.

Useful Actions
I won't list all the possible actions we can bind in this article. You can have the complete list by looking
at the fzf's manual page (man fzf, search for AVAILABLE ACTIONS).

Some actions take arguments, some don't. Actions with arguments are suffixed below with (...), exactly like
in fzf's manual page:
-------------------------------------------------------------------------------------------------------------
Action                Description
-------------------------------------------------------------------------------------------------------------
execute(...)          Switch to the alternate screen and execute a command in a sh subshell. Return to fzf
                      when it's done. Similarly to the --preview option, you can use a placeholder {} for the
                      current entry.

execute-silent(...)   Execute a command in a sh subshell, in the current screen, without leaving fzf (but
                      block fzf the time the command run). Similarly to --preview, you can use the
                      placeholder {} for the current entry.

preview(...)          Specify one more preview command, additionally to the one given to the --preview
                      option.

change-preview(...)   Change the --preview option.
refresh-preview       Refresh the preview.
change-preview-window Change the value of --preview-window. Use the delimiter | to create (and cycle through)
(...)                 different groups of options.

change-prompt(...)    Change the prompt to the given characters.
reload(...)           Reload the list of entries with the given command.
select-all            Select all matches.
deselect-all          Clear the selection.
toggle-all            Toggle all matches.
toggle-sort           Toggle the sorting.
replace-query         Replace the query with the current selection.
clear-query           Delete the query.
unbind(...)           Unbind a binding keystroke.
rebind(...)           Rebind a keystroke after unbinding it.
abort                 Close fzf.
-------------------------------------------------------------------------------------------------------------

You know what's next: yep, some examples.
# Close fzf with CTRL-D
$> fzf --bind='ctrl-d:abort'

# Display the preview with CTRL-P
$> fzf --preview-window=hidden --bind='ctrl-p:preview(stat {})'

# Change the preview with CTRL-P
$> fzf --preview='file {}' \
--bind='ctrl-p:change-preview(stat {})'

# Change the position and size of the preview window with CTRL-P
$> fzf --preview='file {}' \
--bind='ctrl-p:change-preview-window(20%,top|50%,right)'

# Change the prompt with CTRL-P
$> fzf --preview='file {}' \
--bind='ctrl-p:change-prompt(→ )'

# Delete the file or directory with DEL
$> fzf --preview='file {}' \
--bind='del:execute(rm -ri {})'

# Reload the list of files
$> find . -type f | fzf \
--bind='ctrl-r:reload(find . -type f)'

# Bind CTRL-A to select all entries
# Unbind CTRL-A and rebind it with, respectively, CTRL-U and CTRL-R
$> find . -type f | fzf --multi \
--bind='ctrl-a:select-all' \
--bind='ctrl-u:unbind(ctrl-a)' \
--bind='ctrl-r:rebind(ctrl-a)'

Putting it Together: a File Explorer with fzf
It's time! We looked at fzf enough to be able to create our file explorer. Here are the requirements:

  * It should display files by hitting CTRL-f, or directories by hitting CTRL-d.
  * It should display directories by default.
  * The user should know what keystrokes she can use.
  * The user should be able to select one or multiple files or directories.
  * Switching to files or directories should refresh fzf's list as well as the preview.
  * Both files and directories should be open using the default text editor when hitting ENTER.
  * Everything can be selected with CTRL-a.
  * Everything can be de-selected with CTRL-x.
  * The preview window can be hidden with CTRL-p
  * The user can delete selected files or directories with DEL. There should be a prompt to confirm the
    choice.

Concerning the TUI:
  * The height should be 90%.
  * The preview window should be 45% wide, on the right.
  * The border should be sharp.
  * The border of the preview window should be sharp.

If files are displayed:
  * The prompt should be Files > .
  * The preview should be the content of the current file.

If directories are displayed:
  * The prompt should be Dirs > .
  * The preview should be the tree of the current directory.

So, how would you build that? Don't worry if you don't succeed: the most important is to try. It will help
you remember the solution.

Here's the result:
Using fzf as a file explorer (or a directory explorer)Click to enlarge

Here's my solution:

$> find -type d | fzf --multi --height=80% --border=sharp \
--preview='tree -C {}' --preview-window='45%,border-sharp' \
--prompt='Dirs > ' \
--bind='enter:execute($EDITOR {+})' \
--bind='del:execute(rm -ri {+})' \
--bind='ctrl-p:toggle-preview' \
--bind='ctrl-d:change-prompt(Dirs > )' \
--bind='ctrl-d:+reload(find -type d)' \
--bind='ctrl-d:+change-preview(tree -C {})' \
--bind='ctrl-d:+refresh-preview' \
--bind='ctrl-f:change-prompt(Files > )' \
--bind='ctrl-f:+reload(find -type f)' \
--bind='ctrl-f:+change-preview(cat {})' \
--bind='ctrl-f:+refresh-preview' \
--bind='ctrl-a:select-all' \
--bind='ctrl-x:deselect-all' \
--header '
CTRL-D to display directories | CTRL-F to display files
CTRL-A to select all | CTRL-x to deselect all
ENTER to edit | DEL to delete
CTRL-P to toggle preview
'

Now, can we improve this explorer by editing the files using the current editor when we display the files
only, but moving to the good directory when we display the directories only?

First, we need to know if the current entry is a file or directory, to either change the working directory or
edit the file with $EDITOR. Let's try to add a conditional as argument to "execute":
--bind='enter:execute(if [ -d {} ]; then cd {}; else $EDITOR {+}; fi)+abort'

But this won't work. The action execute will run cd in a subshell (doing sh -c under the hood), which won't
change the directory of the current shell.

No choice here: we need to create a bash script to solve our problem.

<code>
#!/usr/bin/env bash

# Store the STDOUT of fzf in a variable
selection=$(find -type d | fzf --multi --height=80% --border=sharp \
	--preview='tree -C {}' --preview-window='45%,border-sharp' \
	--prompt='Dirs > ' \
	--bind='del:execute(rm -ri {+})' \
	--bind='ctrl-p:toggle-preview' \
	--bind='ctrl-d:change-prompt(Dirs > )' \
	--bind='ctrl-d:+reload(find -type d)' \
	--bind='ctrl-d:+change-preview(tree -C {})' \
	--bind='ctrl-d:+refresh-preview' \
	--bind='ctrl-f:change-prompt(Files > )' \
	--bind='ctrl-f:+reload(find -type f)' \
	--bind='ctrl-f:+change-preview(cat {})' \
	--bind='ctrl-f:+refresh-preview' \
	--bind='ctrl-a:select-all' \
	--bind='ctrl-x:deselect-all' \
	--header '
	CTRL-D to display directories | CTRL-F to display files
	CTRL-A to select all | CTRL-x to deselect all
	ENTER to edit | DEL to delete
	CTRL-P to toggle preview
	'
)

# Determine what to do depending on the selection
if [ -d "$selection" ]; then
	cd "$selection" || exit
else
	eval "$EDITOR $selection"
fi
</code>

Then, we need to call it in the current shell. For example:
$> source explorer.sh

Fixing Performance Issues
In general, fuzzy search with fzf is blazlingly fast. That said, you might run into performance issues if you
have too many entries for example. Here are some options you shouldn't use if you want to improve the
performances:
-------------------------------------------------------------------------------------------
Option         Description
-------------------------------------------------------------------------------------------
--ansi         Parse ANSI color codes from the input and makes the initial scanning slower.
--nth          Limit search scope, but tokenize each entry and make fzf slower.
--with-nth     Transform the presentation of each line, but make fzf slower.
-------------------------------------------------------------------------------------------

If you're not using any of the above and you still have performance issues, you can also try to change fzf's
search engine. By default, it uses "v2", but you can switch to "v1" as follows:
$> fzf --algo=v1

Fuzzy Find Forever
The file explorer we've created might not be of the taste of everybody, but that's the real power of CLIs:
you can often customize them for your own needs and preferences.

What did we see in this article?
  * fzf is a fuzzy finder, allowing us to match a plain text query against line-separated inputs.
  * We can overwrite fzf's default command and options with environment variables.
  * fzf allows multi-selection with the option -m (or --multi).
  * Some metacharacters (similar to regex patterns) can be used for queries: ^,$, or | for example.
  * To limit the search scope, we can specify what part of the entry we want to be searchable, thanks to
    --nth and --delimiter.
  * fzf provides many different options to customize its TUI.
  * Creating a preview (the output of a command) is quite easy with the --preview option.
  * We can bound many actions to different keystrokes or events, to create a trully unique experience.
  * Some options take more resources than other; better disabling them if you're runnning into performance
    issues.

As you can see, fzf is general enough to fit many use cases. It's simple yet powerful, to help us customize
our workflow as much as we can. The links belows have many more examples; you're now able to understand them,
and customize them as you see fit!


---
https://thevaluable.dev/fzf-shell-integration/

2. A Practical Guide to fzf: Shell Integration

   This article is part of a series about fzf:

   Becoming a fzf master
    1. [https://thevaluable.dev/practical-guide-fzf-example/]A Practical Guide to fzf: Building a File Explorer
    2. [https://thevaluable.dev/fzf-shell-integration/]A Practical Guide to fzf: Shell Integration
    3. [https://thevaluable.dev/fzf-vim-integration/]A Practical Guide to fzf: Vim Integration
    4. [https://thevaluable.dev/fzf-git-integration/]A Practical Guide to fzf: Building a Git Explorer

   In the (1)previous article of this series, Davina (your colleague developer) explained how powerful
   fzf can be to create our own fuzzy search and, to an extent, our own TUIs.

   Good news everyone: Davina is back! This time, her mission is to explain how to integrate fzf with
   the shell. This integration adds many new functionalities to your favorite shell, making it even more
   powerful.

   You can use fzf's shell integration if you use either Bash, Zsh, or Fish. I'm not the biggest fan
   of Fish (it's not POSIX compatible), so I will focus mostly on Bash and Zsh in this article.

   More specifically, we'll see:
     * What keystrokes we can use to fuzzy search through files and directories.
     * How to use a completion using fzf in the shell.
     * How to customize keybindings and completions.
     * How to launch fzf in tmux panes automatically.

   I encourage you to try out the different configurations described in this article. To follow along,
   you can download the [**1]companion project and run the different commands from there. Most of the
   screenshots are executed from this guide-fzf directory.

   Keybinding and completion are possible thnaks to a couple of files which need to be sourced in your
   shell. I'm using Arch Linux (by the way), so for me these files are located in the directory
   /usr/share/fzf/. You can also find them in the official repository of fzf. The files with the
   extension .bash need to be sourced if you use Bash; the same for Zsh.

   Here's how I source them in my zshrc:
source /usr/share/fzf/key-bindings.zsh
source /usr/share/fzf/completion.zsh

   Depending on what OS you're running and how you've installed fzf on your machine, these files might
   be in a different place. You can also copy them manually somewhere in your system and source them,
   too.

   Let's now dive in these files to see what secrets they hold!

Keybinding with fzf
   Let's begin by the keybindings: what keystrokes can we hit in our shells to invoke the power of fzf?

Keystrokes Available
   If you open the file "key-bindings.bash", you'll see the different binding declared at the end of the
   file, using the commands bind.

   Here's the list of all keystrokes available:
   Keystroke Description
   * CTRL-t Fuzzy find all files and subdirectories of the working directory, and output the selection to
     STDOUT.
   * ALT-c Fuzzy find all subdirectories of the working directory, and run the command "cd" with the output as
     argument.
   * CTRL-r Fuzzy find through your shell history, and output the selection to STDOUT.

   My life would be grimmer without CTRL-r. I'm searching in my shell history all the time, to run
   similar commands I ran in the past. Here's how it looks in my shell:
   Using fzf in the shell to search the history

   The keystroke CTRL-t is also very useful if you want to quickly edit a file. I just have to type vim
   in my terminal followed by CTRL-t to search the file I want to edit.
   Using fzf in the shell to search the files and directories

   Finally, ALT-c is useful if you want to search for and move into a subdirectory.
   Using fzf in the shell to search the files

   This is great, but what I'd like to do now is to configure all of these keystrokes according to my
   own specific needs.

Customizing fzf Keybindings
   If you look a bit closer at the completion file, you'll find three functions called by our three
   keystrokes:

   ------------------------------------------------
   Keystroke   Bash function     Zsh function
   ------------------------------------------------
   CTRL-t      __fzf_select__    __fsel
   CTRL-r      __fzf_history__   fzf-history-widget
   ALT-c       __fzf_cd__        fzf-cd-widget
   ------------------------------------------------

   The body of these functions will give you the commands executed each time you hit one of the
   keystrokes. For example, here's the command running when you hit CTRL-t:
cmd="${FZF_CTRL_T_COMMAND:-"command find -L . -mindepth 1 \\( -path '*/\\.*' \
-o -fstype 'sysfs' \
-o -fstype 'devfs' \
-o -fstype 'devtmpfs' \
-o -fstype 'proc' \\) -prune \
-o -type f -print \
-o -type d -print \
-o -type l -print 2> /dev/null | cut -b3-"}"

   Here, the command find is used with many different expressions to filter the result of the search. If
   you want to know more about find, I've written an article about it
   [https://themouseless.dev/posts/find-guide-example-mouseless/]here.

   We can also see that the command itself can be overwritten with the value of the environment variable
   FZF_CTRL_T_COMMAND. There are more environment variables available to overwrite commands; you can
   find them at the beginning of the completion file. Here's the list:

   ---------------------------------
   Environment variable    Keystroke
   ---------------------------------
   FZF_CTRL_T_COMMAND      CTRL-t
   FZF_ALT_C_COMMAND       ALT-c
   ---------------------------------

   We can't change the default command for CTRL-r, to search through the shell history. It's because
   there are some scripts involved here; an AWK script for Zsh, a Perl script for Bash.

   Looking at the beginning of the "keystroke" file, you'll see other environment variables allowing us
   to set fzf's default options depending on the keystroke we use:

   ---------------------------------
   Environment variables   Keystroke
   ---------------------------------
   FZF_CTRL_T_OPTS         CTRL-t
   FZF_CTRL_R_OPTS         CTRL-r
   FZF_ALT_C_OPTS          ALT-c
   ---------------------------------

   Here's an example:
export FZF_CTRL_T_OPTS="--height 60% \
--border sharp \
--layout reverse \
--prompt '∷ ' \
--pointer ▶ \
--marker -->"

   If you run the above in your shell, these options will be given to fzf each time you hit CTRL-t.

   What about changing the keystrokes themselves? If you look at the end of the file
   "key-bindings.bash", you'll see their definitions. For example:
bind -m emacs-standard '"\ec": " \C-b\C-k \C-u`__fzf_cd__`\e\C-e\er\C-m\C-y\C-h\e \C-y\ey\C-x\C-x\C-d"'
bind -m vi-command '"\ec": "\C-z\ec\C-z"'
bind -m vi-insert '"\ec": "\C-z\ec\C-z"'

   The keystroke itself is \ec here, meaning ALT-c. Let's say that we don't like to use ALT-c, but
   instead we'd like to use CTRL-e. First, we need to find in the file key-bindings.bash the good
   keystroke:
bind -m emacs-standard '"\ec": " \C-b\C-k \C-u`__fzf_cd__`\e\C-e\er\C-m\C-y\C-h\e \C-y\ey\C-x\C-x\C-d"'

   Next, we need to add the following to our bashrc:
bind -m emacs-standard '"\C-e": " \C-b\C-k \C-u`__fzf_cd__`\e\C-e\er\C-m\C-y\C-h\e \C-y\ey\C-x\C-x\C-d"'

   Here, we create a new keystroke using CTRL-e (represented by \C-e), which will do the same as ALT-c.

   For Zsh, if you look into the file "key-bindings.zsh", you'll see the different keybindings set in
   the different functions themselves. The idea stays the same; first, we need to find the different
   keystrokes we want to change:
zle     -N             fzf-cd-widget
bindkey -M emacs '\ec' fzf-cd-widget
bindkey -M vicmd '\ec' fzf-cd-widget
bindkey -M viins '\ec' fzf-cd-widget

   Then, we can add the following to our zshrc:
zle     -N            fzf-cd-widget
bindkey -M emacs '\C-e' fzf-cd-widget
bindkey -M vicmd '\C-e' fzf-cd-widget
bindkey -M viins '\C-e' fzf-cd-widget

   It's also possible to unbind ALT-c if you want to. I've already written an article about
   [https://thevaluable.dev/zsh-line-editor-configuration-mouseless/]Zsh and keybindings if you want to know
   more about that. For now, here's how to unbind the default keystroke ALT-c:
bindkey -rM emacs '\ec'
bindkey -rM vicmd '\ec'
bindkey -rM viins '\ec'

Completion Using fzf
   Having some keystrokes to fire fzf and search through your files, directories, or history is really
   useful, but it's only half the functionalities fzf gives us to make the shell even more powerful. The
   other half is about completion.

Command and Trigger
   Let's type the following in our shell, followed by the TAB key:
vim **

   We can trigger fzf's completion with two stars followed by hitting tab

   You can then select the files and directories you want (multi-selection is enabled here), and Vim
   will open them all.

   There are two important elements in the command above: vim (the command itself), and **, which fzf
   recognizes as a trigger for completion. Said differently, if you don't write **, hitting TAB won't
   trigger fzf.

   The completion will be different depending on the command. For example, we just saw that triggering
   the completion with Vim will give you files and directories (the default behavior for most commands).
   But if you try to complete "cd" for example, you'll get only directories:
cd **

   Here's the result:
   The completion for cd will only display directories

   Whatever is put before the trigger will be used as query for fzf. For example:
cd mouseless-book-behind-scene**

   The result:
   It's possible to add a query before the completion trigger

   You'll notice that you can't have multiple selections here; after all, "cd" needs only one argument.

   When you think about it, most commands get some paths (files or directories) as arguments; as a
   result, fzf's give you paths by default for the completion. As we just saw, other commands will only
   give you directories. Here's the complete list of these commands:
     * cd
     * pushd
     * rmdir

   If you look in the file "completion.bash", you can search for the two variables a_cmds and d_cmds.
   The first is used for completing paths, the second to only complete directories. For Zsh it's the
   same, except that everything which is not part of the value of the variable d_cmds will be completed
   with paths.

   Of course, there are commands expecting other arguments than file or directory paths. Some of them
   are supported out of the box; here's the complete list:

   ------------------------------------------------------------------------------------------------
   Command    Completion
   ------------------------------------------------------------------------------------------------
   export     Environment variables
   unset      Environment variables
   unalias    Aliases (use the command alias under the hood).
   ssh        Hosts (grep entries from ~/.ssh/config, ~/.ssh/config.d/* , and /etc/ssh/ssh_config).
   telnet     Hosts (grep entries from /etc/hosts).
   kill       Processes (use the command ps -ef under the hood).
   ------------------------------------------------------------------------------------------------

   Looking at the completion files, how do we know what command triggers what completion? The name of
   the functions can help here; for example, _fzf_complete_export will trigger the completion after the
   command export, at least for Zsh. For Bash, the functions are called differently, referencing what
   they complete instead of what command they complete; for example _fzf_var_completion() complete
   environment variables.

Customizing the Completion
   If you look at one of the completion files, you'll see again at the very top of the file all the
   environment variables you can use to customize the completion.
# - $FZF_TMUX               (default: 0)
# - $FZF_TMUX_OPTS          (default: '-d 40%')
# - $FZF_COMPLETION_TRIGGER (default: '**')
# - $FZF_COMPLETION_OPTS    (default: empty)

   There's one environment variable missing, however: $FZF_COMPLETION_DIR_COMMANDS. It allows us to
   specify the commands which should only be completed with directories. For example:
export FZF_COMPLETION_DIR_COMMANDS="cd pushd rmdir tree"

   Here, I've added back the three commands which should have directory paths as completion (cd, pushd,
   and rmdir), and I've added tree. Next, if we try to complete tree **, we'll get the following:
   We can assign new commands to fzf directory-only completion

   Here are the two other interesting environment variables referenced at the beginning of the file
   (let's forget about the tmux related ones for now):
$FZF_COMPLETION_TRIGGER (default: '**')
$FZF_COMPLETION_OPTS    (default: empty)

   It's self-explanatory enough: the first one allow us to change the completion trigger, and the second
   one can let us add some options to fzf each time we trigger the completion.

   What about changing the different commands used for the completion themselves? You can create two
   functions to do so:
     * _fzf_compgen_path
     * _fzf_compgen_dir

   Here are the default commands:
_fzf_compgen_path() {
	find -L "$1" \
		-name .git -prune -o -name .hg -prune -o -name .svn -prune -o \( -type d -o -type f -o -type l \) \
		-a -not -path "$1" -print 2> /dev/null | sed 's@^\./@@'
}

_fzf_compgen_dir() {
		find -L "$1" \
		-name .git -prune -o -name .hg -prune -o -name .svn -prune -o -type d \
		-a -not -path "$1" -print 2> /dev/null | sed 's@^\./@@'
}

   Instead of using find, we could use ripgrep or fd for example:
_fzf_compgen_path() {
	rg --files --glob "!.git" . "$1"
}

_fzf_compgen_dir() {
	fd --type d --hidden --follow --exclude ".git" . "$1"
}

   We change here the default completion "path" to only complete files, and not files and directories.

Managing your Own Completion
   The first way to create our own custom completion is to simply create a new function named
   _fzf_complete_<cmd_name>. For example, to create a completion for the "git" command:

_fzf_complete_git() {
	_fzf_complete -- "$@" < <(
		echo log
		echo diff
	)
}

   With this, you can run git **, and you'll have the choice between log or diff for the completion.
   That's a naive approach however, because you need to add here all the completions possible. Here's a
   more useful function:

_fzf_complete_git() {
	_fzf_complete -- "$@" < <(
		git --help -a | grep -E '^\s+' | awk '{print $1}'
	)
}

   This will allow you to complete all git subcommands using fzf!

   There is another interesting function allowing us to give any command for completing any CLI out
   there: the "comprun" function. For example, if we want to run a specific command to complete the CLI
   "tree", we can run the following:

_fzf_comprun() {
	local command=$1
	shift

	case "$command" in
		tree)  find . -type d | fzf --preview 'tree -C {}' "$@";;
		*)     fzf "$@" ;;
	esac
}

   Then, if you try to complete tree **, it will run the corresponding commands (the find . -type d
   command). The $@ at the end pass all the arguments given to fzf. The result:
   We can customize fzf's completion with the comprun function

fzf and tmux
   If you're using tmux already, you can force fzf to open in a new pane of your tmux session. To do
   so, you need to use a script wrapping fzf, called fzt-tmux. Of course, you already need to be in a
   tmux session for the following to work:
fzf-tmux --height 50%

   fzf can run in a tmux pane

   Do you remember the environment variables at the beginning of the completion files? Two of them are
   directly about tmux:
   ---------------------------------------------------------------------------------------------------
   Environment variable   Description                                               Default when empty
   ---------------------------------------------------------------------------------------------------
   FZF_TMUX               If set to 1, fzf's will open in a new tmux pane when      0
                          using a keystroke or the completion.
   ---------------------------------------------------------------------------------------------------
   FZF_TMUX_OPTS          Gives default options to fzf; automatically use a         -d 40%
                          new pane for keystrokes or the completion if the
                          value of the variable is not empty.
   ---------------------------------------------------------------------------------------------------

   Said differently, if you already give a value to FZF_TMUX_OPTS, there is no need to set FZF_TMUX to
   1; keybindings and completion will always open in a new tmux pane in that case.

   There's even a short man page you can read: man fzf-tmux. The most noticeable option is -p, to open
   fzf in a tmux floating pane. You can try it by yourself easily:
fzf-tmux -p

   fzf can run in a floating tmux pane

   How fancy!

More Power to the Shell
   You can now configure and customize fzf following your craziest wishes. You can adapt it to match
   your workflow in the holy shell!

   What did we see in this article?
     * We can use multiple keystrokes in our shell to launch fzf: CTRL-t, CTRL-r, and ALT-c. We can
       customize the options given to fzf, as well as the commands used to populate fzf's list.
     * We can also complete some shell commands using fzf, by default triggered with ** (followed by
       TAB). Really handy to find files or directory quickly, or anything else you want!
     * We have different ways to create our own completion: using the "comprun" function, or by defining
       our own custom functions.
     * We can also open fzf inside a tmux pane automatically (even a floating one), when using
       keybindings or completion, using the wrapper script fzf-tmux.

   The shell is already a powerful environment, and fzf makes it even more useful. It has been a huge
   game changer for my own workflow throughout the years.


---
https://thevaluable.dev/fzf-vim-integration/

3. A Practical Guide to fzf: Vim Integration

This article is the third part of a series about fzf:

Becoming a fzf master
 1. A Practical Guide to fzf: Building a File Explorer
 2. A Practical Guide to fzf: Shell Integration
 3. A Practical Guide to fzf: Vim Integration
 4. A Practical Guide to fzf: Building a Git Explorer

Davina, your colleague developer, explained in the two previous articles of the series how to use and
configure fzf for the shell. This time, she's back to explain how to use fzf directly in the Best Editor in
the Known Universe™, Vim (or Neovim).

Vim vanilla functionalities are often enough to do what we want to do, but not this time. To use fzf in Vim,
we'll have to use two plugins:

 1. A first plugin, coming directly with fzf. I'll call it the "native fzf plugin" in this article.
 2. Another plugin, fzf.vim, adding new user commands and global options.

The plugin fzf.vim is built on top of the native fzf plugin, that's why we'll need to use both. They are
great plugins for two reasons:

 1. They are not bloated. It's not too hard to dig in the code and understand how they work.
 2. They are both written by the author of fzf itself, and he's far from being an amateur.

I'll try to clearly specify what plugin bring what functionality in this article. In fact, if you're ready to
spend more time to configure fzf in Vim, you can skip fzf.vim entirely, and only rely on the native fzf
plugin.

We'll see, in this article:
  * How to install these two plugins to harness fzf power in Vim.
  * The default user commands offered by the plugin fzf.vim.
  * The global variables we can use to configure further the fzf integration.
  * The basic functions allowing us to build our own user commands.

Are you ready to fuzzy find everything and anything? Me neither, but let's dive anyway.

Installing the fzf Plugins for Vim
Let's first install the two plugins we were speaking about in the introduction.

They can be installed like any other plugin; for example, if you use a plugin manager like vim-plug, you can
simply add the following to your Vim config:

" fzf native plugin
Plug 'junegunn/fzf'

" fzf.vim
Plug 'junegunn/fzf.vim'

Nothing earth-shattering here. That said, the native fzf plugin is automatically installed when you install
fzf itself. As a result, you can directly include fzf's directory in your runtime path. For example, if you
installed fzf with homebrew, you can add the following to your Vim config to get the native fzf plugin:

set rtp+=/usr/local/opt/fzf

If you're using Arch Linux: you don't need to do anything to use the native fzf plugin, it's directly
included in your Vim's global plugin directory when you install fzf with pacman. It means that it will always
be sourced when Vim starts.

It's also interesting to note that the native fzf plugin is quite small (it's only one file). If you decide
to only use this one, your integration's footprint will be minimal.

That's it! Next!

The Default User Commands
The plugin fzf.vim comes with many different user commands you can use from the get-go. They allow you to
search through your files to find and edit what you want.

I describe, in this section, some of the user commands I find the most useful. There are many others you can
find in the plugin's README file.

Searching Through Files

Using fzf in vim with the :File Ex command
To search any file in your project by its filename, you can always use the Ex command :find in vanilla Vim.
But you need to already know where the file is located in your filesystem (more or less), and it can be
cumbersome to always have to type a pattern to narrow down the search.

In my opinion, it's where fuzzy finding becomes handy. The plugin fzf.vim offers you a couple of Ex commands
which can help you search the filenames you want to edit:
-------------------------------------------------------------------------------------------------------------
Ex command    Description
-------------------------------------------------------------------------------------------------------------
:Files        Populate fzf with all the filenames from the {directory}, recursively. The working directory is
{directory}   used if no {directory} is specified.
:GFiles       Populate fzf with the filenames of all the files added to Git (using the shell command git
              ls-files under the hood).
:History      Populate fzf with the history of open filenames.
-------------------------------------------------------------------------------------------------------------

How these Ex commands work, you might rightfully ask?

Under the hood, the commands above run a shell command defined by the environment variable
FZF_DEFAULT_COMMAND, to populate fzf with a list of filenames. It also uses the environment variable
FZF_DEFAULT_OPTS to give to fzf some default options.

If these environment variables are not defined, fzf uses the
[https://thevaluable.dev/find-cli-guide-examples/]CLI find to get the list of filenames it needs.  If you want
to know more about these two environment variables, I've written about them in the first article of this
series.

You can also use a couple of keystrokes directly in fzf after running one of the command above. They allow
you to edit the files you want to edit in new split windows or tabs:
-----------------------------------------------------
Keystroke    Description
-----------------------------------------------------
ENTER        Open the file in the current window.
CTRL-x       Open the file in a new horizontal split.
CTRL-v       Open the file in a new vertical split.
CTRL-t       Open the file in a new tab.
-----------------------------------------------------

When you hit any keystroke described above, Vim will run an Ex command with the entry selected as argument.
For example, when you hit ENTER after selecting the file a, Vim will run the Ex commands :edit a. If you hit
CTRL-v, :vsplit will be used instead of :edit.

Since fzf runs with
[https://thevaluable.dev/practical-guide-fzf-example/#selecting-more-entries-with-multi-selection]multi-selection
on, you can hit the TAB key to select more than one file to edit them all! In that case, Vim will run the
different Ex commands (:edit for example) multiple times.

Using the Fzf Ex Command
There is another, more flexible command you can use to search through your files using their filenames. This
one is implemented in the native fzf plugin; as a result, you won't need fzf.vim to use it. Here it is:
------------------------------------------------------------------------------------------------------------
Ex command     Description
------------------------------------------------------------------------------------------------------------
:FZF           Populate fzf with all the filenames from the {directory}, recursively. It also gives fzf some
{options}      {options}. The working directory is used if no {directory} is specified.
{path}
------------------------------------------------------------------------------------------------------------

Again, both environment variables FZF_DEFAULT_COMMAND and FZF_DEFAULT_OPTS are used if they are defined.

Here's an example:
:FZF --multi --layout=reverse-list --info=inline --pointer=→  --marker=♡

If you know how to use fzf in your shell, it's then easy to use :FZF in Vim to search any file you want. If
you want more options to feed the gluttony fzf, you can look at the first article of this series.

It's not easy to craft more complex commands, however. For example, you'll have a hard time to display a
preview of the files, configuring the layout, or even change the syntax highlighting.

Searching Through the Content of Files

Using fzf with ripgrep
The above user commands are great, but you need to have an idea of the filename you want to edit to use them
effectively. What if you want to search into your files' content directly? Vanilla Vim already offers many
functionalities to do so natively, but being able to fuzzy search through all this content is even more
effective.

The plugin fzf.vim offers a couple of user commands directly using two external CLIs:
  * ag - The Silver Searcher
  * rg - ripgrep

Here they are:
---------------------------------------------------------------------------------------------
Ex command       Description
---------------------------------------------------------------------------------------------
:Ag [pattern]    Use The Silver Searcher to search the [pattern] through your files' content.
:Rg [pattern]    Use ripgrep to search the [pattern] through your files' content.
---------------------------------------------------------------------------------------------

You can also use two handy keystrokes when fzf pops up:
---------------------------------
Keystroke    Description
---------------------------------
ALT-a        Select all files.
ALT-d        De-select all files.
---------------------------------

Again, you can select multiple entries to edit all the files selected. It's interesting to note that, in that
case, a [https://thevaluable.dev/vim-advanced/#quickfix-lists]quickfix list will also be created and filled
with these files. Handy if you need to do some
[https://thevaluable.dev/vim-advanced/#vims-quickfix-and-location-list]operations across all the selected
files, for example.

Searching Through Open Buffers

Using fzf in Vim to search a buffer
What about searching directly through your open buffers using fzf? It can be a good alternative to the
:buffer Ex command, especially if you have an unfathomable amount of buffers open.

Here are the magical commands you always wanted:
---------------------------------------------------------------
Ex command    Description
---------------------------------------------------------------
:Buffers      Search through all open buffers.
:Lines        Search through the content of all open buffers.
:BLines       Search through the content of the current buffer.
---------------------------------------------------------------

Again, it's interesting to note that both :Lines and :BLines will fill a quickfix list if multiple entries
are selected.

Searching Through Command and Search Histories

Using fzf in Vim to search through your histories
It's also possible to fuzzy-find your way through different histories, like your Ex command history or even
your search history:
-----------------------------------------------------
Ex command    Description
-----------------------------------------------------
:History:     Search through your Ex command history.
:History/     Search through your search history.
-----------------------------------------------------

As a reminder, the [https://thevaluable.dev/vim-intermediate/#command-line-window]Ex command history gives all
the executed Ex command you've run.

Searching Through your Mapping

Using fzf in Vim to search through your mapping
Have you ever wonder how to go through your mapping? By default in Vim, you can use the
[https://thevaluable.dev/vim-expert/#verbose-commands]verbose Ex command :verbose to do so. You can also use
fzf:
-----------------------------------------------------
Ex command    Description
-----------------------------------------------------
:Maps         Search through all NORMAL mode mapping.
-----------------------------------------------------

Adding a Prefix to the Default Fzf Ex-Commands
If you don't like the names of the Ex commands provided by fzf.vim, or if they conflict with your own user
commands, you can add a prefix to their names using the global variable g:fzf_vim.command_prefix. For
example:

let g:fzf_vim = {}
let g:fzf_vim.command_prefix = 'Fzf'

Then, instead of running :Files to search for a filename for example, you can run :FzfFiles.

You can also directly overwrite these commands with more customized one; we'll see that in another section
below.

Opening fzf Fullscreen

Using fzf in Vim to search through your mapping
A last detail which can be quite handy: if you want to open fzf fullscreen, you just need to add a bang ! to
any Ex command described above. For example:

:Files!

Now, fzf is taking the space it deserves.

Global Variables to Configure Fzf
Now that we saw the most useful user commands to use fzf in Vim, let's see how you can customize the
integration to suit your needs. The easiest way to do so is to use a couple of global variables, directly
available in the native fzf plugin.

The plugin fzf.vim add more global variables on top of the ones described below, but in general I find them
less useful. As a result, I won't describe them in this article. If you're curious, you can grab them in
fzf.vim's README file.

These variables will add different options to the fzf shell command running in the background. To see what
this fzf shell command looks like, you can run :echo fzf#wrap(). It's very handy if you need to debug any
unexpected behavior.

History of Fzf Queries
You can keep a history of all the queries you write when fuzzy-finding using fzf, thanks to the global
variable g:fzf_history_dir. For example:

let g:fzf_history_dir = '~/.config/local/share/fzf-vim-history'

Each time you hit ENTER after typing a fzf query (to fuzzy search and select what you want), the query itself
will be added to the history file, located in the filepath defined by g:fzf_history_dir. To go through the
history, you can use the two following keystrokes directly in fzf:
---------------------------------------------------------
Keystroke    Description
---------------------------------------------------------
CTRL-p       Display the previous entry from the history.
CTRL-n       Display the next entry from the history.
---------------------------------------------------------

Keystrokes for fzf: the Actions
We saw that some Ex commands provided by fzf allow us to use some handy keystrokes to do all sorts of things.
We can actually overwrite these keystrokes and add new ones if we want to, using the handy global variable
g:fzf_action. Its value is a dictionary with the keystrokes as keys and any Ex command they should run as
values.

For example, after running the Ex command :Files (available in fzf.vim), you can open your selected file in a
new horizontal split thanks to the keystroke CTRL-x. But what if you want to use CTRL-h instead?

Here's what you can add to your Vim's config to do so. Note that g:fzf_action overwrite all the default
keystrokes, so you'll need to define them again (like ctrl-t or ctrl-v for example):

let g:fzf_action = {
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-h': 'split',
  \ 'ctrl-v': 'vsplit' }

Here's another example I personally use. It shows that you can also use custom functions, not only Ex
commands, to create your actions. Here, the function allow me to select multiple files (after running :Files
for example) and then open them in a quickfix list with CTRL-x:

" Build a quickfix list when multiple files are selected
function! s:build_quickfix_list(lines)
	call setqflist(map(copy(a:lines), '{ "filename": v:val }'))
	copen
	cc
endfunction

let g:fzf_action = {
  \ 'ctrl-x': function('s:build_quickfix_list'),
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-h': 'split',
  \ 'ctrl-v': 'vsplit' }

Customizing fzf Layout
What if we want to customize the layout of fzf? We can use the global variable g:fzf_layout to do so. For
example:

let g:fzf_layout = { 'window': { 'width': 0.7, 'height': 0.6 } }

Here, fzf's window will take 70% of the width of the screen, and 60% of its height. If you want fzf's window
to be relative to the current window, you can set "relative" to true; for example:

let g:fzf_layout = { 'window': { 'width': 0.7, 'height': 0.6, 'relative': v:true } }

We also saw, in another article, that fzf can use tmux to open a floating window. You can also use it in Vim;
for example:
let g:fzf_layout = { 'tmux': '-p70%,60%' }

Configuring fzf Highlighting
Configuring the layout is not enough? You want to change the highlighting in fzf to match your wonderful Vim
color theme? You can use yet another global variable, g:fzf_colors, to do so:

let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Search'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Visual'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'border':  ['fg', 'StatusLineNC'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }

As you can see, this variable takes a dictionary as value:
  * The keys are the elements you want to highlight; they are the same elements you can give to the --color
    option using fzf in the shell. Here's a handy list of these elements.
  * The values are Vim highlight groups.

Let's take an example from above to understand how it works:

'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],

Vim will highlight the text of the current line (fg+) with the given highlight group (CursorLine). If this
highlight group doesn't exist, it will try to reach the second one (CursorColumn) and so on, until there are
no highlight groups left; in that case, it will use a default color.

The Basic Functions for fzf Integration
We saw, at the beginning of this article, that fzf.vim defines some user commands you can directly use (like
:Files or :Rg) to search and edit the files we want. We can also create new user commands, or even overwrite
the existing ones.

Using the Run and Wrap Functions
There are two low level functions you can use to define your own user commands: fzf#run and fzf#wrap.
Actually, fzf#wrap is not mandatory, but recommended. They are both defined in the native fzf plugin for Vim,
so you don't need fzf.vim to use them.

Both fzf#run and fzf#wrap accept a dictionary as argument. Here are the most useful keys you can use:
-----------------------------------------------------------------------------------------------------
Key     Description                                     Default
-----------------------------------------------------------------------------------------------------
sink    The Ex command executed after selecting some    :edit
        entries.

source  The shell command piped to fzf.                 FZF_DEFAULT_COMMAND (or fzf's defaults if not
                                                        initialized).

options The different options given to fzf.             FZF_DEFAULT_OPTS (or fzf's defaults if not
                                                        initialized).
-----------------------------------------------------------------------------------------------------

Here's one of the simplest example we can run:
:call fzf#run(fzf#wrap())

If you run the Ex command above, all the default values will be used:
 1. The value of the environment variable FZF_DEFAULT_COMMAND will be piped to fzf under the hood, to create
    the list of files given to fzf.
 2. The options defined in the environment variable FZF_DEFAULT_OPTS will be given to fzf.
 3. Every entry you've selected in fzf will be added as argument to the Ex command :edit.

If you don't want to use FZF_DEFAULT_COMMAND (or fzf's defaults) to create your entries, you can add a source
as follows:

:call fzf#run(fzf#wrap({'source': 'fd --hidden .'}))

You need the CLI fd installed on your system for the above command to work properly.
You can also add some options to fzf:

call fzf#run(fzf#wrap({
    \ 'source': 'fd --hidden .',
    \ 'sink': 'edit',
    \ 'options': ['--multi', '--pointer', '→', '--marker', '♡', '--preview', 'cat {}']
    \ }))

This is more or less equivalent to the following shell command:

fd --hidden | fzf --multi --pointer='→' --marker='♡' --preview='cat {}'

From there, it's not difficult to create your own user command using these functions, and then create a
keystroke you could use in NORMAL mode. For example:

command! MyFiles call fzf#run(fzf#wrap({
    \ 'source': 'fd --hidden .',
    \ 'sink': 'edit',
    \ 'options': ['--multi', '--pointer', '→', '--marker', '♡', '--preview', 'cat {}']
    \ }))

nnoremap <leader>a :MyFiles<cr>

You can also add two more arguments to the fzf#wrap function: a first one to specify the filename to use if
you want to keep a history of your queries (it won't have any effect if you don't define g:fzf_history_dir
beforehand), and a last one to specify if the fzf's window should be fullscreen. For example:

let g:fzf_history_dir = '~/.config/local/share/fzf-vim-history'
command! MyFiles call fzf#run(fzf#wrap('my_files_history', {
    \ 'source': 'fd --hidden .',
    \ 'sink': 'edit',
    \ 'options': ['--multi', '--pointer', '→', '--marker', '♡', '--preview', 'cat {}']
    \ }, 1))

In that case, your history file for your fzf queries will be ~/.config/local/share/fzf-vim-history/
my_files_history, and fzf's window will always be fullscreen.

What if we want to copy the behavior of the default Ex commands defined in fzf.vim, and only display fzf's
window fullscreen if there is a bang added to the command? We can add the -bang option to the Ex command
:command to do so:

command! -bang MyFiles call fzf#run(fzf#wrap({
    \ 'source': 'fd --hidden .',
    \ 'sink': 'edit',
    \ 'options': ['--multi', '--pointer', '→', '--marker', '♡', '--preview', 'cat {}']
    \ }, <bang>0))

Now, the Ex command :MyFile! will display fzf's window fullscreen.

As we already saw, these two functions fzf#run and fzf#wrap are defined in in the native fzf plugin. You
could only source this file, create the user commands which are most useful for you, and skip entirely the
plugin fzf.vim.

But it's the theory. In practice, it can be quite challenging to implement :Rg for example. We could think of
something like that:

command! -bang -nargs=* Rg call fzf#run(fzf#wrap({
    \ 'source': 'rg --column --line-number --no-heading --glob="!.git/*" '.shellescape(<q-args>),
    \ 'sink': 'edit',
    \ 'options': [
                \ '--multi',
                \ '--pointer', '→',
                \ '--marker', '♡',
                \ '--preview', 'cat {}',
                \ '--preview-window', '50%,border-double,right']
    \ },
    \ <bang>0))

Here's the result:
Using fzf in vim with the run and wrap functions

As you can see, it doesn't really work as expected. Here, fzf tries to add the current entry to the command
cat to display the preview, including the filename and the pattern matched by ripgrep. This glob of
information doesn't match any filepath on my filesystem, that's why the cat command fails, and the preview
breaks.

Even worse: if I try to edit a file, this glob of information would be given to :edit, and, as a result, it
wouldn't work either.

It's better to use the higher level functions offered by fzf.vim to define more complex user commands. These
functions use fzf#run and fzf#wrap under the hood.

Using the Functions from fzf.vim
If you look in the GitHub repository of fzf.vim, you'll find a file defining higher level functions we can
use as examples to define our own.

For example, you can see that the command :Rg call the function fzf#vim#grep as follows:

command! -bang -nargs=* Rg call fzf#vim#grep("rg --column --line-number --no-heading --color=always \
--smart-case -- ".fzf#shellescape(<q-args>), fzf#vim#with_preview(), <bang>0)

This looks a lot like the user command we tried to create in the previous section. But here you don't have to
parse the different entries to isolate the filenames from the pattern matched. The function fzf#vim#grep does
that for you.

For example, here's a user command I use every day, directly overwriting the :Rg Ex command from fzf.vim:

# Overwrite :Rg from fzf.vim
# Hit '?' to toggle the preview
command! -bang -nargs=* Rg call fzf#vim#grep(
  \   'rg
        \ --column
        \ --line-number
        \ --no-heading
        \ --fixed-strings
        \ --ignore-case
        \ --hidden
        \ --follow
        \ --glob "!.git/*"
        \ --color "always" '.shellescape(<q-args>),
  \   fzf#vim#with_preview('right:50%:hidden', '?'),
  \   <bang>0)

If your curious about the implementation of all these higher level functions, you can look at the file
vim.vim from the plugin itself.

Alternative plugins
Finally, let's finish this article with two more plugins specifically targeting Neovim users. I know that
many people only want Lua in their config; these plugins, in that case, will be of interest for you:
  * nvim-fzf
  * fzf-lua

The second plugin is built on top of the first one, a bit like fzf.vim is built on top of the native fzf
plugin.

The Fusion Between Vim and fzf
Vim is a really powerful tool by itself, offering many functionalities without the need of any plugin. But
it's also true that a tool like fzf can improve Vim significantly, offering a more comfortable way to go
through your files and lists.

Here's a summary of the main ideas of this article:
  * There are two plugins allowing us to use fzf in Vim: the native fzf plugin directly installed with fzf,
    and fzf.vim. The second plugin is built on the first one.
  * The plugin fzf.vim offers many user commands to search through your filenames, or directly parsing the
    content of your files.
  * You can also search through other lists using fzf: your search or Ex command history, or even your
    mapping for example.
  * Many global variables can be used to easily configure fzf. The most interesting ones are defined in the
    native fzf plugin.
  * You can write your own user functions only using the native fzf plugin for Vim, or, to make the
    implementation easier, by using higher level functions offered by fzf.vim.
  * There are a couple of alternative plugins if you use Neovim, allowing you to configure them in Lua.

If you know any more way to use fzf in Vim, don't hesitate to let a comment! It could help more people than
you think.


---
https://thevaluable.dev/fzf-git-integration/

4. A Practical Guide to fzf: Building a Git Explorer

Becoming a fzf master
 1. A Practical Guide to fzf: Building a File Explorer
 2. A Practical Guide to fzf: Shell Integration
 3. A Practical Guide to fzf: Vim Integration
 4. A Practical Guide to fzf: Building a Git Explorer

It's again a boring day in the offices of MegaCorpMoneyMaker, the company you're working with. As often
you're writing spaghetti code, not because you're a bad developer, but because your deadlines are incredibly
short, your motivation non-existent, and your colleagues care more about their promotions than their actual
work.

Looking out of the window while questioning your life choices, you suddenly see a globular and reflecting
flying saucer landing on the parking of the company. Flabbergasted, you begin to wonder if these aliens want
to buy the horrible products MegaCorpMoneyMaker is selling. Quite disappointed to see aliens with such a lack
of taste, you decide to see by yourself what these creatures want.

From the flying saucer comes creatures you have a hard time to describe, even to yourself. They're like cones
with cyclopean tentacles, covered by tiny holes opening and closing randomly, like hundreds of little mouths
trying to say something. Nobody is around, you're alone with these nightmares.

Suddenly, you hear a voice in your head:
"Git is such a nightmare to use. Write some interfaces we can customize easily, earthling! We don't like GUI,
it's not configurable enough, and we don't like to use a mouse. Our tentacles can't grab it easily."

Wondering what they'll do to you if you refuse, you quickly have the answer pumping in your head:

"Do you want to see the heart of a star, earthling? The bottom of a black hole? Do you want to travel in
different plans, full of creatures even uglier than you?"

You realize suddenly that these propositions don't sound too appealing. Working in MegaCorpMoneyMaker is not
that bad, at the end.

You come back to your office, grab your laptop, and begin to work. This day was written in the Memory of a
Charming Alien, a very famous book every alien in the universe read at least once, even these rednecks on
Titan. This article is a transcription of the work done in this day.

More precisely, we'll see:
  * How to create an interface with fzf to manage files with Git.
  * How to create an interface with fzf to manage Git commits.
  * How to create an interface with fzf to manage Git branches.

We'll build these interfaces step by step: we'll first define how to display the information we're interested
in, to then add keystrokes to perform some useful operations using the Holy Git.

There is no guarantee that these commands work in any situation, but they're explained enough for you to
improve and customize them depending on your needs and preferences.

The goal of this article is to show you how far we can go with fzf, some useful Git commands you might not be
aware of, as well as some general tips about shell scripting in general. I won't explain everything related
to Git here, but if you're interested to see a series of article covering this amazing tool, don't hesitate
to connect, or to let a comment at the end of this page.

If you're lost in the different fzf options we'll use in this article, they're all explained in the first
article of this series.

Are you ready to interface the sourcing power of Git with the listing energy of fzf?

The Article Companion
To get the most of this article, I'd recommend you to follow along and fidget with the different commands
we'll discuss here. We'll use a dummy repository to test out the different interfaces we'll create; you just
need to clone it with the following shell command:
$> git clone https://github.com/Phantas0s/tvd_companion_git_fzf

We'll call this project the [**2]article companion.

From there, simply open a terminal, go to the folder tvd_companion_git_fzf, and you're good to go. All the
commands we'll see in this article work in Bash (tested with GNU bash, version 5.2.26) and other similar
shells like Zsh. I used fzf 0.48.

Working with Files
The files are your project are the most important entities when it comes to version control. Let's build an
interface to perform the most common operations in a typical Git workflow.

Preparing the Terrain
To stage and unstage files using Git, we need first to create, modify, and delete some of them in our article
companion. Let's run the following shell commands:
$> touch 1.md 2.md
$> rm DUMMY.md
$> echo 'New line!' >> README.md

If you run git status --short you should get the following output:
 D DUMMY.md
 M README.md
?? 1.md
?? 2.md

If you're not familiar with this output, let me explain quickly:
  * Each file are prefixed with two columns, indicating the status of the file.
  * The prefix ?? indicates that the file is untracked by Git. It has never been committed yet.
  * The prefix D indicates that the file has been deleted. Because the D is in the second column of the
    prefix, we know that this deleted file is unstaged.
  * The prefix M indicated that the file was modified. It's also in the second column of the prefix, so we
    know that it's unstaged.

If we run the command git add DUMMY.md, the deletion becomes staged; the status D is now in the first column
of the prefix:
D  DUMMY.md
 M README.md
?? 1.md
?? 2.md

Let's unstage the deletion: run git reset DUMMY.md.

Git manual
$> man git-status # Search for "Changed Tracked Entries"

Listing Staged and Unstaged Files
One of the most common thing we can do with Git is staging and unstaging files, thanks to the shell command
git add and git reset respectively.

We could imagine using fzf to get the list of unstaged files, select the files we want to stage, and run git
add on the selection.

Listing the Unstaged Files
First, we need to list the unstaged files. We could use git ls-files to get the files modified, deleted, and
untracked ("other"). We should also skip the files listed in .gitignore:
$> git ls-files --modified --deleted --other --exclude-standard

Here's what you should get:
1.md
2.md
DUMMY.md
DUMMY.md
README.md

Deleted and unstaged files are considered both modified and deleted, that's why DUMMY.md appears two times
here. We need to add the option --deduplicate to fix this problem:
$> git ls-files --modified --deleted --other --exclude-standard --deduplicate

The magical output:
1.md
2.md
DUMMY.md
README.md

But this command is not perfect for our use case. To illustrate the problem, run cd subdir to change our
current directory to a subdirectory of the [**2]article companion. If we run again the above Git command, there
won't be any output.

It's because git ls-files look at the current directory by default, not the root directory of a project. We
could give this root directory as argument to fix this problem. Good news everyone: the following command
output what we need:
$> git rev-parse --show-toplevel

If we run the following, we'll always have the unstaged files we need, even if we're in a subdirectory of a
project:
$> git ls-files \
    --modified \
    --deleted \
    --other \
    --exclude-standard \
    --deduplicate \
    $(git rev-parse --show-toplevel)

The output:
../1.md
../2.md
../DUMMY.md
../DUMMY.md
../README.md

Listing the Staged Files
If we want a fzf interface to also unstage files, we need a list of all staged ones. First, let's stage a
file in our [**2]article companion:
$> git add ../1.md

The following command can display the list of staged files:
$> git diff --name-only --staged

The output:
1.md

But, again, we have a problem: we're still in the subdirectory subdir, so the path 1.md is not correct.
Running git add 1.md won't work; instead, we need the list of the relative filepaths of our staged files, to
be able to do something like git add ../1.md for example.

An alternative would be to use git status to list all the staged files and get the good filepaths, but it
gets a bit more complicated:
$> git status --short | grep '^[A-Z]' | awk '{print $NF}'

We basically list here all the staged and unstaged files, and only grep the ones which have a letter in the
first column of their prefixes (and therefore which are staged). We also use the CLI tool awk to get the name
of the files without the prefixes. As you can see, we get what we want:
../1.md

An interface to Stage and Unstage Files
Let's combine the commands we've seen above with fzf. First, let's create an interface to stage files:
$> git add $(git ls-files \
    --modified \
    --deleted \
    --other \
    --exclude-standard \
    --deduplicate \
    $(git rev-parse --show-toplevel) \
  | fzf --multi --reverse --no-sort)

Here's another command to unstage files:
$> git reset -- $(git status --short \
  | grep '^[A-Z]' \
  | awk '{print $NF}' \
  | fzf --multi --reverse --no-sort)

We add -- here to specify to Git that we want to reset files, not commits.

If we don't want to quit fzf when adding one or multiple files, we could also bind the ENTER key to add the
files. Let's also add a preview showing the status of all the project's files, a nice prompt, and some help:
staged_files='git ls-files \
  --modified \
  --deleted \
  --other \
  --exclude-standard \
  --deduplicate \
  $(git rev-parse --show-toplevel)' \
&& eval "$staged_files" | fzf \
  --multi \
  --reverse \
  --no-sort \
  --prompt='Add > ' \
  --header-first \
  --header='ENTER to stage the files' \
  --preview='git status --short' \
  --bind='enter:execute(git add {+})' \
  --bind="enter:+reload($staged_files)"

If you don't understand what all these options stand for, the first article of this series can help you.

The result:
fzf interface to stage files using Git

From there, it's easy to come up with a similar command to unstage files:
unstaged_files='git status --short \
  | grep "^[A-Z]" \
  | awk "{print \$NF}"' \
&& eval "$unstaged_files" | fzf \
  --multi \
  --reverse \
  --no-sort \
  --prompt='Reset > ' \
  --header-first \
  --header='ENTER to unstage the file' \
  --preview='git status --short' \
  --bind='enter:execute(git reset -- {+})' \
  --bind="enter:+reload($unstaged_files)"

We have to escape the $ of $NF using a backslash (\$NF) because we're using weak double quotes here, and we
don't want the shell to expand $NF; awk should do that instead. When we begin to add layers of quoting in
Bash, we run quickly into nasty problems. This trope will follow us until the end of this article, and
possibly the end of time.

All of that is great, but we have now two different interfaces to stage and unstage our files. What about
having only one interface to rule them all? We could switch between the "Add mode" and the "Reset mode" with
a couple of keystrokes.

What should happen when we hit ENTER? If the files can be found in the list of unstaged files, we stage them;
otherwise, we unstage them. Something like the following:
$> git ls-files --modified --deleted --other --exclude-standard --deduplicate | grep {} \
&& git add {+} \
|| git reset -- {+}

Here's a possible implementation:
staged_files='git ls-files \
  --modified \
  --deleted \
  --other \
  --exclude-standard \
  --deduplicate \
  $(git rev-parse --show-toplevel)' \
&& unstaged_files='git status  --short \
  | grep "^[A-Z]" \
  | awk "{print \$NF}"' \
&& eval "$staged_files" | fzf \
  --multi \
  --reverse \
  --no-sort \
  --prompt='Add > ' \
  --header-first \
  --header '
  > CTRL-R to Reset | CTRL-A to Add
  > ENTER to Reset or Add files
  > ENTER in Reset mode switch back to Add mode
  ' \
  --preview='git status --short' \
  --bind='ctrl-a:change-prompt(Add > )' \
  --bind="ctrl-a:+reload($staged_files)" \
  --bind='ctrl-r:change-prompt(Reset > )' \
  --bind="ctrl-r:+reload($unstaged_files)" \
  --bind="enter:execute($staged_files | grep {} \
    && git add {+} \
    || git reset -- {+})" \
  --bind='enter:+change-prompt(Add > )' \
  --bind="enter:+reload($staged_files)" \
  --bind='enter:+refresh-preview'

As explained in the header, we can switch to "Add mode" by hitting CTRL-a, and to "Reset mode" by hitting
CTRL-r.

Each time we reset one (or multiple) files, we come back to "Add mode". It's because it's difficult to know
in what mode we're in, and, as a result, it's difficult to know what shell command we should use to reload
the list of entries in fzf when we stage or unstage files. Always being in "Add mode" allows us to avoid this
problem; we just have to reload the list of unstaged files. But it's not ideal.

It's also a bit annoying to have two different keystrokes for our two modes. What about having one keystroke
to switch between them? It's where the transform action can help us:
staged_files='git ls-files \
  --modified \
  --deleted \
  --other \
  --exclude-standard \
  --deduplicate \
  $(git rev-parse --show-toplevel)' \
&& unstaged_files='git status --short \
  | grep "^[A-Z]" \
  | awk "{print \$NF}"' \
&& eval "$staged_files" | fzf \
  --multi \
  --reverse \
  --no-sort \
  --prompt='Add > ' \
  --header-first \
  --header '
  > CTRL-S to switch between Add and Reset mode
  > ENTER to Reset or Add files
  ' \
  --preview='git status --short' \
  --bind="ctrl-s:transform:[[ \$FZF_PROMPT =~ 'Add >' ]] \
    && echo 'change-prompt(Reset > )+reload($unstaged_files)' \
    || echo 'change-prompt(Add > )+reload($staged_files)'" \
  --bind="enter:execute(
    $staged_files | grep {} \
    && git add {+} \
    || git reset -- {+}
    )" \
  --bind="enter:+reload(
    [[ \$FZF_PROMPT =~ 'Add >' ]] \
    && $staged_files \
    || $unstaged_files
    )" \
  --bind='enter:+refresh-preview'

The sumptuous result:
The internal variable $FZF_PROMPT store the string used as prompt in fzf (Add > or Reset > here). We can look
at its value to know in what mode we're in; as a result, we can refresh the good list of files (staged or
unstaged) each time we hit CTRL-s or ENTER.

Multiple Preview
It's great to display the status of our files in fzf's preview, but it would also be useful to show the diff
of these files, to know what was modified at a glance.

To display the diff of the file ../README.md for example, we can run the following command:
$> git diff --color ../README.md

The output:
------------------------------------
modified: README.md
------------------------------------
@ README.md:1 @
This is the [**1]companion repository for the article [A Practical Guide to fzf:
Building a Git Explorer](https://thevaluable.dev/fzf-git-integration).
New line!

The first four lines of the diff are quite useless for our use case, so let's use the CLI tool sed to get rid
of them:

git diff --color=always archives/outlines/fzf-git-integration.md \
| sed '1,4d'

If you want to know more about sed, I've written an
[https://thevaluable.dev/sed-cli-practical-guide-examples/]article about it.

You might not want to display the diff at all, but only some stats. You could do the following in that case:
$> git diff --color --stat ../README.md

As always, it depends on what you prefer. For example, we could also add --diff-algorithm=histogram to avoid
repeating some changes in common elements. Also, the options --ignore-all-space and --ignore-blank-lines can
be useful if you don't want to bother with diff of spaces and blank lines.

Here are the options we can add to our interfaces to change the preview:
  --bind='ctrl-f:change-preview-label([ Diff ])' \
  --bind='ctrl-f:+change-preview(git diff --color=always {} | sed "1,4d")' \
  --bind='ctrl-s:change-preview-label([ Status ])' \
  --bind='ctrl-s:+change-preview(git status --short)' \

Unfortunately, it seems that there is no way to use only one keystroke to switch between the two previews.
There is no environment variable like $FZF_PROMPT which contains the label of the preview, to switch to the
other one. But fear not! I've open a pull request to add a new environment variable $FZF_PREVIEW_LABEL; if
it's ever merged, something like the following would then be possible:
  --bind="ctrl-p:transform:[[ \$FZF_PREVIEW_LABEL =~ '[ Status ]' ]] \
    && echo 'change-preview(git diff --color=always {} | sed \"1,4d\")+change-preview-label([ Diff ])' \
    || echo 'change-preview(git status --short)+change-preview-label([ Status ])'" \

We can also add another keystroke to display a preview of git blame:
 --bind='ctrl-b:change-preview-label([ Blame ])' \
 --bind='ctrl-b:+change-preview(git blame --color-by-age {})' \

Now that our preview can be quite long, it would be nice to have some keystrokes to scroll it. We can add the
following ones for example, mimicking some good old Vim keystrokes:
--bind='ctrl-y:preview-up' \
--bind='ctrl-e:preview-down' \
--bind='ctrl-u:preview-half-page-up' \
--bind='ctrl-d:preview-half-page-down' \

Adding Patches
If you have multiple changes in a single file, and you want to commit some of these changes but not all of
them, you can choose and add hunks of patch thanks to git add --patch. Let's add this functionality to our
splendid interface:

--bind='alt-p:execute(git add --patch {+})' \
--bind='alt-p:+reload($unstaged_files)' \

Editing the Files
What about editing the files selected in your favorite editor (which is obviously Vim) directly from fzf? We
can add the following keystrokes to do so:
--bind 'alt-e:execute(${EDITOR:-vim} {+})' \

We use the environment variable $EDITOR to find your favorite editor and edit the files selected. If the
variable is empty we default to Vim.

Checkout the Files
If you want to undo all the changes you've made since the last commit in some files, you simply need to
checkout them. We could add this functionality to our interface: first, we reset the file in case it was
staged, and then we undo all the modifications we did in the last commit. Something like the following:

--bind='alt-d:execute(git reset -- {+})' \
--bind='alt-d:+execute(git checkout {+})' \

To commit or not to Commit
Lastly, it would be nice to create commits directly from our interface. Let's not wait any longer:
--bind 'alt-c:execute(git commit)+abort' \

We could also add the staged files to the last commit as follows:
--bind 'alt-a:execute(git commit --amend)+abort' \

As you can see, when the commit is created, we ask fzf to abort. Again, it's up to you: you might not want to
close fzf when you've committed your staged files.

A Script to rule them all
At that point, our command is quite a monster. It's time to create a Bash script, to make our interface
readily available, and also to refactor it a bit.

You can [https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/guide-fzf-git/fzf_git_files.sh]find
the final result here. Let's look a bit more closely at this implementation; first, we don't allow all the
keystrokes for each mode:
local -r mode_reset="change-prompt($prompt_reset)+reload($git_staged_files)+change-header($reset_header)\
+unbind(alt-p)+rebind(alt-d)"

local -r mode_add="change-prompt($prompt_add)+reload($git_unstaged_files)+change-header($add_header)+\
rebind(alt-p)+unbind(alt-d)"

As you can see, we unbind ATL-p when we are in "Reset mode", and we unbind ALT-d when we are in the "Add
mode". It's because we don't want to enable git add --patch in "Reset mode", and we don't want to enable git
checkout in Add mode.

Since we're directly in "Add mode" when we start fzf, we also need to unbind ALT-d at startup:
--bind='start:unbind(alt-d)' \

We also use some heredoc to make long strings and commands more manageable. For example:
        local -r header=$(cat <<-EOF
                > CTRL-S to switch between Add Mode and Reset mode
                > CTRL_T for status preview | CTRL-F for diff preview | CTRL-B for blame preview
                > ALT-E to open files in your editor
                > ALT-C to commit | ALT-A to append to the last commit
                EOF
        )

We use here TAB characters for our indentation coupled with <<-, which will ignore any leading TAB character.
It means that the string itself won't have any indentation.

If you don't use TAB characters as indentation in your file, and you don't want any indentation in the string
itself, you can do the following:

    local -r header=$(cat <<EOF
> CTRL-S to switch between Add Mode and Reset mode
> CTRL_T for status preview | CTRL-F for diff preview | CTRL-B for blame preview
> ALT-E to open files in your editor
> ALT-C to commit | ALT-A to append to the last commit
EOF
)

If you're a blessed Vim user and if you want to replace all your indentations with tabs in your file, you can
simply run the following:
:set noexpandtab shiftwidth=2 tabstop=2 | retab!

That's it! We have now a functional interface to manage our files with Git. It's time now to go a level
higher in our adventure: let's create a new interface to manage Git commits.

Working with Commits
Managing commits is also an important part in a typical Git workflow. Let's see how we can use fzf to make
the changes we want as easily as possible.

Listing Git Commits
If we want to manage our commits using fzf, we first need to list them. One commit per line would be ideal;
each line should contain the commit hash, to be able to give it as argument to other Git commands.

The following list all the commit hashes of the current branch:
$> git log --format="%h"

The output:
27f62ab
73ce782
2716af8
a0df21f
008faec
c13db2b
21868b1
7c2636f

From there, we can add more information on each line to make these commits more understandable. For example,
we can add:
  * The short form of the committer date (%cs).
  * The subject of the commit (%s).
  * The name of the reference; for example head, tags, or remote branch (%d).

Here's the command we need:
$> git log --format='%h - %cs - %s%d'

The output:
27f62ab - 2024-03-22 - Revert the changes from a0df21f in DUMMY (HEAD -> new-branch, origin/main, origin/HEAD, main)
73ce782 - 2024-03-22 - Merge branch 'another_branch'
2716af8 - 2024-03-22 - Add more explanation to DUMMY
a0df21f - 2024-03-22 - Add more text to DUMMY (origin/another_branch, another_branch)
008faec - 2024-03-22 - Add more text to another_file
c13db2b - 2024-03-22 - Add another file
21868b1 - 2024-03-22 - Add README, subdir and a file, and DUMMY
7c2636f - 2024-03-20 - First commit

Let's improve our display even further, by adding pretty colors, and a graph:
$> git log --graph --color --format='%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d'

The output:
* 27f62ab - 2024-03-22 - Revert the changes from a0df21f in DUMMY (HEAD)
*   73ce782 - 2024-03-22 - Merge branch 'another_branch'
|\
| * a0df21f - 2024-03-22 - Add more text to DUMMY (origin/another_branch)
| * 008faec - 2024-03-22 - Add more text to another_file
| * c13db2b - 2024-03-22 - Add another file
* | 2716af8 - 2024-03-22 - Add more explanation to DUMMY
|/
* 21868b1 - 2024-03-22 - Add README, subdir and a file, and DUMMY
* 7c2636f - 2024-03-20 - First commit

It's time to bring fzf in the party:
$> git log --graph --color \
  --format='%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d' \
| fzf \
  --ansi \
  --reverse \
  --no-sort

What about displaying the changes of the selected commit in fzf's preview? We can use git show to do so. For
example:
$> git show --color 7c2636f

It means that we need to isolate the commit hash from each line of our graph, and give it to git show. Let's
consider the following line as an example:
| * 008faec - 2024-03-22 - Add more text to another_file

We could get the hash using grep here:
$> echo '| * 008faec - 2024-03-22 - Add more text to another_file' \
| grep -o "[a-f0-9]\{7\}"

We get our expected output, the commit hash:
008faec

If you want to know more about grep, I've written an [https://thevaluable.dev/grep-cli-guide-examples/]article
about it. Also, if you're not comfortable with the basics of regular expression, you can look at this
[https://thevaluable.dev/regular-expression-basics-vim-grep/]other article.

Let's improve our interface with this new preview:
$> git log --graph --color \
  --format='%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d' \
| fzf \
  --ansi \
  --reverse \
  --no-sort \
  --preview='
    echo {} | grep -o "[a-f0-9]\{7\}" \
    && git show --color $(echo {} | grep -o "[a-f0-9]\{7\}")
  '

The splendid result:
fzf interface to manage Git commits

We repeat echo {} | grep -o "[a-f0-9]\{7\}" two times here. The first one make sure that there is indeed a
hash on the line (it's possible to have lines without commit hashes because of the --graph option). If a hash
is found on the selected line, we run git show with the hash as argument.

If there is also a hash in the subject of the commit, we end up with multiple hashes on the same line (as you
can see above). Let's make sure that we only give to git show the first hash of the line:
$> git log --graph --color \
  --format='%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d' \
| fzf \
  --ansi \
  --reverse \
  --no-sort \
  --preview='
    echo {} | grep -o "[a-f0-9]\{7\}" \
    && git show --color $(echo {} \
    | grep -o "[a-f0-9]\{7\}" \
    | sed -n "1p")
  '

The preview command can be simpler (without using sed or even grep) if you get rid of the --graph option. As
a result, you're now sure that the commit is always the first field of each line:
$> git log --color \
  --format='%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d' \
| fzf \
  --ansi \
  --reverse \
  --no-sort \
  --preview='git show --color {1}'

Scrolling and looking at fzf's preview is not always the most practical. We could also try to open a new
subshell and display the commit's changes using less when hitting ENTER:
$> git log --graph --color \
  --format='%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d' \
| fzf \
  --ansi \
  --reverse \
  --no-sort \
  --preview='
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && git show --color $hash
    ' \
  --bind='enter:execute(
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && sh -c "git show --color $hash | less -R"
    )' \
  --header-first \
  --header '
    > ENTER to display the diff
  '

Now that we can get the hash of each of our commits, let's add more functionalities to our interface.

Checkout and Reset Commits
It's sometimes useful to checkout a commit to look at the state of a project at a specific point in time.
Let's add a binding to do so:
$> git log --graph --color \
  --format='%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d' \
| fzf \
  --ansi \
  --reverse \
  --no-sort \
  --preview='
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && git show --color $hash
    ' \
  --bind='enter:execute(
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && sh -c "git show --color $hash | less -R"
    )' \
  --bind='alt-c:execute(
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && git checkout $hash
    )+abort' \
  --header-first \
  --header '
  > ENTER to display the diff
  > ALT-C to checkout the commit
  '

Also, when I develop a new functionality, I often create a bunch of random commits. When I'm done, I reset to
the first commit I've made for this functionality, and I re-create a bunch of new commits which are more
logical, describing each important step, and it's ideally possible to revert them without crashing the whole
application.

It's quite trivial to add this functionality to our interface:
$> git log --graph --color \
  --format='%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d' \
| fzf \
  --ansi \
  --reverse \
  --no-sort \
  --preview='
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && git show --color $hash
    ' \
  --bind='enter:execute(
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && sh -c "git show --color $hash | less -R"
    )' \
  --bind='alt-c:execute(
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && git checkout $hash
    )+abort' \
  --bind='alt-r:execute(
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && git reset $hash
    )+abort' \
  --header-first \
  --header '
  ENTER to display the diff
  ALT-C to checkout the commit | ALT-R to reset to the commit
  '

Interactive Rebasing
Interactive rebasing can be useful if you want to modify a bunch of commits. Let's add the functionality in
our interface:
$> git log --graph --color --format='%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d' | fzf \
  --ansi \
  --reverse \
  --no-sort \
  --preview='
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && git show --color $hash
    ' \
  --bind='enter:execute(
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && sh -c "git show --color $hash | less -R"
    )' \
  --bind='alt-c:execute(
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && git checkout $hash
    )+abort' \
  --bind='alt-r:execute(
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && git reset $hash
    )+abort' \
  --bind='alt-i:execute(
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && git rebase --interactive $hash
    )+abort' \
  --header-first \
  --header '
  > ENTER to display the diff
  > ALT-C to checkout the commit | ALT-R to reset to the commit
  > ALT-I to rebase interactively
  '

Nothing new here; as you can see, it's trivial to implement new bindings using the commit hash of the current
line.

Cherry-Pick a Commit
It can be useful to cherry-pick a commit and add it on top of the current branch. We could add the following
to our previous command:
  --bind='alt-p:execute(
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && git cherry-pick $hash
    )+abort' \

But it's not idea: our interface only list commits of the current branch, and it's often useful to
cherry-pick a commit from another branch. Again, we could imagine switching between two lists in fzf:
 1. The list of the commits of the current branch.
 2. The list of all commits reachable from a reference (for example a branch or a tag).

To do so, we'll have to use the fzf action transform again. Here's a possible solution:
branch_commits='git log --graph --color --format="%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d"' \
&& all_commits='git log --all --graph --color --format="%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d"' \
&& eval "$branch_commits" | fzf \
  --ansi \
  --reverse \
  --no-sort \
  --prompt="Branch > " \
  --preview='
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && git show --color $hash
    ' \
  --bind="ctrl-s:transform:[[ \$FZF_PROMPT =~ 'Branch >' ]] \
    && echo 'change-prompt(All > )+reload($all_commits)' \
    || echo 'change-prompt(Branch > )+reload($branch_commits)'" \
  --bind='enter:execute(
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && sh -c "git show --color $hash | less -R"
    )' \
  --bind='alt-c:execute(
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    &&  git checkout $hash
    )+abort' \
  --bind='alt-r:execute(
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && git reset $hash
    )+abort' \
  --bind='alt-i:execute(
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && git rebase --interactive $hash
    )+abort' \
  --bind='alt-p:execute(
    hash=$(echo {} | grep -o "[a-f0-9]\{7\}" | sed -n "1p") \
    && [[ $hash != "" ]] \
    && git cherry-pick $hash
    )+abort' \
  --header-first \
  --header '
  > ENTER to display the diff
  > ALT-C to checkout the commit | ALT-R to reset to the commit
  > ALT-I to rebase interactively
  > ALT-P to cherry pick
  '

We've created a monster again; it's time to create a Bash script and refactor this mess. You'll find the
complete function here.

We have now two different interfaces to manage our files and our commits. Again, it's time to move a level
higher: let's create a last interface to manage our Git branches.

Working with Branches
First, let's list all the branches we have for our current project. We can do so with this simple command:
$> git branch --color

The output:
  another_branch
* main
  new-branch
  yet_another_branch

If we want to also include the remote branches in the list, we can add the option --all:
$> git branch --all --color

What about checkout the selected branch directly from fzf? We can do that easily with the following:
$> git checkout \
  $(git branch --color | fzf --ansi --reverse --no-sort | tr -d ' ')

Since the output of git branch includes many SPACE characters, we use here the CLI tool tr to delete them.

We can also shorten the reference or our remote branch by using the --format option:
$> git branch --all --color --format="%(refname:short)"

The output:
another_branch
main
new-branch
yet_another_branch
origin
origin/another_branch
origin/main
origin/yet_another_branch

We can also add some color:
$> git branch --all --color --format="%(color:green) %(refname:short)"

It would also be nice to have a star * in front of the current branch, to know where we are in life:
$> git branch --all --color --format="%(HEAD) %(color:green)%(refname:short)"

If we want to checkout the selected branch, we also need to get rid of the star *:
$> git checkout $(git branch --all --color \
  --format="%(HEAD) %(color:green)%(refname:short)" \
| fzf --ansi --reverse --no-sort \
| sed 's/^[* ]*//')

Granted, trying to checkout the current branch is a bit useless, but, at least, with this solution, Git will
output the correct error message if we try to do so.

Let's not stop here: let's add the short committer date, and the subject of the last commit of each branch
since we're at it:
$> git checkout $(git branch --all --color \
  --format="%(HEAD) %(color:yellow)%(refname:short) %(color:green)%(committerdate:short) %(color:blue)%(subject)" \
| fzf --ansi --reverse --no-sort \
| sed 's/^[* ]*//' \
| awk '{print $1}')

We also have more information per line now, so we need to use the CLI tool awk again to select the name of
the branch we want to checkout.

We're using the short version of the committer date (for example 2024-01-01), but you can also use the
relative committer date (for example 2 weeks ago) with committerdate:relative.

As you can see, the formatting is a bit all over the place. We could try to format our output in a table,
using the CLI tool column:
$> git checkout $(git branch --all --color \
  --format=$'%(HEAD) %(color:yellow)%(refname:short)\t%(color:green)%(committerdate:short)\t%(color:blue)%(subject)' \
| column --table --separator $'\t' \
| fzf --ansi --reverse --no-sort \
| sed 's/^[* ]*//' \
| awk '{print $1}')

We use the quoting $' here to interpret the escape sequence \t as a TAB character. We could have used any
other character as delimiter for our columns, but if this delimiter is also in the subject of the last commit
of a branch, the formatting breaks. Feel free to use any other delimiter if you have some TAB characters in
one of these subjects.

Let's now display the logs of the selected branch as preview:
$> git checkout $(git branch --all --color \
  --format=$'%(HEAD) %(color:yellow)%(refname:short)\t%(color:green)%(committerdate:short)\t%(color:blue)%(subject)' \
| column --table --separator $'\t' | \
  fzf \
  --ansi \
  --reverse \
  --no-sort \
  --preview 'git log $(echo {} \
    | sed "s/^[* ]*//" \
    | awk "{print \$1}") \
    --graph --color \
    --format="%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d"' \
| sed 's/^[* ]*//' \
| awk '{print $1}')

We could also display the diff between the current branch and the branch selected in fzf as preview. Let's
also bind the ENTER key to git checkout, to avoid closing fzf when we checkout a different branch:
$> git_branches="git branch --all --color \
  --format=$'%(HEAD) %(color:yellow)%(refname:short)\t%(color:green)%(committerdate:short)\t%(color:blue)%(subject)' \
  | column --table --separator=$'\t'" \
&& eval "$git_branches" \
| fzf \
  --ansi \
  --reverse \
  --no-sort \
  --preview-label '[ Commits ]' \
  --preview 'git log $(echo {} \
    | sed "s/^[* ]*//" | \
    awk "{print \$1}") \
    --graph --color  \
    --format="%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d"' \
  --bind 'ctrl-f:change-preview-label([ Diff ])' \
  --bind 'ctrl-f:+change-preview(
    git diff --color \
    $(git branch --show-current)..$(echo {} \
      | sed "s/^[* ]*//" \
      | awk "{print \$1}")
    )' \
  --bind 'ctrl-i:change-preview-label([ Commits ])' \
  --bind 'ctrl-i:+change-preview(
    git log $(echo {} \
    | sed "s/^[* ]*//" \
    | awk "{print \$1}") \
    --graph --color \
    --format="%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d")' \
  --bind 'enter:execute(
    git checkout $(echo {} \
    | sed "s/^[* ]*//" \
    | awk "{print \$1}")
    )' \
  --bind "enter:+reload($git_branches)" \
  --header-first \
  --header '
  > CTRL-F to preview with diff | CTRL-I to preview with logs
  > ENTER to checkout the branch
  '

The fantastic result:
fzf interface to manage Git branches

We could also display the diff in a subshell when hitting ENTER, and checkout any branch with ALT-c:
$> git_branches="git branch --all --color \
  --format=$'%(HEAD) %(color:yellow)%(refname:short)\t%(color:green)%(committerdate:short)\t%(color:blue)%(subject)' \
  | column --table --separator=$'\t'" \
&& eval "$git_branches" \
| fzf \
  --ansi \
  --reverse \
  --no-sort \
  --preview-label='[ Commits ]' \
  --preview='
    git log $(echo {} \
    | sed "s/^[* ]*//" \
    | awk "{print \$1}") \
    --graph --color \
    --format="%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d"' \
  --bind='alt-c:execute(
    git checkout $(echo {} \
    | sed "s/^[* ]*//" \
    | awk "{print \$1}")
    )' \
  --bind "alt-c:+reload($git_branches)" \
  --bind='enter:execute(
    branch=$(echo {} \
    | sed "s/^[* ]*//" \
    | awk "{print \$1}") \
    && sh -c "git diff --color $branch \
    | less -R"
    )' \
  --header-first \
  --header '
  > ALT C to checkout the branch
  > ENTER to open the diff with less
  '

Let's not stop here: what about merging and rebasing the branch selected with the current one?
$> git_branches="git branch --all --color \
  --format=$'%(HEAD) %(color:yellow)%(refname:short)\t%(color:green)%(committerdate:short)\t%(color:blue)%(subject)' \
  | column --table --separator=$'\t'" \
&& eval "$git_branches" \
| fzf \
  --ansi \
  --reverse \
  --no-sort \
  --preview-label='[ Commits ]' \
  --preview='git log $(echo {} \
    | sed "s/^[* ]*//" \
    | awk "{print \$1}") \
    --graph --color \
    --format="%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d"' \
  --bind='alt-c:execute(
    git checkout $(echo {} \
    | sed "s/^[* ]*//" \
    | awk "{print \$1}")
    )' \
  --bind="alt-c:+reload($git_branches)" \
  --bind='alt-m:execute(git merge $(echo {} \
    | sed "s/^[* ]*//" \
    | awk "{print \$1}")
    )+abort' \
  --bind='alt-r:execute(git rebase $(echo {} \
    | sed "s/^[* ]*//" \
    | awk "{print \$1}")
    )+abort' \
  --bind='enter:execute(
    branch=$(echo {} \
    | sed "s/^[* ]*//" \
    | awk "{print \$1}") \
    && sh -c "git diff --color $branch | less -R"
    )' \
  --header-first \
  --header '
  > The branch marked with a star * is the current branch
  > ALT-C to checkout the branch
  > ALT-M to merge with current branch | ALT-R to rebase with current branch
  > ENTER to open the diff with less
  '

You have now a good foundation to add anything you want. You could add a binding to run git fetch to get all
the remote branches for example, or add another binding running git branch --delete --force to delete a
remote branch. The sky's the limit.

As always, there is a final Bash script waiting for you.

Vim Integration
What about having these nice interfaces directly in Vim? I already cover fzf integration with Vim in this
article.

For example, we could create a new scrim fzf.vim and source it in our vimrc. Here's a simple fzf interface to
stage files:
let s:git_unstaged='git ls-files --modified --deleted --other --exclude-standard
    \ --deduplicate $(git rev-parse --show-toplevel)' command! -bang GitAdd call fzf#run(fzf#wrap({
    \ 'source': s:git_unstaged,
    \ 'options': [
        \ '--multi',
        \ '--reverse',
        \ '--no-sort',
        \ '--prompt', 'Add > ',
        \ '--preview', 'git status --short',
        \ '--bind', 'enter:execute(git add {+})',
        \ '--bind', 'enter:+reload('.s:git_unstaged.')',
    \ ]}))

The prefix s: in Vimscript simply means that the scope of the variable is the current script only, to avoid
conflicts with other variables having the same name.

An Interface to Merge Them All
As we saw in this article, using the advanced functionalities of fzf is not hard if we build our interfaces
step by step. We can then craft powerful and customized tools directly in our comfy shell, without the need
to program a full-blown TUI.

If you have other ideas to improve the functions we've written in this article, or if you want to share your
own interfaces written with fzf, don't hesitate to leave a comment. You know, sharing is caring!

Related Sources
  * [https://github.com/junegunn/fzf/wiki/examples#git]Example of Git interfaces using fzf
  * [https://github.com/junegunn/fzf-git.sh/tree/main]fzf-git.sh
  * [https://github.com/junegunn/fzf/blob/master/ADVANCED.md]Advanced fzf


---

