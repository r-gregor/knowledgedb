filename: fzf-config-shell-integration-multif-20251127.txt
https://github.com/junegunn/fzf

junegunn/fzf
fzf - a command-line fuzzy finder

fzf is a general-purpose command-line fuzzy finder.
[fzf-preview.png]

   It's an interactive filter program for any kind of list; files, command history, processes,
   hostnames, bookmarks, git commits, etc. It implements a "fuzzy" matching algorithm, so you can
   quickly type in patterns with omitted characters and still get the results you want.

Highlights
     * Portable - Distributed as a single binary for easy installation
     * Fast - Optimized to process millions of items instantly
     * Versatile - Fully customizable through an event-action binding mechanism
     * All-inclusive - Comes with integrations for Bash, Zsh, Fish, Vim, and Neovim

Installation

Using Homebrew
$> brew install fzf

   Important
   To set up shell integration (key bindings and fuzzy completion), see the instructions below.



Windows packages
   On Windows, fzf is available via Chocolatey, Scoop, Winget, and MSYS2:

   -------------------------------------------------------
   Package manager     Command
   -------------------------------------------------------
   Chocolatey          choco install fzf
   Scoop               scoop install fzf
   Winget              winget install fzf
   MSYS2 (pacman)      pacman -S $MINGW_PACKAGE_PREFIX-fzf
   -------------------------------------------------------

Using git
   Alternatively, you can "git clone" this repository to any directory and run install script.
$> git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf
$> ~/.fzf/install

   The install script will add lines to your shell configuration file to modify $PATH and set up shell
   integration.

Binary releases
   You can download the official fzf binaries from the releases page.
     * https://github.com/junegunn/fzf/releases

!!! Setting up shell integration !!!

   Add the following line to your shell configuration file.
     * bash
# Set up fzf key bindings and fuzzy completion
$> eval "$(fzf --bash)"

     * zsh
# Set up fzf key bindings and fuzzy completion
$> source <(fzf --zsh)

     * fish
# Set up fzf key bindings
$> fzf --fish | source

   Note
   --bash, --zsh, and --fish options are only available in fzf 0.48.0 or later. If you have an older
   version of fzf, or want finer control, you can source individual script files in the /shell
   directory. The location of the files may vary depending on the package manager you use. Please refer
   to the package documentation for more information. (e.g. apt show fzf)

   Tip (5+)
   You can disable CTRL-T, CTRL-R, or ALT-C bindings by setting the corresponding *_COMMAND variable to
   an empty string when sourcing the script. For example, to disable CTRL-R and ALT-C:
     * bash: FZF_CTRL_R_COMMAND= FZF_ALT_C_COMMAND= eval "$(fzf --bash)"
     * zsh: FZF_CTRL_R_COMMAND= FZF_ALT_C_COMMAND= source <(fzf --zsh)
     * fish: fzf --fish | FZF_CTRL_R_COMMAND= FZF_ALT_C_COMMAND= source

   Setting the variables after sourcing the script will have no effect.

Vim/Neovim plugin
   If you use vim-plug, add this to your Vim configuration file:
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'

     * junegunn/fzf provides the basic library functions
          + fzf#install() makes sure that you have the latest binary
     * junegunn/fzf.vim is a separate project that provides a variety of useful commands

   To learn more about the Vim integration, see
   [https://github.com/junegunn/fzf/blob/master/README-VIM.md]README-VIM.md.

   Tip
   If you use Neovim and prefer Lua-based plugins, check out [https://github.com/ibhagwan/fzf-lua]fzf-lua.

Upgrading fzf
   fzf is being actively developed, and you might want to upgrade it once in a while. Please follow the
   instruction below depending on the installation method used.
     * git: cd ~/.fzf && git pull && ./install
     * brew: brew update; brew upgrade fzf
     * macports: sudo port upgrade fzf
     * chocolatey: choco upgrade fzf
     * vim-plug: :PlugUpdate fzf

Building fzf
   See [https://github.com/junegunn/fzf/blob/master/BUILD.md]BUILD.md.

Usage
   fzf will launch interactive finder, read the list from STDIN, and write the selected item to STDOUT.
$> find * -type f | fzf > selected

   Without STDIN pipe, fzf will traverse the file system under the current directory to get the list of
   files.
$> vim $(fzf)

   Note
   You can override the default behavior
     * Either by setting $FZF_DEFAULT_COMMAND to a command that generates the desired list
     * Or by setting --walker, --walker-root, and --walker-skip options in $FZF_DEFAULT_OPTS

   Warning
   A more robust solution would be to use xargs but we've presented the above as it's easier to grasp
$> fzf --print0 | xargs -0 -o vim

   Tip
   fzf also has the ability to turn itself into a different process.
$> fzf --bind 'enter:become(vim {})'

   See [https://github.com/junegunn/fzf#turning-into-a-different-process]Turning into a different process for
   more information.

Using the finder
     * CTRL-K / CTRL-J (or CTRL-P / CTRL-N) to move cursor up and down
     * Enter key to select the item, CTRL-C / CTRL-G / ESC to exit
     * On multi-select mode (-m), TAB and Shift-TAB to mark multiple items
     * Emacs style key bindings
     * Mouse: scroll, click, double-click; shift-click and shift-scroll on multi-select mode

Display modes
   fzf by default runs in fullscreen mode, but there are other display modes.

--height mode
   With --height HEIGHT[%], fzf will start below the cursor with the given height.
fzf --height 40%


   reverse layout and --border goes well with this option.
fzf --height 40% --layout reverse --border

   By prepending ~ to the height, you're setting the maximum height.
# Will take as few lines as possible to display the list
seq 3 | fzf --height ~100%
seq 3000 | fzf --height ~100%

   Height value can be a negative number.
# Screen height - 3
fzf --height -3

--tmux mode
   With --tmux option, fzf will start in a tmux popup.
# --tmux [center|top|bottom|left|right][,SIZE[%]][,SIZE[%][,border-native]]

fzf --tmux center         # Center, 50% width and height
fzf --tmux 80%            # Center, 80% width and height
fzf --tmux 100%,50%       # Center, 100% width and 50% height
fzf --tmux left,40%       # Left, 40% width
fzf --tmux left,40%,90%   # Left, 40% width, 90% height
fzf --tmux top,40%        # Top, 40% height
fzf --tmux bottom,80%,40% # Bottom, 80% width, 40% height

   --tmux is silently ignored when you're not on tmux.

   Note
   If you're stuck with an old version of tmux that doesn't support popup, or if you want to open fzf in
   a regular tmux pane, check out [https://github.com/junegunn/fzf/blob/master/bin/fzf-tmux]fzf-tmux script.

   Tip (5+)
   You can add these options to $FZF_DEFAULT_OPTS so that they're applied by default. For example,
# Open in tmux popup if on tmux, otherwise use --height mode
export FZF_DEFAULT_OPTS='--height 40% --tmux bottom,40% --layout reverse --border top'

Search syntax
   Unless otherwise specified, fzf starts in "extended-search mode" where you can type in multiple
   search terms delimited by spaces. e.g. ^music .mp3$ sbtrkt !fire

   -----------------------------------------------------------------------------------------------
   Token      Match type                                Description
   -----------------------------------------------------------------------------------------------
   sbtrkt     fuzzy-match                               Items that match sbtrkt
   'wild      exact-match (quoted)                      Items that include wild
   'wild'     exact-boundary-match (quoted both ends)   Items that include wild at word boundaries
   ^music     prefix-exact-match                        Items that start with music
   .mp3$      suffix-exact-match                        Items that end with .mp3
   !fire      inverse-exact-match                       Items that do not include fire
   !^music    inverse-prefix-exact-match                Items that do not start with music
   !.mp3$     inverse-suffix-exact-match                Items that do not end with .mp3
   -----------------------------------------------------------------------------------------------

   If you don't prefer fuzzy matching and do not wish to "quote" every word, start fzf with -e or
   --exact option. Note that when --exact is set, '-prefix "unquotes" the term.

   A single bar character term acts as an OR operator. For example, the following query matches entries
   that start with core and end with either go, rb, or py.
^core go$ | rb$ | py$

Environment variables (5+)
     * FZF_DEFAULT_COMMAND
          + Default command to use when input is tty
          + e.g. export FZF_DEFAULT_COMMAND='fd --type f'

     * FZF_DEFAULT_OPTS
          + Default options
          + e.g. export FZF_DEFAULT_OPTS="--layout=reverse --inline-info"

     * FZF_DEFAULT_OPTS_FILE
          + If you prefer to manage default options in a file, set this variable to point to the
            location of the file
          + e.g. export FZF_DEFAULT_OPTS_FILE=~/.fzfrc

   Warning
   FZF_DEFAULT_COMMAND is not used by shell integration due to the slight difference in requirements.
     * CTRL-T runs $FZF_CTRL_T_COMMAND to get a list of files and directories
     * ALT-C runs $FZF_ALT_C_COMMAND to get a list of directories
     * vim ~/**<tab> runs fzf_compgen_path() with the prefix (~/) as the first argument
     * cd foo**<tab> runs fzf_compgen_dir() with the prefix (foo) as the first argument

   The available options are described later in this document.

Customizing the look
   The user interface of fzf is fully customizable with a large number of configuration options. For a
   quick setup, you can start with one of the style presets - default, full, or minimal - using the
   --style option.

fzf --style full \
    --preview 'fzf-preview.sh {}' --bind 'focus:transform-header:file --brief {}'

Preset    Screenshot
default   [https://raw.githubusercontent.com/junegunn/i/master/fzf-style-default.png][fzf-style-default.png]
full      [https://raw.githubusercontent.com/junegunn/i/master/fzf-style-full.png][fzf-style-full.png]
minimal   [https://raw.githubusercontent.com/junegunn/i/master/fzf-style-minimal.png][fzf-style-minimal.png]

   Here's an example based on the full preset:
   [https://raw.githubusercontent.com/junegunn/i/master/fzf-4-borders.png][fzf-4-borders.png]

git ls-files | fzf --style full \
    --border --padding 1,2 \
    --border-label ' Demo ' --input-label ' Input ' --header-label ' File Type ' \
    --preview 'fzf-preview.sh {}' \
    --bind 'result:transform-list-label:
        if [[ -z $FZF_QUERY ]]; then
          echo " $FZF_MATCH_COUNT items "
        else
          echo " $FZF_MATCH_COUNT matches for [$FZF_QUERY] "
        fi
        ' \
    --bind 'focus:transform-preview-label:[[ -n {} ]] && printf " Previewing [%s] " {}' \
    --bind 'focus:+transform-header:file --brief {} || echo "No file selected"' \
    --bind 'ctrl-r:change-list-label( Reloading the list )+reload(sleep 2; git ls-files)' \
    --color 'border:#aaaaaa,label:#cccccc' \
    --color 'preview-border:#9999cc,preview-label:#ccccff' \
    --color 'list-border:#669966,list-label:#99cc99' \
    --color 'input-border:#996666,input-label:#ffcccc' \
    --color 'header-border:#6699cc,header-label:#99ccff'

Options
   See the man page (fzf --man or man fzf) for the full list of options.

Demo
   If you learn by watching videos, check out this screencast by [https://github.com/samoshkin]@samoshkin to
   explore fzf features.
   [https://www.youtube.com/watch?v=qgG5Jhi_Els]

Examples

Key bindings for command-line
   By setting up shell integration, you can use the following key bindings in bash, zsh, and fish.
     * CTRL-T - Paste the selected files and directories onto the command-line
          + The list is generated using --walker file,dir,follow,hidden option
               o You can override the behavior by setting FZF_CTRL_T_COMMAND to a custom command that
                 generates the desired list
               o Or you can set --walker* options in FZF_CTRL_T_OPTS
          + Set FZF_CTRL_T_OPTS to pass additional options to fzf

# Preview file content using bat (https://github.com/sharkdp/bat)
export FZF_CTRL_T_OPTS="
  --walker-skip .git,node_modules,target
  --preview 'bat -n --color=always {}'
  --bind 'ctrl-/:change-preview-window(down|hidden|)'"
          + Can be disabled by setting FZF_CTRL_T_COMMAND to an empty string when sourcing the script
     * CTRL-R - Paste the selected command from history onto the command-line
          + If you want to see the commands in chronological order, press CTRL-R again which toggles
            sorting by relevance
          + Press ALT-R to toggle "raw" mode where you can see the surrounding items of a match. In this
            mode, you can press CTRL-N and CTRL-P to move between the matching items only.
          + Press CTRL-/ or ALT-/ to toggle line wrapping
          + Set FZF_CTRL_R_OPTS to pass additional options to fzf

# CTRL-Y to copy the command into clipboard using pbcopy
export FZF_CTRL_R_OPTS="
  --bind 'ctrl-y:execute-silent(echo -n {2..} | pbcopy)+abort'
  --color header:italic
  --header 'Press CTRL-Y to copy command into clipboard'"
          + Can be disabled by setting FZF_CTRL_R_COMMAND to an empty string when sourcing the script
          + Custom override via a non-empty FZF_CTRL_R_COMMAND is not yet supported and will emit a
            warning
     * ALT-C - cd into the selected directory
          + The list is generated using --walker dir,follow,hidden option
          + Set FZF_ALT_C_COMMAND to override the default command
               o Or you can set --walker-* options in FZF_ALT_C_OPTS
          + Set FZF_ALT_C_OPTS to pass additional options to fzf

# Print tree structure in the preview window
export FZF_ALT_C_OPTS="
  --walker-skip .git,node_modules,target
  --preview 'tree -C {}'"
          + Can be disabled by setting FZF_ALT_C_COMMAND to an empty string when sourcing the script

   Display modes for these bindings can be separately configured via FZF_{CTRL_T,CTRL_R,ALT_C}_OPTS or
   globally via FZF_DEFAULT_OPTS. (e.g. FZF_CTRL_R_OPTS='--tmux bottom,60% --height 60% --border top')

   More tips can be found on [https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings]the wiki
   page.

Fuzzy completion for bash and zsh

Files and directories (5+)
   Fuzzy completion for files and directories can be triggered if the word before the cursor ends with
   the trigger sequence, which is by default **.
     * COMMAND [DIRECTORY/][FUZZY_PATTERN]**<TAB>

# Files under the current directory
# - You can select multiple items with TAB key
vim **<TAB>

# Files under parent directory
vim ../**<TAB>

# Files under parent directory that match `fzf`
vim ../fzf**<TAB>

# Files under your home directory
vim ~/**<TAB>


# Directories under current directory (single-selection)
cd **<TAB>

# Directories under ~/github that match `fzf`
cd ~/github/fzf**<TAB>

Process IDs
   Fuzzy completion for PIDs is provided for kill command.
# Can select multiple processes with <TAB> or <Shift-TAB> keys
kill -9 **<TAB>

Host names
   For ssh and telnet commands, fuzzy completion for hostnames is provided. The names are extracted from
   /etc/hosts and ~/.ssh/config.
ssh **<TAB>
telnet **<TAB>

Environment variables / Aliases
unset **<TAB>
export **<TAB>
unalias **<TAB>

Customizing fzf options for completion
# Use ~~ as the trigger sequence instead of the default **
export FZF_COMPLETION_TRIGGER='~~'

# Options to fzf command
export FZF_COMPLETION_OPTS='--border --info=inline'

# Options for path completion (e.g. vim **<TAB>)
export FZF_COMPLETION_PATH_OPTS='--walker file,dir,follow,hidden'

# Options for directory completion (e.g. cd **<TAB>)
export FZF_COMPLETION_DIR_OPTS='--walker dir,follow'

# Advanced customization of fzf options via _fzf_comprun function
# - The first argument to the function is the name of the command.
# - You should make sure to pass the rest of the arguments ($@) to fzf.

_fzf_comprun() {
	local command=$1
	shift

	case "$command" in
		cd)           fzf --preview 'tree -C {} | head -200'   "$@" ;;
		export|unset) fzf --preview "eval 'echo \$'{}"         "$@" ;;
		ssh)          fzf --preview 'dig {}'                   "$@" ;;
		*)            fzf --preview 'bat -n --color=always {}' "$@" ;;
	esac
}

Customizing completion source for paths and directories
# Use fd (https://github.com/sharkdp/fd) for listing path candidates.
# - The first argument to the function ($1) is the base path to start traversal
# - See the source code (completion.{bash,zsh}) for the details.

_fzf_compgen_path() {
	fd --hidden --follow --exclude ".git" . "$1"
}

# Use fd to generate the list for directory completion
_fzf_compgen_dir() {
	fd --type d --hidden --follow --exclude ".git" . "$1"
}

Supported commands
   On bash, fuzzy completion is enabled only for a predefined set of commands (complete | grep _fzf to
   see the list). But you can enable it for other commands as well by using _fzf_setup_completion helper
   function.

# usage: _fzf_setup_completion path|dir|var|alias|host COMMANDS...
_fzf_setup_completion path ag git kubectl
_fzf_setup_completion dir tree

Custom fuzzy completion
   (Custom completion API is experimental and subject to change)

   For a command named "COMMAND", define _fzf_complete_COMMAND function using _fzf_complete helper.

# Custom fuzzy completion for "doge" command
#   e.g. doge **<TAB>
_fzf_complete_doge() {
	_fzf_complete --multi --reverse --prompt="doge> " -- "$@" < <(
		echo very
		echo wow
		echo such
		echo doge
	)
}

     * The arguments before -- are the options to fzf.
     * After --, simply pass the original completion arguments unchanged ("$@").
     * Then, write a set of commands that generates the completion candidates and feed its output to the
       function using process substitution (< <(...)).

   zsh will automatically pick up the function using the naming convention but in bash you have to
   manually associate the function with the command using the complete command.

[ -n "$BASH" ] && complete -F _fzf_complete_doge -o default -o bashdefault doge

   If you need to post-process the output from fzf, define _fzf_complete_COMMAND_post as follows.

_fzf_complete_foo() {
	_fzf_complete --multi --reverse --header-lines=3 -- "$@" < <(
		ls -al
	)
}

_fzf_complete_foo_post() {
	awk '{print $NF}'
}

[ -n "$BASH" ] && complete -F _fzf_complete_foo -o default -o bashdefault foo

Vim plugin
   See [https://github.com/junegunn/fzf/blob/master/README-VIM.md]README-VIM.md.

Advanced topics

Customizing for different types of input
   Since fzf is a general-purpose text filter, its algorithm was designed to "generally" work well with
   any kind of input. However, admittedly, there is no true one-size-fits-all solution, and you may want
   to tweak the algorithm and some of the settings depending on the type of the input. To make this
   process easier, fzf provides a set of "scheme"s for some common input types.
   Scheme           Description
   --scheme=default Generic scheme designed to work well with any kind of input
   --scheme=path    Suitable for file paths
   --scheme=history Suitable for command history or any input where chronological ordering is important

   (See fzf --man for the details)

Performance
   fzf is fast. Performance should not be a problem in most use cases. However, you might want to be
   aware of the options that can affect performance.
     * --ansi tells fzf to extract and parse ANSI color codes in the input, and it makes the initial
       scanning slower. So it's not recommended that you add it to your $FZF_DEFAULT_OPTS.
     * --nth makes fzf slower because it has to tokenize each line.
     * A plain string --delimiter should be preferred over a regular expression delimiter.
     * --with-nth makes fzf slower as fzf has to tokenize and reassemble each line.

Executing external programs
   You can set up key bindings for starting external processes without leaving fzf (execute,
   execute-silent).
# Press F1 to open the file with less without leaving fzf
# Press CTRL-Y to copy the line to clipboard and aborts fzf (requires pbcopy)
fzf --bind 'f1:execute(less -f {}),ctrl-y:execute-silent(echo {} | pbcopy)+abort'

   See KEY/EVENT BINDINGS section of the man page for details.

Turning into a different process
   become(...) is similar to execute(...)/execute-silent(...) described above, but instead of executing
   the command and coming back to fzf on complete, it turns fzf into a new process for the command.
fzf --bind 'enter:become(vim {})'

   Compared to the seemingly equivalent command substitution vim "$(fzf)", this approach has several
   advantages:
     * Vim will not open an empty file when you terminate fzf with CTRL-C
     * Vim will not open an empty file when you press ENTER on an empty result
     * Can handle multiple selections even when they have whitespaces
fzf --multi --bind 'enter:become(vim {+})'

   To be fair, running fzf --print0 | xargs -0 -o vim instead of vim "$(fzf)" resolves all of the issues
   mentioned. Nonetheless, become(...) still offers additional benefits in different scenarios.
     * You can set up multiple bindings to handle the result in different ways without any wrapping
       script
fzf --bind 'enter:become(vim {}),ctrl-e:become(emacs {})'
          + Previously, you would have to use --expect=ctrl-e and check the first line of the output of
            fzf
     * You can easily build the subsequent command using the field index expressions of fzf
# Open the file in Vim and go to the line
git grep --line-number . |
    fzf --delimiter : --nth 3.. --bind 'enter:become(vim {1} +{2})'

Reloading the candidate list
   By binding reload action to a key or an event, you can make fzf dynamically reload the candidate
   list. See [https://github.com/junegunn/fzf/issues/1750]#1750 for more details.

1. Update the list of processes by pressing CTRL-R

ps -ef |
  fzf --bind 'ctrl-r:reload(ps -ef)' \
      --header 'Press CTRL-R to reload' --header-lines=1 \
      --height=50% --layout=reverse

2. Switch between sources by pressing CTRL-D or CTRL-F

FZF_DEFAULT_COMMAND='find . -type f' \
  fzf --bind 'ctrl-d:reload(find . -type d),ctrl-f:reload(eval "$FZF_DEFAULT_COMMAND")' \
      --height=50% --layout=reverse

3. Interactive ripgrep integration
   The following example uses fzf as the selector interface for ripgrep. We bound reload action to
   change event, so every time you type on fzf, the ripgrep process will restart with the updated query
   string denoted by the placeholder expression {q}. Also, note that we used --disabled option so that
   fzf doesn't perform any secondary filtering.

: | rg_prefix='rg --column --line-number --no-heading --color=always --smart-case' \
    fzf --bind 'start:reload:$rg_prefix ""' \
        --bind 'change:reload:$rg_prefix {q} || true' \
        --bind 'enter:become(vim {1} +{2})' \
        --ansi --disabled \
        --height=50% --layout=reverse

   If ripgrep doesn't find any matches, it will exit with a non-zero exit status, and fzf will warn you
   about it. To suppress the warning message, we added || true to the command, so that it always exits
   with 0.

   See [https://github.com/junegunn/fzf/blob/master/ADVANCED.md#using-fzf-as-interactive-ripgrep-launcher]"Using fzf as interactive Ripgrep launcher" for more sophisticated examples.

Preview window
   When the --preview option is set, fzf automatically starts an external process with the current line
   as the argument and shows the result in the split window. Your $SHELL is used to execute the command
   with $SHELL -c COMMAND. The window can be scrolled using the mouse or custom key bindings.
# {} is replaced with the single-quoted string of the focused line
fzf --preview 'cat {}'

   Preview window supports ANSI colors, so you can use any program that syntax-highlights the content of
   a file, such as Bat or Highlight:
fzf --preview 'bat --color=always {}' --preview-window '~3'

   You can customize the size, position, and border of the preview window using --preview-window option,
   and the foreground and background color of it with --color option. For example,
fzf --height 40% --layout reverse --info inline --border \
    --preview 'file {}' --preview-window up,1,border-horizontal \
    --bind 'ctrl-/:change-preview-window(50%|hidden|)' \
    --color 'fg:#bbccdd,fg+:#ddeeff,bg:#334455,preview-bg:#223344,border:#778899'

   See the man page (man fzf) for the full list of options.

   More advanced examples can be found [https://github.com/junegunn/fzf/blob/master/ADVANCED.md]here.

   Warning
   Since fzf is a general-purpose text filter rather than a file finder, it is not a good idea to add
   --preview option to your $FZF_DEFAULT_OPTS.

# *********************
# ** DO NOT DO THIS! **
# *********************
export FZF_DEFAULT_OPTS='--preview "bat --style=numbers --color=always --line-range :500 {}"'

# bat doesn't work with any input other than the list of files
ps -ef | fzf
seq 100 | fzf
history | fzf

Previewing an image
   fzf can display images in the preview window using one of the following protocols:
     * [https://sw.kovidgoyal.net/kitty/graphics-protocol/]Kitty graphics protocol
     * [https://iterm2.com/documentation-images.html]iTerm2 inline images protocol
     * [https://en.wikipedia.org/wiki/Sixel]Sixel

   See [https://github.com/junegunn/fzf/blob/master/bin/fzf-preview.sh]bin/fzf-preview.sh script for more
   information.
fzf --preview 'fzf-preview.sh {}'

Tips

Respecting .gitignore
   You can use fd, ripgrep, or the silver searcher to traverse the file system while
   respecting .gitignore.
# Feed the output of fd into fzf
fd --type f --strip-cwd-prefix | fzf

# Setting fd as the default source for fzf
export FZF_DEFAULT_COMMAND='fd --type f --strip-cwd-prefix'

# Now fzf (w/o pipe) will use the fd command to generate the list
fzf

# To apply the command to CTRL-T as well
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"

   If you want the command to follow symbolic links and don't want it to exclude hidden files, use the
   following command:
export FZF_DEFAULT_COMMAND='fd --type f --strip-cwd-prefix --hidden --follow --exclude .git'

Fish shell
   CTRL-T key binding of fish, unlike those of bash and zsh, will use the last token on the command-line
   as the root directory for the recursive search. For instance, hitting CTRL-T at the end of the
   following command-line
ls /var/

   will list all files and directories under /var/.

   When using a custom FZF_CTRL_T_COMMAND, use the unexpanded $dir variable to make use of this feature.
   $dir defaults to . when the last token is not a valid directory. Example:
set -g FZF_CTRL_T_COMMAND "command find -L \$dir -type f 2> /dev/null | sed '1d; s#^\./##'"

fzf Theme Playground
   [https://vitormv.github.io/fzf-themes/]fzf Theme Playground created by Vitor Mello is a webpage where
   you can interactively create fzf themes.

Related projects
   [https://github.com/junegunn/fzf/wiki/Related-projects]https://github.com/junegunn/fzf/wiki/Related-projects


---
https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings

Configuring shell key bindings
May 11, 2024

Changing the display mode
   The key bindings use --height 40% option to display fzf finder below your cursor, but it's
   configurable.

   If you prefer to run fzf in fullscreen mode, add --no-height to your $FZF_DEFAULT_OPTS like follows:
export FZF_DEFAULT_OPTS='--no-height --no-reverse'

CTRL-T
Preview
   You can preview the content of the file under the cursor by setting --preview option.
# Using highlight (http://www.andre-simon.de/doku/highlight/en/highlight.html)
export FZF_CTRL_T_OPTS="--preview '(highlight -O ansi -l {} 2> /dev/null || cat {} || tree -C {}) \
2>/dev/null | head -200'"

Using --select-1 and/or --exit-0
export FZF_CTRL_T_OPTS="--select-1 --exit-0"

   --select-1 automatically selects the item if there's only one so that you don't have to press enter
   key. Likewise, --exit-0 automatically exits when the list is empty. These options are also useful in
   FZF_ALT_C_OPTS.

CTRL-R
Sorting and exact matching
   Sorting by relevance is enabled by default. You can dynamically switch to chronological order by
   pressing CTRL-R again, but if you like it to be enabled by default, add --no-sort to FZF_CTRL_R_OPTS.
   Likewise, if you prefer to use exact (non-fuzzy) matching, add --exact.
export FZF_CTRL_R_OPTS='--no-sort --exact'

Full command on preview window
   Commands that are too long are not fully visible on screen. We can use --preview option to display
   the full command on the preview window. In the following example, we bind ? key for toggling the
   preview window.
export FZF_CTRL_R_OPTS="--preview 'echo {}' --preview-window down:3:hidden:wrap --bind '?:toggle-preview'"

Directly executing the command (CTRL-X CTRL-R)

zsh
fzf-history-widget-accept() {
	fzf-history-widget
	zle accept-line
}
zle     -N     fzf-history-widget-accept
bindkey '^X^R' fzf-history-widget-accept

bash
bind "$(bind -s | grep '^"\\C-r"' | sed 's/"/"\\C-x/' | sed 's/"$/\\C-m"/')"

Dynamically choose to execute or edit
   There is an open issue for this; We have a solution for zsh, but not for bash.

ALT-C
Preview
   The following example uses tree command to show the entries of the directory.
export FZF_ALT_C_OPTS="--preview 'tree -C {} | head -200'"


---
https://github.com/junegunn/fzf/issues/1661

ZF_CTRL_T_OPTS seemingly not applied #1661
Aug 7, 2019

I have been periodically improving my fzf configuration, and recently I noticed that the preview window
doesn't show anymore when pressing CTRL + T. I shuffled around my options quite a bit, so I'm not sure what
might have caused it. I have my fuzzy completion configured like described at
Configuring-fuzzy-completion#dedicated-completion-key.

Here are the relevant lines of my .zshrc:

# fzf config
export FZF_ALT_C_OPTS="--preview 'tree -C {} | head -200'"

# export FZF_CTRL_T_OPTS="--preview '[[ $(file --mime {}) =~ binary ]] &&
#                  echo {} is a binary file ||
#                  (bat --style=numbers --color=always {} ||
#                   highlight -O ansi -l {} ||
#                   coderay {} ||
#                   rougify {} ||
#                   cat {}) 2> /dev/null | head -500' --preview-window=right:60%"
export FZF_CTRL_T_OPTS="--preview 'cat {}'"
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh
export FZF_COMPLETION_TRIGGER=''
bindkey '^T' fzf-completion
bindkey '^I' $fzf_default_completion

The commented out value comes from my recent testing with the suggested preview option from README.md. As you
can see the current value is --preview 'cat {}', for testing a minimal version to rule out issues in the
commands themselves. Even with --preview 'cat {}' or --preview 'cat {}' --preview-window=right:60%, the
preview window doesn't show up, not under tmux and not in the plain GNOME terminal either.

Strangely enough FZF_ALT_C_OPTS does work under all circumstances.

Notes
    * I have bat installed
    * my $TERM under tmux doesn't start with screen (it's tmux-256color), but the behaviour I'm describing is
      identical both under tmux and outside it, in GNOME terminal, and in Xterm as well
    * I have oh-my-zsh installed, but I made sure to not have their "plugin" of fzf enabled
    * I don't setopt vi anywhere, yet bindkey '^I' still returns "^I" expand-or-complete, but it seems to me
      that shouldn't be relevant for my problem
    * after noticing the issue I updated my installation using git pull and ~/.fzf/install
    * I call bindkey '^X' and zle -N in my .zshrc after the last line in the fragment above, but nothing else
    * I also tried reinstating the default FZF_COMPLETION_TRIGGER='**' setting because that was one of the
      things I was messing around with, but this didn't fix my problem

Any help is appreciated, thanks.

I'd also like to note that when I run the command fzf with the contents of FZF_CTRL_T_OPTS appended, the
preview works as expected

***
It's because you mapped your CTRL-T to fuzzy completion, not default "CTRL-T" binding.

So you need to customize fuzzy completion instead. See https://github.com/junegunn/fzf#settings

***
Many thanks for looking into my issue! I'm very glad to have this detail resolved in my setup.

I just discovered that if you want to use the example preview config from README.md as your
FZF_COMPLETION_OPTS like so:

export FZF_COMPLETION_OPTS="--preview '[[ $(file --mime {}) =~ binary ]] &&
					echo {} is a binary file ||
					(bat --style=numbers --color=always {} ||
					highlight -O ansi -l {} ||
					coderay {} ||
					rougify {} ||
					cat {}) 2> /dev/null | head -500' --preview-window=right:60%"

It won't work since the $() around the file command will be evaluated early.
If your command to complete was vi it prints:

$> vi unknown option: (No

... and exits. To fix it, escape the dollar sign once, so the subshell command looks
like this: \$(file --mime{}). This should've been more obvious to me, but I missed it. I'll note it here for
future reference.


---
https://github.com/junegunn/fzf/discussions/4108

FZF_CTRL_T_OPTS evaluates IF statement with system default shell #4108
Nov 22, 2024

   I switch between Zsh and Fish on Mac.

   I have found that FZF evaluates IF statements with the system default shell and not the current
   shell, if it is different. I am using an IF statement to conditionally set eza or bat in
   FZF_CTRL_T_OPTS. As a result, I can only use FZF like this when my current and system default shell
   match. I would like to better understand why and maybe resolve this limitation. My knowledge of
   shells is limited but I have done extensive troubleshooting to get to this point of understanding the
   situation. Hope someone can help!

   Here are my Zsh and Fish configurations:
# ZSH ~/.zshrc
# CONTROL + T to preview file content using bat or directory structure using eza
export FZF_CTRL_T_OPTS="
  --walker-skip .git,node_modules,target
  --preview 'if [ -d {} ]; then eza --tree --color=always {}; else bat -n --color=always {}; fi'
  --bind 'ctrl-/:change-preview-window(down|hidden|)'
  --color header:italic
  --header 'Use CONTROL + / to toggle preview window'"

# FISH ~/.config/fish/config.fish
# CONTROL + T to preview file content using bat or directory structure using eza
set -x FZF_CTRL_T_OPTS "
  --walker-skip .git,node_modules,target
  --preview 'if test -d {}; eza --tree --colour=always --icons=always {}; else; bat -n --color=always {}; end'
  --bind 'ctrl-/:change-preview-window(down|hidden|)'
  --color header:italic
  --header 'Use CONTROL + / to toggle preview window'"

   When I am in Zsh, but the system default shell is Fish, the IF statement in the Zsh configuration
   causes an error that is reported as a Fish error. And vice versa. When I am in Fish, but the system
   default shell is Zsh, the IF statement in the Fish configuration causes an error that is reported as
   a Zsh error.

   In this screenshot, I have just set the system default shell to fish with sudo dscl . -create
   /Users/$(whoami) UserShell /opt/homebrew/bin/fish and opened a new terminal. I then switch to zsh and
   press CONTROL + Y. Here, you can clearly see that fish is reporting an error but showing the IF
   string from my zsh configuration. This means the IF string is being evaluated with a fish shell (the
   current system default) even though I am now in zsh.
   Screenshot 2024-11-22 at 10 41 10 pm

   In this screenshot, I have just set the system default shell to zsh with sudo dscl . -create
   /Users/$(whoami) UserShell /bin/zsh and opened a new terminal. I then switch to fish and press
   CONTROL + Y. The error is reported as a zsh error, even though I am now in fish. With some messing
   around, I was able to confirm that zsh is indeed getting the IF string from my fish configuration.
   Screenshot 2024-11-22 at 10 39 21 pm

   Here is a screenshot where it works because I am in fish and the system default shell is also fish.
   Screenshot 2024-11-22 at 10 41 45 pm

   Beta Was this translation helpful? Give feedback.

***
	I have found that FZF evaluates IF statements with the system default shell and not the current shell, if
	it is different.

Note
fzf runs the command with $SHELL -c if SHELL is set, otherwise with sh -c

Try assigning SHELL in your zsh or fish config file to see if it works for you.
fzf --bind 'start:become:echo zsh $ZSH_VERSION fish $FISH_VERSION bash $BASH_VERSION'
# zsh 5.9 fish bash

SHELL=$(which fish)

fzf --bind 'start:become:echo zsh $ZSH_VERSION fish $FISH_VERSION bash $BASH_VERSION'
# zsh fish 3.7.1 bash

Alternatively, you can pass the --with-shell=STR1 flag to fzf.
fzf --with-shell="$(which zsh) -c" \
  --bind 'start:become:echo zsh $ZSH_VERSION fish $FISH_VERSION bash $BASH_VERSION'
# zsh 5.9 fish bash

fzf --with-shell="$(which fish) -c" \
  --bind 'start:become:echo zsh $ZSH_VERSION fish $FISH_VERSION bash $BASH_VERSION'
# zsh fish 3.7.1 bash

fzf --with-shell="$(which bash) -c" \
  --bind 'start:become:echo zsh $ZSH_VERSION fish $FISH_VERSION bash $BASH_VERSION'
# zsh fish bash 5.2.37(1)-release

Footnotes

    [https://github.com/junegunn/fzf/blob/master/CHANGELOG.md#0510]fzf/CHANGELOG.md 0.51.0

***
Thank you! That works!

# ~/.config/fish/config.fish

# Set SHELL for Fish sessions
set -x SHELL (which fish)

# ~/.zshrc

# Set SHELL for Zsh sessions
export SHELL=$(which zsh)

And I'll keep the --with-shell approach up my sleeve too! Much appreciated!


---
https://github.com/junegunn/fzf/issues/2399


FZF_CTRL_R_OPTS to support ctrl-o to execute and prepare next commad #2399
Mar 21, 2021

     * [X] I have read through the manual page (man fzf)
     * [X] I have the latest version of fzf
     * [X] I have searched through the existing issues

Problem / Steps to reproduce
   bash ctrl-o operate-and-get-next stops working once I source source ~/.fzf.bash which is auto
   generated by fzf and replaces the default ctrl-r by the __fzf_history__ function.

   fzf ctrl-r behavior
    1. bash --noprofile --norc
    2. source ~/.fzf.bash
    3. export FZF_CTRL_R_OPTS="--bind=ctrl-o:accept", I don't see an accept-and-execute event, and
       execute(...) isn't what I want either.
    4. cd ~
    5. ls
    6. press ctrl-r
    7. find cd ~ command
    8. press ctrl-o, notice fzf exits and command line is populated with cd ~, but no execution happens.
    9. press ctrl-o again, notice it executes cd ~, then populates cd ~ again.

   for comparison, here is vanilla bash ctrl-r behavior
    1. bash --noprofile --norc
    2. cd ~
    3. ls
    4. press ctrl-r
    5. find cd ~ command
    6. press ctrl-o, notice the history search exits and the command is executed, and ls is auto
       populated, ready for execution.
    7. press ctrl-o will execute ls and further chain up remaining next commands, eventualy giving a
       walking through previous sequence effect. this works even when I modify the commands (except the
       first one found in history which has to be executed as is by ctrl-o).

   is there anyway to keep bash original ctrl-o behavior? I do like fzf to search history, but the
   ctrl-o auto sequencing behavior is very useful, e.g., in edit-compile-run cycles. thanks.

   for reference, here is some explanation about bash behavior, I found it on
   [http://web.mit.edu/gnu/doc/html/features_7.html]http://web.mit.edu/gnu/doc/html/features_7.html
   operate-and-get-next (C-o)

###################################################################
Thanks for the suggestion. I wasn't aware of operate-and-get-next, hence not implemented here. I like the idea
but I can't immediately see how we can correctly implement the behavior.

These two steps are easy:
    * Accept the current line for execution
    * and fetch the next line

diff --git a/shell/key-bindings.bash b/shell/key-bindings.bash
index 0cfc423..514d7ff 100644
--- a/shell/key-bindings.bash
+++ b/shell/key-bindings.bash
@@ -45,13 +45,21 @@ __fzf_cd__() {
 }

 __fzf_history__() {
-  local output
+  local output key no cmd
   output=$(
     builtin fc -lnr -2147483648 |
       last_hist=$(HISTTIMEFORMAT='' builtin history 1) perl -n -l0 -e 'BEGIN { getc; $/ = "\n\t"; $HISTCMD = $ENV{last_hist} + 1 } s/^[ *]//; print $HISTCMD - $. . "\t$_" if !$seen{$_}++' |
-      FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} $FZF_DEFAULT_OPTS -n2..,.. --tiebreak=index --bind=ctrl-r:toggle-sort,ctrl-z:ignore $FZF_CTRL_R_OPTS +m --read0" $(__fzfcmd) --query "$READLINE_LINE"
+      FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} $FZF_DEFAULT_OPTS -n2..,.. --tiebreak=index --bind=ctrl-r:toggle-sort,ctrl-z:ignore $FZF_CTRL_R_OPTS +m --read0" $(__fzfcmd) --query "$READLINE_LINE" --expect ctrl-o
   ) || return
-  READLINE_LINE=${output#*$'\t'}
+  key=${output%%$'\n'*}
+  output=${output#*$'\n'}
+  no=${output%$'\t'*}
+  cmd=${output#*$'\t'}
+  if [ "$key" = ctrl-o ]; then
+    cmd=$(history -p "!$(( no + 1 ))" 2> /dev/null)
+    fc -s "$no"
+  fi
+  READLINE_LINE=$cmd
   if [ -z "$READLINE_POINT" ]; then
     echo "$READLINE_LINE"
   else

But after that, we need to programmatically move the current position to the point in the command history so
that we can proceed with the subsequent commands.

***
Thanks. as for the second ctrl-o and beyond, I suspect it's some bash internal keeping track of the history
index, that is reset on every use of ctrl-r/ctrl-o, for otherwise, bash doesn't have necessary info to be
smart enough to differentiate the case where a command is prepared by previous ctrl-o vs. the case when the
same command is typed up. without an internal index, bash would also have trouble going back to the correct
history point based on a command modified from previous ctrl-o result.

I am guessing
[https://github.com/bminor/bash/blob/f3a35a2d601a55f337f8ca02a541f8c033682247/lib/readline/misc.c#L677]this
might be the internal state. if you can somehow call rl_operate_and_get_next for the job,
maybe you can ride on bash behavior for free? I am not sure if it's doable inside fzf, just some ideas.

***
Also, at the very least it should be possible with fzf-tmux while using popup window, as fzf can send keys to
the "current pane" to execute the command...

***
For me as well. Long ago, when I first learned about CTRL+R in general, my life improved vastly. Then, years
later, when I learned about CTRL+O's enhancement of CTRL+R, my life again improved vastly. Then a few years
ago I learned about fzf and my life improved vastly.

Then when I tried my typical CTRL+O sequences and that fzf didn't support it, I was saddened. I'm hopeful it
can be added back!


---
https://nickjanetakis.com/blog/customize-fzf-ctrl-t-binding-to-preview-files

Customize FZF's CTRL + T Binding with FZF_CTRL_T_OPTS to Preview Files
November 14, 2023

   A few years ago I made a post on how to preview files with FZF where we set up a pf (preview
   file) alias to call FZF with a few flags and I still use that method today.

   In this post we'll re-use the same preview flags to also work with FZF's built-in CTRL + T key bind
   which lets you fuzzy match files in a directory and if you select a file it outputs the match into
   your prompt without executing it.

   But, if you hit escape instead of enter to select the file then nothing is added to your prompt which
   makes CTRL + T a quick way to preview files as an alternative to the pf alias.

   We can do all of this by setting FZF_CTRL_T_OPTS which is provided by FZF. I've added it to my
   .zshrc file so it's always available:
# These flags are explained in the post about previewing files with FZF.
export FZF_CTRL_T_OPTS="--preview='less {}' --height=100% \
--bind shift-up:preview-page-up,shift-down:preview-page-down"

   Now we can simplify the pf alias to use alias pf="fzf "${FZF_CTRL_T_OPTS}". Here's
   [https://github.com/nickjj/dotfiles/commit/893093a6f40cc1238ef4e39674cd5f52242abe5c]the commit in my
   dotfiles which makes that change. I did make a last minute adjustment to add --height=100% too which isn't
   included in the linked commit.

Demo
https://www.youtube.com/embed/TuaeG_iS71w?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0

Timestamps
     * 0:09 - Quick recap on previewing files
     * 0:26 - CTRL + T
     * 1:05 - Figuring out how to customize CTRL + T
     * 1:41 - Going over how to implement it
     * 3:20 - Making the CTRL + T preview height taller


---
https://superuser.com/questions/1640183/how-to-delete-history-lines-when-browsing-history-with-fzf

How to delete history lines when browsing history with fzf

   There are often items in the bash history which I don't need anymore and/or are so long that when
   used with fzf match pretty much any text entered, making fuzzy matching on the history a bit useless.
   So I was looking for a way to be able to delete these lines when viewing history with fzf, but this
   is too naive (plus misses reloading, but that's not the issue here):
export FZF_CTRL_R_OPTS="--bind 'ctrl-d:execute-silent(history -d {1})'"

   It doesn't delete any history and I am assuming that might be because fzf runs the command like
   $SHELL -c "history -d 1000" but that is a new shell (my $SHELL is /bin/bash) which has no history (or
   at least not the one from the current shell). Is that assumption correct? And how to fix this?

***
   One approach (shown below as an alias to be put in your .bashrc) is to edit the .bash_history file
   directly, using fzf to select commands, then after editing, reload it:
alias histfzf='history -w; cat .bash_history | fzf > /tmp/to_remove; \
grep -vxFf /tmp/to_remove .bash_history > .new_bash_history; \
mv .new_bash_history .bash_history; rm /tmp/to_remove; history -r'

   Explanation of each step:
# write active history in memory to the .bash_history file
history -w;

# select commands from history (using fzf), and store them in a file:
cat .bash_history | fzf > /tmp/to_remove

# Find commands that don't appear in the to_remove list (and store in .new_bash_history:
grep -vxFf /tmp/to_remove .bash_history > .new_bash_history

# overwrite the history with the edited version:
mv .new_bash_history .bash_history;

# clean up:
rm /tmp/to_remove;

# reload history:
history -r

***
   Thanks to mattb's idea I'm currently using this in .bashrc, comments added.
# Separate so that should fzf's __fzf_history__ implementation change I can just copy-paste
# from it into this file without having to put my stuff in between.
# {+f2..} = fzf will replace this with path to a file containing
#           all selected items starting at second field i.e. the actual history text
export FZF_CTRL_R_OPTS="--bind 'ctrl-s:clear-selection,ctrl-d:execute-silent(grep -vxFf {+f2..} \
~/.bash_history > ~/.edh; cp ~/.edh ~/.bash_history)'"

__fzf_history__() {
	# Flush to .bash_history
	history -w

	# Same as in fzf's original implementation, except that +m is replaced with -m
	# to allow selection of multiple items.
	local output
	output=$(
		builtin fc -lnr -2147483648 |
		last_hist=$(HISTTIMEFORMAT='' builtin history 1) \
		perl -n -l0 -e 'BEGIN { getc; $/ = "\n\t"; $HISTCMD = $ENV{last_hist} + 1 } \
		s/^[ *]//; print $HISTCMD - $. . "\t$_" if !$seen{$_}++' \
		| FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-60%} \
		$FZF_DEFAULT_OPTS -n2..,.. --tiebreak=index --bind=ctrl-r:toggle-sort,ctrl-z:ignore \
		$FZF_CTRL_R_OPTS -m --read0" $(__fzfcmd) --query "$READLINE_LINE"
	)

	# Reload from .bash_history if needed.
	if [ -f ~/.edh ]; then
		history -r
		rm ~/.edh
	fi

	# Rest of original implementation
	if [ -z "$output"]; then
		return
	fi

	READLINE_LINE=${output#*$'\t'}
	if [ -z "$READLINE_POINT" ]; then
		echo "$READLINE_LINE"
	else
		READLINE_POINT=0x7fffffff
	fi
}

# CTRL-R - Paste the selected command from history into the command line
bind -m emacs-standard -x '"\C-r": __fzf_history__'
bind -m vi-command -x '"\C-r": __fzf_history__'
bind -m vi-insert -x '"\C-r": __fzf_history__'

   Does everything I want, except reloading the view but that would require putting most of that massive
   command in the fzf commandline so I'm not going there right now :)

***
   Another thing that might be useful to keep your bash history free of non-useful commands is to set
   the HISTIGNORE variable in your .bashrc:
HISTIGNORE="cd:cl:clc:ls:l:ll:lll:..:...:....:sob:f *"

   Each command that you don't want recorded in your history is separated by a colon. You can also use
   regexp patterns to filter out the commands.

   Many of the commands I filter out are aliases I have that I never search back to repeat:
# clear the terminal (clc is because I did too much matlab)
alias cl='clear && clear'
alias clc='clear && clear'

# show ls vertically by default using the -1 switch
alias l='ls -1 -hF'

# same as above, but with file details too
alias ll='ls -lhF'

# same as above, but with hidden files too
alias lll='ls -alhF'

# move up 1,2 or 3 directories
alias ..='cd ../'
alias ...='cd ../../'
alias ....='cd ../../../'

# source .bashrc
alias sob='source ~/.bashrc'

   The last command f * is a function I wrote
   ([https://github.com/nickjj/dotfiles/commit/893093a6f40cc1238ef4e39674cd5f52242abe5c]see answer here) to
   use fzf to select files from around my system and pass them as arguments to any program (e.g. vim, cat,
   vlc, evince etc.). When I first wrote it, my history would be full of things like f vim and f cd -
   completely useless to me later. I've since improved the function so that it actually puts the fzf expanded
   command into history, so I don't need to filter f * now, but it helps illustrate the use of regexp to
   ignore certain commands.

   In case they fzf function I mentioned interests you, here it is:
#!/bin/bash

# Run command/application and choose paths/files with fzf.
# Always return control of the terminal to user (e.g. when opening GUIs).
# The full command that was used will appear in your history just like any
# other (N.B. to achieve this I write the shell's active history to
# ~/.bash_history)
#
# Usage:
# f cd [OPTION]... (hit enter, choose path)
# f cat [OPTION]... (hit enter, choose files)
# f vim [OPTION]... (hit enter, choose files)
# f vlc [OPTION]... (hit enter, choose files)

f() {
	# Store the program
	program="$1"

	# Remove first argument off the list
	shift

	# Store option flags with separating spaces, or just set as single space
	options="$@"
	if [ -z "${options}" ]; then
		options=" "
	else
		options=" $options "
	fi

	# Store the arguments from fzf
	arguments=($(fzf --multi))

	# If no arguments passed (e.g. if Esc pressed), return to terminal
	if [ -z "${arguments}" ]; then
		return 1
	fi

	# We want the command to show up in our bash history, so write the shell's
	# active history to ~/.bash_history. Then we'll also add the command from
	# fzf, then we'll load it all back into the shell's active history
	history -w

	# ADD A REPEATABLE COMMAND TO THE BASH HISTORY ############################
	# Store the arguments in a temporary file for sanitising before being
	# entered into bash history
	: > /tmp/fzf_tmp
	for file in "${arguments[@]}"; do
		echo "$file" >> /tmp/fzf_tmp
	done

	# Put all input arguments on one line and sanitise the command by putting
	# single quotes around each argument, also first put an extra single quote
	# next to any pre-existing single quotes in the raw argument
	sed -i "s/'/''/g; s/.*/'&'/g; s/\n//g" /tmp/fzf_tmp

	# If the program is on the GUI list, add a '&' to the command history
	if [[ "$program" =~ ^(nautilus|zathura|evince|vlc|eog|kolourpaint)$ ]]; then
		sed -i '${s/$/ \&/}' /tmp/fzf_tmp
	fi

	# Grab the sanitised arguments
	arguments="$(cat /tmp/fzf_tmp)"

	# Add the command with the sanitised arguments to our .bash_history
	echo $program$options$arguments >> ~/.bash_history

	# Reload the ~/.bash_history into the shell's active history
	history -r

	# EXECUTE THE LAST COMMAND IN ~/.bash_history #############################
	fc -s -1

	# Clean up temporary variables
	rm /tmp/fzf_tmp
}


---
https://junegunn.github.io/fzf/shell-integration/
Jul 8, 2024

Shell Integration

   To be useful out of the box without any scripting effort, fzf provides shell integration for bash,
   zsh and fish.
     * CTRL-T, ALT-C, CTRL-R for bash, zsh, and fish
     * Fuzzy completion for bash and zsh

Setting up shell integration
   To set up shell integration, add the following to your shell configuration file:
     * bash (~/.bashrc)
eval "$(fzf --bash)"

     * zsh (~/.zshrc)
source <(fzf --zsh)

     * fish (~/.config/fish/config.fish)
fzf --fish | source

   Tip
   You can disable CTRL-T or ALT-C binding by setting FZF_CTRL_T_COMMAND or FZF_ALT_C_COMMAND to an
   empty string when sourcing the script. For example, to disable ALT-C binding:
     * bash: FZF_ALT_C_COMMAND= eval "$(fzf --bash)"
     * zsh: FZF_ALT_C_COMMAND= source <(fzf --zsh)
     * fish: fzf --fish | FZF_ALT_C_COMMAND= source

   Setting the variables after sourcing the script will have no effect.

Key bindings

CTRL-R
   Paste the selected command from history onto the command-line
     * If you want to see the commands in chronological order, press CTRL-R again which toggles sorting
       by relevance
     * Press CTRL-/ to toggle line wrapping and see the whole command
     * Set FZF_CTRL_R_OPTS to pass additional options to fzf
# CTRL-Y to copy the command into clipboard using pbcopy
export FZF_CTRL_R_OPTS="
  --bind 'ctrl-y:execute-silent(echo -n {2..} | pbcopy)+abort'
  --color header:italic
  --header 'Press CTRL-Y to copy command into clipboard'"

CTRL-T
   Paste the selected files and directories onto the command-line
     * The list is generated using --walker file,dir,follow,hidden option
          + You can override the behavior by setting FZF_CTRL_T_COMMAND to a custom command that
            generates the desired list
          + Or you can set --walker* options in FZF_CTRL_T_OPTS
     * Set FZF_CTRL_T_OPTS to pass additional options to fzf
# Preview file content using bat (https://github.com/sharkdp/bat)
export FZF_CTRL_T_OPTS="
  --walker-skip .git,node_modules,target
  --preview 'bat -n --color=always {}'
  --bind 'ctrl-/:change-preview-window(down|hidden|)'"

     * Can be disabled by setting FZF_CTRL_T_COMMAND to an empty string when sourcing the script

ALT-C
   cd into the selected directory
     * The list is generated using --walker dir,follow,hidden option
     * Set FZF_ALT_C_COMMAND to override the default command
          + Or you can set --walker-* options in FZF_ALT_C_OPTS
     * Set FZF_ALT_C_OPTS to pass additional options to fzf
# Print tree structure in the preview window
export FZF_ALT_C_OPTS="
  --walker-skip .git,node_modules,target
  --preview 'tree -C {}'"

     * Can be disabled by setting FZF_ALT_C_COMMAND to an empty string when sourcing the script

Key bindings for Git objects

   [https://github.com/junegunn/fzf-git.sh]fzf-git.sh project provides a bunch of key bindings for completing
   Git objects. You should definitely check it out.

Fuzzy completion for bash and zsh

Files and directories
   Fuzzy completion for files and directories can be triggered if the word before the cursor ends with
   the trigger sequence, which is by default **.
     * COMMAND [DIRECTORY/][FUZZY_PATTERN]**<TAB>

# Files under the current directory
# - You can select multiple items with TAB key
vim **<TAB>

# Files under parent directory
vim ../**<TAB>

# Files under parent directory that match `fzf`
vim ../fzf**<TAB>

# Files under your home directory
vim ~/**<TAB>

# Directories under current directory (single-selection)
cd **<TAB>

# Directories under ~/github that match `fzf`
cd ~/github/fzf**<TAB>

Process IDs
   Fuzzy completion for PIDs is provided for kill command.
# Can select multiple processes with <TAB> or <Shift-TAB> keys
kill -9 **<TAB>

Host names
   For ssh and telnet commands, fuzzy completion for hostnames is provided. The names are extracted from
   /etc/hosts and ~/.ssh/config.
ssh **<TAB>
telnet **<TAB>

Environment variables / Aliases
unset **<TAB>
export **<TAB>
unalias **<TAB>


---
https://thevaluable.dev/fzf-shell-integration/

A Practical Guide to fzf: Shell Integration

   This article is part of a series about fzf:

   Becoming a fzf master
    1. [https://thevaluable.dev/practical-guide-fzf-example/]A Practical Guide to fzf: Building a File Explorer
    2. [https://thevaluable.dev/fzf-shell-integration/]A Practical Guide to fzf: Shell Integration
    3. [https://thevaluable.dev/fzf-vim-integration/]A Practical Guide to fzf: Vim Integration
    4. [https://thevaluable.dev/fzf-git-integration/]A Practical Guide to fzf: Building a Git Explorer

   In the (1)previous article of this series, Davina (your colleague developer) explained how powerful
   fzf can be to create our own fuzzy search and, to an extent, our own TUIs.

   Good news everyone: Davina is back! This time, her mission is to explain how to integrate fzf with
   the shell. This integration adds many new functionalities to your favorite shell, making it even more
   powerful.

   You can use fzf's shell integration if you use either Bash, Zsh, or Fish. I'm not the biggest fan
   of Fish (it's not POSIX compatible), so I will focus mostly on Bash and Zsh in this article.

   More specifically, we'll see:
     * What keystrokes we can use to fuzzy search through files and directories.
     * How to use a completion using fzf in the shell.
     * How to customize keybindings and completions.
     * How to launch fzf in tmux panes automatically.

   I encourage you to try out the different configurations described in this article. To follow along,
   you can download the companion project and run the different commands from there. Most of the
   screenshots are executed from this guide-fzf directory.

   Keybinding and completion are possible thnaks to a couple of files which need to be sourced in your
   shell. I'm using Arch Linux (by the way), so for me these files are located in the directory
   /usr/share/fzf/. You can also find them in the official repository of fzf. The files with the
   extension .bash need to be sourced if you use Bash; the same for Zsh.

   Here's how I source them in my zshrc:
source /usr/share/fzf/key-bindings.zsh
source /usr/share/fzf/completion.zsh

   Depending on what OS you're running and how you've installed fzf on your machine, these files might
   be in a different place. You can also copy them manually somewhere in your system and source them,
   too.

   Let's now dive in these files to see what secrets they hold!

Keybinding with fzf
   Let's begin by the keybindings: what keystrokes can we hit in our shells to invoke the power of fzf?

Keystrokes Available
   If you open the file "key-bindings.bash", you'll see the different binding declared at the end of the
   file, using the commands bind.

   Here's the list of all keystrokes available:
   Keystroke Description
   * CTRL-t Fuzzy find all files and subdirectories of the working directory, and output the selection to
     STDOUT.
   * ALT-c Fuzzy find all subdirectories of the working directory, and run the command "cd" with the output as
     argument.
   * CTRL-r Fuzzy find through your shell history, and output the selection to STDOUT.

   My life would be grimmer without CTRL-r. I'm searching in my shell history all the time, to run
   similar commands I ran in the past. Here's how it looks in my shell:
   Using fzf in the shell to search the history

   The keystroke CTRL-t is also very useful if you want to quickly edit a file. I just have to type vim
   in my terminal followed by CTRL-t to search the file I want to edit.
   Using fzf in the shell to search the files and directories

   Finally, ALT-c is useful if you want to search for and move into a subdirectory.
   Using fzf in the shell to search the files

   This is great, but what I'd like to do now is to configure all of these keystrokes according to my
   own specific needs.

Customizing fzf Keybindings
   If you look a bit closer at the completion file, you'll find three functions called by our three
   keystrokes:

   ------------------------------------------------
   Keystroke   Bash function     Zsh function
   ------------------------------------------------
   CTRL-t      __fzf_select__    __fsel
   CTRL-r      __fzf_history__   fzf-history-widget
   ALT-c       __fzf_cd__        fzf-cd-widget
   ------------------------------------------------

   The body of these functions will give you the commands executed each time you hit one of the
   keystrokes. For example, here's the command running when you hit CTRL-t:
cmd="${FZF_CTRL_T_COMMAND:-"command find -L . -mindepth 1 \\( -path '*/\\.*' \
-o -fstype 'sysfs' \
-o -fstype 'devfs' \
-o -fstype 'devtmpfs' \
-o -fstype 'proc' \\) -prune \
-o -type f -print \
-o -type d -print \
-o -type l -print 2> /dev/null | cut -b3-"}"

   Here, the command find is used with many different expressions to filter the result of the search. If
   you want to know more about find, I've written an article about it here.

   We can also see that the command itself can be overwritten with the value of the environment variable
   FZF_CTRL_T_COMMAND. There are more environment variables available to overwrite commands; you can
   find them at the beginning of the completion file. Here's the list:

   ---------------------------------
   Environment variable    Keystroke
   ---------------------------------
   FZF_CTRL_T_COMMAND      CTRL-t
   FZF_ALT_C_COMMAND       ALT-c
   ---------------------------------

   We can't change the default command for CTRL-r, to search through the shell history. It's because
   there are some scripts involved here; an AWK script for Zsh, a Perl script for Bash.

   Looking at the beginning of the "keystroke" file, you'll see other environment variables allowing us
   to set fzf's default options depending on the keystroke we use:

   ---------------------------------
   Environment variables   Keystroke
   ---------------------------------
   FZF_CTRL_T_OPTS         CTRL-t
   FZF_CTRL_R_OPTS         CTRL-r
   FZF_ALT_C_OPTS          ALT-c
   ---------------------------------

   Here's an example:
export FZF_CTRL_T_OPTS="--height 60% \
--border sharp \
--layout reverse \
--prompt '∷ ' \
--pointer ▶ \
--marker -->"

   If you run the above in your shell, these options will be given to fzf each time you hit CTRL-t.

   What about changing the keystrokes themselves? If you look at the end of the file
   "key-bindings.bash", you'll see their definitions. For example:
bind -m emacs-standard '"\ec": " \C-b\C-k \C-u`__fzf_cd__`\e\C-e\er\C-m\C-y\C-h\e \C-y\ey\C-x\C-x\C-d"'
bind -m vi-command '"\ec": "\C-z\ec\C-z"'
bind -m vi-insert '"\ec": "\C-z\ec\C-z"'

   The keystroke itself is \ec here, meaning ALT-c. Let's say that we don't like to use ALT-c, but
   instead we'd like to use CTRL-e. First, we need to find in the file key-bindings.bash the good
   keystroke:
bind -m emacs-standard '"\ec": " \C-b\C-k \C-u`__fzf_cd__`\e\C-e\er\C-m\C-y\C-h\e \C-y\ey\C-x\C-x\C-d"'

   Next, we need to add the following to our bashrc:
bind -m emacs-standard '"\C-e": " \C-b\C-k \C-u`__fzf_cd__`\e\C-e\er\C-m\C-y\C-h\e \C-y\ey\C-x\C-x\C-d"'

   Here, we create a new keystroke using CTRL-e (represented by \C-e), which will do the same as ALT-c.

   For Zsh, if you look into the file "key-bindings.zsh", you'll see the different keybindings set in
   the different functions themselves. The idea stays the same; first, we need to find the different
   keystrokes we want to change:
zle     -N             fzf-cd-widget
bindkey -M emacs '\ec' fzf-cd-widget
bindkey -M vicmd '\ec' fzf-cd-widget
bindkey -M viins '\ec' fzf-cd-widget

   Then, we can add the following to our zshrc:
zle     -N            fzf-cd-widget
bindkey -M emacs '\C-e' fzf-cd-widget
bindkey -M vicmd '\C-e' fzf-cd-widget
bindkey -M viins '\C-e' fzf-cd-widget

   It's also possible to unbind ALT-c if you want to. I've already written an article about Zsh and
   keybindings if you want to know more about that. For now, here's how to unbind the default keystroke
   ALT-c:
bindkey -rM emacs '\ec'
bindkey -rM vicmd '\ec'
bindkey -rM viins '\ec'

Completion Using fzf
   Having some keystrokes to fire fzf and search through your files, directories, or history is really
   useful, but it's only half the functionalities fzf gives us to make the shell even more powerful. The
   other half is about completion.

Command and Trigger
   Let's type the following in our shell, followed by the TAB key:
vim **

   We can trigger fzf's completion with two stars followed by hitting tab

   You can then select the files and directories you want (multi-selection is enabled here), and Vim
   will open them all.

   There are two important elements in the command above: vim (the command itself), and **, which fzf
   recognizes as a trigger for completion. Said differently, if you don't write **, hitting TAB won't
   trigger fzf.

   The completion will be different depending on the command. For example, we just saw that triggering
   the completion with Vim will give you files and directories (the default behavior for most commands).
   But if you try to complete "cd" for example, you'll get only directories:
cd **

   Here's the result:
   The completion for cd will only display directories

   Whatever is put before the trigger will be used as query for fzf. For example:
cd mouseless-book-behind-scene**

   The result:
   It's possible to add a query before the completion trigger

   You'll notice that you can't have multiple selections here; after all, "cd" needs only one argument.

   When you think about it, most commands get some paths (files or directories) as arguments; as a
   result, fzf's give you paths by default for the completion. As we just saw, other commands will only
   give you directories. Here's the complete list of these commands:
     * cd
     * pushd
     * rmdir

   If you look in the file "completion.bash", you can search for the two variables a_cmds and d_cmds.
   The first is used for completing paths, the second to only complete directories. For Zsh it's the
   same, except that everything which is not part of the value of the variable d_cmds will be completed
   with paths.

   Of course, there are commands expecting other arguments than file or directory paths. Some of them
   are supported out of the box; here's the complete list:

   ------------------------------------------------------------------------------------------------
   Command    Completion
   ------------------------------------------------------------------------------------------------
   export     Environment variables
   unset      Environment variables
   unalias    Aliases (use the command alias under the hood).
   ssh        Hosts (grep entries from ~/.ssh/config, ~/.ssh/config.d/* , and /etc/ssh/ssh_config).
   telnet     Hosts (grep entries from /etc/hosts).
   kill       Processes (use the command ps -ef under the hood).
   ------------------------------------------------------------------------------------------------

   Looking at the completion files, how do we know what command triggers what completion? The name of
   the functions can help here; for example, _fzf_complete_export will trigger the completion after the
   command export, at least for Zsh. For Bash, the functions are called differently, referencing what
   they complete instead of what command they complete; for example _fzf_var_completion() complete
   environment variables.

Customizing the Completion
   If you look at one of the completion files, you'll see again at the very top of the file all the
   environment variables you can use to customize the completion.
# - $FZF_TMUX               (default: 0)
# - $FZF_TMUX_OPTS          (default: '-d 40%')
# - $FZF_COMPLETION_TRIGGER (default: '**')
# - $FZF_COMPLETION_OPTS    (default: empty)

   There's one environment variable missing, however: $FZF_COMPLETION_DIR_COMMANDS. It allows us to
   specify the commands which should only be completed with directories. For example:
export FZF_COMPLETION_DIR_COMMANDS="cd pushd rmdir tree"

   Here, I've added back the three commands which should have directory paths as completion (cd, pushd,
   and rmdir), and I've added tree. Next, if we try to complete tree **, we'll get the following:
   We can assign new commands to fzf directory-only completion

   Here are the two other interesting environment variables referenced at the beginning of the file
   (let's forget about the tmux related ones for now):
$FZF_COMPLETION_TRIGGER (default: '**')
$FZF_COMPLETION_OPTS    (default: empty)

   It's self-explanatory enough: the first one allow us to change the completion trigger, and the second
   one can let us add some options to fzf each time we trigger the completion.

   What about changing the different commands used for the completion themselves? You can create two
   functions to do so:
     * _fzf_compgen_path
     * _fzf_compgen_dir

   Here are the default commands:
_fzf_compgen_path() {
	find -L "$1" \
		-name .git -prune -o -name .hg -prune -o -name .svn -prune -o \( -type d -o -type f -o -type l \) \
		-a -not -path "$1" -print 2> /dev/null | sed 's@^\./@@'
}

_fzf_compgen_dir() {
		find -L "$1" \
		-name .git -prune -o -name .hg -prune -o -name .svn -prune -o -type d \
		-a -not -path "$1" -print 2> /dev/null | sed 's@^\./@@'
}

   Instead of using find, we could use ripgrep or fd for example:
_fzf_compgen_path() {
	rg --files --glob "!.git" . "$1"
}

_fzf_compgen_dir() {
	fd --type d --hidden --follow --exclude ".git" . "$1"
}

   We change here the default completion "path" to only complete files, and not files and directories.

Managing your Own Completion
   The first way to create our own custom completion is to simply create a new function named
   _fzf_complete_<cmd_name>. For example, to create a completion for the "git" command:

_fzf_complete_git() {
	_fzf_complete -- "$@" < <(
		echo log
		echo diff
	)
}

   With this, you can run git **, and you'll have the choice between log or diff for the completion.
   That's a naive approach however, because you need to add here all the completions possible. Here's a
   more useful function:

_fzf_complete_git() {
	_fzf_complete -- "$@" < <(
		git --help -a | grep -E '^\s+' | awk '{print $1}'
	)
}

   This will allow you to complete all git subcommands using fzf!

   There is another interesting function allowing us to give any command for completing any CLI out
   there: the "comprun" function. For example, if we want to run a specific command to complete the CLI
   "tree", we can run the following:

_fzf_comprun() {
	local command=$1
	shift

	case "$command" in
		tree)  find . -type d | fzf --preview 'tree -C {}' "$@";;
		*)     fzf "$@" ;;
	esac
}

   Then, if you try to complete tree **, it will run the corresponding commands (the find . -type d
   command). The $@ at the end pass all the arguments given to fzf. The result:
   We can customize fzf's completion with the comprun function

fzf and tmux
   If you're using tmux already, you can force fzf to open in a new pane of your tmux session. To do
   so, you need to use a script wrapping fzf, called fzt-tmux. Of course, you already need to be in a
   tmux session for the following to work:
fzf-tmux --height 50%

   fzf can run in a tmux pane

   Do you remember the environment variables at the beginning of the completion files? Two of them are
   directly about tmux:
   ---------------------------------------------------------------------------------------------------
   Environment variable   Description                                               Default when empty
   ---------------------------------------------------------------------------------------------------
   FZF_TMUX               If set to 1, fzf's will open in a new tmux pane when      0
                          using a keystroke or the completion.
   ---------------------------------------------------------------------------------------------------
   FZF_TMUX_OPTS          Gives default options to fzf; automatically use a         -d 40%
                          new pane for keystrokes or the completion if the
                          value of the variable is not empty.
   ---------------------------------------------------------------------------------------------------

   Said differently, if you already give a value to FZF_TMUX_OPTS, there is no need to set FZF_TMUX to
   1; keybindings and completion will always open in a new tmux pane in that case.

   There's even a short man page you can read: man fzf-tmux. The most noticeable option is -p, to open
   fzf in a tmux floating pane. You can try it by yourself easily:
fzf-tmux -p

   fzf can run in a floating tmux pane

   How fancy!

More Power to the Shell
   You can now configure and customize fzf following your craziest wishes. You can adapt it to match
   your workflow in the holy shell!

   What did we see in this article?
     * We can use multiple keystrokes in our shell to launch fzf: CTRL-t, CTRL-r, and ALT-c. We can
       customize the options given to fzf, as well as the commands used to populate fzf's list.
     * We can also complete some shell commands using fzf, by default triggered with ** (followed by
       TAB). Really handy to find files or directory quickly, or anything else you want!
     * We have different ways to create our own completion: using the "comprun" function, or by defining
       our own custom functions.
     * We can also open fzf inside a tmux pane automatically (even a floating one), when using
       keybindings or completion, using the wrapper script fzf-tmux.

   The shell is already a powerful environment, and fzf makes it even more useful. It has been a huge
   game changer for my own workflow throughout the years.


---
https://carlosneto.dev/blog/2024/2024-04-21-zsh/

fzf: Life is Too Short for Pipe Grep
2024/04/28

   This blog post outlines the advantages of the fzf (Fuzzy Finder CLI) and explains how to
   configure its Zsh widgets.

Searching in the Terminal - Tedious Task
   Searching for items in the terminal is a trivial activity, but can be a boring and tedious task. I
   will list three cases to exemplify it: searching command history; files and directories; and command
   output.

   Usually, users press the arrow up/down to recall last commands executed. The most used shells
   implemented an interactive search tool called by CTRL + R shortcut. In Zsh, it is implemented as
   reverse-i-search, which works well, but you need to press the shortcut again to see the next results.
   This behavior can be a problem if you need to recall commands executed multiple times with different
   arguments.

   When it is necessary to find some file or directory, the most common method adopted is to use $ find.
   It works well when you know exactly the item that you need to find, but not so good when you only
   know some partials of the path.

   Lastly, I can mention searching elements in command outputs. The most adopted method for this case is
   to use matching expressions within a command output using $ command | grep. When the same problem of
   finding files and directories previously described is true for this. Depending on the case, it is
   necessary to execute grep multiple times until you find the elements that you need.

   This tedious task prompted me to research better alternatives for interactive searching.

Fuzzy Finders - The Solution
   After a few days of research, I found an amazing project that solves my problems: fzf -
   command-line fuzzy finder. It is a cross-platform Fuzzy Finder command-line written in Go. But, what
   is Fuzzy Finder?

   Fuzzy Finder is a search tool category for providing a quickly and flexibly way to find files,
   directories, or other elements, even when they don't remember the precise names. It employs fuzzy
   matching to find results based on partial words, erratic characters, or typographical errors.

   fzf filters the list of items as you type. This makes your searching much more efficient,
   avoiding $ command | grep execution. It can receive output of the other commands for interative
   searching, for instance you can execute $ kgp -A | fzf to find pods in a Kubernetes cluster. In
   addition, it has some predefined shells widgets to search files, directories, and search history
   commands.

   The next section will explain how to configure these widgets in Zsh.

   There are widgets available for Fish, Bash, Zsh. You can check the available implementations in
   [https://github.com/junegunn/fzf/tree/master/shell]github.com/junegunn/fzf/shell

How to Configure fzf Widgets in Zsh
   The first step is to install fzf. There are some distinct ways to install it described in fzf -
   installation section. Depending on the package manager on your workstation, the version available can
   be older. Thus, I will download and install the latest version available in GitHub Releases section.
setopt INTERACTIVE_COMMENTS

# download the latest version (in a moment of the blog publish date, the latest version is 0.50.0)
$> curl -L https://github.com/junegunn/fzf/releases/latest/download/fzf-0.50.0-linux_amd64.tar.gz > \
fzf-0.50.0-linux_amd64.tar.gz

# uncompress the donwloaded file to access the fzf binary
$> tar -xzvf fzf-0.50.0-linux_amd64.tar.gz

# check fzf binary execution
$> ./fzf --help

# move the binary to a folder present in your path
$> mv fzf /usr/local/bin/

   The fzf use the command $ find behind the scenes as engine to search directories and files. You can
   change it. In this example, I will install and configure the fd-find, a fast and user-friendly
   alternative to $ find.
# In Linux workstation with dnf package manager
$> dnf install fd-find

# In MacOs workstation with homebrew package manager
$> brew install fd

   For file content preview, I will install and configure bat, a $ cat clone with syntax
   highlighting.
# In Linux workstation with dnf package manager
$> dnf install bat

# In MacOs workstation with homebrew package manager
$> brew install bat

   For directory and sub directories preview, I will install and configure tree, a utility which
   recursively displays the contents of directories in a tree-like format.
# In Linux workstation with dnf package manager
$> dnf install tree

# In MacOs workstation with homebrew package manager
$> brew install tree

   Now, it is necessary load the Shell widgets. For this, you can get the widget setup source-code given
   the shell name as argument (--zsh, --fish, --bash). In this case, I will setup the widgets for Zsh.
# Set up fzf key bindings and fuzzy completion (only available in 0.48.0 or later)
$> eval "$(fzf --zsh)"

   Run the following command to check the keybindings are correctly loaded.
$> bindkey -a | grep fzf

# output expected:
#
# "^R" fzf-history-widget  # CTRL + R: reverse history search
# "^T" fzf-file-widget     # CTRL + T: search files
# "^[c" fzf-cd-widget      # ALT  + C: search directories

   You can customize the widgets fzf parameters through environment variables described in fzf -
   environment variables. Each widget has its own environments variables you can customize based on your
   needs. Take a look at following code block for an example of the how to parametrize fzf widgets.
# fzf parameters used in all widgets - configure layout and wrapped the preview results (useful in large
   command rendering)
export FZF_DEFAULT_OPTS="--height 100% --layout reverse --preview-window=wrap"

# CTRL + R: put the selected history command in the preview window - "{}" will be replaced by item selected in
 fzf execution runtime
export FZF_CTRL_R_OPTS="--preview 'echo {}'"

# ALT + C: set "fd-find" as directory search engine instead of "find" and exclude "venv|virtualenv|.git" of
the results during searching
export FZF_ALT_C_COMMAND="fd --type directory --exclude venv --exclude virtualenv --exclude .git"

# ALT + C: put the tree command output based on item selected
export FZF_ALT_C_OPTS="--preview 'tree -C {}'"

# CTRL + T: set "fd-find" as search engine instead of "find" and exclude "venv|virtualenv|.git" for the
results
export FZF_CTRL_T_COMMAND="fd --exclude venv --exclude virtualenv --exclude .git"

# CTRL + T: put the file content if item select is a file, or put tree command output if item selected is
directory
export FZF_CTRL_T_OPTS="--preview '[ -d {} ] && tree -C {} || bat --color=always --style=numbers {}'"

   The next section will present widgets executions preview.

   You can check my ~/.zshrc file content in the following link. It contains my personal fzf
   parametrization: c-neto/ansible-configure-fedora

Results
     * fzf-history-widget executed by CTRL + R.

   fzf-history-widget execution print
     * fzf-cd-widget executed by ALT + C.

   fzf-cd-widget execution print
     * fzf-file-widget executed by CTRL + T.

   fzf-file-widget execution print
     * Searching pods in Kubernetes Cluster with $ kgp -A | fzf execution.

   find pods with fzf print

Conclusion (Author Opinion)
   My research for improvements in searching history commands has yielded results that exceed my
   expectations. fzf opened my mind to understand what is Fuzzy Finder and it purpose. It not limited to
   be command history searching only, it is a tool that you can search anything. It is really nice!

   Certainly, I think it is a much better alternative to command history search widget default in Zsh,
   Bash, and Fish (which already has a good history search widget).

   The interactive searching are blazingly fast and customization expanding the possibilities based on
   your needs. The productivity which fzf provides is really awesome! In a fact, that its justifies more
   than 59K stars in your GitHub repo.


---

