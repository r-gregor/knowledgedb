filename: vim-working-with-buffers-multif-5ppp-20260210.txt
https://builtin.com/articles/working-with-buffers-in-vim

Working With Buffers in Vim: A Guide
Dec. 09, 2024

   When I formally switched to Vim full time after using Atom, IntelliJ and VS Code, I started a
   quest to find the best Vim editing workflow. After months of using Vim, I was drawn to the buffer
   workflow. A buffer is a temporary space in the memory to store your opened files. It's a unique
   abstraction not found in other editors or IDEs.

6 Vim Buffers Workflow Commands to Know
    1. set hidden: Remove the vim save prompt that raises every time you change files.
    2. :bnext, :bprev: navigate to the next and previous buffer on the list.
    3. :bfirst, :blast: navigate to the first and last buffer on the list.
    4. ]b, [b: These shortened navigation commands come from the unimpaired.vim plugin, replacing :bnext
       and :bprev, respectively.
    5. ]B, [B: These shortened navigation commands come from the unimpaired.vim plugin, replacing :blast
       and :bfirst respectively.
    6. :bufdo: Run an operation across all buffer files.

   Each time you open a file, Vim stores it in a buffer. If you open five files, you have five buffers.
   A buffer remains opened even if that file is not visible, in other words, the buffer is hidden.
   Buffers won't go away until you either quit Vim or explicitly command it to close, like :bdelete.

   In this article, I will share how that workflow works.

What Is Vim Buffers?
   When I first learned about buffers, it was hard for me to visualize it. After all, I had never used
   buffer in editing before. The editors and IDEs that I've used all have tabs and windows, but not
   buffers. A good analogy is to think of the Vim buffer list as a stack of playing cards. Each card
   represents the files you have opened so far. All the cards are stacked face-up, but because they are
   stacked, only the top-most card is visible. The top card is the file that you are currently seeing,
   file1.txt.

   In this analogy, we're only dealing with one tab and window, no split windows either. There are N
   numbers of cards in the stack just as there are N opened files. If you opened 10 files, then you have
   10 buffers and 10 cards in the stack. If you need to view the next card, file2.txt card, you swap the
   topmost card with the second card from the top. Now, your second card from the top is visible sitting
   on the top of the stack. Your previous card, the file1.txt card, is now the second-from-the-top, no
   longer displayed. If you need to view the next card, file3.txt, you just need to find that card from
   the deck and put it on the top of the stack after tucking the file2.txt card back into the stack.
   That's what it means to switch buffers.

Working With Buffers in Vim: A Guide
   First, you need to have this in your vimrc:
set hidden

   Without the set hidden, each time you switch to a different buffer without saving the current
   changes, Vim stops you and asks you to either discard your changes or save them. Common courtesy, I
   guess. Although it's a nice feature to be prompted to save your file before leaving it, not being
   able to quickly switch buffers is the antithesis of the buffer workflow. Plus, your files aren't
   really closed when you switch to a different buffer, they are just hidden.

   Generally, you shouldn't worry about losing your changes when switching to different buffers. Even
   when you exit Vim (:qall) and forget to save your changes, Vim will still remind you to save your
   changes, just don't run :qall!. But in general, I almost never force quit Vim. Your muscle memory
   should save changes (:w) all the time. Since the positives, i.e., quick buffer switch, outweighs the
   cons, losing unsaved files, I suggest having the set hidden in your vimrc.

How to Switch Buffers
   There are two major ways you can switch buffers quickly. We'll examine the quickest buffer-switching
   method here, flying. But first, to display all buffers, you can use one of the two commands below:
:ls

   Or:
:buffers

   To switch to a buffer, you can run:
:buffer n

   Where n is the buffer number.

   I find it challenging to try and remember all the buffer numbers. The :buffers command makes a nice
   combo with the :buffer n command. Try running these two sequentially:
:buffers
:buffer n

   You can also pass to the buffer command the buffer file name, too.
:buffers
:buffer file1.rb

   With this, you can jump to any buffer files quickly and consistently. This command sequence is a
   bread-and-butter to my daily editing workflow.

   You can create a key map for this operation. In your vimrc:
nnoremap <Leader>b :buffers<CR>:buffer<Space>

   When you press <Leader>b, Vim displays all buffer information, including their buffer numbers and
   filenames, and you can select which buffer to jump into.

   One of my favorite Vim plugins, fzf.vim, has a buffer command :Buffers that uses fzf and Vim's
   popup window to fuzzy search your buffer list. I personally use this over the :buffers command
   because I find the pop-up window easier to see.

   In my vimrc, I map the :Buffers command to Ctrl-b:
nnoremap <silent> <C-b> :Buffers<CR>

   If you are a purist, stick with :buffers. If you are a fan of fzf, use :Buffers. Principally, they do
   the same thing: displaying a list of buffers and quickly jumping to a buffer. I am pretty sure that
   there are alternatives out there to switch buffers that I am not aware of. Don't take my word, shop
   around.

   This is the crux of the buffer workflow:
     * You open N files. These are the files relevant to your current task.
     * With these files opened, you can jump to any of them thanks to the buffer operation. I call this
       flying because you can reach any of these files quickly with the same number of keystrokes.

   Let's say that you have nine opened files in the buffers: file1.rb, file2.rb, ... file9.rb. You can
   reach any file with the same number of keystrokes. If you have the <Leader>b keymap, you can reach
   any of the nine files with four keystrokes: <Leader> + b + (buffer number) + Return. A constant
   number of keystrokes for an indefinite number of opened files? It's a win!

   Prior to the buffer workflow, I used to do a codebase-wide search to switch files. For example, if I
   need to go to the get_pdf method, I would go to my editor's fuzzy search text box and type
   g-e-t-p-d-f in-file search. That's a lot of typing. Moreover, what if the method name is long? I'd
   have to type nearly a dozen letters before getting there. No thanks. With buffer workflow, once
   you've found all your files, you only need to type a constant number of keystrokes to go to any file.

   You may argue that you can just open all the relevant files in split windows or store them in your
   editor's tabs, if your editor supports multiple tabs. Some editors also have a "recently opened
   files" section. Having multiple split windows will quickly crowd your screen real estate. Having
   multiple tabs sounds like an acceptable strategy, until you realize that if you have multiple tabs,
   it would take a long time to go to your target tab. You'd need to pause, browse through the list of
   tabs you have opened for that one file you want to open.

   With Vim buffers, all your files are reachable, searchable, and you get the whole screen in front of
   you so you can focus on the most important task: coding.

Buffer Commands to Know
   In addition to the :buffers and :buffer commands, here are more useful buffer commands:
:bnext
:bprev
:bfirst
:blast

   :bnext and :bprev navigate to the next and previous buffer on the list, while :bfirst and :blast
   navigate to the first and last buffer on the list.

   Another one of my favorite Vim plugins, [https://github.com/tpope/vim-unimpaired]unimpaired.vim offers
   intuitive shortcuts to traverse different file collections, like buffers.

   With it, I can traverse the buffer list with ]b (:bnext), [b (:bprev), ]B (:blast), and [B (:bfirst).
   This allows me to traverse my buffer list very quickly. I call it sprinting because I can type ]b ]b
   ]b ]b rapidly and go across my buffer list at an olympian speed.

Vim Buffer Workflow Example
   So what does a typical buffer workflow look like?

   By the time I open Vim, I usually already know what task I need to do. Let's say that I need to fix a
   particular UI bug. By then, I have a gut feeling for what or where the relevant method is. I would
   then search with either :grep, :find, :vimgrep or plugins like fzf.vim. Suppose my starting line is
   ui.js. From there, I follow the logic. Eventually, I have ui.jsx, uis_controller.rb and
   uis_controller_spec.rb opened in my buffer list.

   My buffers now contain four files: ui.js, ui.jsx, uis_controller.rb and uis_controller_spec.rb.

   From here, I can easily travel to any of these four files using a combination of flying (:Buffers +
   select one) and sprinting ([b ]b [B ]B).

   Whenever I add a new file to my workflow task, that file is automatically added to the buffer list.
   Remember, Vim automatically adds an opened file into the buffer list, so I can immediately fly or
   sprint to it.

   Why walk when you can sprint and fly?

Bufdo
   As an added bonus, you can also run an operation across all buffers with :bufdo. You can pass an
   operation and apply it to all the buffer files.

   If you want to substitute all "pancake" with "waffle" across all buffers, run:
:bufdo %s/pancake/waffle/g | update

   s/pancake/waffle is the substitute command that replaces pancakes with waffles. Update saves each
   buffer file after substitution.

Vim Buffers vs. Argument List Explained
   An alternative to the buffer workflow is the argument list (args/arglist/argslist) workflow. Before I
   go over what an args list is, I'm going to explain why you might want to also learn how to use :args.

Disadvantages of the Vim Buffers Workflow
   After years of using the buffers workflow, I started noticing a friction. Over time, my buffer list
   would grow into an uncontrollably large list of files.

   This usually happens when working on a complex task in which the file set that I need to work with is
   not clear. I've seen my buffer list grow to 50 files. It's entirely plausible to have more than 100
   files in the buffer list.

   When you have that many files, it's not a sprint anymore. It's now a marathon. If you have that many
   files in your buffers list, many of them are probably irrelevant files.

   There are a few things you can do. First, you can make a mental note of all the relevant files in
   your buffer list, then reopen Vim and open only the relevant files. However, I don't have a good
   short-term memory, so this isn't ideal. Second, you can create a different, new set of files that you
   can still sprint across, yet distinct from buffers: the arglist files.

   An arglist is a controlled file set. It's a subset of the buffer list. Whereas Vim automatically adds
   all opened files into the buffer list, it doesn't automatically add them into the arglist. You decide
   when and which file goes into the list.

   Buffers are still awesome.

   It's only when I am working with complex tasks that cause my buffer list to grow exponentially that I
   resort to the arglist workflow. When I know exactly which files I need to work with or if the size of
   my buffer list is manageable, the buffer workflow is always my immediate go-to partner.

Vim Arglist Explained
   In the terminal, when you pass to the Vim command file(s) as arguments, like:
vim file1.rb file2.rb file3.rb

   Vim opens them and stores them not only in the buffer list, but also the arglist. Recall that you can
   check all the buffer files with the :buffers command (or :ls). To check all the args files, you can
   run:
:args

   On the bottom screen, Vim displays:
[file1.rb] file2.rb file3.rb

   The enclosed file in a square bracket, [file1.rb], is the current args file.

Adding New Files to Args
   If you open a new file file4.rb, your buffer list now has four items (file1 to file4). However, Vim
   doesn't add it into the arglist automatically.You have to do it manually.

   To add file4.rb into the arglist, use the :arga command:
:arga file4.rb

   Running :args one more time reveals that the arglist now contains four files: file1.rb file2.rb
   file3.rb file4.rb.

   If you need to remove or delete a file from the arglist, you can run the :argd command:
:argd file4.rb

   To create a new arglist, you can run the :args command again, but this time you pass it file(s)
   arguments:
:args file1.js file2.js

   The arglist now contains file1.js and file2.js instead of file1.rb, file2.rb and file3.rb. Running
   :args YOUR_FILES will overwrite your existing arglist. You have been warned!

   If you run :args without arguments, it displays the arglist. If you run :args some_files, it starts a
   new args list with some_files.

Globs
   The :args command accepts globs so you can quickly build up your args files. To recursively add
   all files ending with controller.rb:
:args **/*controller.rb

Args and the CLI Commands
   You can combine most terminal search commands to populate the arglist, don't forget the
   back-tick. For example, to integrate the classic find command with arglist:
:args `find . -name '*txt'`

   Check out your arglist again (:args). Now, it has all the text files.

No-Fly Zone
   With the buffer workflow, you can easily fly between the buffer files. Unfortunately with args, there
   is no way to fly between the args list.

   Unlike the :buffers command that presents you a list of buffer files for you to fly into with :buffer
   BUFFER_NUMBER or :buffer FILE_NAME, there is no equivalent command with args.

   Maybe in the future someone will make it possible to fly with args. But for now, we have to be
   content with sprinting.

Sprinting
   Similar to buffer's :bnext, :bprev, :bfirst and :blast commands, args have:
:next
:prev
:first
:last

   The vim.unimpaired plugin also has useful commands: [a ]a [A ]A.

Multi-File Arguments
   With :argdo, you can execute an operation across the arglist, similar to :bufdo.

   If you want to substitute all method_a with method_b across your args files, run:
:argdo %s/method_a/method/b/g | update

When to Use Vim Buffer vs. Args
   Buffer list and arglist have their own use cases. Neither is superior to the other. When do you use a
   buffer list, and when do you use an arglist?

   My rule of thumb is, whenever you start feeling the friction from having too many buffer files, it's
   a good indicator to use args. Some people can tolerate having a lot of buffer files while some can't
   even handle 10 buffer files. Whenever my buffer files ballooned to more than 10, smoke would start
   coming out of my ears. This would be a good time to use arglist. Otherwise, I would stick with
   buffers.

   You can always purge your buffer list whenever it gets too large. In fact, I have two custom commands in my
   vimrc: One to delete all buffers, and one to delete specific buffer files. You can find them here in my
   [https://github.com/iggredible/dotfiles/blob/master/vim/custom-functions/remove-buffers.vim]dotfiles.

   It is common to go into the detective mode, inspecting and opening a large number of files. You can
   quickly accumulate a large number of buffer files. The more files you open, the harder it is to clean
   up your buffer list. The argument list starts a fresh list of files, distinct from the buffer list.
   Once you know which files are relevant, just run :arga % to add the current file or :arga
   name/of/file to add to the argument list.

   The buffer and args workflows are unique to Vim. If you aren't already familiar with them, get
   acquainted with them. They may pragmatically change your editing workflow forever.

   Even if you are not a Vim user, I think it is worth learning this, and who knows, maybe after reading
   about buffers and args, you may implement something similar in your favorite non-Vim editor or IDE.

Frequently Asked Questions

How do buffers work in Vim?
   A buffer in Vim is a temporary space in the memory to store your opened files. Each time you open a
   file, Vim stores it in a buffer, stacking each file like a deck of cards, making it easier to
   navigate between files.

What's the difference between Vim buffers and arglist?
     * Vim Buffers: Buffers opens a temporary space in the memory to store opened files, stacking them
       like a deck of cards. It's a useful workflow to swap between files when working on a project. But
       when the file size reaches 10 or more, it can become difficult to navigate, making arglist a more
       useful tool.
     * Arglist: An arglist is a controlled file set that's a subset of the buffer list. You decide when
       and which file goes into the list, which makes it a useful tool to use when working on a project
       with 10 or more files.


---
https://linuxhandbook.com/vim-buffers/

Complete Guide to Buffers in Vim
Aug 23, 2025

   Vim has been one of the most popular text editors that also influences extensions for other IDEs.

   If you are an advanced Vim user, you might be using a terminal multiplexer like tmux or
   screen.

   That could work but it's not the "Vim way" of doing things.

   So, how do you edit multiple files at once without closing one and opening another file? Well, let me
   introduce you to Vim buffers!

What is a buffer in Vim?
   Technically speaking, a buffer is anything that is loaded into the memory which is going to be used
   in the immediate future. The green progress bar in YouTube videos is an excellent example of a
   buffer. Now, talking about buffers in context with Vim, it means any file that you have opened in Vim
   that is stored in the memory for editing.

Creating new buffers
   Now that you know what a buffer is and how it is useful in Vim, let's go over how you can create new
   buffers in Vim i.e. open multiple files in Vim simultaneously.

edit command
   Vim has the :edit command that you can use for opening a file to edit, in an active Vim session. Or,
   you can use the :e command if you want to be really efficient in Vim.
:edit <filename>

   If a file with that name exists, it will be loaded in the active buffer, otherwise, a new file will
   be created.

   With that, you can begin editing the "current buffer" (opened file).
   opening multiple files in Vim's buffer using "edit" command

   As you can see, at first, I open the 'main.rs' file using the :e command and Vim immediately loaded
   that file in the active buffer. Next, I load 'node.rs' and it puts 'node.rs' in the active buffer,
   replacing 'main.rs'. Finally, I load the 'platform.rs' file in the active buffer which replaces the
   previous file which was in the active buffer.

   Doing this, I loaded three files in the active buffer using the :e command.

badd command
   That's not a typo for 'bad'. Vim has the :badd command. Read it like b-add or buffer-add and you'll
   understand its meaning.

   If you prefer using a shorter version of commands, you can use the :bad command.

   As the name suggests, it takes an argument that is a file name and adds it to the buffer.
:badd <filename>

   The difference between :edit and :badd command is that when you use :edit, the specified file will be
   loaded in the buffer, yes, but it will be in the active buffer. Meaning, that if you are editing a
   file and use :edit command, the file you specify will be displayed in the current window.

   Whereas, when you use :badd command, the file you specify will be loaded into the buffer, in the
   background.

   Let's look at an example.
   using the "badd" command in Vim

   As you can see from this gif, initially I have no file open, then I add 'main.rs' to the buffer using
   :badd command but 'main.rs' is not opened for editing right away. I also add 'utils.rs' to buffer and
   I am still on the empty file without any name.

Splitting windows
   As you might already know, Vim supports creating horizontal and vertical split panes. Naturally,
   this is so that you can have multiple files open for viewing and editing at once.

   There are several methods of creating splits in Vim.

   Use either :split and :vsplit commands and specify a file name to create a horizontal split and a
   vertical split respectively. Alternatively, you can use the :sp and :vs commands for short, for
   respective commands.
:split <filename>
:vsplit <filename>

Show open buffers
   Before you learn about switching between buffers, you must know which files are currently loaded in
   the buffer and how to view those open buffers.

   There are three commands that you can use for listing open buffers and they are listed below:
:ls
:files
:buffers

   listing Vim buffers using "ls", "buffers" and "files" commands

   When you list the buffers, it will give you a few details...

   At first, it will give you an index of each file open in the buffer, that way you can switch between
   buffers without typing out the whole filename.

   If the buffer is active, in the current window, it will show a % symbol before the file name.
   Additionally, if it is the active buffer, the a symbol will be shown before the file name.

   Some more information about a buffer is also shown by the following flags:
     * % : Buffer which is in the current window
     * # : Alternate buffer (the last file which was most recently edited in the current window)
     * a : Active buffer (the file which is being edited in the current window)
     * h : Hidden buffer (buffer with unsaved modifications but is not being displayed in any window)
     * u : Unlisted buffer (files that are not open in Vim but are present in the current working
       directory; use :ls! to view this)
     * - : Buffer with 'modifiable' set to off
     * = : A read-only buffer
     * + : A modified buffer (buffer with changes that are not written to disk)
     * x : A buffer that has read errors

   These buffer flags can be combined together to portray a specific meaning.
   image of a few files in the buffer using the "ls" command

   The most common example is %a, meaning that said buffer is "open" (being edited) in the current
   window.

   Let's look at another example. Here, I made a few edits to 'a.rs' file and hid it using :set hidden
   command. Then I switched to editing 'main.c' without writing out any modifications that I made to
   'a.rs'.

   And now the flags of 'a.rs' indicate exactly that with #h + flags.
     * # -> It was the last file to be edited in the current window (before I switched to editing
       'main.c')
     * h -> It is a hidden buffer
     * + -> It was modified but changes weren't saved to the disk

Extra
   With a few files in the buffer, you can open all of them for editing in each separate window using
   either of the following commands:
     * :ball -> Make n horizontal splits and open all files in windows (where n is the number of files
       in buffer)
     * :vertical ball -> Make n vertical splits and open all of them in windows (again, n is the number
       of files in buffer)

Deleting buffers
   When there are buffers open that are no longer necessary, it is best to get rid of them. Why keep a
   file open in the buffer if you don't intend to edit it any longer?

   To do exactly that, you can use the :bdelete command along with the buffer name (or its index) to
   remove it from the buffer. You can also use the :bd command if you are a bit lazy.
:bdelete <filename>

   As with everything in Vim, you can even delete multiple buffers at once by specifying a range. Below
   is a command if you want to delete buffers 1, 2, 3, and 4:
:1,4bd

Move between buffers
   Now that you know how to append files to the buffer, how to remove them from the buffer, and list
   files that are open in the buffer, let us have a look at how to switch from editing one file to
   another file without quitting Vim.

   There are several ways you can switch between buffers.

Switch to a specific buffer
   Most of the time, when editing multiple files, you switch back and forth between only a few select
   files instead of opening every file.

   When you need to switch from one file to another file, use the :buffer command, or :b for short.
:buffer <filename>

   When you know the buffer number, you can switch to the desired buffer just by mentioning its name
   using the following command:
:bufferN

   Here N is the buffer number.
   switching between open buffers using "buffer" command by index in Vim

Switch between buffers, consecutively
   Since each buffer has a unique number, and the number does not change, you can easily jump to the
   next or a previous buffer from the list of open buffers.

   When you want to switch to the next buffer, use the :bnext command. As with most Vim commands, a
   shorter command exists, which is :bn.
:bnext

   To switch to the previous buffer, you can use the :bprevious command. And the short-to-type command
   to switch to the previous buffer is :bp.
:bprevious

   switching back and forth between buffers using "bprevious" and "bnext" commands in Vim

Jump to the first and last buffer
   You can easily use the command :b1 to switch to the first buffer, but how do you switch to the last
   buffer without knowing its index?

   There are commands available in Vim to do exactly this!

   If you want to jump to the first buffer, use the :bfirst command, or :bf if you are as lazy as I am.
:bfirst

   And, to jump to the last buffer [without knowing its number], use the :blast command, or :bl command.
:blast

Hiding buffers
   When you try to switch between buffers when you have modified the active buffer, Vim will ask if you
   want to discard changes or save them, before switching to another buffer.

   That can be quite annoying. To disable that message (per buffer, per session), use the :set hidden
   command.
:set hidden

   hiding buffers in Vim to switch between buffer without saving or without discarding changes

   This will keep the changes "in memory". Changes that you made will not be discarded, nor will they be
   written to disk. They will be "saved in the buffer", to be handled later on.

   Now, Vim will not keep asking if you want to save the changes or not when you switch from a modified
   buffer to another buffer.

   If you want this to be automatically applied to every file, it is best that you add the following
   line to your 'vimrc' file:
set hidden

   This way, you won't have to run :set hidden command for every buffer each time you open Vim.

Conclusion
   This article goes in-depth with almost every operation you can use to manipulate buffers in Vim.


---
https://jitesh117.github.io/vim_stuff/buffers-windows-and-tabs-in-vim/

Mastering Vim Buffers, Tabs and Windows
September 17, 2024

Vim offers various ways to manage multiple files and organize your workspace.

Three of the most important concepts for this purpose are buffers, windows, and tabs. While they might seem
similar at first glance, they serve distinct purposes and operate differently. This comprehensive guide will
explain the differences and relationships between buffers, windows, and tabs in Vim, helping you understand
when and how to use each effectively to boost your productivity.

Understanding Buffers

What are buffers?
In Vim, a buffer is an in-memory representation of a file. When you open a file in Vim, it's loaded into a
buffer. Buffers are Vim's way of keeping track of all the files you're working on, even if they're not
visible on the screen.

Key characteristics of buffers
 1. File association: Each buffer is associated with a specific file.
 2. Persistence: Buffers persist throughout your Vim session unless explicitly closed.
 3. Invisibility: Buffers can exist without being visible on the screen.
 4. Efficiency: Vim can handle hundreds or even thousands of buffers simultaneously.

Working with Buffers
Here are some common commands for working with buffers:

  * :edit file.txt or :e file.txt: Open a file in a new buffer
  * :buffers or :ls: List all buffers
  * :buffer N or :bN: Switch to buffer number N
  * :bnext or :bn: Move to the next buffer
  * :bprevious or :bp: Move to the previous buffer
  * :bdelete or :bd: Delete (close) the current buffer

Example workflow:
:edit file1.txt
:edit file2.txt
:buffers
:buffer 1
:bnext

This sequence opens two files, lists the buffers, switches to the first buffer, and then moves to the next
buffer.

Understanding Windows

What are windows?
In Vim, a window is a viewport onto a buffer. Windows are used to view the contents of buffers. You can have
multiple windows open, each displaying a different part of the same buffer or different buffers altogether.

Key characteristics of windows
 1. Buffer display: Each window displays the contents of a single buffer at a time.
 2. Multiple Views: You can have multiple windows showing different parts of the same buffer.
 3. Layout flexibility: Windows can be split horizontally or vertically.
 4. Independent Cursor position: Each window maintains its own cursor position within the buffer it's
    displaying.
 5. Local Options: Some Vim options can be set locally to a window.

Working with windows
Here are some common commands for working with windows:
  * :split or :sp: Split the current window horizontally
  * :vsplit or :vs: Split the current window vertically
  * Ctrl-w s: Split the current window horizontally
  * Ctrl-w v: Split the current window vertically
  * Ctrl-w w: Cycle between windows
  * Ctrl-w h/j/k/l: Move to the window left/below/above/right
  * Ctrl-w c: Close the current window
  * Ctrl-w o: Make the current window the only one on the screen

Example workflow:
:edit file1.txt
:vsplit file2.txt
Ctrl-w w
:split file3.txt

This sequence opens file1.txt, creates a vertical split with file2.txt, moves to the new window, and then
creates a horizontal split with file3.txt.

Understanding Tabs

What are Tabs
Tabs in Vim are different from tabs in most other applications. A Vim tab is more like a layout or a
workspace. Each tab can contain one or more windows, and each window can display a different buffer.

Key characteristics of Tabs
 1. Workspace representation: Tabs represent workspaces or layouts, not individual files.
 2. Visibility: Tabs are always visible when you have more than one.
 3. Window containers: Each tab can contain multiple windows with different layouts.
 4. Buffer independence: The same buffer can be displayed in multiple tabs simultaneously.
 5. Task organization: Tabs are typically used to organize different tasks or projects.

Working with Tabs
Here are some common commands for working with tabs:
  * :tabnew: Open a new tab
  * :tabedit file.txt: Open a file in a new tab
  * gt: Move to the next tab
  * gT: Move to the previous tab
  * :tabclose or :tabc: Close the current tab
  * :tabs: List all tabs

Example workflow:
:tabnew
:edit file1.txt
:vsplit file2.txt
:tabnew
:edit file3.txt
gt

This sequence creates a new tab, opens two files side by side in the first tab, creates another tab with a
single file, and then moves to the next tab.

Buffers, Windows, and Tabs: Key Differences

-------------------------------------------------------------------------------------------------------------
Aspect         Buffers                        Windows                       Tabs
-------------------------------------------------------------------------------------------------------------
Representation Files in memory                Viewports onto buffers        Collections of windows
-------------------------------------------------------------------------------------------------------------
Visibility     Can exist without being        Always visible (when not      Always visible (when more than
               visible                        covered)                      one)
-------------------------------------------------------------------------------------------------------------
File           Associated with a specific     Display contents of a buffer  Not directly associated; contain
Association    file                                                         windows that display buffers
-------------------------------------------------------------------------------------------------------------
Purpose        Managing multiple files        Viewing and editing buffer    Organizing workspace
                                              contents
-------------------------------------------------------------------------------------------------------------
Persistence    Persist throughout Vim session Can be opened/closed without  Closing a tab closes its windows
               unless explicitly closed       affecting buffers             but not the buffers
-------------------------------------------------------------------------------------------------------------
Resource Usage Lightweight; can be numerous   More resource-intensive than  Most resource-intensive; fewer
                                              buffers, less than tabs       typically used
-------------------------------------------------------------------------------------------------------------
Scope          Global across Vim session      Local to a tab (or single     Local to a specific Vim instance
                                              "tab" if not using tabs)
-------------------------------------------------------------------------------------------------------------

When to use Buffers
  * When working with multiple files in the same project.
  * For quick navigation between different files.
  * When you want to keep files open but not necessarily visible.
  * When dealing with a large number of files.
  * When you need to perform operations across multiple files.

When to use windows
  * When you need to view different parts of the same file simultaneously.
  * For comparing the contents of different files side by side.
  * When you want to see the results of a command in a separate view.
  * When you need to maintain different cursor positions in the same file.
  * For keeping a "scratch" space open while working on a main file.

When to use tabs
  * To separate different tasks or contexts (e.g., coding vs. documentation).
  * To maintain different window layouts for different purposes.
  * When you want a visual separation of your workspaces.
  * For organizing files by project or feature when working on a complex system.
  * When you need to switch between entirely different sets of files quickly.

Advanced Usage

Combining Buffers, Windows, and Tabs
You can leverage the power of buffers, windows, and tabs by using them in combination:
 1. Use tabs to create separate workspaces for different aspects of your project.
 2. Within each tab, use multiple windows to view different buffers or different parts of the same buffer.
 3. Utilize buffer commands to quickly switch between files within windows.

Example:

:tabnew
:edit src/main.cpp
:vsplit include/header.h
:tabnew
:edit docs/README.md
:split docs/API.md
Ctrl-w v
:buffer src/main.cpp

This setup creates two tabs: one for code with two files side by side, and another for documentation with
three windows (two stacked vertically on the left, and one on the right showing the main.cpp file).

Buffer-Specific Commands
  * :bufdo {cmd}: Execute a command on all buffers
  * :ball: Open a window for each buffer
  * :bmodified: List all modified buffers

Window-Specific Commands
  * Ctrl-w =: Make all windows equal in size
  * Ctrl-w _: Maximize height of the current window
  * Ctrl-w |: Maximize width of the current window
  * Ctrl-w +: Increase height of the current window
  * Ctrl-w -: Decrease height of the current window
  * :windo {cmd}: Execute a command in all windows

Tab-Specific Commands
  * :tabdo {cmd}: Execute a command on all tabs
  * :tab split: Open the current buffer in a new tab
  * :tabmove N: Move the current tab to the Nth position (0-based)

Best Practices
 1. Use buffers for file management: Keep your working files open in buffers for quick access.
 2. Use windows for comparing and viewing: Split windows to compare files or view different parts of the same
    file.
 3. Use tabs for task organization: Create a new tab for each major task or context switch.
 4. Utilize split windows within tabs: Maximize screen real estate by splitting windows within a tab.
 5. Learn and use keyboard shortcuts: Efficiency in Vim comes from minimizing hand movement.
 6. Customize your Vim configuration: Add mappings and settings in your .vimrc to streamline your workflow.
 7. Use buffer numbers: Refer to buffers by their numbers for quick switching.
 8. Name your tabs: Use :tabname to give meaningful names to your tabs for better organization.
 9. Use window-local options: Take advantage of setting options locally to windows for specific behaviors.
10. Leverage buffer lists: Use commands like :ls and :buffers to keep track of your open files.
11. Master window movements: Get comfortable with window navigation commands to move efficiently between
    split views.

Common Pitfalls and How to Avoid Them
 1. Overusing tabs: Remember that tabs are for workspaces, not individual files. Avoid creating a new tab for
    each file.
 2. Forgetting about hidden buffers: Regularly check your buffer list to avoid losing track of unsaved
    changes.
 3. Ignoring the power of splits: Don't forget you can split windows to view multiple buffers or different
    parts of the same buffer simultaneously.
 4. Not using marks: Utilize Vim marks to quickly jump between important locations across buffers and
    windows.
 5. Neglecting buffer-specific options: Remember that some options (like 'filetype') are buffer-specific and
    may need to be set for each buffer.
 6. Overcomplicating layouts: While it's possible to create complex layouts with many splits, it's often more
    efficient to keep things simple and use fewer, well-organized windows.
 7. Forgetting window-specific commands: Make use of commands like Ctrl-w = to manage window sizes
    effectively.
 8. Not utilizing the arglist: For project-specific files, consider using the argument list in conjunction
    with buffers for better organization.
 9. Ignoring session management: For complex setups, learn to use Vim's session management to save and
    restore your workspace layouts.

Conclusion
Understanding the differences and relationships between buffers, windows, and tabs in Vim is crucial for
creating an efficient editing environment. Buffers are your primary tool for managing multiple files, windows
allow you to view and edit those files, and tabs help you organize your workspace. By leveraging these
features effectively, you can create a powerful and flexible editing environment tailored to your workflow.

Remember, the key is to use buffers for file management, windows for viewing and editing, and tabs for
workspace organization. With practice and experimentation, you'll find the perfect balance that suits your
editing style in Vim. Happy Vimming!


---
https://learnvim.irian.to/basics/buffers_windows_tabs

Buffers, Windows, and Tabs

   If you have used a modern text editor, you are probably familiar with windows and tabs. Vim uses
   three display abstractions instead of two: buffers, windows, and tabs. In this chapter, I will
   explain what buffers, windows, and tabs are and how they work in Vim.

   Before you start, make sure you have the set hidden option in vimrc. Without it, whenever you switch
   buffers and your current buffer is not saved, Vim will prompt you to save the file (you don't want
   that if you want to move quickly). I haven't cover vimrc yet. If you don't have a vimrc, create one.
   It is usually placed at the root directory and named .vimrc. I have mine on ~/.vimrc. To see where
   you should create your vimrc, check out :h vimrc. Inside it, add:
set hidden

   Save it, then source it (run :source % from inside the vimrc).

Buffers
   What is a buffer?
   A buffer is an in-memory space where you can write and edit some text. When you open a file in Vim,
   the data is bound to a buffer. When you open 3 files in Vim, you have 3 buffers.

   Have two empty files, file1.js and file2.js available (if possible, create them with Vim). Run this
   in the terminal:
$> vim file1.js

   What you are seeing is file1.js buffer. Whenever you open a new file, Vim creates a new buffer.

   Exit Vim. This time, open two new files:
$> vim file1.js file2.js

   Vim currently displays file1.js buffer, but it actually creates two buffers: file1.js buffer and
   file2.js buffer. Run :buffers to see all the buffers (alternatively, you can use :ls or :files too).
   You should see both file1.js and file2.js listed. Running vim file1 file2 file3 ... filen creates n
   amount of buffers. Each time you open a new file, Vim create a new buffer for that file.

   There are several ways you can traverse buffers:
     * :bnext to go to the next buffer (:bprevious to go to the previous buffer).
     * :buffer + filename. Vim can autocomplete filename with <Tab>.
     * :buffer + n, where n is the buffer number. For example, typing :buffer 2 will take you to buffer
       #2.
     * Jump to the older position in jump list with Ctrl-O and to the newer position with Ctrl-I. These
       are not buffer specific methods, but they can be used to jump between different buffers. I will
       talk more about jumps in Chapter 5.
     * Go to the previously edited buffer with Ctrl-^.

   Once Vim creates a buffer, it will remain in your buffers list. To remove it, you can type :bdelete.
   It accepts either a buffer number (:bdelete 3 to delete buffer #3) or a filename (:bdelete then use
   <Tab> to autocomplete).

   The hardest thing for me when learning about buffer was visualizing how it worked because my mind was
   used to windows from when using a mainstream text editor. A good analogy is a deck of playing cards.
   If I have 2 buffers, I have a stack of 2 cards. The card on top is the only card I see, but I know
   there are card(s) below it. If I see file1.js buffer displayed then the file1.js card is on the top
   of the deck. I can't see the other card, the file2.js, but it's there. If I switch buffers to
   file2.js, that file2.js card is now on the top of the deck and file1.js card is at the bottom.

   If you haven't used Vim before, this is a new concept. Take your time to understand it.

Exiting Vim
   By the way, if you have multiple buffers opened, you can close all of them with quit-all:
:qall

   If you want to close without saving your changes, just add ! at the end:
:qall!

   To save and quit all, run:
:wqall

Windows
   A window is a viewport on a buffer. If you're coming from a mainstream editor, this concept may be
   familiar to you. Most text editors have the ability to display multiple windows. In Vim, you can also
   have multiple windows.

   Let's open file1.js from the terminal again:
$> vim file1.js

   Earlier I said that you're looking at file1.js buffer. While that was correct, that statement was
   incomplete. You are looking at file1.js buffer displayed through a window. A window is what you are
   seeing a buffer through.

   Don't quit Vim yet. Run:
:split file2.js

   Now you are looking at two buffers through two windows. The top window displays file2.js buffer. The
   bottom window displays file1.js buffer.

   If you want to navigate between windows, use these shortcuts:
Ctrl-W H Moves the cursor to the left window
Ctrl-W J Moves the cursor to the window below
Ctrl-W K Moves the cursor to the window upper
Ctrl-W L Moves the cursor to the right window

   Now run:
:vsplit file3.js

   You are now seeing three windows displaying three buffers. One window displays file3.js buffer,
   another window displays file2.js buffer, and another window displays file1.js buffer.

   You can have multiple windows displaying the same buffer. While you're on the top left window, type:
:buffer file2.js

   Now both two windows are displaying file2.js buffer. If you start typing on a file2.js window, you
   will see that both windows that display file2.js buffers are being updated in real-time.

   To close the current window, you can run Ctrl-W C or type :quit. When you close a window, the buffer
   will still be there (run :buffers to confirm this).

   Here are some useful normal-mode window commands:
Ctrl-W V Opens a new vertical split
Ctrl-W S Opens a new horizontal split
Ctrl-W C Closes a window
Ctrl-W O Makes the current window the only one on screen and closes other windows

   And here is a list of useful window command-line commands:
:vsplit filename Split window vertically
:split filename Split window horizontally
:new filename Create new window

   Take your time to understand them. For more, check out :h window.

Tabs
   A tab is a collection of windows. Think of it like a layout for windows. In most modern text editors
   (and modern internet browsers), a tab means an open file / page and when you close it, that file /
   page goes away. In Vim, a tab does not represent an open file. When you close a tab in Vim, you are
   not closing a file. You are only closing the layout. The data for those files are stored in-memory in
   buffers. The buffers are still there.

   Let's see Vim tabs in action. Open file1.js:
$> vim file1.js

   To open file2.js in a new tab:
:tabnew file2.js

   You can also let Vim autocomplete the file you want to open in a new tab by pressing <Tab> (no pun
   intended).

   Below is a list of useful tab navigations:
:tabnew file.txt Open file.txt in a new tab
:tabclose Close the current tab
:tabnext Go to next tab
:tabprevious Go to previous tab
:tablast Go to last tab
:tabfirst Go to first tab

   You can also run gt to go to next tab page (you can go to previous tab with gT). You can pass count
   as argument to gt, where count is tab number. To go to the third tab, do 3gt.

   One advantage of having multiple tabs is you can have different window arrangements in different
   tabs. Maybe you want your first tab to have 3 vertical windows and second tab to have a mixed
   horizontal and vertical windows layout. Tab is the perfect tool for the job!

   To start Vim with multiple tabs, you can do this from the terminal:
$> vim -p file1.js file2.js file3.js

Moving In 3D
   Moving between windows is like traveling two-dimensionally along X-Y axis in a Cartesian coordinate.
   You can move to the top, right, bottom, and left window with Ctrl-W H/J/K/L.

   Moving between buffers is like traveling across the Z axis in a Cartesian coordinate. Imagine your
   buffer files lining up across the Z axis. You can traverse the Z axis one buffer at a time with
   :bnext and :bprevious. You can jump to any coordinate in Z axis with :buffer filename/buffernumber.

   You can move in three-dimensional space by combining window and buffer movements. You can move to the
   top, right, bottom, or left window (X-Y navigations) with window navigations. Since each window
   contains buffers, you can move forward and backward (Z navigations) with buffer movements.

Using Buffers, Windows, and Tabs The Smart Way
   You have learned what buffers, windows, and tabs are and how they work in Vim. Now that you
   understand them better, you can use them in your own workflow.

   Everyone has a different workflow, here is mine for example:
     * First I use buffers to store all the required files for the current task. Vim can handle many
       open buffers before it starts slowing down. Plus having many buffers opened won't crowd my
       screen. I am only seeing one buffer (assuming I have only one window) at any time, allowing me to
       focus on one screen. When I need to go somewhere, I can quickly fly to any open buffer anytime.
     * I use multiple windows to view multiple buffers at once, usually when diffing files, reading
       docs, or following a code flow. I try to keep the number of windows opened to no more than three
       because my screen will get crowded (I use a small laptop). When I am done, I close any extra
       windows. Fewer windows means less distractions.
     * Instead of tabs, I use tmux windows. I usually use multiple tmux windows at once. For
       example, one tmux window for client-side codes and another for backend codes.

   My workflow may look different than yours based on your editing style and that's fine. Experiment
   around to discover your own flow suited for your coding style.


---

