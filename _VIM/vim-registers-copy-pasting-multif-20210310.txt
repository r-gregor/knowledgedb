filename: vim_registers-copy-pasting-multif_20210310.txt
https://www.brianstorti.com/vim-registers/

Vim registers: The basics and beyond
09 Feb 2015

   Vim's registers are that kind of stuff that you don't think you need until you learn about them.
   After that, they become essential in your workflow, and it's hard to let them behind. Saying that,
   it's still incredible how many people use vim for years without knowing how to make proper use of
   them. Bear with me and you won't be one of them.

If you have no idea what I'm talking about
   You can think of registers as a bunch of spaces in memory that vim uses to store some text. Each of
   these spaces have a identifier, so it can be accessed later.
   It's no different than when you copy some text to your clipboard, except that you usually have just
   one clipboard to copy to, while vim allows you to have multiple places to store different texts.

The basic usage
   Every register is accessed using a double quote before its name. For example, we can access the
   content that is in the register r with "r.

   You could add the selected text to the register r by doing "ry. By doing y you are copying (yanking)
   the selected text, and then adding it to the register "r. To paste the content of this register, the
   logic is the same: "rp. You are pasting the data that is in this register.
   You can also access the registers in insert/command mode with Ctrl-r + register name, like in Ctrl-r
   r. It will just paste the text in your current buffer.
   You can use the :reg command to see all the registers and their content, or filter just the ones that
   you are interested with :reg a b c.

:reg a b c
--- Registers ---
"a   register a content
"b   register b content
"c   register c content

The unnamed register
   vim has a unnamed (or default) register that can be accessed with "". Any text that you delete (with
   d, c, s or x) or yank (with y) will be placed there, and that's what vim uses to paste, when no
   explicit register is given. A simple p is the same thing as doing ""p.

Never lose a yanked text again
   It already happened to all of us. We yank some text, than delete some other, and when we try to paste
   the yanked text, it's not there anymore, vim replaced it with the text that you deleted, then you
   need to go there and yanked that text again.
   Well, as I said, vim will always replace the unnamed register, but of course we didn't lose the
   yanked text, vim would not have survived that long if it was that dumb, right?

   vim automatically populates what is called the numbered registers for us. As expected, these are
   registers from "0 to "9.
   "0 will always have the content of the latest yank, and the others will have last 9 deleted text,
   being "1 the newest, and "9 the oldest. So if you yanked some text, you can always refer to it using
   "0p.

The read only registers
   There are 4 read only registers: "., "%, ": and "#
   The last inserted text is stored on "., and it's quite handy if you need to write the same text
   twice, in different places, not needing to yank and paste.

   "% has the current file path, starting from the directory where vim was first opened. What I usually
   use it for is to copy the current file to the clipboard, so I can use it externally (running a script
   in another terminal, for instance). You could execute :let @+=@% to do that. let is used to write to
   a register, and "+ is the clipboard register, so we are copying the current file path to the
   clipboard.

   ": is the most recently executed command. If you save the current buffer with :w, "w" will be in this
   register. A good way to use it is with @:, to execute this command again. For example, if you execute
   a substitute command in one line, like in :s/foo/bar, you can just to go another line and execute @:
   to run this substitution again.

   "# is the name of the alternate file, that you can think of it as the last edited file (it's a bit
   more complex than that, go to :h alternate-file if you want to understand it better). It's what vim
   uses to switch between files when you use Ctrl-^, and you could do the same thing with :e Ctrl-r #. I
   rarely use this, but hopefully you are more creative than I am.

The expression and the search registers
   The expression register ("=) is used to deal with results of expressions. This is easier to
   understand with an example. If, in insert mode, you type Ctrl-r =, you will see a "=" sign in the
   command line. Then if you type 2+2 <enter>, 4 will be printed. This can be used to execute all sort
   of expressions, even calling external commands. To give another example, if you type Ctrl-r = and
   then, in the command line, system('ls') <enter>, the output of the ls command will be pasted in your
   buffer.

   The search register, as you may have imagined, is where the latest text that you searched with /, ?,
   * or # is. If, for example, you just searched for /Nietzsche, and now you want to replace it with
   something else, there is no way you are going to type "Nietzsche" again,
   just do :%s/<Ctrl-r />/mustache/g and you are good to go.

Macros
   You may already be familiar with vim's macros. It's a way to record a set of actions that can be
   executed multiple times (:h recording if you need more information). What you probably didn't know is
   that vim uses a register to store these actions, so if you use qw to record a macro, the register "w
   will have all the things that you did, it's all just plain text.

   The cool thing about this is that, as it is just a normal register, you can manipulate it as you
   want. How many times have you forgotten that step in the middle of a macro recording and had to do it
   all over again? Well, fixing that is as simple as editing a register.
   For example, if you forgot to add a semicolon in the end of that w macro, just do something like :let
   @W='i;'. Noticed the upcased W? That's just how we append a value to a register, using its upcased
   name, so here we are just appending the command i; to the register, to enter insert mode (i) and add
   a semicolon.
   If you need to edit something in the middle of the register, just do :let @w='<Ctrl-r w>, change what
   you want, and close the quotes in the end. Done, no more recording a macro 10 times before you get it
   right.

   Another cool thing about this is that, as it's just plain text in a register, you can easily move
   macros around, applying it in other vim instance, or sharing it with someone else. Think about it, if
   you have that register in your clipboard, you can just execute it with @+ ("+ is the clipboard
   register). Try it, just write "ivim is awesome" anywhere, then copy it to your clipboard, and execute
   @+ in a vim buffer. How cool is that?

Wrapping up
   Understanding how registers work is quite simple, and although you are not going to use them every 5
   minutes, it certainly will avoid some annoyances, like losing a yanked text, of having to record a
   macro again. I covered the things that I use the most, but there is more. If you are curious about
   what a small delete or a black hole register is, you should definitely read the short and easy to
   follow documentation in :h registers. And if you want to learn more about vim in general, the book
   [https://amzn.to/3bE2qku]Practical Vim is a great resource.



---
https://www.tutorialspoint.com/vim/vim_registers.htm

Vim - Registers
   
   Vim provides many registers. We can use these registers as multiple clipboards. This feature is
   really useful while working with multiple files. In this chapter, we will discuss following items −
     * Copy text in register
     * Paste text from register
     * List available registers
     * Register types

Copy text in register
   For copying, we can use normal yank command i.e. yy and to store it in register we can use following
   syntax −
"<register-name><command>

   For instance, to copy text in register "a" use following command −
"ayy

Paste text from register
   To paste text from register use −
"<register-name>p

   For instance, below command copies text from register "a" −
"ap

List available registers
   To list all available registers use following command
:registers

Register types
   Vim supports following types of registers −

Unnamed registers
   Unnamed register is denoted by "". Vim stores deleted or copied text in this register

Named registers
   We can use 26 named registers; we can use a-z or A-Z. By default vim doesn't uses these registers.

   If we use lower case register name then contents will be overwritten and if we use uppercase name
   then contents will be appended in that register.

Numbered registers
   We can use 0 to 9 named registers. Vim fills these registers with text from yank and delete command.
     * Numbered register 0 contains the text from the most recent yank command.
     * Numbered register 1 contains the text deleted by the most recent delete or change command

Default registers
   Following are the default registers −
   ----------------------------------------------------------
   Sr.No	Register & Description
   ----------------------------------------------------------
   1 %		Name of the current file
   2 #		Name of the alternate file for the current window
   3 :		Most recently executed command
   4 .		Contains the last inserted text
   5 "		Last used register
   ----------------------------------------------------------



---
https://vim.fandom.com/wiki/Pasting_registers

It is possible to paste the contents of any register into the current buffer or command-line.

In normal and visual modes
   In normal and visual modes, "xp pastes the contents of the register x.

   This works with special registers as well: "+p (or "*p) pastes the contents of the clipboard, "/p
   pastes the last search, and ":p pastes the last command. For example, you might want to save a
   complex search and replace (:%s///g) that you have just used, which you can do by pasting with ":p.

In insert and command-line modes
   In insert and command-line modes, you can use <C-R> to paste the contents of a register
   (:help i_CTRL-R). In particular, <C-R>" pastes from the default (unnamed) register, which is
   analogous to doing p in normal mode.

   Note that because Vim faithfully translates the contents of the clipboard to a buffer in insert and
   command-line modes, using <C-R>+ is susceptible to attacks if the contents of the clipboard cannot be
   fully trusted. This is sometimes called "clipboard hijacking". For instance, if one copies text from
   a website that contains a literal escape character (i.e. the character with ASCII value 27, not a
   representation of the escape character such as <Esc>), Vim will faithfully switch to normal mode and
   begin executing normal mode commands. Some browsers hide special characters when displaying a page,
   so it is not immediately obvious even if one has copied malicious text. Moreover, using clever
   div-tag positioning, even browsers that display special characters are susceptible to such attacks
   (proof of concept). It is possible to use <C-O>"+p, <C-R><C-R>+ (:help i_CTRL-R_CTRL-R), and
   similar commands instead, which prevents attacks of this form.

   If one prefers to continue using <C-R>+ to paste from the system clipboard, one of the following
   mappings can be used:
" Pick one
inoremap <C-R>+ <C-R><C-R>+
inoremap <C-R>+ <C-R><C-O>+
inoremap <C-R>+ <C-G>u<C-\><C-O>"+gP
inoremap <C-R>+ <C-G>ux<Esc>"=@+.'xy'<CR>gPFx"_2x"_s
exe 'inoremap <script> <C-R>+ <C-G>u' . paste#paste_cmd['i']

--------------------------------------------------------------------------------------------------------------
Mapping for <C-R>+     Force           Obey textwidth,
                       characterwise   formatoptions,   Contents of ". (:help quote.)
                       paste?          etc.?
--------------------------------------------------------------------------------------------------------------
                                                        Keeps anything inserted before pasting, puts in the
<C-R><C-R>+            Yes             Yes              actually pasted text (^V-escaped), and keeps anything
                                                        inserted after pasting
--------------------------------------------------------------------------------------------------------------
<C-R><C-O>+            No              No               Keeps anything inserted before pasting, puts in ^R^O+,
                                                        and keeps anything inserted after pasting
--------------------------------------------------------------------------------------------------------------
<C-G>u<C-\><C-O>"+gP   No              No               Clears anything inserted before pasting, but keeps
                                                        anything inserted after pasting
--------------------------------------------------------------------------------------------------------------
<C-G>ux<Esc>"=                                          Clears anything inserted before pasting, but keeps
@+.'xy'<CR>            Yes             No               anything inserted after pasting
gPFx"_2x"_s
--------------------------------------------------------------------------------------------------------------
exe ...                If has                           Clears anything inserted before pasting, but keeps
(see above)            ('virtualedit') No               anything inserted after pasting
                       is false
--------------------------------------------------------------------------------------------------------------

   For the first mapping, see :help i_CTRL-R_CTRL-R.

   For the second mapping, see :help i_CTRL-R_CTRL-O.

   The third mapping will temporarily switch to normal mode without moving the cursor, and then paste.
   It first uses <C-g>u to break the undo sequence so that the pasting can be undone. Then <C-\><C-o>
   temporarily switches to normal mode without moving the cursor. It then accesses the + register and
   uses gP instead of the usual P to paste so that the cursor is positioned after what is pasted (just
   like the default <C-R>+). Note that because the clipboard is pasted in "one move" instead of being
   translated character-by-character (the default behavior), formatting options such as textwidth are
   not obeyed (use something like gqip to fix the formatting; see :help gq).

   The fourth mapping employs the strategy used in paste.vim (when virtualedit is unavailable). This
   mapping forces Vim to paste characterwise (:help characterwise-register) even if the register
   contains linewise text. This is useful if you always want Vim to start pasting where the cursor was
   on the line. Select some lines using V, then yank with "+y. Now enter insert mode in the middle of a
   line. The behavior of the first mapping would be to jump to the previous line and insert the lines
   there (thus not changing the current line), whereas in most other text editors the text is pasted in
   the middle of the current line (since most text editors don't distinguish between linewise and
   characterwise operations).

   The fifth mapping is essentially from mswin.vim. If Vim was compiled with virtualedit, it takes
   advantage of this to paste linewise and blockwise text in a more Vim-like manner. If Vim is not
   compiled with virtualedit, it falls back to the behavior of the previous mapping.

   Even with the above mappings, the default behavior can still be retrieved by waiting a moment after
   typing <C-R> (so that Vim gives up on trying to use the custom mapping).

References
     * :help c_CTRL-R


---
https://zean.be/articles/vim-registers/

Vim - Registers

Overview
   A register in Vim is basically a slot in memory that you can put a piece of text in and read it out
   later. Each register is like the clipboard provided by the OS (e.g. Windows, MacOS etc.), except that
   Vim has a LOT of them instead of just one.
   It takes a while to learn how to use them and some slow repetitions in the beginning to develop the
   muscle memory, but you'll never go back to the simple yank/paste again after getting comfortable with
   it.

Basic usage
   You can list all registers and their contents by using the :reg command, or using the :reg
   <register-a> <register-b> ... to filter to the specific registers and their contents.

   Each register is accessed following the pattern "<register-name><command>. Note it's got 3 parts,
     * the " prefix,
     * the <register-name>, and
     * the <command> to perform on that register.

   For example, "ay yanks the current selected text and stores it in the register "a, and "ap pastes the
   current content of register "a.

Registers
   There're 9 different types of registers provided by Vim. I've listed them all below, but only
   included detailed explanation (with some common practices) for the ones I've used the most. For the
   advanced ones, I've included a link to the official documentation.

1. Unnamed (or default) register
   The " register (accessed via "") is the default register.

   Its content will be updated whenever you delete (using the d, c, s or x commands) or yank (using the
   y command) some text.

   You can read the content of this register by using "". For example, you can do ""p to paste the value
   store in it.
   Vim reads the content of the unnamed register for any put command (p or P) which does not specify a
   register. So, p is the same as ""p

2. Numbered registers
   These are the registers "0, "1, "2, "3, "4, "5, "6, "7, "8, "9.

   "0 will be set by the most recent yank command, therefore it always has the content of the latest
   yank.
   If you yanked some text, you can always refer to it using "0p.

   "1 will be set by the most recent delete or change command only if the deleted or changed text is
   longer than one line (also called big delete).

   "2, "3, "4, "5, "6, "7, "8, "9 stores the other 8 latest big deletion or change. With each successive
   big deletion or change command, Vim shifts the previous contents of "1 into "2, "2 into "3, and so
   forth, losing the previous contents of "9.

3. Small delete register
   The register - is set by a delete command only if the deleted text is smaller than one line (also
   called small delete).
   Tip: The latest yanked texts will always appear in "0. The latest small deletion will appear in "-
   while the latest big deletion will appear in "1. The other latest 8 big deletion will appear in "2,
   "3, "4, "5, "6, "7, "8, "9.

4. Named registers
   These are the registers "a to "z, or "A to "Z.

   These registers are only used when you say so. Specify them as lowercase letters to replace their
   previous contents or as uppercase letters to append to their previous contents.
   Tip: I only use a couple of these as more permanent storage for code snippets such as
   console.log(``), as compared to the temporary storage provided by the numbered registers and the
   small delete register.
   I find myself can survive with just the basic registers mentioned so far, and rarely use the ones
   below. But if you're interested, keep reading.

5. Read-only registers
   These are %, #, : and ..

   You can use them only with the p, P, and :put commands and with CTRL-R.
   ".   Contains the last inserted text (the same as what is inserted with the insert mode commands
        CTRL-A and CTRL-@).

        Note: this doesn't work with CTRL-R on the command-line. It works a bit differently, like
        inserting the text instead of putting it ('textwidth' and other options affect what is inserted).

   "%   Contains the name of the current file.
   "#   Contains the name of the alternate file.
   ":   Contains the most recent executed command-line. Example: Use @: to repeat the previous command-line
        command.

   The command-line is only stored in this register when at least one character of it was typed. Thus it
   remains unchanged if the command was completely from a mapping.

6. Expression register
   The expression register is the "=. According to the documentation,

     This is not really a register that stores text, but is a way to use an expression in commands
     which use a register. The expression register is read-only; you cannot put text into it. After the
     '=', the cursor moves to the command-line, where you can enter any expression. All normal
     command-line editing commands are available, including a special history for expressions. When you
     end the command-line by typing <CR>, Vim computes the result of the expression. If you end it with
     <Esc>, Vim abandons the expression. If you do not enter an expression, Vim uses the previous
     expression (like with the "/" command). The expression must evaluate to a String. A Number is
     always automatically converted to a String. For the p and :put command, if the result is a Float
     it's converted into a String. If the result is a List each element is turned into a String and
     used as a line. A Dictionary or FuncRef results in an error message. If the "= register is used
     for the p command, the String is split up at <NL> characters. If the String ends in a <NL>, it is
     regarded as a linewise register.

   Please see the documentation for details

7. Selection and drop registers
   These are the "*, "+, and "~.

   They're used for storing and retrieving the selected text for the GUI. As I've never used this, I
   won't write down all the details for it. If you're interested, you could read the documentation
   for details.

8. Black hole register
   The "_ is the black hole register. As the name implies, nothing will happen if you write to it, and
   nothing will be returned from it if you try to read its content.
   Tip: You can direct your deleted text to the black hole register to avoid affecting other normal
   registers.

9. Last search pattern register
   This is the "/ register, and it stores the most recent search pattern.

   According to the documentation,

     This is used for n and hlsearch. It is writable with :let, you can change it to have hlsearch
     highlight other matches without actually searching. You can't yank or delete into this register.
     The search direction is available in v:searchforward. Note that the valued is restored when
     returning from a function function-search-undo.



---
https://blog.sanctum.geek.nz/advanced-vim-registers/

Advanced Vim registers
2012-10-24

   Registers in Vim are best thought of as scratch spaces for text, some of which are automatically
   filled by the editor in response to certain actions. Learning how to use registers fluently has a lot
   of subtle benefits, although it takes some getting used to because the syntax for using them is a
   little awkward.

   If you're reasonably fluent with Vim by now, it's likely you're already familiar with the basic usage
   of the 26 named registers, corresponding to the letters of the alphabet. These are commonly used for
   recording macros; for example, to record a series of keystrokes into register a, you might start
   recording with qa, and finish with q; your keystrokes could then be executed with @a.

   Similarly, we can store text from the buffer itself rather than commands in these registers, by
   prepending "a to any command which uses a register, such as the c, d, and y commands:
     * "ayy - Read current line into register a.
     * "bP - Paste contents of register b above current line.
     * "cc3w - Change three words, putting the previous three words into register c.

   Like many things in Vim, there's a great deal more functionality to registers for those willing to
   explore.

   Note that here I'll be specifically ignoring the *, +, and ~ registers; that's another post about the
   generally unpleasant business of making Vim play nice with system clipboards. Instead, I'll be
   focussing on stuff that only applies within a Vim session. All of this is documented in :help
   registers.

Capital registers
   Yanking and deleting text into registers normally replaces the previous contents of that register. In
   some cases it would be preferable to append to a register, for example while cherry-picking different
   lines from the file to be pasted elsewhere. This can be done by simply capitalizing the name of the
   register as it's referenced:
     * "ayy - Replace the contents of register a with the current line.
     * "Ayy - Append the current line to register a.

   This works for any context in which an alphabetical register can be used. Similarly, to append to a
   macro already recorded in register a, we can start recording with qA to add more keystrokes to it.

Viewing register contents
   A good way to start getting a feel for how all the other registers work is to view a list of them
   with their contents during an editing session with :registers. This will show the contents of any
   register used in the editing session. It might look something like this, a little inscrutable at
   first:
:registers
--- Registers ---
""   Note that much of it includes
"0   execut
"1   ^J^J
"2   16 Oct (2 days ago)^J^Jto Jeff, Alan ^JHi Jeff (cc Alan);^J^JPlease
"3   <?php^Jheader("Content-Type: text/plain; charset=utf-8");^J?>^J.^J
"4   ^J
"5   Business-+InternationalTrade-TelegraphicTransfers-ReceivingInternati
"6   ../^J
"7       diff = auto^J    status = auto^J    branch = auto^J    interacti
"8   ^J[color]^J    ui = auto^J    diff = auto^J    status = auto^J    br
"9       ui = true^J
"a    escrow
"b   03wdei^R=2012-^R"^M^[0j
"c   a
"e   dui{<80>kb^[^[
"g   ^[gqqJgqqjkV>JgqqJV>^[Gkkkjohttp://tldp.org/LDP/abs/html/^[I: ^[k
"h   ^[^Wh:w^Mgg:w^M^L:w^Mjk/src^Mllhh
"j   jjjkkkA Goo<80>kb<80>kb<80>kbThis one is good pio<80>kbped through a
"-   Note that much of it includes
".    OIt<80>kb<80>kb<80>kbIt might looks <80>kb<80>kb something like thi
":   register
"%   advanced-vim-registers.markdown
"/   Frij

   The first column contains the name of the register, and the second its contents. The contents of any
   of these registers can be pasted into the buffer with "ap, where a is the name of any of them. Note
   that there are considerably more registers than just the named alphabetical ones mentioned above.

Unnamed register
   The unnamed register is special in that it's always written to in operations, no matter whether you
   specified another register or not. Thus if you delete a line with dd, the line's contents are put
   into the unnamed register; if you delete it with "add, the line's contents are put into both the
   unnamed register and into register a.

   If you need to explicitly reference the contents of this register, you can use ", meaning you'd
   reference it by tapping " twice: "". One handy application for this is that you can yank text into
   the unnamed register and execute it directly as a macro with @".

   Man, and you thought Perl looked like line noise.

Black hole register
   Another simple register worth mentioning is the black hole register, referenced with "_. This
   register is special in that everything written to it is discarded. It's the /dev/null of the Vim
   world; you can put your all into it, and it'll never give anything back. A pretty toxic relationship.

   This may not seem immediately useful, but it does come in handy when running an operation that you
   don't want to clobber the existing contents of the unnamed register. For example, if you deleted
   three lines into the unnamed register with 3dd with the intent of pasting them elsewhere with p, but
   you wanted to delete another line before doing so, you could do that with "_dd; line gone, and no
   harm done.

Numbered registers
   The read-only registers 0 through 9 are your "historical record" registers. The register 0 will
   always contain the most recently yanked text, but never deleted text; this is handy for performing a
   yank operation, at least one delete operation, and then pasting the text originally yanked with "0p.

   The registers 1 through 9 are for deleted text, with "1 referencing the most recently deleted text,
   "2 the text deleted before that, and so on up to "9.

The small delete register
   This read-only register, referenced by "-, stores any text that you deleted or changed that was less
   than one line in length, unless you specifically did so into some other named register. So if you
   just deleted three characters with 3x, you'll find it in here.

Last inserted text register
   The read-only register ". contains the text that you last inserted. Don't make the mistake of using
   this to repeat an insert operation, though; just tap . for that after you leave insert mode, or have
   the foresight to prepend a number to your insert operation; for example, 6i.

Filename registers
   The read-only register "% contains the name of the current buffer's file. Similarly, the "# register
   contains the name of the alternate buffer's file.

Command registers
   The read-only register ": contains the most recently executed : command, such as :w or :help. This is
   likely only of interest to you if you're wanting to paste your most recent command into your Vim
   buffer. For everything else, such as repeating or editing previous commands, you will almost
   certainly want to use the command window.

Search registers
   The read-only register / contains the most recent search pattern; this can be handy for inserting the
   search pattern on the command line, by pressing Ctrl-R and then / - very useful for performing
   substitutions using the last search pattern.

Expression register
   Here's the black sheep of the bunch. The expression register = is used to treat the results of
   arbitrary expressions in register context. What that means in actual real words is that you can use
   it as a calculator, and the result is returned from the register.

   Whenever the expression register is referenced, the cursor is put on the command line to input an
   expression, such as 2+2, which is ended with a carriage return.

   This means in normal mode you can type "=2+2<Enter>p, and 4 will be placed after the cursor; in
   insert or command mode you can use Ctrl-R then =2+2<Enter> for the same result. If you don't find
   this syntax as impossibly awkward as I do, then this may well suit you for quick inline calculations
   ... personally, I'd drop to a shell and bust out bc for this.

   Knowing your registers well isn't as profound a productivity boost as squelching a few of the other
   Vim anti-patterns, but it can certainly save you some of the annoyance of lost text.
   This entry was posted in Vim and tagged advanced, black hole, expression, named,
   numbered, read-only, registers, unnamed by Tom Ryder. Bookmark the permalink.



---
https://fzheng.me/2018/03/24/practical-vim-registers/

Practical Vim: Registers
Mar 24, 2018

Chap 10 - Copy and Paste

Tip 59: Delete, Yank, and Put with Unnamed Register
   Delete/Yank without specifying a register will put the characters into the unnamed register.

   Paste(Put) without specifying a register will put the characters from the unnamed register.

   y{motion} for yank with motion.

   x for deleting a character.

   s for deleting a character and then into Insert mode.

   d{motion} for deleting with motion.

   p for pasting.

Tip 60: Grok Registers
   "{reg}: address a register.

   "bdd: cut the current line into register b.

   "ayiw: yank the current word into register a.

   "" is the unnamed register.

   "0 is the Yank register, only for y{motion}.

   "a-"z are the Named Registers for users to explicitly use.

   "_ is the Black Hole Register, 'eating' anything put into it. "_d{motion} will delete the specified
   text without saving a copy of it.

   "+ is the System Register (The X11 clipboard, used with cut, copy and paste).

   "* is the Selection Register (The X11 primary, used with middle mouse button).

   "= is the Expression Register, check Tip 16.

   More Registers:
   Register           Contents
   "%       name of the current file
   "#       name of the alternative file
   ".       last insert text
   ":       last Ex command
   "/       last search pattern

Tip 61: Replace a Visual Selection with Register
   On selecting some text, Put will replace it with the text in the registers. In this case, the
   replaced text would be put in the register (think of it as being deleted by d). This technique can be
   use to swap two words.

Tip 62: Paste from a Register
   p P in Normal mode, <C-r> in Insert mode.

   gp gP paste the same thing, but leaving the cursor at the end of pasted text instead of at the
   beginning.

Tip 63: Interact with the System Clipboard
   In Insert mode, Ctrl-Shift-v or Ctrl-Alt-v provided by the terminal, or <C-r>+ may cause wrong
   indentation if autoindent is enabled. The paste option can help with this. When it is enabled, Vim
   turns off all Insert mode mappings and abbrevations and resets a host of options, including
   autoindent (look up :h 'paste').

   "+p in Normal mode is better.

Chap 11 - Macros

Tip 64: Record and Execute a Macro
   q{register} to begin recording a macro into a given register; q again to stop recording.

   @{register} to execute the recorded contents in the specified register.

   @@ repeats the macro that was invoked most recently.

Tip 65: Normalize, Strike, Abort
   When executing a macro, Vim blindly repeats the sequence of canned keystrokes. Therefore,

   1) Make sure the cursor is explicitly positioned where you expect (like 0,gg, etc.).

   2) Strike the target with a repeatable motion: word-wise motion is better than character-wise;
   navigating by search can be exploited.

   3) Abort when a motion fails - by default Vim aborts the rest of the macro if a motion fails, so we
   need not worry 100@a may over-count, and can use a very large number if we want to repeat for many
   times.

Tip 66: Play Back with a Count
   11@{register}: execute a macro in {register} for 11 times.

   Again, since Vim would abort the execution if a motion fails, so you can provide a large enough count
   without much worry.

Tip 67: Repeat a Change on Contiguous Lines
   Record a series of operations on a line into a macro in {register}, with the last keystroke being j.
   Then 5@{register} would repeat the same change to the next 5 contiguous lines in series.

   One problem of executing macro in series: if the executation fails in one line in the middle, it
   would be aborted, leaving the following lines unchanged.

   Executing in parallel is a better choice in this case: use V to trigger line-wise Visual mode, select
   those lines, and :'<,'>normal @{register} to execute the macro on each of the lines.

Tip 68: Append Commands to a Macro
   qA will record keystrokes, appending them to the existing contents of register a.

Tip 69: Act Upon a Collection of Files
    1. Build a list of target files with :args, e.g.
:args *.py

    2. Make sure we are at the start of the argument list:
:first

    3. Now record a macro to reg a, while applying a series of operations.
    4. Revert the change we have just made to the first buffer, to prevent applying the change twice on
       it (because we would execute the macro to ALL buffers in the argument list later):
:edit!

    5. Execute the macro on all of the buffers in the argument list:
:argdo normal @a

       This macro can also be executed in series across many files, by appending a final step that
       advances to the next buffer in the list (analogous to the j in the macro applied on contiguous
       lines) :

       Keystrokes                    Effect
       qA         Begin recording new operations to append to a
       :next      Advance to next buffer
       q          Stop recording
       22@a       Execute the macro on many buffers
    6. Save changes to all files:
:wall

Tip 70: Evaluate an Iterator to Number Items in a List
   Suppose we have this text:
partridge in a pear tree
turtle doves
French hens
calling birds
golden rings

   We want it to be:
1) partridge in a pear tree
2) turtle doves
3) French hens
4) calling birds
5) golden rings

   For this task we use a variable and increment it, which would look like:
:let i=0
:let i += 1

   Specifically, 1) record the macro:
       Keystrokes                            Effect
   :let i=1           declare the variable
   qa                 begin recording
   I<C-r>=i<CR>)<Esc> insert to the line beginning, getting the value of i
   :let i += 1        increment i
   q                  stop recording

   2) execute the macro:
     Keystrokes                Effect
   jVG             select all the following lines
   :'<,'>normal @a execute the macro in parallel

Tip 71: Edit the Contents of a Macro
   The contents of a macro in a register are the very same with which the Yank/Put operations interact.
   So we can paste the macro contents as plain text and edit them, and then yank the contents back to
   the register.

   Moreover, we can manipulate the text of a macro programmatically using Vim script, like
:let @a=substitute(@a, '\~', 'vU', 'g')

   Look up :h substitute() for details.


---
https://www.barbarianmeetscoding.com/blog/5-minutes-vim-copy-pasting-and-registers

5 Minutes Vim: Copying, Cutting, Pasting, Registers and How to Tame Them
Feb 01, 2020

   In this 5 minutes of Vim goodness we'll learn how to effectively copy, cut and paste things in Vim by
   taking advantage of Vim's registers and a cool plugin. Here we go!

   Copy and paste. Doesn't sound like much excitement, does it? You are probably accustomed to use your
   mouse to perform some text selection, copy or cut it and then paste it somewhere else. And that is
   it. Not so much to be excited about.

   Vim spices up copying, cutting and pasting in a couple of ways:
    1. It gives you new shiny operators and commands you can use in combination with all the motions
       you've learn thus far
    2. It provides a handful of registers where you can save stuff for later pasting which can enable
       interesting workflows

   The two main commands for copying and pasting are y and p. *Why y and not c for copy, you may
   wonder?* Well, if you are familiar with Vim you may know that c is already taken, it is the change
   command. And thus, the vi engineers had to come up with a suitable way to describe copying and
   settled on the colourful name of yank (because engineers are far more playful than one would think at
   first sight). So in Vim you don't copy stuff, you yank it (great naming... So visceral). p stands for
   put and therefore in Vim you yank some text from somwhere and put it some place else. If you're
   accustomed to think of p in terms of pasting then feel free to use whichever mnemonic makes you
   happy.

   From now on, instead of copy I'll say **yank** so you get accustomed to it and can easily connect it
   in your brain and muscle memory to the letter y. Yank! Yank! Yank!

   y is an operator. You can combine it with any of the motions and text-objects we've learned to yank
   stuff to your heart's content:
     * yl yanks a letter,
     * yaw yanks a word,
     * yas yanks a sentence
     * yi( yanks everything within ( and so on...

   If you double y as in yy you get a linewise operator like dd and cc and yank a whole line. The Y
   command also yanks a complete line.

   In order to paste things you use the p command and its variants:
     * p pastes something after the cursor
     * P pastes something before the cursor
     * gp same as p but puts the cursor after the pasted selection
     * gP same as P and puts the cursor after the pasted selection

   Pasting in Vim is kind of special and the behavior of p and P depend on whether you've yanked
   characters or lines. If you've yanked characters then pasting will put those characters after or
   before the cursor (no surprises there). If you've yanked lines, however, pasting will put those lines
   after or before the line where the cursor is resting on. This behavior may sound weird at first but
   it makes a lot of sense in practice.

   Imagine that you are contemplating this powerful extract from an ancient text:
Hither came Conan, the Cimmerian, black-haired, sullen-eyed, sword in hand, a thief, a reaver, a slayer, with
gigantic melancholies and gigantic mirth, to tread the jeweled thrones of the Earth under his sandaled feet.

   And you want to add more intensity to this passage you may decide to yank the the particle and
   sprinkle it here and there:
v
Hither came Conan, the Cimmerian, black-haired, sullen-eyed, ...

   Start by jumping to the the particle with f,w:
       v                  v
f,w    Hither came Conan, the Cimmerian, black-haired, ...

   Then yank the word with yaw, jump to the next location were to put the with ;w and paste with P:
                         v                 v
;w    Hither came Conan, the Cimmerian, the black-haired, ...

   The jump to the next location again with ;w and type . to repeat the last change:
Hither came Conan, the Cimmerian, the black-haired, the sullen-eyed, ...

   Want to duplicate a line instead? It is as easy as typing yyp. Imagine that you have an array literal
   in JavaScript and it's filled with magical items of wonder:
const chest = [
  {name: 'sword', weight: 2.1, state: 'well kept'},
  {name: 'rusty dagger', weight: 0.4, state: 'worn out'},
];

   And now you want to add some more items to this chest. You can use any of the existing items as a
   template and type yyp to duplicate it:
const chest = [
  {name: 'sword', weight: 2.1, state: 'well kept'},
  {name: 'rusty dagger', weight: 0.4, state: 'worn out'},
  {name: 'rusty dagger', weight: 0.4, state: 'worn out'},
];

   Then type ci' to change its name to something else:
const chest = [
  {name: 'sword', weight: 2.1, state: 'well kept'},
  {name: 'rusty dagger', weight: 0.4, state: 'worn out'},
  {name: 'scepter of fire', weight: 0.4, state: 'worn out'},
];

   Want to n-plicate a line? (Yes, I'm pretty sure that's a real word) It is as simple as typing
   yy{count}p. Yes! Counts also work with yank and pasting because they're just commands! Let's retry
   the example above but this time type yy5p:
const chest = [
  {name: 'sword', weight: 2.1, state: 'well kept'},
  {name: 'rusty dagger', weight: 0.4, state: 'worn out'},
  {name: 'rusty dagger', weight: 0.4, state: 'worn out'},
  {name: 'rusty dagger', weight: 0.4, state: 'worn out'},
  {name: 'rusty dagger', weight: 0.4, state: 'worn out'},
  {name: 'rusty dagger', weight: 0.4, state: 'worn out'},
  {name: 'rusty dagger', weight: 0.4, state: 'worn out'},
];

   Wow! Impressive, isn't it?

   Ok. So if y, the yank command, copies stuff... How do you cut things in Vim? Aha! Here comes a
   surprise!

Cutting Stuff In Vim
   You may be familiar with the d (delete) and c (change) commands in Vim? As their name indicates they
   let you delete and change text in Vim. A lesser know fact is that, in addition to deleting and
   changing text, they also cut it.

   Imagine that in addition to the chest we had earlier we now have a brave adventurer ready to explore
   the world and confront its perils. Sadly, our adventurer has little and lacks many of the tools of
   the adventuring trade she'll need to survive:
const chest = [
  {name: 'sword', weight: 2.1, state: 'well kept'},
  {name: 'rusty dagger', weight: 0.4, state: 'worn out'},
  {name: 'rusty dagger', weight: 0.4, state: 'worn out'},
];

const sonja = {
  name: 'Sonja',
  inventory: [
  ],
};

   Let's give her some help and move the well kept sword from the chest into her inventory:
v
const chest = [
  {name: 'sword', weight: 2.1, state: 'well kept'},
  {name: 'rusty dagger', weight: 0.4, state: 'worn out'},
  {name: 'rusty dagger', weight: 0.4, state: 'worn out'},
];

   We type 2jdd to jump two lines down and delete (and cut) our sword:
const chest = [
  v
  {name: 'rusty dagger', weight: 0.4, state: 'worn out'},
  {name: 'rusty dagger', weight: 0.4, state: 'worn out'},
];

   Then /in<ENTER> to move our cursor on to of the in in inventory:
const sonja = {
  name: 'Sonja',
  v
  inventory: [
  ],
};

   And now we type p and we're ready for adventure:
const sonja = {
  name: 'Sonja',
  inventory: [
  v
  {name: 'sword', weight: 2.1, state: 'well kept'},
  ],
};

   Now you can save the file and if you have an autoformatter setup it'll fix your indentation or you
   can type == to manually format that line.

   What more can you do with cutting and pasting in Vim? Have you ever made a typo and need to swap two
   characters? Type dlp (or xp). Want to swap couple of lines? Type ddp. Want to swap a couple of
   paragraphs? Type dapp.

   Excellent! So now you've boosted your knowledge with yanking, cutting and pasting in Vim. But there's
   yet one crucial element left that we haven't even touched on yet: The mighty registers.

   A wonderful way to illustrate the impact of registers is swapping two values within Vim. I do some
   variant of this task incredibly often.

   Imagine that you have a couple of CSS variables that represent a couple of colors in a color theme of
   a beautiful website you've just designed:
:root {
  --red: #0F0;
  --green: #F00;
}

   You quickly notice the colors are wrong. You've mixed them. The red is the green and the green is the
   red. Oh no! What to do!?

   So you try swapping them using what we've just learned. You type /#<Enter> and put the cursor on top
   of the hexadecimal value:
  --red: #0F0;
         ^

   You cut it with daW:
  --red:
       ^

   Type n to move to the next hex value, delete it with daW and try to paste the red with p, but...
:root {
  --red:
  --green: #F00;
}

   What!? That is so not what I expected to happen. What did I do wrong?

   You may have noticed the issue with this swap as you were following the example but if you haven't I
   will tell you: The problem is that delete also cuts. When we deleted the hexadecimal value for the
   green color in the last step we literally overwrote the red hexadecimal value. That's why when we
   typed p at the end the pasted characters where #F00 and not #0F0 as we initially expected.

   But what did we overwrite exactly? Most systems have the concept of a clipboard, which is a place
   where you put the stuff that you copy and cut. Well Vim doesn't have a clipboard, Vim has registers.

Vim's Registers
   Vim registers are the equivalent of a clipboard, but since you have lots of them, they're that much
   powerful.

   When we use commands like y, d, c and p we're interacting with Vim's unnamed register. You aren't
   limited to that one though, you have 26 named registers, one for each letter of the alphabet, that
   you are free to use as you see fit.

   The way that you explicitly access a given register is by prefixing a command with "[a-z]. So:
     * "ayy yanks a line into the a register
     * "add cuts a line into the a register
     * "ap pastes from the a register

   Using the same pattern we can access the mysterious **unnamed register** which does have a name after
   all. Its name is " and you could replace y for ""y if you had a fancy for writing more than you need
   to. But we won't do that.

   Using the lowercase name of a named register overwrites its contents, whereas if we use the
   capitalized version of that name we will append whatever we yank or cut into the register (this can
   be really useful when we want to collect text into a register for later pasting).

   Using named registers offers one way to solve the problem that ailed us earlier when we were swapping
   colors. Instead of using the unnamed register alone we could've used it in combination with the a
   register:
    1. /#<Enter> to move the cursor to the first hex value
    2. daW to cut the green color value in the unnamed register
    3. n to move to the second hex value
    4. "adaW to cut it into the a named register
    5. p pastes the first hex value in the write place
    6. k to go up
    7. "ap which now pastes from the a register and we're done

   Excellent! If you ever lose track about which register you have put stuff in, you can rely on the
   :registers (or :reg) command. :registers will print the value of all registers into a buffer. If
   you're only interested in the contents of a particular register you can also specify it as an
   argument. For instance, typing :reg a after the previous example would result in the following:
--- Registers ---
"a    #F00;

   Another useful way to interact with named registers is by taking advantage of the fact that
   capitalized named registers append to the register instead of replacing its contents. For instance,
   we could build an outline of a markdown document by continously appending headers to the a register:
     * /^#.*<ENTER> to jump to the next header
     * "ayy to copy the header into the a register
     * n to jump to the next header
     * "Ayy to append the header to the contents of the a register
     * then n and "Ayy until you've gathered all the headers you want
     * "ap to paste the outline of the mardown document

   In addition to the named and unnamed registers there are more registers that will be useful from time
   to time: The yank register (0), the delete registers (1-9) and the black hole register (_).

   The yank register 0 holds the last bit of text you yanked. That is, it only stores text you have
   yanked with the y command and lives completely unperturbed by whatever happens with cutting
   operations like d or c. This can be really useful if you want to rename a variable or other pieces of
   text. Using the yank register offers yet another alternative way to swap values.

   The delete registers 1-9 are nine registers that contain the last 9 pieces of text you cut or
   deleted. They work as a queue where every time you cut something it gets stuck in the queue at
   position 1, whatever was in 1 is pushed to 2 and so on. The delete register can be really useful when
   you happen to delete something in the past and you want to bring it back (in fact, it just saved me
   from losing a beautifully written parapraph). Just like the named and yank registers, you can take
   advantage of delete registers as an alternative way to swap values.

   The black hole register has a fitting name because it truly allows you to delete text into oblivion.
   A nice way to avoid overwriting the unnamed register is to prefix the delete operator with the black
   hole register: For instance, type "_daw to blast a word into oblivion for ever and ever.

   For a list of all registers available in Vim and how you can use them take a look at :h registers.

Copy and Pasting In and Outside Of Vim
   Everything we've discussed thus far only applies to the world of Vim. All the commands and registers
   that we've seen allow you to yank, cut and paste text only within the confines of Vim. What happens
   when you want to copy to or paste from outside of Vim? For instance, when you find a wonderful piece
   of code on StackOverflow and want to try it in a program?

   There's two registers that work as an interface between Vim and the outside world: The + and the *
   registers.
     * You can use the + register to interact with the system clipboard in Windows, Mac and Linux
     * You can use the * register to interact with the primary clipboard in Linux, and also the system
       clipboard in Windows and Mac (since these two only have the single clipboard)

   One thing that I find super convenient and that I'd advise you to do is to have your system clipboard
   use the unnamed register. That way you can seamlessly copy and paste between Vim and the rest of your
   computer, taking advantage of the fastest commands d, c, y and p, and avoiding the need to specify
   the + and * registers.

   If you are using Neovim you can enable this behavior in your vimrc like so:
set clipboard+=unnamedplus " use system clipboard

   Likewise in traditional Vim:
set clipboard=unnamed " use system clipboard

   Take a look at :h clipboard for more information.

Pasting in Insert mode
   All of this article has focused on how you can copy and paste things from within Normal mode.
   Sometimes however, it can be helpful to paste things within Insert mode. Earlier you learned how you
   can paste using the p command but that won't do in Insert mode (it would just insert the letter p).
   What to do? Well, in some instances (f.i. gvim and mvim) you may be able to use your system
   copy/paste key bindings, but you can always rely on <C-R>{register} to paste text from any given
   register:
     * <C-R>a pastes the contents of the a register
     * <C-R>" pastes the contents of the unnamed register
     * <C-R>0 pastes the contents of the yank register.

   And yes, you've guessed it right, the R stands for Register. Use that as a mnemnonic and you'll never
   forget how to paste things in Insert mode.

A Really Cool Plugin To Simplify Working With Registers in Vim
   Before we part here is a really cool plugin that helps you work with register in Vim:
   vim-peekaboo. This plugin extends " and @ in normal mode and <CTRL-R> in insert mode so you can
   see the contents of the registers as you are about to perform a copying, cutting or pasting
   operation:
   A Vim user takes advantage of the peekaboo plugin to inspect whatʼs inside their registers before
   pasting

   Cool right?

   And that's all for today! Take care and have a wonderful day!
   Spread The Word. Share this article!


---
https://francopasut.medium.com/vim-cut-copy-and-paste-to-and-from-the-system-clipboard-e11da66ca95c

Vim: Cut, Copy and Paste to and from the system clipboard

1 Cut, Copy and Paste using the computer keyboard
   Everybody knows how to use the keyboard combinations Ctrl-c, Ctrl-x, and Ctrl-v in Windows and Linux
   (or Cmd-c, Cmd-x and Cmd-v in macOS) to copy, cut and paste text across applications.

   Many think that those combinations are universal and work with any application.

   But Vim and gVim are different, they use another system to exchange information with the rest of the
   IT world.

   For example, in Vim under Linux, the key combination Ctrl-v corresponds to the visual block function
   and does not affect the pasting text.

   I wrote this article to remind me, as a non-programmer, the key combinations to be used in the Vim
   world to share text with other applications.

2 Vim and the clipboard
   Vim uses an original resource to exchange text with other applications.

   If you press the Vim (or gVim) :reg command, you can notice a list of items beginning with a double
   quotation mark (") and followed by a symbol, a letter or a number: these are the registers.

   Vim uses a specific register to interact with the system clipboard and, consequently, with other
   applications.

   This specific clipboard register is identified with the mathematical plus symbol (+)

3 From Vim to the Clipboard
   If you need to transfer information from Vim to other environments you must use the key combination
   "+y to copy the text and "+x to cut it from the original document.

   As shown in the official menu visible in gVim:
   Image for post
   Image for post Image for post

   Then you have to press three keys in sequence:
    1. "
    2. +
    3. x or y

   In both cases, the cut or copied text is sent also to the clipboard and can be pasted outside Vim
   using the usual Ctrl-v command, in Windows and Linux, or Cmd-v in macOS.

4 From the Clipboard to Vim
   The reverse operation is also quite simple. You can transfer your text copied from the clipboard
   using the string "+gP.
   Image for post
   Image for post Image for post

   Let's analyze every single component of the string:

   "P" means paste before the current position.

   The "g" key puts the cursor after the pasted text.

   Then "gP" command produces the following result: Paste before the current position, placing the
   cursor after the pasted text.

   If you don't use g the cursor will be placed on the last letter of the pasted text and you'll waste
   time to advance the cursor by one character.

   In Vim philosophy everything must be optimized, also the single movements of the cursor!

5 Some key shortcuts in gVim
   In some cases, it is also possible to use key shortcuts in gVim.

   They mainly work in MS Windows but some of the work also in several Linux distributions. I can
   directly confirm the working in Mint, Fedora, Ubuntu, Antergos for the pasting shortcut (see list
   below) but not the same for the others.

   The following is the list of shortcuts:
     * Shift+Delete =Cut text and copy it in the clipboard
     * Ctrl+Insert =Copy text in the clipboard
     * Shift+Insert =Paste text from the clipboard into a document


---

