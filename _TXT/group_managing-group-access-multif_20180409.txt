filename: group_managing-group-access-multif_20180409.txt
https://unix.stackexchange.com/questions/116070/granting-write-permissions-to-a-group-to-a-folder

Granting write permissions to a group to a folder

   How can I grant write permission to 1 group ?
   I have 2 users (alex and ben).
   alex is member of group alex and of group consult.
   ben is member of group ben and of group consult.

   I want to grant read write access to both alex and ben on the folder consult_documents.

   If I make alex the owner of the directory consult_documents and I grant 775 access to the directory
   consult_documents, ben and alex will be able to access the folder, I think.

   But will this allow ben access to alex's other folders as well? If a user is in two groups, does that
   mean that all the members from both groups get the same permissions on all folders?

***
   Granting 775 permissions on a directory doesn't automatically mean that all users in a certain group
   will gain rwx access to it. They need to either be the owner of the directory or to belong to the
   directory's group:
$ ls -ld some_dir
drwxrwxr-x 2 alex consult 4096 Feb 20 10:10 some_dir/
              ^     ^
              |     |_____ directory's group
              |___________ directory's owner

   So, in order to allow both alex and ben to have write access to consult_documents, the
   consult_documents directory itself must belong to the consult group. If that's not the case, the
   directory's owner (alex in your example), should issue the following command:
$ chgrp consult consult_documents

   or to change group ownership of everything inside the directory:
$ chgrp -R consult consult_documents

   This will only work if alex is a member of the consult group, which seems to be the case in your
   example.

   This will not allow ben to access all of alex's directories for two reasons:
    1. Not all of alex's directories will belong to the consult group
    2. Some of alex's directories may belong to the consult group but alex may not have chosen to allow
       rwx group access to them.

   In short, the answer depends both on group ownership and on the group permission bits set for the
   directory.

   All of this is provided you don't use any additional [41]mandatory access control measures on your
   system.

***
   This will make alex and ben to colabrate each other in this Directory, And they can't collab in other
   Dir..

   Modify the User group using
# usermod -a -G alex,ben alex

   Then change the Permission for Folder
# chown alex:ben consult_documents

   Check here i have worked it around
$ sudo usermod -a -G alex,ben alex

$ sudo chown alex:ben consult_documents/

cd consult_documents/

$ touch babin

drwxrwxr-x 2 alex ben  4096 Feb 20 15:19 .
drwxr-xr-x 3 alex alex 4096 Feb 20 15:17 ..
-rw-rw-r-- 1 alex alex    0 Feb 20 15:19 babin

$ su - ben

cd /home/alex/consult_documents/

ben@system99:/home/alex/consult_documents$ touch babin1
ben@system99:/home/alex/consult_documents$ ls -la
total 8
drwxrwxr-x 2 alex ben  4096 Feb 20 15:19 .
drwxr-xr-x 3 alex alex 4096 Feb 20 15:17 ..
-rw-rw-r-- 1 alex alex    0 Feb 20 15:19 babin
-rw-rw-r-- 1 ben  ben     0 Feb 20 15:19 babin1
ben@system99:/home/alex/consult_documents$

***
   If I understood correctly your question, the answer is yes.

   Let me explain:

   Your folder and file access rights are divided into three categroies:
xxxyyyzzz
xxx are access rights for the owner
yyy are access rights for the owner's group
zzz are the access rights for everyone else

   Every file and folder must be owned by a user.

   Which means, if you have a folder named consult_documents, and you want it to be accessible from
   everyone of the group Consult, you will have this (with 755 access rights):
drwxrwxr-x Alex Consult [......]

   The directory is owned by Alex, and the group is Consult. Alex has RWX access rights on it. Group
   Consult has RWX access rights on it. Other users have RX rights.

   As your user Alex has several groups, you can choose the group to share with.

   For example, if your folder is owned by Alex from groupe Alex:
drwxrwxr-x Alex Alex [......]

   Do it:
chown Alex:Consult your_folder

   It will become:
drwxrwxr-x Alex Consult [......]

   And then the directory is available for the group Consult.

   Please note that, as far as I know, you can add a group that is not one of the owner's group. But I'm
   not sure if it is recommended (not clear when reading access rights).

***
   setfacl -m g:debian-transmission:rwx -R /mnt/sra

   Found this command nice, instead of chown that will change completly the owner of the file or
   directory!

   You will see on a 'ls -Al' that a + sign will be added to show that there is more than one owner!
     drwxr-xr-x 2 root root 4096 Nov 8 19:11 sdc1/
     drwxrwxr-x+ 3 root root 4096 Feb 17 19:16 sra/

   And then you can use getfacl to see who can write or read the file or directory!
     # file: sra
     # owner: root
     # group: root user::rwx
     group::r-x
     group:debian-transmission:rwx
     mask::rwx
     other::r-x
     default:user::rwx
     default:group::r-x
     default:group:debian-transmission:rwx
     default:mask::rwx
     default:other::r-x


---
https://superuser.com/questions/381416/forcing-group-and-permissions-for-created-file-inside-folder

Forcing group and permissions for created file inside folder?

   I need that for the folder /var/www when my user testuser creates a file the permissions are g+rwx
   and the files belong to the group www-data

   Any idea of how could I do that ?
   Cheers.

   To set the group, give /var/www the setgid bit:
chgrp www-data /var/www
chmod g+s /var/www

   To also adjust subdirectories: find /var/www -type d -exec chmod g+s {} +

   This will make all newly created files inherit the parent directory's group, instead of the user's.
     ________________________________________________________________________________________________

   To set the default group permissions, you will have to use ACLs. Set a "default" ACL:
setfacl -m "default:group::rwx" /var/www

   To also adjust subdirectories: find /var/www -type d -exec setfacl -m d:g::rwx {} +

   Note: The file system must have ACL support enabled. Sometimes it is on by default; on ext3 or ext4
   you might get "Operation not supported", in which case it must be enabled manually:
     * For a currently mounted filesystem: mount -o remount,acl /
     * Permanently – one of the methods below:
          + at fstab level: edit /etc/fstab to have acl in the options field
          + at filesystem level: tune2fs -o acl /dev/diskname

***
     * can't you get the subdirectories with chmod -R g+s /var/www? Doesn't seem like you should need
       the find command. – [46]bobpaul Jan 14 '14 at 0:56
     * 4
       @bobpaul: No, because chmod would also get all files. – [47]grawity Jan 14 '14 at 3:01

***
   This might have gotten a few people stuck with 'grawity' answer on setgid, if the folder's group is
   different from your own you may need to run chmod as root but you won't get any error indicating you
   need to do this.
$ ls -ld dir
drwxrwxr-x 2 luke testgroup 4096 Mar  9 10:44 dir

$ chmod g+s dir                                    #no errors

$ ls -ld dir
drwxrwxr-x 2 luke testgroup 4096 Mar  9 10:44 dir  #but nothing changed

$ touch dir/nosudo && ls -l dir/
-rw-rw-r-- 1 luke luke 0 Mar  9 10:51 nosudo       #and the group is still wrong

$ sudo chmod g+s dir
$ ls -ld dir
drwxrwsr-x 2 luke testgroup 4096 Mar  9 10:44 dir  #the setgid bit is now on

$ touch dir/withsudo && ls -l dir/
-rw-rw-r-- 1 luke luke      0 Mar  9 10:51 nosudo
-rw-rw-r-- 1 luke testgroup 0 Mar  9 10:51 withsudo #and group is set

***
   The group of the files being created by an user is the group of that user (in /etc/group). The
   permissions are controlled by the UMASK parameter [51]see this


---
http://www.wiomax.com/setting-multiple-groups-as-directory-owners-in-linux/

Setting permissions for one file/directory to multiple groups in Linux

   This post is a summary of (workaround) methods to have a file/directory owned by multiple Linux
   groups with traditional Unix permissions.
     * Access Control Lists (ACL)

   Each file or directory can only have one group as owner, but permissions can be defined for other
   groups using ACL.

   If your system hasn’t ACL installed, install the command line tools which are in the [41]acl package
   with:
sudo apt-get install acl

   Then with [42]getfacl you can read the ACL information of a directory or other file, and with
   setfacl you can add groups to a file.

   For example, to adds the group YourGroup with read, write, execute permissions to
   directory YourDirectory:
setfacl -m g:YourGroup:rwx /YourDirectory/

   If you also want files created in that directory to be owned by multiple groups, set the ACL as the
   default ACL. The X in the default group entry means “allow execution if executable by the owner (or
   anyone else)”.
setfacl -d -m g:YourGroup:rwX /YourDirectory/

     * “Super Group”

   The following workaround creates a new group SuperGroup that will include the users of a set of
   subgroups {SubGroup1, ..., SubGroupN}. You create and add users to these subgroups with:
sudo addgroup SuperGroup

sudo addgroup SubGroup1
...
sudo addgroup SubGroup1
sudo adduser NEWUSER SubGroup

   First, you might have to install id-utils to get the lid-command:
sudo apt-get install id-utils

   Then you can run the following line of code to easily copy all users of SourceGroup to TargeGroup. Of
   course you have to run the command once for each group you want to copy. Don’t forget to replace the
   capitalized place-holders with the actual group names.
for u in $(lid -g -n SourceGroup); do sudo usermod -a -G TargeGroup $u; done

   So in your case you would have to run the command (all lines at once):
sudo addgroup SuperGroup &&
for u in $(lid -g -n SubGroup1); do sudo usermod -a -G SuperGroup $u; done
...
for u in $(lid -g -n SubGroupN); do sudo usermod -a -G SuperGroup $u; done

   Note that these commands only copy all users who are current members of the source groups. Every user
   who gets added later will also have to be manually added to your common group with the adduser
   command. Just replace once again the capitalized place-holders with the actual user and group name:
sudo adduser NEWUSER SubGroup
sudo adduser NEWUSER SuperGroup


---
https://www.tecmint.com/manage-users-and-groups-in-linux/

Managing Users & Groups, File Permissions & Attributes and Enabling sudo Access on Accounts – Part 8
January 27, 2017

   Last August, the Linux Foundation started the LFCS certification (Linux Foundation Certified
   Sysadmin), a brand new program whose purpose is to allow individuals everywhere and anywhere take an
   exam in order to get certified in basic to intermediate operational support for Linux systems, which
   includes supporting running systems and services, along with overall monitoring and analysis, plus
   intelligent decision-making to be able to decide when it’s necessary to escalate issues to higher
   level support teams.
   
   Linux Users and Groups Management Linux Users and Groups Management
   
   Linux Foundation Certified Sysadmin – Part 8

   Please have a quick look at the following video that describes an introduction to the Linux
   Foundation Certification Program.

   IFRAME: [64]//www.youtube.com/embed/Y29qZ71Kicg

   This article is Part 8 of a 10-tutorial long series, here in this section, we will guide you on how
   to manage users and groups permissions in Linux system, that are required for the LFCS certification
   exam.

   Since Linux is a multi-user operating system (in that it allows multiple users on different computers
   or terminals to access a single system), you will need to know how to perform effective user
   management: how to add, edit, suspend, or delete user accounts, along with granting them the
   necessary permissions to do their assigned tasks.

Adding User Accounts
   To add a new user account, you can run either of the following two commands as root.
# adduser [new_account]
# useradd [new_account]

   When a new user account is added to the system, the following operations are performed.

   1. His/her home directory is created (/home/username by default).

   2. The following hidden files are copied into the user’s home directory, and will be used to provide
   environment variables for his/her user session.
.bash_logout
.bash_profile
.bashrc

   3. A mail spool is created for the user at /var/spool/mail/username.

   4. A group is created and given the same name as the new user account.

Understanding /etc/passwd
   The full account information is stored in the /etc/passwd file. This file contains a record per
   system user account and has the following format (fields are delimited by a colon).
[username]:[x]:[UID]:[GID]:[Comment]:[Home directory]:[Default shell]

    1. Fields [username] and [Comment] are self explanatory.
    2. The x in the second field indicates that the account is protected by a shadowed password (in
       /etc/shadow), which is needed to logon as [username].
    3. The [UID] and [GID] fields are integers that represent the User IDentification and the primary
       Group IDentification to which [username] belongs, respectively.
    4. The [Home directory] indicates the absolute path to [username]’s home directory, and
    5. The [Default shell] is the shell that will be made available to this user when he or she logins
       the system.

Understanding /etc/group
   Group information is stored in the /etc/group file. Each record has the following format.
[Group name]:[Group password]:[GID]:[Group members]

    1. [Group name] is the name of group.
    2. An x in [Group password] indicates group passwords are not being used.
    3. [GID]: same as in /etc/passwd.
    4. [Group members]: a comma separated list of users who are members of [Group name].

   Add User Accounts in Linux Add User Accounts in Linux

Add User Accounts
   After adding an account, you can edit the following information (to name a few fields) using the
   usermod command, whose basic syntax of usermod is as follows.
# usermod [options] [username]

Setting the expiry date for an account
   Use the –expiredate flag followed by a date in YYYY-MM-DD format.
# usermod --expiredate 2014-10-30 tecmint

Adding the user to supplementary groups
   Use the combined -aG, or –append –groups options, followed by a comma separated list of groups.
# usermod --append --groups root,users tecmint

Changing the default location of the user’s home directory
   Use the -d, or –home options, followed by the absolute path to the new home directory.
# usermod --home /tmp tecmint

Changing the shell the user will use by default
   Use –shell, followed by the path to the new shell.
# usermod --shell /bin/sh tecmint

Displaying the groups an user is a member of
# groups tecmint
# id tecmint

   Now let’s execute all the above commands in one go.
# usermod --expiredate 2014-10-30 --append --groups root,users --home /tmp --shell /bin/sh tecmint

   In the example above, we will set the expiry date of the tecmint user account to October 30th, 2014.
   We will also add the account to the root and users group. Finally, we will set sh as its default
   shell and change the location of the home directory to /tmp:

   For existing accounts, we can also do the following.

Disabling account by locking password
   Use the -L (uppercase L) or the –lock option to lock a user’s password.
# usermod --lock tecmint

Unlocking user password
   Use the –u or the –unlock option to unlock a user’s password that was previously blocked.
# usermod --unlock tecmint

Creating a new group for read and write access to files that need to be accessed by several users
   Run the following series of commands to achieve the goal.
# groupadd common_group # Add a new group
# chown :common_group common.txt # Change the group owner of common.txt to common_group
# usermod -aG common_group user1 # Add user1 to common_group
# usermod -aG common_group user2 # Add user2 to common_group
# usermod -aG common_group user3 # Add user3 to common_group

Deleting a group
   You can delete a group with the following command.
# groupdel [group_name]

   If there are files owned by group_name, they will not be deleted, but the group owner will be set to
   the GID of the group that was deleted.

Linux File Permissions
   Besides the basic read, write, and execute permissions that we discussed in [70]Archiving Tools and
   Setting File Attributes – Part 3 of this series, there are other less used (but not less important)
   permission settings, sometimes referred to as “special permissions”.

   Like the basic permissions discussed earlier, they are set using an octal file or through a letter
   (symbolic notation) that indicates the type of permission.

Deleting user accounts
   You can delete an account (along with its home directory, if it’s owned by the user, and all the
   files residing therein, and also the mail spool) using the userdel command with the –remove option.
# userdel --remove [username]

Group Management
   Every time a new user account is added to the system, a group with the same name is created with the
   username as its only member. Other users can be added to the group later. One of the purposes of
   groups is to implement a simple access control to files and other system resources by setting the
   right permissions on those resources.

   For example, suppose you have the following users.
    1. user1 (primary group: user1)
    2. user2 (primary group: user2)
    3. user3 (primary group: user3)

   All of them need read and write access to a file called common.txt located somewhere on your local
   system, or maybe on a network share that user1 has created. You may be tempted to do something like,
# chmod 660 common.txt
OR
# chmod u=rw,g=rw,o= common.txt [notice the space between the last equal sign and the file name]

   However, this will only provide read and write access to the owner of the file and to those users who
   are members of the group owner of the file (user1 in this case). Again, you may be tempted to add
   user2 and user3 to group user1, but that will also give them access to the rest of the files owned by
   user user1 and group user1.

   This is where groups come in handy, and here’s what you should do in a case like this.

Understanding Setuid
   When the setuid permission is applied to an executable file, an user running the program inherits the
   effective privileges of the program’s owner. Since this approach can reasonably raise security
   concerns, the number of files with setuid permission must be kept to a minimum. You will likely find
   programs with this permission set when a system user needs to access a file owned by root.

   Summing up, it isn’t just that the user can execute the binary file, but also that he can do so with
   root’s privileges. For example, let’s check the permissions of /bin/passwd. This binary is used to
   change the password of an account, and modifies the /etc/shadow file. The superuser can change
   anyone’s password, but all other users should only be able to change their own.

   Thus, any user should have permission to run /bin/passwd, but only root will be able to specify an
   account. Other users can only change their corresponding passwords.

Understanding Setgid
   When the setgid bit is set, the effective GID of the real user becomes that of the group owner. Thus,
   any user can access a file under the privileges granted to the group owner of such file. In addition,
   when the setgid bit is set on a directory, newly created files inherit the same group as the
   directory, and newly created subdirectories will also inherit the setgid bit of the parent directory.
   You will most likely use this approach whenever members of a certain group need access to all the
   files in a directory, regardless of the file owner’s primary group.
# chmod g+s [filename]

   To set the setgid in octal form, prepend the number 2 to the current (or desired) basic permissions.
# chmod 2755 [directory]

Setting the SETGID in a directory

Understanding Sticky Bit
   When the “sticky bit” is set on files, Linux just ignores it, whereas for directories it has the
   effect of preventing users from deleting or even renaming the files it contains unless the user owns
   the directory, the file, or is root.
# chmod o+t [directory]

   To set the sticky bit in octal form, prepend the number 1 to the current (or desired) basic
   permissions.
# chmod 1755 [directory]

   Without the sticky bit, anyone able to write to the directory can delete or rename files. For that
   reason, the sticky bit is commonly found on directories, such as /tmp, that are world-writable.

Special Linux File Attributes
   There are other attributes that enable further limits on the operations that are allowed on files.
   For example, prevent the file from being renamed, moved, deleted, or even modified. They are set with
   the [75]chattr command and can be viewed using the lsattr tool, as follows.
# chattr +i file1
# chattr +a file2

   After executing those two commands, file1 will be immutable (which means it cannot be moved, renamed,
   modified or deleted) whereas file2 will enter append-only mode (can only be open in append mode for
   writing).

Accessing the root Account and Using sudo
   One of the ways users can gain access to the root account is by typing.
$ su

   and then entering root’s password.

   If authentication succeeds, you will be logged on as root with the current working directory as the
   same as you were before. If you want to be placed in root’s home directory instead, run.
$ su -

   and then enter root’s password.

   The above procedure requires that a normal user knows root’s password, which poses a serious security
   risk. For that reason, the sysadmin can configure the sudo command to allow an ordinary user to
   execute commands as a different user (usually the superuser) in a very controlled and limited way.
   Thus, restrictions can be set on a user so as to enable him to run one or more specific privileged
   commands and no others.

   To authenticate using sudo, the user uses his/her own password. After entering the command, we will
   be prompted for our password (not the superuser’s) and if the authentication succeeds (and if the
   user has been granted privileges to run the command), the specified command is carried out.

   To grant access to sudo, the system administrator must edit the /etc/sudoers file. It is recommended
   that this file is edited using the visudo command instead of opening it directly with a text editor.
# visudo

   This opens the /etc/sudoers file using vim (you can follow the instructions given in [79]Install and
   Use vim as Editor – Part 2 of this series to edit the file).

   These are the most relevant lines.
Defaults    secure_path="/usr/sbin:/usr/bin:/sbin"
root        ALL=(ALL) ALL
tecmint     ALL=/bin/yum update
gacanepa    ALL=NOPASSWD:/bin/updatedb
%admin      ALL=(ALL) ALL

   Let’s take a closer look at them.
Defaults    secure_path="/usr/sbin:/usr/bin:/sbin:/usr/local/bin"

   This line lets you specify the directories that will be used for sudo, and is used to prevent using
   user-specific directories, which can harm the system.

   The next lines are used to specify permissions.
root        ALL=(ALL) ALL

    1. The first ALL keyword indicates that this rule applies to all hosts.
    2. The second ALL indicates that the user in the first column can run commands with the privileges
       of any user.
    3. The third ALL means any command can be run.

tecmint     ALL=/bin/yum update

   If no user is specified after the = sign, sudo assumes the root user. In this case, user tecmint will
   be able to run yum update as root.
gacanepa    ALL=NOPASSWD:/bin/updatedb

   The NOPASSWD directive allows user gacanepa to run /bin/updatedb without needing to enter his
   password.
%admin      ALL=(ALL) ALL

   The % sign indicates that this line applies to a group called “admin”. The meaning of the rest of the
   line is identical to that of an regular user. This means that members of the group “admin” can run
   all commands as any user on all hosts.

   To see what privileges are granted to you by sudo, use the “-l” option to list them.

PAM (Pluggable Authentication Modules)
   Pluggable Authentication Modules (PAM) offer the flexibility of setting a specific authentication
   scheme on a per-application and / or per-service basis using modules. This tool present on all modern
   Linux distributions overcame the problem often faced by developers in the early days of Linux, when
   each program that required authentication had to be compiled specially to know how to get the
   necessary information.

   For example, with PAM, it doesn’t matter whether your password is stored in /etc/shadow or on a
   separate server inside your network.

   For example, when the login program needs to authenticate a user, PAM provides dynamically the
   library that contains the functions for the right authentication scheme. Thus, changing the
   authentication scheme for the login application (or any other program using PAM) is easy since it
   only involves editing a configuration file (most likely, a file named after the application, located
   inside /etc/pam.d, and less likely in /etc/pam.conf).

   Files inside /etc/pam.d indicate which applications are using PAM natively. In addition, we can tell
   whether a certain application uses PAM by checking if it the PAM library (libpam) has been linked to
   it:
# ldd $(which login) | grep libpam # login uses PAM
# ldd $(which top) | grep libpam # top does not use PAM

   In the above image we can see that the libpam has been linked with the login application. This makes
   sense since this application is involved in the operation of system user authentication, whereas top
   does not.

   Let’s examine the PAM configuration file for passwd – yes, the well-known utility to change user’s
   passwords. It is located at /etc/pam.d/passwd:
# cat /etc/passwd

   The first column indicates the type of authentication to be used with the module-path (third column).
   When a hyphen appears before the type, PAM will not record to the system log if the module cannot be
   loaded because it could not be found in the system.

   The following authentication types are available:
    1. account: this module type checks if the user or service has supplied valid credentials to
       authenticate.
    2. auth: this module type verifies that the user is who he / she claims to be and grants any needed
       privileges.
    3. password: this module type allows the user or service to update their password.
    4. session: this module type indicates what should be done before and/or after the authentication
       succeeds.

   The second column (called control) indicates what should happen if the authentication with this
   module fails:
    1. requisite: if the authentication via this module fails, overall authentication will be denied
       immediately.
    2. required is similar to requisite, although all other listed modules for this service will be
       called before denying authentication.
    3. sufficient: if the authentication via this module fails, PAM will still grant authentication even
       if a previous marked as required failed.
    4. optional: if the authentication via this module fails or succeeds, nothing happens unless this is
       the only module of its type defined for this service.
    5. include means that the lines of the given type should be read from another file.
    6. substack is similar to includes but authentication failures or successes do not cause the exit of
       the complete module, but only of the substack.

   The fourth column, if it exists, shows the arguments to be passed to the module.

   The first three lines in /etc/pam.d/passwd (shown above), load the system-auth module to check that
   the user has supplied valid credentials (account). If so, it allows him / her to change the
   authentication token (password) by giving permission to use passwd (auth).

   For example, if you append
remember=2

   to the following line
password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok

   in /etc/pam.d/system-auth:
password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok remember=2

   the last two hashed passwords of each user are saved in /etc/security/opasswd so that they cannot be
   reused:

Summary
   Effective user and file management skills are essential tools for any system administrator. In this
   article we have covered the basics and hope you can use it as a good starting to point to build upon.
   Feel free to leave your comments or questions below, and we’ll respond quickly.


---
https://superuser.com/questions/144984/setting-permissions-for-specific-user-and-groups-in-linux

Setting permissions for specific user and groups in Linux

   How can I grant permission for files to a specific user or a specific group?

   We have three groups: "g12" ("u1" and "u2), "g34" and "g56".
     * g12 - should only read the file.
     * g34 - should write and read it.
     * g56 - should have all permissions (rwx).

   And others should not access the file at all.

***
     * I agree with @webdestroya, and additionally I'd strongly advice you to read my answer. I takes
       care of your update too. With Access Control Lists you get what you fine grained control on file
       and directory access. – [38]Peter Jaric May 31 '10 at 19:47

***
   You need to use Access Control Lists. They are a more advanced way of handling permissions than the
   default user/group/other way in Linux. See this page for example: [42]Ubuntu Access Control Lists

   An example from that page:
setfacl -m u:mike:rwx file or directory

   I've only used these commands in a lab on an server adminstration course myself, but as far as I
   could see, it's a pretty easy way to do it.

***
   As root:
chown u1:u1 f1.txt
chmod 400 f1.txt

   This will ensure that the file is owned by user u1 (chown) and group u1 (assuming that user u1's
   default group is u1) and that only that user can read the file (chmod). If you would like the user to
   be able to write to the file, change 400 to 600.

   You can add a second user to the default group of the first user with:
useradd -G u1 u2

   The above command assumes that user u1's default group is also called u1 and the second user is u2.

   Now we change the permissions on f1.txt to allow members of group u1 read access (the second "4" in
   400 is group permissions):
chmod 440 f1.txt

   Each of the three digits following the chmod command represents the permissions for the owner (first
   digit), the group (second digit), and all other users (third digit) on the system. A value of 1 is
   the execute permission, 2 is the write permission and 4 is the read permission. You add add these
   numbers together to "mix" these three types of permissions. Example, 4 (read) + 1 (execute) = 5, so
   to allow the owner and the group to read and execute the file but restrict access to everyone else
   you would use 550, to allow the owner to read and write to the file and the group and all other users
   to read the file, you would use 644.

   There are other formats to setting permissions, type:
man chmod

   at the command prompt for more details.
   [46]share|[47]improve this answer
   [48]edited May 25 '10 at 10:38
   answered May 25 '10 at 9:44
   [49]Stacey Richards
   1,162810
     * Thanks. OK, and how can i grant to "u2" the same right ? Should i use "chown u2:u2 f1.txt &&
       chmod ..." ?? I really, don't understand the main conception ... For example, when i asking my
       friend to bring something from my home, i give them a key. But i don't present my home to he :)
       – [50]AntonAL May 25 '10 at 9:53
     * That would change the owner to u2 and the group to user u2's default group. If you do that and
       chmod 400 then u1 would no longer be able to access the file. I've added some more detail to my
       answer, hope that helps. – [51]Stacey Richards May 25 '10 at 10:39
     * See my answer for a way to add a user without removing the existing ones. It should work at least
       if you are running Ubuntu. – [52]Peter Jaric May 25 '10 at 18:12
     * Thanks, now i understood the main idea. But, as far, as i understand it - changing permission is
       performed in scope of only ONE group. In our example, u1 and u2 are in one group, say "g12". But,
       what, if another group "g34" is coming (u3 and u4), that must have different permissions ? To
       completely figure this question out, please say, how to solve the task, described in my question
       (updated) – [53]AntonAL May 27 '10 at 13:55

***
   short answer is, you can't

   you don't set permissions for groups or users, you set permissions for files. A file has an owner and
   a group, and you can set the "read" "write" and "execute" permissions seperately for one user, one
   group, and everyone else.

   Can you give an example of what it is you're wanting to do?

***
     * Sorry, i wrote my question not correct. I want to grant, say, only read permission for file
       (f1.txt) only for one user "u1" – [57]AntonAL May 25 '10 at 8:57
     * corrected my question – [58]AntonAL May 25 '10 at 8:58
     * I have read man, but i don't understood it. It states only about groups, users, owners and other.
       How can i exactly specify, to which group (or user) i grant permission to ? – [59]AntonAL May 25
       '10 at 9:01
     * A file has one owner, and one owning group, which you can see when doing ls -l and change with
       chown. You set the permissions for this user and this group (and all others). – [60]DevSolar May
       25 '10 at 11:48

***
   I think what you want done is in how you organize your groups.

   I'm relatively new to Linux but from what I understand, you can make some new groups. Say something
   like AccessLow and AccessAll. Let's say you want Jim to access all, then you just put Jim in that
   group. Then you give that specific directory you want them to have access to the group ownership of
   AccessAll. Then say what you want them to be able to do with chmod (if you want them to access it
   with execute, just give them Chmod 750. This gives owner full control while AccessAll group only has
   Read and Execute ability but cannot write to the folder. If you want a folder to have limited access,
   then use group ownership to AccessLow and do your appropriate mode for what you want them to be able
   to do. I think this will work knowing what I know. If a new person comes along you want to give
   access to, you can simply consider then "Other" and give specific chmod to allow them to just read
   but if you want them to do a little more than what "Other" specifies but still want to have some
   things still concealed then I suggest putting them in a group that has the ability to do a little
   more but not as low access as "Other". It takes a little setting up but seems to be able to do what
   you are looking for. It's all I know from what I was reading here in searching for a way to change
   ownership myself for something very similar. Using Ubuntu server, I was limited to changing those
   parameters, but found out in the process and ended up deciding to write about what I think could
   work.

   EDIT: In thinking about this, I wonder if there is a way to assign people to more than one group
   cause I have come up with some idea now to do a different type of share in Samba. I may research this
   later and get my own answer. But in Windows, you are able to do so, so think it may be somehow
   possible here. It would be nice to say people currently with my domain access to be able to have most
   permissions available to them while someone authenticated but not in domain only has read abilities
   and maybe execute with no writing at all, etc. I think it could be possible by making them specific
   but generalized login names as well. Like to access my music directory, can just make a login called
   "music" (with an easy password) that is already set up in Samba to be able to access the specific
   directory Music with full read ability and won't see nothing else.


---
https://linode.com/docs/tools-reference/linux-users-and-groups/

Linux Users and Groups
March 23, 2017

If you are new to Linux/Unix, then the concept of permissions may be confusing. This guide will provide you
with an explanation of what permissions are, how they work, and how to manage them. A number of examples will
be provided to illustrate how to set and change permissions for both users and groups.

What are User and Group Permissions?
Linux/Unix operating systems have the ability to multitask in a manner similar to other operating systems.
However, Linux’s major difference from other operating systems is its ability to have multiple users. Linux
was designed to allow more than one user to have access to the system at the same time. In order for this
multiuser design to work properly, there needs to be a method to protect users from each other. This is where
permissions come in to play.

Read, Write & Execute Permissions
Permissions are the “rights” to act on a file or directory. The basic rights are read, write, and execute.

  - Read - a readable permission allows the contents of the file to be viewed. A read permission on a
    directory allows you to list the contents of a directory.
  - Write - a write permission on a file allows you to modify the contents of that file. For a directory, the
    write permission allows you to edit the contents of a directory (e.g. add/delete files).
  - Execute - for a file, the executable permission allows you to run the file and execute a program or
    script. For a directory, the execute permission allows you to change to a different directory and make it
    your current working directory. Users usually have a default group, but they may belong to several
    additional groups.

Viewing File Permissions
To view the permissions on a file or directory, issue the command ls -l <directory/file>. Remember to replace
the information in the < > with the actual file or directory name. Below is sample output for the ls command:

-rw-r--r-- 1 root root 1031 Nov 18 09:22 /etc/passwd

The first ten characters show the access permissions. The first dash (-) indicates the type of file (d for
directory, s for special file, and - for a regular file). The next three characters (rw-) define the owner’s
permission to the file. In this example, the file owner has read and write permissions only. The next three
characters (r–) are the permissions for the members of the same group as the file owner (which in this
example is read only). The last three characters (r–) show the permissions for all other users and in this
example it is read only.

Working with Users, Groups, and Directories

The following sections will go over the commands needed to create, delete, and modify user accounts. Groups
will be covered, as well as commands for creating and deleting directories. You will be provided with the
commands and descriptions needed for working with users, groups, and directories.

Creating and Deleting User Accounts

To create a new standard user, use the useradd command. The syntax is as follows:

useradd <name>

The useradd command utilizes a variety of variables, some of which are shown in the table below:

Option          Description                                                   Example
-d <home_dir>   home_dir will be used as the value for the user’s login dir   useradd <name> -d /home/<user's home>
-e <date>       the date when the account will expire                         useradd <name>** -e <YYYY-MM-DD>
-f <inactive>   the number of days before the account expires                 useradd <name> -f <0 or -1> 
-s <shell>      sets the default shell type                                   useradd <name> -s /bin/<shell>

You will need to set a password for the new user by using the passwd command. Note, you will need root
privileges to change a user password. The syntax is as follows:

passwd <username>

The user will be able to change their password at any time using the passwd command with the syntax. Below is
an example:

$ passwd
Changing password for lmartin.
(current) UNIX password:
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully

There is another way of creating user accounts that might be easier for first-time administrators. However,
you may need to install a new package. The installation command for Debian/Ubuntu is as follows:

apt-get install adduser

The adduser command automatically creates a home directory and sets the default group, shell, etc. To create
a new standard user with the adduser command the syntax is as follows:

adduser <name>

Once you enter the command you will receive a series of prompts; most of this information is optional.
However, you should include at least the user’s name (for this example the user name is cjones) and of course
a password.

root@localhost:~# adduser cjones
  Adding user `cjones' ...
  Adding new group `cjones' (1001) ...
  Adding new user `cjones' (1001) with group `cjones' ...
  Creating home directory `/home/cjones' ...
  Copying files from `/etc/skel' ...
  Enter new UNIX password:
  Retype new UNIX password:
  passwd: password updated successfully
  Changing the user information for cjones
  Enter the new value, or press ENTER for the default
      Full Name []: Chuck Jones
      Room Number []: 213
      Work Phone []: 856-555-1212
      Home Phone []:
      Other []:
  Is the information correct? [Y/n] Y

It is important to note that security should always be taken very seriously. Therefore, it is strongly
recommended to use unique passwords for each account. Never share or give your password to other users.

To remove a user account, enter the following command:
userdel <name>

Issuing the command above will only delete the user’s account. Their files and home directory will not be
deleted.

To remove the user, their home folder, and their files, use this command:
userdel -r <name>

Understanding Sudo
Root is the super user and has the ability to do anything on a system. Therefore, in order to have protection
against potential damage sudo is used in place of root. Sudo allows users and groups access to commands they
normally would not be able to use. Sudo will allow a user to have administration privileges without logging
in as root. A sample of the sudo command is as follows:
sudo apt-get install <package>

Before using sudo, it may need to be installed if it is not part of your distribution. The command for Debian
is as follows:
apt-get install sudo

For CentOS, the command is as follows:
yum install sudo

In order to provide a user with sudo ability, their name will need to be added to the sudoers file. This file
is very important and should not be edited directly with a text editor. If the sudoers file is edited
incorrectly it could result in preventing access to the system.

Therefore the visudo command should be used to edit the sudoers file. At a command line, log into your system
as root and enter the command visudo.

Below is the portion of the sudoers file that shows the users with sudo access.
# User privilege specification
root    ALL=(ALL:ALL) ALL
cjones  ALL=(ALL:ALL) ALL
kbrown  ALL=(ALL:ALL) ALL
lmartin ALL=(ALL:ALL) ALL

After you have given your user account sudo privileges, save the sudoers file and log out as root. Now log in
as your user and test the privileges as your user with sudo access. When a new user needs sudo access, you
will now be able to edit the sudoers file with your own login using the following command:
sudo visudo

Working with Groups
Linux uses groups as a way to organize users. Groups organize collections of accounts, primarily as a
security measure. Control of group membership is administered through the /etc/group file, which shows a list
of groups and its members. Every user has a default or primary group. When a user logs in, the group
membership is set for their primary group. This means that when a user launches a program or creates a file,
both the file and the running program will be associated with the user’s current group membership. A user may
access other files in other groups, as long as they are also a member of that group and the access
permissions are set. To run programs or create a file in a different group, the user must run the newgrp
command to switch their current group. A sample of the newgrp command is as follows:

$ newgrp <marketing>
If the user entering the above-referenced command is a member of the marketing group in the /etc/group file,
then the current group membership will change. It is important to note that any files created will now be
associated with the marketing group rather than the user’s primary group. Users may also change their group
by using the chgrp command. The syntax for the chgrp command is as follows:
$ chgrp <newgroup>

Creating and Removing Directories
To make a directory use the command:
mkdir <directory name>

To make a directory and set the permissions at the same time, use the following option and syntax:
mkdir -m a=rwx <directory name>

The -m option is short for mode, and a=rwx means that all users have read, write, and execute permissions on
the directory. To see a complete list of all options for the mkdir command enter man mkdir at a command
prompt.

To remove a file, use the following:
rm <file>

To remove a directory:
rm -r <directory name>

It is important to note that if you remove a directory all the files inside will be deleted as well.

Changing Directory and File Permissions
To view file permissions and ownership on files and directories, use the ls -al command. The a option is to
show hidden files or all files, and the l option is for the long listing. The output will be similar to the
following:

drwxr-xr-x 2 user user 4096 Jan  9 10:11 documents
-rw-r--r-- 1 user user  675 Jan  7 12:05 .profile
drwxr-xr-x 4 user user 4096 Jan  7 14:55 public

The first column with the ten letters and dashes shows the permissions of the file or directory. The second
column (with the single number) indicates the number of files or directories contained in the directory. The
next column indicates the owner, followed by the group name, the size, date, and time of last access, and
finally the name of the file . For example, using the first line from the output above, the details are as
follows:
`drwxr-xr-x` are the permissions
`2` is the number of files or directories
`user` is the owner
`user` is the group
`4096` is the size
`Jan  9 10:11` is the date/time of last access
`documents` is the directory

    Note
    Since a directory itself is a file, any directory will always show 4096 as it’s size. This does not
    reflect the size of the contents of the directory.

Chmod Command
The command chmod is short for change mode. Chmod is used to change permissions on files and directories. The
command chmod may be used with either letters or numbers (also known as octal) to set the permissions. The
letters used with chmod are in the table below:

Letter Permission
r      Read
w      Write
x      Execute
X      Execute (only if file is a directory)
s      Set user or group ID on execution
t      Save program text on swap device
u      Current permissions the file has for owner
g      Current permissions the file has for users in the same group
o      Current permissions the file has for others not in the group

It is important to remember that the first character of the first column of a file listing denotes whether it
is a directory or a file. The other nine characters are the permissions for the file/directory. The first
three characters are for the user, the next three are for the group, and the last three are for others. The
example drwxrw-r– is broken down as follows:
    d is a directory
    rwx the user has read, write, and execute permissions
    rw- the group has read and write permissions
    r– all others have read only permissions

Note that the dash (-) denotes permissions are removed. Therefore, with the “all others” group, r– translates
to read permission only, the write and execute permissions were removed.

Conversely, the plus sign (+) is equivalent to granting permissions: chmod u+r,g+x <filename>

The example above translates as follows:
u is for user
r is for read
g is for group
x is for execute

In other words, the user was given read permission and the group was given execute permission for the file.
Note, when setting multiple permissions for a set, a comma is required between sets.

Chmod Octal Format
To use the octal format, you have to calculate the permissions for each portion of the file or directory. The
first ten characters mentioned above will correspond to a four digit numbers in octal. The execute permission
is equal to the number one (1), the write permission is equal to the number two (2), and the read permission
is equal to the number four (4). Therefore, when you use the octal format, you will need to calculate a
number between 0 and 7 for each portion of the permission. A table has been provided below for clarification.

Octal format for permissions.
Although octal format may seem difficult to understand, it is easy to use once you get the gist of it.
However, setting permissions with r, w, and x may be easier. Below are examples of how to use both letters
and octal format to set permissions on a file or directory.
    Sample syntax: chmod <octal or letters> <file/directory name>
    Letter format: chmod go-rwx Work (Deny rwx permission for the group and others)

The output of ls -al after the chmod command above would looks as follows:
dr-------- 2 user user 4096 Dec 17 14:38 Work

Octal format: chmod 444 Work

The output of ls -al after the chmod command above would look as follows:
dr--r--r-- 2 user user 4096 Dec 17 14:38 Work

An octal table showing the numeric equivalent for permissions is provided below.

Letter	Permission
r	    Read
w	    Write
x	    Execute
X	    Execute (only if file is a directory)
s	    Set user or group ID on execution
t	    Save program text on swap device
u	    Current permissions the file has for owner
g	    Current permissions the file has for users in the same group
o	    Current permissions the file has for others not in the group

Additional File Permissions
In addition to the most common read/write/execute file permissions, there are some additional modes that you
might find useful, specifically the +t mode (sticky bit) and the +s mode (setuid bit). These functions
describe the behavior of files and executables in multi-user situations.

When set on a file or directory, the sticky bit, or +t mode, means that only the owner (or root) can delete
the file, regardless of which users have write access to this file/directory by way of group membership or
ownership. This is useful when a file or directory is owned by a group through which a number of users share
write access to a given set of files.

To set the sticky bit on a file named /root/sticky.txt, issue the following command:
chmod +t /root/sticky.txt

To remove the sticky bit from a file, use the chmod -t command. Note, to change the sticky bit, you need to
be either root or the file owner. The root user will be able to delete files regardless of the status of the
sticky bit.

The setuid bit, or +s, when set on files allows users with permissions to execute a given file the ability to
run that file with the permissions of file owner. For instance, if the file work was owned by the root user
and the marketing group, members of the marketing group could run the work program as if they were the root
user. This may pose potential security risks in some cases and executables should be properly evaluated
before receiving the +s flag. To set the +s bit on a file named /usr/bin/work, issue the following command:
chmod g+s /usr/bin/work

In contrast to the +s mode for the ownership of a file, the effect of the +s mode on a directory is somewhat
different. Files created in +s directories receive the ownership of that directory’s user and group, rather
than the ownership of the user that created the file and their default group. To set the setguid (group id)
option on a directory, use the following command:
chmod g+s /var/doc-store/

To set the setuid (user id) for a directory named /var/doc-store, issue the following command:
chmod u+s /var/doc-store/

Changing File Ownership
By default, all files are “owned” by the user who creates them and by that user’s default group. To change
the ownership of a file, use the chown command in the chown user:group /path/to/file format. In the following
example, the ownership of the “list.html” file will be changed to the “cjones” user in the “marketing” group:

chown cjones:marketing list.html
To change the ownership of a directory and all the files contained inside, use the recursive option with the
-R flag. In the following example, change the ownership of /srv/smb/leadership/ to the “cjones” user in the
“marketing” group:
chown -R cjones:marketing /srv/smb/leadership/

Leveraging Users and Groups
In many cases, user permissions are used to provide your system with greater security without any direct
interaction. Many operating systems create specific system user accounts for different packages during the
installation process.

The best practice is to give each user their own login to your system. This protects each user’s files from
all other users. Furthermore, using specific accounts for users allows more accurate system logging,
particularly when combined with tools like sudo. We recommend avoiding situations where more than one
individual knows the password for a user account for maximum security.

In contrast, groups are useful for allowing multiple independent user accounts to collaborate and share
files. If you create groups on a machine for common tasks on a per-task basis (e.g. web editors,
contributors, content submitters, support) and add relevant users to the relevant groups, these users can all
edit and run the same set of files without sharing these files with the world. Use of the chown command with
file permissions of 770 and 740 would help accomplish this goal.


---
https://wiki.archlinux.org/index.php/users_and_groups 

Users and groups
From ArchWiki

Users and groups are used on GNU/Linux for access control—that is, to control access to the system's files,
directories, and peripherals. Linux offers relatively simple/coarse access control mechanisms by default. For
more advanced options, see ACL and PAM#Configuration How-Tos.

Overview
A user is anyone who uses a computer. In this case, we are describing the names which represent those users.
It may be Mary or Bill, and they may use the names Dragonlady or Pirate in place of their real name. All that
matters is that the computer has a name for each account it creates, and it is this name by which a person
gains access to use the computer. Some system services also run using restricted or privileged user accounts.

Managing users is done for the purpose of security by limiting access in certain specific ways. The superuser
(root) has complete access to the operating system and its configuration; it is intended for administrative
use only. Unprivileged users can use the su and sudo programs for controlled privilege escalation.

Any individual may have more than one account as long as they use a different name for each account they
create. Further, there are some reserved names which may not be used such as "root".

Users may be grouped together into a "group", and users may be added to an existing group to utilize the
privileged access it grants.

Note: The beginner should use these tools carefully and stay away from having anything to do with any other
existing user account, other than their own.

Permissions and ownership

From In UNIX Everything is a File:
    The UNIX operating system crystallizes a couple of unifying ideas and concepts that shaped its design,
    user interface, culture and evolution. One of the most important of these is probably the mantra:
    "everything is a file," widely regarded as one of the defining points of UNIX.

    This key design principle consists of providing a unified paradigm for accessing a wide range of input/
    output resources: documents, directories, hard-drives, CD-ROMs, modems, keyboards, printers, monitors,
    terminals and even some inter-process and network communications. The trick is to provide a common
    abstraction for all of these resources, each of which the UNIX fathers called a "file." Since every
    "file" is exposed through the same API, you can use the same set of basic commands to read/write to a
    disk, keyboard, document or network device.

From Extending UNIX File Abstraction for General-Purpose Networking:
    A fundamental and very powerful, consistent abstraction provided in UNIX and compatible operating systems
    is the file abstraction. Many OS services and device interfaces are implemented to provide a file or file
    system metaphor to applications. This enables new uses for, and greatly increases the power of, existing
    applications — simple tools designed with specific uses in mind can, with UNIX file abstractions, be used
    in novel ways. A simple tool, such as cat, designed to read one or more files and output the contents to
    standard output, can be used to read from I/O devices through special device files, typically found under
    the /dev directory. On many systems, audio recording and playback can be done simply with the commands,
    "cat /dev/audio > myfile" and "cat myfile > /dev/audio," respectively.

Every file on a GNU/Linux system is owned by a user and a group. In addition, there are three types of access
permissions: read, write, and execute. Different access permissions can be applied to a file's owning user,
owning group, and others (those without ownership). One can determine a file's owners and permissions by
viewing the long listing format of the ls command:

$ ls -l /boot/
total 13740
drwxr-xr-x 2 root root    4096 Jan 12 00:33 grub
-rw-r--r-- 1 root root 8570335 Jan 12 00:33 initramfs-linux-fallback.img
-rw-r--r-- 1 root root 1821573 Jan 12 00:31 initramfs-linux.img
-rw-r--r-- 1 root root 1457315 Jan  8 08:19 System.map26
-rw-r--r-- 1 root root 2209920 Jan  8 08:19 vmlinuz-linux

The first column displays the file's permissions (for example, the file initramfs-linux.img has permissions
-rw-r--r--). The third and fourth columns display the file's owning user and group, respectively. In this
example, all files are owned by the root user and the root group.

$ ls -l /media/
total 16
drwxrwx--- 1 root vboxsf 16384 Jan 29 11:02 sf_Shared

In this example, the sf_Shared directory is owned by the root user and the vboxsf group. It is also possible
to determine a file's owners and permissions using the stat command:

Owning user:
$ stat -c %U /media/sf_Shared/
root

Owning group:
$ stat -c %G /media/sf_Shared/
vboxsf

Access rights:
$ stat -c %A /media/sf_Shared/
drwxrwx---

Access permissions are displayed in three groups of characters, representing the permissions of the owning
user, owning group, and others, respectively. For example, the characters -rw-r--r-- indicate that the file's
owner has read and write permission, but not execute (rw-), whilst users belonging to the owning group and
other users have only read permission (r-- and r--). Meanwhile, the characters drwxrwx--- indicate that the
file's owner and users belonging to the owning group all have read, write, and execute permissions (rwx and
rwx), whilst other users are denied access (---). The first character represents the file's type.

List files owned by a user or group with the find utility:
# find / -group group
# find / -user user

A file's owning user and group can be changed with the chown (change owner) command. A file's access
permissions can be changed with the chmod (change mode) command.

File list
Warning: Do not edit these files by hand. There are utilities that properly handle locking and avoid
invalidating the format of the database. See #User management and #Group management for an overview.

File            Purpose
/etc/shadow     Secure user account information
/etc/passwd     User account information
/etc/gshadow    Contains the shadowed information for group accounts
/etc/group      Defines the groups to which users belong
/etc/sudoers    List of who can run what by sudo
/home/*         Home directories

User management
To list users currently logged on the system, the who command can be used. To list all existing user accounts
including their properties stored in the user database, run passwd -Sa as root. See passwd(1) for the
description of the output format.

To add a new user, use the useradd command:
# useradd -m -g initial_group -G additional_groups -s login_shell username

  - -m creates the user home directory as /home/username. Within their home directory, a non-root user can
    write files, delete them, install programs, and so on.
  - -g defines the group name or number of the user's initial login group. If specified, the group name must
    exist; if a group number is provided, it must refer to an already existing group. If not specified, the
    behaviour of useradd will depend on the USERGROUPS_ENAB variable contained in /etc/login.defs. The
    default behaviour (USERGROUPS_ENAB yes) is to create a group with the same name as the username, with GID
    equal to UID.
  - -G introduces a list of supplementary groups which the user is also a member of. Each group is separated
    from the next by a comma, with no intervening spaces. The default is for the user to belong only to the
    initial group.
  - -s defines the path and file name of the user's default login shell. After the boot process is complete,
    the default login shell is the one specified here. Ensure the chosen shell package is installed if
    choosing something other than Bash.

Warning: In order to be able to log in, the login shell must be one of those listed in /etc/shells, otherwise
the PAM module pam_shell will deny the login request. In particular, do not use the /usr/bin/bash path
instead of /bin/bash, unless it is properly configured in /etc/shells.
Note: The password for the newly created user must then be defined, using passwd as shown in #Example adding
a user.

When the login shell is intended to be non-functional, for example when the user account is created for a
specific service, /usr/bin/nologin may be specified in place of a regular shell to politely refuse a login
(see nologin(8)).

Example adding a user
On a typical desktop system, use the following command to add a new user named archie and specify Bash as
their login shell:
# useradd -m -s /bin/bash archie

Although it is not required to protect the newly created user archie with a password, it is highly
recommended to do so:
# passwd archie

Tip: Bash is the default value for the shell (as indicated by useradd -D), so you can omit the -s option
except if you want to use something else.

The above useradd command will also automatically create a group called archie with the same GID as the UID
of the user archie and makes this the default group for archie on login. Making each user have their own
group (with group name same as user name and GID same as UID) is the preferred way to add users.

You could also make the default group something else, e.g. study:
# useradd -m -g study -s /bin/bash archie

Note that, in multi-user systems, using a single default group (e.g. users) for every user is not
recommended. The reason is that typically, the method for facilitating shared write access for specific
groups of users is setting user umask value to 002, which means that the default group will by default always
have write access to any file you create. See also User Private Groups.

In the recommended scenario, where the default group has the same name as the user name, all files are by
default writeable only for the user who created them. To allow write access to a specific group, shared files
/folders can be made writeable by default for everyone in this group and the owning group can be
automatically fixed to the group which owns the parent directory by setting the setgid bit on this directory:
# chmod g+s our_shared_directory

Otherwise the file creator's default group (usually the same as the user name) is used.

If a GID change is required temporarily you can also use the newgrp command to change the user's default GID
to another GID at runtime. For example, after executing newgrp groupname files created by the user will be
associated with the groupname GID, without requiring a re-login. To change back to the default GID, execute
newgrp without a groupname.

Example adding a system user
System users can be used to run processes/daemons under a different user, protecting (e.g. with chown) files
and/or directories and more examples of computer hardening.

With the following command a system user without shell access and without a home directory is created
(optionally append the -U parameter to create a group with the same name as the user, and add the user to
this group):
# useradd -r -s /usr/bin/nologin username

Change a user's login name or home directory
To change a user's home directory:
# usermod -d /my/new/home -m username

The -m option also automatically creates the new directory and moves the content there.

Tip: You can create a link from the user's former home directory to the new one. Doing this will allow
programs to find files that have hardcoded paths.
# ln -s /my/new/home/ /my/old/home

Make sure there is no trailing / on /my/old/home.
To change a user's login name:
# usermod -l newname oldname

Warning: Make certain that you are not logged in as the user whose name you are about to change. Open a new
tty (Ctrl+Alt+F1) and log in as root or as another user and su to root. usermod should prevent you from doing
this by mistake.

Changing a username is safe and easy when done properly, just use the usermod command. If the user is
associated to a group with the same name, you can rename this with the groupmod command.

Alternatively, the /etc/passwd file can be edited directly, see #User database for an introduction to its
format.

Also keep in mind the following notes:
  - If you are using sudo make sure you update your /etc/sudoers to reflect the new username(s) (via the
    visudo command as root).
  - Personal crontabs need to be adjusted by renaming the user's file in /var/spool/cron from the old to the
    new name, and then opening crontab -e to change any relevant paths and have it adjust the file
    permissions accordingly.
  - Wine's personal folders/files' contents in ~/.wine/drive_c/users, ~/.local/share/applications/wine/
    Programs and possibly more need to be manually renamed/edited.
  - Certain Thunderbird addons, like Enigmail, may need to be reinstalled.
  - Anything on your system (desktop shortcuts, shell scripts, etc.) that uses an absolute path to your home
    dir (i.e. /home/oldname) will need to be changed to reflect your new name. To avoid these problems in
    shell scripts, simply use the ~ or $HOME variables for home directories.
  - Also do not forget to edit accordingly the configuration files in /etc that relies on your absolute path
    (i.e. Samba, CUPS, so on). A nice way to learn what files you need to update involves using the grep
    command this way: grep -r {old_user} *

Other examples of user management
To add a user to other groups use (additional_groups is a comma-separated list):
# usermod -aG additional_groups username

Warning: If the -a option is omitted in the usermod command above, the user is removed from all groups not
listed in additional_groups (i.e. the user will be member only of those groups listed in additional_groups).

Alternatively, gpasswd may be used. Though the username can only be added (or removed) from one group at a
time:
# gpasswd --add username group

To enter user information for the GECOS comment (e.g. the full user name), type:
# chfn username

(this way chfn runs in interactive mode).

Alternatively the GECOS comment can be set more liberally with:
# usermod -c "Comment" username

To mark a user's password as expired, requiring them to create a new password the first time they log in,
type:
# chage -d 0 username

User accounts may be deleted with the userdel command:
# userdel -r username

The -r option specifies that the user's home directory and mail spool should also be deleted.

To change the user's login shell:
# usermod -s /bin/bash username

Tip: The adduser^AUR script allows carrying out the jobs of useradd, chfn and passwd interactively. See also
FS#32893.

User database
Local user information is stored in the plain-text /etc/passwd file: each of its lines represents a user
account, and has seven fields delimited by colons.
account:password:UID:GID:GECOS:directory:shell

Where:
  - account is the user name. This field can not be blank. Standard *NIX naming rules apply.
  - password is the user password.
    Warning: The passwd file is world-readable, so storing passwords (hashed or otherwise) in this file is
    insecure. Instead, Arch Linux uses shadowed passwords: the password field will contain a placeholder
    character (x) indicating that the hashed password is saved in the access-restricted file /etc/shadow. For
    this reason it is recommended to always change passwords using the passwd command.
  - UID is the numerical user ID. In Arch, the first login name (after root) is UID 1000 by default;
    subsequent UID entries for users should be greater than 1000.
  - GID is the numerical primary group ID for the user. Numeric values for GIDs are listed in /etc/group.
  - GECOS is an optional field used for informational purposes; usually it contains the full user name, but
    it can also be used by services such as finger and managed with the chfn command. This field is optional
    and may be left blank.
  - directory is used by the login command to set the $HOME environment variable. Several services with their
    own users use /, but normal users usually set a folder under /home.
  - shell is the path to the user's default command shell. This field is optional and defaults to /bin/bash.

Example:
jack:x:1001:100:Jack Smith,some comment here,,:/home/jack:/bin/bash

Broken down, this means: user jack, whose password is in /etc/shadow, whose UID is 1001 and whose primary
group is 100. Jack Smith is his full name and there is a comment associated to his account; his home
directory is /home/jack and he is using Bash.

The pwck command can be used to verify the integrity of the user database. It can sort the user list by GID
at the same time, which can be helpful for comparison:
# pwck -s

Note: Arch Linux defaults of the files are created as .pacnew files by new releases of the filesystem
package. Unless Pacman outputs related messages for action, these .pacnew files can, and should, be
disregarded/removed. New required default users and groups are added or re-added as needed by 
systemd-sysusers(8).

Group management
/etc/group is the file that defines the groups on the system (see group(5) for details).

Display group membership with the groups command:
$ groups user

If user is omitted, the current user's group names are displayed.

The id command provides additional detail, such as the user's UID and associated GIDs:
$ id user

To list all groups on the system:
$ cat /etc/group

Create new groups with the groupadd command:
# groupadd group

Add users to a group with the gpasswd command:
# gpasswd -a user group

Modify an existing group with groupmod; e.g. to rename old_group group to new_group whilst preserving gid
(all files previously owned by old_group will be owned by new_group):
# groupmod -n new_group old_group

Note: This will change a group name but not the numerical GID of the group.

To delete existing groups:
# groupdel group

To remove users from a group:
# gpasswd -d user group

If the user is currently logged in, he must log out and in again for the change to take effect.

The grpck command can be used to verify the integrity of the system's group files.

Updates to the filesystem package create .pacnew files. Alike the .pacnew files for the #User database, these
can be disregarded/removed, because the install script adds any new required groups.

Group list
This section explains the purpose of the essential groups from the core/filesystem package. There are many
other groups, which will be created with correct GID when the relevant package is installed. See the main
page for the software for details.

Note: A later removal of a package does not remove the automatically created user/group (UID/GID) again. This
is intentional because any files created during its usage would otherwise be left orphaned as a potential
security risk.

User groups
Non-root workstation/desktop users often need to be added to some of following groups to allow access to
hardware peripherals and facilitate system administration:

--------------------------------------------------------------------------------------------------------------
Group               Affected files                  Purpose
--------------------------------------------------------------------------------------------------------------
adm                                                 Administration group, similar to wheel.
ftp                 /srv/ftp/                       Access to files served by FTP servers.
games               /var/games                      Access to some game software.
http                /srv/http/                      Access to files served by HTTP servers.
log                                                 Access to log files in /var/log/ created by syslog-ng.
rfkill              /dev/rfkill                     Right to control wireless devices power state (used by rfkill).
sys                                                 Right to administer printers in CUPS.
systemd-journal     /var/log/journal/*              Can be used to provide read-only access to the systemd logs,
                                                    as an alternative to adm and wheel [1]. Otherwise, only user
                                                    generated messages are displayed.
users                                               Standard users group.

uucp                /dev/ttyS[0-9]+, /dev/tts/      RS-232 serial ports and devices connected to them.
                    [0-9]+, /dev/ttyUSB[0-9]+, /    
                    dev/ttyACM[0-9]+, /dev/rfcomm
                    [0-9]+
                    
wheel                                               Administration group, commonly used to give access to the
                                                    sudo and su utilities (neither uses it by default,
                                                    configurable in /etc/pam.d/su and /etc/pam.d/su-l). It can
                                                    also be used to gain full read access to journal files.
--------------------------------------------------------------------------------------------------------------


System groups
The following groups are used for system purposes, an assignment to users is only required for dedicated
purposes:
--------------------------------------------------------------------------------------------------------------
Group   Affected files                          Purpose
--------------------------------------------------------------------------------------------------------------
dbus                                            used internally by dbus
kmem    /dev/port, /dev/mem, /dev/kmem

locate  /usr/bin/locate, /var/lib/locate        See Core utilities#locate.
        /var/lib/mlocate, /var/lib/slocate
       
lp      /dev/lp[0-9]*, /dev/parport[0-9]*       Access to parallel port devices (printers and others).
mail    /usr/bin/mail
nobody                                          Unprivileged group.

proc    /proc/pid/                              A group authorized to learn processes information otherwise
                                                prohibited by hidepid= mount option of the proc filesystem.
                                                The group must be explicitly set with the gid= mount option.
                                                
root    /*                                      Complete system administration and control (root, admin).

smmsp                                           sendmail group.

tty     /dev/tty, /dev/vcc, /dev/vc, /dev/ptmx
utmp    /run/utmp, /var/log/btmp, /var/log/wtmp
--------------------------------------------------------------------------------------------------------------

Pre-systemd groups
Before arch migrated to systemd, users had to be manually added to these groups in order to be able to access
the corresponding devices. This way has been deprecated in favour of udev marking the devices with a uaccess
tag and logind assigning the permissions to users dynamically via ACLs according to which session is
currently active. Note that the session must not be broken for this to work (see General troubleshooting#
Session permissions to check it).

There are some notable exceptions which require adding a user to some of these groups: for example if you
want to allow users to access the device even when they are not logged in. However, note that adding users to
the groups can even cause some functionality to break (for example, the audio group will break fast user
switching and allows applications to block software mixing).

--------------------------------------------------------------------------------------------------------------
Group       Affected files          Purpose
--------------------------------------------------------------------------------------------------------------
audio       /dev/audio, /dev/snd    Direct access to sound hardware, for all sessions. It is still required to make
            /*, /dev/rtc0           ALSA and OSS work in remote sessions, see ALSA#User privileges. Also used in
                                    JACK to give users realtime processing permissions.
                                    
disk        /dev/sd[a-z][1-9]       Access to block devices not affected by other groups such as optical, floppy,
                                    and storage.
                                    
floppy      /dev/fd[0-9]            Access to floppy drives.

input       /dev/input/event[0-9]*, Access to input devices. Introduced in systemd 215 [2].
            /dev/input/mouse[0-9]*     
             
kvm         /dev/kvm                Access to virtual machines using KVM.
optical     /dev/sr[0-9],           Access to optical devices such as CD and DVD drives.
            /dev/sg[0-9] 
            
scanner     /var/lock/sane          Access to scanner hardware.
storage                             Access to removable drives such as USB hard drives, flash/jump drives, MP3
                                    layers; enables the user to mount storage devices.
video       /dev/fb/0,              Access to video capture devices, 2D/3D hardware acceleration, framebuffer (X can
            /dev/misc/agpgart       be used without belonging to this group).
--------------------------------------------------------------------------------------------------------------

Unused groups
The following groups are currently not used for any purpose:

--------------------------------------------------------------------------------------------------------------
 Group      Affected files  Purpose
--------------------------------------------------------------------------------------------------------------
bin         none            Historical
daemon
lock
mem
network                     Unused by default. Can be used e.g. for granting access to NetworkManager (see
                            NetworkManager#Set up PolicyKit permissions).
                            
power
uuidd
--------------------------------------------------------------------------------------------------------------
Retrieved from "https://wiki.archlinux.org/index.php?title=Users_and_groups&oldid=514670"

---
