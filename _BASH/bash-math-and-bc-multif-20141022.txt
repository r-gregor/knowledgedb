filename: bash-math-and-bc-multif_20141022.txt
http://www.basicallytech.com/blog/?/archives/23-command-line-calculations-using-bc.html

command-line calculations using bc

   If like me, you do most of your work from the command-line, using vim to edit files, mutt
   for e-mails, cd/ls/mv/find/etc instead of a file manager, then you may get annoyed by
   having to fire up a GUI calculator to make (what may sometimes be) a single calculation.

   One useful feature of calculating on the command-line is that you can see what you've
   typed. For instance, sometimes when I'm entering a long, complex calculation on a
   calculator (either the GUI or the solid, hold-in-your-hand type), I sometimes forget if
   I've actually typed in all those numbers or made the calculations in the right order. Maybe
   it's just me ... :-)

   This article shows how to quickly perform standard calculations on the command line
   including addition, subtraction, multiplication, division, square root, powers, conversion
   from decimal to hex, decimal to binary, hex to decimal, and binary to decimal. It also
   briefly introduces using bc in interactive mode and how to write files for use with bc for
   frequently repeated operations. There is a mention of using Google for performing
   calulations. It finishes with a little challenge to test the power of your CPU.

   Other advantages of using bc include:
     * bc is included with (almost?) all Linux distros as standard, as well as (again,
       almost?) all Unices.
     * Results from calculations in some proprietary flavours of bc have up to 99 decimal
       digits before and after the decimal point. This limit has been greatly surpassed in GNU
       bc. I don't know what that limit is, but it's at least many, many tens of thousands.
       Certainly it's more than any GUI-based calculators (I've used) could accomodate.
     * You may also find yourself working in an environment where you simply don't have access
       to a GUI.
     * The syntax for basic sums is almost identical to [47]Google's calculator function, so
       you can learn how to use two utilities in one go!

   bc is a preprocessor for dc. The useful thing about bc is that it accepts input from files
   and from standard input. This allows us to pipe data to it for quick calculations.
     * [48]addition
     * [49]subtraction
     * [50]multiplication
     * [51]scale
     * [52]division
     * [53]square root
     * [54]power
     * [55]parentheses
     * [56]obase and ibase
     * [57]convert from decimal to hexadecimal
     * [58]convert from decimal to binary
     * [59]convert from binary to decimal
     * [60]convert from hexadecimal to decimal
     * [61]a brief introduction to interactive mode
     * [62]using bc with shell scripts
     * [63]a brief introduction to using bc with files
     * [64]a quick challenge for your PC (GNU bc only)

   Most of these examples follow a simple formula.

addition

   $ echo '57+43' | bc
100

subtraction

   $ echo '57-43' | bc
14

multiplication

   $ echo '57*43' | bc
2451

scale

   The scale variable determines the number of digits which follow the decimal point in your
   result. By default, the value of the scale variable is zero. (Unless you use the -l option
   in which case it defaults to 20 decimal places. More about -l later.) This can be set by
   declaring scale before your calculation, as in the following division example:

division

   $ echo 'scale=25;57/43' | bc
1.3255813953488372093023255

square root

   $ echo 'scale=30;sqrt(2)' | bc
1.414213562373095048801688724209

   This beats [65]Google's calculator function which only calculates the result to 8 decimal
   places! ;-) Although Google's calculator function has this 8 decimal places limitation, it
   will allow [66]imaginary numbers as answers.

power

   $ echo '6^6' | bc
46656

parentheses

   If you have read Robert Heinlein's The Number of the Beast, you may recall that the number
   of parallel universes in the story equals (six to the power of six) to the power of six. If
   you should try to calculate that like this:

   $ echo '6^6^6' | bc

   You will get a screen full of numbers (some 37374 digits), not the
10314424798490535546171949056

   that you might expect.

   If you're running a non-GNU version of bc, you'll most likely get something like:
exp too big
empty stack
save:args

   The Google Calculator balks at '6^6^6' as well. Good ol' GNU.

   That's because you typed the wrong question. You need to type:

   $ echo '(6^6)^6' | bc

   Whereas what you did type was interpreted as:

   $ echo '6^(6^6)' | bc

   which is an entirely different number altogether. So the positioning of parentheses
   (brackets to you and me!) is very important. I use brackets to separate the different
   components of my sums whenever possible, just eliminate any possible doubt that I may get
   the wrong answer. Consider the following calculations:

   $ echo '7+(6*5)' | bc

   $ echo '7+6*5' | bc

   $ echo '6*5+7' | bc

   They all give the same answer, 37, but I would have typed the first calculation, unless of
   course, I meant:

   $ echo '(7+6)*5' | bc

   Or to put it another way:

   $ echo '13*5' | bc

   which is 65.

obase and ibase

   obase and ibase are special variables which define output and input base.

   Legitimate obase values range from 2 to 999, although anything beyond 16 is wasted on me!

   Legitimate ibase values range from 2 to 16.

   Some examples will explain all this better.

convert from decimal to hexadecimal

   Here we're converting 255 from base 10 to base 16:

   $ echo 'obase=16;255' | bc
FF

convert from decimal to binary

   And here we're converting the number 12 from base 10 to base 2:

   $ echo 'obase=2;12' | bc
1100

   Which reminds me of the old joke:

   There are only 10 types of people in the world -- those who understand binary, and those
   who don't.

   Which leads us neatly onto the next example:

convert from binary to decimal

   Here we're converting the binary number 10 to a base 10 (decimal) number.

   $ echo 'ibase=2;obase=A;10' | bc
2

   Note that the obase is "A" and not "10". Sorry, you've got to learn some hex. The reason
   for this is you've set the ibase to "2", so if you now had tried to use "10" as the value
   for the obase, it would stay as "2", because "10" in base 2 is "2". So you need to use hex
   to "break out" of binary mode.

   Well, that was just to explain the joke; now something a bit more challenging:

   $ echo 'ibase=2;obase=A;10000001' | bc
129

convert from hexadecimal to decimal

   $ echo 'ibase=16;obase=A;FF' | bc
255

   Again, note the use of "A" to denote base 10. That is because "10" in hex (base 16 - the
   ibase value) is 16.

a brief introduction to interactive mode

   You can also run bc in interactive mode:

   $ bc

   If you're running GNU bc, you should get the following notice:
bc 1.06
Copyright 1991-1994, 1997, 1998, 2000 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'.

   Followed by an uninviting blank prompt. Otherwise you'll just get an uninviting blank
   prompt.

   If you wish to get straight to the uninviting blank prompt, use the -q option, which runs
   bc in quiet mode, preventing the normal GNU bc welcome from being printed:

   $ bc -q

   Using the basics we've been through from the examples above, enter a calculation:

   scale=5
   57/43
   1.32558

   Type quit to exit bc interactive mode.

using bc with shell scripts

   You can use shell variables with bc, which is very useful in shell scripts:

   $ FIVE=5 ; echo "$FIVE^2" | bc
25

   Note the use of double-quotes to preserve the value of the variable $FIVE.

a brief introduction to using bc with files

   Using bc with files allows complex calculations to be repeated, again and again, a bit like
   using a spreadsheet to run the same calculations on changing figures ... but faster.

   Here is a simple example:
scale=2

/* C-style comments
   are allowed, as are spaces */

print "\nConvert Fahrenheit to Celsius\n\n"
print "Temperature in Fahrenheit: " ; fah = read()
print "\n"
print "Equivalent Temperature in Celsius is: "
(fah - 32.0) * 5.0 / 9.0
quit

   Create and save the file, then run it like this:

   $ bc -q filename
   Convert Fahrenheit to Celsius
   Temperature in Fahrenheit: 61
   Equivalent Temperature in Celsius is: 16.11

   Note that this example has only been tested with GNU bc. Other (proprietary) versions of bc
   may have more stringent syntax requirements. Some bcs don't allow the use of print or read,
   for example, so you have to edit your file before each calculation. Not very useful.

a quick challenge for your PC (GNU bc only)

   If you wish to test the comparative speed of your PC, try this challenge: use bc to
   calculate Pi to 5000 decimal places. The idea for this challenge came from a great
   [67]article at Geekronomicon.

   If you really want to tie up your machine for an hour (or more), you could try the "Pi to
   25000 decimal places" challenge from the aforementioned [68]Geekronomicon. ;-)

   First, to put things in perspective, here is some information about my CPU:

   $ cat /proc/cpuinfo | egrep "model name|MHz"
model name      : AMD Athlon(tm) 64 Processor 3500+
cpu MHz         : 2211.346

   Note the use (below) of the command bc -l -q.
   -l loads the math library which is required for the use of the "a" (arctangent) in the
   calculation for Pi. You can learn more about the math library functions in the [69]bc
   command manual.
   I'm not sure what effect the -q option (quiet, no welcome message printed) has on our test,
   but I guess it can't harm.

   $ time echo "scale=5000; 4*a(1)" | bc -l -q
3.141592653589793238462643383279502884197169399375105820974944592307\
...
...
...
73774418426312986080998886874132604720

real    0m44.164s
user    0m44.099s
sys     0m0.008s

   44.099 seconds! Not bad. :-) I imagine that some Gentoo folks may be interested to see what
   difference their compile-time optimisations make to the speed of bc. FWIW, my distro of
   choice is [70]Arch Linux.



---
http://hacktux.com/bash/math

Bash Math
     ______________________________________________________________________________________

   Use Bash builtins (let, expr) for integer math and bc (a GNU numeric processing language)
   for floating point arithmetic in your bash scripts. Here are some examples.

   Integer Math in Bash

   The expr builtin can be used as a simple integer calculator. Results are rounded to the
   nearest integer and floating point is unknown. BE sure to escape the multiplication
   asterisks (*) to avoid Bash expansion.

   bash$ expr 1 + 1
   2
   bash$ expr 3 \* 2
   6
   bash$ expr 6 / 3
   2
   bash$ expr 6 % 3
   0
   bash$ expr 3 / 2
   1
   bash$ expr 3 / 6
   0
   bash$ expr 6 \* 3.5
   expr: non-numeric argument

   Instead of expr(), you can also echo the output of $(( )) or $[ ].

   bash$ expr 1 + 1
   4
   bash$ echo $((2 + 2))
   4
   bash$ echo $[2 + 2]
   4

   Use the bash builtin let for quick manipulation of bash variables.

   bash$ NUM=41
   bash$ let NUM+=1
   bash$ echo $NUM
   42

   Floating Point Arithmetic in Bash

   Using floating point in bash scripts requires an external calculator like GNU bc. Pipe your
   request to bc and note that escaping is not needed for quoted asterisks.

   bash$ echo "3.8 + .4" | bc
   4.2
   bash$ echo '6 * 1.5' | bc
   9.0

   If all input values are integers, the bc option scale must be defined if you expect a
   floating point result.

   bash$ echo '2 / 5' | bc
   0
   bash$ echo 'scale=2; 2 / 5' | bc
   .40

   You can also use the bash here string <<< to accomplish the same as a pipe of echo to bc:

   bash$ echo 'scale=2; 2 / 5' | bc
   .40
   bash$ bc <<< 'scale=2; 2 / 5'
   .40

   Or, use bc -l to evoke the standard (but not default!) mathlib and see the result in
   floating point at max scale:

   bash$ bc -l <<< '10.5 / 1'
   10.50000000000000000000



---
http://phoxis.org/2009/12/23/floatmathbash/

Floating point math operations in bash

   Posted on [31]December 23, 2009 by [32]phoxis

   When writing scripts in bash, sometimes we need to work with basic math functions. Like the
   trigonometric functions, square root, cube root, logarithms. Bash does not support floating
   point operations. This is where the problem is encountered, and we cannot write a math
   function of our own. There must be a way to do this, and yes. Bash supports redirections so
   we can feed the floating point computations and the math functions into some other
   program's input who understands it. The program which can be used is the bc, which is an
   arbitrary precision calculator language. bc can do floating point operations, and also can
   do basic math functions. With bash and bc we can do the above. Continue reading to know
   how.

Check

   Before doing anything first check if bc is installed in your system.To check if bc is
   installed execute the following:
rpm -q bc

   If it says package bc is not installed then you need to install it. To install bc just
   execute the following in yum.
yum -y install bc

What's the stuff

   The main stuff is to simply write a string with echo and pipe it into the input of bc, and
   get the answer.

   If we want to add two floating point numbers say 2.5 and 3.75, then simply the string
   "2.5+3.75'' should be feed into the input of bc and you are done. Check out the example
   below:
echo "2.5+3.75" | bc
6.25

   Above the first line shows the input to bash, and the second line is the output.

   As now you have understood the basic trick, that is so simply feed in any arithmetic
   expression into a program's input, who understands it, to get the answer from it, i will
   present some more examples.

Examples

   Now lets say you want to get a square root of a number (floating point), say 641 . The
   function of bc which performs square root is sqrt. And as we are performing a math function
   we need to tell bc to turn on its standard math library. This can be done just by including
   the -l switch to bc. So the command will be as below:
echo "sqrt(641)" | bc -l
25.31797780234432546177

   Till now you should have guessed that we can also use the shell variables in the echo with
   double quotes to enable variable value. For example check the command sequence below:
x=215
echo "sqrt($x)" | bc -l

   And yes now the command performs the square root of the variable "x" , which can be
   assigned whatever.

   The below nano shell script performs floating point addition operation using bc.

#!/bin/bash
echo "Enter a floating point number: "
read a

echo "Enter another floating point number: "
read b

echo "Addition: "
echo "$a+$b" | bc

   Integer powers of a floating point could be calculated with the "^" operator. Below "a" is
   a floating point and "b" is integer.
echo "$a^$b" | bc -l

   So it is simple. Now some trigonometric functions. In bc the s is the sine function, c is
   the cos function, and the a is the arctangent function (atan). And as normal the angles are
   to be passed as radians, but we can always do a degree to radian conversion. So we have the
   basic two. The below shell script demonstrates the calculation of different trigonometric
   vales.
#!/bin/bash
echo "Enter angle in degree: "
read deg

# Note: Pi calculation
# tan(pi/4) = 1
# atan(1) = pi/4 and
# pi = 4*atan(1)

pi=`echo "4*a(1)" | bc -l`
rad=`echo "$deg*($pi/180)" | bc -l`

echo "$deg Degree = $rad Radian"

echo "Sin($deg): "
echo "s($rad)" | bc -l

echo "Cos($deg): "
echo "c($rad)" | bc -l

echo "Tan($deg): "
echo "s($rad)/c($rad)" | bc -l

   The natural logarithmic function in bc is l. So to calculate natural logarithm and ten base
   logarithm we would do the following:
#!/bin/bash
echo "Enter value: "
read x

echo "Natural Log: ln($x) :"
echo "l($x)" | bc -l

echo "Ten Base Log: log($x) :"
echo "l($x)/l(10)" | bc -l

   And similarly the exponential function could be implemented by calling the e function in
   bc.

   You can adjust the precision of the value which the math functions calculate be assigning
   the decimal point accuracy in the scale variable within bc. For an example if you want
   square root of a number up to 2 decimal places, you should do as below, where "x" is the
   variable.
echo "scale=2;sqrt($x)" | bc -l

   Note that it simply truncates the decimal places, so the scaled value is not the
   approximation but only truncated. For example 6.74536878161602073277 in 2 decimal places
   would be simple truncated to 6.74, and not 6.75

More

   And now you can write a function in bc syntax and also make it use. As presented below, a
   factorial function:
#!/bin/bash

echo "Enter an integer: "
read n

# Below we define the factorial function in bc syntax
fact="define f (x) {
i=x
fact=1
while (i > 1) {
fact=fact*i
i=i-1
}
return fact
}"

# Below we pass the function defined above, and call it with n as a parameter and pipe it to bc
factorial=`echo "$fact;f($n)" | bc -l`

echo "$n! = $factorial"

   Clearly any other functions written in bc syntax could be used

Resources

   Check out more functions and operators and all the details of bc by visiting the site here:
   [33]http://www.gnu.org/software/bc/manual/html_mono/bc.html , and also check the man page
   and info pages by executing:
man bc
info bc



---
http://www.gnu.org/software/bc/manual/html_mono/bc.html

bc

an arbitrary precision calculator language

version 1.06


    Philip A. Nelson
     ______________________________________________________________________________________

                                         Table of Contents

     * [1]Introduction
          + [2]Description
          + [3]Command Line Options
     * [4]Basic Elements
          + [5]Numbers
          + [6]Variables
          + [7]Comments
     * [8]Expressions
          + [9]About Expressions and Special Variables
          + [10]Basic Expressions
          + [11]Relational Expressions
          + [12]Boolean Expressions
          + [13]Precedence
          + [14]Special Expressions
     * [15]Statements
          + [16]Pseudo Statements
     * [17]Functions
          + [18]Math Library Functions
     * [19]Examples
     * [20]Readline and Libedit Options
     * [21]GNU bc and Other Implementations
     * [22]Limits
     * [23]Environment Variables
     ______________________________________________________________________________________

                                          [24]Introduction

[25]Description

   bc [ -hlwsqv ] [long-options] [ file ... ]

   bc is a language that supports arbitrary precision numbers with interactive execution of
   statements. There are some similarities in the syntax to the C programming language. A
   standard math library is available by command line option. If requested, the math library
   is defined before processing any files. bc starts by processing code from all the files
   listed on the command line in the order listed. After all files have been processed, bc
   reads from the standard input. All code is executed as it is read. (If a file contains a
   command to halt the processor, bc will never read from the standard input.)

   This version of bc contains several extensions beyond traditional bc implementations and
   the POSIX draft standard. Command line options can cause these extensions to print a
   warning or to be rejected. This document describes the language accepted by this processor.
   Extensions will be identified as such.

   The author would like to thank Steve Sommars ([26]Steve.Sommars@att.com) for his extensive
   help in testing the implementation. Many great suggestions were given. This is a much
   better product due to his involvement.

   Email bug reports to [27]bug-bc@gnu.org. Be sure to include the word "bc" somewhere in the
   "Subject:" field.

[28]Command Line Options

   bc takes the following options from the command line:
   -h, --help
          Print the usage and exit.
   -l, --mathlib
          Define the standard math library.
   -w, --warn
          Give warnings for extensions to POSIX bc.
   -s, --standard
          Process exactly the POSIX bc language.
   -q, --quiet
          Do not print the normal GNU bc welcome.
   -v, --version
          Print the version number and copyright and quit.

                                         [29]Basic Elements

[30]Numbers

   The most basic element in bc is the number. Numbers are arbitrary precision numbers. This
   precision is both in the integer part and the fractional part. All numbers are represented
   internally in decimal and all computation is done in decimal. (This version truncates
   results from divide and multiply operations.) There are two attributes of numbers, the
   length and the scale. The length is the total number of significant decimal digits in a
   number and the scale is the total number of decimal digits after the decimal point. For
   example, .000001 has a length of 6 and scale of 6, while 1935.000 has a length of 7 and a
   scale of 3.

[31]Variables

   Numbers are stored in two types of variables, simple variables and arrays. Both simple
   variables and array variables are named. Names begin with a letter followed by any number
   of letters, digits and underscores. All letters must be lower case. (Full alphanumeric
   names are an extension. In POSIX bc all names are a single lower case letter.) The type of
   variable is clear by the context because all array variable names will be followed by
   brackets ( [ ] ).

   There are four special variables, scale, ibase, obase, and last. scale defines how some
   operations use digits after the decimal point. The default value of scale is 0. ibase and
   obase define the conversion base for input and output numbers. The default for both input
   and output is base 10. last (an extension) is a variable that has the value of the last
   printed number. These will be discussed in further detail where appropriate. All of these
   variables may have values assigned to them as well as used in expressions.

[32]Comments

   Comments in bc start with the characters /* and end with the characters */. Comments may
   start anywhere and appear as a single space in the input. (This causes comments to delimit
   other input items. For example, a comment can not be found in the middle of a variable
   name.) Comments include any newlines (end of line) between the start and the end of the
   comment.

   To support the use of scripts for bc, a single line comment has been added as an extension.
   A single line comment starts at a # character and continues to the next end of the line.
   The end of line character is not part of the comment and is processed normally.

                                          [33]Expressions

[34]About Expressions and Special Variables

   The numbers are manipulated by expressions and statements. Since the language was designed
   to be interactive, statements and expressions are executed as soon as possible. There is no
   main program. Instead, code is executed as it is encountered. (Functions, discussed in
   detail later, are defined when encountered.)

   A simple expression is just a constant. bc converts constants into internal decimal numbers
   using the current input base, specified by the variable ibase. (There is an exception in
   functions.) The legal values of ibase are 2 through 16. Assigning a value outside this
   range to ibase will result in a value of 2 or 16. Input numbers may contain the characters
   0-9 and A-F. (Note: They must be capitals. Lower case letters are variable names.) Single
   digit numbers always have the value of the digit regardless of the value of ibase. (i.e. A
   = 10.) For multi-digit numbers, bc changes all input digits greater or equal to ibase to
   the value of ibase-1. This makes the number FFF always be the largest 3 digit number of the
   input base.

   Full expressions are similar to many other high level languages. Since there is only one
   kind of number, there are no rules for mixing types. Instead, there are rules on the scale
   of expressions. Every expression has a scale. This is derived from the scale of original
   numbers, the operation performed and in many cases, the value of the variable scale. Legal
   values of the variable scale are 0 to the maximum number representable by a C integer.

[35]Basic Expressions

   In the following descriptions of legal expressions, "expr" refers to a complete expression
   and "var" refers to a simple or an array variable. A simple variable is just a

   name

   and an array variable is specified as

   name[expr]

   Unless specifically mentioned the scale of the result is the maximum scale of the
   expressions involved.
   - expr
          The result is the negation of the expression.
   ++ var
          The variable is incremented by one and the new value is the result of the
          expression.
   -- var
          The variable is decremented by one and the new value is the result of the
          expression.
   var ++
          The result of the expression is the value of the variable and then the variable is
          incremented by one.
   var --
          The result of the expression is the value of the variable and then the variable is
          decremented by one.
   expr + expr
          The result of the expression is the sum of the two expressions.
   expr - expr
          The result of the expression is the difference of the two expressions.
   expr * expr
          The result of the expression is the product of the two expressions.
   expr / expr
          The result of the expression is the quotient of the two expressions. The scale of
          the result is the value of the variable scale
   expr % expr
          The result of the expression is the "remainder" and it is computed in the following
          way. To compute a%b, first a/b is computed to scale digits. That result is used to
          compute a-(a/b)*b to the scale of the maximum of scale+scale(b) and scale(a). If
          scale is set to zero and both expressions are integers this expression is the
          integer remainder function.
   expr ^ expr
          The result of the expression is the value of the first raised to the second. The
          second expression must be an integer. (If the second expression is not an integer, a
          warning is generated and the expression is truncated to get an integer value.) The
          scale of the result is scale if the exponent is negative. If the exponent is
          positive the scale of the result is the minimum of the scale of the first expression
          times the value of the exponent and the maximum of scale and the scale of the first
          expression. (e.g. scale(a^b) = min(scale(a)*b, max(scale, scale(a))).) It should be
          noted that expr^0 will always return the value of 1.
   ( expr )
          This alters the standard precedence to force the evaluation of the expression.
   var = expr
          The variable is assigned the value of the expression.
   var <op>= expr
          This is equivalent to "var = var <op> expr" with the exception that the "var" part
          is evaluated only once. This can make a difference if "var" is an array.

[36]Relational Expressions

   Relational expressions are a special kind of expression that always evaluate to 0 or 1, 0
   if the relation is false and 1 if the relation is true. These may appear in any legal
   expression. (POSIX bc requires that relational expressions are used only in if, while, and
   for statements and that only one relational test may be done in them.) The relational
   operators are
   expr1 < expr2
          The result is 1 if expr1 is strictly less than expr2.
   expr1 <= expr2
          The result is 1 if expr1 is less than or equal to expr2.
   expr1 > expr2
          The result is 1 if expr1 is strictly greater than expr2.
   expr1 >= expr2
          The result is 1 if expr1 is greater than or equal to expr2.
   expr1 == expr2
          The result is 1 if expr1 is equal to expr2.
   expr1 != expr2
          The result is 1 if expr1 is not equal to expr2.

[37]Boolean Expressions

   Boolean operations are also legal. (POSIX bc does NOT have boolean operations). The result
   of all boolean operations are 0 and 1 (for false and true) as in relational expressions.
   The boolean operators are:
   !expr
          The result is 1 if expr is 0.
   expr && expr
          The result is 1 if both expressions are non-zero.
   expr || expr
          The result is 1 if either expression is non-zero.

[38]Precedence

   The expression precedence is as follows: (lowest to highest)
|| operator, left associative
&& operator, left associative
! operator, nonassociative
Relational operators, left associative
Assignment operator, right associative
+ and - operators, left associative
*, / and % operators, left associative
^ operator, right associative
unary - operator, nonassociative
++ and -- operators, nonassociative

   This precedence was chosen so that POSIX compliant bc programs will run correctly. This
   will cause the use of the relational and logical operators to have some unusual behavior
   when used with assignment expressions. Consider the expression:
a = 3 < 5

   Most C programmers would assume this would assign the result of "3 < 5" (the value 1) to
   the variable "a". What this does in bc is assign the value 3 to the variable "a" and then
   compare 3 to 5. It is best to use parentheses when using relational and logical operators
   with the assignment operators.

[39]Special Expressions

   There are a few more special expressions that are provided in bc. These have to do with
   user-defined functions and standard functions. They all appear as "name(parameters)". See
   section [40]Functions, for user-defined functions. The standard functions are:
   length ( expression )
          The value of the length function is the number of significant digits in the
          expression.
   read ( )
          The read function (an extension) will read a number from the standard input,
          regardless of where the function occurs. Beware, this can cause problems with the
          mixing of data and program in the standard input. The best use for this function is
          in a previously written program that needs input from the user, but never allows
          program code to be input from the user. The value of the read function is the number
          read from the standard input using the current value of the variable ibase for the
          conversion base.
   scale ( expression )
          The value of the scale function is the number of digits after the decimal point in
          the expression.
   sqrt ( expression )
          The value of the sqrt function is the square root of the expression. If the
          expression is negative, a run time error is generated.

                                           [41]Statements

   Statements (as in most algebraic languages) provide the sequencing of expression
   evaluation. In bc statements are executed "as soon as possible." Execution happens when a
   newline in encountered and there is one or more complete statements. Due to this immediate
   execution, newlines are very important in bc. In fact, both a semicolon and a newline are
   used as statement separators. An improperly placed newline will cause a syntax error.
   Because newlines are statement separators, it is possible to hide a newline by using the
   backslash character. The sequence "\<nl>", where <nl> is the newline appears to bc as
   whitespace instead of a newline. A statement list is a series of statements separated by
   semicolons and newlines. The following is a list of bc statements and what they do: (Things
   enclosed in brackets ( [ ] ) are optional parts of the statement.)
   expression
          This statement does one of two things. If the expression starts with "<variable>
          <assignment> ...", it is considered to be an assignment statement. If the expression
          is not an assignment statement, the expression is evaluated and printed to the
          output. After the number is printed, a newline is printed. For example, "a=1" is an
          assignment statement and "(a=1)" is an expression that has an embedded assignment.
          All numbers that are printed are printed in the base specified by the variable
          obase. The legal values for obase are 2 through BC_BASE_MAX (see section
          [42]Environment Variables). For bases 2 through 16, the usual method of writing
          numbers is used. For bases greater than 16, bc uses a multi-character digit method
          of printing the numbers where each higher base digit is printed as a base 10 number.
          The multi-character digits are separated by spaces. Each digit contains the number
          of characters required to represent the base ten value of "obase -1". Since numbers
          are of arbitrary precision, some numbers may not be printable on a single output
          line. These long numbers will be split across lines using the "\" as the last
          character on a line. The maximum number of characters printed per line is 70. Due to
          the interactive nature of bc, printing a number causes the side effect of assigning
          the printed value to the special variable last. This allows the user to recover the
          last value printed without having to retype the expression that printed the number.
          Assigning to last is legal and will overwrite the last printed value with the
          assigned value. The newly assigned value will remain until the next number is
          printed or another value is assigned to last. (Some installations may allow the use
          of a single period (.) which is not part of a number as a short hand notation for
          for last.)
   string
          The string is printed to the output. Strings start with a double quote character and
          contain all characters until the next double quote character. All characters are
          taken literally, including any newline. No newline character is printed after the
          string.
   print list
          The print statement (an extension) provides another method of output. The list is a
          list of strings and expressions separated by commas. Each string or expression is
          printed in the order of the list. No terminating newline is printed. Expressions are
          evaluated and their value is printed and assigned to the variable last. Strings in
          the print statement are printed to the output and may contain special characters.
          Special characters start with the backslash character (\e). The special characters
          recognized by bc are "a" (alert or bell), "b" (backspace), "f" (form feed), "n"
          (newline), "r" (carriage return), "q" (double quote), "t" (tab), and "\e"
          (backslash). Any other character following the backslash will be ignored.
   { statement_list }
          This is the compound statement. It allows multiple statements to be grouped together
          for execution.
   if ( expression ) statement1 [else statement2]
          The if statement evaluates the expression and executes statement1 or statement2
          depending on the value of the expression. If the expression is non-zero, statement1
          is executed. If statement2 is present and the value of the expression is 0, then
          statement2 is executed. (The else clause is an extension.)
   while ( expression ) statement
          The while statement will execute the statement while the expression is non-zero. It
          evaluates the expression before each execution of the statement. Termination of the
          loop is caused by a zero expression value or the execution of a break statement.
   for ( [expression1] ; [expression2] ; [expression3] ) statement
          The for statement controls repeated execution of the statement. Expression1 is
          evaluated before the loop. Expression2 is evaluated before each execution of the
          statement. If it is non-zero, the statement is evaluated. If it is zero, the loop is
          terminated. After each execution of the statement, expression3 is evaluated before
          the reevaluation of expression2. If expression1 or expression3 are missing, nothing
          is evaluated at the point they would be evaluated. If expression2 is missing, it is
          the same as substituting the value 1 for expression2. (The optional expressions are
          an extension. POSIX bc requires all three expressions.) The following is equivalent
          code for the for statement:
expression1;
while (expression2) {
   statement;
   expression3;
}

   break
          This statement causes a forced exit of the most recent enclosing while statement or
          for statement.
   continue
          The continue statement (an extension) causes the most recent enclosing for statement
          to start the next iteration.
   halt
          The halt statement (an extension) is an executed statement that causes the bc
          processor to quit only when it is executed. For example, "if (0 == 1) halt" will not
          cause bc to terminate because the halt is not executed.
   return
          Return the value 0 from a function. (See section [43]Functions.)
   return ( expression )
          Return the value of the expression from a function. (See section [44]Functions.) As
          an extension, the parenthesis are not required.

[45]Pseudo Statements

   These statements are not statements in the traditional sense. They are not executed
   statements. Their function is performed at "compile" time.
   limits
          Print the local limits enforced by the local version of bc. This is an extension.
   quit
          When the quit statement is read, the bc processor is terminated, regardless of where
          the quit statement is found. For example, "if (0 == 1) quit" will cause bc to
          terminate.
   warranty
          Print a longer warranty notice. This is an extension.

                                           [46]Functions

   Functions provide a method of defining a computation that can be executed later. Functions
   in bc always compute a value and return it to the caller. Function definitions are
   "dynamic" in the sense that a function is undefined until a definition is encountered in
   the input. That definition is then used until another definition function for the same name
   is encountered. The new definition then replaces the older definition. A function is
   defined as follows:
define name ( parameters ) { newline
    auto_list   statement_list }

   A function call is just an expression of the form "name (parameters)".

   Parameters are numbers or arrays (an extension). In the function definition, zero or more
   parameters are defined by listing their names separated by commas. Numbers are only call by
   value parameters. Arrays are only call by variable. Arrays are specified in the parameter
   definition by the notation "name[ ]". In the function call, actual parameters are full
   expressions for number parameters. The same notation is used for passing arrays as for
   defining array parameters. The named array is passed by variable to the function. Since
   function definitions are dynamic, parameter numbers and types are checked when a function
   is called. Any mismatch in number or types of parameters will cause a runtime error. A
   runtime error will also occur for the call to an undefined function.

   The auto_list is an optional list of variables that are for "local" use. The syntax of the
   auto list (if present) is "auto name, ... ;". (The semicolon is optional.) Each name is the
   name of an auto variable. Arrays may be specified by using the same notation as used in
   parameters. These variables have their values pushed onto a stack at the start of the
   function. The variables are then initialized to zero and used throughout the execution of
   the function. At function exit, these variables are popped so that the original value (at
   the time of the function call) of these variables are restored. The parameters are really
   auto variables that are initialized to a value provided in the function call. Auto
   variables are different than traditional local variables because if function A calls
   function B, B may access function A's auto variables by just using the same name, unless
   function B has called them auto variables. Due to the fact that auto variables and
   parameters are pushed onto a stack, bc supports recursive functions.

   The function body is a list of bc statements. Again, statements are separated by semicolons
   or newlines. Return statements cause the termination of a function and the return of a
   value. There are two versions of the return statement. The first form, "return", returns
   the value 0 to the calling expression. The second form, "return ( expression )", computes
   the value of the expression and returns that value to the calling expression. There is an
   implied "return (0)" at the end of every function. This allows a function to terminate and
   return 0 without an explicit return statement.

   Functions also change the usage of the variable ibase. All constants in the function body
   will be converted using the value of ibase at the time of the function call. Changes of
   ibase will be ignored during the execution of the function except for the standard function
   read, which will always use the current value of ibase for conversion of numbers.

   As an extension, the format of the definition has been slightly relaxed. The standard
   requires the opening brace be on the same line as the define keyword and all other parts
   must be on following lines. This version of bc will allow any number of newlines before and
   after the opening brace of the function. For example, the following definitions are legal.
   define d (n) { return (2*n); }
   define d (n)
       { return (2*n); }

[47]Math Library Functions

   If bc is invoked with the -l option, a math library is preloaded and the default scale is
   set to 20. The math functions will calculate their results to the scale set at the time of
   their call. The math library defines the following functions:
   s (x)
          The sine of x, x is in radians.
   c (x)
          The cosine of x, x is in radians.
   a (x)
          The arctangent of x, arctangent returns radians.
   l (x)
          The natural logarithm of x.
   e (x)
          The exponential function of raising e to the value x.
   j (n,x)
          The bessel function of integer order n of x.

                                            [48]Examples

   In /bin/sh, the following will assign the value of "pi" to the shell variable pi.

pi=$(echo "scale=10; 4*a(1)" | bc -l)


   The following is the definition of the exponential function used in the math library. This
   function is written in POSIX bc.

scale = 20

/* Uses the fact that e^x = (e^(x/2))^2
   When x is small enough, we use the series:
     e^x = 1 + x + x^2/2! + x^3/3! + ...
*/

define e(x) {
  auto  a, d, e, f, i, m, v, z

  /* Check the sign of x. */
  if (x<0) {
    m = 1
    x = -x
  }

  /* Precondition x. */
  z = scale;
  scale = 4 + z + .44*x;
  while (x > 1) {
    f += 1;
    x /= 2;
  }

  /* Initialize the variables. */
  v = 1+x
  a = x
  d = 1

  for (i=2; 1; i++) {
    e = (a *= x) / (d *= i)
    if (e == 0) {
      if (f>0) while (f--)  v = v*v;
      scale = z
      if (m) return (1/v);
      return (v/1);
    }
    v += e
  }
}


   The following is code that uses the extended features of bc to implement a simple program
   for calculating checkbook balances. This program is best kept in a file so that it can be
   used many times without having to retype it at every use.

scale=2
print "\nCheck book program\n!"
print "  Remember, deposits are negative transactions.\n"
print "  Exit by a 0 transaction.\n\n"

print "Initial balance? "; bal = read()
bal /= 1
print "\n"
while (1) {
  "current balance = "; bal
  "transaction? "; trans = read()
  if (trans == 0) break;
  bal -= trans
  bal /= 1
}
quit


   The following is the definition of the recursive factorial function.

define f (x) {
  if (x <= 1) return (1);
  return (f(x-1) * x);
}


                                  [49]Readline and Libedit Options

   GNU bc can be compiled (via a configure option) to use the GNU readline input editor
   library or the BSD libedit library. This allows the user to do more editing of lines before
   sending them to bc. It also allows for a history of previous lines typed. When this option
   is selected, bc has one more special variable. This special variable, history is the number
   of lines of history retained. A value of -1 means that an unlimited number of history lines
   are retained. This is the default value. Setting the value of history to a positive number
   restricts the number of history lines to the number given. The value of 0 disables the
   history feature. For more information, read the user manuals for the GNU readline, history
   and BSD libedit libraries. One can not enable both readline and libedit at the same time.

                                [50]GNU bc and Other Implementations

   This version of bc was implemented from the POSIX P1003.2/D11 draft and contains several
   differences and extensions relative to the draft and traditional implementations. It is not
   implemented in the traditional way using dc. This version is a single process which parses
   and runs a byte code translation of the program. There is an "undocumented" option (-c)
   that causes the program to output the byte code to the standard output instead of running
   it. It was mainly used for debugging the parser and preparing the math library.

   A major source of differences is extensions, where a feature is extended to add more
   functionality and additions, where new features are added. The following is the list of
   differences and extensions.
   LANG environment
          This version does not conform to the POSIX standard in the processing of the LANG
          environment variable and all environment variables starting with LC_.
   names
          Traditional and POSIX bc have single letter names for functions, variables and
          arrays. They have been extended to be multi-character names that start with a letter
          and may contain letters, numbers and the underscore character.
   Strings
          Strings are not allowed to contain NUL characters. POSIX says all characters must be
          included in strings.
   last
          POSIX bc does not have a \fBlast variable. Some implementations of bc use the period
          (.) in a similar way.
   comparisons
          POSIX bc allows comparisons only in the if statement, the while statement, and the
          second expression of the for statement. Also, only one relational operation is
          allowed in each of those statements.
   if statement, else clause
          POSIX bc does not have an else clause.
   for statement
          POSIX bc requires all expressions to be present in the for statement.
   &&, ||, !
          POSIX bc does not have the logical operators.
   read function
          POSIX bc does not have a read function.
   print statement
          POSIX bc does not have a print statement.
   continue statement
          POSIX bc does not have a continue statement.
   array parameters
          POSIX bc does not (currently) support array parameters in full. The POSIX grammar
          allows for arrays in function definitions, but does not provide a method to specify
          an array as an actual parameter. (This is most likely an oversight in the grammar.)
          Traditional implementations of bc have only call by value array parameters.
   function format
          POSIX bc requires the opening brace on the same line as the define key word and the
          auto statement on the next line.
   =+, =-, =*, =/, =%, =^
          POSIX bc does not require these "old style" assignment operators to be defined. This
          version may allow these "old style" assignments. Use the limits statement to see if
          the installed version supports them. If it does support the "old style" assignment
          operators, the statement "a =- 1" will decrement a by 1 instead of setting a to the
          value -1.
   spaces in numbers
          Other implementations of bc allow spaces in numbers. For example, "x=1 3" would
          assign the value 13 to the variable x. The same statement would cause a syntax error
          in this version of bc.
   errors and execution
          This implementation varies from other implementations in terms of what code will be
          executed when syntax and other errors are found in the program. If a syntax error is
          found in a function definition, error recovery tries to find the beginning of a
          statement and continue to parse the function. Once a syntax error is found in the
          function, the function will not be callable and becomes undefined. Syntax errors in
          the interactive execution code will invalidate the current execution block. The
          execution block is terminated by an end of line that appears after a complete
          sequence of statements. For example,
a = 1
b = 2

          has two execution blocks and
{ a = 1
  b = 2 }

          has one execution block. Any runtime error will terminate the execution of the
          current execution block. A runtime warning will not terminate the current execution
          block.
   Interrupts
          During an interactive session, the SIGINT signal (usually generated by the control-C
          character from the terminal) will cause execution of the current execution block to
          be interrupted. It will display a "runtime" error indicating which function was
          interrupted. After all runtime structures have been cleaned up, a message will be
          printed to notify the user that bc is ready for more input. All previously defined
          functions remain defined and the value of all non-auto variables are the value at
          the point of interruption. All auto variables and function parameters are removed
          during the clean up process. During a non-interactive session, the SIGINT signal
          will terminate the entire run of bc.

                                             [51]Limits

   The following are the limits currently in place for this bc processor. Some of them may
   have been changed by an installation. Use the limits statement to see the actual values.
   BC_BASE_MAX
          The maximum output base is currently set at 999. The maximum input base is 16.
   BC_DIM_MAX
          This is currently an arbitrary limit of 65535 as distributed. Your installation may
          be different.
   BC_SCALE_MAX
          The number of digits after the decimal point is limited to INT_MAX digits. Also, the
          number of digits before the decimal point is limited to INT_MAX digits.
   BC_STRING_MAX
          The limit on the number of characters in a string is INT_MAX characters.
   exponent
          The value of the exponent in the raise operation (^) is limited to LONG_MAX.
   multiply
          The multiply routine may yield incorrect results if a number has more than LONG_MAX
          / 90 total digits. For 32 bit longs, this number is 23,860,929 digits.
   variable names
          The current limit on the number of unique names is 32767 for each of simple
          variables, arrays and functions.

                                     [52]Environment Variables

   The following environment variables are processed by bc:
   POSIXLY_CORRECT
          This is the same as the -s option (see section [53]Command Line Options).
   BC_ENV_ARGS
          This is another mechanism to get arguments to bc. The format is the same as the
          command line arguments. These arguments are processed first, so any files listed in
          the environent arguments are processed before any command line argument files. This
          allows the user to set up "standard" options and files to be processed at every
          invocation of bc. The files in the environment variables would typically contain
          function definitions for functions the user wants defined every time bc is run.
   BC_LINE_LENGTH
          This should be an integer specifing the number of characters in an output line for
          numbers. This includes the backslash and newline characters for long numbers.
     ______________________________________________________________________________________

   This document was generated on 20 March 2001 using [54]texi2html 1.56k.



---
http://superuser.com/questions/31445/gnu-bc-modulo-with-scale-other-than-0

GNU BC: "modulo" % with scale other than 0

   If the scale is other than zero, calculations with %, such as 3%2 and 46%4, tend to output
   0. How is the algorithm designed with the scale other than 0?
bc
scale=10
print 4%3   // output 0

   [27]bc
   [28]share|[29]improve this question
   [30]edited Jul 10 '12 at 18:46
   [31]KronoS
   15k2475130
   asked Aug 28 '09 at 16:28
   user3672

   For those who just want something that works: define mod(x,base){oldscale=scale; scale=0;
   result=x%base; scale=oldscale; return result } -  [32]Hello World Oct 12 at 12:16
   add a comment |

3 Answers 3

   [33]active [34]oldest [35]votes
   up vote 7 down vote accepted

   The [36]command manual says this about how BC calculates the modulo:

     The result of the expression is the "remainder" and it is computed in the following way.
     To compute a%b, first a/b is computed to scale digits. That result is used to compute a
     - ( a/b ) * b to the scale of the maximum of scale+scale(b) and scale(a). If scale is
     set to zero and both expressions are integers this expression is the integer remainder
     function.
     ______________________________________________________________________________________

   EDIT: I looked at the source code for GNU BC and found that the mod operator extends the
   division operator. In other words, the modulo is calculated as a by-product of the
   division. It relies on integer division to calculate the modulo. When scale is set, however
   integer division does not take place.

   Try this in BC:
bc
scale = 0
print 5/2

scale = 5
print 5/2

   you should get:
2        << Integer Division
2.50000  << NOT integer division!

   Now let's plug in these figures the way BC does. The manual says it uses a-(a/b)*b to
   calculate. Let's plug in our two results, the one resulting from integer division and the
   one with a scale other than 0.
a - ( a/b ) * b
5 - ( 2   ) * 2  = 1  << CORRECT!
5 - ( 2.5 ) * 2  = 0  << VERY WRONG!

   Without integer division:
a - ( a/b ) * b == a - (  a  ) == 0

   This is why scale must be set to 0 for the modulo to work properly.
   The issue seems to arise out of the design of BC and how it handles numbers with a 'scale'.
   In order for the modulo to work correctly we need integer division.

   There are [37]other much [38]more advanced tools that are free and open source for this
   purpose, and I recommend you use them.
   [39]share|[40]improve this answer
       [41]edited Sep 3 '09 at 13:00
   answered Aug 28 '09 at 17:22
   [42]jweede
   4,68511931

   I am also getting the same results. -  [43]tj111 Aug 28 '09 at 17:25

   Your scale is 0, not "other than zero". Please, set it with "scale=10", for example, and
   then try "3%2". -  user3672 Aug 28 '09 at 17:54

   thanks for the clarification. I'll update my answer. -  [44]jweede Aug 28 '09 at 18:10
   2
   when it says 'scale' with no parenthesis, it refers to the global variable 'scale'. -
   [45]jweede Aug 31 '09 at 11:55
   1
   I'm not sure why it needs to be scale+scale(b) since the scale of a/b should generally be
   zero for it to give meaningful output. -  [46]jweede Sep 3 '09 at 13:19
    | [47]show 7 more comments
   [apple-touch-icon.png]

Did you find this question interesting? Try our newsletter

   Sign up for our newsletter and get our top new questions delivered to your inbox ([48]see
   an example).
   ____________________ Subscribe
   up vote 2 down vote

   user272970's answer is great. Here's a tweak to it:
define int(x) { auto oldscale; oldscale=scale; scale=0; x=x/1; scale=oldscale; return( x ); }
define fmod(x,y) { auto oldscale; oldscale=scale; scale=1000; x = x - y * int(x/y); scale=oldscale;
return( x ); }

   This (using auto oldscale) makes oldscale local to the function. Without that, setting
   oldscale in int() from fmod() will overwrite the oldscale that is trying to be saved in
   fmod(), leaving scale set to 1000 instead of whatever you had before calling fmod().

   I added these functions to ~/.bcrc and set the BC_ENV_ARGS environment variable to ~/.bcrc.
   That will load these functions every time you run bc. So now I can just run fmod(x,y) any
   time I'm in bc without having to manually define those functions every time.

   p.s. scale of 1000 might be overkill in most cases
   [49]share|[50]improve this answer
   answered Apr 4 at 19:10
   [51]Juan
   211
   add a comment |
   up vote 1 down vote

   I solved it this way:

integer

   define int(x) { oldscale=scale; scale=0; x=x/1; scale=oldscale; return( x ); }

modulo

   define mod(x,y) { oldscale=scale; scale=1000; x = x - y * int(x/y); scale=oldscale; return(
   x ); }



---
http://math-blog.com/2012/07/23/floating-point-arithmetic-in-the-bourne-again-shell-bash/

Floating Point Arithmetic in the Bourne Again Shell (BASH)

   Posted by John F. McGowan, Ph.D. in [25]Applied Math on July 23rd, 2012 | [26]2 responses

   This is a brief post on quick ways to perform [27]floating point arithmetic in the GNU
   [28]Bourne Again Shell (BASH), either at the command prompt or in a [29]shell script. It is
   partially a followup to the post [30]Ten Great Quick Calculators for Computer Users and
   overlaps some of the content in this previous post.

   The Bourne Again Shell, or bash, is the default command line processor (shell) for Mac OS
   X, the [31]cygwin environment on MS Windows, and many other Unix and Unix-like systems.
   Especially if you work with numbers, you may want to perform quick floating point
   arithmetic at the command prompt (shell) or in shell scripts. This post covers five ways to
   perform floating point arithmetic in bash: the [32]bc arbitrary precision calculator
   language, the [33]awk pattern scanning and processing language, the [34]perl programming
   language, the [35]python programming language, and the [36]ruby programming language.

   Integer Only Arithmetic in BASH

   Note: One can perform integer arithmetic and integer arithmetic alone (no floating point)
   by using the Unix expr utility and the bash $[N op M] syntax where N and M are any integers
   and op is any arithmetic operator (+, -, *, /). For example:
John@John-HP ~
$ expr 1 + 2
3

John@John-HP ~
$ echo $[1 + 2]
3

   These integer-only arithmetic methods were described more fully in the previous post
   [37]Ten Great Quick Calculators for Computer Users.

   Five Ways to Perform Floating Point Arithmetic in BASH

   (1) BC

   The following commands show how to perform floating point arithmetic (addition,
   subtraction, multiplication, and division) at the bash shell prompt using the bc arbitrary
   precision calculator language. Note the need to escape the multiply operator * with a
   backslash or enclose the arithmetic expression in single quotes. Note the use of the
   backtick myvar=`command` syntax to assign the results of the arithmetic to a bash variable.

   Note that there should be no space between the variable name and the equal sign in the
   assignment, otherwise an error occurs.
John@John-HP ~
$ echo 1.1 + 2.2 | bc -l
3.3

John@John-HP ~
$ echo 1.1 - 2.2 | bc -l
-1.1

John@John-HP ~
$ echo 1.1 * 2.2 | bc -l
1.1  (THIS IS WRONG!!!!)

John@John-HP ~
$ echo 1.1 \* 2.2 | bc -l
2.42   (THIS IS RIGHT!!!)

John@John-HP ~
$ echo '1.1 * 2.2' | bc -l
2.42    (THIS IS RIGHT!!!)

John@John-HP ~
$ echo '1.1 / 2.2' | bc -l
.50000000000000000000

John@John-HP ~
$ myvar=`echo '1.1 / 2.2' | bc -l`

John@John-HP ~
$ echo $myvar
.50000000000000000000


   (2) AWK

   The following commands show how to perform floating point arithmetic (addition,
   subtraction, multiplication, and division) at the bash prompt using the awk pattern
   scanning and processing language. The AWK operators and functions for raising a number to a
   power (**,^), the square root (sqrt(x)), the natural logarithm (log(x)), the sine function
   (sin(x)), cosine function (cos(x)), and the arctangent (atan2(y,x)) are also shown. Note
   the use of the backtick myvar=`command` syntax to assign the results of the arithmetic to a
   bash variable. AWK has the advantage that it is very old and is almost always available on
   Unix and Unix-like systems.

   Note that there should be no space between the variable name and the equal sign in the
   variable assignment.
John@John-HP ~
$ echo - | awk '{print 1.1 + 2.2}'
3.3

John@John-HP ~
$ echo - | awk '{print 1.1 - 2.2}'
-1.1

John@John-HP ~
$ echo - | awk '{print 1.1 * 2.2}'
2.42

John@John-HP ~
$ echo - | awk '{print 1.1 / 2.2}'
0.5

John@John-HP ~
$ echo - | awk '{print 1.1 ^ 2.2}'
1.23329

John@John-HP ~
$ echo - | awk '{print 1.1 ** 2.2}'
1.23329

John@John-HP ~
$ echo - | awk '{print log(10.0)}'
2.30259

John@John-HP ~
$ echo - | awk '{print sqrt(2.0)}'
1.41421

John@John-HP ~
$ echo - | awk '{print sin(1.0)}'
0.841471

John@John-HP ~
$ echo - | awk '{print cos(1.0)}'
0.540302

John@John-HP ~
$ echo - | awk '{print atan2(1.0, 1.0)}'
0.785398

John@John-HP ~
$ myvar=`echo - | awk '{print 1.1 + 2.2}'`

John@John-HP ~
$ echo $myvar
3.3


   (3) PERL

   The following commands show how to perform floating point arithmetic (addition,
   subtraction, multiplication, and division) using the Perl programming language at the bash
   prompt. Note the use of the backtick myvar=`command` syntax to assign the results of the
   arithmetic to a bash variable. Perl is widely used and almost always already installed on
   Unix and Unix-like systems.

   Note that there should be no space between the variable name and the equal sign in the
   variable assignment.
John@John-HP ~
$ perl -e 'print 1.1 + 2.2'
3.3
John@John-HP ~
$ perl -e 'print 1.1 - 2.2'
-1.1
John@John-HP ~
$ perl -e 'print 1.1 * 2.2'
2.42
John@John-HP ~
$ perl -e 'print 1.1 / 2.2'
0.5
John@John-HP ~
$ myvar2=`perl -e 'print 1.1 + 2.2'`

John@John-HP ~
$ echo $myvar2
3.3


   (4) PYTHON

   The following commands show how to perform floating point arithmetic (addition,
   subtraction, multiplication, and division) using the Python programming language at the
   bash prompt. Note the use of the backtick myvar=`command` syntax to assign the results of
   the arithmetic to a bash variable. Python is widely used and frequently already installed
   on Unix and Unix-like systems.

   Note that there should be no space between the variable name and the equal sign in the
   variable assignment.
John@John-HP ~
$ python -c 'print 1.1 + 2.2'
3.3

John@John-HP ~
$ python -c 'print 1.1 - 2.2'
-1.1

John@John-HP ~
$ python -c 'print 1.1 * 2.2'
2.42

John@John-HP ~
$ python -c 'print 1.1 / 2.2'
0.5

John@John-HP ~
$ myvar3=`python -c 'print 1.1 + 2.2'`

John@John-HP ~
$ echo $myvar3
3.3

   (5) RUBY

   The following commands show how to perform floating point arithmetic (addition,
   subtraction, multiplication, and division) using the Ruby programming language at the bash
   prompt. Note the use of the backtick myvar=`command` syntax to assign the results of the
   arithmetic to a bash variable. Ruby is widely used and sometimes already installed on Unix
   and Unix-like systems.

   Note that there should be no space between the variable name and the equal sign in the
   variable assignment.
John@John-HP ~
$ ruby -e 'print 1.1 + 2.2'
3.3
John@John-HP ~
$ ruby -e 'print 1.1 - 2.2'
-1.1
John@John-HP ~
$ ruby -e 'print 1.1 * 2.2'
2.42
John@John-HP ~
$ ruby -e 'print 1.1 / 2.2'
0.5
John@John-HP ~
$ myvar4=`ruby -e 'print 1.1 + 2.2'`

John@John-HP ~
$ echo $myvar4
3.3


   These same commands to perform floating point arithmetic can be included in Bourne Again
   Shell (bash) scripts.

   Conclusion

   There are at least five ways to perform floating point arithmetic under the Unix or GNU
   Bourne Again Shell (bash), either at the command prompt or in shell scripts. These are the
   [38]bc arbitrary precision calculator language, the [39]awk pattern scanning and processing
   language, the [40]perl programming language, the [41]python programming language, and the
   [42]ruby programming language.

   AWK is most likely to be preinstalled on a Unix or Unix-like system, followed by BC and
   PERL. Python is now fairly common although still not as common as PERL. RUBY is becoming
   fairly common, but it is still not as common as Python in the author's experience. BC has
   the special advantage that it is an arbitrary precision calculator whereas the others are
   usually 32 or 64 bit precision floating point by default.

   (c) 2012 John F. McGowan
