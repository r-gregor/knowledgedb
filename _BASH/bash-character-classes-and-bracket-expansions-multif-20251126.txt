filename: bash-character-classes-and-bracket-expansions-multif-20251126.txt
https://www.gnu.org/software/grep/manual/html_node/Character-Classes-and-Bracket-Expressions.html

3.2 Character Classes and Bracket Expressions

A bracket expression is a list of characters enclosed by '[' and ']'. It matches any single character in that
list. If the first character of the list is the caret '^', then it matches any character not in the list, and
it is unspecified whether it matches an encoding error. For example, the regular expression '[0123456789]'
matches any single digit, whereas '[^()]' matches any single character that is not an opening or closing
parenthesis, and might or might not match an encoding error.

Within a bracket expression, a range expression consists of two characters separated by a hyphen. In the
default C locale, it matches any single character that appears between the two characters in ASCII order,
inclusive. For example, '[a-d]' is equivalent to '[abcd]'. In other locales the behavior is unspecified:
'[a-d]' might be equivalent to '[abcd]' or '[aBbCcDd]' or some other bracket expression, or it might fail to
match any character, or the set of characters that it matches might be erratic, or it might be invalid. To
obtain the traditional interpretation of bracket expressions, you can use the 'C' locale by setting the LC_ALL
environment variable to the value 'C'.

Finally, certain named classes of characters are predefined within bracket expressions, as follows. Their
interpretation depends on the LC_CTYPE locale; for example, '[[:alnum:]]' means the character class of numbers
and letters in the current locale.

'[:alnum:]'
    Alphanumeric characters: '[:alpha:]' and '[:digit:]'; in the 'C' locale and ASCII character encoding, this
    is the same as '[0-9A-Za-z]'.

'[:alpha:]'
    Alphabetic characters: '[:lower:]' and '[:upper:]'; in the 'C' locale and ASCII character encoding, this
    is the same as '[A-Za-z]'.

'[:blank:]'
    Blank characters: space and tab.

'[:cntrl:]'
    Control characters. In ASCII, these characters have octal codes 000 through 037, and 177 (DEL). In other
    character sets, these are the equivalent characters, if any.

'[:digit:]'
    Digits: 0 1 2 3 4 5 6 7 8 9.

'[:graph:]'
    Graphical characters: '[:alnum:]' and '[:punct:]'.

'[:lower:]'
    Lower-case letters; in the 'C' locale and ASCII character encoding, this is a b c d e f g h i j k l m n o
    p q r s t u v w x y z.

'[:print:]'
    Printable characters: '[:alnum:]', '[:punct:]', and space.

'[:punct:]'
    Punctuation characters; in the 'C' locale and ASCII character encoding, this is ! " # $ % & ' ( ) * + , -
    . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~.

'[:space:]'
    Space characters: in the 'C' locale, this is tab, newline, vertical tab, form feed, carriage return, and
    space. See Usage, for more discussion of matching newlines.

'[:upper:]'
    Upper-case letters: in the 'C' locale and ASCII character encoding, this is A B C D E F G H I J K L M N O
    P Q R S T U V W X Y Z.

'[:xdigit:]'
    Hexadecimal digits: 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f.

Note that the brackets in these class names are part of the symbolic names, and must be included in addition
to the brackets delimiting the bracket expression.

If you mistakenly omit the outer brackets, and search for say, '[:upper:]', GNU grep prints a diagnostic and
exits with status 2, on the assumption that you did not intend to search for the regular expression '[:epru]'.

Special characters lose their special meaning inside bracket expressions.

']'
    ends the bracket expression if it's not the first list item. So, if you want to make the ']' character a
    list item, you must put it first.

'[.'
    represents the open collating symbol.

'.]'
    represents the close collating symbol.

'[='
    represents the open equivalence class.

'=]'
    represents the close equivalence class.

'[:'
    represents the open character class symbol, and should be followed by a valid character class name.

':]'
    represents the close character class symbol.

'-'
    represents the range if it's not first or last in a list or the ending point of a range. To make the '-' a
    list item, it is best to put it last.

'^'
    represents the characters not in the list. If you want to make the '^' character a list item, place it
    anywhere but first.


---
https://www.gnu.org/software/sed/manual/html_node/Character-Classes-and-Bracket-Expressions.html

5.5 Character Classes and Bracket Expressions

A bracket expression is a list of characters enclosed by '[' and ']'. It matches any single character in that
list; if the first character of the list is the caret '^', then it matches any character not in the list. For
example, the following command replaces the words 'gray' or 'grey' with 'blue':
sed 's/gr[ae]y/blue/'

Bracket expressions can be used in both basic and extended regular expressions (that is, with or without the
-E/-r options).

Within a bracket expression, a range expression consists of two characters separated by a hyphen. It matches
any single character that sorts between the two characters, inclusive. In the default C locale, the sorting
sequence is the native character order; for example, '[a-d]' is equivalent to '[abcd]'.

Finally, certain named classes of characters are predefined within bracket expressions, as follows.

These named classes must be used inside brackets themselves. Correct usage:

$> echo 1 | sed 's/[[:digit:]]/X/'
X

Incorrect usage is rejected by newer sed versions. Older versions accepted it but treated it as a single
bracket expression (which is equivalent to '[dgit:]', that is, only the characters d/g/i/t/:):

# current GNU sed versions - incorrect usage rejected
$> echo 1 | sed 's/[:digit:]/X/'
sed: character class syntax is [[:space:]], not [:space:]

# older GNU sed versions
$> echo 1 | sed 's/[:digit:]/X/'
1

'[:alnum:]'
    Alphanumeric characters: '[:alpha:]' and '[:digit:]'; in the 'C' locale and ASCII character encoding, this
    is the same as '[0-9A-Za-z]'.

'[:alpha:]'
    Alphabetic characters: '[:lower:]' and '[:upper:]'; in the 'C' locale and ASCII character encoding, this
    is the same as '[A-Za-z]'.

'[:blank:]'
    Blank characters: space and tab.

'[:cntrl:]'
    Control characters. In ASCII, these characters have octal codes 000 through 037, and 177 (DEL). In other
    character sets, these are the equivalent characters, if any.

'[:digit:]'
    Digits: 0 1 2 3 4 5 6 7 8 9.

'[:graph:]'
    Graphical characters: '[:alnum:]' and '[:punct:]'.

'[:lower:]'
    Lower-case letters; in the 'C' locale and ASCII character encoding, this is a b c d e f g h i j k l m n o
    p q r s t u v w x y z.

'[:print:]'
    Printable characters: '[:alnum:]', '[:punct:]', and space.

'[:punct:]'
    Punctuation characters; in the 'C' locale and ASCII character encoding, this is ! " # $ % & ' ( ) * + , -
    . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~.

'[:space:]'
    Space characters: in the 'C' locale, this is tab, newline, vertical tab, form feed, carriage return, and
    space.

'[:upper:]'
    Upper-case letters: in the 'C' locale and ASCII character encoding, this is A B C D E F G H I J K L M N O
    P Q R S T U V W X Y Z.

'[:xdigit:]'
    Hexadecimal digits: 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f.


Note that the brackets in these class names are part of the symbolic names, and must be included in addition
to the brackets delimiting the bracket expression.

Most meta-characters lose their special meaning inside bracket expressions:

']'
    ends the bracket expression if it's not the first list item. So, if you want to make the ']' character a
    list item, you must put it first.

'-'
    represents the range if it's not first or last in a list or the ending point of a range.

'^'
    represents the characters not in the list. If you want to make the '^' character a list item, place it
    anywhere but first. 


TODO: incorporate this paragraph (copied verbatim from BRE section).

The characters $, *, ., [, and \ are normally not special within list. For example, [\*] matches either '\' or
'*', because the \ is not special here. However, strings like [.ch.], [=a=], and [:space:] are special within
list and represent collating symbols, equivalence classes, and character classes, respectively, and [ is
therefore special within list when it is followed by ., =, or :. Also, when not in POSIXLY_CORRECT mode,
special escapes like \n and \t are recognized within list. See Escapes.

'[.'
    represents the open collating symbol.

'.]'
    represents the close collating symbol.

'[='
    represents the open equivalence class.

'=]'
    represents the close equivalence class.

'[:'
    represents the open character class symbol, and should be followed by a valid character class name.

':]'
    represents the close character class symbol. 


---
https://www.shell-tips.com/bash/character-class/#gsc.tab=0

How to Master String Pattern Matching using Bash Character Classes
2023-03-21

   Bash scripts can be used for many purposes, from automating system administration tasks to creating
   tools for data analysis. One area where Bash shines is in its ability to manipulate characters and
   strings. GNU Bash provides several character classes that can be used in pattern matching and regular
   expressions. In this blog post, we will explore these character classes and learn how to use them in
   a Bash script that test and categorize ASCII characters in a detailed ASCII table.

What are character classes in Bash?
   In Bash, character classes are patterns representing a group of characters. They are enclosed in
   square brackets and can be used to match or test for certain types of characters. For example, the
   character class [[:digit:]] matches any digit character (0-9), and [[:alpha:]] matches any alphabetic
   character.

   Bash supports several built-in character classes, which are described below:

   --------------------------------------------------------------------------------------------------
   Class       Description
   --------------------------------------------------------------------------------------------------
   alnum       The [:alnum:]  character class matches all alphabetic and numeric characters.
   alpha       The [:alpha:]  character class matches all alphabetic characters.
   ascii       The [:ascii:]  character class matches all ASCII characters.
   blank       The [:blank:]  character class matches spaces and tabs.
   cntrl       The [:cntrl:]  character class matches all control characters.
   digit       The [:digit:]  character class matches all numeric digits.
   graph       The [:graph:]  character class matches all printable characters except space.
   lower       The [:lower:]  character class matches all lowercase alphabetic characters.
   print       The [:print:]  character class matches all printable characters.
   punct       The [:punct:]  character class matches all punctuation characters.
   space       The [:space:]  character class matches all whitespace characters.
   upper       The [:upper:]  character class matches all uppercase alphabetic characters.
   word        The [:word:]   character class matches all alphanumeric characters and the underscore.
   xdigit      The [:xdigit:] character class matches all hexadecimal digits.
   --------------------------------------------------------------------------------------------------

   Make sure to enclose the desired character class name in square brackets with a colon to use that
   character class in a Bash script. For example, to match all alphabetic characters, we can use the
   [:alpha:] character class as follows:

# Using a If Statement
if [[ $char =~ [:alpha:] ]]; then
	# do something
fi

# Or using ls command
ls -ld [[:alpha:]]*

   We can also use negation with character classes. For example, to match all non-alphabetic characters,
   we can use the caret symbol ^ as follows:

# Using a If Statement
if [[ $char =~ [^[:alpha:]] ]]; then
	# do something
fi

#  Or using ls command
l s -ld [^[:alpha:]]*
  
E xample Script to Generate an ASCII-Table with Character Class
  
    The script we will explore uses character classes in Bash to test and categorize ASCII characters. It
    does this by iterating through the ASCII range from 32 to 127. Then, for each character, checks
    whether it belongs to any of the following character classes: alnum, alpha, ascii, blank, cntrl,
    digit, graph, lower, print, punct, space, upper, word, xdigit.
  
for ((i=32;i<127;i++)); do
	printf -v char "\x$(printf '%x' "$i" )"
	as_class=()
	for class in alnum alpha ascii blank cntrl digit graph lower print punct space upper word xdigit; do
		[[ "$char" = @([[:$class:]]) ]] && as_class+=("$class") || as_class+=('')
	done
	printf '%3d | %s | %-6s | %-6s | %-6s | %-6s | %-6s | %-6s | %-6s | %-6s | %-6s | %-6s | %-6s | %-6s \
	| %-6s | %-6s | %-6s\n' "$i" "$char" "${as_class[@]}"
done

   Let's break down this snippet script and see what it does:
    1. The for loop icon mdi-link-variant iterates through the ASCII range from 32 to 127.
    2. The printf command converts the ASCII code to its corresponding character and stores it in the
       char variable.
    3. The as_class bash array icon mdi-link-variant is initialized to later store the character
       class.
    4. The inner for loop checks whether the character belongs to each of the 14 character classes using
       the Bash conditional statement icon mdi-link-variant with [[ ... ]] test operator and the @()
       array construct.
    5. If the character belongs to a class, its name is added to the as_class array.
    6. The final printf command prints the character code, the character itself, and the results of the
       character class tests in a formatted table.

   This Bash script is a helpful tool for testing and categorizing ASCII characters based on their
   properties. By using character classes, the script can quickly and easily identify characters
   belonging to specific categories, such as digits, letters, or punctuation. This script is an
   excellent example of how Bash can be used to manipulate characters and strings and can be easily
   modified to fit specific use cases.

   Example output: [https://www.shell-tips.com/bash/character-class/ascii_character_classes.png#center]ASCII
   Characters - Bash Character Classess - Essentials References

Conclusion
   In this blog post, we explored the Bash built-in character classes and learned how to use them in a
   Bash script. Character classes are a powerful feature of Bash and can be used in various ways to
   match patterns and manipulate strings. With this knowledge, you can make your Bash scripts more
   efficient and powerful.


---

