filename: bash-test-patterns-in-scripts-20260226.txt
https://www.howtogeek.com/the-test-patterns-that-real-world-bash-scripts-actually-use/

The 6 test patterns that real-world Bash scripts actually use
Feb 14, 2026

   Bash, and other shells like zsh, support several test operators that you can use to check conditions:
   whether something is a file, or if one number is larger than another, for example. These tests are
   very useful and will likely feature in most shell scripts you write.

   Discover how to use these operators with examples from real-world shell scripts.

-f to check if a regular file exists
   The -f operator checks whether the given file path points to a regular file or not, and it's one of
   the most useful you'll encounter. You can [38]use it in a conditional block with this structure:

if [ -f file ]
then
	echo true
else
	echo false
fi

   For example:
if [ -f /bin/ls ]; then echo 0; else echo 1; fi

   This shorter version (useful for testing) outputs the result of the test directly:
[ -f /bin ]; echo $?

   In a script, it's often convenient to use boolean operators instead of the if construct. Remember
   that the [ (test) command is still required to evaluate the condition:
[ -f /bin/ls ] && echo "It's all OK, we can run ls"

   One common use for this check is to load configuration from a file that may not exist:
[ -f CONFIG-FILE ] && . CONFIG-FILE

   Another use lets you create a file with a unique name, so you can avoid accidentally overwriting
   existing data:

while [[ -f $filename ]]; do
	filename=${filename%.html}$RANDOM.html
done

   When this loop completes, the filename variable will hold a name that doesn't already exist. RANDOM
   is a special shell variable that returns a different value each time it is accessed.

   This isn't the best way to create random values. If you want to create a temporary file and don't
   care about its location, consider mktemp instead.

-d to check for a directory
   The -d operator tests its file operand to see if it's a directory. If there's no such file, or if
   it's not a directory, -d returns false.

   Many scripts create files in a directory, when transforming input files or generating content. For
   example, tar -C directory will cause [39]tar to archive files from, or extract them to, the given
   directory. If you do something similar in your own scripts, you can check whether the given directory
   exists:

if [ ! -d "$OUTPUT_DIR" ]
then
	mkdir -p "$OUTPUT_DIR"
fi

   This example creates the directory if it doesn't exist, but your program's behavior may differ. In
   this case, it's not strictly necessary since mkdir -p silently ignores an existing directory. But
   it's good practice anyway, and checking gives you the option of logging or raising an error if
   required.

   Another common case for this operator is almost the opposite: clearing up any directories that your
   script may have created. For example, if you use a cache directory to store files temporarily, you
   can clear it out periodically or on demand:

if [[ -d "$HOME/.cache/myscript" ]]; then
	rm -rf "$HOME/.cache/myscript" 2> /dev/null || true
fi

   I use the -d operator in one of my own shell functions to verify the contents of my PATH environment
   variable:

echo $PATH | tr ':' '\n' | while read tmppath; do
	if [ ! -d "$tmppath" ]; then
		echo "bad PATH: dir does not exist: $tmppath" >&2
	fi
done

-n to check for a string with a nonzero length
   The -n operator returns true (0) if its operand is a non-empty string, otherwise it returns false
   (1). Since a fixed string will always return the same value, it's typically used with a variable. You
   can use it as follows:

if [[ -n $var ]]
then
	echo "non-empty"
else
	echo "empty"
fi

   This operator will return true for an undefined variable, since such variables always evaluate to the
   empty string.

   You can use -n in conjunction with code that depends on a variable having some kind of value. For
   example, a very common case involves checking the shell to see if certain extended functionality can
   be used. The zsh shell sets a ZSH_VERSION environment variable, so this function checks if zsh is in
   use:

shell_is_zsh() {
	[ -n "${ZSH_VERSION-}" ]
}

-z to check for an empty string
   The -z operator is simply the opposite of -n; it checks for an empty string. Since you can use the !
   operator to reverse a condition, -z isn't strictly necessary. You can always rewrite code that uses
   it, for example:

if [[ -z $var ]]; then ...

   This code can be written using -n instead, as:
if [[ ! -n $var ]]; then ...

   However, -z is still useful because it makes the intention more explicit and produces better
   consistency among a series of tests. The condition can be useful for bailing out of a function or
   script early, in case a required value is missing:

login() {
	[[ -z $user_name && -z $user_password ]] && return 1

	# more code from here down to implement the actual login process
}

-x to check for an executable
   The -x operator determines if the given file can be executed by the current user. This involves
   checking [40]the file's execute bit.

   You can use -x in your script if you need to run an external program, for example:

[ -x "./myscript.sh" ] || echo "Missing execute permissions!"

   You won't usually need to check standard commands like this, although it can be handy to combine with
   command for common programs that may or may not be installed, e.g.:

if [ -x "$(command -v git)" ]; then
	echo "Git is installed and ready."
else
	echo "Please install Git."
	exit 1
fi

   Here, "$(command -v git)" expands to the full path of the git command, as your shell resolves it
   using PATH. If this is the empty string or the current user does not have permission to execute that
   file, the script will report an error and halt.

-nt to compare file dates
   The -nt operator takes two operands and tests whether the first is a newer file than the second. It's
   not a part of the formal POSIX specification, so relying on -nt will result in slightly less-portable
   scripts. However, it does work in both Bash and Zsh, and if you're writing a script just for your own
   benefit, there's no problem tying it to a specific shell.

[[ $file1 -nt $file2 ]]

   One good use of -nt is to determine the most recent file in a set:
unset -v latest

for file in *; do
	[[ $file -nt $latest ]] && latest=$file
done

echo $latest

   You can do something similar with ls/find in a pipeline, but the above approach has fewer
   dependencies and may be clearer. It should also be more robust, since parsing ls output is not 100%
   reliable.

   You can also use this operator to approximate [41]a basic form of Make:

[[ "main.c" -nt "main" ]] && gcc -o main main.c

   Much like Make does, this command will compile the C source code only if it's changed since the
   binary was created. To cater for the initial case, when the program has never been compiled, you can
   combine it with the -f operator:

[[ ! -f "main" || "main.c" -nt "main" ]] && gcc -o main main.c


---

