filename: bash-assign-multiple-variables-from-user-input-multif-20251028.txt
https://unix.stackexchange.com/questions/153331/using-sed-with-herestring-and-read-a

Using sed with herestring (<<<) and read -a

   I use sed with <<< and read to assign all words in a string to variables. What I do is:
$> read -a A0 <<< $(sed '2q;d' /proc/stat)

   Hence, sed reads the second line of the file file and immediately quits. The line sed has read in is
   fed to <<< which does expands the input it receives from sed and read -a assign the resulting values
   of <<< to elements of an array. Is the usage of <<< and sed in this way a good idea or are there
   obvious reasons that speak against this and most of all, is there a faster way to do this?

***
   You can use array assignment directly:
A0=($(sed '2q;d' /proc/stat))

   Beware that this performs globbing: if the output of the command contains shell wildcards, then the
   words containing wildcards are replaced by the list of matching files if there are any. If the output
   of the command might contain one of the characters \[?*, temporarily turn off globbing:
set -f
A0=($(sed '2q;d' /proc/stat))
set +f

   This can be tiny faster than using read:
$> time for i in {1..1000}; do read -a A0 <<< $(sed '2q;d' /proc/stat); done

real    0m2.829s
user    0m0.220s
sys     0m0.480s

$> time for i in {1..1000}; do A0=($(sed '2q;d' /proc/stat)); done

real    0m2.388s
user    0m0.128s
sys     0m0.276s

   With bash 4.0 and above, you can use mapfile:
mapfile -t < <(sed '2q;d' /proc/stat)

   But mapfile seems to be slowest:
$> time for i in {1..1000}; do mapfile -t < <(sed '2q;d' /proc/stat); done

real    0m3.990s
user    0m0.104s
sys     0m0.444s

***
   The syntax seems too complex to my eyes. I'd use the following instead:
read -a A0 < <( sed '2q;d' /proc/stat )

   I usually use the <<< word syntax when I need a command to take input from a variable, not from
   another command.

***
   Instead of any sed, the fastest for me (on Ubuntu 22.04 'jammy', yeah I'm lazy) is
{ read; read -a A0; } </proc/stat


---
https://stackoverflow.com/questions/36382565/how-to-assign-multiple-bash-variables-from-user-input

How to assign multiple bash variables from user input

   Using read -p "ENTER 1 - 5 WORDS" v1 v2 v3 v4 v5 allows me to assign value to each of the variables v
   by typing them on the command line. Is this the most practical approach? Suppose I wanted to assign a
   larger number of variables. Would I list each of them in this same way? I have tried read -p "ENTER
   1-20 WORDS" {v1..v20} which didn't work.

***
   v is not part of the sequence. Try this :
read -p "ENTER 1-20 WORDS" v{1..20}

***
   You might want to read into an array with read -a:
$> read -a arr -p "Enter words: "
Enter words: v1 v2 v3 v4 v5

$> echo "${arr[@]}"
v1 v2 v3 v4 v5

$> read -a arr -p "Enter words: "
Enter words: v1 v2 v3 v4 v5 v6 v7 v8 v9 v10

$> echo "${arr[@]}"
v1 v2 v3 v4 v5 v6 v7 v8 v9 v10

   This uses shell word splitting and assigns the input to the array arr, elements of which can then be
   accessed using ${arr[0]}, ${arr[1]} etc.

   The main advantage is that the array holds exactly as many elements as you entered and you don't have
   to know in advance how many there will be.


---
https://askubuntu.com/questions/707751/way-to-take-multiple-input-from-same-line-separated-by-a-space

Way to take multiple input from same line separated by a space

   I need to store three names in three different variables but taking input from a single line
   separated by spaces between them. Is there any way to do that?

***
   You should be able to use the bash shell's built in read command for that.
$> read -p "Please enter names: " name1 name2 name3
Please enter names: alice bob carol

$> echo $name1
alice

$> echo $name2
bob

$> echo $name3
carol


---
https://www.baeldung.com/linux/bash-multiple-variable-assignment

Linux Bash: Multiple Variable Assignment
March 18, 2024

1. Overview
Assigning multiple variables in a single line of code is a handy feature in some programming languages, such
as Python and PHP.

In this quick tutorial, we'll take a closer look at how to do multiple variable assignment in Bash scripts.

2. Multiple Variable Assignment
Multiple variable assignment is also known as tuple unpacking or iterable unpacking.

It allows us to assign multiple variables at the same time in one single line of code.

Let's take a look at a simple Python example to understand what multiple variable assignment looks like:

var1, var2, var3 = "I am var1", "I am var2", "I am var3"

In the example above, we assigned three string values to three variables in one shot.

Next, let's prove if the values are assigned to variables correctly using the print() function:

print(var1)
I am var1

print(var2)
I am var2

print(var3)
I am var3

As the output shows, the assignment works as we expect.

Using the multiple variable assignment technique in Bash scripts can make our code look compact and give us
the benefit of better performance, particularly when we want to assign multiple variables by the output of
expensive command execution.

For example, let's say we want to assign seven variables - the calendar week number, year, month, day, hour,
minute, and second - based on the current date. We can straightforwardly do:

WEEK="$(date +'%W')"
YEAR="$(date +'%Y')"
MONTH="$(date +'%m')"
...

These assignments work well.

However, during the seven executions of the date commands, the current time is always changing, and we could
get unexpected results.

Further, we'll execute the date command seven times. If the command were an expensive process, the multiple
assignments would definitely hurt the performance.

We can tweak the output format to ask the date command to output those required fields in one single shot:

$> date +'%W %Y %m %d %H %M %S'
08 2021 02 23 19 15 52

In other words, if we can somehow use the multiple variable assignment technique, we merely need to execute
the date command once to assign the seven variables, something like:

WEEK YEAR MONTH DAY HOUR MINUTE SECOND="$(date +'%W %Y %m %d %H %M %S')"

Unfortunately, not all programming languages support the multiple variable assignment feature. Bash and shell
script don't support this feature. Therefore, the assignment above won't work.

However, we can achieve our goal in some other ways.

Next, let's figure them out.

3. Using the read Command
The read command is a powerful Bash built-in utility to read standard input (stdin) to shell variables.

It allows us to assign multiple variables at once:

$> read -r var1 var2 var3
100 200 300  #<- We input the values here

$> echo "var1=$var1; var2=$var2; var3=$var3"
var1=100; var2=200; var3=300

We use the -r option in the example above to disable backslash escapes when it reads the values.

However, the read command reads from stdin. It's not so convenient to be used as variable assignments in shell
scripts. After all, not all variables are assigned by user inputs.

But there are some ways to redirect values to stdin. Next, let's see how to do it.

3.1. Using Process Substitution and IO Redirection
We know that we can use "< FILE" to redirect FILE to stdin. Further, process substitution can help us to make
the output of a command appear like a file.

Therefore, we can combine the process substitution and the IO redirection together to feed the read command:

$> read -r var1 var2 var3 < <(COMMAND)

Let's test it with the previous date command and seven variables' assignment problem:

$> read -r WEEK YEAR MONTH DAY HOUR MINUTE SECOND < <(date +'%W %Y %m %d %H %M %S')

$> echo "week: $WEEK\nyear: $YEAR\nmonth: $MONTH\nday: $DAY\nhour: $HOUR\nminute: $MINUTE\nsecond: $SECOND"
week: 08
year: 2021
month: 02
day: 23
hour: 17
minute: 35
second: 17

As the output above shows, we've assigned seven variables in one shot using the process substitution and IO
redirection trick.

3.2. Using Command Substitution and the Here-String (5+)!!
Alternatively, we can use the here-string to feed the stdin of the read command:

$> read -r var1 var2 var3 <<< "101 202 303"
$> echo "var1=$var1; var2=$var2; var3=$var3"
var1=101; var2=202; var3=303

If we replace the hard-coded string with a command substitution, we can set multiple variables using a
command's output.

Let's test with the seven variables and the date command scenario:

$> read -r WEEK YEAR MONTH DAY HOUR MINUTE SECOND <<< "$(date +'%W %Y %m %d %H %M %S')"
$> echo "week: $WEEK\nyear: $YEAR\nmonth: $MONTH\nday: $DAY\nhour: $HOUR\nminute: $MINUTE\nsecond: $SECOND"
week: 08
year: 2021
month: 02
day: 23
hour: 19
minute: 26
second: 09

We've assigned seven variables in one shot. Also, the date command is executed only once.

Thus, the read command can help us to achieve multiple variables assignment.

3.3. Changing the Delimiter
The read command will take the value of the IFS variable as the delimiter. By default, it's whitespace.

But we know that the output of a command is not always delimited by whitespace.

Let's change the output format of the date command:

$> date +'%W@%F %T@%A' 
08@2021-02-23 21:45:40@Tuesday

This time, the output is delimited by the '@' character and has three fields: the week number, the current
date and time, and the weekday of the current date. The second field contains a space.

Now, we're about to assign the three fields to three variables in one shot.

Obviously, it won't work with the default delimiter. We can change the delimiter by setting the IFS variable:
$> IFS='@' read -r WEEK_NO DATE_TIME WEEK_DAY <<< "$(date +'%W@%F %T@%A')"
$> echo "week_no: $WEEK_NO\ndate_time: $DATE_TIME\nweek_day: $WEEK_DAY"
week_no: 08
date_time: 2021-02-23 21:53:53
week_day: Tuesday

It's worthwhile to mention that in the example above, the change to the IFS variable only affects the read
command following it.

4. Using an Array
Another way to assign multiple variables using a command's output is to assign the command output fields to an
array.

Let's show how it works with the date command and seven variables example:
$> readarray -d' ' -t ARR <<< "$(date +'%W %Y %m %d %H %M %S')"

$> echo -e "week: ${ARR[0]}\nyear: ${ARR[1]}\nmonth: ${ARR[2]}\nday: ${ARR[3]}\nhour: ${ARR[4]}\nminute: \
${ARR[5]}\nsecond: ${ARR[6]}"
week: 08
year: 2021
month: 02
day: 23
hour: 22
minute: 19
second: 23

In the example, we used the Bash built-in readarray command to read the date command's output.

The default delimiter used by the readarray command is a newline character. But we can set space as the
delimiter using the -d option.

5. Conclusion
In this article, we've learned what the multiple variable assignment technique is.

Further, we've addressed how to achieve multiple variable assignment in Bash scripts through examples, even
though Bash doesn't support this language feature.


---
https://askubuntu.com/questions/338857/automatically-enter-input-in-command-line

Automatically enter input in command line

   I'm running a script that it requests entering 'y' on each operation, I am looking for a solution
   like $ ./script < echo 'yyyyyyyyyyyyyy' to pass all my inputs in one time.

***
   There is a command created specifically for that case: yes
$> yes | ./script

   What this does is connect the output of yes to the input of ./script. So when ./script asks for user
   input it will instead get the output of yes. The output of yes is an endless stream of y followed by
   enter. So basically as if the user is entering y for every question of ./script.

   If you want to say no (n) instead of yes (y) you can do it like this:
$> yes n | ./script

   Note that some tools already have an option to always asume yes as answer. Thus no need for an extra
   tool. See here for example: Bypass the yes/no prompt in 'apt-get upgrade'

   Other methods to enter input:
   If you know exactly how many y your script is expecting you can do it like this:
$> printf 'y\ny\ny\n' | ./script

   The newlines (\n) are the enter keys.

   Using printf instead of yes you have more fine grained control of input:
$> printf 'yes\nno\nmaybe\n' | ./script

   Note that in some rare cases the command does not require the user to press enter after the
   character. in that case leave the newlines out:
$> printf 'yyy' | ./script

   For sake of completeness you can also use a here document:
$> ./script << EOF
y
y
y
EOF

   (the actual newlines will be part of the input feeded to ./script)

   Or if your shell supports it a here string:
$> ./script <<< "y
y
y
"

   Or you can create a file with one input per line:
$> ./script < inputfile

   If the command is sufficiently complex and the methods above no longer suffice then you can use
   expect.

   Here is an example of a super simple expect script:
$> spawn ./script
$> expect "are you sure?"
$> send "yes\r"
$> expect "are you really sure?"
$> send "YES!\r"
$> expect eof

Technical nitpick:
   The hypothetical command invocation you gave in your question does not work:
$> ./script < echo 'yyyyyyyyyyyyyy'
bash: echo: No such file or directory

   This is because the shell grammar allows a redirect operator anywhere in the command line. As far as
   the shell is concerned your hypothetical command line is the same as this line:
$> ./script 'yyyyyyyyyyyyyy' < echo
bash: echo: No such file or directory

   That means ./script will be called with the argument 'yyyyyyyyyyyyyy' and the stdin will get input
   from a file named echo. And bash complains since the file does not exists.


---

