filename: bash-read-user-input-into-array-multif-20251028.txt
https://askubuntu.com/questions/29215/how-can-i-read-user-input-as-an-array-in-bash

How can I read user input as an array in Bash?

***
   Here's one way to do it:
while read line; do
	my_array=("${my_array[@]}" $line)
done

echo ${my_array[@]}

   If you just run it, it will keep reading from standard-input until you hit Ctrl+D (EOF). Afterwards,
   the lines you entered will be in my_array. Some may find this code confusing. The body of the loop
   basically says my_array = my_array + element.

***
   Read it using this:
$> read -a arr

   And for printing, use:
for elem in ${arr[@]}
do
	echo $elem
done

***
   And one that doesn't recreate the array each time (though requires bash 3.1 or newer):
array=()
while IFS= read -r -p "Next item (end with an empty line): " line; do
	[[ $line ]] || break  # break if line is empty
	array+=("$line")
done

printf '%s\n' "Items read:"
printf '  «%s»\n' "${array[@]}"

   See http://mywiki.wooledge.org/BashFAQ/001 for more.

***
   How about this one-liner ;)
$> arr=( $(cat -) )
$> echo ${arr[@]}

   Edit:

   In bash,
arr=(val1 val2 ...)

   is the way of assigning to an array. Using it in conjunction with command substitution, you can
   read in arrays from pipeline which is not possible to use read to accomplish this in a
   straight-forward manner:
$> echo -e "a\nb" | read -a arr
$> echo ${arr[@]}

   You will find that it output nothing due to the fact that read does nothing when stdin is a pipe
   since a pipeline may be run in a subshell so that the variable may not be usable at all.

   Using the way suggested by this answer:
$> arr=(`echo -e "a\nb"`)
$> echo ${arr[@]}

   It gives a b which is way simpler and more straight-forward than any workaround given by the answers
   of Read values into a shell variable from a pipe and in bash read after a pipe is not setting
   values.

***
#!/bin/bash

read line
list=(${line})

for i in ${list[@]};do
	echo $i
done

   OUTPUT
./list-input.sh
banna apple pie
banna
apple
pie


---
https://superuser.com/questions/1001755/bash-return-array-from-function-and-display-contents

bash - return array from function and display contents

   After some bash self study and experimenting, I am stuck with returning an array from a function, and
   for the life of me can't see my error.

   In short, what this should/must do is by using a function have a function which reads in
   values/strings from a file, returning an array:
    * declare an array: clients
    * assign the function's return array to array clients
    * display array clients

   It seems to me as if the function reads the whole file and not line by line, thus putting all strings
   into a single cell in the array, and I am not sure how to explicitly display clients[0] as this
   $(clients[0]) fails in bash code

   If by an means I am doing something incorrectly, please point this out too or any suggestions on
   optimising this too

<code>
#!/bin/bash
readArray(){
	local array=()
	local i=0;
	local j=0
	while IFS= read -r LINE  && [[ -n "$LINE" ]] ; do
		array[$((i++))]+=${LINE}; # Append line to the array
		((j++))
	done < "$1";
	rtr=${array[@]}
}
string="/home/cybex/openvpntest/openvpn.log"
declare -a clients
# sed -i '/^$/d' $string
clients=$(readArray "$string")
echo "${clients[@]}"

echo -e "array not empty, displaying array contents\n"

for i in "${!clients[@]}"; do
	echo "$i: ${clients[$i]}"
done
echo -e "\nfinished displaying contents of array"
</code>

$> cat openvpn.log
something
anotherthing
anotherlineoftext
here is one more line
and lastly
one with
a few spaces
nice

   UPDATE For anyone wanting to see how I resolved this:
     * declare a "global" array with
declare -a clients

     * while the function executes, add values DIRECTLY to the clients array

   To display a single index position of an array, ref. last line of code
echo "${clients[0]}"      or any other number >=0

   Working code:

<code>
declare -a clients
readArray(){
	local array=()
	local i=0;
	local j=0
	while IFS= read -r LINE  && [[ -n "$LINE" ]] ; do
		clients[$((i++))]+=${LINE}; # Append line to the array
		((j++))
	done < "$1";
}
string="/home/cybex/openvpntest/openvpn.log"
sed -i '/^$/d' $string
readArray "$string"
echo "${clients[@]}"

echo -e "array not empty, displaying array contents\n"

for i in "${!clients[@]}"; do
	echo "$i: ${clients[$i]}"
done

echo -e "\nfinished displaying contents of array"
echo "${clients[0]}"
</code>

***
   You should do a minimal search in google, because this was the first link returned for "bash return
   array"

Edit:
   In bash, functions don't return values. They can return a status (the same as other programs).

   So, if you want to return something, you should use global variables that are updated inside your
   function.

***
Discussion
   If you have come to the point of wanting to return an array from a function, then you are probably
   aware that you can only return status codes. Boo! You say. :-)

   What can we do with other data in a function that we want to use in another function / context?
    1. echo

   Assuming stdout is set to the terminal, at least you can see the contents of a variable or something.
    2. Output Redirection: > or >>

   Not ideal, but possible. :-) There are probably more things you can do, but let's stop here.

Discussion continued ...
   Let us say we think option #1 above sounds promising. What usually happens? Something like this ...
function listToString () {
	echo "$*"
}

   Reference: Your UNIX: The Ultimate Guide, 2nd Edition, p. 387 (last para).

   If I call doSomething, it might, say, send a string message to stdout. That output can be captured in
   two different ways.
    1. Backticks `doSomething`
    2. This thing: $(doSomthing)

   If that is true, then you can save something you send to stdout in another context.
var1=`doSomething`

   or
var1=$(doSomething)

In summary ....
   Convert a list to a string. Echo the string. Capture the echoed string with command substitution (see
   above). Use read combined with a here string (<<<) to convert the string into an array. Use array at
   your leisure.

   File: new_users
fsmith
jdoe

   Let's say we wanted to add new users with a function we made called addAccounts that loops over
   username arguments. The order of march would be.
    1. Make file
    2. Read file
    3. Convert list to a string
    4. Convert the string to an array.

   The code would be something like this

function listToString () {
	echo "$*"
}

usersString=$(listToString $(cat new_users))
read -a users <<< $usersString
addAccounts "${users[@]}"

   listToString may not work with all lines of input. Test it on your input.

   The last line should resolve to:
addAccounts "fsmith" "jdoe"

   Many people will not understand the line ...
read -a users <<< $usersString

   ... because they have never heard of a here string.

   This solution does not pass an array from a function, but it does allow you to convert the output of
   a function to an array. Some are satisfied with converting a list to a string and calling it a day,
   but if you truly want to deal with an official bash array, the here sting above will do that for you.

***
   This trick won't always work (When you have values with whitespaces, or you want to return values
   that depend on input values), but it usually does the work:

array_returning_func() {
	echo "cat dog tree"
}

declare -a arr="$(array_returning_func)"
for obj in ${arr[@]}; do
	echo "$obj"
done


---
https://www.geeksforgeeks.org/linux-unix/bash-scripting-array/

Bash Scripting - Array
13 Apr, 2022

   Arrays are important concepts in programming or scripting. Arrays allow us to store and retrieve
   elements in a list form which can be used for certain tasks. In bash, we also have arrays that help
   us in creating scripts in the command line for storing data in a list format. In this article, we
   will understand the basics of arrays in bash scripting.

Creating Arrays
   To create a basic array in a bash script, we can use the declare -a command followed by the name of
   the array variable you would like to give.

#!/bin/usr/env bash

declare -a sport=(
[0]=football
[1]=cricket
[2]=hockey
[3]=basketball
)

   OR
#!/bin/usr/env bash

sport[0]=football
sport[1]=cricket
sport[2]=hockey
sport[3]=basketball

   The value of the elements can be any integer or strings or any other form of data as desired. We can
   see that the array is declared in a bash script in two ways the former seems more convenient and less
   hectic to declare. If we want to declare the array in one go, the former is the optimum choice but if
   the elements are to be added in bits and pieces the latter is a good choice.

Printing the Arrays
   After declaring the array, if we wanted to display all the elements in the array we can use the @
   symbol.
#!/bin/usr/env bash

declare -a sport=(
[0]=football
[1]=cricket
[2]=hockey
[3]=basketball
)

echo "${sport[@]}"
echo "${array_name[@]}"

   We use the [@] as an index to the array to display all the elements. All the elements are printed
   with space-separated, The quotes around the variable expands and print all the elements in the array.

Iterating over the Array
   To iterate over an array one element at a time, we can use loops and perform any operations within
   the body of it.
#!/bin/usr/env bash

declare -a sport=(
[0]=football
[1]=cricket
[2]=hockey
[3]=basketball
)

for i in ${nums[@]}; do
	echo -e "$i \n"
done

   As we can see we have used a for loop to print the element from the array one by one. We have used
   the trick in the previous section of getting all the elements of the array and iterating over it one
   by one in the for a loop. The  "${array_name[@]}" expands into all the elements in the array and the
   for loop iterates over them one by one with the iterator in the example it is the variable i, inside
   the body of the for loop we print the variable/iterator i and thus iterate over the array.

Get the number of elements in the Array
   To fetch the number of the elements array we can use the # operator before the array name in the s in
   "${array_name[@]}".

 #!/bin/usr/env bash

declare -a sport=(
[0]=football
[1]=cricket
[2]=hockey
[3]=basketball
)

echo "${#sport[@]}"

   We thus return the size of the array by using the command "${#sport[@]}", the # is used to get the
   size of the variable next to it, using the double quotes the value of the command is evaluated and we
   get the number of the elements in the array as desired.

Inserting an element into Array
   To insert an element is quite straightforward, we need to set the element's appropriate index
   followed by the value of the element you liked to give.

#!/bin/usr/env bash

declare -a sport=(
[0]=football
[1]=cricket
[2]=hockey
[3]=basketball
)

echo "${sport[@]}"

sport[4]="dodgeball"
sport[2]="golf"

echo "${sport[@]}"

   We have added the 5th element (4th index) into the array and also modified/edited the array's 3rd
   element(2nd index). The arrayname[index]=value is all the tricks to add, modify or initialize the
   elements of the array.

   We can also add elements to an array using the += operator.

#!/bin/usr/env bash

declare -a sport=(
[0]=football
[1]=cricket
[2]=hockey
[3]=basketball
)

echo "${sport[@]}"
sport+=("golf" "baseball")
echo "${sport[@]}"
echo "Size : ${#sport[@]}"

   As seen in the example, we can add multiple elements to the array with minimal code. We use the
   array_name+=(elements) to append elements to the array.

Deleting an element from Array
   To delete an element from the array, we can use the command unset. The command takes in the name of
   the variable in our case the array name and the index of that element. The index can also be relative
   i.e. -1 indicating the last element and -2 to second last and so on.

#!/bin/usr/env bash

declare -a sport=(
[0]=football
[1]=cricket
[2]=hockey
[3]=basketball
)

unset sport[1]
echo "${sport[@]}"
echo "${#sport[@]}"

   As we can see unset arrayname[index] will delete the element at index from the array. Also, the size
   of the array has been reduced to 3 from 4 which indicates that the element is entirely removed and
   not just replaced with whitespace.

Using relative indices
   If we use indices like -1,-2, and so on, the elements are referenced from the last element, and hence
   we can delete or modify them with relative ordering from the back as well.

#!/bin/usr/env bash

declare -a sport=(
[0]=football
[1]=cricket
[2]=hockey
[3]=basketball
)

unset sport[-3]
echo "${sport[@]}"

   As we can see index 1 is also referenced as -3 from the back and hence it becomes relatively easier
   to reference certain elements in a large array.

Splice an Array
   We can splice(take out a potion) an array to take assign or print it to another variable/array.

#!/bin/usr/env bash

declare -a sport

sport+=("football" "cricket" "hockey" "basketball")
sport+=("golf" "baseball")

echo "sport = ${sport[@]}"
arr="${sport[@]:1:3}"
echo "arr = ${arr[@]}"

   We have taken out a chunk from the sport array i.e. the element between index 1 and 3 inclusive and
   assigned it to the arr variable which is also an array. The @ operator gets all the elements from the
   array and then we can splice the array between indices 1 and 3 so that we have the elements at 1,2and
   3 (cricket, hockey, and baseball) from the sport array.

   Define a static array and print the elements of the array

# To declare static Array
programmingArray=(Java Python Ruby Perl)

# In below 2 ways we can print the elements of the static array
echo "Way 1 of printing static values by using <array>[@]:0 - " ${programmingarray[@]$
echo "Way 2 of printing static values by using <array>[*]:0 - " ${programmingarray[*]$

   Program execution
sh <filename>

So, we can give as

sh arraycheck2.sh # arraycheck2.sh is the name of the script file here

   Passing the command line arguments in a script file
# All the array elements are stored in an array called programmingArray
programmingArray=("$@")
# Index values start from 0

# If we do not specify the index, it will take up the size of first index value
echo "Size of programmingArray at 0th location..:" $(#programmingArray[0]}
echo "Size of programmingArray at 1st location..:" $(#programmingArray[1]}

   The above script can be executed as

   # Here Java, Python and Ruby are command line arguments
sh arrayCheck.sh Java Python Ruby

   Script execution steps :
   programmingArray=(Java Python  Ruby)

   # Java will be present at the 0th index, its size can be computed in the below way
   ${#programmingArray[0]}

   Similarly, Python will be present at the 1st index, its size can be computed in the below way
   ${#programmingArray[1]}

   Iterating the array values using for loop
   $@ will give all the values that got passed via command-line arguments and it is stored in an array.

   It can be iterated by using the "for" loop
declare -a programmingArray=("$@")

i=0
for programming in "$@"; do
	echo "Array value at index " $i " : " $programming
	i=$((i+1));
done

   Let us take a quick look of what each and every symbol represent

   Output
   arr=()
   arr[0]=3 Overwrite 1st element
   arr+=(4) Append value(s)
   str=$(ls) Save ls output as a string
   arr=( $(ls) ) Save ls output as an array of files
   ${arr[@]:s:n} Retrieve n elements starting at index

   # We can provide set of values like this:
   arr=(one two three) To initialize an array
   ${arr[0]}           To retrieve the first element. Always index starts with 0
   ${arr[@]}           To retrieve all elements and thereupon we can iterate in a loop
   ${!arr[@]}          To retrieve array indices alone
   ${#arr[@]}          To calculate the size of an array
   arr[2]=3            To overwrite 3rd element we need to use it this way. As the index starts at 0, arr[2]
                       is correct.
   arr+=(40)           To append value(s), we can use + and then assign with = and hence += is used.
   str=$(ls)           To save "ls" command output as a string(Example 4 is shown for this output)
   arr=( $(ls) )       To save "ls" output as an array of files(Example 5 is shown for this output)
   ${arr[@]:s:n}       To retrieve "n" elements starting at index "s"


---
https://www.atlantic.net/dedicated-server-hosting/use-read-command-to-get-user-inputs-into-an-array-in-bash/

Use Read Command to Get User Inputs Into an Array in Bash
September 29, 2024

   In Bash scripting, handling user inputs is an essential task. Often, you need to gather multiple
   inputs and store them for further operations. Arrays are an efficient way to store such inputs.

   In this guide, we'll explore how to use the read command to capture user inputs and store them in a
   Bash array.

Introduction to Arrays in Bash
   In Bash, an array is a variable that holds multiple values. Unlike regular variables, which store a
   single value, arrays allow you to store and manage lists of items, making them incredibly useful for
   many applications.

   You can create a simple array like this:
my_array=("item1" "item2" "item3")

   To access elements of the array, use the following syntax:
echo ${my_array[0]}   # Outputs: item1
echo ${my_array[1]}   # Outputs: item2

   You can also iterate over the array:
for item in "${my_array[@]}"; do
	echo $item
done

   Output:
item1
item2
item3

Overview of the read Command
   The read command in Bash is used to take user input. By default, it reads a single value into a
   variable.

   Here's a simple example of using read to capture input:
echo "Enter your name:"
read name
echo "Hello, $name!"

   Output:
Enter your name:
John
Hello, John!

   The read command can also be used to read multiple values into an array by using the -a option, which
   we'll explore next.

Using read -a to Capture User Inputs Into an Array
   To read multiple inputs and store them into an array, we use the read command with the -a flag. This
   flag tells Bash to store the input into an array instead of a single variable.

   Here's an example:
echo "Enter a list of items (separated by spaces):"
read -a items
echo "You entered: ${items[@]}"

   Output:
Enter a list of items (separated by spaces):
apple banana orange
You entered: apple banana orange

   The user's input (apple banana orange) is stored in the items array, and we print the array using
   ${items[@]}.

Prompting the User for Multiple Inputs
   You can prompt users to enter multiple values on a single line. Here's how you can capture that input
   and store it in an array:
echo "Enter your favorite colors (separated by spaces):"
read -a colors
echo "Your favorite colors are:"

# Loop through the array and print each color
for color in "${colors[@]}"; do
	echo $color
done

   Output:
Enter your favorite colors (separated by spaces):
red blue green
Your favorite colors are:
red
blue
green

   In this example, red, blue, and green are stored in the colors array, and we print each color using a
   loop.

Reading Multiple Inputs (Line by Line) Into an Array
   Sometimes, you may want to collect inputs line by line and store them in an array. This can be done
   using a while loop.

echo "Enter items one by one (leave blank to finish):"
declare -a input_array
	while true; do
		read item
		[[ -z "$item" ]] && break
		input_array+=("$item")
	done

echo "You entered: ${input_array[@]}"

   Output:
Enter items one by one (leave blank to finish):
apple
banana
grape

You entered: apple banana grape

   This script reads user input one line simultaneously, appending each value to the input_array. The
   loop breaks when the user enters an empty line.

Practical Example: Collecting a List of User-Defined Items
   Here's a practical script example where the user can input items for a shopping list, and the script
   stores them in an array.

echo "Enter items for your shopping list (leave blank to finish):"
declare -a shopping_list
	while true; do
		read item
		[[ -z "$item" ]] && break
		shopping_list+=("$item")
	done

echo "Your shopping list is:"
for item in "${shopping_list[@]}"; do
	echo $item
done

   Output:
Enter items for your shopping list (leave blank to finish):
bread
milk
eggs

Your shopping list is:
bread
milk
eggs

   This simple shopping list script collects user inputs line by line and displays them at the end.

Error Handling and Edge Cases
   When reading inputs into arrays, there are a few potential issues:

   1. Handling Whitespace: Be mindful of values with spaces. To handle multi-word inputs, use quotes
   around the value like so:

read -a input_array <<< "one two 'multi word input'"
echo "${input_array[@]}"

   Output:
one two multi word input

   2. Validating User Inputs: Always check for empty or invalid inputs before adding them to the array.

   3. Escaping Special Characters: If the user's input contains special characters (like &, |, etc.),
   make sure to escape or handle them accordingly.

Conclusion
   Using the read command in Bash is a powerful way to capture user input, and with the -a option, you
   can easily store multiple inputs into an array. Whether you need to collect input in a single line or
   line by line, this method provides flexibility in handling user data in Bash scripts.

   Experiment with arrays and user inputs to enhance your Bash scripts and make them more interactive
   and efficient on dedicated server hosting from Atlantic.Net!


---

