filename: bash-parameter-expansion_20140409.txt
http://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html

    3.5.3 Shell Parameter Expansion

   The `$' character introduces parameter expansion, command substitution, or arithmetic
   expansion. The parameter name or symbol to be expanded may be enclosed in braces, which are
   optional but serve to protect the variable to be expanded from characters immediately
   following it which could be interpreted as part of the name.

   When braces are used, the matching ending brace is the first `}' not escaped by a backslash
   or within a quoted string, and not within an embedded arithmetic expansion, command
   substitution, or parameter expansion.

   The basic form of parameter expansion is ${parameter}. The value of parameter is
   substituted. The braces are required when parameter is a positional parameter with more
   than one digit, or when parameter is followed by a character that is not to be interpreted
   as part of its name.

   If the first character of parameter is an exclamation point (!), a level of variable
   indirection is introduced. Bash uses the value of the variable formed from the rest of
   parameter as the name of the variable; this variable is then expanded and that value is
   used in the rest of the substitution, rather than the value of parameter itself. This is
   known as indirect expansion. The exceptions to this are the expansions of ${!prefix
   } and ${!name[@]} described below. The exclamation point must immediately follow the left
   brace in order to introduce indirection.

   In each of the cases below, word is subject to tilde expansion, parameter expansion,
   command substitution, and arithmetic expansion.

   When not performing substring expansion, using the form described below, Bash tests for a
   parameter that is unset or null. Omitting the colon results in a test only for a parameter
   that is unset. Put another way, if the colon is included, the operator tests for both
   parameter's existence and that its value is not null; if the colon is omitted, the operator
   tests only for existence.
   ${parameter:-word}
          If parameter is unset or null, the expansion of word is substituted. Otherwise, the
          value of parameter is substituted.
   ${parameter:=word}
          If parameter is unset or null, the expansion of word is assigned to parameter. The
          value of parameter is then substituted. Positional parameters and special parameters
          may not be assigned to in this way.
   ${parameter:?word}
          If parameter is null or unset, the expansion of word (or a message to that effect if
          word is not present) is written to the standard error and the shell, if it is not
          interactive, exits. Otherwise, the value of parameter is substituted.
   ${parameter:+word}
          If parameter is null or unset, nothing is substituted, otherwise the expansion of
          word is substituted.
   ${parameter:offset}
   ${parameter:offset:length}
          Expands to up to length characters of parameter starting at the character specified
          by offset. If length is omitted, expands to the substring of parameter starting at
          the character specified by offset. length and offset are arithmetic expressions (see
          [12]Shell Arithmetic). This is referred to as Substring Expansion.
          If offset evaluates to a number less than zero, the value is used as an offset from
          the end of the value of parameter. If length evaluates to a number less than zero,
          and parameter is not `@' and not an indexed or associative array, it is interpreted
          as an offset from the end of the value of parameter rather than a number of
          characters, and the expansion is the characters between the two offsets. If
          parameter is `@', the result is length positional parameters beginning at offset. If
          parameter is an indexed array name subscripted by `@' or `*', the result is the
          length members of the array beginning with ${parameter[offset]}. A negative offset
          is taken relative to one greater than the maximum index of the specified array.
          Substring expansion applied to an associative array produces undefined results.
          Note that a negative offset must be separated from the colon by at least one space
          to avoid being confused with the `:-' expansion. Substring indexing is zero-based
          unless the positional parameters are used, in which case the indexing starts at 1 by
          default. If offset is 0, and the positional parameters are used, $@ is prefixed to
          the list.
   ${!prefix*}
   ${!prefix@}
          Expands to the names of variables whose names begin with prefix, separated by the
          first character of the IFS special variable. When `@' is used and the expansion
          appears within double quotes, each variable name expands to a separate word.
   ${!name[@]}
   ${!name[*]}
          If name is an array variable, expands to the list of array indices (keys) assigned
          in name. If name is not an array, expands to 0 if name is set and null otherwise.
          When `@' is used and the expansion appears within double quotes, each key expands to
          a separate word.
   ${#parameter}
          The length in characters of the expanded value of parameter is substituted. If
          parameter is `*' or `@', the value substituted is the number of positional
          parameters. If parameter is an array name subscripted by `*' or `@', the value
          substituted is the number of elements in the array.
   ${parameter#word}
   ${parameter##word}
          The word is expanded to produce a pattern just as in filename expansion (see
          [13]Filename Expansion). If the pattern matches the beginning of the expanded value
          of parameter, then the result of the expansion is the expanded value of parameter
          with the shortest matching pattern (the `#' case) or the longest matching pattern
          (the `##' case) deleted. If parameter is `@' or `*', the pattern removal operation
          is applied to each positional parameter in turn, and the expansion is the resultant
          list. If parameter is an array variable subscripted with `@' or `*', the pattern
          removal operation is applied to each member of the array in turn, and the expansion
          is the resultant list.
   ${parameter%word}
   ${parameter%%word}
          The word is expanded to produce a pattern just as in filename expansion. If the
          pattern matches a trailing portion of the expanded value of parameter, then the
          result of the expansion is the value of parameter with the shortest matching pattern
          (the `%' case) or the longest matching pattern (the `%%' case) deleted. If parameter
          is `@' or `*', the pattern removal operation is applied to each positional parameter
          in turn, and the expansion is the resultant list. If parameter is an array variable
          subscripted with `@' or `*', the pattern removal operation is applied to each member
          of the array in turn, and the expansion is the resultant list.
   ${parameter/pattern/string}
          The pattern is expanded to produce a pattern just as in filename expansion.
          Parameter is expanded and the longest match of pattern against its value is replaced
          with string. If pattern begins with `/', all matches of pattern are replaced with
          string. Normally only the first match is replaced. If pattern begins with `#', it
          must match at the beginning of the expanded value of parameter. If pattern begins
          with `%', it must match at the end of the expanded value of parameter. If string is
          null, matches of pattern are deleted and the / following pattern may be omitted. If
          parameter is `@' or `*', the substitution operation is applied to each positional
          parameter in turn, and the expansion is the resultant list. If parameter is an array
          variable subscripted with `@' or `*', the substitution operation is applied to each
          member of the array in turn, and the expansion is the resultant list.
   ${parameter^pattern}
   ${parameter^^pattern}
   ${parameter,pattern}
   ${parameter,,pattern}
          This expansion modifies the case of alphabetic characters in parameter. The pattern
          is expanded to produce a pattern just as in filename expansion. The `^' operator
          converts lowercase letters matching pattern to uppercase; the `,' operator converts
          matching uppercase letters to lowercase. The `^^' and `,,' expansions convert each
          matched character in the expanded value; the `^' and `,' expansions match and
          convert only the first character in the expanded value. If pattern is omitted, it is
          treated like a `?', which matches every character. If parameter is `@' or `*', the
          case modification operation is applied to each positional parameter in turn, and the
          expansion is the resultant list. If parameter is an array variable subscripted with
          `@' or `*', the case modification operation is applied to each member of the array
          in turn, and the expansion is the resultant list.



---
http://wiki.bash-hackers.org/syntax/pe

Parameter expansion

Introduction

   One core functionality of Bash is to manage parameters. A parameter is an entity that
   stores values and is referenced by a name, a number or a special symbol.
     * parameters referenced by a name are called variables (this also applies to [50]arrays)
     * parameters referenced by a number are called positional parameters and reflect the
       arguments given to a shell
     * parameters referenced by a special symbol are auto-set parameters that have different
       special meanings and uses

   Parameter expansion is the procedure to get the value from the referenced entity, like
   expanding a variable to print its value. On expansion time you can do very nasty things
   with the parameter or its value. These things are described here.

   If you saw some parameter expansion syntax somewhere, and need to check what it can be, try
   the overview section below!

   Arrays can be special cases for parameter expansion, every applicable description mentions
   arrays below. Please also see the [51]article about arrays.

   For a more technical view what a parameter is and which types exist, [52]see the dictionary
   entry for "parameter".

Overview

   Looking for a specific syntax you saw, without knowing the name?
     * [53]Simple usage
          + $PARAMETER
          + ${PARAMETER}
     * [54]Indirection
          + ${!PARAMETER}
     * [55]Case modification
          + ${PARAMETER^}
          + ${PARAMETER^^}
          + ${PARAMETER,}
          + ${PARAMETER,,}
          + ${PARAMETER~}
          + ${PARAMETER~~}
     * [56]Variable name expansion
          + ${!PREFIX*}
          + ${!PREFIX@}
     * [57]Substring removal (also for filename manipulation!)
          + ${PARAMETER#PATTERN}
          + ${PARAMETER##PATTERN}
          + ${PARAMETER%PATTERN}
          + ${PARAMETER%%PATTERN}
     * [58]Search and replace
          + ${PARAMETER/PATTERN/STRING}
          + ${PARAMETER//PATTERN/STRING}
          + ${PARAMETER/PATTERN}
          + ${PARAMETER//PATTERN}
     * [59]String length
          + ${#PARAMETER}
     * [60]Substring expansion
          + ${PARAMETER:OFFSET}
          + ${PARAMETER:OFFSET:LENGTH}
     * [61]Use a default value
          + ${PARAMETER:-WORD}
          + ${PARAMETER-WORD}
     * [62]Assign a default value
          + ${PARAMETER:=WORD}
          + ${PARAMETER=WORD}
     * [63]Use an alternate value
          + ${PARAMETER:+WORD}
          + ${PARAMETER+WORD}
     * [64]Display error if null or unset
          + ${PARAMETER:?WORD}
          + ${PARAMETER?WORD}

Simple usage

   $PARAMETER

   ${PARAMETER}

   The easiest form is to just use a parameter's name within braces. This is identical to
   using $FOO like you see it everywhere, but has the advantage that it can be immediately
   followed by characters that would be interpreted as part of the parameter name otherwise.
   Compare these two expressions (WORD="car" for example), where we want to print a word with
   a trailing "s":

echo "The plural of $WORD is most likely $WORDs"
echo "The plural of $WORD is most likely ${WORD}s"

   Why does the first one fail? It prints nothing, because a parameter (variable) named
   "WORDs" is undefined and thus printed as "" (nothing). Without using braces for parameter
   expansion, Bash will interpret the sequence of all valid characters from the introducing
   "$" up to the last valid character as name of the parameter. When using braces you just
   force Bash to only interpret the name inside your braces.

   Also, please remember, that parameter names are (like nearly everything in UNIX(R)) case
   sentitive!

   The second form with the curly braces is also needed to access positional parameters
   (arguments to a script) beyond $9:
echo "Argument  1 is: $1"
echo "Argument 10 is: ${10}"

Simple usage: Arrays

   See also the [65]article about general array syntax

   For arrays you always need the braces. The arrays are expanded by individual indexes or
   mass arguments. An individual index behaves like a normal parameter, for the mass
   expansion, please read the article about arrays linked above.
     * ${array[5]}
     * ${array[*]}
     * ${array[@]}

Indirection

   ${!PARAMETER}

   In come cases, like for example

${PARAMETER}

${PARAMETER:0:3}

   you can instead use the form

${!PARAMETER}

   to enter a level of indirection. The referenced parameter is not PARAMETER itself, but the
   parameter whose name is stored as the value of PARAMETER. If the parameter PARAMETER has
   the value "TEMP", then ${!PARAMETER} will expand to the value of the parameter named TEMP:
read -rep 'Which variable do you want to inspect? ' look_var

printf 'The value of "%s" is: "%s"\n' "$look_var" "${!look_var}"

   Of course the indirection also works with special variables:

# set some fake positional parameters
set one two three four

# get the LAST argument ("#" stores the number of arguments, so "!#" will reference the LAST argumen
t)
echo ${!#}

   You can think of this mechanism as being roughly equivalent to taking any parameter
   expansion that begins with the parameter name, and substituting the !PARAMETER part with
   the value of PARAMETER.

echo "${!var^^}"
# ...is equivalent to
eval 'echo "${'"$var"'^^}"'

   It was an unfortunate design decision to use the ! prefix for indirection, as it introduces
   parsing ambiguity with other parameter expansions that begin with !. Indirection is not
   possible in combination with any parameter expansion whose modifier requires a prefix to
   the parameter name. Specifically, indirection isn't possible on the ${!var@}, ${!var*},
   ${!var[@]}, ${!var[*]}, and ${#var} forms. This means the ! prefix can't be used to
   retrieve the indices of an array, the length of a string, or number of elements in an array
   indirectly (see [66]indirection for workarounds). Additionally, the !-prefixed parameter
   expansion conflicts with ksh-like shells which have the more powerful "name-reference" form
   of indirection, where the exact same syntax is used to expand to the name of the variable
   being referenced.

   Indirect references to [67]array names are also possible since the Bash 3 series (exact
   version unknown), but undocumented. See [68]indirection for details.

   Chet has added an initial implementation of the ksh nameref declaration command to the git
   devel branch. (declare -n, local -n, etc, will be supported). This will finally address
   many issues around passing and returning complex datatypes to/from functions.

Case modification

   ${PARAMETER^}

   ${PARAMETER^^}

   ${PARAMETER,}

   ${PARAMETER,,}

   ${PARAMETER~}

   ${PARAMETER~~}

   These expansion operators modify the case of the letters in the expanded text.

   The ^ operator modifies the first character to uppercase, the , operator to lowercase. When
   using the double-form (^^ and ,,), all characters are converted.

   The (currently undocumented) operators ~ and ~~ reverse the case of the given text (in
   PARAMETER).~ reverses the case of first letter of words in the variable while ~~ reverses
   case for all.Thanks to Bushmills and geirha on the Freenode IRC channel for this finding.

   Example: Rename all *.txt filenames to lowercase
for file in *.txt; do
  mv "$file" "${file,,}"
done

   Note: The feature worked word-wise in Bash 4 RC1 (a modification of a parameter containing
   hello world ended up in Hello World, not Hello world). In the final Bash 4 version it works
   on the whole parameter, regardless of something like "words". IMHO a technically cleaner
   implementation. Thanks to Chet.

Case modification: Arrays

   For [69]array expansion, the case modification applies to every expanded element, no matter
   if you expand an individual index or mass-expand the whole array using @ or * subscripts.
   Some examples:

   Assume: array=(This is some Text)
     * echo "${array[@],}"
          + => this is some text
     * echo "${array[@],,}"
          + => this is some text
     * echo "${array[@]^}"
          + => This Is Some Text
     * echo "${array[@]^^}"
          + => THIS IS SOME TEXT
     * echo "${array[2]^^}"
          + => TEXT

Variable name expansion

   ${!PREFIX*}

   ${!PREFIX@}

   This expands to a list of all set variable names beginning with the string PREFIX. The
   elements of the list are separated by the first character in the IFS-variable (<space> by
   default).

   This will show all defined variable names (not values!) beginning with "BASH":
$ echo ${!BASH*}
BASH BASH_ARGC BASH_ARGV BASH_COMMAND BASH_LINENO BASH_SOURCE BASH_SUBSHELL BASH_VERSINFO BASH_VERSI
ON

   This list will also include [70]array names.

Substring removal

   ${PARAMETER#PATTERN}

   ${PARAMETER##PATTERN}

   ${PARAMETER%PATTERN}

   ${PARAMETER%%PATTERN}

   This one can expand only a part of a parameter's value, given a pattern to describe what to
   remove from the string. The pattern is interpreted just like a pattern to describe a
   filename to match (globbing). See [71]Pattern matching for more.

   Example string (just a quote from a big man):
MYSTRING="Be liberal in what you accept, and conservative in what you send"

From the beginning

   ${PARAMETER#PATTERN} and ${PARAMETER##PATTERN}

   This form is to remove the described [72]pattern trying to match it from the beginning of
   the string. The operator "#" will try to remove the shortest text matching the pattern,
   while "##" tries to do it with the longest text matching. Look at the following examples to
   get the idea (matched text [DEL: marked striked :DEL] , remember it will be removed!):
   Syntax Result
   ${MYSTRING#* } [DEL: Be :DEL] liberal in what you accept, and conservative in what you send
   ${MYSTRING##* } [DEL: Be liberal in what you accept, and conservative in what you :DEL]
   send

From the end

   ${PARAMETER%PATTERN} and ${PARAMETER%%PATTERN}

   In the second form everything will be the same, except that Bash now tries to match the
   pattern from the end of the string:
       Syntax                                         Result
   ${MYSTRING% *}  Be liberal in what you accept, and conservative in what you[DEL: send :DEL]
   ${MYSTRING%% *} Be[DEL: liberal in what you accept, and conservative in what you send :DEL]

Common use

   How the heck does that help to make my life easier?

   Well, maybe the most common use for it is to extract parts of a filename. Just look at the
   following list with examples:
     * Get name without extension
          + ${FILENAME%.*}
          + => bash_hackers[DEL: .txt :DEL]
     * Get extension
          + ${FILENAME##*.}
          + => [DEL: bash_hackers. :DEL] txt
     * Get directory name
          + ${PATHNAME%/*}
          + => /home/bash[DEL: /bash_hackers.txt :DEL]
     * Get filename
          + ${PATHNAME##*/}
          + => [DEL: /home/bash/ :DEL] bash_hackers.txt

   These are the syntaxes for filenames with a single extension. Depending on your needs, you
   might need to adjust shortest/longest match.

Substring removal: Arrays

   As for most parameter expansion features, working on [73]arrays will handle each expanded
   element, for individual expansion and also for mass expansion.

   Simple example, removing a trailing is from all array elements (on expansion):

   Assume: array=(This is a text)
     * echo "${array[@]%is}"
          + => Th a text
          + (it was: Th[DEL: is :DEL] [DEL: is :DEL] a text)

   All other variants of this expansion behave the same.

Search and replace

   ${PARAMETER/PATTERN/STRING}

   ${PARAMETER//PATTERN/STRING}

   ${PARAMETER/PATTERN}

   ${PARAMETER//PATTERN}

   This one can substitute (replace) a substring [74]matched by a pattern, on expansion time.
   The matched substring will be entirely removed and the given string will be inserted. Again
   some example string for the tests:
MYSTRING="Be liberal in what you accept, and conservative in what you send"

   The two main forms only differ in the number of slashes after the parameter name:
   ${PARAMETER/PATTERN/STRING} and ${PARAMETER//PATTERN/STRING}

   The first one (one slash) is to only substitute the first occurrence of the given pattern,
   the second one (two slashes) is to substitute all occurrences of the pattern.

   First, let's try to say "happy" instead of "conservative" in our example string:
${MYSTRING//conservative/happy}

   => Be liberal in what you accept, and [DEL: conservative :DEL] happy in what you send

   Since there is only one "conservative" in that example, it really doesn't matter which of
   the two forms we use.

   Let's play with the word "in", I don't know if it makes any sense, but let's substitute it
   with "by".

   First form: Substitute first occurrence
${MYSTRING/in/by}

   => Be liberal [DEL: in :DEL] by what you accept, and conservative in what you send

   Second form: Substitute all occurrences
${MYSTRING//in/by}

   => Be liberal [DEL: in :DEL] by what you accept, and conservative [DEL: in :DEL] by what
   you send

   Anchoring Additionally you can "anchor" an expression: A # (hashmark) will indicate that
   your expression is matched against the beginning portion of the string, a % (percent-sign)
   will do it for the end portion.

MYSTRING=xxxxxxxxxx
echo ${MYSTRING/#x/y}  # RESULT: yxxxxxxxxx
echo ${MYSTRING/%x/y}  # RESULT: xxxxxxxxxy

   If the replacement part is completely omitted, like, the matches are replaced by the
   nullstring, i.e. they are removed. This is equivalent to specifying an empty replacement:
echo ${MYSTRING//conservative/}
# is equivalent to
echo ${MYSTRING//conservative}

Search and replace: Arrays

   This parameter expansion type applied to [75]arrays applies to all expanded elements, no
   matter if an individual element is expanded, or all elements using the mass expansion
   syntaxes.

   A simple example, changing the (lowercase) letter t to d:

   Assume: array=(This is a text)
     * echo "${array[@]/t/d}"
          + => This is a dext
     * echo "${array[@]//t/d}"
          + => This is a dexd

String length

   ${#PARAMETER}

   When you use this form, the length of the parameter's value is expanded. Again, a quote
   from a big man, to have a test text:

MYSTRING="Be liberal in what you accept, and conservative in what you send"

   Using echo ${#MYSTRING}...

   => 64

   There's not much to say about it, mh?

(String) length: Arrays

   For [76]arrays, this expansion type has two meanings:
     * For individual elements, it reports the string length of the element (as for every
       "normal" parameter)
     * For the mass subscripts @ and * it reports the number of set elements in the array

   Example:

   Assume: array=(This is a text)
     * echo ${#array[1]}
          + => 2 (the word "is" has a length of 2)
     * echo ${#array[@]}
          + => 4 (the array contains 4 elements)

   Attention: The number of used elements does not need to conform to the highest index.
   Sparse arrays are possible in Bash, that means you can have 4 elements, but with indexes 1,
   7, 20, 31. You can't loop through such an array with a counter loop based on the number of
   elements!

Substring expansion

   ${PARAMETER:OFFSET}

   ${PARAMETER:OFFSET:LENGTH}

   This one can expand only a part of a parameter's value, given a position to start and maybe
   a length. If LENGTH is omitted, the parameter will be expanded up to the end of the string.
   If LENGTH is negative, it's taken as a second offset into the string, counting from the end
   of the string.

   OFFSET and LENGTH can be any [77]arithmetic expression. Take care: The OFFSET starts at 0,
   not at 1!

   Example string (a quote from a big man): MYSTRING="Be liberal in what you accept, and
   conservative in what you send"

Using only Offset

   In the first form, the expansion is used without a length value, note that the offset 0 is
   the first character:
echo ${MYSTRING:34}

   => [DEL: Be liberal in what you accept, and :DEL] conservative in what you send

Using Offset and Length

   In the second form we also give a length value:
echo ${MYSTRING:34:13}

   => [DEL: Be liberal in what you accept, and :DEL] conservative[DEL: in what you send :DEL]

Negative Offset Value

   If the given offset is negative, it's counted from the end of the string, i.e. an offset of
   -1 is the last character. In that case, the length still counts forward, of course. One
   special thing is to do when using a negative offset: You need to separate the (negative)
   number from the colon:
${MYSTRING: -10:5}
${MYSTRING:(-10):5}

   Why? Because it's interpreted as the parameter expansion syntax to [78]use a default value.

Negative Length Value

   If the LENGTH value is negative, it's used as offset from the end of the string. The
   expansion happens from the first to the second offset then:
echo "${MYSTRING:11:-17}"

   => [DEL: Be liberal :DEL] in what you accept, and conservative[DEL: in what you send :DEL]

   This works since Bash 4.2-alpha, see also [79]Bash changes.

Substring/Element expansion: Arrays

   For [80]arrays, this expansion type has again 2 meanings:
     * For individual elements, it expands to the specified substring (as for every "normal"
       parameter)
     * For the mass subscripts @ and * it mass-expands individual array elements denoted by
       the 2 numbers given (starting element, number of elements)

   Example:

   Assume: array=(This is a text)
     * echo ${array[0]:2:2}
          + => is (the "is" in "This", array element 0)
     * echo ${array[@]:1:2}
          + => is a (from element 1 inclusive, 2 elements are expanded, i.e. element 1 and 2)

Use a default value

   ${PARAMETER:-WORD}

   ${PARAMETER-WORD}

   If the parameter PARAMETER is unset (never was defined) or null (empty), this one expands
   to WORD, otherwise it expands to the value of PARAMETER, as if it just was ${PARAMETER}. If
   you omit the : (colon), like shown in the second form, the default value is only used when
   the parameter was unset, not when it was empty.

echo "Your home directory is: ${HOME:-/home/$USER}."
echo "${HOME:-/home/$USER} will be used to store your personal data."

   If HOME is unset or empty, everytime you want to print something useful, you need to put
   that parameter syntax in.

#!/bin/bash

read -p "Enter your gender (just press ENTER to not tell us): " GENDER
echo "Your gender is ${GENDER:-a secret}."

   It will print "Your gender is a secret." when you don't enter the gender. Note that the
   default value is used on expansion time, it is not assigned to the parameter.

Use a default value: Arrays

   For [81]arrays, the behaviour is very similar. Again, you have to make a difference between
   expanding an individual element by a given index and mass-expanding the array using the @
   and * subscripts.
     * For individual elements, it's the very same: If the expanded element is NULL or unset
       (watch the :- and - variants), the default text is expanded
     * For mass-expansion syntax, the default text is expanded if the array
          + contains no element or is unset (the :- and - variants mean the same here)
          + contains only elements that are the nullstring (the :- variant)

   In other words: The basic meaning of this expansion type is applied as consistent as
   possible to arrays.

   Example code (please try the example cases yourself):

####
# Example cases for unset/empty arrays and nullstring elements
####


### CASE 1: Unset array (no array)

# make sure we have no array at all
unset array

echo ${array[@]:-This array is NULL or unset}
echo ${array[@]-This array is NULL or unset}

### CASE 2: Set but empty array (no elements)

# declare an empty array
array=()

echo ${array[@]:-This array is NULL or unset}
echo ${array[@]-This array is NULL or unset}


### CASE 3: An array with only one element, a nullstring
array=("")

echo ${array[@]:-This array is NULL or unset}
echo ${array[@]-This array is NULL or unset}


### CASE 4: An array with only two elements, a nullstring and a normal word
array=("" word)

echo ${array[@]:-This array is NULL or unset}
echo ${array[@]-This array is NULL or unset}

Assign a default value

   ${PARAMETER:=WORD}

   ${PARAMETER=WORD}

   This one works like the [82]using default values, but the default text you give is not only
   expanded, but also assigned to the parameter, if it was unset or null. Equivalent to using
   a default value, when you omit the : (colon), as shown in the second form, the default
   value will only be assigned when the parameter was unset.

echo "Your home directory is: ${HOME:=/home/$USER}."
echo "$HOME will be used to store your personal data."

   After the first expansion here (${HOME:=/home/$USER}), HOME is set and usable.

   Let's change our code example from above:

#!/bin/bash

read -p "Enter your gender (just press ENTER to not tell us): " GENDER
echo "Your gender is ${GENDER:=a secret}."
echo "Ah, in case you forgot, your gender is really: $GENDER"

Assign a default value: Arrays

   For [83]arrays this expansion type is limited. For an individual index, it behaves like for
   a "normal" parameter, the default value is assigned to this one element. The mass-expansion
   subscripts @ and * can not be used here because it's not possible to assign to them!

Use an alternate value

   ${PARAMETER:+WORD}

   ${PARAMETER+WORD}

   This form expands to nothing if the parameter is unset or empty. If it is set, it does not
   expand to the parameter's value, but to some text you can specify:
echo "The Java application was installed and can be started.${JAVAPATH:+ NOTE: JAVAPATH seems to be
set}"

   The above code will simply add a warning if JAVAPATH is set (because it could influence the
   startup behaviour of that imaginary application).

   Some more unrealistic example... Ask for some flags (for whatever reason), and then, if
   they were set, print a warning and also print the flags:
#!/bin/bash

read -p "If you want to use special flags, enter them now: " SPECIAL_FLAGS
echo "The installation of the application is finished${SPECIAL_FLAGS:+ (NOTE: there are special flag
s set: $SPECIAL_FLAGS)}."

   If you omit the colon, as shown in the second form (${PARAMETER+WORD}), the alternate value
   will be used if the parameter is set (and it can be empty)! You can use it, for example, to
   complain if variables you need (and that can be empty) are undefined:
# test that with the three stages:

# unset foo
# foo=""
# foo="something"

if [[ ${foo+isset} = isset ]]; then
  echo "foo is set..."
else
  echo "foo is not set..."
fi

Use an alternate value: Arrays

   Similar to the cases for [84]arrays to expand to a default value, this expansion behaves
   like for a "normal" parameter when using individual array elements by index, but reacts
   differently when using the mass-expansion subscripts @ and *:
     * For individual elements, it's the very same: If the expanded element is not NULL or
       unset (watch the :+ and + variants), the alternate text is expanded
     * For mass-expansion syntax, the alternate text is expanded if the array
          + contains elements where min. one element is not a nullstring (the :+ and +
            variants mean the same here)
          + contains only elements that are not the nullstring (the :+ variant)

   For some cases to play with, please see the code examples in the [85]description for using
   a default value.

Display error if null or unset

   ${PARAMETER:?WORD}

   ${PARAMETER?WORD}

   If the parameter PARAMETER is set/non-null, this form will simply expand it. Otherwise, the
   expansion of WORD will be used as appendix for an error message:
$ echo "The unset parameter is: ${p_unset?not set}"
bash: p_unset: not set

   After printing this message,
     * an interactive shell has $? to a non-zero value
     * a non-interactive shell exits with a non-zero exit code

   The meaning of the colon (:) is the same as for the other parameter expansion syntaxes: It
   specifies if
     * only unset or
     * unset and empty parameters

   are taken into account.

Code examples

Substring removal

   Removing the first 6 characters from a text string:
STRING="Hello world"

# only print 'Hello'
echo "${STRING%??????}"

# only print 'world'
echo "${STRING#??????}"

# store it into the same variable
STRING=${STRING#??????}

Bugs and Portability considerations

     * Fixed in 4.2.36 ([86] patch). Bash doesn't follow either POSIX or its own documentation
       when expanding either a quoted "$@" or "${arr[@]}" with an adjacent expansion. "$@$x"
       expands in the same way as "$*$x" - i.e. all parameters plus the adjacent expansion are
       concatenated into a single argument. As a workaround, each expansion needs to be quoted
       separately. Unfortunately, this bug took a very long time to notice.
~ $ set -- a b c; x=foo; printf '<%s> ' "$@$x" "$*""$x" "$@""$x"
<a b cfoo> <a b cfoo> <a> <b> <cfoo>

     * Almost all shells disagree about the treatment of an unquoted $@, ${arr[@]}, $*, and
       ${arr[*]} when [87]IFS is set to null. POSIX is unclear about the expected behavior. A
       null IFS causes both [88]word splitting and [89]pathname expansion to behave randomly.
       Since there are few good reasons to leave IFS set to null for more than the duration of
       a command or two, and even fewer to expand $@ and $* unquoted, this should be a rare
       issue. Always quote them!
touch x 'y z'
for sh in bb {{d,b}a,{m,}k,z}sh; do
    echo "$sh"
    "$sh" -s a 'b c' d \* </dev/fd/0
done <<\EOF
${ZSH_VERSION+:} false && emulate sh
IFS=
printf '<%s> ' $*
echo
printf "<%s> " $@
echo
EOF
bb
<ab cd*>
<ab cd*>
dash
<ab cd*>
<ab cd*>
bash
<a> <b c> <d> <x> <y z>
<a> <b c> <d> <x> <y z>
mksh
<a b c d *>
<a b c d *>
ksh
<a> <b c> <d> <x> <y z>
<a> <b c> <d> <x> <y z>
zsh
<a> <b c> <d> <x> <y z>
<a> <b c> <d> <x> <y z>
       When IFS is set to a non-null value, or unset, all shells behave the same - first
       expanding into separate args, then applying pathname expansion and word-splitting to
       the results, except for zsh, which doesn't do pathname expansion in its default mode.

     * Additionally, shells disagree about various wordsplitting behaviors, the behavior of
       inserting delimiter characters from IFS in $*, and the way adjacent arguments are
       concatenated, when IFS is modified in the middle of expansion through side-effects.
for sh in bb {{d,b}a,po,{m,}k,z}sh; do
    printf '%-4s: ' "$sh"
    "$sh" </dev/fd/0
done <<\EOF
${ZSH_VERSION+:} false && emulate sh
set -f -- a b c
unset -v IFS
printf '<%s> ' ${*}${IFS=}${*}${IFS:=-}"${*}"
echo
EOF
bb  : <a b cabc> <a-b-c>
dash: <a b cabc> <a-b-c>
bash: <a> <b> <ca> <b> <c-a b c>
posh: <a> <b> <ca b c> <a-b-c>
mksh: <a> <b> <ca b c> <a-b-c>
ksh : <a> <b> <ca> <b> <c> <a b c>
zsh : <a> <b> <ca> <b> <c> <a-b-c>
       ksh93 and mksh can additionally achieve this side effect (and others) via the ${ cmds;}
       expansion. I haven't yet tested every possible side-effect that can affect expansion
       halfway through expansion that way.

     * As previously mentioned, the Bash form of indirection by prefixing a parameter
       expansion with a ! conflicts with the same syntax used by mksh, zsh, and ksh93 for a
       different purpose. Bash will "slightly" modify this expansion in the next version with
       the addition of namerefs.

     * Bash (and most other shells) don't allow .'s in identifiers. In ksh93, dots in variable
       names are used to reference methods (i.e. "Discipline Functions"), attributes, special
       shell variables, and to define the "real value" of an instance of a class.

     * In ksh93, the _ parameter has even more uses. It is used in the same way as self in
       some object-oriented languages; as a placeholder for some data local to a class; and
       also as the mechanism for class inheritance. In most other contexts, _ is compatible
       with Bash.

     * Bash only evaluates the subscripts of the slice expansion (${x:y:z}) if the parameter
       is set (for both nested expansions and arithmetic). For ranges, Bash evaluates as
       little as possible, i.e., if the first part is out of range, the second won't be
       evaluated. ksh93 and mksh always evaluate the subscript parts even if the parameter is
       unset.
 $ bash -c 'n="y[\$(printf yo >&2)1]" m="y[\$(printf jo >&2)1]"; x=(); echo "${x[@]:n,6:m}"' # No output
 $ bash -c 'n="y[\$(printf yo >&2)1]" m="y[\$(printf jo >&2)1]"; x=([5]=hi); echo "${x[@]:n,6:m}"'yo
 $ bash -c 'n="y[\$(printf yo >&2)1]" m="y[\$(printf jo >&2)1]"; x=([6]=hi); echo "${x[@]:n,6:m}"'yojo
 $ bash -c 'n="y[\$(printf yo >&2)1]" m="y[\$(printf jo >&2)1]"; x=12345; echo "${x:n,5:m}"'yojo
 $ bash -c 'n="y[\$(printf yo >&2)1]" m="y[\$(printf jo >&2)1]"; x=12345; echo "${x:n,6:m}"'yo

Quote Nesting

     * In most shells, when dealing with an "alternate" parameter expansion that expands to
       multiple words, and nesting such expansions, not all combinations of nested quoting are
       possible.

# Bash
 $ typeset -a a=(meh bleh blerg) b
 $ IFS=e
 $ printf "<%s> " "${b[@]-"${a[@]}" "${a[@]}"}"; echo # The entire PE is quoted so Bash considers th
e inner quotes redundant.
<meh> <bleh> <blerg meh> <bleh> <blerg>
 $ printf "<%s> " "${b[@]-${a[@]} ${a[@]}}"; echo # The outer quotes cause the inner expansions to b
e considered quoted.
<meh> <bleh> <blerg meh> <bleh> <blerg>
 $ b=(meep beep)
 $ printf "<%s> " "${b[@]-"${a[@]}" "${a[@]}"}" "${b[@]-${a[@]} ${a[@]}}"; echo # Again no surprises
. Outer quotes quote everything recursively.
<meep> <beep> <meep> <beep>

   Now lets see what can happen if we leave the outside unquoted.
# Bash
 $ typeset -a a=(meh bleh blerg) b
 $ IFS=e
 $ printf "<%s> " ${b[@]-"${a[@]}" "${a[@]}"}; echo # Inner quotes make inner expansions quoted.
<meh> <bleh> <blerg meh> <bleh> <blerg>
 $ printf "<%s> " ${b[@]-${a[@]} ${a[@]}}; echo' # No quotes at all wordsplits / globs, like you'd e
xpect.
<m> <h> <bl> <h> <bl> <rg m> <h> <bl> <h> <bl> <rg>

   This all might be intuitive, and is the most common implementation, but this design sucks
   for a number of reasons. For one, it means Bash makes it absolutely impossible to expand
   any part of the inner region unquoted while leaving the outer region quoted. Quoting the
   outer forces quoting of the inner regions recursively (except nested command substitutions
   of course). Word-splitting is necessary to split words of the inner region, which cannot be
   done together with outer quoting. Consider the following (only slightly far-fetched) code:

# Bash (non-working example)

unset -v IFS # make sure we have a default IFS

if some crap; then
    typeset -a someCmd=(myCmd arg1 'arg2 yay!' 'third*arg*' 4)
fi

someOtherCmd=mycommand
typeset -a otherArgs=(arg3 arg4)

# What do you think the programmer expected to happen here?
# What do you think will actually happen...

"${someCmd[@]-"$someOtherCmd" arg2 "${otherArgs[@]}"}" arg5

   This final line is perhaps not the most obvious, but I've run into cases were this type of
   logic can be desirable and realistic. We can deduce what was intended:
     * If someCmd is set, then the resulting expansion should run the command: "myCmd" "arg1"
       "arg2 yay!" "third*arg*" "4" "arg5"
     * Otherwise, if someCmd is not set, expand $someOtherCmd and the inner args, to run a
       different command: "mycommand" "arg2" "arg3" "arg4" "arg5".

   Unfortunately, it is impossible to get the intended result in Bash (and most other shells)
   without taking a considerably different approach. The only way to split the literal inner
   parts is through word-splitting, which requires that the PE be unquoted. But, the only way
   to expand the outer expansion correctly without word-splitting or globbing is to quote it.
   Bash will actually expand the command as one of these:

# The quoted PE produces a correct result here...
 $ bash -c 'typeset -a someCmd=(myCmd arg1 "arg2 yay!" "third*arg*" 4); printf "<%s> " "${someCmd[@]
-"$someOtherCmd" arg2 "${otherArgs[@]}"}" arg5; echo'
<myCmd> <arg1> <arg2 yay!> <third*arg*> <4> <arg5>

# ...but in the opposite case the first 3 arguments are glued together. There are no workarounds.
 $ bash -c 'typeset -a otherArgs=(arg3 arg4); someOtherCmd=mycommand; printf "<%s> " "${someCmd[@]-"
$someOtherCmd" arg2 "${otherArgs[@]}"}" arg5; echo'
<mycommand arg2 arg3> <arg4> <arg5>

# UNLESS! we unquote the outer expansion allowing the inner quotes to
# affect the necessary parts while allowing word-splitting to split the literals:
 $ bash -c 'typeset -a otherArgs=(arg3 arg4); someOtherCmd=mycommand; printf "<%s> " ${someCmd[@]-"$
someOtherCmd" arg2 "${otherArgs[@]}"} arg5; echo'
<mycommand> <arg2> <arg3> <arg4> <arg5>

# Success!!!
 $ bash -c 'typeset -a someCmd=(myCmd arg1 "arg2 yay!" "third*arg*" 4); printf "<%s> " ${someCmd[@]-
"$someOtherCmd" arg2 "${otherArgs[@]}"} arg5; echo'
<myCmd> <arg1> <arg2> <yay!> <third*arg*> <4> <arg5>

# ...Ah fuck. (again, no workaround possible.)

The ksh93 exception

   To the best of my knowledge, ksh93 is the only shell that acts differently. Rather than
   forcing nested expansions into quoting, a quote at the beginning and end of the nested
   region will cause the quote state to reverse itself within the nested part. I have no idea
   whether it's an intentional or documented effect, but it does solve the problem and
   consequently adds a lot of potential power to these expansions.

   All we need to do is add two extra double-quotes:
# ksh93 passing the two failed tests from above:

 $ ksh -c 'otherArgs=(arg3 arg4); someOtherCmd="mycommand"; printf "<%s> " "${someCmd[@]-""$someOthe
rCmd" arg2 "${otherArgs[@]}""}" arg5; echo'
<mycommand> <arg2> <arg3> <arg4> <arg5>

 $ ksh -c 'typeset -a someCmd=(myCmd arg1 "arg2 yay!" "third*arg*" 4); printf "<%s> " "${someCmd[@]-
""$someOtherCmd" arg2 "${otherArgs[@]}""}" arg5; echo'
<myCmd> <arg1> <arg2 yay!> <third*arg*> <4> <arg5>

   This can be used to control the quote state of any part of any expansion to an arbitrary
   depth. Sadly, it is the only shell that does this and the difference may introduce a
   possible compatibility problem.

See also

     * Internal: [90]Introduction to expansion and substitution
     * Internal: [91]Arrays
     * Dictionary, internal: [92]Parameter

Discussion

   Stan R., 2010/06/20 01:48

   Found an error under the "Search and replace" sub-heading, near the beginning of the
   "Anchoring" section, where there is an example snippet:

MYSTRING=xxxxxxxxxx
echo ${MYSTRING//#x/y}  # RESULT: yxxxxxxxxx
echo ${MYSTRING//%x/y}  # RESULT: xxxxxxxxxy

   This should be:

MYSTRING=xxxxxxxxxx
echo ${MYSTRING/#x/y}  # RESULT: yxxxxxxxxx
echo ${MYSTRING/%x/y}  # RESULT: xxxxxxxxxy

   The difference is MYSTRING/ instead of MYSTRING//, since you cannot have both anchoring and
   .
   Reply
   Jan Schampera, 2010/06/20 14:56

   Thanks for this finding. A late night typo, maybe :)
   Reply
   Stan R., 2010/06/21 03:11

   Glad I could help.
   Reply
   Shmerl, 2010/10/20 18:37

   I found an error. You write:

   ${PARAMETER:-WORD} ${PARAMETER-WORD} If the parameter PARAMETER is unset (never was
   defined) or null (empty), this one expands to WORD, otherwise it expands to the value of
   PARAMETER, as if it just was ${PARAMETER}. If you omit the : (colon), like shown in the
   second form, the default value is only used when the parameter was unset, not when it was
   empty.

   Running a simple test

   str=""; echo ${str-test_result}

   Produces:

   test_result

   Now running:

   unset str; echo ${str-test_result}

   Produces nothing. So the above is just the opposite. It should be: If you omit the :
   (colon), like shown in the second form, the default value is only used when the parameter
   was empty, not when it was usnet.
   Reply
   Jan Schampera, 2010/10/20 23:13

   It works (and always worked) for me:
bonsai@core:~$ str=""; echo ${str-test_result}

bonsai@core:~$ unset str; echo ${str-test_result}
test_result
bonsai@core:~$

   I'm not sure what could be the reason for your tests to do the exact opposite. Is this
   really a Bash? Though, this behaviour is specified by POSIX(R), too: "In the parameter
   expansions [shown previously], use of the <colon> in the format shall result in a test for
   a parameter that is unset or null; omission of the <colon> shall result in a test for a
   parameter that is only unset."

   Do you have any way to find out where your (or my) problem is here?
   Reply
   Shmerl, 2010/10/21 17:59

   Sorry, I really meant the case with plus.

   Run this test:

   str=""; echo ${str+'test_result'}

   produces: test_result

   unset str; echo ${str+'test_result'}

   produces: (nothing)

   I was wrong about other cases, this difference only applies to + (alternative value) case.
   Reply
   Shmerl, 2010/10/21 18:03

   Make sure there is a plus there - the preview ate it.
   Reply
   Jan Schampera, 2010/10/23 11:36

   It does exactly what it should do. + produces an alternate value, means it expands to
   something instead of the real value of the parameter, if the parameter is "set" (+) or "set
   or null" (:+).
   Reply
   Shmerl, 2010/10/24 06:20

   Yes, but your text in the wiki above is misleading. It writes:

   If you omit the colon, as shown in the second form (${PARAMETER+WORD}), the alternate value
   will not be used when the parameter is empty, only if it is unset!

   While it should say:

   If you omit the colon, as shown in the second form (${PARAMETER+WORD}), the alternate value
   will not be used when the parameter is unset, only if it is empty!
   Reply
   Jan Schampera, 2010/10/24 08:09

   Oh, yes! Sorry, it took a while to see what you mean :(

   I rephrased it a bit. If you're not okay with it, feel free to change it. Thanks for
   pointing it out.
   Reply
   Shmerl, 2010/10/20 18:38

   Actually the previous note relates to all similar examples with :-, :=, etc.
   Reply
   my, 2011/01/25 11:55

   the ${ ^^ } and friends have a pattern parameter. But it seems anything beyond [ ] does not
   work.

TEST="abcABCxyz"

echo ${TEST^[abc]} # change first char if it is a||b||c
echo ${TEST^![abc]} # change first char if it is NOT a||b||c

TEST="hello world"
echo ${TEST^^[aeiou]}    # change ANY char that is in aeiou

AbcABCxyz
abcABCxyz
hEllO wOrld

   Reply
   Jan Schampera, 2011/02/01 06:30

   I don't see what doesn't work here. Did you mean
${TEST^[!abc]}
# (instead of ${TEST^![abc]})

   here?
   Reply
   Frederick Grose, 2011/02/11 23:43

   In GNU bash, 4.1.7(1)-release (x86_64-redhat-linux-gnu),

   the 'Negative Length Value' syntax,
echo "${MYSTRING:11:-17}"

   results in the following:
bash: -17: substring expression < 0

   LENGTH seems to behave like the array element COUNT.
   Reply
   Jan Schampera, 2011/02/12 09:44

   Hello Frederick,

   you're absolutely right, this is a Bash 4.2 feature. I added a note.
   Reply
   Altair IV, 2012/01/12 14:02

   Hmm? The [b]${!array[*]}[/b]/[b]${!array[@]}[/b] patterns aren't listed here? They print
   out a list of all existing array indexes, and can be used for looping through sparse and
   associative arrays.
   Reply
   Jan Schampera, 2012/06/20 23:24

   This is listed in the [93]arrays page, but might belong here, too, yes. It's a mixed
   subject, since all array-related expansion is parameter expansion.
   Reply
   David C, 2012/04/27 02:01

   Under your Code Example of Substring Removal, you only remove 1 character per "?".
   Therefore the example needs to be updated to echo "${STRING#??????}" (6 question marks).
   Another example for context would be echo "${STRING%??????}" which will give you "Hello".
   Reply
   Jan Schampera, 2012/06/20 23:18

   Late but fixed. Thank you.



---
http://www.cyberciti.biz/tips/bash-shell-parameter-substitution-2.html

HowTo: Use Bash Parameter Substitution Like A Pro

   by [12]NIX Craft on October 13, 2010 . [13]25 comments. LAST UPDATED February 23, 2013

   in [14]Shell scripting
   [15][terminal.png]

   The $ character is used for parameter expansion, and command substitution. You can use it
   for manipulating and/or expanding variables on demands without using external commands such
   as sed or awk.

#1: Getting Up Default Shell Variables Value

   The syntax is as follows:
${parameter:-defaultValue}
var=${parameter:-defaultValue}

   [16][unix-logo.gif]

   If parameter not set, [17]use defaultValue. In this example, your shell script takes
   arguments supplied on the command line. You'd like to provide default value so that the
   most common value can be used without needing to type them every time. If variable $1 is
   not set or passed, use root as default value for u:
u=${1:-root}

   Consider the following example:
#!/bin/bash
_jail_dir="${1:-/home/phpcgi}"
echo "Setting php-cgi at ${_jail_dir}..."
# rest of the script ...

   You can now run this script as follows:

./script.sh /jail              # <--- set php jail at /jail dir
./script.sh /home/httpd/jail   # <---- set php jail at /home/httpd/jail dir
./script.sh                    # <--- set php jail dir at /home/phpcgi (default)

   Here is another handy example:
_mkdir(){
        local d="$1"               # get dir name
        local p=${2:-0755}      # get permission, set default to 0755
        [ $# -eq 0 ] && { echo "$0: dirname"; return; }
        [ ! -d "$d" ] && mkdir -m $p -p "$d"
}

   Use this substitution for creating failsafe functions and providing missing command line
   arguments in scripts.

#1.1: Setting Default Values

   The syntax is as follows:
${var:=value}
var=${USER:=value}

   The assignment (:=) operator is used to assign a value to the variable if it doesn't
   already have one. Try the following examples:
echo $USER

   Sample outputs:
vivek

   Now, assign a value foo to the $USER variable if doesn't already have one:
echo ${USER:=foo}

   Sample outputs:
vivek

   Unset value for $USER:
unset USER
echo ${USER:=foo}

   Sample outputs:
foo

   This make sure you always have a default reasonable value for your script.

Tip: ${var:-defaultValue} vs ${var:=defaultValue}

   Please note that it will not [18]work with positional parameter arguments:
var=${1:=defaultValue}  ### FAIL with an error cannot assign in this way
var=${1:-defaultValue}    ### Perfect

#2: Display an Error Message If $VAR Not Passed

   If the variable is not defined or not passed, you [19]can stop executing the Bash script
   with the following syntax:
${varName?Error varName is not defined}
${varName:?Error varName is not defined or is empty}
${1:?"mkjail: Missing operand"}
MESSAGE="Usage: mkjail.sh domainname IPv4"             ### define error message
_domain=${2?"Error: ${MESSAGE}"}  ### you can use $MESSAGE too

   This is used for giving an error message for unset parameters. In this example, if the $1
   command line arg is not passed, stop executing the script with an error message:
_domain="${1:?Usage: mknginxconf domainName}"

   Here is a sample script:
#!/bin/bash
# Purpose: Wrapper script to setup Nginx Load Balancer
# Author: Vivek Gite
_root="/nas.pro/prod/scripts/perl/nginx"
_setup="${_root}/createnginxconf.pl"
_db="${_root}/database/text/vips.db"
_domain="${1:?Usage: mknginxconf domainName}"     ### die if domainName is not passed ####

[ ! -f $_db ] && { echo "$0: Error $_db file not found."; exit 1; }
line=$(grep "^${_domain}" $_db) || { echo "$0: Error $_domain not found in $_db."; exit 2; }

# Get domain config info into 4 fields:
# f1 - Domain Name|
# f2 - IPv4Vip:httpPort:HttpsPort, IPv6Vip:httpPort:HttpsPort|
# f3 - PrivateIP1:port1,PrivateIP2,port2,...PrivateIPN,portN|
# f4 - LB Type (true [round robin] OR false [session])
# -------------------------------------------------------------------------------
IFS='|'
read -r f1 f2 f3 f4  <<<"$line"

# Do we want ssl host config too?
IFS=':'
set -- $f2
ssl="false"
[ "$3" == "443" ] && ssl="true"

# Build query
d="$f1:$ssl:$f4"
IFS=','
ips=$f3

# Call our master script to setup nginx reverse proxy / load balancer (LB) for given domain name
$_setup "$d" $ips

#2.1: Display an Error Message and Run Command

   If $2 is not set display an error message for $2 parameter and run cp command on fly as
   follows:
#!/bin/bash
_file="$HOME/.input"
_message="Usage: chkfile commandname"

# Run another command (compact format)
_cmd="${2:? $_message $(cp $_file $HOME/.output)}"

$_cmd "$_file"

#3: Find Variable Length

   You can easily find string length using the following syntax:
${#variableName}
echo ${#variableName}
len=${#var}

   Here is a sample shell script to add a ftp user:
#!/bin/bash
# Usage : Add a ftp user
_fuser="$1"
_fpass="$2"

# die if username/password not provided
[ $# -ne 2 ] && { echo "Usage: addftpuser username password"; exit 1;}

# Get username length and make sure it always <= 8
[[ ${#_fuser} -ge 9 ]] && { echo "Error: Username should be maximum 8 characters in length. "; exit
2;}

# Check for existing user in /etc/passwd
/usr/bin/getent passwd "${_fuser}" &>/dev/null

# Check exit status
[ $? -eq 0 ] && { echo "Error: FTP username \"${_fuser}\" exists."; exit 3; }

# Add user
/sbin/useradd -s /sbin/nologin -m  "${_fuser}"
echo "${_fpass}" | /usr/bin/passwd "${_fuser}" --stdin

   Each Linux or UNIX command returns a status when it terminates normally or abnormally. You
   can use [20]command exit status in the shell script to display an error message or take
   some sort of action. In above example, if getent command is successful, it returns a code
   which tells the shell script to display an error message. 0 exit status means the command
   was successful without any errors. [21]$? holds the return value set by the previously
   executed command.

#4: Remove Pattern (Front of $VAR)

   The syntax is as follows:
${var#Pattern}
${var##Pattern}

   You can strip $var as per given pattern from front of $var. In this example remove /etc/
   part and get a filename only, enter:
f="/etc/resolv.conf"
echo ${f#/etc/}

   The first syntax removes shortest part of pattern and the second syntax removes the longest
   part of the pattern. Consider the following example:
_version="20090128"
_url="http://dns.measurement-factory.com/tools/dnstop/src/dnstop-${_version}.tar.gz"

   You just want to get filename i.e. dnstop-20090128.tar.gz, enter (try to remove shortest
   part of $_url) :
echo "${_url#*/}"

   Sample outputs:
/dns.measurement-factory.com/tools/dnstop/src/dnstop-20090128.tar.gz

   Now try using the longest part of the pattern syntax:
echo "${_url##*/}"

   Sample outputs:
dnstop-20090128.tar.gz

   This is also useful to get a script name without using /bin/basename:
#!/bin/bash
_self="${0##*/}"
echo "$_self is called"

   Create a script called master.info as follows:
#!/bin/bash
# Purpose: Display jail info as per softlink
# Author: Vivek Gite
_j="$@"

# find out script name
_self="${0##*/}"

[ "$VERBOSE" == "1" ] && echo "Called as $_self for \"$_j\" domain(s)"

for j in $_j
do
        export _DOMAIN_NAME=$j
        source functions.sh
        init_jail
        # call appropriate functions as per script-name / softlink
        case $_self in
                uploaddir.info) echo "Upload dir for $j: $(get_domain_upload_dir)" ;;
                tmpdir.info) echo "/tmp dir for $j: $(get_domain_tmp_dir)" ;;
                mem.info) echo "$j domain mem usage (php+lighttpd): $(get_domain_mem_info)" ;;
                cpu.info) echo "$j domain cpu usage (php+lighttpd): $(get_domain_cpu_info)" ;;
                user.info) echo "$j domain user and group info: $(get_domain_users_info)" ;;
                diskquota.info) echo "$j domain disk quota info (mysql+disk): $(get_domain_diskquota
_info)" ;;
                *) warn "Usage: $_self"
        esac
done

   Finally, create softlink as follows:
   # ln -s master.info uploaddir.info
   # ln -s master.info tmpdir.info
   # ln -s master.info mem.info
   ....
   ..
   You can now call script as follows:
   # ./mem.info example.org
   # ./cpu.info example.com example.net

#4.1: Remove Pattern (Back of $VAR)

   The syntax is as follows:
${var%pattern}
${var%%pattern}

   Exactly the same as above, except that it applies to the back of $var. In this example
   remove .tar.gz from $FILE, enter:
FILE="xcache-1.3.0.tar.gz"
echo ${FILE%.tar.gz}

   Sample outputs:
xcache-1.3.0

   Rename all [22]*.perl files to *.pl using bash for loop as Apache web server is configured
   to only use .pl file and not .perl file names:

for p in /scripts/projects/.devl/perl/*.perl
do
        mv "$p" "${p%.perl}.pl"
done

   You can combine all of them as follows to [23]create a build scripts:
#!/bin/bash
# Usage: Build suhosin module for RHEL based servers
# Author: Vivek Gite
# ----
# Set default value for $2
VERSION="-${2:-0.9.31}"
URL="http://download.suhosin.org/suhosin${VERSION}.tgz"
vURL="http://download.suhosin.org/suhosin${VERSION}.tgz.sig"

# Get tar ball names
FILE="${URL##*/}"
vFILE="${vURL##*/}"
DLHOME="/opt"
SOFTWARE="suhosin"

# Remove .tgz and get dir name
DEST="${FILE%.tgz}"

# Download software
wget $URL -O "${DLHOME}/$FILE"
wget $vURL -O "${DLHOME}/$vFILE"

# Extract it
tar -zxvf $FILE
cd "$DEST"

# Build it and install it
phpize --clean && phpize && ./configure && make && read -p "Update/Install $SOFTWARE [Y/n] ? " answe
r
shopt -s nocasematch
[[ $answer =~ y|es  ]] && make install
shopt -u nocasematch

   If you turn on [24]nocasematch option, shell matches patterns in a case-insensitive fashion
   when performing matching while executing [25]case or [26][[ conditional expression.

#5: Find And Replace

   The syntax is as follows:
${varName/Pattern/Replacement}
${varName/word1/word2}
${os/Unix/Linux}

   Find word unix and replace with linux, enter:
x="Use unix or die"
sed 's/unix/linux/' <<<$x

   You can avoid using sed as follows:
echo "${x/unix/linux}"
out="${x/unix/linux}"
echo "${out}"

   To replace all matches of pattern, enter :
out="${x//unix/linux}"

   You can use this to rename or remove files on fly
y=/etc/resolv.conf
cp "${y}" "${y/.conf/.conf.bak}"

   Here is another example:

         # RHEL php modules path
        _php_modules="/usr/lib64/php/modules"
        for i in $_php_modules/*
        do
                p="${i##*/}"                  ## Get module name
                ini="/etc/php.d/${p/so/ini}"  ## Get ini file by replacing .so with .ini extension
                # make sure file exists
                [ ! -f "$ini" ] && echo "$i php module exists but $ini file not found."
        done

   The following function installs required modules in chrooted php-cgi process

install_php_modules(){
        # get jail name
        local n="${_chrootbase}/${d##/}"
        local p=""
        local ini=""
        # enable only ${_php_modules_enabled} php modules and delete other .ini files if exists in j
ail
        for i in $_php_modules/*
        do
                p="${i##*/}"
                ini="$n/etc/php.d/${p/so/ini}"
                # find out if module is enabled or not
                if [[ ${_php_modules_enabled} = *${p}*   ]]
                then
                        [ "$VERBOSE" == "1" ] && echo " [+] Enabling php module $p"
                        $_cp -f "$i" "$n/${_php_modules##/}"      ## install it
                        copy_shared_libs "$i"                     ## get shared libs in jail too
                else
                        [ -f "${ini}" ] && $_rm -f "${ini}"       ## if old .ini exists in jail, jus
t delete it
                fi
        done
}

#6: Substring Starting Character

   The syntax is as follows:
${parameter:offset}
${parameter:offset:length}
${variable:position}
var=${string:position}

   Expands to up to length characters of parameter starting at the character specified by
   offset.
base="/backup/nas"
file="/data.tar.gz"
#### strip extra slash from $file  ####
path="${base}/${file:1}"

   Extract craft word only:
x="nixcraft.com"
echo ${x:3:5}"

   To extract phone number, enter:
phone="022-124567887"
# strip std code
echo "${phone:4}"

Summary: String Manipulation and Expanding Variables

   For your ready references here are all your handy bash parameter substitution operators.
   Try them all; enhance your scripting skills like a pro:
   ${parameter:-defaultValue}    Get default shell variables value
   ${parameter:=defaultValue}    Set default shell variables value
   ${parameter:?"Error Message"} Display an error message if parameter is not set
   ${#var}                       Find the length of the string
   ${var%pattern}                Remove from shortest rear (end) pattern
   ${var%%pattern}               Remove from longest rear (end) pattern
   ${var:num1:num2}              Substring
   ${var#pattern}                Remove from shortest front pattern
   ${var##pattern}               Remove from longest front pattern
   ${var/pattern/string}         Find and replace (only replace first occurrence)
   ${var//pattern/string}        Find and replace all occurrences



---
http://www.debuntu.org/how-to-bash-parameter-expansion-and-default-values/

[71]How-To: Bash Parameter Expansion and Default Values

   Posted by [72]chantra on January 28th, 2013
   [INS: :INS]

   Bash is a sh-compatible command language interpreter that executes commands read from the
   standard input or from a file.
   There is much more to bash than running a sequence of commands, one of the features bundled
   with bash is parameter expansion.

   Any shell user has most likely used shell variables, be it $1 or $myvar, to save values...
   but there is more to it. This tutorial will cover a subset of shell parameter expansion
   that can become really handy and save you a lot of time.

   Parameter expansion is introduced by the dollar $ character followed by the parameter name
   optionally enclosed in curly brackets to protect the variable to be expanded from
   characters following it and which could be interpreted as the variable name.

   So far, I guess everybody is aware of this. There is many common operation that you might
   have come across when creating shell scripts, like:
     * assigning a default value to a variable
     * string substitution
     * substring
     * Removing prefixes/sufixes
     * Case modification
     * .....

   Guess what, this can be done using builtin shell functionalities, no need to rely on
   external programs like expr, sed or even basename and dirname for path manipulation.....

   In this article, we will see how we can handle default value assignment.

Default Values

   Default value handling is done by parameter of the form: ${parameter:[-=?+]word} such as:
     * ${parameter:-word} to use a default value
     * ${parameter:=word} to assign a default value
     * ${parameter:?word} to display an error if unset or null
     * ${parameter:+word} to use an alternate value

Use a default value

   To use a default value, we will use the form ${parameter:-word}. If parameter is null or
   unset it will expand to word, otherwise it will expand to parameter, e.g it will be similar
   to ${parameter}.

   The script below shows a use case where if the $HOME is not set, it will default to
   /home/${USER}.
#!/bin/bash
unset HOME
echo ${HOME:-/home/${USER}}
echo $HOME
echo "== END of script =="

   Will output:

   chantra@testing:~$ ./bash-expansion.sh
   /home/chantra
   == END of script ==

Assign a default value

   As you could see in the previous example, HOME was not set after the expansion. In order to
   also set the parameter we can use ${parameter:=word} type of expansion.

   Let's modify the previous script to:
#!/bin/bash
unset HOME
echo ${HOME:=/home/${USER}}
echo $HOME
echo "== END of script =="

   The output is now:

   chantra@testing:~$ ./bash-expansion.sh
   /home/chantra
   /home/chantra
   == END of script ==

   As you can see, HOME now has the value of /home/${USER}.

Display Error if Null or Unset

   Sometimes, you might want to check if a value is set and exit if not. The form
   ${parameter:?word} allows you to do that in a pretty easy way:
#!/bin/bash
unset HOME
echo ${HOME:?is not set}
echo "== END of script =="

   will return 1 and output:

   chantra@testing:~$ ./dftval-dsplerror.sh
   ./dftval-dsplerror.sh: line 3: HOME: is not set

Using an Alternate Value

   The form ${parameter:+word} will expand word only if parameter is set and not null. For
   instance:
#!/bin/bash
echo ${HOME:+HOME is set}
echo "== END of script =="

   will output:

   chantra@testing:~$ ./alt.sh
   HOME is set
   == END of script ==

   That is it on how to handle default values with bash parameter expansion. I will cover
   other bash parameter expansion features in coming articles.
   Tks.
