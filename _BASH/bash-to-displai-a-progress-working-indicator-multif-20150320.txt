filename: bash-to-displai-a-progress-working-indicator-multif_20150320.txt
http://stackoverflow.com/questions/12498304/using-bash-to-display-a-progress-working-indicator

[26]Using BASH to display a progress (working) indicator

   up vote 4 down vote [27]favorite
   8

   Using a bash only script, how can you provide a bash progress indicator?

   So I can run a command form bash, and while that command is executing let the user know
   that something is still happening.
   [28]bash [29]shell [30]unix [31]progress
   [32]share|[33]improve this question
        [34]edited Sep 19 '12 at 15:57
   asked Sep 19 '12 at 15:50
   [35]Pez Cuckow
   5,94944189
   add a comment |

3 Answers 3

   [36]active [37]oldest [38]votes
   up vote 17 down vote accepted

   In this example using SCP, I'm demonstrating how to grab the process id (pid) and then do
   something while that process is running.

   This displays a simple spinnng icon.
/usr/bin/scp me@website.com:file somewhere 2>/dev/null &
pid=$! # Process Id of the previous running command

spin[0]="-"
spin[1]="\\"
spin[2]="|"
spin[3]="/"

echo -n "[copying] ${spin[0]}"
while [ kill -0 $pid ]
do
  for i in "${spin[@]}"
  do
        echo -ne "\b$i"
        sleep 0.1
  done
done
     ______________________________________________________________________________________

   William Pursell's solution
/usr/bin/scp me@website.com:file somewhere 2>/dev/null &
pid=$! # Process Id of the previous running command

spin='-\|/'

i=0
while kill -0 $pid 2>/dev/null
do
  i=$(( (i+1) %4 ))
  printf "\r${spin:$i:1}"
  sleep .1
done

   [39]share|[40]improve this answer
   [41]edited Mar 31 '14 at 22:58
   [42]diff_sky
   18325
   answered Sep 19 '12 at 15:50
   [43]Pez Cuckow
   5,94944189

   +1 This is really good: A third of the LOC other solutions use. –  [44]Eugen Rieck Sep 19
   '12 at 15:52

   +1 nice solution! –  [45]Kent Sep 19 '12 at 16:01
   1
   You need to run scp in the background, or it completes before the rest of this script runs.
   (Backgrounding is also required for $! to have any meaning). –  [46]chepner Sep 19 '12 at
   16:03

   It's much simpler to do: s='-\|/'; i=0; while kill -0 $pid; do i=$(( (i+1) %4 )); printf
   "\r${s:$i:1}"; sleep .1; done –  [47]William Pursell Sep 19 '12 at 16:04

   @chepner Good point, I just missed off the &. @WilliamPursell Yes, though not sure how
   clear that is! –  [48]Pez Cuckow Sep 19 '12 at 16:06
    |  [49]show 4 more comments
   up vote 4 down vote

   If you have a way to estimate percentage done, such as the current number of files
   processed and total number, you can make a simple linear progress meter with a little math
   and assumptions about screen width.
count=0
total=34
pstr="[=======================================================================]"

while [ $count -lt $total ]; do
  sleep 0.5 # this is work
  count=$(( $count + 1 ))
  pd=$(( $count * 73 / $total ))
  printf "\r%3d.%1d%% %.${pd}s" $(( $count * 100 / $total )) $(( ($count * 1000 / $total) % 10 )) $p
str
done

   Or instead of a linear meter you could estimate time remaining. It's about as accurate as
   other similar things.
count=0
total=34
start=`date +%s`

while [ $count -lt $total ]; do
  sleep 0.5 # this is work
  cur=`date +%s`
  count=$(( $count + 1 ))
  pd=$(( $count * 73 / $total ))
  runtime=$(( $cur-$start ))
  estremain=$(( ($runtime * $total / $count)-$runtime ))
  printf "\r%d.%d%% complete ($count of $total) - est %d:%0.2d remaining\e[K" $(( $count*100/$total
)) $(( ($count*1000/$total)%10)) $(( $estremain/60 )) $(( $estremain%60 ))
done
printf "\ndone\n"

   [50]share|[51]improve this answer
   answered Sep 19 '12 at 18:42
   [52]evil otto
   6,319522

   How can I estimate the files that are still to copy? You mean take a count of the current
   files at the start and then every loop count how many are on the remote system? (genuinely
   interested rather than saying you're wrong) –  [53]Pez Cuckow Sep 20 '12 at 10:57

   It depends completely on your task. For instance, if you're using scp to copy a bunch of
   files, you could call it separately for each file rather than using *. Or as you suggest
   you could check on the remote system for the number of files or file sizes, although that
   could be fairly expensive to do. –  [54]evil otto Sep 20 '12 at 17:24
   add a comment |
   up vote 0 down vote

   Referred from [55]here is a nice spinner function (with slight modification), will help
   your cursor to stay in original position also.
spinner()
{
    local pid=$!
    local delay=0.75
    local spinstr='|/-\'
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
}

   with usage:
(a_long_running_task) &
spinner



---
http://unix.stackexchange.com/questions/92920/use-the-command-bar-in-bash-without-i-o

[25]Use the command bar in bash without I/O?

   I really like the look of the output of [27]bar

   But that script is only used for Input/Output operations.

   How can I use it as a replacement for sleep but with visual feedback?
sleep 10

   [28]bash [29]programming
   [30]share|[31]improve this question
        [32]edited Nov 11 '14 at 18:23
   asked Sep 30 '13 at 4:39
   [33]rubo77
   2,49142153
   add a comment |

1 Answer 1

   [34]active [35]oldest [36]votes
   up vote 8 down vote

   I couldn't see a way to do this using bar. However you might be interested in these other
   commands that do the same thing, that might suite your needs better.

Method #1 - Fake it

   This method will simply overwrite what's been previously displayed to the screen with a
   larger progress bar. Simple but effective.

   Example, ex.bash:
#!/bin/bash

echo -ne '#####                     (33%)\r'
sleep 1
echo -ne '#############             (66%)\r'
sleep 1
echo -ne '#######################   (100%)\r'
echo -ne '\n'

Method #2 - pipeview

   The command pv provides progress bar functionality. You can see more elaborate examples in
   this article titled: [37]A Unix Utility You Should Know About: Pipe Viewer.
$ pv access.log | gzip > access.log.gz
611MB 0:00:11 [58.3MB/s] [=>      ] 15% ETA 0:00:59

Method #3 - spinner

   You can use the following sample code to construct your own "spinner" using a simple loop.
   Within the loop you could embed whatever commands you like. This code comes from this
   article, titled: [38]Can I do a spinner in Bash?.
#!/bin/bash

sp='/-\|'
printf ' '
for i in $(seq 3); do
  printf '\b%.1s' "$sp"
  sp=${sp#?}${sp%???}
  sleep 1
done
echo ''

Method #4 - dialog

   There's a command called dialog which does pretty much what you want. It makes use of
   graphical dialogs, but they're ncurses based so they'll work in most every terminal and/or
   script so long as there's support for ncurses. You can see all the [39]dialog documentation
   on the project's website.

   screenshot



---
http://www.theiling.de/projects/bar.html

‘bar’ - ‘cat’ with ASCII progress bar

     * [9]Download
     * [10]Examples
     * [11]Docs
     * [12]Bugs
     * [13]Changes
     * [14]Portability
     * [15]Other Projects
     * [16]Subscribe via Freshmeat
     ______________________________________________________________________________________

   This is a small shell script intended to be used in portable Unix install scripts for
   showing progress bars.

   The overall goal is to write a minimally complex shell script (thus a program that needs no
   compilation) that is as robust as possible to work on as many Bourne shells and operating
   systems as possible, and that implements ‘cat’ with an ASCII progress bar and some other
   nifty features.

   This is pure Bourne shell code. (For sh, ash, ksh, zsh, bash, ...)

   The script is mainly intended to be used in portable install scripts, where you can use the
   body of the script.

   animated barcat progress bar in ASCII

   Source Code

   IFRAME: [17]../downloads/idx.cgi/bar*?raw;lang=en
   [18]Click here to download.
     ______________________________________________________________________________________

Portability

   [19]※
   Shell           OS                          Confirmed Script Version(s)
   Regularly checked by myself
   /bin/sh         NetBSD 1.6.2                >= 1.2
   /bin/sh         Solaris 2.9                 >= 1.0
   /bin/sh         Solaris 2.8                 >= 1.2
   ae 2.1.8        Linux (Suse)                >= 1.2
   ash 0.2         Linux (Suse)                >= 1.2
   bash 1.14.5     Linux (Suse)                >= 1.2
   bash 2.05.0(1)  Linux (Suse)                >= 1.0
   bash 2.05.0(1)  Solaris 2.9                 >= 1.2
   bash 2.05a.0(1) Linux (Debian)              >= 1.2
   bash 2.05b.0(1) NetBSD 1.6.2                >= 1.2
   bash 3.00.0(1)  Solaris 2.8                 >= 1.2
   jsh 050621      Linux (Suse)                >= 1.3
   ksh             Solaris 2.9                 >= 1.2
   ksh             Solaris 2.8                 >= 1.2
   pdksh 5.2.14    Linux (Suse)                >= 1.2
   pdksh 5.2.14    NetBSD 1.6.2                >= 1.2
   zsh 4.2.5       Linux (Suse)                >= 1.2
   zsh 4.0.4       Linux (Debian)              >= 1.2
   zsh 3.0.8       Solaris 2.9                 >= 1.2
   Verified by users
   ksh             AIX 5.0                     1.3.1
   /bin/sh         FreeBSD 5.3                 1.3.1
   bash            Mac OS X 10.4.6             1.4
   bash            Fedora Core 5               1.4
   bash 3.1        Fedora Core 6               1.4
   ksh             Tru64 Unix                  1.4
   bash 3.2.13(1)  Ubuntu 7.04 Feisty          1.4
   bash-3.1.17     Gentoo 2007.0               1.4
   bash-3.2.25(1)  Ubuntu 7.10                 1.4
   ksh             OpenBSD 4.2                 1.4
                   HP-UX 11i v2 (11.23)        1.4
   ksh             FreeBSD 7.1-STABLE          1.4
   /bin/sh         SunOS OpenSolaris i386 5.11 1.4
   Bash 4.0        ArchLinux                   1.4

   Please help improve this project by reporting success or failure in other shells,
   especially in /bin/sh on other operating systems.
   Success!
   Failure!
     ______________________________________________________________________________________

Examples

   [20]※
                      Append files
   Standard:
cat file1 file2 file2 > file3

   With Progress Bar:
bar file1 file2 file2 > file3

                      Copy a file
   Standard:
cp infile outfile

   With Progress Bar:
bar -o outfile infile

                      Copy several files to another directory (showing a common progress bar)
   Standard:
cp file1 file2 file2 outdir/

   With Progress Bar:
bar -c 'cat > outdir/${bar_file}' file1 file2 file3

                      Unpack each file individually, but have a common progress bar
   Standard:
for i in *.tar.gz; do tar xzpf $i; done

   With Progress Bar:
bar -c 'tar xzpf -' *.tar.gz

Make a File Listing

   We don't want to mention ‘.tar.gz’ in the listing, so we use ‘-e’ to append an extension in
   each command.
   Standard:
(for file in erwin-2.0.274 bar-1.0-src linux-2.4.21
do
    echo ${file}:
    tar tzvpf ${file}.tar.gz
done) > package-list.txt

   With Progress Bar:
bar -c 'echo ${bar_file}: ; tar tzvpf -' \
    -e .tar.gz                           \
        erwin-2.0.274                    \
        bar-1.0-src                      \
        linux-2.4.21                     \
            > package-list.txt
     ______________________________________________________________________________________

Documentation

Options Overview

   For the shell script, features are usually passed on the command line, and for the shell
   function (but also for the script), features are passed as exported environment variables.
   The following tables gives an overview of the features
   Cmd. Line   Env. Var   Description
   -o FILE use shell redirection Redirects output to a file.
   -n BAR_CLEAR=1 After termination, clear the line with the bar instead of leaving a full bar
   on the console.
   -p BAR_PERC=0 Hides the percentage display.
   -E BAR_ETA=0 Hides the estimated time of arrival (ETA) display.
   -t BAR_TRACE=1 Shows the current file (trace mode).
   -T WIDTH BAR_TRACE_WIDTH=WIDTH Sets the number of characters reserved for the current file
   display. If not set, the default is 10.
   -q BAR_OK=0 Hides the bar completely, and reverts to the plain behaviour of cat.
   -c CMD BAR_CMD=CMD For each file, pipe the contents into CMD. The command is evaluated in
   the shell, you have access to the internal variables of the script. Currently, the most
   interesting variable is bar_file which contains the name of the current file as given on
   the command line, i.e., without the additional ending set by BAR_EXT.
   -e EXT BAR_EXT=EXT Sets EXT as an additional file extension to be appended to each given
   file.
   -d DIR BAR_DIR=DIR Sets DIR to be prefixed to each given file. Typically used for
   prepending directories to each file, in which case the argument must end in a slash.
   -b SIZE BAR_BS=SIZE Sets the maximal block size to use for dd. By default, this is 1048567
   (= 1 MB). The command line option accepts suffixes: k for kilobytes and M for megabytes.
   The environment variable must be specified in bytes.
   -s SIZE BAR_SIZE=SIZE

   Sets the expected number of bytes expected to be processed. Under no circumstances, this
   may be smaller than the amount of bytes read, as the script might process less bytes of
   data then (but this is also not good for restricting the data flow to an exact number of
   bytes, since the internal counting is heuristical: the script will cut the stream at some
   unpredictable point after the given amount of bytes).

   Like -b, the command line accepts k and M suffixes, but only when the result is smaller
   than the numbers expr can handle.

   Without using suffixes, i.e., in bytes, you may specify any amount, even larger ones than
   expr can handle.
   -w WIDTH BAR_WIDTH=WIDTH Sets the bar width to WIDTH characters. The script tries to find a
   default value by using the environment variable COLUMNS. If it is not set, the default is
   76.
   -0 CHAR BAR_C0=CHAR Sets the character displayed for work yet to be done.
   -1 CHAR BAR_C1=CHAR Sets the character displayed for work already done.
   -[ CHAR BAR_A=CHAR Sets the first character displayed in the bar (may be empty).
   -] CHAR BAR_B=CHAR Sets the last character displayed in the bar (may be empty).
   -V Prints the version number and exits.
   -D

   Tries to dump the bar_cat() shell function, i.e. everything but the command line interface.
   The output can be included in your own scripts. This options strips comments, empty lines,
   and leading white space on all lines to make the result small.

   Some features may be removed completely from the dumped shell code by specifying the
   corresponding options before -D. These are: -t (trace), -p (percentage), -E (ETA) and -L
   (large file support). (-L only has an effect with -D.)
   -D- Same as -D, but only dumps the function body.
   -- Last option: only file names follow

Input Files

   In the comment line, after the options, the input files follow. The shell function bar_cat
   is invoked with that list of files.

   Note: If the list of files you provide to bar_cat is empty, nothing is read. To explicitly
   state that stdin is to be read, use the special file name /dev/stdin.

   The command line interface invoked with no file names will also read from stdin.



---
http://stackoverflow.com/questions/238073/how-to-add-a-progress-bar-to-a-shell-script

[26]How to add a progress bar to a shell script?

   When scripting in bash or any other shell in *NIX, while running a command that will take
   more than a few seconds, a progress bar is needed.

   For example, copying a big file, opening a big tar file.

   What ways do you recommend to add progress bars to shell scripts?
   [28]bash [29]shell [30]zsh
   [31]share|[32]improve this question
   [33]edited May 30 '12 at 10:56
   [34]Jens
   22.9k53878
   asked Oct 26 '08 at 14:32
   [35]Tom Feiner
   4,642113447
   add a comment |

21 Answers 21

   [36]active [37]oldest [38]votes
   up vote 237 down vote accepted

   You can implement this by overwriting a line. Use \r to go back to the beginning of the
   line without writing \n to the terminal.

   Write \n when you're done to advance the line.

   Use echo -ne to:
    1. not print \n and
    2. to recognize escape sequences like \r.

   Here's a demo:
echo -ne '#####                     (33%)\r'
sleep 1
echo -ne '#############             (66%)\r'
sleep 1
echo -ne '#######################   (100%)\r'
echo -ne '\n'

   [39]share|[40]improve this answer
   [41]edited Dec 15 '13 at 6:36
   [42]Michael Petrotta
   38.3k988137
   answered Oct 26 '08 at 14:47
   [43]Mitch Haile
   5,66911821
   27
   I've allways wanted to know this. That's an epiphany for me!!!! Thanks! –  [44]Hugo Oct 27
   '08 at 17:22
   8
   According to the echo man page (at least on MacOS X) sh/bash use their own built-in echo
   command that doesn't accept "-n" ... so in order to accomplish the same thing you need to
   put \r\c at the end of the string, instead of just \r –  [45]Justin Jenkins Apr 2 '12 at
   1:17
   12
   The portable way to output this is to use printf instead of echo. –  [46]Jens May 30 '12 at
   10:52
   2
   for printf we would have to use this format: printf "#### (50%%)\r", it wouldn't work with
   single quotes and percent sign needs to be escaped. –  [47]nurettin Sep 10 '13 at 9:55
   3
   The question was "How do I do progress bars" with an example of copying files. I focused on
   the "graphics" problem, not the calculation of how far along a file copy operation is. –
   [48]Mitch Haile May 25 '14 at 5:00
    |  [49]show 3 more comments
   up vote 52 down vote

   you can use this project: [50]http://www.theiling.de/projects/bar.html

   looks like this: progress bar
   [51]share|[52]improve this answer
   answered Nov 25 '10 at 10:59
   [53]mishunika
   1,1811813
   1
   Looks cool! Thanks for sharing –  [54]Viet Nov 15 '12 at 1:02

   How could I use that for processes that do not involwe copying?
   [55]unix.stackexchange.com/questions/92920/… –  [56]rubo77 Sep 30 '13 at 10:25

   @rubo77 see my answer for long description, tl;dr $ copy <(bar file1) file2 –  [57]thedk
   Jul 18 '14 at 6:08
   1
   @thedk which one? I only found your answer for copying files. But [58]How can I use the
   command bar in bash without I/O? –  [59]rubo77 Jul 18 '14 at 9:47
   add a comment |
   up vote 24 down vote

   Some posts have showed how to display the command's progress. In order to calculate it,
   you'll need to see how much you've progressed. On BSD systems some commands, like dd(1),
   accept a SIGINFO signal, and will report their progress. On Linux systems some commands
   will respond similarly to SIGUSR1. If this facility is available, you can pipe your input
   through dd to monitor the number of bytes processed.

   Alternatively, you can use [60]lsof to obtain the offset of the file's read pointer, and
   thereby calculate the progress. A command like the following could do the trick.
lsof -o0 -o -p $PID |
awk '
            BEGIN { CONVFMT = "%.2f" }
            $4 ~ /^[0-9]+r$/ && $7 ~ /^0t/ {
                    offset = substr($7, 3)
                    fname = $9
                    "stat -f %z '\''" fname "'\''" | getline
                    len = $0
                    print fname, offset / len * 100 "%"
            }
    '

   I've posted Linux and FreeBSD shell scripts on [61]my blog.
   [62]share|[63]improve this answer
   [64]edited Jan 27 at 13:39
   [65]Zearin
   555719
   answered Oct 26 '08 at 15:18
   [66]Diomidis Spinellis
   9,27822348

   This is awesome, I always forget to pipe things through pv :-) I think my "stat" command
   works a bit differently, my (Linux) version of this script:
   [67]gist.github.com/unhammer/b0ab6a6aa8e1eeaf236b –  [68]unhammer Jul 29 '14 at 12:46
   add a comment |
   up vote 14 down vote

   use the linux command pv:

   [69]http://linux.die.net/man/1/pv

   it doesn't know the size if it's in the middle of the stream, but it gives a speed and
   total and from there you can figure out how long it should take and get feedback so you
   know it hasn't hung.
   [70]share|[71]improve this answer
   answered Jul 28 '11 at 17:35
   [72]Seth Wegner
   14912
   add a comment |
   up vote 10 down vote

   A simpler method that works on my system using the pipeview ( pv ) utility.
srcdir=$1
outfile=$2


tar -Ocf - $srcdir | pv -i 1 -w 50 -berps `du -bs $srcdir | awk '{print $1}'` | 7za a -si $outfile

   [73]share|[74]improve this answer
    answered [75]Jul 25 '10 at 20:07
   community wiki
   [76]leebert
   add a comment |
   up vote 9 down vote

   I found this bash script which wraps around cp & tar commands to provide a progress bar:
   [77]http://www.theiling.de/projects/bar.html
   [78]share|[79]improve this answer
   answered Oct 26 '08 at 14:49
   [80]Tom Feiner
   4,642113447
   4
   While this link may answer the question, it is better to include the essential parts of the
   answer here and provide the link for reference. Link-only answers can become invalid if the
   linked page changes. –  [81]chilemagic Oct 3 '14 at 17:11
   add a comment |
   up vote 8 down vote

   [82]GNU tar has a useful option which gives a functionality of a simple progress bar.

   (...) Another available checkpoint action is ‘dot’ (or ‘.’). It instructs tar to print a
   single dot on the standard listing stream, e.g.:
$ tar -c --checkpoint=1000 --checkpoint-action=dot /var
...

   The same effect may be obtained by:
$ tar -c --checkpoint=.1000 /var

   [83]share|[84]improve this answer
   answered Aug 2 '10 at 14:15
   [85]Wojtek
   9712
   add a comment |
   up vote 5 down vote

   My solution displays the percentage of the tarball that is currently being uncompressed and
   written. I use this when writing out 2GB root filesystem images. You really need a progress
   bar for these things. What I do is use gzip --list to get the total uncompressed size of
   the tarball. From that I calculate the blocking-factor needed to divide the file into 100
   parts. Finally, I print a checkpoint message for each block. For a 2GB file this gives
   about 10MB a block. If that is too big then you can divide the BLOCKING_FACTOR by 10 or
   100, but then it's harder to print pretty output in terms of a percentage.

   Assuming you are using Bash then you can use the following shell function
untar_progress ()
{
  TARBALL=$1
  BLOCKING_FACTOR=$(gzip --list ${TARBALL} |
    perl -MPOSIX -ane '$.==2 && print ceil $F[1]/50688')
  tar --blocking-factor=${BLOCKING_FACTOR} --checkpoint=1 \
    --checkpoint-action='ttyout=Wrote %u%  \r' -zxf ${TARBALL}
}

   [86]share|[87]improve this answer
   [88]edited Feb 12 '14 at 20:30
   [89]anon
   23.6k1085146
   answered Aug 24 '10 at 9:01
   [90]Noah Spurrier
   37945
   add a comment |
   up vote 4 down vote

   You may also be interested in [91]how to do a spinner:

Can I do a spinner in Bash?

   Sure!
i=1
sp="/-\|"
echo -n ' '
while true
do
    printf "\b${sp:i++%${#sp}:1}"
done

   Each time the loop iterates, it displays the next character in the sp string, wrapping
   around as it reaches the end. (i is the position of the current character to display and
   ${#sp} is the length of the sp string).

   The \b string is replaced by a 'backspace' character. Alternatively, you could play with \r
   to go back to the beginning of the line.

   If you want it to slow down, put a sleep command inside the loop (after the printf).

   A POSIX equivalent would be:
sp='/-\|'
printf ' '
while true; do
    printf '\b%.1s' "$sp"
    sp=${sp#?}${sp%???}
done

   If you already have a loop which does a lot of work, you can call the following function at
   the beginning of each iteration to update the spinner:
sp="/-\|"
sc=0
spin() {
   printf "\b${sp:sc++:1}"
   ((sc==${#sp})) && sc=0
}
endspin() {
   printf "\r%s\n" "$@"
}

until work_done; do
   spin
   some_work ...
done
endspin

   [92]share|[93]improve this answer
   [94]edited Jul 18 '14 at 9:56
   [95]rubo77
   2,06322060
   answered Jul 25 '10 at 20:12
   [96]Daenyth
   12.8k3273
   add a comment |
   up vote 2 down vote

   Most unix commands will not give you the sort of direct feedback from which you can do
   this. Some will give you output on stdout or stderr that you can use.

   For something like tar you could use the -v switch and pipe the output to a program that
   updates a small animation for each line it reads. As tar writes out a list of files it's
   unravelled the program can update the animation. To do a percent complete you would have to
   know the number of files and count the lines.

   cp doesn't give this sort of output as far as I know. To monitor the progress of cp you
   would have to monitor the source and destination files and watch the size of the
   destination. You could write a small c program using the [97]stat (2) system call to get
   the file size. This would read the size of the source then poll the destination file and
   update a % complete bar based on the size of the file written to date.
   [98]share|[99]improve this answer
   answered Oct 26 '08 at 14:42
   [100]ConcernedOfTunbridgeWells
   39.6k1193161
   add a comment |
   up vote 1 down vote

   This lets you visualize that a command is still executing:
while :;do echo -n .;sleep 1;done &
tar zxf packages.tar.gz; # or any other command here
kill $!; trap 'kill $!' SIGTERM

   This will create an infinite while loop that executes in the background and echoes a "."
   every second. This will display . in the shell. Run the tar command or any a command you
   want. When that command finishes executing then kill the last job running in the background
   - which is the infinite while loop.
   [101]share|[102]improve this answer
   [103]edited Jun 8 '14 at 17:06
   [104]rubo77
   2,06322060
   answered May 2 '13 at 21:54
   [105]romeror
   191
   add a comment |
   up vote 1 down vote

   First of all bar is not the only one pipe progress meter. The other (maybe even more known)
   is pv (pipe viewer).

   Secondly bar and pv can be used for example like this:
$ bar file1 | wc -l
$ pv file1 | wc -l

   or even:
$ tail -n 100 file1 | bar | wc -l
$ tail -n 100 file1 | pv | wc -l

   one useful trick if you want to make use of bar and pv in commands that are working with
   files given in arguments, like e.g. copy file1 file2, is to use [106]process substitution:
$ copy <(bar file1) file2
$ copy <(pv file1) file2

   Process substitution is a bash magic thing that creates temporary fifo pipe files /dev/fd/
   and connect stdout from runned process (inside parenthesis) through this pipe and copy sees
   it just like an ordinary file (with one exception, it can only read it forwards).

   Update:

   bar command itself allows also for copying. After man bar:
bar --in-file /dev/rmt/1cbn --out-file \
     tape-restore.tar --size 2.4g --buffer-size 64k

   But process substitution is in my opinion more generic way to do it. An it uses cp program
   itself.
   [107]share|[108]improve this answer
        [109]edited Jul 18 '14 at 6:13
   answered Jul 18 '14 at 6:06
   [110]thedk
   768715
   add a comment |
   up vote 1 down vote

   Got an easy progress bar function that i wrote the other day:
#!/bin/bash
# 1. Create ProgressBar function
# 1.1 Input is currentState($1) and totalState($2)
function ProgressBar {
# Process data
    let _progress=(${1}*100/${2}*100)/100
    let _done=(${_progress}*4)/10
    let _left=40-$_done
# Build progressbar string lengths
    _fill=$(printf "%${_done}s")
    _empty=$(printf "%${_left}s")

# 1.2 Build progressbar strings and print the ProgressBar line
# 1.2.1 Output example:
# 1.2.1.1 Progress : [########################################] 100%
printf "\rProgress : [${_fill// /#}${_empty// /-}] ${_progress}%%"

}

# Variables
_start=1

# This accounts as the "totalState" variable for the ProgressBar function
_end=100

# Proof of concept
for number in $(seq ${_start} ${_end})
do
    sleep 0.1
    ProgressBar ${number} ${_end}
done
printf '\nFinished!\n'

   Or snag it from,
   [111]https://github.com/fearside/ProgressBar/
   [112]share|[113]improve this answer
   answered Jan 20 at 12:05
   [114]fearside
   112
   add a comment |
   up vote 0 down vote

   To make a tar progress bar
tar xzvf pippo.tgz |xargs -L 19 |xargs -I@ echo -n "."

   Where "19" is the number of files in the tar divided the length of the intended progress
   bar. Example: the .tgz contains 140 files and you'll want a progress bar of 76 ".", you can
   put -L 2.

   You'll need nothing else.
   [115]share|[116]improve this answer
   answered May 30 '12 at 10:40
   [117]DeathFromAbove
   1

   This is specific to tar, so unless the shell script only consist of tar command, it doesn't
   really apply to OP's case. –  [118]doubleDown Oct 20 '12 at 4:30
   add a comment |
   up vote 0 down vote

   If you don't mind against using additional packages - there is an awesome tool, which shows
   colored information bar while copying data stream - [119]http://clpbar.sourceforge.net/
   [120]share|[121]improve this answer
   answered Apr 26 '13 at 6:27
   [122]techtonik
   3,80112643

   easyer to install is Tom Feiner's answer: bar –  [123]rubo77 Sep 30 '13 at 7:07
   add a comment |
   up vote 0 down vote

   I had the same thing to do today and based on Diomidis answer, here is how I did it (linux
   debian 6.0.7). Maybe, that could help you :
#!/bin/bash

echo "getting script inode"
inode=`ls -i ./script.sh | cut -d" " -f1`
echo $inode

echo "getting the script size"
size=`cat script.sh | wc -c`
echo $size

echo "executing script"
./script.sh &
pid=$!
echo "child pid = $pid"

while true; do
        let offset=`lsof -o0 -o -p $pid | grep $inode | awk -F" " '{print $7}' | cut -d"t" -f 2`
        let percent=100*$offset/$size
        echo -ne " $percent %\r"
done

   [124]share|[125]improve this answer
   answered May 2 '13 at 11:40
   [126]akiuni
   1

   can you explain what offset calculate . –  [127]deven98602 May 9 '13 at 7:46

   When I start this script as root, I get the error: lsof: WARNING: can't stat()
   fuse.gvfsd-fuse file system /home/rubo77/.gvfs Output information may be incomplete. –
   [128]rubo77 Sep 30 '13 at 11:30

   And, I get the error: progressbar: Zeile 17: let: offset=: Syntax Fehler: Operator
   erwartet. (Fehlerverursachendes Zeichen ist \"=\"). if I call this script progressbar.sh
   and call it with cd /tmp/; echo "sleep 5">script.sh; bash progressbar.sh on Ubuntu 13.04 –
   [129]rubo77 Sep 30 '13 at 11:37
   add a comment |
   up vote 0 down vote

   I couldn't find bash throbber topic so pasting example code here

   [130]https://gist.github.com/3621677
#!/usr/bin/env bash

C="0" # count
while [ $C -lt 20 ]
do
    case "$(($C % 4))" in
        0) char="/"
        ;;
        1) char="-"
        ;;
        2) char="\\"
        ;;
        3) char="|"
        ;;
    esac

    sleep .2
    echo -ne $char "\r"
    C=$[$C+1]
done
echo -e 'done\r'

   [131]share|[132]improve this answer
   [133]edited Sep 30 '13 at 11:26
   [134]Syon
   3,27241225
   answered Sep 4 '12 at 14:32
   [135]sobi3ch
   3641318
   1
   I would call this a spinner, not a progressbar –  [136]rubo77 Sep 30 '13 at 11:23

   Thats true indeed –  [137]sobi3ch Oct 1 '13 at 10:33
   add a comment |
   up vote 0 down vote

   Once I also had a busy script which was occupied for hours without showing any progress. So
   I implemented a function which mainly includes the techniques of the previous answers:
#!/bin/bash
# Updates the progress bar
# Parameters: 1. Percentage value
update_progress_bar()
{
  if [ $# -eq 1 ];
  then
    if [[ $1 == [0-9]* ]];
    then
      if [ $1 -ge 0 ];
      then
        if [ $1 -le 100 ];
        then
          local val=$1
          local max=100

          echo -n "["

          for j in $(seq $max);
          do
            if [ $j -lt $val ];
            then
              echo -n "="
            else
              if [ $j -eq $max ];
              then
                echo -n "]"
              else
                echo -n "."
              fi
            fi
          done

          echo -ne " "$val"%\r"

          if [ $val -eq $max ];
          then
            echo ""
          fi
        fi
      fi
    fi
  fi
}

update_progress_bar 0
# Further (time intensive) actions and progress bar updates
update_progress_bar 100

   [138]share|[139]improve this answer
   answered Nov 1 '13 at 11:52
   [140]janr
   1,6842821

   You could roll up those first four ifs into a single if statement with a series of ANDs,
   since you don't have any specific code within any of them: if [ $# -eq 1 ] && [[ $1 ==
   [0-9]* ]] && [ $1 -ge 0 ] && [ $1 -le 100 ]; You could also circumvent the for loops and
   shorten your code with printf and command substitution: printf "["; printf "%.0=" $(seq
   $val); printf "%.0." $(seq $[ $val+1 ] $max); printf "] %s%%\r" $val; –
   [141]CaffeineConnoisseur Jul 22 '14 at 1:16
   add a comment |
   up vote 0 down vote

   This is only applicable using gnome zenity. Zenity provides a great native interface to
   bash scripts: [142]https://help.gnome.org/users/zenity/stable/

   From Zenity Progress Bar Example:
#!/bin/sh
(
echo "10" ; sleep 1
echo "# Updating mail logs" ; sleep 1
echo "20" ; sleep 1
echo "# Resetting cron jobs" ; sleep 1
echo "50" ; sleep 1
echo "This line will just be ignored" ; sleep 1
echo "75" ; sleep 1
echo "# Rebooting system" ; sleep 1
echo "100" ; sleep 1
) |
zenity --progress \
  --title="Update System Logs" \
  --text="Scanning mail logs..." \
  --percentage=0

if [ "$?" = -1 ] ; then
        zenity --error \
          --text="Update canceled."
fi

   [143]share|[144]improve this answer
   answered Mar 17 '14 at 12:25
   [145]tPSU
   1
   add a comment |
   up vote 0 down vote

   I did a pure shell version for an embedded system taking advantage of:
     * /usr/bin/dd's SIGUSR1 signal handling feature.
       Basically, if you send a 'kill SIGUSR1 $(pid_of_running_dd_process)', it'll output a
       summary of throughput speed and amount transferred.
     * backgrounding dd and then querying it regularly for updates, and generating hash ticks
       like old-school ftp clients used to.
     * Using /dev/stdout as the destination for non-stdout friendly programs like scp

   The end result allows you to take any file transfer operation and get progress update that
   looks like old-school FTP 'hash' output where you'd just get a hash mark for every X bytes.

   This is hardly production quality code, but you get the idea. I think it's cute.

   For what it's worth, the actual byte-count might not be reflected correctly in the number
   of hashes - you may have one more or less depending on rounding issues. Don't use this as
   part of a test script, it's just eye-candy. And, yes, I'm aware this is terribly
   inefficient - it's a shell script and I make no apologies for it.

   Examples with wget, scp and tftp provided at the end. It should work with anything that has
   emits data. Make sure to use /dev/stdout for programs that aren't stdout friendly.
#!/bin/sh
#
# Copyright (C) Nathan Ramella (nar+progress-script@remix.net) 2010
# LGPLv2 license
# If you use this, send me an email to say thanks and let me know what your product
# is so I can tell all my friends I'm a big man on the internet!

progress_filter() {

        local START=$(date +"%s")
        local SIZE=1
        local DURATION=1
        local BLKSZ=51200
        local TMPFILE=/tmp/tmpfile
        local PROGRESS=/tmp/tftp.progress
        local BYTES_LAST_CYCLE=0
        local BYTES_THIS_CYCLE=0

        rm -f ${PROGRESS}

        dd bs=$BLKSZ of=${TMPFILE} 2>&1 \
                | grep --line-buffered -E '[[:digit:]]* bytes' \
                | awk '{ print $1 }' >> ${PROGRESS} &

        # Loop while the 'dd' exists. It would be 'more better' if we
        # actually looked for the specific child ID of the running
        # process by identifying which child process it was. If someone
        # else is running dd, it will mess things up.

        # My PID handling is dumb, it assumes you only have one running dd on
        # the system, this should be fixed to just get the PID of the child
        # process from the shell.

        while [ $(pidof dd) -gt 1 ]; do

                # PROTIP: You can sleep partial seconds (at least on linux)
                sleep .5

                # Force dd to update us on it's progress (which gets
                # redirected to $PROGRESS file.
                #
                # dumb pid handling again
                pkill -USR1 dd

                local BYTES_THIS_CYCLE=$(tail -1 $PROGRESS)
                local XFER_BLKS=$(((BYTES_THIS_CYCLE-BYTES_LAST_CYCLE)/BLKSZ))

                # Don't print anything unless we've got 1 block or more.
                # This allows for stdin/stderr interactions to occur
                # without printing a hash erroneously.

                # Also makes it possible for you to background 'scp',
                # but still use the /dev/stdout trick _even_ if scp
                # (inevitably) asks for a password.
                #
                # Fancy!

                if [ $XFER_BLKS -gt 0 ]; then
                        printf "#%0.s" $(seq 0 $XFER_BLKS)
                        BYTES_LAST_CYCLE=$BYTES_THIS_CYCLE
                fi
        done

        local SIZE=$(stat -c"%s" $TMPFILE)
        local NOW=$(date +"%s")

        if [ $NOW -eq 0 ]; then
                NOW=1
        fi

        local DURATION=$(($NOW-$START))
        local BYTES_PER_SECOND=$(( SIZE / DURATION ))
        local KBPS=$((SIZE/DURATION/1024))
        local MD5=$(md5sum $TMPFILE | awk '{ print $1 }')

        # This function prints out ugly stuff suitable for eval()
        # rather than a pretty string. This makes it a bit more
        # flexible if you have a custom format (or dare I say, locale?)

        printf "\nDURATION=%d\nBYTES=%d\nKBPS=%f\nMD5=%s\n" \
            $DURATION \
            $SIZE \
            $KBPS \
            $MD5
}

   Examples:
echo "wget"
wget -q -O /dev/stdout http://www.blah.com/somefile.zip | progress_filter

echo "tftp"
tftp -l /dev/stdout -g -r something/firmware.bin 192.168.1.1 | progress_filter

echo "scp"
scp user@192.168.1.1:~/myfile.tar /dev/stdout | progress_filter

   [146]share|[147]improve this answer
   answered Oct 10 '14 at 1:03
   [148]synthesizerpatel
   11.1k13254
   add a comment |
   up vote 0 down vote

   for me easiest to use and best looking so far is command pv or bar like some guy already
   wrote

   for example: need to make a backup of entire drive with dd

   normally you use dd if="$input_drive_path" of="$output_file_path"

   with pv you can make it like this :

   dd if="$input_drive_path" | pv | dd of="$output_file_path"

   and the progress goes directly to STDOUT as this:
    7.46GB 0:33:40 [3.78MB/s] [  <=>                                            ]

   after it is done summary comes up
    15654912+0 records in
    15654912+0 records out
    8015314944 bytes (8.0 GB) copied, 2020.49 s, 4.0 MB/s



---
http://bash.cyberciti.biz/guide/A_progress_bar_(gauge_box)

A progress bar (gauge box)

   From Linux Shell Scripting Tutorial - A Beginner's handbook
   Jump to: [5]navigation, [6]search
   [7]← A menu box [8]Home [9]The file selection box →
     * You can create a progress bar (progress indicator) when copying/moving files or making
       backups using the gauge box.
     * It displays a meter along the bottom of the box. The meter indicates the percentage.
       New percentages are read from standard input, one integer per line. The meter is
       updated to reflect each new percentage.
     * If the standard input reads the string "START_BAR", then the first line following is
       taken as an integer percentage, then subsequent lines up to another "START_BAR" are
       used for a new prompt. The gauge exits when EOF is reached on the standard input.
     * The syntax is as follows:

echo percentage | dialog --gauge "text" height width percent
echo "10" | dialog --gauge "Please wait" 10 70 0
echo "50" | dialog --gauge "Please wait" 10 70 0
echo "100" | dialog --gauge "Please wait" 10 70 0
     * However, you need to use the [10]while or [11]for loop to show 0 to 100% progress. In
       this example, the [12]for loop is used to display progress:

for i in $(seq 0 10 100) ; do sleep 1; echo $i | dialog --gauge "Please wait" 10 70 0; done

Example

   Create a shell script dvdcopy.sh:
#!/bin/bash
# dvdcopy.sh - A sample shell script to display a progress bar
# set counter to 0
counter=0
(
# set infinite while loop
while :
do
cat <<EOF
XXX
$counter
Disk copy /dev/dvd to /home/data ( $counter%):
XXX
EOF
# increase counter by 10
(( counter+=10 ))
[ $counter -eq 100 ] && break
# delay it a specified amount of time i.e 1 sec
sleep 1
done
) |
dialog --title "File Copy" --gauge "Please wait" 7 70 0

   Save and close the file. Run it as follows:
chmod +x dvdcopy.sh
./dvdcopy.sh

   Sample outputs:
   A sample progress bar (gauge box)

File Copy Progress Bar With Dialog

     * Create a shell script called pcp.sh:

#!/bin/bash
# pcp.sh: A shell script to copy /bin/* and /etc/* files
#         Display a progress bar while copying files.
# * Based upon Greg's (GreyCat's) GPLd wiki example. *
# --------------------------------------------------------
# Create an array of all files in /etc and /bin directory
DIRS=(/bin/* /etc/*)

# Destination directory
DEST="/tmp/test.$$"

# Create $DEST if does not exits
[ ! -d $DEST ] && mkdir -p $DEST

#
# Show a progress bar
# ---------------------------------
# Redirect dialog commands input using substitution
#
dialog --title "Copy file" --gauge "Copying file..." 10 75 < <(
   # Get total number of files in array
   n=${#DIRS[*]};

   # set counter - it will increase every-time a file is copied to $DEST
   i=0

   #
   # Start the for loop
   #
   # read each file from $DIRS array
   # $f has filename
   for f in "${DIRS[@]}"
   do
      # calculate progress
      PCT=$(( 100*(++i)/n ))

      # update dialog box
cat <<EOF
XXX
$PCT
Copying file "$f"...
XXX
EOF
  # copy file $f to $DEST
  /bin/cp $f ${DEST} &>/dev/null
   done
)

# just delete $DEST directory
/bin/rm -rf $DEST

   Save and close the file. Run it as follows:
chmod +x pcp.sh
./pcp.sh

   Retrieved from
   "[16]http://bash.cyberciti.biz/wiki/index.php?title=A_progress_bar_(gauge_box)&oldid=2871"



---
http://bash.cyberciti.biz/guide/File:Shell-progress-bar.png

File:Shell-progress-bar.png

   Retrieved from
   "[19]http://bash.cyberciti.biz/wiki/index.php?title=File:Shell-progress-bar.png&oldid=1567"

   

---
http://fitnr.com/showing-a-bash-spinner.html

Showing a Bash Spinner for Long Running Tasks

   by Louis Marascio on February 27, 2011

   This post is part of a series: [10]Bash Tips and Tricks.

   I’ve [11]mentioned before that I like to show users of my scripts useful information. This can be a
   complex progress bar, a simple progress meter, or it can be an animation to let the user know the
   script hasn’t hung. These animations are typically called [12]Throbbers are exist purely to tell the
   user to continue patiently waiting. Sometimes folks like me call Throbbers Spinners for two reasons.
   First, a very common throbber animation type is the spinning wheel. Second, the word throbber sounds
   oddly sexual, and sort of creeps me out if I say it too many times in a sentence (Just kidding. Well,
   no, not really.)

   This tip will show you to create a spinner for your Bash scripts. If you have a long running process
   and don’t want to try to tell the user approximately how much of that process is left to run, showing
   them a spinner is a great alternative.

Implementing the Spinner

   The throbber, er I mean spinner, is implemented as a loop that shifts a string during each iteration.
spinner()
{
    local pid=$1
    local delay=0.75
    local spinstr='|/-\'
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
}

   Let’s dissect the spinner function so to illustrate how it works.

local pid=$1
local delay=0.75
local spinstr='|/-\'

   This is pretty self-explanatory. The function has one input argument and two internal variables that
   control how it works.
    1. The input argument is assigned to the local variable pid. This is the process ID of the
       background task for which we are showing the spinner.
    2. The next local variable, delay, is how long each frame of the spinner animation stays visible
       for. We’ve set it to 75% of 1 second or 750ms. A smaller number will make the spinner rotate
       faster while a larger number will make it slower.
    3. The final local variable is called spinstr. This is a string for which each character is a frame
       in our spinner animation. As you can see, the string is 4 characters long, therefore we have four
       frames in our animation.

   Moving along we get to the meat of the function, the primary loop.
while [ "$(ps a | awk '{print $1}' | grep -w $pid)" ]; do

   The loop condition does three things:
    1. ps a will show all processes.
    2. awk '{print $1}' will extract the pid column of the process list.
    3. grep -w $pid will look for the process ID of our background task in the list of PIDs printed by
       awk.

   The loop is conditioned on the return value of grep, the last command in our pipe chain. If grep
   finds a match in our PID list it will return 0, otherwise it will return 1.

   The next several lines do the hard work of displaying our animation. I’ve created two images to help
   illustrate what’s going on.

   First, I remove the first character from the string and save the remaining characters into a temp.
local temp=${spinstr#?}

   Then I use printf to output the first character of spinstr, which contains our animation. Only the
   first character is output because I use the %c format string.
printf " [%c]  " "$spinstr"

   These two steps are illustrated below.

   Bash Spinner Steps 1 and 2

   Finally, I shift spinstr by constructing a new string that contains the value of temp and all
   characters from spinstr that aren’t in temp.
local spinstr=$temp${spinstr%"$temp"}

   The first part of this, the character rotation, appears as step 3 and the last part, the assignment
   to spinstr appears as step 4.

   Bash Spinner Steps 3 and 4

Using the Bash Spinner

   When you have a task to run that will take a large (or unknown) amount of time invoke it in a
   background subshell like this:
(a_long_running_task) &

   Then, immediately following that invocation, call the spinner and pass it the PID of the subshell you
   invoked.
spinner $!

   The $! is a [13]bash internal variable for the PID of the last job run in the background. In this
   case, it will give us the PID of the bash shell executing our long running task.

   When it’s all said and done you’ll have a nice and simple Bash spinner like the one below.

   A Bash Spinner
