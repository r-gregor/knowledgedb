filename: bash_howto-get-directory-script-from-within-script-itself-multif_20201027.txt
https://www.cyberciti.biz/faq/unix-linux-appleosx-bsd-bash-script-find-what-directory-itsstoredin/

Bash Script: Find Out In What Directory Script Is Stored Under Unix Or Linux
December 12, 2012

 find out the path of the directory in which my bash shell script is located and store that
   path in _base variable?
   You need to use the combination of the following:

   [a] readlink - Display value of a symbolic link or canonical file name.
   This is a safe way to get the target of a symbolic link. 
   
   [b] ${BASH_SOURCE[0]} or $0 - The name of
   the shell script file is stored in $0 or ${BASH_SOURCE[0]}

   Please note that the following examples are only tested on the Bash shell running on Debian Linux.
   This code may not be portable and may break on other Linux distributions/Unix like operating systems.

Examples

   Create a shell script as follows:
#!/bin/bash
# Name: /tmp/demo.bash :
# Purpose: Tell in what directory $0 is stored in
# Warning: Not tested for portability
# ------------------------------------------------

## who am i? ##
_script="$(readlink -f ${BASH_SOURCE[0]})"

## Delete last component from $_script ##
_base="$(dirname $_script)"

## Okay, print it ##
echo "Script name : $_script"
echo "Current working dir : $PWD"
echo "Script location path (dir) : $_base"

   Save and close the file. Run it as follows:
$> chmod +x /tmp/demo.bash
$> /tmp/demo.bash

   Sample outputs:
Script name : /tmp/demo.bash
Current working dir : /home/vivek
Script location path (dir) : /tmp

   cd to /home/vivek
$> cd ~
$> /tmp/demo.bash

   Sample outputs:
Script name : /tmp/demo.bash
Current working dir : /home/vivek
Script location path (dir) : /tmp

   Run it as follows:
$> ../../tmp/demo.bash

   Sample outputs:
Script name : /tmp/demo.bash
Current working dir : /home/vivek
Script location path (dir) : /tmp

   Finally, create a symbolic link in /home/vivek and test it:
$> cd ~
$> ln -s /tmp/demo.bash
$> ./demo.bash
$> rm demo.bash

   Sample outputs:
Script name : /tmp/demo.bash
Current working dir : /home/vivek
Script location path (dir) : /tmp


---
https://gist.github.com/TheMengzor/968e5ea87e99d9c41782

BASH Absolute path of current script

DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )

   Is a useful one-liner which will give you the full directory name of the script no matter where it is
   being called from

   These will work as long as the last component of the path used to find the script is not a symlink
   (directory links are OK). If you want to also resolve any links to the script itself, you need a
   multi-line solution:

SOURCE="${BASH_SOURCE[0]}"

while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
	DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
	SOURCE="$(readlink "$SOURCE")"
	[[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"  # if $SOURCE was a relative symlink, we need to resolve it
	# relative to the path where the symlink file was located
done

DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

   This last one will work with any combination of aliases, source, bash -c, symlinks, etc.

   Beware: if you cd to a different directory before running this snippet, the result may be incorrect!
   Also, watch out for $CDPATH gotchas.

   To understand how it works, try running this more verbose form:
#!/bin/bash

SOURCE="${BASH_SOURCE[0]}"

while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
	TARGET="$(readlink "$SOURCE")"
	if [[ $SOURCE == /* ]]; then
		echo "SOURCE '$SOURCE' is an absolute symlink to '$TARGET'"
		SOURCE="$TARGET"
	else
		DIR="$( dirname "$SOURCE" )"
		echo "SOURCE '$SOURCE' is a relative symlink to '$TARGET' (relative to '$DIR')"
		SOURCE="$DIR/$TARGET"   # if $SOURCE was a relative symlink, we need to resolve it relative to the path
								# where the symlink file was located
	fi
done

echo "SOURCE is '$SOURCE'"
RDIR="$( dirname "$SOURCE" )"
DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
if [ "$DIR" != "$RDIR" ]; then
	echo "DIR '$RDIR' resolves to '$DIR'"
fi
echo "DIR is '$DIR'"

   And it will print something like:
SOURCE './scriptdir.sh' is a relative symlink to 'sym2/scriptdir.sh' (relative to '.')
SOURCE is './sym2/scriptdir.sh'
DIR './sym2' resolves to '/home/ubuntu/dotfiles/fo fo/real/real1/real2'
DIR is '/home/ubuntu/dotfiles/fo fo/real/real1/real2'


---
https://codefather.tech/blog/bash-get-script-directory/

How to Get the Directory of a Bash Script
March 5, 2020

   Have you ever tried to get the directory of your Bash script programmatically?

   It's a common thing people ask and it can be done in different ways.

   The first thing to look at to solve this problem is the $0 variable, used in Bash to store the first
   element of the command executed.

   Create a script called get_script_dir.sh in the directory /opt/scripts/:

#!/bin/bash

echo "$0"

   If we execute it:
     * From the script directory (/opt/scripts/)
     * Using the relative path from the parent directory /opt
     * Using the absolute path of the script

   We get the following:
1) From script directory: /opt/scripts
[ec2-user@ip-172-12-20-120 ~]$ ./test.sh
./test.sh

2) Relative path from parent directory: /opt
[ec2-user@ip-172-12-20-120 opt]$ scripts/get_script_dir.sh
scripts/get_script_dir.sh

3) Absolute path
[ec2-user@ip-172-12-20-120 ~]$ /opt/scripts/get_script_dir.sh
/opt/scripts/get_script_dir.sh

   So this is not enough because only in the scenario 3) we get the full path for the script.

   First of all, to find a solution we need to introduce the dirname command that strips the last
   component from a file name. We update our script to add dirname $0:
#!/bin/bash

echo "$0"
dirname "$0"

   And here is the output of the script in the three scenarios shown before:
1) From script directory: /opt/scripts
[ec2-user@ip-172-12-20-120 scripts]$ ./get_script_dir.sh
./get_script_dir.sh
.

2) Relative path from parent directory: /opt
[ec2-user@ip-172-12-20-120 scripts]$ cd ..
[ec2-user@ip-172-12-20-120 opt]$ scripts/get_script_dir.sh
scripts/get_script_dir.sh
scripts

3) Absolute path
[ec2-user@ip-172-12-20-120 opt]$ /opt/scripts/get_script_dir.sh
/opt/scripts/get_script_dir.sh
/opt/scripts

   So the dirname allows, in scenario 3), to get the directory of the script.

   Obviously this approach doesn't work well, we want a command that gives back the full path of the
   script when it's executed from any directory (script directory, relative path and absolute path).

   Let's also test how $0 behaves with the source command, very common in Bash scripting to execute the
   lines in a script:
[ec2-user@ip-172-12-20-120 scripts]$ source get_script_dir.sh
-bash

   This time we don't get the path of the script back but just -bash.

   This doesn't work in the way we want, we need to find an alternative.

The BASH_SOURCE array
   The $BASH_SOURCE array represents an alternative to $0 that is a lot more robust.

   I don't want to get into too many details about $BASH_SOURCE that can be quite confusing at this
   stage.

   The only thing that matters right now is that $BASH_SOURCE always contains the name and path of the
   script executed. As we have seen before this is true for $0 only when the script is not sourced
   (using the source command).

   With $BASH_SOURCE our script becomes:
#!/bin/bash

echo "${BASH_SOURCE[0]}"
dirname "${BASH_SOURCE[0]}"

   Where ${BASH_SOURCE[0]} is the first element of the BASH_SOURCE array.

   Let's see how it behaves in the three scenarios we have analysed before:
1) From script directory: /opt/scripts
[ec2-user@ip-172-12-20-120 scripts]$ ./get_script_dir.sh
./get_script_dir.sh
.

2) Relative path from parent directory: /opt
[ec2-user@ip-172-12-20-120 scripts]$ cd ..
[ec2-user@ip-172-12-20-120 opt]$ scripts/get_script_dir.sh
scripts/get_script_dir.sh
scripts

3) Absolute path
[ec2-user@ip-172-12-20-120 opt]$ /opt/scripts/get_script_dir.sh
/opt/scripts/get_script_dir.sh
/opt/scripts

   So there are no changes compared to $0 ... so what's the point of using BASH_SOURCE?

   What happens if we source our script in the same way we have done before?
[ec2-user@ip-172-12-20-120 scripts]$ source get_script_dir.sh
get_script_dir.sh
.

   That's great!

   This time we get the correct output instead of -bash (see example in the previous section using
   source and $0).

A One Liner to Get the Script Directory
   Now that we know that it's better to use the $BASH_SOURCE variable we want to come up with a generic
   way to get the directory of the script...

   ...no matter the location the script is executed from.

   We can use the following approach:
    1. Get the script directory (relative to the current directory)
    2. cd into the directory
    3. Use pwd to get the absolute path

   A script that follows the three steps above would look like:
#!/bin/bash

# Step 1
SCRIPT_RELATIVE_DIR=$(dirname "${BASH_SOURCE[0]}")

# Step 2
cd $SCRIPT_RELATIVE_DIR

# Step 3
pwd

   And now let's go through the three scenarios we have seen before:
1) From script directory: /opt/scripts
[ec2-user@ip-172-12-20-120 scripts]$ ./get_script_dir.sh
/opt/scripts

2) Relative path from parent directory: /opt
[ec2-user@ip-172-12-20-120 scripts]$ cd ..
[ec2-user@ip-172-12-20-120 opt]$ scripts/get_script_dir.sh
/opt/scripts

3) Absolute path
[ec2-user@ip-172-12-20-120 opt]$ /opt/scripts/get_script_dir.sh
/opt/scripts/get_script_dir.sh
/opt/scripts

   Finally something that works well...

   It doesn't work if every scenario (e.g. with symlinks) but it's enough to cover most use cases.
   Now we want to create a one liner to put the three steps together:
Step 1 + Step 2
cd $(dirname "${BASH_SOURCE[0]}")

Step 1 + Step 2 + Step 3
cd $(dirname "${BASH_SOURCE[0]}") && pwd

   And to store this directory into a variable called SCRIPT_DIR we use:
SCRIPT_DIR=$(cd $(dirname "${BASH_SOURCE[0]}") && pwd)

   The pwd command is executed only if cd $(dirname "${BASH_SOURCE[0]}") is successful.
   How do we do that? Using &&.
   Then you can use the echo command to print the value of $SCRIPT_DIR.

Conclusion
   I thought getting the directory of a Bash script would be super simple!
   As we have seen in this article it's not the case...
   Now you know how to use $0 and $BASH_SOURCE.
   Also how to run a command if the execution of the previous command is successful using &&.

   I hope you have found this useful...


---
https://www.xspdf.com/resolution/50635459.html

Shell get script directory
   Unix shell script find out which directory the , In Bash, you should get what you need like this:
   #!/usr/bin/env bash BASEDIR=$(dirname "$0") echo "$BASEDIR". Getting the source directory of a
   Bash script from within. And it is: DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )" One-liner
   which will give you the full directory name of the script no matter where it is being called from. To
   understand how it works you can execute the following script:

   How to get script name, script path within the bash script in Linux, Get script full path, bash get
   script directory, bash get script path, bash get script name, shell get script nameÂ  You can use
   shell variable called PWD or pwd built-in command to get the current working directory. The cd
   command sets the following shell variable: [a] OLDPWD The previous working directory as set by the cd
   command. [b] PWD The current working directory as set by the cd command. [c] pwd command â€" Print
   the name of the current working directory.

   Linux / Unix: Shell Script Find Out In Which Directory Script File , Examples: Shell script find out
   which directory the script file resides. In bash script use $0 instead of
   /home/nixcraft/scripts/foo.sh: #!/bin/bash script="$0" basename="$(dirname $script)" echo "Script
   name $script resides in $basename directory." Get the Current Script Directory in PowerShell,
   VBScript and Batch Overview. This post shows how to quickly get the current script directory using
   PowerShell, VBScript and Batch â€" the Windows Batch. Windows batch is the trickiest in some ways â€"
   it also is the one that cannot support UNC

Bash get parent directory of script
   Retrieve parent directory of script, the ultimate simple way of getting the parent directory path: cd
   "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"; # parent dir of that dirÂ  In bash, $0 stores the
   first element of the executed command: Given that, a valid strategy to get the script directory may
   be something like: Get directory component of $0 (using dirname ). Change directory into #1 (using cd
   ). Get full path of current directory (using pwd ).

   command line, Here's another way to do it: cd "$(dirname "$0")" /bin/pwd. /bin/pwd prints the real
   path of the directory, as opposed to the pwd builtin command. Hi, Edit: The title should really read
   listing files in a non-parent directory, sorry! Im trying to get one of my Bash scripting assignments
   done for uni and now I'm stuck. This is probably going to be one of those kick yourself moments but,
   in my script I have a variable usrDir which (2 Replies)

   Get the parent directory for a file, edit: Sorry, nested expansion isn't possible in bash, but it
   works in zsh. Bash-version: $ filepath=/a/b/c/d/file $ path=${filepath%/*} $ echo ${path##*/} d.
   In this article, we will review a simple but helpful utility for quickly moving back into a parent
   directory in Linux with the help of bd tool. bd is a handy utility for navigating the filesystem, it
   enables you to quickly go back to a parent directory without typing cd ../../.. repeatedly.

Bash get current directory
   How can I get the current working directory?, used symbolic links to get the the current directory,
   pwd will give different results than /usr/bin/pwd. Since you are using bash, I would use:
   dir=$(/usr/bin/pwd). For example if we change the directory to /home/user, pwd will print
   /home/user as the current working directory: $ cd /home/user. $ pwd. /home/user. In Bash shell script
   you can get the current working directory by: dir=$ (PWD) pwd command . pwd command. ls command.

   Bash Commands to Manage Directories and Files, the same folders that we do in the Finder window. How
   do I get the current working directory under Bash or Ksh shell running on Linux or Unix like
   operating systems? You can use shell variable called PWD or pwd built-in command to get the current
   working directory. The cd command sets the following shell variable: [a] OLDPWD The previous working
   directory as set by the cd command.

   Determining Your Current Directory with pwd, No need for basename, and especially no need for a
   subshell running pwd (which adds an extra, and expensive, fork operation); the shell canÂ  Below
   is the answer for this question. There is a very simple way to get the directory from a batch script
   file. CD environment variable stores the current directory of a command window session.

Bash get path to script location
   Reliable way for a Bash script to get the full path to itself, But the result can still have relative
   bits in it (although overall it's absolute) - for instance, if the script is t in the directory
   /usr/bin and you're in /usr and you type bin/  Get script name in shell script. Use the below
   variable within the script to get the script name from within the shell script. #!/bin/bash
   script_name1=`basename $0` script_name2=`basename "$ (realpath $0)"` echo $script_name1 echo
   $script_name2. Let us execute the script.

   Bash: get absolute path to current script, Luckily there is a command called realpath that will
   calculate and print the absolute path of a given path. $0 is the name of the current script as it was
   executed. So if we run the script as ./examples/shell/absolute.sh then that will be the content of
   $0. realpath prints the abosulte path. Bash script may need to get its own path. In normal Bash
   script, $0 is the path to the script. However, when a script is sourced, such as . a.sh, a.shâ€˜s $0
   does not give a.sh while the callerâ€™s name. How to reliably get a bash scriptâ€™s own path no
   matter whether the Bash script is executed or sourced is introduced in this post.

   When writing a bash script, how do I get the absolute path of the , bash ) inside the script. Is
   there a command I can use to find this location? Edit: The idea is that I want to set-up a zip-folder
   withÂ  There can be many reasons why you'd want to get the exact location of your currently running
   script. For example to calculate the relative path in a reliable way.. Luckily there is a command
   called realpath that will calculate and print the absolute path of a given path.

Bash_source
   choosing between $0 and BASH_SOURCE, Bash maintains a number of variables including BASH_SOURCE which
   is an array of source file pathnames. ${} acts as a kind of quoting for variables. BASH_SOURCE An
   array variable whose members are the source filenames where the corresponding shell function names in
   the FUNCNAME array variable are defined. The shell function ${FUNCNAME[$i]} is defined in the file
   ${BASH_SOURCE[$i]} and called from ${BASH_SOURCE[$i+1]}

   DIR="$( cd "$( dirname "${BASH_SOURCE[0 , BASH_SOURCE. An array variable whose members are the source
   filenames where the corresponding shell function names in the FUNCNAME array variableÂ  The source
   command reads and executes commands from the file specified as its argument in the current shell
   environment. It is useful to load functions, variables, and configuration files into shell scripts.
   source is a shell built-in in Bash and other popular shells used in Linux and UNIX operating systems.

   Bash Variables (Bash Reference Manual), Spoiler a 'good enough' middle ground that I often
   use is "$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )" , as long as I know thatÂ  Bash source
   builtin command Updated: 05/04/2019 by Computer Hope On Unix-like operating systems, source is a
   builtin command of the Bash shell. It takes a file name, and executes the commands in that file as if
   they had been typed on the command line.

Bash get absolute path
   bash/fish command to print absolute path to a file, This relative path to absolute path converter
   shell function You can simplify it if you will only get a few results (e.g. directory near bottom of
   tree containing fewÂ  When it is in a symbolic link in a directory, it is generally intended to be
   relative to that directory (though the user may have other uses in mind). Hence an absolute path is
   just a path relative to the root directory. A path (absolute or relative) may or may not contain
   symbolic links.

   How to get the full path of a file in bash?, On linux systems, you should have readlink from the GNU
   coreutils project installed and can do this: readlink -f file.ext. Debian/ubuntu systems may have
   theÂ  As above image shows, readlink command tells that /etc/samba/smb.conf is the Absolute Path
   of the smb.conf file. Get the Path of a Symbolic Link. Linux readlink command can be also used to
   find where a symlink is pointing to.

   Bash: get absolute path to current script, Luckily there is a command called realpath that will
   calculate and print the absolute path of a given path. Let's see how it works:
   examples/shell/absolute.sh. In Linux and Unix systems, commands are executable files. The commands
   may be specific with user environment.We can set the absolute path of specific command as per user in
   environment.If we require the information, to get the absolute path of command. In that case we will
   use which command.

Bash script path
   Determine the path of the executing BASH script, For the relative path (i.e. the direct equivalent of
   Windows' %~dp0 ): MY_PATH="`dirname \"$0\"`" echo "$MY_PATH". For the absoluteÂ  Get script full
   path, bash get script directory, bash get script path, bash get script name, shell get script name
   from inside the script, shell script get absolute path, Linux find script location. In my last script
   I shared the steps to run shell scripts in parallel and collect their individual exit status .

   Reliable way for a Bash script to get the full path to itself, Here's what I've come up with (edit:
   plus some tweaks provided by sfstewman, levigroker, Kyle Strand, and Rob Kennedy), that seems to
   mostly fit my "better"  Bash script may need to get its own path. In normal Bash script, $0 is the
   path to the script. However, when a script is sourced, such as . a.sh , a.sh â€˜s $0 does not give
   a.sh while the caller's name.

   How to get script name, script path within the bash script in Linux, Get script name in shell script,
   bash get script path shell, bash get script name, shell get script name from inside the script, Linux
   find scriptÂ  Can a Bash script tell what directory it's stored in? In a Windows command script, one
   can determine the directory path of the currently executing script using %~dp0. For example: @echo
   Running from %~dp0 What would be the equivalent in a BASH script?

Bash get directory of file
   Extract directory from path, In my script I need the directory of the file I am working with. For
   example, the file="stuff/backup/file.zip". I need a way to get the string "stuff/backup/Â  Bash
   Get Basename of Filename or Directory Name. To extract filename and extension in Bash use any one of
   the following method: basename /path/to/file.tar.gz .gz â€" Strip directory and suffix from filenames
   ${VAR%pattern} â€" Remove file extension ${VAR#pattern} â€" Delete from shortest front pattern

   Get file directory path from file path, In Bash, if VAR="/home/me/mydir/file.c" , how do I get
   "/home/me/mydir" ? share. To use a block size of one byte, use the following command to get the exact
   sizes of the directories and files: du --block=1. If you want to use a block size of one megabyte,
   you can use the -m (megabyte) option, which is the same as --block=1M: du -m.

   Which directory is that bash script in?, A BASH script makes the first command line argument
   available as $1, the Note that the directory and/or file do not actually exists; dirname simply
   strips the last to the directory the script is located, change to the scripts directory and get theÂ
   Bash get filename from given path on Linux or Unix; Linux / Unix: Shell Script Find Out In Which
   Directory Script File Resides; How to find and delete directory recursively on Linux or Unix-like
   system; How do I force delete a directory in Linux? What does rm -rf command do on a Linux or Unix;
   HowTo: Unpack .tgz File On a Linux


---
filename: bash_howto-get-directory-script-from-within-script-itself-multif_20201027.txt
https://stackoverflow.com/questions/4774054/reliable-way-for-a-bash-script-to-get-the-full-path-to-itself

Reliable way for a Bash script to get the full path to itself [duplicate]

   I have a Bash script that needs to know its full path. I'm trying to find a broadly-compatible way of
   doing that without ending up with relative or funky-looking paths. I only need to support Bash, not
   sh, csh, etc.

   What I've found so far:
    1. The accepted answer to Getting the source directory of a Bash script from within addresses
       getting the path of the script via dirname $0, which is fine, but that may return a relative path
       (like .), which is a problem if you want to change directories in the script and have the path
       still point to the script's directory. Still, dirname will be part of the puzzle.
    2. The accepted answer to Bash script absolute path with OS X (OS X specific, but the answer
       works regardless) gives a function that will test to see if $0 looks relative and if so will
       pre-pend $PWD to it. But the result can still have relative bits in it (although overall it's
       absolute) - for instance, if the script is t in the directory /usr/bin and you're in /usr and you
       type bin/../bin/t to run it (yes, that's convoluted), you end up with /usr/bin/../bin as the
       script's directory path. Which works, but...
    3. The readlink solution on this page, which looks like this:
# Absolute path to this script. /home/user/bin/foo.sh
SCRIPT=$(readlink -f $0)
# Absolute path this script is in. /home/user/bin
SCRIPTPATH=`dirname $SCRIPT`

       But readlink isn't POSIX and apparently the solution relies on GNU's readlink where BSD's won't
       work for some reason (I don't have access to a BSD-like system to check).

   So, various ways of doing it, but they all have their caveats.

   What would be a better way? Where "better" means:
     * Gives me the absolute path.
     * Takes out funky bits even when invoked in a convoluted way (see comment on #2 above). (E.g., at
       least moderately canonicalizes the path.)
     * Relies only on Bash-isms or things that are almost certain to be on most popular flavors of *nix
       systems (GNU/Linux, BSD and BSD-like systems like OS X, etc.).
     * Avoids calling external programs if possible (e.g., prefers Bash built-ins).
     * (Updated, thanks for the heads up, wich) It doesn't have to resolve symlinks (in fact, I'd
       kind of prefer it left them alone, but that's not a requirement).

***
   Here's what I've come up with, that seems to mostly fit my "better" criteria:
SCRIPTPATH="$( cd "$(dirname "$0")" >/dev/null 2>&1 ; pwd -P )"

   That SCRIPTPATH line seems particularly roundabout, but we need it rather than SCRIPTPATH=`pwd` in
   order to properly handle spaces and symlinks.

   The inclusion of output redirection (>/dev/null 2>&1) handles the rare(?) case where cd might produce
   output that would interfere with the surrounding $( ... ) capture. (Such as cd being overridden
   to also ls a directory after switching to it.)

   Note also that esoteric situations, such as executing a script that isn't coming from a file in an
   accessible file system at all (which is perfectly possible), is not catered to there (or in any of
   the other answers I've seen).

***
       This does not work if the script is in a directory from the $PATH and you call it bash
       scriptname. In such a case $0 does not contain any path, just scriptname.
     * I agree with @pabouk, I am launching my shell script from Python and this SCRIPTPATH="$( cd
       "$(dirname "$0")" ; pwd -P )" is returning me nothing
     * 3
       -1 (please don't take it personnaly, it is just so that the real answer cat maybe get closer to
       the top): I used to do a similar thing (I used: "$(cd -P "$(dirname "$0")" && pwd)" until today,
       but Andrew Norrie's answer covers more cases (ie : PATH="/some/path:$PATH" ; bash
       "script_in_path" : will only work with his answer, not with yours (as $0 contains only
       "script_in_path" and no indication of where (in $PATH) bash found it). correct is :
       ABSOLUTE_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"
       (ie, @andrew-norrie 's answer: covers all cases, imo)
     * 6
       I would prefer if you used dirname "${BASH_SOURCE[0]}" rather than dirname "$0" for added support
       for sourced scripts.

***
   I'm surprised that the realpath command hasn't been mentioned here. My understanding is that it is
   widely portable / ported.

   Your initial solution becomes:
SCRIPT=`realpath $0`
SCRIPTPATH=`dirname $SCRIPT`

   And to leave symbolic links unresolved per your preference:
SCRIPT=`realpath -s $0`
SCRIPTPATH=`dirname $SCRIPT`

***
       @bolinfest: realpath is part of GNU coreutils since Jan 2012 / v8.15. If you're running a
       recent Linux distro that includes coreutils (which should be basically all of them) and realpath
       is missing, the packagers have certainly gone out of their way to separate realpath into another
       package. (current coreutils version is 8.21, released 2013-02-04. The version I am running (on
       Arch Linux) appears to be this one, 8.21, and the package includes realpath, as any
       right-thinking package would ;)
     * 11
       Using realpath, and even shorter: SCRIPT_PATH=$(dirname $(realpath -s $0))
     * 1
       It is also an extra package on Debian Wheezy. The coreutils version is 8.13 and does not include
       it yet.
     * 5
       realpath is not mentioned in the POSIX standard.
     * 12
       Many if not most of these answers are buggy when given filenames with whitespace.
       SCRIPT_PATH=$(dirname "$(realpath -s "$0")") is a fixed version of GuySoft's answer, though using
       $BASH_SOURCE would be more reliable still than $0 (and this depends on having realpath, a
       non-POSIX tool, installed).

***
   The simplest way that I have found to get a full canonical path in Bash is to use cd and pwd:
ABSOLUTE_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

   Using ${BASH_SOURCE[0]} instead of $0 produces the same behavior regardless of whether the script is
   invoked as <name> or source <name>.

***
       This doesn't seem to work if the originally-specified file is a symlink. I think you need to use
       something like readlink (or ls) in a loop, to make sure you've found a final non-symlink file.
       I've been on the lookout for something more concise, but in any case you can find the last
       version of the solution I used in the Android codebase, under dalvik/dx/etc/dx.
     * @danfuzz see Dennis Williamson comment, regarding using -P for pwd. It should do what you want.
     * 6
       @over_optimistic I'm not convinced that -P helps here: If $0 names a symlink, then cd $(dirname
       $0); pwd -P still just tells you what directory the symlink is in and not the physical directory
       where the actual script resides. You really need to use something like readlink on the script
       name, except that readlink is not actually POSIX and it does seem to vary in practice between
       OSes.
     * @danfuzz: linux.die.net/man/8/symlinks looks like a good thing to use, to both have "cleaner"
       symlinks, and find their full path equivalent
     * 7
       +1 works nicely in all reasonable scenarios on a mac. No external dependencies and executes in 1
       line. I use it to get the script's directory like so: SCRIPTPATH=$(cd `dirname
       "${BASH_SOURCE[0]}"` && pwd)

***
   I just had to revisit this issue today and found Get the source directory of a Bash script from
   within the script itself:
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

   There's more variants at the linked answer, e.g. for the case where the script itself is a symlink.

***
       I just found out that the above does not work when the script is straight out executed rather
       than sourced: stackoverflow.com/questions/27880087/...

***
   Use:
SCRIPT_PATH=$(dirname `which $0`)

   which prints to standard output the full path of the executable that would have been executed when
   the passed argument had been entered at the shell prompt (which is what $0 contains)

   dirname strips the non-directory suffix from a file name.

   Hence you end up with the full path of the script, no matter if the path was specified or not.

***
       Simple, and that works for me. Nice solution.
     * 7
       dirname ./myscript returns .. This might not be what you want.
     * @BobbyNorton Yes because the non-directory suffix at that point is simply .. However, if you run
       which on the script name and store it in a variable, such as a=$(which ./myscript), it will
       return the full path, such as /tmp/myscript, which if passed to dirname will return the path.
       Interestingly if you run which ./myscript and not assign it to a variable, it simply returns
       ./myscript. I suspect this is because when assigning it to a variable it executes in another
       shell and passes the complete path to bash at that time.
     * 3
       Unfortunately, this doesn't appear to work on OS X. It would be a nice solution if it did!
     * 2
       @Matt I would not use the 'which' command unless the command is in the current path. Which only
       searches for the command in the path. If your script is not in the path it will never be found.

***
Get the absolute path of a shell script

   It does not use the -f option in readlink, and it should therefore work on BSD/Mac OS X.

Supports
     * source ./script (When called by the . dot operator)
     * Absolute path /path/to/script
     * Relative path like ./script
     * /path/dir1/../dir2/dir3/../script
     * When called from symlink
     * When symlink is nested eg) foo->dir1/dir2/bar bar->./../doe doe->script
     * When caller changes the scripts name

   I am looking for corner cases where this code does not work. Please let me know.


<code>
pushd . > /dev/null
SCRIPT_PATH="${BASH_SOURCE[0]}";
while([ -h "${SCRIPT_PATH}" ]); do
    cd "`dirname "${SCRIPT_PATH}"`"
    SCRIPT_PATH="$(readlink "`basename "${SCRIPT_PATH}"`")";
done
cd "`dirname "${SCRIPT_PATH}"`" > /dev/null
SCRIPT_PATH="`pwd`";
popd  > /dev/null
echo "srcipt=[${SCRIPT_PATH}]"
echo "pwd   =[`pwd`]"
</code>

Known issus
   The script must be on disk somewhere. Let it be over a network. If you try to run this script from a
   PIPE it will not work
wget -o /dev/null -O - http://host.domain/dir/script.sh |bash

   Technically speaking, it is undefined. Practically speaking, there is no sane way to detect this. (A
   co-process can not access the environment of the parent.)

***
       As stated elsewhere, and it's not quite an edge case I think, but readlink -f is not a standard
       parameter and very well not be available, e.g. on my BSD.
     * I ran into a corner case where this didn't work. I had a script under ~/scripts/myscript and a
       symlink at ~/bin/myscript which pointed to ../scripts/myscript. Running ~/bin/myscript from ~/
       caused it to think the script's location was ~/. The solution here worked fine, which looks
       pretty similar to your solution

***
   As realpath is not installed per default on my Linux system, the following works for me:
SCRIPT="$(readlink --canonicalize-existing "$0")"
SCRIPTPATH="$(dirname "$SCRIPT")"

   $SCRIPT will contain the real file path to the script and $SCRIPTPATH the real path of the directory
   containing the script.

***
       The OP already noted this solution and disregarded it for not being POSIX -- but this is nice and
       tidy for GNU-based systems at least. The key feature of this is that it resolves symbolic links.

***
   Easy to read? Below is an alternative. It ignores symlinks
#!/bin/bash
currentDir=$(
  cd $(dirname "$0")
  pwd
)

echo -n "current "
pwd
echo script $currentDir

   Since I posted the above answer a couple years ago, I've evolved my practice to using this linux
   specific paradigm, which properly handles symlinks:
ORIGIN=$(dirname $(readlink -f $0))

***
   Simply:
BASEDIR=$(readlink -f $0 | xargs dirname)

***
   You may try to define the following variable:
CWD="$(cd -P -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd -P)"

   Or you can try the following function in Bash:
realpath () {
  [[ $1 = /* ]] && echo "$1" || echo "$PWD/${1#./}"
}

   This function takes one argument. If the argument already has an absolute path, print it as it is,
   otherwise print $PWD variable + filename argument (without ./ prefix).

***
   Answering this question very late, but I use:
SCRIPT=$( readlink -m $( type -p $0 ))      # Full path to script
BASE_DIR=`dirname ${SCRIPT}`                # Directory script is run in
NAME=`basename ${SCRIPT}`                   # Actual name of script even if linked

     * The full path provided is exactly what I was looking for. Compact, efficient, reliable. Well
       done!
     * Not all implementation of readlink have -m I believe the OP is looking for a solution that does
       not depend on GNU readlink extended functionality.
     * 1
       I've just tried a lot of these solutions, and this and @GreenFox 's answer are the only ones that
       work, when I have a symlink to the script in PATH, and call it like "bash -e my_script"

***
   We have placed our own product realpath-lib on GitHub for free and unencumbered community use.

   Shameless plug but with this Bash library you can:
get_realpath <absolute|relative|symlink|local file>

   This function is the core of the library:

<code>
function get_realpath() {

    if [[ -f "$1" ]]
    then
        # file *must* exist
        if cd "$(echo "${1%/*}")" &>/dev/null
        then
            # file *may* not be local
            # exception is ./file.ext
            # try 'cd .; cd -;' *works!*
            local tmppwd="$PWD"
            cd - &>/dev/null
        else
            # file *must* be local
            local tmppwd="$PWD"
        fi
    else
        # file *cannot* exist
        return 1 # failure
    fi

    # reassemble realpath
    echo "$tmppwd"/"${1##*/}"
    return 0 # success
}
</code>

   It doesn't require any external dependencies, just Bash 4+. Also contains functions to get_dirname,
   get_filename, get_stemname and [DEL: validate_path :DEL] validate_realpath. It's free, clean, simple
   and well documented, so it can be used for learning purposes too, and no doubt can be improved. Try
   it across platforms.

   Update: After some review and testing we have replaced the above function with something that
   achieves the same result (without using dirname, only pure Bash) but with better efficiency:

<code> # 5+
function get_realpath() {
    [[ ! -f "$1" ]] && return 1 # failure : file does not exist.
    [[ -n "$no_symlinks" ]] && local pwdp='pwd -P' || local pwdp='pwd' # do symlinks.
    echo "$( cd "$( echo "${1%/*}" )" 2>/dev/null; $pwdp )"/"${1##*/}" # echo result.
    return 0 # success
}
</code>

   This also includes an environment setting no_symlinks that provides the ability to resolve symlinks
   to the physical system. By default it keeps symlinks intact.

***
   Bourne shell (sh) compliant way:
SCRIPT_HOME=`dirname $0 | while read a; do cd $a && pwd && break; done`

***
   Considering this issue again: there is a very popular solution that is referenced within this thread
   that has its origin here:
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

   I have stayed away from this solution because of the use of dirname - it can present cross-platform
   difficulties, particularly if a script needs to be locked down for security reasons. But as a pure
   Bash alternative, how about using:
DIR="$( cd "$( echo "${BASH_SOURCE[0]%/*}" )" && pwd )"

***
   If we use Bash I believe this is the most convenient way as it doesn't require calls to any external
   commands:
THIS_PATH="${BASH_SOURCE[0]}";
THIS_DIR=$(dirname $THIS_PATH)

***
   The accepted solution has the inconvenient (for me) to not be "source-able":
   if you call it from a "source ../../yourScript", $0 would be "bash"!

   The following function (for bash >= 3.0) gives me the right path, however the script might be called
   (directly or through source, with an absolute or a relative path):
   (by "right path", I mean the full absolute path of the script being called, even when called from
   another path, directly or with "source")

<code>
#!/bin/bash
echo $0 executed

function bashscriptpath() {
  local _sp=$1
  local ascript="$0"
  local asp="$(dirname $0)"
  #echo "b1 asp '$asp', b1 ascript '$ascript'"
  if [[ "$asp" == "." && "$ascript" != "bash" && "$ascript" != "./.bashrc" ]] ; then asp="${BASH_SOURCE[0]%/*}
"
  elif [[ "$asp" == "." && "$ascript" == "./.bashrc" ]] ; then asp=$(pwd)
  else
    if [[ "$ascript" == "bash" ]] ; then
      ascript=${BASH_SOURCE[0]}
      asp="$(dirname $ascript)"
    fi
    #echo "b2 asp '$asp', b2 ascript '$ascript'"
    if [[ "${ascript#/}" != "$ascript" ]]; then asp=$asp ;
    elif [[ "${ascript#../}" != "$ascript" ]]; then
      asp=$(pwd)
      while [[ "${ascript#../}" != "$ascript" ]]; do
        asp=${asp%/*}
        ascript=${ascript#../}
      done
    elif [[ "${ascript#*/}" != "$ascript" ]];  then
      if [[ "$asp" == "." ]] ; then asp=$(pwd) ; else asp="$(pwd)/${asp}"; fi
    fi
  fi
  eval $_sp="'$asp'"
}

bashscriptpath H
export H=${H}
</code>

   The key is to detect the "source" case and to use ${BASH_SOURCE[0]} to get back the actual script.

***
   Try this:
cd $(dirname $([ -L $0 ] && readlink -f $0 || echo $0))

***
   Just for the hell of it I've done a bit of hacking on a script that does things purely textually,
   purely in Bash. I hope I caught all the edge cases.

   Note that the ${var//pat/repl} that I mentioned in the other answer doesn't work since you can't make
   it replace only the shortest possible match, which is a problem for replacing /foo/../ as e.g. /*/../
   will take everything before it, not just a single entry. And since these patterns aren't really
   regexes I don't see how that can be made to work. So here's the nicely convoluted solution I came up
   with, enjoy. ;)

   By the way, let me know if you find any unhandled edge cases.

<code>
#!/bin/bash

canonicalize_path() {
  local path="$1"
  OIFS="$IFS"
  IFS=$'/'
  read -a parts < <(echo "$path")
  IFS="$OIFS"

  local i=${#parts[@]}
  local j=0
  local back=0
  local -a rev_canon
  while (($i > 0)); do
    ((i--))
    case "${parts[$i]}" in
      ""|.) ;;
      ..) ((back++));;
      *) if (($back > 0)); then
           ((back--))
         else
           rev_canon[j]="${parts[$i]}"
           ((j++))
         fi;;
    esac
  done
  while (($j > 0)); do
    ((j--))
    echo -n "/${rev_canon[$j]}"
  done
  echo
}

canonicalize_path "/.././..////../foo/./bar//foo/bar/.././bar/../foo/bar/./../..//../foo///bar/"
</code>

***
   I have used the following approach successfully for a while (not on OS X though), and it only uses a
   shell built-in and handles the 'source foobar.sh' case as far as I have seen.

   One issue with the (hastily put together) example code below is that the function uses $PWD which may
   or may not be correct at the time of the function call. So that needs to be handled.

<code>
#!/bin/bash

function canonical_path() {
    # Handle relative vs absolute path
    [ ${1:0:1} == '/' ] && x=$1 || x=$PWD/$1
    # Change to dirname of x
    cd ${x%/*}
    # Combine new pwd with basename of x
    echo $(pwd -P)/${x##*/}
    cd $OLDPWD
}

echo $(canonical_path "${BASH_SOURCE[0]}")
</code>

type [
type cd
type echo
type pwd

***
   Yet another way to do this:
shopt -s extglob

selfpath=$0
selfdir=${selfpath%%+([!/])}

while [[ -L "$selfpath" ]];do
  selfpath=$(readlink "$selfpath")
  if [[ ! "$selfpath" =~ ^/ ]];then
    selfpath=${selfdir}${selfpath}
  fi
  selfdir=${selfpath%%+([!/])}
done

echo $selfpath $selfdir

***
   More simply, this is what works for me:
MY_DIR=`dirname $0`
source $MY_DIR/_inc_db.sh


---
https://stackoverflow.com/questions/59895/how-to-get-the-source-directory-of-a-bash-script-from-within-the-script-itself

How to get the source directory of a Bash script from within the script itself?

   How do I get the path of the directory in which a Bash script is located, inside that script?

   I want to use a Bash script as a launcher for another application. I want to change the working
   directory to the one where the Bash script is located, so I can operate on the files in that
   directory, like so:
$ ./application

***
#!/bin/bash

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

   is a useful one-liner which will give you the full directory name of the script no matter where it is
   being called from.

   It will work as long as the last component of the path used to find the script is not a symlink
   (directory links are OK). If you also want to resolve any links to the script itself, you need a
   multi-line solution:

<code>
#!/bin/bash

SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it rela
tive to the path where the symlink file was located
done
DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
</code>

   This last one will work with any combination of aliases, source, bash -c, symlinks, etc.

   Beware: if you cd to a different directory before running this snippet, the result may be incorrect!

   Also, watch out for $CDPATH gotchas, and stderr output side effects if the user has smartly
   overridden cd to redirect output to stderr instead (including escape sequences, such as when calling
   update_terminal_cwd >&2 on Mac). Adding >/dev/null 2>&1 at the end of your cd command will take care
   of both possibilities.

   To understand how it works, try running this more verbose form:

<code>
#!/bin/bash

SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  TARGET="$(readlink "$SOURCE")"
  if [[ $TARGET == /* ]]; then
    echo "SOURCE '$SOURCE' is an absolute symlink to '$TARGET'"
    SOURCE="$TARGET"
  else
    DIR="$( dirname "$SOURCE" )"
    echo "SOURCE '$SOURCE' is a relative symlink to '$TARGET' (relative to '$DIR')"
    SOURCE="$DIR/$TARGET" # if $SOURCE was a relative symlink, we need to resolve it relative to the path wher
e the symlink file was located
  fi
done
echo "SOURCE is '$SOURCE'"
RDIR="$( dirname "$SOURCE" )"
DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
if [ "$DIR" != "$RDIR" ]; then
  echo "DIR '$RDIR' resolves to '$DIR'"
fi
echo "DIR is '$DIR'"
</code>

   And it will print something like:
SOURCE './scriptdir.sh' is a relative symlink to 'sym2/scriptdir.sh' (relative to '.')
SOURCE is './sym2/scriptdir.sh'
DIR './sym2' resolves to '/home/ubuntu/dotfiles/fo fo/real/real1/real2'
DIR is '/home/ubuntu/dotfiles/fo fo/real/real1/real2'

***
   Use dirname "$0":
#!/bin/bash
echo "The script you are running has basename `basename "$0"`, dirname `dirname "$0"`"
echo "The present working directory is `pwd`"

   using pwd alone will not work if you are not running the script from the directory it is contained in.
[matt@server1 ~]$ pwd
/home/matt
[matt@server1 ~]$ ./test2.sh
The script you are running has basename test2.sh, dirname .
The present working directory is /home/matt
[matt@server1 ~]$ cd /tmp
[matt@server1 tmp]$ ~/test2.sh
The script you are running has basename test2.sh, dirname /home/matt
The present working directory is /tmp

***
   The dirname command is the most basic, simply parsing the path up to the filename off of the $0
   (script name) variable:
dirname "$0"

   But, as matt b pointed out, the path returned is different depending on how the script is called. pwd
   doesn't do the job because that only tells you what the current directory is, not what directory the
   script resides in. Additionally, if a symbolic link to a script is executed, you're going to get a
   (probably relative) path to where the link resides, not the actual script.

   Some others have mentioned the readlink command, but at its simplest, you can use:
dirname "$(readlink -f "$0")"

   readlink will resolve the script path to an absolute path from the root of the filesystem. So, any
   paths containing single or double dots, tildes and/or symbolic links will be resolved to a full path.

   Here's a script demonstrating each of these, whatdir.sh:
#!/bin/bash
echo "pwd: `pwd`"
echo "\$0: $0"
echo "basename: `basename $0`"
echo "dirname: `dirname $0`"
echo "dirname/readlink: $(dirname $(readlink -f $0))"

   Running this script in my home dir, using a relative path:
>>>$ ./whatdir.sh
pwd: /Users/phatblat
$0: ./whatdir.sh
basename: whatdir.sh
dirname: .
dirname/readlink: /Users/phatblat

   Again, but using the full path to the script:
>>>$ /Users/phatblat/whatdir.sh
pwd: /Users/phatblat
$0: /Users/phatblat/whatdir.sh
basename: whatdir.sh
dirname: /Users/phatblat
dirname/readlink: /Users/phatblat

   Now changing directories:
>>>$ cd /tmp
>>>$ ~/whatdir.sh
pwd: /tmp
$0: /Users/phatblat/whatdir.sh
basename: whatdir.sh
dirname: /Users/phatblat
dirname/readlink: /Users/phatblat

   And finally using a symbolic link to execute the script:
>>>$ ln -s ~/whatdir.sh whatdirlink.sh
>>>$ ./whatdirlink.sh
pwd: /tmp
$0: ./whatdirlink.sh
basename: whatdirlink.sh
dirname: .
dirname/readlink: /Users/phatblat

***
pushd . > /dev/null
SCRIPT_PATH="${BASH_SOURCE[0]}"
if ([ -h "${SCRIPT_PATH}" ]); then
  while([ -h "${SCRIPT_PATH}" ]); do cd `dirname "$SCRIPT_PATH"`;
  SCRIPT_PATH=`readlink "${SCRIPT_PATH}"`; done
fi
cd `dirname ${SCRIPT_PATH}` > /dev/null
SCRIPT_PATH=`pwd`;
popd  > /dev/null

   Works for all versions,including
     * when called via multple depth soft link,
     * when the file it
     * when script called by command "source" aka . (dot) operator.
     * when arg $0 is modified from caller.
     * "./script"
     * "/full/path/to/script"
     * "/some/path/../../another/path/script"
     * "./some/folder/script"

   Alternatively, if the bash script itself is a relative symlink you want to follow it and return the
   full path of the linked-to script:
pushd . > /dev/null
SCRIPT_PATH="${BASH_SOURCE[0]}";
if ([ -h "${SCRIPT_PATH}" ]) then
  while([ -h "${SCRIPT_PATH}" ]) do cd `dirname "$SCRIPT_PATH"`; SCRIPT_PATH=`readlink "${SCRIPT_PATH}"`; done
fi
cd `dirname ${SCRIPT_PATH}` > /dev/null
SCRIPT_PATH=`pwd`;
popd  > /dev/null

   SCRIPT_PATH is given in full path, no matter how it is called.
   Just make sure you locate this at start of the script.

---
