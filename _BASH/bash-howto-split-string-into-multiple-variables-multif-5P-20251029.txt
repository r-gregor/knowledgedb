filename: bash-howto-split-string-into-multiple-variables-multif-5P-20251029.txt
https://www.baeldung.com/linux/bash-string-split-into-array

How to Split a String Into an Array in Bash
March 18, 2024

1. Overview
Splitting a string into an array is a common task in computer programming. For example, we might want to
extract words from lines within a text file or process user input in a certain way.

In this tutorial, we'll learn techniques to convert a string to an array using the Bash shell.

2. Iterating Over a String
A for loop construct in Bash can split a string value and iterate over the tokens. The for loop performs
string splitting based on the characters defined in the IFS shell variable.

2.1. Split a Sentence Into Words
To begin the process of splitting a sentence into words, let's declare a shell variable and assign a sentence
where words are separated with spaces:
$> sentence='Hello World of Linux'

In this example, we set the value of the shell variable named sentence to the string value 'Hello World of
Linux'.Furthermore, we placed the string inside single quotes to prevent the assignment from failing.

Next, let's create an empty array where we'll put the words of the sentence after splitting it:
$> words=()

Now, we're ready to create the loop that splits the sentence and adds the words to the words array:
$> for i in $sentence; do words+=($i) ; done

Here, the loop extracts the next word from the sentence and assigns it to the i variable. Then, we use the +=
operator to add the value of the i variable to the words array.

Finally, let's print the elements of the words array to verify the result of our script:
$> for word in ${words[@]}; do echo $word ; done
Hello
World
of
Linux

Indeed, the sentence was split into words and the words were added to the words array correctly.

2.2. Using Other Separator Characters
The for loop uses the characters in the IFS shell variable to split strings. IFS stands for Internal Field
Separator and Bash uses it to recognize fields. Its value defaults to " \t\n", meaning that the shell uses the
space, the tab, or the newline characters to split a string value into fields or words.

If we want to split a string using a different character, we can append the desired character to the IFS
variable. For example, let's change our sentence:
$> sentence='Hello#World#of#Linux'

As we can see, we've used the # character to separate words. Next, let's add the # character to the IFS
variable:
$> IFS=$IFS#
$> printf "%q" "$IFS"
$' \t\n#'

Indeed, we successfully appended the # character to the IFS variable. Furthermore, we used the printf "%q"
command to print the value of the IFS variable. The %q format escapes non-printable characters. As a result,
the space, tab, and newline characters are clearly printed on the terminal.

Next, let's empty the words array and run for again:

$> words=()
$> for i in $sentence; do words+=($i) ; done
$> for word in ${words[@]}; do echo $word ; done
Hello
world
of
Linux

Indeed, we can see that the for construct used the # character as a field separator and split the sentence
into words.

Finally, we can reset IFS to its initial value by removing the # character:
$> IFS="${IFS:0:3}"
$> printf '%q' "${IFS}"
' \t\n'

As we can see, we extracted a three-character length substring of IFS, starting from position 0, and assigned
it back to the IFS variable.

3. Using the read Command
Another technique to split a string into an array is to use the read command with the -a option.

The read command's purpose is to capture user input into shell variables. Similar to the for loop, it uses the
characters in the IFS variable as field separators:

$> words=()
$> read -a words
Hello World of Linux

$> for word in ${words[@]}; do echo $word ; done
Hello
World
of
Linux

Here, the read command loads the words of the sentence to the words array because of the -a option. In
particular, we specified the array variable after the -a option. Furthermore, the read command waits until we
enter a string value.

Notably, entering the string value interactively isn't very convenient. Instead, we can input a here-string to
avoid the read command being blocked:
$> words=()
$> read -a words <<< "Hello World of Linux"
$> for word in ${words[@]}; do echo $word ; done
Hello
World
of
Linux

In this example, we used the <<< operator to input the here-string to the read command. This form is
convenient when we want to split a string inside a shell script.

Moreover, we can again add separator characters to the IFS variable:
$> IFS=$IFS#
$> words=()
$> read -a words <<< "Hello#World#of#Linux"
$> for word in ${words[@]}; do echo $word ; done
Hello
World
of
Linux

As we can see, read was also successful in splitting a string into words that were separated by the #
character, after appending this character to the IFS string.

4. Conclusion
In this article, we talked about splitting a string into an array in the Bash shell. We showcased two methods,
the first using a for loop and the second using the read command.


---
https://stackoverflow.com/questions/10520623/how-to-split-one-string-into-multiple-variables-in-bash-shell

How to split one string into multiple variables in bash shell? [duplicate]

   I've been looking for a solution and found similar questions, only they were attempting to split
   sentences with spaces between them, and the answers do not work for my situation.

   Currently a variable is being set to something a string like this:
   ABCDE-123456
   and I would like to split that into 2 variables, while eliminating the "-". i.e.:
   var1=ABCDE
   var2=123456

   How is it possible to accomplish this?

   This is the solution that worked for me:
   var1=$(echo $STR | cut -f1 -d-)
   var2=$(echo $STR | cut -f2 -d-)

   Is it possible to use the cut command that will work without a delimiter (each character gets set as
   a variable)?

   var1=$(echo $STR | cut -f1 -d?)
   var2=$(echo $STR | cut -f1 -d?)
   var3=$(echo $STR | cut -f1 -d?)
   etc.

***
   To split a string separated by -, you can use read with IFS:
$> IFS=- read -r var1 var2 <<< ABCDE-123456
$> echo "$var1"
ABCDE
$> echo "$var2"
123456

   Edit:

   Here is how you can read each individual character into array elements:
$> read -ra foo <<<"$(echo "ABCDE-123456" | sed 's/./& /g')"

   Dump the array:
$> declare -p foo
declare -a foo='([0]="A" [1]="B" [2]="C" [3]="D" [4]="E" [5]="-" [6]="1" [7]="2" [8]="3" [9]="4" [10]="5" \
[11]="6")'

   If there are spaces in the string:
$> IFS=$'\v' read -ra foo <<<"$(echo "ABCDE 123456" | sed $'s/./&\v/g')"
$> declare -p foo
declare -a foo='([0]="A" [1]="B" [2]="C" [3]="D" [4]="E" [5]=" " [6]="1" [7]="2" [8]="3" [9]="4" [10]="5" \
[11]="6")'

***
   If you know it's going to be just two fields, you can skip the extra subprocesses. Like this:
STR="ABCDE-12345"
var1=${STR%-*} # ABCDE
var2=${STR#*-} # 12345

   Explanation:
     * ${STR%-*} deletes the shortest substring of $STR that matches the pattern -* (deletes - and
       anything after it). It starts from the end of the string.
     * ${STR#*-} deletes the shortest substring of $STR that matches the pattern *- (deletes - and
       anything before it). It starts from the beginning of the string.

   They each have counterparts %% and ## which find the longest anchored pattern match. To memorize, use
   this mnemonic, shared by @DS:

     "#" is to the left of "%" on a standard keyboard, so "#" removes a prefix (on the left), and "%"
     removes a suffix (on the right).

***
Using bash regex capabilities:

re="^([^-]+)-(.*)$"
[[ "ABCDE-123456" =~ $re ]] && var1="${BASH_REMATCH[1]}" && var2="${BASH_REMATCH[2]}"
echo $var1
echo $var2

OUTPUT:

ABCDE
123456


---
https://unix.stackexchange.com/questions/503572/how-to-break-a-long-string-into-multiple-lines-assigned-to-a-variable-in-linux-b

How to break a long string into multiple lines assigned to a variable in linux bash script

   I am working towards writing a bash script that contains a variable with a long string value. When I
   split the string into multiple lines it is throwing error. How to split the string into multiple
   lines and assigned to a variable?

***
   One suggestion:
x='Lorem ipsum dolor sit amet, consectetur '\
'adipiscing elit, sed do eiusmod tempor '\
'incididunt ut labore et dolore magna aliqua.'

   Which results in the expected:
$> printf '%s\n' "$x"
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore
magna aliqua.

***
   Assigning long strings as multiple sub-string in an array could make the code more aesthetically
   appealing:

#!/bin/bash

text=(
    'Contrary to popular'
    'belief, Lorem Ipsum'
    'is not simply'
    'random text. It has'
    'roots in a piece'
    'of classical Latin'
    'literature from 45'
    'BC, making it over'
    '2000 years old.'
)

# output one line per string in the array:
printf '%s\n' "${text[@]}"

# output all strings on a single line, delimited by space (first
# character of $IFS), and let "fmt" format it to 45 characters per line
printf '%s\n' "${text[*]}" | fmt -w 45

   To do the opposite, i.e. to take a long line, split it into multiple lines, and read these into an
   array variable:
$> cat file
Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin
literature from 45 BC, making it over 2000 years old.

   We use fmt here to break the line down into shorter lines that are at most 30 characters long, then
   readarray in the bash shell to read these lines into the array called text:
$> readarray -t text < <(fmt -w 30 file)

   Now we may access the set of lines, or each individual line:
$> printf '%s\n' "${text[@]}"
Contrary to popular belief,
Lorem Ipsum is not simply
random text. It has roots in a
piece of classical Latin
literature from 45 BC, making
it over 2000 years old.

$> printf '%s\n' "${text[3]}"
piece of classical Latin

***
   If the point is to store a very long line in a shell variable, but for the code to do so not to
   exceed some fixed width, assuming a Bourne-like shell, you can do:
string="Rerum inventore nemo neque reiciendis ullam. Volupta\
te amet eveniet corporis nostrum. Laboriosam id sapiente atq\
ue non excepturi. Dolorem alias sed et voluptatem est unde s\
ed atque. Itaque ut molestias alias dolor eos doloremque exp\
licabo. Quas dolorum sint sit dicta nemo qui."

   Inside double quotes (contrary to single quotes), backslash-newline is still treated as a line
   continuation). Beware that inside double quotes, ", $, `, \ (and sometimes !) are still special and
   would need to be escaped.

   On approach that avoids having to worry about quoting is to write:
string=$(<<'EOF' tr -d '\n'
Rerum inventore nemo neque reiciendis ullam. Vo
luptate amet eveniet corporis nostrum. Laborios
am id sapiente atque non excepturi. Dolorem ali
as sed et voluptatem est unde sed atque. Itaque
 ut molestias alias dolor eos doloremque explic
abo. Quas dolorum sint sit dicta nemo qui. 'And
'#\`"$% whatever.
EOF
)

   When the << delimiter is quoted, even partly, no expansion is made in the body of the here-document.
   Here, we capture the output of tr which is fed the here-document from which it deletes the newline
   characters. You could use a similar approach to add some indentation with:
string=$(<<'EOF' cut -b3- | tr -d '\n'
  Rerum inventore nemo neque reiciendis ullam. Vo
  luptate amet eveniet corporis nostrum. Laborios
  am id sapiente atque non excepturi. Dolorem ali
  as sed et voluptatem est unde sed atque. Itaque
   ut molestias alias dolor eos doloremque explic
  abo. Quas dolorum sint sit dicta nemo qui. 'And
  '#\'"$% whatever.
EOF
)

***
   Assuming you want to assign the string some long piece of text to assign to the variable str. This
   won't work:
str='some long'
'piece of text'
'to assign'

   It'll try to run the lines after the first as commands, you'll probably get "command not found"
   errors.

   You can do this, but the newlines will be embedded in the variable, so it won't be a single line:
str='some long
piece of text
to assign'

   Though you can use the substring replacement expansion (in Bash, ksh, zsh) to replace them with
   spaces, e.g. str="${str//$'\n'/ }" to do the replacement and save the new value in the same variable.
   Note that any trailing whitespace on all but the last line will be left in the string.

   Another option is to use += to append to the value of the variable (also Bash, ksh, zsh only):
str='some long'
str+=' piece of text'
str+=' to assign'

   Here, any whitespace will need to be manually typed within the quotes.

   Or, similarly in a standard shell:
str='some long'
str="$str"' piece of text'
str="$str"' to assign'

   Then there's the way with line continuation (that Jeff already mentioned in their answer):
str='some long'\
' piece of text'\
' to assign'

   Here, too, trailing whitespace is important, the line continuation only works if the backslash is
   immediately followed by a newline, not if there are spaces in between.

***
   I would write it this way in a command line prompt. It could be, of course, more compressed, but for
   clarity's sake:
$> text='You can do this, but the newlines will be embedded in the variable, so it won'tbe a single line'
$> array=$(echo $text | cut -d' ' -f 1-)
$> for x in ${array[@]}; do echo $x ; done

   Here is a one liner:
$> echo $text | tr ' ' '\n'

   Output:
You
can
do
this,
but
the
newlines
will
be
embedded
in
the
variable,
so
it
won't
be
a
single
line

   Or, for a sorted output:
$> echo $text | tr ' ' '\n' | sort

   Output:
a
be
be
but
can
do
embedded
in
it
line
newlines
single
so
the
the
this,
variable,
will
won't
You


---
https://unix.stackexchange.com/questions/519013/assign-the-same-string-to-multiple-variables

Assign the same string to multiple variables

   I want to assign the string contained in $value to multiple BASH variables.

   Actually the example I gave before (var1=var2=...=$value) was not reflecting exactly what I wanted.
   So far, I found this but it only works if $value is an integer:
$> let varT=varz=var3=$value

   How can I do that?

***
   In my opinion you're better of just doing the more readable:
var1="$value" var2="$value" var3="$value" var4="$value" var5="$value" var6="$value" var7="$value" \
var8="$value" var9="$value" var10="$value"

   But if you want a very short way of accomplishing this then try:
declare var{1..10}="$value"

   Edited: using brace expansions instead of printf and declare instead of eval, which could be
   dangerous depending on what's in $value.

   Cf. EDIT1: You could still use brace expansions in the new case:
declare var{T,z,3}="$value"

   It's safer than the printf approach in the comments because it can handle spaces in $value.

***
   let is doing an arithmetic evaluation. In bash, this is equivalent to (( ... )). This is why your
   code only works for integers.

   Using an array instead of specially named variables:
var=( "$value"  "$value" "$value" "$value" "$value" "$value" "$value" "$value" "$value" "$value" )

printf 'var[5]=%s\n' "${var[5]}"

   or an associative array,
declare -A var

var=( ["T"]=$value ["z"]=$value [3]=$value )

printf 'var[T]=%s\n' "${var["T"]}"

   You could also do a loop:
for varname in var0 var1 varT varfoo; do
	declare -n var="$varname"
	var=$value
done

   This loop loops over names of variables. In the loop body, a name reference variable is created that
   references the current loop variable. When the value of the name reference variable is set, the named
   variable is set.

***
value=balabala
eval var{1..10}=\$value
echo $var{1..10}

***
Value='-%% this is a test %%-'
for VarName in myVar1 myVar2 myOtherVar; do printf -v "$VarName" %s "$Value"; done

***
   you could do:
declare {varT,varz}="$value"


---
https://superuser.com/questions/1660844/using-read-to-capture-multiple-variables-from-a-commands-output

Using read to capture multiple variables from a command's output

   I have a youtube-dl command that when run outputs two new lines, and I'm trying to capture each of
   those to variables.

   Here is what I have so far, but for some reason I can't understand, it only captures the first line
   of output while discarding the second ($audio is empty).
read -r video audio <<< "$(youtube-dl -g --youtube-skip-dash-manifest https://www.youtube.com/watch?v=-gcvAxJJiGo)"

   How can I fix it to make it capture both inputs, or alternatively, is there a more reliable way to do
   so?

***
   read -r video audio will capture the first ($IFS separated) word into "video" and the rest of the
   line into "audio"

   Another way to capture 2 lines is with command grouping and a process substitution:
{
  read -r video
  read -r audio
} < <(
  youtube-dl -g --youtube-skip-dash-manifest "$url"
)

   The space between < <( is important: a <(process substitution) acts like a file, so you're using < to
   redirect input from a file.

   It just occurred to me: another way to read lines of output is the mapfile command:
mapfile -t lines < <(youtube-dl ...)
declare -p lines  # just to inspect the array contents

video=${lines[0]}
audio=${lines[1]}

***
   [https://unix.stackexchange.com/a/328783/108618]read reads one line by design. The simplest way to read two
   lines is to use read twice.

exec 3< <(youtube-dl -g --youtube-skip-dash-manifest 'https://www.youtube.com/watch?v=-gcvAxJJiGo')
IFS= read -r -u3 video
IFS= read -r -u3 audio
exec 3>&-

   read -u is not portable, neither is <(...). They work in Bash and your question is tagged bash,
   so they should work for you.

   Note I single-quoted the string containing ? in case you had a directory https:/www.youtube.com/ and
   a matching file therein. It's only remotely possible, still quoting wildcard characters that should
   not be treated as wildcards is good practice in any shell. Compare what happens in Zsh.

   Empty IFS is the right thing in general, when you want to read a line.

   This other answer does not use exec and it's good. It's my personal preference to set input up
   visually before tools that will use it (compare this answer). Unfortunately <(...) { ...; } does not
   work. With exec I can do it.

   Or I can do it by piping youtube-dl to the rest of the script.
youtube-dl -g --youtube-skip-dash-manifest 'https://www.youtube.com/watch?v=-gcvAxJJiGo' \
| {
IFS= read -r video
IFS= read -r audio
}

   Normally Bash runs the { ... } fragment in a subshell, so the variables will not survive after }. shopt
   -s lastpipe can change this (if job control is not active). Without lastpipe (which is not portable)
   the entire approach is portable but you need to run everything that uses the variables inside the { }
   block because you don't know if it's a subshell or not (POSIX allows both behaviors). Note the stdin
   inside the block comes from youtube-dl; if anything inside the block needs to use the stdin of the
   entire script then you may need to use exec anyway to juggle the descriptors.

   Another portable approach is like this:
input="$(youtube-dl -g --youtube-skip-dash-manifest 'https://www.youtube.com/watch?v=-gcvAxJJiGo')"
video="$(printf '%s\n' "$input" | head -n 1)"
audio="$(printf '%s\n' "$input" | head -n 2 | tail -n 1)"

   Instead of head and tail you can use sed or awk to isolate the right line.

   Note this solution does not use read. If you need features of read then this is not the way. It seems
   you don't need the features of read in this particular case though.

   Even if youtube-dl was very fast, I would not advise video="$(youtube-dl ... | head -n 1)" plus
   audio="$(youtube-dl ... | ...)". If video and audio come from the same input, from the same invocation of
   youtube-dl, then they are as coherent as the tool allows. Otherwise they may be incoherent. Frankly I
   don't know how incoherent they may be (if ever); but I know in general it's better to query once
   (e.g. date +%H:+%M should always be coherent; date +%H; date +%M will surprise you if you run it just
   before a full hour).


---
https://www.geeksforgeeks.org/linux-unix/bash-scripting-split-string/

Bash Scripting - Split String
Last Updated : 15 Sep, 2023

   In this article, we will discuss how to split strings in a bash script.

   Dividing a single string into multiple strings is called string splitting. Many programming languages
   have a built-in function to perform string splitting but there is no built-in function in bash to do
   so. There are various methods to perform split string in bash. Let's see all methods one by one with
   examples.

Method 1: Using IFS variable
   $IFS(Internal Field Separator) is a special shell variable. It is used to assign the delimiter (a
   sequence of one or more characters based on which we want to split the string). Any value or
   character like '\t', '\n', '-' etc. can be the delimiter. After assigning the value to the $IFS
   variable, the string value needs to be read. We can read string using '-r' and '-a' options.
     * '-r': It read backslash (\) as a character instead of an escape character
     * '-a': It is used to store the split-ted words into an array variable that is declared after the
       -a option.

   Example 1: Split the string by space

   Code:
#!/bin/bash

# String
text="Welcome to GeeksforGeeks"

# Set space as the delimiter
IFS=' '

# Read the split words into an array
# based on space delimiter
read -ra newarr <<< "$text"

# Print each value of the array by using
# the loop
for val in "${newarr[@]}"; do
	echo "$val"
done

   Output:
Welcome
to
GeeksforGeeks

   Example 2: Split string by a symbol

   String split using @ symbol.

   Code:
#!/bin/bash

#String
text="Welcome@to@GeeksforGeeks@!!"

# Set @ as the delimiter
IFS='@'

# Read the split words into an array
# based on space delimiter
read -ra newarr <<< "$text"


# Print each value of the array by
# using the loop
for val in "${newarr[@]}";
do
	echo "$val"
done

   Output:
Welcome
to
GeeksforGeeks
!!

Method 2: Without using IFS variable
   In this method, readarray command with the -d option is used to split the string data.  '-d': this
   option act as an IFS variable to define the delimiter.

   Example 1: Split string by space

   Code:
#!/bin/bash

# Read the main string
text="Welcome to GeeksforGeeks"

# Split the string by space
readarray -d " " -t strarr <<< "$text"

# Print each value of the array by
# using loop
for (( n=0; n < ${#strarr[*]}; n++)); do
	echo "${strarr[n]}
done

   Now, let's see how the script behaves:
     * The script sets the value of text to "Welcome to GeeksforGeeks."
     * The readarray command splits the string into an array using space as the delimiter, resulting in
       the array strarr containing the following elements: "Welcome", "to", "GeeksforGeeks."
     * The for loop iterates over each element of the strarr array.
     * It prints each element one by one on separate lines.

   Output:
Welcome
to
GeeksforGeeks

   Example 2: Split using a colon as a delimiter

   Code:
#!/bin/bash

# Read the main string
text="Welcome:to:GeeksforGeeks"

# Split the string based on the delimiter, ':'
readarray -d : -t strarr <<< "$text"

# Print each value of the array by using
# loop
for (( n=0; n < ${#strarr[*]}; n++)); do
	echo "${strarr[n]}"
done

   Output:
Welcome
to
GeeksforGeeks

Method 3: Split the string with a multi-character  delimiter
   In this method, a variable is used to store string data and another variable is used to store
   multi-character delimiter data. An array variable is also declared to store the split-ted string.

   Code:
# Define the string to split
text="HelloRomy HelloPushkar HelloNikhil HelloRinkle"

# store multi-character delimiter
delimiter="Hello"

# Concatenate the delimiter with the
# main string
string=$text$delimiter

# Split the text based on the delimiter
newarray=()
while [[ $string ]]; do
	rewarray+=( "${string%%"$delimiter"*}" )
	string=${string#*"$delimiter"}
done

# Print the words after the split
for value in ${newarray[@]}
do
	echo "$value "
done

   Output:
Romy
Pushkar
Nikhil
Rinkle


---
https://superuser.com/questions/1578362/how-to-efficiently-split-a-bash-variable-into-two-variables

How to efficiently split a bash variable into two variables

   I have a variable $b which I want to split into two variables $startt and $finisht.

#!/bin/bash
b='08:10:00','11:12:00'
b=$(echo "$b" | tr -d "'")
IFS=',' read -r _ startt finisht _ <<<"$b"
echo "$startt"
echo "$finisht"

   The following is the desired output. startt = 08:10:00 and finisht = 11:12:00. However when I run
   this script I only get 11:12:00. I want to split the variable as efficiently as possible. Can anyone
   help?

***
   Use [https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Parameter-Expansion]shell
   parameter expansion:

startt=${b%,*}  # cut off the comma and everything that follows
finisht=${b#*,} # cut off the comma and everything that precedes

$> b='08:10:00','11:12:00'
$> echo $b
08:10:00,11:12:00

$> startt=${b%,*}
$> finisht=${b#*,}
$> echo $startt
08:10:00

$> echo $finisht
11:12:00


---
https://superuser.com/questions/461981/how-do-i-convert-a-bash-array-variable-to-a-string-delimited-with-newlines

How do I convert a bash array variable to a string delimited with newlines?

   I want to write out a bash array variable to a file, with each element on a new line. I could do this
   with a for loop, but is there another (cleaner) way to join the elements with \n?

***
   Here's a way that utilizes bash parameter expansion and its IFS special variable.
$> System=('s1' 's2' 's3' 's4 4 4')
$> ( IFS=$'\n'; echo "${System[*]}" )

   We use a subshell to avoid overwriting the value of IFS in the current environment. In that subshell,
   we then modify the value of IFS so that the first character is a newline (using $'...' quoting).
   Finally, we use parameter expansion to print the contents of the array as a single word; each element
   is separated by the first charater of IFS.

   To capture to a variable:
$> var=$( IFS=$'\n'; echo "${System[*]}" )

   If your bash is new enough (4.2 or later), you can (and should) still use printf with the -v option:
$> printf -v var "%s\n" "${System[@]}"

   In either case, you may not want the final newline in var. To remove it:
$> var=${var%?}    # Remove the final character of var

***
   You can use printf to print each array item on its own line:
$> System=('s1' 's2' 's3' 's4 4 4')
$> printf "%s\n"  "${System[@]}"
s1
s2
s3
s4 4 4

***
awk -v sep='\n' 'BEGIN{ORS=OFS="";for(i=1;i<ARGC;i++){print ARGV[i],ARGC-i-1?sep:""}}' "${arr[@]}"

   or
perl -le 'print join "\n",@ARGV' "${arr[@]}"

   or
python -c 'import sys;print "\n".join(sys.argv[1:])' "${arr[@]}"

   or
sh -c 'IFS=$'\''\n'\'';echo "$*"' '' "${arr[@]}"

   or
lua <(echo 'print(table.concat(arg,"\n"))') "${arr[@]}"

   or
tclsh <(echo 'puts [join $argv "\n"]') "${arr[@]}"

   or
php -r 'echo implode("\n",array_slice($argv,1));' -- "${arr[@]}"

   or
ruby -e 'puts ARGV.join("\n")' "${arr[@]}"

   that's all I can remind so far.

***
   Above solutions are pretty much it, but the original question asks for output to file:
$> a=(a b c d e)
$> ( IFS=$'\n'; echo "${a[*]}" ) > /tmp/file
$> cat /tmp/file
a
b
c
d
e
$> 

   Notes: 1) 'echo' provides the final newline 2) If this file will just be read in by bash again, then
   declare -p may be the serialization wanted.

***
   Using for:
for each in "${alpha[@]}"
do
	echo "$each"
done

   Using history; note this will fail if your values contain !:
$> history -p "${alpha[@]}"

   Using basename; note this will fail if your values contain /:
basename -a "${alpha[@]}"
$> 
   Using shuf; note that results might not come out in order:
$> shuf -e "${alpha[@]}"

***
   printf seems to be the most efficient approach for creating a delimited string from an array:
# create a delimited string; note that printf doesn't put the trailing delimiter
# need to save and restore IFS
# it is prudent to put the whole logic on a single line so as to minimize the risk of future code changes
  breaking the sequence of saving/restoring of IFS

oldIFS=$IFS; IFS=$'\n'; printf -v var "${arr[*]}"; IFS=$oldIFS

# print string to file; note that the newline is required in the format string because printf wouldn'tput a
  trailing delimiter (which is a good thing)

printf '%s\n' "$var" > file

   An even simpler way to do this is:
delim=$'\n'
printf -v var "%s$delim" "${arr[@]}" # create a delimited string
var="${var%$delim}"                  # remove the trailing delimiter

Example

delim=:
arr=(one two three)
printf -v var "%s$delim" "${arr[@]}" # yields one:two:three:
var="${var%$delim}"                  # yields one:two_three

***
   My take, using only Bash builtins, without mutating IFS:

# $1  separator
# $2... strings

join_strings () {
	declare separator="$1";
	declare -a args=("${@:2}");
	declare result;
	printf -v result '%s' "${args[@]/#/$separator}";
	printf '%s' "${result:${#separator}}"
}

Example

$> join_strings $'\n' "a b c" "d e f" "g h i"
a b c
d e f
g h i

   You can also use any separator:
$> join_strings '===' "a b c" "d e f" "g h i"
a b c===d e f===g h i

***
   here is my impression of joinArray:

function joinArray() {
	local delimiter="${1}"
	local output="${2}"
	for param in ${@:3}; do
		output="${output}${delimiter}${param}"
	done

	echo "${output}"
}

***
   As said before, the following:
$> printf -v var "%s\n" "${System[@]}"

   works, if you're converting to a string, but you have to deal with the single blank line at the end.
   I find you can avoid this by using command substitution instead, so
$> var=$(printf '%\n' "${System[@]}")

   should work just fine. Just remember to quote var to get the required effect!

***
   The shortest and probably one of the most efficient solutions I can think of, is just redirecting the
   output from printf into a file:
printf '%s\n' "${array[@]}" > testfile


---

