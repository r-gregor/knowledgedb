filename: bash_generating-random-numbers_20200828.txt
https://linuxconfig.org/generating-random-numbers-in-bash-with-examples

Generating Random Numbers In Bash With Examples
12 August 2020

   When coding Bash scripts - especially when developing scripts for functionality testing - we
   sometimes need to generate a random number or random input. These numbers may also need to be within
   a specific range. This article will teach you how to perform random number generation in Bash.

   In this tutorial you will learn:
     * How to generate random numbers in Bash
     * How to generate random numbers is a specific range
     * Examples demonstrating random number generation in Bash

   Generating Random Numbers In Bash With Examples Generating Random Numbers In Bash With Examples
   Generating Random Numbers In Bash With Examples

Example 1: Generating a random number using the random generator
   Let's generate a random number in Bash:
$> echo $RANDOM
24758
$> echo $RANDOM
13

   That was simple wasn't it?

   There are a few challenges with this approach though; it is not very usable as it stands: the random
   number could be 1 or 32000. Also noteworthy is that whilst the returned number seems random, it is
   actually influenced by how the random entropy variable (RANDOM=) is initialized. This will be the
   focus for another article. A quick example of how you can make it more random would be;
$> RANDOM=1
$> echo $RANDOM
16807
$> RANDOM=1
$> echo $RANDOM
16807
$> RANDOM=$(date +%s%N | cut -b10-19)
$> echo $RANDOM
18991
$> RANDOM=$(date +%s%N | cut -b10-19)
$> echo $RANDOM
11045

   Note that the random number 16807 is not really that random, as the random generator was seeded with
   the same 1.

   The RANDOM=$(date +%s%N | cut -b10-19) command is a much better random generator entropy seeder based
   on second and nanosecond time.

Example 2: Numbers in a range
   Selecting random numbers in a range is simple. Let's generate a random number between 1 and 113:
$> echo $(( $RANDOM % 113 + 1 ))
50
$> echo $(( $RANDOM % 113 + 1 ))
17
$> echo $(( $RANDOM % 113 + 1 ))
95

   And we can also use an alternative syntax/command. This time we will generate a random number between
   1 and 117:
$> echo $[ $RANDOM % 117 + 1 ]
113
$> echo $[ $RANDOM % 117 + 1 ]
71
$> echo $[ $RANDOM % 117 + 1 ]
10

   To increase the minimum of a given range, you can simply increase the +1 to a higher number.

   Please consider the following example, generating a random number between 11 and 30:
$> echo $[ $RANDOM % 20 + 11 ]
21

Conclusion
   In this article, we learned how to generate a random number in Bash, in any preferred range. We also
   touched briefly on how randomness in Bash works via an entropy seed initialized random generator.


---
https://linuxconfig.org/random-entropy-in-bash

Random Entropy in Bash
12 August 2020

   When using random numbers in Bash, the question of random entropy will sooner or later come up. This
   article will help you understand what entropy is, how it can be modified and optimized in Bash, and
   how it will affect random number generation.

   In this tutorial you will learn:
     * How to generate random entropy in Bash
     * How to pre-seed the random number generator in Bash
     * Examples demonstrating random entropy generation in Bash

Example 1: Random, or not so random?
   We can easily generate a random number in Bash:
$> echo $RANDOM
13

   However, whilst this number looks random, it is in fact not, or at best pseudo-random. This is
   because a computer can in and by itself never be truly random, and the random number generator in
   Bash is pre-seeded with a value, which determines all subsequent calls of the $RANDOM
   variable/function.

   Let's pre-seed the random number generator in a few different ways. We'll start off by pre-seeding
   the random generator with seed '1' by setting RANDOM to 1:
$> echo $RANDOM
25552
$> RANDOM=1
$> echo $RANDOM
16807
$> RANDOM=1
$> echo $RANDOM
16807
$> echo $RANDOM
15089
$> RANDOM=1
$> echo $RANDOM
16807
$> echo $RANDOM
15089
$> RANDOM=a
$> echo $RANDOM
20034

   Note that the 16807 and secondary-call 15089 results remain the same while the random generator was
   pre-seeded with 1. It changes when pre-seeded with a.

   Whilst the $RANDOM variable in Bash will always yield a random number generated by the Bash random
   number generator, it is also a variable which, when set, pre-seeds the random generator. The
   challenge is that if the seed is the same, the outcome (and sequence!) will also be the same, as you
   can see from studying the above example.

   How the random generator is initialized in your system may depend on the Linux or Unix operating
   system in use, hardware used, and configuration settings. Let's immediately agree it is not a very
   secure way to generate a true/real random number, hence the terms pseudo-random and
   pseudo-randomness. That said, much can be done to make it (much) better.

Example 2: Our own random entropy generator
   The only input which is available to the random generator is basically the seed as passed to RANDOM=.
   So how can we come up with a truly random seed to seed the random generator, and create real random
   entropy (entropy: the quality of lack of predictability)? Random entropy is important, especially in
   the field of computer security.

   Think about this question; how can you provide (to Bash) the most random input to use as a seed for
   random entropy generation?

   I believe I have found a solution in the following code:
$> date +%s%N
1593785871313595555
#        |--------| < Selected part indicated
$> date +%s%N | cut -b10-19
4418322030
$> date +%s%N | cut -b10-19
4914627208
$> date +%s%N | cut -b10-19
5282934388
$> date +%s%N | cut -b10-19
5635463163
$> date +%s%N | cut -b10-19
5967700148
$> date +%s%N | cut -b10-19
6322917009
$> RANDOM=$(date +%s%N | cut -b10-19)
$> echo $RANDOM
16349
$> RANDOM=$(date +%s%N | cut -b10-19)
$> echo $RANDOM
9713

   The final 9713 result is almost truly random.

   date +%s%N is a combination of %s which is the seconds since 1970-01-01 00:00:00 UTC - quite a unique
   number, but still something which could potentially be re-calculated. And %N is nanoseconds. Then we
   slice the input to grab only the last 10 digits.

   This means we are passing the second (last 0-9 digit) + the full exact nanosecond 000000000-999999999
   to the random generator as a seed. This would be as good as impossible to reconstruct, unless you
   capture the value generated before assigning it. Almost truly random.

   This also means you can get a semi-random number of x digits by simply selecting the most granular
   part of the microsecond:
date +%s%N | cut -b19-19
date +%s%N | cut -b18-19
date +%s%N | cut -b17-19

   The first command will produce 1 digit, the second 2 digits etc.

   However, the longer your cut slice becomes (by increasing the cut length), the less pseudo-random the
   number will be, especially once you slice into the seconds part. You could also leave off the %s, and
   reduce the cut size to have a less intensive system call. Whilst it may not matter for a single call
   of $RANDOM, it would matter if it was called hundreds of thousands of times.

Conclusion
   In this article, we saw how to generate random entropy, in a reasonably random way. Whilst no random
   entropy generator is perfect (and therefore any random number resulting from it), we came close by
   calling on nanosecond time. We also saw how pre-seeding the random generator entropy variable with a
   specific seed will subsequently yield the same outcomes whenever a random number is generated using
   the $RANDOM variable.


---
