filename: getopts_parse-options-to-bash-script-multif_20170921.txt
http://wiki.bash-hackers.org/howto/getopts_tutorial

Small getopts tutorial

Description
   When you want to parse command line arguments in a professional way, getopts is the tool of choice.
   Unlike its older brother getopt (note the missing s!), it's a shell builtin command. The advantages
   are:
     * No need to pass the positional parameters through to an external program.
     * Being a builtin, getopts can set shell variables to use for parsing (impossible for an external
       process!)
     * There's no need to argue with several getopt implementations which had buggy concepts in the past
       (whitespace, …)
     * getopts is defined in POSIX®.

   Some other methods to parse positional parameters (without getopt(s)) are described in: [33]How to
   handle positional parameters.

   Note that getopts is not able to parse GNU-style long options (--myoption) or XF86-style long options
   (-myoption)!

Terminology
   It's useful to know what we're talking about here, so let's see… Consider the following command line:
mybackup -x -f /etc/mybackup.conf -r ./foo.txt ./bar.txt

   These are all positional parameters, but they can be divided into several logical groups:
     * -x is an option (aka flag or switch). It consists of a dash (-) followed by one character.
     * -f is also an option, but this option has an associated option argument (an argument to the
       option -f): /etc/mybackup.conf. The option argument is usually the argument following the option
       itself, but that isn't mandatory. Joining the option and option argument into a single argument
       -f/etc/mybackup.conf is valid.
     * -r depends on the configuration. In this example, -r doesn't take arguments so it's a standalone
       option like -x.
     * ./foo.txt and ./bar.txt are remaining arguments without any associated options. These are often
       used as mass-arguments. For example, the filenames specified for cp(1), or arguments that don't
       need an option to be recognized because of the intended behavior of the program. POSIX® calls
       them operands.

   To give you an idea about why getopts is useful, The above command line is equivalent to:
mybackup -xrf /etc/mybackup.conf ./foo.txt ./bar.txt

   which is complex to parse without the help of getopts.

   The option flags can be upper- and lowercase characters, or digits. It may recognize other
   characters, but that's not recommended (usability and maybe problems with special characters).

How it works
   In general you need to call getopts several times. Each time it will use the next positional
   parameter and a possible argument, if parsable, and provide it to you. getopts will not change the
   set of positional parameters. If you want to shift them, it must be done manually:

shift $((OPTIND-1))
# now do something with $@

   Since getopts sets an exit status of FALSE when there's nothing left to parse, it's easy to use in a
   while-loop:

while getopts ...; do
  ...
done

   getopts will parse options and their possible arguments. It will stop parsing on the first non-option
   argument (a string that doesn't begin with a hyphen (-) that isn't an argument for any option in
   front of it). It will also stop parsing when it sees the -- (double-hyphen), which means [34]end of
   options.

Used variables
   variable description
   OPTIND Holds the index to the next argument to be processed. This is how getopts "remembers" its
   own status between invocations. Also useful to shift the positional parameters after processing with
   getopts. OPTIND is initially set to 1, and needs to be re-set to 1 if you want to parse anything
   again with getopts
   OPTARG This variable is set to any argument for an option found by getopts. It also contains the
   option flag of an unknown option.
   OPTERR (Values 0 or 1) Indicates if Bash should display error messages generated by the getopts
   builtin. The value is initialized to 1 on every shell startup - so be sure to always set it to 0 if
   you don't want to see annoying messages! OPTERR is not specified by POSIX for the getopts builtin
   utility — only for the C getopt() function in unistd.h (opterr). OPTERR is bash-specific and not
   supported by shells such as ksh93, mksh, zsh, or dash.

   getopts also uses these variables for error reporting (they're set to value-combinations which arent
   possible in normal operation).

Specify what you want

   The base-syntax for getopts is:
getopts OPTSTRING VARNAME [ARGS...]

   where:
   OPTSTRING tells getopts which options to expect and where to expect arguments (see below)
    VARNAME  tells getopts which shell-variable to use for option reporting
     ARGS    tells getopts to parse these optional words instead of the positional parameters

The option-string
   The option-string tells getopts which options to expect and which of them must have an argument. The
   syntax is very simple — every option character is simply named as is, this example-string would tell
   getopts to look for -f, -A and -x:
getopts fAx VARNAME

   When you want getopts to expect an argument for an option, just place a : (colon) after the proper
   option flag. If you want -A to expect an argument (i.e. to become -A SOMETHING) just do:
getopts fA:x VARNAME

   If the very first character of the option-string is a : (colon), which would normally be nonsense
   because there's no option letter preceding it, getopts switches to "silent error reporting mode". In
   productive scripts, this is usually what you want because it allows you to handle errors yourself
   without being disturbed by annoying messages.

Custom arguments to parse
   The getopts utility parses the [38]positional parameters of the current shell or function by default
   (which means it parses "$@").

   You can give your own set of arguments to the utility to parse. Whenever additional arguments are
   given after the VARNAME parameter, getopts doesn't try to parse the positional parameters, but these
   given words.

   This way, you are able to parse any option set you like, here for example from an array:

while getopts :f:h opt "${MY_OWN_SET[@]}"; do
  ...
done

   A call to getopts without these additional arguments is equivalent to explicitly calling it with
   "$@":
getopts ... "$@"

Error Reporting

   Regarding error-reporting, there are two modes getopts can run in:
     * verbose mode
     * silent mode

   For productive scripts I recommend to use the silent mode, since everything looks more professional,
   when you don't see annoying standard messages. Also it's easier to handle, since the failure cases
   are indicated in an easier way.

Verbose Mode
   invalid option VARNAME is set to ? (question-mark) and OPTARG is unset
   required argument not found VARNAME is set to ? (question-mark), OPTARG is unset and an error message
   is printed

Silent Mode
   invalid option VARNAME is set to ? (question-mark) and OPTARG is set to the (invalid) option
   character
   required argument not found VARNAME is set to : (colon) and OPTARG contains the option-character in
   question

Using it
A first example
   Enough said - action!

   Let's play with a very simple case: only one option (-a) expected, without any arguments. Also we
   disable the verbose error handling by preceding the whole option string with a colon (:):
   
<code>
#!/bin/bash

while getopts ":a" opt; do
  case $opt in
    a)
      echo "-a was triggered!" >&2
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      ;;
  esac
done
</code>

   I put that into a file named go_test.sh, which is the name you'll see below in the examples.

   Let's do some tests:
   
Calling it without any arguments
$ ./go_test.sh
$

   Nothing happened? Right. getopts didn't see any valid or invalid options (letters preceded by a
   dash), so it wasn't triggered.

Calling it with non-option arguments
$ ./go_test.sh /etc/passwd
$

   Again — nothing happened. The very same case: getopts didn't see any valid or invalid options
   (letters preceded by a dash), so it wasn't triggered.

   The arguments given to your script are of course accessible as $1 - ${N}.

Calling it with option-arguments
   Now let's trigger getopts: Provide options.

   First, an invalid one:
$ ./go_test.sh -b
Invalid option: -b
$

   As expected, getopts didn't accept this option and acted like told above: It placed ? into $opt and
   the invalid option character (b) into $OPTARG. With our case statement, we were able to detect this.

   Now, a valid one (-a):
$ ./go_test.sh -a
-a was triggered!
$

   You see, the detection works perfectly. The a was put into the variable $opt for our case statement.

   Of course it's possible to mix valid and invalid options when calling:
$ ./go_test.sh -a -x -b -c
-a was triggered!
Invalid option: -x
Invalid option: -b
Invalid option: -c
$

   Finally, it's of course possible, to give our option multiple times:
$ ./go_test.sh -a -a -a -a
-a was triggered!
-a was triggered!
-a was triggered!
-a was triggered!
$

   The last examples lead us to some points you may consider:
     * invalid options don't stop the processing: If you want to stop the script, you have to do it
       yourself (exit in the right place)
     * multiple identical options are possible: If you want to disallow these, you have to check
       manually (e.g. by setting a variable or so)

An option with argument
   Let's extend our example from above. Just a little bit:
     * -a now takes an argument
     * on an error, the parsing exits with exit 1

<code>
#!/bin/bash

while getopts ":a:" opt; do
  case $opt in
    a)
      echo "-a was triggered, Parameter: $OPTARG" >&2
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2
      exit 1
      ;;
  esac
done
</code>

   Let's do the very same tests we did in the last example:

Calling it without any arguments
$ ./go_test.sh
$

   As above, nothing happened. It wasn't triggered.

Calling it with non-option arguments
$ ./go_test.sh /etc/passwd
$

   The very same case: It wasn't triggered.

Calling it with option-arguments
   Invalid option:

$ ./go_test.sh -b
Invalid option: -b
$

   As expected, as above, getopts didn't accept this option and acted like programmed.

   Valid option, but without the mandatory argument:
$ ./go_test.sh -a
Option -a requires an argument.
$

   The option was okay, but there is an argument missing.

   Let's provide the argument:
$ ./go_test.sh -a /etc/passwd
-a was triggered, Parameter: /etc/passwd
$


---
http://www.bahmanm.com/blogs/command-line-options-how-to-parse-in-bash-using-getopt

Command Line Options: How To Parse In Bash Using “getopt”

   Use “getopt” in a Bash script to parse long and short command line options, enforce arguments for
   some options and spot dubious user input.

Introduction
   Most of the times, when you need to automate system administration tasks on your Linux machine,
   writing a Bash script is your best bet. And sometimes, you need to be able to control the behaviour
   of your script at some point which leaves you with two choices: use environment variables (set before
   running the script) as sort of a flag or the better and more intuitive way to use command line
   arguments.


What is “getopt”?
   getopt is a program that parses command line options in shell scripts. It is the enhanced version of
   older getopts and uses the getopt C library to do its job. It is compatible with getopts as long as
   GETOPT_COMPATIBLE environment variable is set, however some of it best features are not available in
   compatibility mode.


An overview of command options
   Command line input is viewed in 3 categories by getopt: short options (like -a), long options (like
   --some-option) and non-option parameters (like /home/bahman/reports.txt). Also short and long options
   can accept arguments (like -a /home/bahman/Temp or --some-option 'A commit comment').

Short option
   A short option is composed of a - (dash character) followed by a single letter, for example -a or -A,
   and it may expect an argument.
     * Without argument like -a or -H
     * With argument
          + With required arguments like -a bahman or -Hreports
          + With optional arguments like -abahman. Note that there can't be any spaces between the
            option (-a) and the argument (bahman).

Long option
   A long option is composed of a -- (two consequent dash characters) followed by any number of
   alpha-numeric characters (like --option-a) and it may expect an argument.
     * Without argument like --option-a or --more-2-go
     * With arguments
          + With required arguments like --file-to-process reports or
            --package-name-prefix='com.bahmanm'
          + With optional arguments like --package-name-prefix='com.bahmanm'. Note that the argument can
            be passed only using =.


What is an “option string”?
   The only way to tell getopt about the options it should expect is by building an option string.
   Normally you would pass 2 option strings to getopt, one for short options and the other for long
   options.

Option string for short options
   It is passed to getopt using -o option and follows the rules below.

   Rules:
    1. Each single character stands for an option.
    2. A : (colon character) tells that the option has a required argument.
    3. A :: (two consequent colon character) tells that the option has an optional argument.

   Example:
   The option string f:gh::i: means that the are four options. f has a required argument, g has no
   argument, h has an optional argument and i has a required argument.

Option string for long options
   It is passed to getopt using --long option and follows the rules below.

   Rules:
    1. Options are separated by , (comma character).
    2. A : (colon character) tells that the option has a required argument.
    3. A :: (two consequent colon character) tells that the option has an optional argument.

   Example:
   The options string foo,bar::,baz:,foobar means that there are four options. foo has no argument, bar
   has an optional argument, baz has a required argument and foobar has no argument.


Show me some real code!
   Here's a sample Bash script parsing and dealing with options --I hope I've put enough comments in.
<code>
#!/user/bin/env bash

# “a” and “arga” have optional arguments with default values.
# “b” and “argb” have no arguments, acting as sort of a flag.
# “c” and “argc” have required arguments.

# set an initial value for the flag
ARG_B=0

# read the options
TEMP=`getopt -o a::bc: --long arga::,argb,argc: -n 'test.sh' -- "$@"`
eval set -- "$TEMP"

# extract options and their arguments into variables.
while true ; do
    case "$1" in
        -a|--arga)
            case "$2" in
                "") ARG_A='some default value' ; shift 2 ;;
                *) ARG_A=$2 ; shift 2 ;;
            esac ;;
        -b|--argb) ARG_B=1 ; shift ;;
        -c|--argc)
            case "$2" in
                "") shift 2 ;;
                *) ARG_C=$2 ; shift 2 ;;
            esac ;;
        --) shift ; break ;;
        *) echo "Internal error!" ; exit 1 ;;
    esac
done

# do something with the variables -- in this case the lamest possible one :-)
echo "ARG_A = $ARG_A"
echo "ARG_B = $ARG_B"
echo "ARG_C = $ARG_C"
</code>


Conclusion
   You can use getopt to professionally deal with command options in a civilised manner in your Bash
   scripts. No need for dirty tricks.

   Don't forget to read the getopt manpage. There's still some minor topics I haven't covered here, like
   testing for getopt's existence (-T).


---
https://linuxaria.com/howto/parse-options-in-your-bash-script-with-getopt

Parse options in your bash script with getopt

Today i was writing a bash script that should manage some input arguments, and so i studied getopt, this is a
convenient and elegant way to manage input parameters in a bash script. With it you can define switch
(present or not) or parameters with an option, thus making your simple bash script much more professional.

Let’s see how to use this command and its options.
Please note that on Linux there are two different ways of parsing command line arguments. There is an utility
called getopt (man 1 getopt). This utility is available in all shells. Then in bash, there is another built-in
tool for parsing arguments called getopts (it’s a built-in, so it doesn’t have it’s own man-page — try help
getopts). In this article I’ll talk of the first one, after some problems with script not working in dash i
prefer to use external small programs rather than bash built-in commands.

In Debian and Ubuntu the command getopt is contained in the package util-linux that is automatically installed,
i expect that also on other Linux distribution you find it without any need of installing additional packages.

Basic usage
In getopt the parameters are parsed from left to right. Each parameter is classified as a short option, a long
option, an argument to an option, or a non-option parameter.

A simple short option is a `-‘ followed by a short option character. If the option has a required argument, it
may be written directly after the option character or as the next parameter (ie. separated by whitespace on the
command line). If the option has an optional argument, it must be written directly after the option character
if present.

It is possible to specify several short options after one `-‘, as long as all (except possibly the last) do not
have required or optional arguments.

A long option normally begins with `–‘ followed by the long option name. If the option has a required argument,
it may be written directly after the long option name, separated by `=’, or as the next argument (ie. separated
by whitespace on the command line). If the option has an optional argument, it must be written directly after
the long option name, separated by `=’, if present . Long options may be abbreviated, as long as the
abbreviation is not ambiguous.

In my opinion the best way to present the command is with an example.

I want a script that can take the short option -h -1 -2 and -3 with an argument, like -3=Hello, and that can
also manage the following long options –help, –one, –two and –three with an argument.

<code>
#!/bin/bash
 
# Execute getopt on the arguments passed to this program, identified by the special character $@
PARSED_OPTIONS=$(getopt -n "$0"  -o h123: --long "help,one,two,three:"  -- "$@")
 
#Bad arguments, something has gone wrong with the getopt command.
if [ $? -ne 0 ];
then
  exit 1
fi
 
# A little magic, necessary when using getopt.
eval set -- "$PARSED_OPTIONS"
 
# Now goes through all the options with a case and using shift to analyse 1 argument at a time.
# $1 identifies the first argument, and when we use shift we discard the first argument, so $2 becomes $1 and \
    goes again through the case.
while true;
do
  case "$1" in
 
    -h|--help)
      echo "usage $0 -h -1 -2 -3 or $0 --help --one --two --three"
     shift;;
 
    -1|--one)
      echo "One"
      shift;;
 
    -2|--two)
      echo "Dos"
      shift;;
 
    -3|--three)
      echo "Tre"
 
      # We need to take the option of the argument "three"
      if [ -n "$2" ];
      then
        echo "Argument: $2"
      fi
      shift 2;;
 
    --)
      shift
      break;;
  esac
done
</code>

The options we have used with getopt in this example are:

-l, –longoptions (longopts)
The long (multi-character) options to be recognized. More than one option name may be specified at once, by
separating the names with commas. This option may be given more than once, the longopts are cumulative. Each
long option name in longopts may be followed by one colon to indicate it has a required argument, and by two
colons to indicate it has an optional argument.

-o, –options (shortopts)
The short (one-character) options to be recognized. If this option is not found, the first parameter of getopt
that does not start with a `-‘ (and is not an option argument) is used as the short options string. Each short
option character in shortopts may be followed by one colon to indicate it has a required argument, and by two
colons to indicate it has an optional argument.

Conclusions
if you look at the example you can see that is longer to describe how getopt work than using it, you just need
to define the short and long list of options and than manage them with a while loop and a case, and you’ll have
a bash script that can smartly manage options.


---
https://sookocheff.com/post/bash/parsing-bash-script-arguments-with-shopts/

Parsing bash script options with getopts
January 4, 2015

   A common task in shell scripting is to parse command line arguments to your script. Bash provides the
   getopts built-in function to do just that. This tutorial explains how to use the getopts built-in
   function to parse arguments and options to a bash script.

   The getopts function takes three parameters. The first is a specification of which options are valid,
   listed as a sequence of letters. For example, the string 'ht' signifies that the options -h and -t
   are valid.

   The second argument to getopts is a variable that will be populated with the option or argument to be
   processed next. In the following loop, opt will hold the value of the current option that has been
   parsed by getopts.
while getopts ":ht" opt; do
  case ${opt} in
    h ) # process option a
      ;;
    t ) # process option l
      ;;
    \? ) echo "Usage: cmd [-h] [-t]
      ;;
  esac
done

   This example shows a few additional features of getopts. First, if an invalid option is provided, the
   option variable is assigned the value ?. You can catch this case and provide an appropriate usage
   message to the user. Second, this behaviour is only true when you prepend the list of valid options
   with : to disable the default error handling of invalid options. It is recommended to always disable
   the default error handling in your scripts.

   The third argument to getopts is the list of arguments and options to be processed. When not
   provided, this defaults to the arguments and options provided to the application ($@). You can
   provide this third argument to use getopts to parse any list of arguments and options you provide.

Shifting processed options
   The variable OPTIND holds the number of options parsed by the last call to getopts. It is common
   practice to call the shift command at the end of your processing loop to remove options that have
   already been handled from $@.
shift $((OPTIND -1))

Parsing options with arguments
   Options that themselves have arguments are signified with a :. The argument to an option is placed in
   the variable OPTARG. In the following example, the option t takes an argument. When the argument is
   provided, we copy its value to the variable target. If no argument is provided getopts will set opt
   to :. We can recognize this error condition by catching the : case and printing an appropriate error
   message.
while getopts ":t:" opt; do
  case ${opt} in
    t )
      target=$OPTARG
      ;;
    \? )
      echo "Invalid option: $OPTARG" 1>&2
      ;;
    : )
      echo "Invalid option: $OPTARG requires an argument" 1>&2
      ;;
  esac
done
shift $((OPTIND -1))

An extended example – parsing nested arguments and options
   Let’s walk through an extended example of processing a command that takes options, has a sub-command,
   and whose sub-command takes an additional option that has an argument. This is a mouthful so let’s
   break it down using an example. Let’s say we are writing our own version of the [10]pip command. In
   this version you can call pip with the -h option to display a help message.
> pip -h
Usage:
    pip -h                      Display this help message.
    pip install                 Install a Python package.

   We can use getopts to parse the -h option with the following while loop. In it we catch invalid
   options with \? and shift all arguments that have been processed with shift $((OPTIND -1)).
while getopts ":h" opt; do
  case ${opt} in
    h )
      echo "Usage:"
      echo "    pip -h                      Display this help message."
      echo "    pip install                 Install a Python package."
      exit 0
      ;;
    \? )
      echo "Invalid Option: -$OPTARG" 1>&2
      exit 1
      ;;
  esac
done
shift $((OPTIND -1))

   Now let’s add the sub-command install to our script. install takes as an argument the Python package
   to install.
> pip install urllib3

   install also takes an option, -t. -t takes as an argument the location to install the package to
   relative to the current directory.
> pip install urllib3 -t ./src/lib

   To process this line we must find the sub-command to execute. This value is the first argument to our
   script.
subcommand=$1
shift # Remove `pip` from the argument list

   Now we can process the sub-command install. In our example, the option -t is actually an option that
   follows the package argument so we begin by removing install from the argument list and processing
   the remainder of the line.
case "$subcommand" in
  install)
    package=$1
    shift # Remove `install` from the argument list
    ;;
esac

   After shifting the argument list we can process the remaining arguments as if they are of the form
   package -t src/lib. The -t option takes an argument itself. This argument will be stored in the
   variable OPTARG and we save it to the variable target for further work.
case "$subcommand" in
  install)
    package=$1
    shift # Remove `install` from the argument list

  while getopts ":t:" opt; do
    case ${opt} in
      t )
        target=$OPTARG
        ;;
      \? )
        echo "Invalid Option: -$OPTARG" 1>&2
        exit 1
        ;;
      : )
        echo "Invalid Option: -$OPTARG requires an argument" 1>&2
        exit 1
        ;;
    esac
  done
  shift $((OPTIND -1))
  ;;
esac

   Putting this all together, we end up with the following script that parses arguments to our version
   of pip and its sub-command install.

<code>
package=""  # Default to empty package
target=""  # Default to empty target

# Parse options to the `pip` command
while getopts ":h" opt; do
  case ${opt} in
    h )
      echo "Usage:"
      echo "    pip -h                      Display this help message."
      echo "    pip install <package>       Install <package>."
      exit 0
      ;;
   \? )
     echo "Invalid Option: -$OPTARG" 1>&2
     exit 1
     ;;
  esac
done
shift $((OPTIND -1))

subcommand=$1; shift  # Remove 'pip' from the argument list
case "$subcommand" in
  # Parse options to the install sub command
  install)
    package=$1; shift  # Remove 'install' from the argument list

    # Process package options
    while getopts ":t:" opt; do
      case ${opt} in
        t )
          target=$OPTARG
          ;;
        \? )
          echo "Invalid Option: -$OPTARG" 1>&2
          exit 1
          ;;
        : )
          echo "Invalid Option: -$OPTARG requires an argument" 1>&2
          exit 1
          ;;
      esac
    done
    shift $((OPTIND -1))
    ;;
esac
</code>

   After processing the above sequence of commands, the variable package will hold the package to
   install and the variable target will hold the target to install the package to. You can use this as a
   template for processing any set of arguments and options to your scripts.


---
https://gist.github.com/cosimo/3760587

parse-options.sh
Created Sep 21, 2012

<code>
   #!/bin/bash
   #
   # Example of how to parse short/long options with 'getopt'
   #
   OPTS=`getopt -o vhns: --long verbose,dry-run,help,stack-size: -n 'parse-options' -- "$@"`
   if [ $? != 0 ] ; then echo "Failed parsing options." >&2 ; exit 1 ; fi
   echo "$OPTS"
   eval set -- "$OPTS"
   VERBOSE=false
   HELP=false
   DRY_RUN=false
   STACK_SIZE=0
   while true; do
   case "$1" in
   -v | --verbose ) VERBOSE=true; shift ;;
   -h | --help ) HELP=true; shift ;;
   -n | --dry-run ) DRY_RUN=true; shift ;;
   -s | --stack-size ) STACK_SIZE="$2"; shift; shift ;;
   -- ) shift; break ;;
   * ) break ;;
   esac
   done
   echo VERBOSE=$VERBOSE
   echo HELP=$HELP
   echo DRY_RUN=$DRY_RUN
   echo STACK_SIZE=$STACK_SIZE
</code>


***
   Nice. Though a little explanation on what is happening inside the case/esac would help the new-bees.

***
   Do you know how to prevent passing parameters to arguments that doesn't take one ?
   For example
   if i call
   sh parse-options.sh -h hello

   it should throw an error saying that -h doesn't take parameter values

   Do anyone knows how to do it ?

***
   @veera-dr It depends on whether your program takes non-option arguments. If parse-options.sh foo bar
   would be a valid invocation, you would need to follow every single option in your getopt string with
   :: and then test every output option to see if it has an argument attached or not.

   If your program wouldn't normally take any arguments, you could just test for arguments in * and
   throw an error if you find any. For example:
while true; do
    case "$1" in
        -a ) OPT_A=true;;
        -b ) OPT_B=true;;
        -- ) ;;
        * ) if [ -z "$1" ]; then break; else echo "$1 is not a valid option"; exit 1; fi;;
    esac
    shift
done

***
   A subtlety, I woud change shift; shift for shift 2.

***
   As stack-size was the only option that takes a value, it would've been a better idea to not put it
   last:
     * Why's the colon there? does the --long list always end with a colon, or is it part of stack-size
       option definition?
     * It takes a numeric value and getopt's -n switch confused the hell out of me:
          + does it belong to the stack-size: option definition ("takes numeric value?") OR
          + is it something else?

   Upon investigating, it seems to be just a switch to ´getopt´, so IMO this would have been clearer:
getopt -n 'parse-options' -o vhns: --long verbose,stack-size:,dry-run,help -- "$@"`

***
   I have written a faster version by myself which does not need the external program getopt to parse
   long options. It is compatible to bash 3,4 and ksh (fastest). Surely there are more compatible
   shell's but this are the shells I have tested. It is a little bit more advanced than your version but
   easy to maintain.

   
---
https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash

How do I parse command line arguments in Bash?

   Say, I have a script that gets called with this line:
./myscript -vfd ./foo/bar/someFile -o /fizz/someOtherFile

   or this one:
./myscript -v -f -d -o /fizz/someOtherFile ./foo/bar/someFile

   What's the accepted way of parsing this such that in each case (or some combination of the two) $v,
   $f, and $d will all be set to true and $outFile will be equal to /fizz/someOtherFile ?

***
   See my very easy and no-dependency answer here: [37]stackoverflow.com/a/33826763/115363

   For zsh-users there's a great builtin called zparseopts which can do: zparseopts -D -E -M -- d=debug
   -debug=d And have both -d and --debug in the $debug array echo $+debug[1] will return 0 or 1 if one
   of those are used. Ref: [39]zsh.org/mla/users/2011/msg00350.html – [40]dezza Aug 2 '16 at 2:13
   add a comment |

***
Preferred Method: Using straight bash without getopt[s]

   I originally answered the question as the OP asked. This Q/A is getting a lot of attention, so I
   should also offer the non-magic way to do this. I'm going to expand upon [44]guneysus's answer to fix
   the nasty sed and include [45]Tobias Kienzler's suggestion.

   Two of the most common ways to pass key value pair arguments are:

Straight Bash Space Separated

   Usage ./myscript.sh -e conf -s /etc -l /usr/lib /etc/hosts
#!/bin/bash
# Use -gt 1 to consume two arguments per pass in the loop (e.g. each
# argument has a corresponding value to go with it).
# Use -gt 0 to consume one or more arguments per pass in the loop (e.g.
# some arguments don't have a corresponding value to go with it such
# as in the --default example).
# note: if this is set to -gt 0 the /etc/hosts part is not recognized ( may be a bug )
while [[ $# -gt 1 ]]
do
key="$1"

case $key in
    -e|--extension)
    EXTENSION="$2"
    shift # past argument
    ;;
    -s|--searchpath)
    SEARCHPATH="$2"
    shift # past argument
    ;;
    -l|--lib)
    LIBPATH="$2"
    shift # past argument
    ;;
    --default)
    DEFAULT=YES
    ;;
    *)
            # unknown option
    ;;
esac
shift # past argument or value
done
echo FILE EXTENSION  = "${EXTENSION}"
echo SEARCH PATH     = "${SEARCHPATH}"
echo LIBRARY PATH    = "${LIBPATH}"
echo "Number files in SEARCH PATH with EXTENSION:" $(ls -1 "${SEARCHPATH}"/*."${EXTENSION}" | wc -l)
if [[ -n $1 ]]; then
    echo "Last line of file specified as non-opt/last argument:"
    tail -1 $1
fi

Straight Bash Equals Separated

#!/bin/bash

for i in "$@"
do
case $i in
    -e=*|--extension=*)
    EXTENSION="${i#*=}"
    shift # past argument=value
    ;;
    -s=*|--searchpath=*)
    SEARCHPATH="${i#*=}"
    shift # past argument=value
    ;;
    -l=*|--lib=*)
    LIBPATH="${i#*=}"
    shift # past argument=value
    ;;
    --default)
    DEFAULT=YES
    shift # past argument with no value
    ;;
    *)
            # unknown option
    ;;
esac
done
echo "FILE EXTENSION  = ${EXTENSION}"
echo "SEARCH PATH     = ${SEARCHPATH}"
echo "LIBRARY PATH    = ${LIBPATH}"
echo "Number files in SEARCH PATH with EXTENSION:" $(ls -1 "${SEARCHPATH}"/*."${EXTENSION}" | wc -l)
if [[ -n $1 ]]; then
    echo "Last line of file specified as non-opt/last argument:"
    tail -1 $1
fi

   To better understand ${i#*=} search for "Substring Removal" in [46]this guide. It is functionally
   equivalent to `sed 's/[^=]*=//' <<< "$i"` which calls a needless subprocess or `echo "$i" | sed
   's/[^=]*=//'` which calls two needless subprocesses.

Using getopt[s]

   from: http://mywiki.wooledge.org/BashFAQ/035#getopts

   Never use getopt(1). getopt cannot handle empty arguments strings, or arguments with embedded
   whitespace. Please forget that it ever existed.

   The POSIX shell (and others) offer getopts which is safe to use instead. Here is a simplistic getopts
   example:
#!/bin/sh

# A POSIX variable
OPTIND=1         # Reset in case getopts has been used previously in the shell.

# Initialize our own variables:
output_file=""
verbose=0

while getopts "h?vf:" opt; do
    case "$opt" in
    h|\?)
        show_help
        exit 0
        ;;
    v)  verbose=1
        ;;
    f)  output_file=$OPTARG
        ;;
    esac
done

shift $((OPTIND-1))

[ "$1" = "--" ] && shift

echo "verbose=$verbose, output_file='$output_file', Leftovers: $@"

# End of file

   The advantages of getopts are:
    1. It's portable, and will work in e.g. dash.
    2. It can handle things like -vf filename in the expected Unix way, automatically.

   The disadvantage of getopts is that it can only handle short options (-h, not --help) without
   trickery.

   There is a [48]getopts tutorial which explains what all of the syntax and variables mean. In bash,
   there is also help getopts, which might be informative.

***
   Is this really true? According to [54]Wikipedia there's a newer GNU enhanced version of getopt which
   includes all the functionality of getopts and then some. man getopt on Ubuntu 13.04 outputs getopt -
   parse command options (enhanced) as the name, so I presume this enhanced version is standard now.

***
   That something is a certain way on your system is a very weak premise to base asumptions of "being
   standard" on. – [56]szablica Jul 17 '13 at 15:23

***
   If you use -gt 0, remove your shift after the esac, augment all the shift by 1 and add this case: *)
   break;; you can handle non optionnal arguments. Ex: [58]pastebin.com/6DJ57HTc – [59]Nicolas
   Mongrain-Lacombe Jun 19 '16 at 21:22

***
   You do not echo –default. In the first example, I notice that if –default is the last argument, it is
   not processed (considered as non-opt), unless while [[ $# -gt 1 ]] is set as while [[ $# -gt 0 ]]
   – [60]kolydart Jul 10 at 8:11
    |  [61]show 4 more comments
   up vote 201 down vote

***
   No answer mentions enhanced getopt. And the [62]top-voted answer is misleading: It ignores -⁠vfd
   style short options (requested by the OP), options after positional arguments (also requested by the
   OP) and it ignores parsing-errors. Instead:
     * Use enhanced getopt from util-linux or formerly GNU glibc.^[1]
     * It works with getopt_long() the C function of GNU glibc.
     * Has all useful distinguishing features (the others don’t have them):
          + handles spaces, quoting characters and even binary in arguments^[2]
          + it can handle options at the end: script.sh -o outFile file1 file2 -v
          + allows =-style long options: script.sh --outfile=fileOut --infile fileIn
     * Is so old already^[3] that no GNU system is missing this (e.g. any Linux has it).
     * You can test for its existence with: getopt --test → return value 4.
     * Other getopt or shell-builtin getopts are of limited use.

   The following calls
myscript -vfd ./foo/bar/someFile -o /fizz/someOtherFile
myscript -v -f -d -o/fizz/someOtherFile -- ./foo/bar/someFile
myscript --verbose --force --debug ./foo/bar/someFile -o/fizz/someOtherFile
myscript --output=/fizz/someOtherFile ./foo/bar/someFile -vfd
myscript ./foo/bar/someFile -df -v --output /fizz/someOtherFile

   all return
verbose: y, force: y, debug: y, in: ./foo/bar/someFile, out: /fizz/someOtherFile

   with the following myscript
#!/bin/bash

getopt --test > /dev/null
if [[ $? -ne 4 ]]; then
    echo "I’m sorry, `getopt --test` failed in this environment."
    exit 1
fi

OPTIONS=dfo:v
LONGOPTIONS=debug,force,output:,verbose

# -temporarily store output to be able to check for errors
# -activate advanced mode getopt quoting e.g. via “--options”
# -pass arguments only via   -- "$@"   to separate them correctly
PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTIONS --name "$0" -- "$@")
if [[ $? -ne 0 ]]; then
    # e.g. $? == 1
    #  then getopt has complained about wrong arguments to stdout
    exit 2
fi
# use eval with "$PARSED" to properly handle the quoting
eval set -- "$PARSED"

# now enjoy the options in order and nicely split until we see --
while true; do
    case "$1" in
        -d|--debug)
            d=y
            shift
            ;;
        -f|--force)
            f=y
            shift
            ;;
        -v|--verbose)
            v=y
            shift
            ;;
        -o|--output)
            outFile="$2"
            shift 2
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Programming error"
            exit 3
            ;;
    esac
done

# handle non-option arguments
if [[ $# -ne 1 ]]; then
    echo "$0: A single input file is required."
    exit 4
fi

echo "verbose: $v, force: $f, debug: $d, in: $1, out: $outFile"

***
   Thanks for this. Just confirmed from the feature table at [68]en.wikipedia.org/wiki/Getopts, if you
   need support for long options, and you're not on Solaris, getopt is the way to go. – [69]johncip Jan

***
   I believe that the only caveat with getopt is that it cannot be used conveniently in wrapper scripts
   where one might have few options specific to the wrapper script, and then pass the non-wrapper-script
   options to the wrapped executable, intact. Let's say I have a grep wrapper called mygrep and I have
   an option --foo specific to mygrep, then I cannot do mygrep --foo -A 2, and have the -A 2 passed
   automatically to grep; I need to do mygrep --foo -- -A 2.

***
     The simple use of "getopt" is shown in this mini-script:

#!/bin/bash
echo "Before getopt"
for i
do
  echo $i
done
args=`getopt abc:d $*`
set -- $args
echo "After getopt"
for i
do
  echo "-->$i"
done

     What we have said is that any of -a, -b, -c or -d will be allowed, but that -c is followed by an
     argument (the "c:" says that).

     If we call this "g" and try it out:

bash-2.05a$ ./g -abc foo
Before getopt
-abc
foo
After getopt
-->-a
-->-b
-->-c
-->foo
-->--

     We start with two arguments, and "getopt" breaks apart the options and puts each in its own
     argument. It also added "--".

***
   Using $* is broken usage of getopt. (It hoses arguments with spaces.)

***
Usage myscript.sh -p=my_prefix -s=dirname -l=libname

<code>   
#!/bin/bash
for i in "$@"
do
case $i in
    -p=*|--prefix=*)
    PREFIX="${i#*=}"

    ;;
    -s=*|--searchpath=*)
    SEARCHPATH="${i#*=}"
    ;;
    -l=*|--lib=*)
    DIR="${i#*=}"
    ;;
    --default)
    DEFAULT=YES
    ;;
    *)
            # unknown option
    ;;
esac
done
echo PREFIX = ${PREFIX}
echo SEARCH PATH = ${SEARCHPATH}
echo DIRS = ${DIR}
echo DEFAULT = ${DEFAULT}

   To better understand ${i#*=} search for "Substring Removal" in [80]this guide. It is functionally
   equivalent to `sed 's/[^=]*=//' <<< "$i"` which calls a needless subprocess or `echo "$i" | sed
   's/[^=]*=//'` which calls two needless subprocesses.

***
   At the risk of adding another example to ignore, here's my scheme.
     * handles -n arg and --name=arg
     * allows arguments at the end
     * shows sane errors if anything is misspelled
     * compatible, doesn't use bashisms
     * readable, doesn't require maintaining state in a loop

   Hope it's useful to someone.
while [ "$#" -gt 0 ]; do
  case "$1" in
    -n) name="$2"; shift 2;;
    -p) pidfile="$2"; shift 2;;
    -l) logfile="$2"; shift 2;;

    --name=*) name="${1#*=}"; shift 1;;
    --pidfile=*) pidfile="${1#*=}"; shift 1;;
    --logfile=*) logfile="${1#*=}"; shift 1;;
    --name|--pidfile|--logfile) echo "$1 requires an argument" >&2; exit 1;;

    -*) echo "unknown option: $1" >&2; exit 1;;
    *) handle_argument "$1"; shift 1;;
  esac
done

***
   What is the "handle_argument" function? – [92]rhombidodecahedron Sep 11 '15 at 8:40

***
   Sorry for the delay. In my script, the handle_argument function receives all the non-option
   arguments. You can replace that line with whatever you'd like, maybe *) die "unrecognized argument:
   $1" or collect the args into a variable *) args+="$1"; shift 1;;. – [93]bronson Oct 8 '15 at 20:41

***
   I'm about 4 years late to this question, but want to give back. I used the earlier answers as a
   starting point to tidy up my old adhoc param parsing. I then refactored out the following template
   code. It handles both long and short params, using = or space separated arguments, as well as
   multiple short params grouped together. Finally it re-inserts any non-param arguments back into the
   $1,$2.. variables. I hope it's useful.
#!/usr/bin/env bash

# NOTICE: Uncomment if your script depends on bashisms.
#if [ -z "$BASH_VERSION" ]; then bash $0 $@ ; exit $? ; fi

echo "Before"
for i ; do echo - $i ; done


# Code template for parsing command line parameters using only portable shell
# code, while handling both long and short params, handling '-f file' and
# '-f=file' style param data and also capturing non-parameters to be inserted
# back into the shell positional parameters.

while [ -n "$1" ]; do
        # Copy so we can modify it (can't modify $1)
        OPT="$1"
        # Detect argument termination
        if [ x"$OPT" = x"--" ]; then
                shift
                for OPT ; do
                        REMAINS="$REMAINS \"$OPT\""
                done
                break
        fi
        # Parse current opt
        while [ x"$OPT" != x"-" ] ; do
                case "$OPT" in
                        # Handle --flag=value opts like this
                        -c=* | --config=* )
                                CONFIGFILE="${OPT#*=}"
                                shift
                                ;;
                        # and --flag value opts like this
                        -c* | --config )
                                CONFIGFILE="$2"
                                shift
                                ;;
                        -f* | --force )
                                FORCE=true
                                ;;
                        -r* | --retry )
                                RETRY=true
                                ;;
                        # Anything unknown is recorded for later
                        * )
                                REMAINS="$REMAINS \"$OPT\""
                                break
                                ;;
                esac
                # Check for multiple short options
                # NOTICE: be sure to update this pattern to match valid options
                NEXTOPT="${OPT#-[cfr]}" # try removing single short opt
                if [ x"$OPT" != x"$NEXTOPT" ] ; then
                        OPT="-$NEXTOPT"  # multiple short opts, keep going
                else
                        break  # long form, exit inner loop
                fi
        done
        # Done with that param. move to next
        shift
done
# Set the non-parameters back into the positional parameters ($1 $2 ..)
eval set -- $REMAINS


echo -e "After: \n configfile='$CONFIGFILE' \n force='$FORCE' \n retry='$RETRY' \n remains='$REMAINS'"
for i ; do echo - $i ; done

***
   This code can’t handle options with arguments like this: -c1. And the use of = to separate short
   options from their arguments is unusual... – [98]Robert Siemer Dec 6 '15 at 13:47

***
   I ran into two problems with this useful chunk of code: 1) the "shift" in the case of "-c=foo" ends
   up eating the next parameter; and 2) 'c' should not be included in the "[cfr]" pattern for combinable
   short options. – [99]sfnd Jun 6 '16 at 19:28

***
More Succinct way to do is:

while [[ "$#" > 1 ]]; do case $1 in
    --deploy) deploy="$2";;
    --uglify) uglify="$2";;
    *) break;;
  esac; shift; shift
done

echo "Should deploy? $deploy"
echo "Should uglify? $uglify"

***
   My answer is largely based on [110]the answer by Bruno Bronosky, but I sort of mashed his two pure
   bash implementations into one that I use pretty frequently.
# As long as there is at least one more argument, keep looping
while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
        # This is a flag type option. Will catch either -f or --foo
        -f|--foo)
        FOO=1
        ;;
        # Also a flag type option. Will catch either -b or --bar
        -b|--bar)
        BAR=1
        ;;
        # This is an arg value type option. Will catch -o value or --output-file value
        -o|--output-file)
        shift # past the key and to the value
        OUTPUTFILE="$1"
        ;;
        # This is an arg=value type option. Will catch -o=value or --output-file=value
        -o=*|--output-file=*)
        # No need to shift here since the value is part of the same string
        OUTPUTFILE="${key#*=}"
        ;;
        *)
        # Do whatever you want with extra options
        echo "Unknown option '$key'"
        ;;
    esac
    # Shift after checking all the cases to get the next option
    shift
done

   This allows you to have both space separated options/values, as well as equal defined values.

   So you could run your script using:
./myscript --foo -b -o /fizz/file.txt

   as well as:
./myscript -f --bar -o=/fizz/file.txt

   and both should have the same end result.

   PROS:
     * Allows for both -arg=value and -arg value
     * Works with any arg name that you can use in bash
          + Meaning -a or -arg or --arg or -a-r-g or whatever
     * Pure bash. No need to learn/use getopt or getopts

   CONS:
     * Can't combine args
          + Meaning no -abc. You must do -a -b -c

***
   I think this one is simple enough to use:
#!/bin/bash
#

readopt='getopts $opts opt;rc=$?;[ $rc$opt == 0? ]&&exit 1;[ $rc == 0 ]||{ shift $[OPTIND-1];false; }'

opts=vfdo:

# Enumerating options
while eval $readopt
do
    echo OPT:$opt ${OPTARG+OPTARG:$OPTARG}
done

# Enumerating arguments
for arg
do
    echo ARG:$arg
done

   Invocation example:
./myscript -v -do /fizz/someOtherFile -f ./foo/bar/someFile
OPT:v
OPT:d
OPT:o OPTARG:/fizz/someOtherFile
OPT:f
ARG:./foo/bar/someFile

***
   Expanding on the excellent answer by @guneysus, here is a tweak that lets user use whichever syntax
   they prefer, eg
command -x=myfilename.ext --another_switch

   vs
command -x myfilename.ext --another_switch

   That is to say the equals can be replaced with whitespace.

   This "fuzzy interpretation" might not be to your liking, but if you are making scripts that are
   interchangeable with other utilities (as is the case with mine, which must work with ffmpeg), the
   flexibility is useful.
STD_IN=0

prefix=""
key=""
value=""
for keyValue in "$@"
do
  case "${prefix}${keyValue}" in
    -i=*|--input_filename=*)  key="-i";     value="${keyValue#*=}";;
    -ss=*|--seek_from=*)      key="-ss";    value="${keyValue#*=}";;
    -t=*|--play_seconds=*)    key="-t";     value="${keyValue#*=}";;
    -|--stdin)                key="-";      value=1;;
    *)                                      value=$keyValue;;
  esac
  case $key in
    -i) MOVIE=$(resolveMovie "${value}");  prefix=""; key="";;
    -ss) SEEK_FROM="${value}";          prefix=""; key="";;
    -t)  PLAY_SECONDS="${value}";           prefix=""; key="";;
    -)   STD_IN=${value};                   prefix=""; key="";;
    *)   prefix="${keyValue}=";;
  esac
done

***
   This is how I do in a function to avoid breaking getopts run at the same time somewhere higher in
   stack:
function waitForWeb () {
   local OPTIND=1 OPTARG OPTION
   local host=localhost port=8080 proto=http
   while getopts "h:p:r:" OPTION; do
      case "$OPTION" in
      h)
         host="$OPTARG"
         ;;
      p)
         port="$OPTARG"
         ;;
      r)
         proto="$OPTARG"
         ;;
      esac
   done
...
}

***
   getopts works great if #1 you have it installed and #2 you intend to run it on the same platform. OSX
   and Linux (for example) behave differently in this respect.

   Here is a (non getopts) solution that supports equals, non-equals, and boolean flags. For example you
   could run your script in this way:
./script --arg1=value1 --arg2 value2 --shouldClean

# parse the arguments.
COUNTER=0
ARGS=("$@")
while [ $COUNTER -lt $# ]
do
    arg=${ARGS[$COUNTER]}
    let COUNTER=COUNTER+1
    nextArg=${ARGS[$COUNTER]}

    if [[ $skipNext -eq 1 ]]; then
        echo "Skipping"
        skipNext=0
        continue
    fi

    argKey=""
    argVal=""
    if [[ "$arg" =~ ^\- ]]; then
        # if the format is: -key=value
        if [[ "$argKey" =~ \= ]]; then
            argVal=$(echo "$argKey" | cut -d'=' -f2)
            argKey=$(echo "$argKey" | cut -d'=' -f1)
            skipNext=0

        # if the format is: -key value
        elif [[ ! "$nextArg" =~ ^\- ]]; then
            argKey="$arg"
            argVal="$nextArg"
            skipNext=1

        # if the format is: -key (a boolean flag)
        elif [[ "$nextArg" =~ ^\- ]] || [[ -z "$nextArg" ]]; then
            argKey="$arg"
            argVal=""
            skipNext=0
        fi
    # if the format has not flag, just a value.
    else
        argKey=""
        argVal="$arg"
        skipNext=0
    fi

    case "$argKey" in
        --source-scmurl)
            SOURCE_URL="$argVal"
        ;;
        --dest-scmurl)
            DEST_URL="$argVal"
        ;;
        --version-num)
            VERSION_NUM="$argVal"
        ;;
        -c|--clean)
            CLEAN_BEFORE_START="1"
        ;;
        -h|--help|-help|--h)
            showUsage
            exit
        ;;
    esac
done

***
   I'd like to offer my version of option parsing, that allows for the following:
-s p1
--stage p1
-w somefolder
--workfolder somefolder
-sw p1 somefolder
-e=hello

   Also allows for this (could be unwanted):
-s--workfolder p1 somefolder
-se=hello p1
-swe=hello p1 somefolder

   You have to decide before use if = is to be used on an option or not. This is to keep the code
   clean(ish).
while [[ $# > 0 ]]
do
    key="$1"
    while [[ ${key+x} ]]
    do
        case $key in
            -s*|--stage)
                STAGE="$2"
                shift # option has parameter
                ;;
            -w*|--workfolder)
                workfolder="$2"
                shift # option has parameter
                ;;
            -e=*)
                EXAMPLE="${key#*=}"
                break # option has been fully handled
                ;;
            *)
                # unknown option
                echo Unknown option: $key #1>&2
                exit 10 # either this: my preferred way to handle unknown options
                break # or this: do this to signal the option has been handled (if exit isn't used)
                ;;
        esac
        # prepare for next option in this key, if any
        [[ "$key" = -? || "$key" == --* ]] && unset key || key="${key/#-?/-}"
    done
    shift # option(s) fully processed, proceed to next input argument
done

***
   what's the meaning for "+x" on ${key+x} ? – [146]Luca Davanzo Nov 14 '16 at 17:56

***
   It is a test to see if 'key' is present or not. Further down I unset key and this breaks the inner
   while loop.

***
   [148]EasyOptions does not require any parsing:
## Options:
##   --verbose, -v  Verbose mode
##   --output=FILE  Output filename

source easyoptions || exit

if test -n "${verbose}"; then
    echo "output file is ${output}"
    echo "${arguments[@]}"
fi

***
   I give you The Function parse_params that will parse params:
    1. Without polluting global scope.
    2. Effortlessly returns to you ready to use variables so that you could build further logic on them
    3. Amount of dashes before params does not matter (--all equals -all equals all=all)

   The script below is a copy-paste working demonstration. See show_use function to understand how to
   use parse_params.

   Limitations:
    1. Does not support space delimited params (-d 1)
    2. Param names will lose dashes so --any-param and -anyparam are equivalent
    3. eval $(parse_params "$@") must be used inside bash function (it will not work in the global
       scope)
     ________________________________________________________________________________________________

#!/bin/bash

# Universal Bash parameter parsing
# Parse equals separated params into named local variables
# Standalone named parameter value will equal param name (--force creates variable $force=="force")
# Parses multi-valued named params into array (--path=path1 --path=path2 creates ${path[*]} array)
# Parses un-named params into ${ARGV[*]} array
# @author Oleksii Chekulaiev
# @version v1.2 (Aug-24-2017)
parse_params ()
{
    local existing_named
    local ARGV=()
    echo "local ARGV=(); "
    while [[ "$1" != "" ]]; do
        # If equals delimited named parameter
        if [[ "$1" =~ ^..*=..* ]]; then
            # key is part before first =
            local _key=$(echo "$1" | cut -d = -f 1)
            # val is everything after key and = (protect from param==value error)
            local _val="${1/$_key=}"
            # remove dashes from key name
            _key=${_key//\-}
            # search for existing parameter name
            if (echo "$existing_named" | grep "\b$_key\b" >/dev/null); then
                # if name already exists then it's a multi-value named parameter
                # re-declare it as an array if needed
                if ! (declare -p _key 2> /dev/null | grep -q 'declare \-a'); then
                    echo "$_key=(\"\$$_key\");"
                fi
                # append new value
                echo "$_key+=('$_val');"
            else
                # single-value named parameter
                echo "local $_key=\"$_val\";"
                existing_named=" $_key"
            fi
        # If standalone named parameter
        elif [[ "$1" =~ ^\-. ]]; then
            # remove dashes
            local _key=${1//\-}
            echo "local $_key=\"$_key\";"
        # non-named parameter
        else
            # escape asterisk to prevent bash asterisk expansion
            _escaped=${1/\*/\'\"*\"\'}
            echo "ARGV+=('$_escaped');"
        fi
        shift
    done
}

#--------------------------- DEMO OF THE USAGE -------------------------------

show_use ()
{
    eval $(parse_params "$@")
    # --
    echo "${ARGV[0]}"
    echo "${ARGV[1]}"
    echo "$anyparam"
    echo "$k"
    echo "${multivalue[0]}"
    echo "${multivalue[1]}"
    [[ "$force" == "force" ]] && echo "\$force is set so let the force be with you"
}

show_use "param 1" --anyparam="my value" param2 k=5 --force --multi-value=test1 --multi-value=test2

***
   To use the demo to parse params that come into your bash script you just do show_use "$@"

***
   Basically I found out that [158]github.com/renatosilva/easyoptions does the same in the same way but
   is a bit more massive than this function. – [159]Oleksii Chekulaiev Sep 28 '16 at 12:58

***
Mixing positional and flag-based arguments

--param=arg (equals delimited)

   Freely mixing flags between positional arguments:
./script.sh dumbo 127.0.0.1 --environment=production -q -d
./script.sh dumbo --environment=production 127.0.0.1 --quiet -d

   can be accomplished with a fairly concise approach:
# process flags
pointer=1
while [[ $pointer -le $# ]]; do
   param=${!pointer}
   if [[ $param != "-"* ]]; then ((pointer++)) # not a parameter flag so advance pointer
   else
      case $param in
         # paramter-flags with arguments
         -e=*|--environment=*) environment="${param#*=}";;
                  --another=*) another="${param#*=}";;

         # binary flags
         -q|--quiet) quiet=true;;
                 -d) debug=true;;
      esac

      # splice out pointer frame from positional list
      [[ $pointer -gt 1 ]] \
         && set -- ${@:1:((pointer - 1))} ${@:((pointer + 1)):$#} \
         || set -- ${@:((pointer + 1)):$#};
   fi
done

# positional remain
node_name=$1
ip_address=$2

--param arg (space delimited)

   It's usualy clearer to not mix --flag=value and --flag value styles.
./script.sh dumbo 127.0.0.1 --environment production -q -d

   This is a little dicey to read, but is still valid
./script.sh dumbo --environment production 127.0.0.1 --quiet -d

   Source
# process flags
pointer=1
while [[ $pointer -le $# ]]; do
   if [[ ${!pointer} != "-"* ]]; then ((pointer++)) # not a parameter flag so advance pointer
   else
      param=${!pointer}
      ((pointer_plus = pointer + 1))
      slice_len=1

      case $param in
         # paramter-flags with arguments
         -e|--environment) environment=${!pointer_plus}; ((slice_len++));;
                --another) another=${!pointer_plus}; ((slice_len++));;

         # binary flags
         -q|--quiet) quiet=true;;
                 -d) debug=true;;
      esac

      # splice out pointer frame from positional list
      [[ $pointer -gt 1 ]] \
         && set -- ${@:1:((pointer - 1))} ${@:((pointer + $slice_len)):$#} \
         || set -- ${@:((pointer + $slice_len)):$#};
   fi
done

# positional remain
node_name=$1
ip_address=$2

***
   Note that getopt(1) was a short living mistake from AT&T.

   getopt was created in 1984 but already buried in 1986 because it was not really usable.

   A proof for the fact that getopt is very outdated is that the getopt(1) man page still mentions "$*"
   instead of "$@", that was added to the Bourne Shell in 1986 together with the getopts(1) shell
   builtin in order to deal with arguments with spaces inside.

   BTW: if you are interested in parsing long options in shell scripts, it may be of interest to know
   that the getopt(3) implementation from libc (Solaris) and ksh93 both added a uniform long option
   implementation that supports long options as aliases for short options. This causes ksh93 and the
   Bourne Shell to implement a uniform interface for long options via getopts.

   An example for long options taken from the Bourne Shell man page:

   getopts "f:(file)(input-file)o:(output-file)" OPTX "$@"

   shows how long option aliases may be used in both Bourne Shell and ksh93.

   See the man page of a recent Bourne Shell:

   [163]http://schillix.sourceforge.net/man/man1/bosh.1.html

   and the man page for getopt(3) from OpenSolaris:

   [164]http://schillix.sourceforge.net/man/man3c/getopt.3c.html

   and last, the getopt(1) man page to verify the outdated $*:

***
   Here is my improved solution of Bruno Bronosky's answer using variable arrays.

   it lets you mix parameters position and give you a parameter array preserving the order without the
   options
#!/bin/bash

echo $@

PARAMS=()
SOFT=0
SKIP=()
for i in "$@"
do
case $i in
    -n=*|--skip=*)
    SKIP+=("${i#*=}")
    shift # past argument=value
    ;;
    -s|--soft)
    SOFT=1
    shift # past argument=value
    ;;
    *)
        # unknown option
        PARAMS+=("$i")
    ;;
esac
done
echo "SKIP            = ${SKIP[@]}"
echo "SOFT            = $SOFT"
    echo "Parameters:"
    echo ${PARAMS[@]}

   Will output for example:
$ ./test.sh parameter -s somefile --skip=.c --skip=.obj
parameter -s somefile --skip=.c --skip=.obj
SKIP            = .c .obj
SOFT            = 1
Parameters:
parameter somefile

   [170]share|[171]improve this answer
         [172]edited Oct 7 '15 at 8:29
   answered Oct 6 '15 at 8:53
   [173]Masadow
   419210
   add a comment |
   up vote 1 down vote

Solution that preserves unhandled arguments. Demos Included.

   Here is my solution. It is VERY flexible and unlike others, shouldn't require external packages and
   handles leftover arguments cleanly.

   Usage is: ./myscript -flag flagvariable -otherflag flagvar2

   All you have to do is edit the validflags line. It prepends a hyphen and searches all arguments. It
   then defines the next argument as the flag name e.g.
./myscript -flag flagvariable -otherflag flagvar2
echo $flag $otherflag
flagvariable flagvar2

   The main code (short version, verbose with examples further down, also a version with erroring out):
#!/usr/bin/env bash
#shebang.io
validflags="rate time number"
count=1
for arg in $@
do
    match=0
    argval=$1
    for flag in $validflags
    do
        sflag="-"$flag
        if [ "$argval" == "$sflag" ]
        then
            declare $flag=$2
            match=1
        fi
    done
        if [ "$match" == "1" ]
    then
        shift 2
    else
        leftovers=$(echo $leftovers $argval)
        shift
    fi
    count=$(($count+1))
done
#Cleanup then restore the leftovers
shift $#
set -- $leftovers

   The verbose version with built in echo demos:
#!/usr/bin/env bash
#shebang.io
rate=30
time=30
number=30
echo "all args
$@"
validflags="rate time number"
count=1
for arg in $@
do
    match=0
    argval=$1
#   argval=$(echo $@ | cut -d ' ' -f$count)
    for flag in $validflags
    do
            sflag="-"$flag
        if [ "$argval" == "$sflag" ]
        then
            declare $flag=$2
            match=1
        fi
    done
        if [ "$match" == "1" ]
    then
        shift 2
    else
        leftovers=$(echo $leftovers $argval)
        shift
    fi
    count=$(($count+1))
done

#Cleanup then restore the leftovers
echo "pre final clear args:
$@"
shift $#
echo "post final clear args:
$@"
set -- $leftovers
echo "all post set args:
$@"
echo arg1: $1 arg2: $2

echo leftovers: $leftovers
echo rate $rate time $time number $number

   Final one, this one errors out if an invalid -argument is passed through.
#!/usr/bin/env bash
#shebang.io
rate=30
time=30
number=30
validflags="rate time number"
count=1
for arg in $@
do
    argval=$1
    match=0
        if [ "${argval:0:1}" == "-" ]
    then
        for flag in $validflags
        do
                sflag="-"$flag
            if [ "$argval" == "$sflag" ]
            then
                declare $flag=$2
                match=1
            fi
        done
        if [ "$match" == "0" ]
        then
            echo "Bad argument: $argval"
            exit 1
        fi
        shift 2
    else
        leftovers=$(echo $leftovers $argval)
        shift
    fi
    count=$(($count+1))
done
#Cleanup then restore the leftovers
shift $#
set -- $leftovers
echo rate $rate time $time number $number
echo leftovers: $leftovers

   Pros: What it does, it handles very well. It preserves unused arguments which a lot of the other
   solutions here don't. It also allows for variables to be called without being defined by hand in the
   script. It also allows prepopulation of variables if no corresponding argument is given. (See verbose
   example).

   Cons: Can't parse a single complex arg string e.g. -xcvf would process as a single argument. You
   could somewhat easily write additional code into mine that adds this functionality though.

***
   The top answer to this question seemed a bit buggy when I tried it -- here's my solution which I've
   found to be more robust:
boolean_arg=""
arg_with_value=""

while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    -b|--boolean-arg)
    boolean_arg=true
    shift
    ;;
    -a|--arg-with-value)
    arg_with_value="$2"
    shift
    shift
    ;;
    -*)
    echo "Unknown option: $1"
    exit 1
    ;;
    *)
    arg_num=$(( $arg_num + 1 ))
    case $arg_num in
        1)
        first_normal_arg="$1"
        shift
        ;;
        2)
        second_normal_arg="$1"
        shift
        ;;
        *)
        bad_args=TRUE
    esac
    ;;
esac
done

# Handy to have this here when adding arguments to
# see if they're working. Just edit the '0' to be '1'.
if [[ 0 == 1 ]]; then
    echo "first_normal_arg: $first_normal_arg"
    echo "second_normal_arg: $second_normal_arg"
    echo "boolean_arg: $boolean_arg"
    echo "arg_with_value: $arg_with_value"
    exit 0
fi

if [[ $bad_args == TRUE || $arg_num < 2 ]]; then
    echo "Usage: $(basename "$0") <first-normal-arg> <second-normal-arg> [--boolean-arg] [--arg-with-value VAL
UE]"
    exit 1
fi

***
   Here is my approach - using regexp.
     * no getopts
     * it handles block of short parameters -qwerty
     * it handles short parameters -q -w -e
     * it handles long options --qwerty
     * you can pass attribute to short or long option (if you are using block of short options,
       attribute is attached to the last option)
     * you can use spaces or = to provide attributes, but attribute matches until encountering
       hyphen+space "delimiter", so in --q=qwe ty qwe ty is one attribute
     * it handles mix of all above so -o a -op attr ibute --option=att ribu te --op-tion attribute
       --option att-ribute is valid

   script:
#!/usr/bin/env sh

help_menu() {
  echo "Usage:

  ${0##*/} [-h][-l FILENAME][-d]

Options:

  -h, --help
    display this help and exit

  -l, --logfile=FILENAME
    filename

  -d, --debug
    enable debug
  "
}

parse_options() {
  case $opt in
    h|help)
      help_menu
      exit
     ;;
    l|logfile)
      logfile=${attr}
      ;;
    d|debug)
      debug=true
      ;;
    *)
      echo "Unknown option: ${opt}\nRun ${0##*/} -h for help.">&2
      exit 1
  esac
}
options=$@

until [ "$options" = "" ]; do
  if [[ $options =~ (^ *(--([a-zA-Z0-9-]+)|-([a-zA-Z0-9-]+))(( |=)(([\_\.\?\/\\a-zA-Z0-9]?[ -]?[\_\.\?a-zA-Z0-
9]+)+))?(.*)|(.+)) ]]; then
    if [[ ${BASH_REMATCH[3]} ]]; then # for --option[=][attribute] or --option[=][attribute]
      opt=${BASH_REMATCH[3]}
      attr=${BASH_REMATCH[7]}
      options=${BASH_REMATCH[9]}
    elif [[ ${BASH_REMATCH[4]} ]]; then # for block options -qwert[=][attribute] or single short option -a[=][
attribute]
      pile=${BASH_REMATCH[4]}
      while (( ${#pile} > 1 )); do
        opt=${pile:0:1}
        attr=""
        pile=${pile/${pile:0:1}/}
        parse_options
      done
      opt=$pile
      attr=${BASH_REMATCH[7]}
      options=${BASH_REMATCH[9]}
    else # leftovers that don't match
      opt=${BASH_REMATCH[10]}
      options=""
    fi
    parse_options
  fi
done

***
   Like this one. Maybe just add -e param to echo with new line. – [192]mauron85 Jun 21 at 6:03


***
   This also might be useful to know, you can set a value and if someone provides input, override the
   default with that value..

   myscript.sh -f ./serverlist.txt or just ./myscript.sh (and it takes defaults)
    #!/bin/bash
    # --- set the value, if there is inputs, override the defaults.

    HOME_FOLDER="${HOME}/owned_id_checker"
    SERVER_FILE_LIST="${HOME_FOLDER}/server_list.txt"

    while [[ $# > 1 ]]
    do
    key="$1"
    shift

    case $key in
        -i|--inputlist)
        SERVER_FILE_LIST="$1"
        shift
        ;;
    esac
    done


    echo "SERVER LIST   = ${SERVER_FILE_LIST}"

***
Another solution without getopt[s], POSIX, old Unix style

   Similar to [200]the solution Bruno Bronosky posted this here is one without the usage of getopt(s).

   Main differentiating feature of my solution is that it allows to have options concatenated together
   just like tar -xzf foo.tar.gz is equal to tar -x -z -f foo.tar.gz. And just like in tar, ps etc. the
   leading hyphen is optional for a block of short options (but this can be changed easily). Long
   options are supported as well (but when a block starts with one then two leading hyphens are
   required).

Code with example options

#!/bin/sh

echo
echo "POSIX-compliant getopt(s)-free old-style-supporting option parser from phk@[se.unix]"
echo

print_usage() {
  echo "Usage:

  $0 {a|b|c} [ARG...]

Options:

  --aaa-0-args
  -a
    Option without arguments.

  --bbb-1-args ARG
  -b ARG
    Option with one argument.

  --ccc-2-args ARG1 ARG2
  -c ARG1 ARG2
    Option with two arguments.

" >&2
}

if [ $# -le 0 ]; then
  print_usage
  exit 1
fi

opt=
while :; do

  if [ $# -le 0 ]; then

    # no parameters remaining -> end option parsing
    break

  elif [ ! "$opt" ]; then

    # we are at the beginning of a fresh block
    # remove optional leading hyphen and strip trailing whitespaces
    opt=$(echo "$1" | sed 's/^-\?\([a-zA-Z0-9\?-]*\)/\1/')

  fi

  # get the first character -> check whether long option
  first_chr=$(echo "$opt" | awk '{print substr($1, 1, 1)}')
  [ "$first_chr" = - ] && long_option=T || long_option=F

  # note to write the options here with a leading hyphen less
  # also do not forget to end short options with a star
  case $opt in

    -)

      # end of options
      shift
      break
      ;;

    a*|-aaa-0-args)

      echo "Option AAA activated!"
      ;;

    b*|-bbb-1-args)

      if [ "$2" ]; then
        echo "Option BBB with argument '$2' activated!"
        shift
      else
        echo "BBB parameters incomplete!" >&2
        print_usage
        exit 1
      fi
      ;;

    c*|-ccc-2-args)

      if [ "$2" ] && [ "$3" ]; then
        echo "Option CCC with arguments '$2' and '$3' activated!"
        shift 2
      else
        echo "CCC parameters incomplete!" >&2
        print_usage
        exit 1
      fi
      ;;

    h*|\?*|-help)

      print_usage
      exit 0
      ;;

    *)

      if [ "$long_option" = T ]; then
        opt=$(echo "$opt" | awk '{print substr($1, 2)}')
      else
        opt=$first_chr
      fi
      printf 'Error: Unknown option: "%s"\n' "$opt" >&2
      print_usage
      exit 1
      ;;

  esac

  if [ "$long_option" = T ]; then

    # if we had a long option then we are going to get a new block next
    shift
    opt=

  else

    # if we had a short option then just move to the next character
    opt=$(echo "$opt" | awk '{print substr($1, 2)}')

    # if block is now empty then shift to the next one
    [ "$opt" ] || shift

  fi

done

echo "Doing something..."

exit 0

   For the example usage please see the examples further below.

Position of options with arguments
   For what its worth there the options with arguments don't be the last (only long options need to be).
   So while e.g. in tar (at least in some implementations) the f options needs to be last because the
   file name follows (tar xzf bar.tar.gz works but tar xfz bar.tar.gz does not) this is not the case
   here (see the later examples).

Multiple options with arguments
   As another bonus the option parameters are consumed in the order of the options by the parameters
   with required options. Just look at the output of my script here with the command line abc X Y Z (or
   -abc X Y Z):
Option AAA activated!
Option BBB with argument 'X' activated!
Option CCC with arguments 'Y' and 'Z' activated!

Long options concatenated as well

   Also you can also have long options in option block given that they occur last in the block. So the
   following command lines are all equivalent (including the order in which the options and its
   arguments are being processed):
     * -cba Z Y X
     * cba Z Y X
     * -cb-aaa-0-args Z Y X
     * -c-bbb-1-args Z Y X -a
     * --ccc-2-args Z Y -ba X
     * c Z Y b X a
     * -c Z Y -b X -a
     * --ccc-2-args Z Y --bbb-1-args X --aaa-0-args

   All of these lead to:
Option CCC with arguments 'Z' and 'Y' activated!
Option BBB with argument 'X' activated!
Option AAA activated!
Doing something...

Not in this solution

Optional arguments
   Options with optional arguments should be possible with a bit of work, e.g. by looking forward
   whether there is a block without a hyphen; the user would then need to put a hyphen in front of every
   block following a block with a parameter having an optional parameter. Maybe this is too complicated
   to communicate to the user so better just require a leading hyphen altogether in this case.

   Things get even more complicated with multiple possible parameters. I would advise against making the
   options trying to be smart by determining whether the an argument might be for it or not (e.g. with
   an option just takes a number as an optional argument) because this might break in the future.

   I personally favor additional options instead of optional arguments.

Option arguments introduced with an equal sign
   Just like with optional arguments I am not a fan of this (BTW, is there a thread for discussing the
   pros/cons of different parameter styles?) but if you want this you could probably implement it
   yourself just like done at [201]http://mywiki.wooledge.org/BashFAQ/035#Manual_loop with a
   --long-with-arg=?* case statement and then stripping the equal sign (this is BTW the site that says
   that making parameter concatenation is possible with some effort but "left [it] as an exercise for
   the reader" which made me take them at their word but I started from scratch).

Other notes
   POSIX-compliant, works even on ancient Busybox setups I had to deal with (with e.g. cut, head and
   getopts missing).

***
   This example shows how to use getopt and eval and HEREDOC and shift to handle short and long
   parameters with and without a required value that follows. Also the switch/case statement is concise
   and easy to follow.
#!/usr/bin/env bash

# usage function
function usage()
{
   cat << HEREDOC

   Usage: $progname [--num NUM] [--time TIME_STR] [--verbose] [--dry-run]

   optional arguments:
     -h, --help           show this help message and exit
     -n, --num NUM        pass in a number
     -t, --time TIME_STR  pass in a time string
     -v, --verbose        increase the verbosity of the bash script
     --dry-run            do a dry run, don't change any files

HEREDOC
}

# initialize variables
progname=$(basename $0)
verbose=0
dryrun=0
num_str=
time_str=

# use getopt and store the output into $OPTS
# note the use of -o for the short options, --long for the long name options
# and a : for any option that takes a parameter
OPTS=$(getopt -o "hn:t:v" --long "help,num:,time:,verbose,dry-run" -n "$progname" -- "$@")
if [ $? != 0 ] ; then echo "Error in command line arguments." >&2 ; usage; exit 1 ; fi
eval set -- "$OPTS"

while true; do
  # uncomment the next line to see how shift is working
  # echo "\$1:\"$1\" \$2:\"$2\""
  case "$1" in
    -h | --help ) usage; exit; ;;
    -n | --num ) num_str="$2"; shift 2 ;;
    -t | --time ) time_str="$2"; shift 2 ;;
    --dry-run ) dryrun=1; shift ;;
    -v | --verbose ) verbose=$((verbose + 1)); shift ;;
    -- ) shift; break ;;
    * ) break ;;
  esac
done

if (( $verbose > 0 )); then

   # print out all the parameters we read in
   cat <<-EOM
   num=$num_str
   time=$time_str
   verbose=$verbose
   dryrun=$dryrun
EOM
fi

# The rest of your script below

   The most significant lines of the script above are these:
OPTS=$(getopt -o "hn:t:v" --long "help,num:,time:,verbose,dry-run" -n "$progname" -- "$@")
if [ $? != 0 ] ; then echo "Error in command line arguments." >&2 ; exit 1 ; fi
eval set -- "$OPTS"

while true; do
  case "$1" in
    -h | --help ) usage; exit; ;;
    -n | --num ) num_str="$2"; shift 2 ;;
    -t | --time ) time_str="$2"; shift 2 ;;
    --dry-run ) dryrun=1; shift ;;
    -v | --verbose ) verbose=$((verbose + 1)); shift ;;
    -- ) shift; break ;;
    * ) break ;;
  esac
done

   Short, to the point, readable, and handles just about everything (IMHO).


---
https://unix.stackexchange.com/questions/140840/using-getopts-to-parse-options-after-a-non-option-argument

Using getopts to parse options after a non-option argument

   I have a bash script as below in a file nepleaks_upd.sh, that I want to run as ./nepleaks_upd.sh
   bootstrap --branch off. Couldn't make it to take --branch , but what it works with is
   ./nepleaks_upd.sh bootstrap -b off.
usage() { echo "Usage: $0 [prepare | up | down]  [-b <on/off>]" 1>&2; exit 1; }


case "$1" in
               bootstrap)
                  while getopts ":b:" o; do
                   case "${o}" in
                    b)
                        b=${OPTARG}
                        if [ ${b} == "off" ]; then
                               echo "git clone https://github.com/iPrayag/dotfiles.git"
                               ## logic
                        fi
                        ;;
                    *)
                        echo ${o}
                        usage
                        ;;
                   esac
                  done
                  shift $((OPTIND-1))
                  echo "option1 = ${o}"
                  echo "option2 = ${b}"
                  if [ -z "${b}" ]; then
                         usage
                  fi

                    ;;
                up)
                     echo "up"
                     ##logic
                     ;;
                down)
                     echo "down"
                     ##logic
                    ;;
                *)
                    echo "Usage: $0 {up | down} dev"
                    exit 1
                    ;;
esac

   Without first case .. in .... esac, it works fine. With case ... in ... esac, it gives blank option
   for -b,
$ ./nepleaks_upd.sh bootstrap -b off
option1 = ?
option2 =
Usage: ./nepleaks_upd.sh [bootstrap | up | down]  [-b <on/off>]

***
   Shouldn't you check for options before you use $1? – [40]unxnut Jul 4 '14 at 21:28

***
   What do you mean by “Without first case .. in .... esac, it works fine”? Do you mean that lines 5-25
   parse ./nepleaks_upd.sh -b off correctly? Maybe you need a shift, so getopts doesn’t choke on the
   “bootstrap”. – [42]Scott Jul 4 '14 at 22:57

***
   @Scott Yes, exactly that part works fine. – [43]prayagupd Jul 5 '14 at 8:52


1 Answer 1

   getopts starts parsing at the first argument and stops at the first non-option arguments. That's the
   standard convention — some GNU utilities accept options after arguments, but the normal thing is that
   in somecommand foo -bar qux, -bar is not parsed as an option.

   If you want to start parsing options after bootstrap, you need to indicate that. getopts uses the
   OPTIND variable to remember what position it's at. OPTIND starts out with the value 1. To skip the
   first argument, set it to 2.
case "$1" in
   bootstrap)
      OPTIND=2
      while getopts ":b:" o; do
          …

   Alternatively, you could shift the arguments that you've already processed.
subcommand=$1; shift
case "$subcommand" in
    bootstrap)
      while getopts ":b:" o; do
          …

---
https://theholyjava.wordpress.com/2013/01/09/bash-parse-options-and-non-options-with-getopts/

Bash: Parse Options And Non-Options With Getopts
January 9, 2013

   Parsing script or function options and non-option arguments is easy in Bash with getopts but there
   are some catches, such as the need to reset OPTIND. We will se how to do it using getopts, shift, and
   case.

   The code below will parse the function arguments and remove them so that $1 will refer to the first
   non-option argument (i.e. not starting with -). You would invoke it f.ex. as  latest_recur -x Hello
   -a '*.txt'.
# Find the latest files under the current dir, recursively; options:
# -a list all, not only 30 latest
#  - pattern passed to find's -name; ex.: "*.log.processed"
function latest_recur {
   local show_all=
   OPTIND=1
   while getopts "ax:" opt; do
      case $opt in
         a) show_all=yes ;;
         x) echo "You said: $OPTARG" ;;
         \?) echo "Invalid option: -$OPTARG" >&2; return 1;;
     esac
   done
   shift $((OPTIND-1))

   if [ -z "$1" ]; then NAME_ARG=""; else NAME_ARG="-name $1"; fi
   find -type f $NAME_ARG | xargs --no-run-if-empty stat --format '%Y :%y %n' | sort -nr | if [ -z "$show_all"\
 ]; then head -n 30 -; else cat -; fi
}

     * #5, #9 the variable used to store the flag must be defined/reset first
     * #6 OPTIND is a global variable pointing to the next argument that getopts should parse; you must
       reset it manually (otherwise the next call to the function will ignore its arguments)
     * #7 getopts parses one by one all the supported options (a, x here) and stores them into $opt;
     * #10, #11 the value passed to the option (Hello, *.txt) is stored into the variable OPTARG
     * #14 we must manually shift away the processed option arguments so that the first non-option
       argument (‘*.txt’) will become argument number 1 as you can see at #16; OPTIND is set by getopts

   Getopts can do quite a lot. It supports short options with or without arguments such as “-lht”, “-l
   -h -t”, “-l -I ‘*.swp'”. It can also report/ignore unknown arguments etc., see [253]its brief
   documentation and this [254]small getopts tutorial. Briefly said, getopts takes opstring and varname;
   opstring is a list of letters optionally followed by ‘:’ to indicate that that flag requires a value;
   varname is the name of the variable to store the flag name into. If you put : in front of the
   opstring (“:ax:”) then it will not complain about unknown options or missing arguments for options
   that require them.
   Advertisements
