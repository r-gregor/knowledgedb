filename: bash_progress-bar-in-shell-script_20160404.txt
http://stackoverflow.com/questions/238073/how-to-add-a-progress-bar-to-a-shell-script

[30]How to add a progress bar to a shell script?

   up vote 198 down vote [31]favorite
   124

   When scripting in bash or any other shell in *NIX, while running a command that will take more than a
   few seconds, a progress bar is needed.

   For example, copying a big file, opening a big tar file.

   What ways do you recommend to add progress bars to shell scripts?

   ***
   See also [40]stackoverflow.com/questions/12498304/… for examples of the control logic (background a
   job and do something until it finishes). – [41]tripleee Dec 3 '15 at 20:53
   add a comment |

23 Answers 23

***
   You can implement this by overwriting a line. Use \r to go back to the beginning of the line without
   writing \n to the terminal.

   Write \n when you're done to advance the line.

   Use echo -ne to:
    1. not print \n and
    2. to recognize escape sequences like \r.

   Here's a demo:
echo -ne '#####                     (33%)\r'
sleep 1
echo -ne '#############             (66%)\r'
sleep 1
echo -ne '#######################   (100%)\r'
echo -ne '\n'

***
   I've allways wanted to know this. That's an epiphany for me!!!! Thanks! – [50]Hugo Oct 27 '08 at
   17:22
   14
   According to the echo man page (at least on MacOS X) sh/bash use their own built-in echo command that
   doesn't accept "-n" ... so in order to accomplish the same thing you need to put \r\c at the end of
   the string, instead of just \r – [51]Justin Jenkins Apr 2 '12 at 1:17
   28
   The portable way to output this is to use printf instead of echo. – [52]Jens May 30 '12 at 10:52
   4
   for printf we would have to use this format: printf "#### (50%%)\r", it wouldn't work with single
   quotes and percent sign needs to be escaped. – [53]nurettin Sep 10 '13 at 9:55
   6
   The question was "How do I do progress bars" with an example of copying files. I focused on the
   "graphics" problem, not the calculation of how far along a file copy operation is. – [54]Mitch Haile
   May 25 '14 at 5:00
    |  [55]show 7 more comments
   up vote 34 down vote

   Some posts have showed how to display the command's progress. In order to calculate it, you'll need
   to see how much you've progressed. On BSD systems some commands, such as dd(1), accept a SIGINFO
   signal, and will report their progress. On Linux systems some commands will respond similarly to
   SIGUSR1. If this facility is available, you can pipe your input through dd to monitor the number of
   bytes processed.

   Alternatively, you can use [56]lsof to obtain the offset of the file's read pointer, and thereby
   calculate the progress. I've written a command, named [57]pmonitor, that displays the progress of
   processing a specified process or file. With it you can do things, such as the following.
$ pmonitor -c gzip
/home/dds/data/mysql-2015-04-01.sql.gz 58.06%

   An earlier version of Linux and FreeBSD shell scripts appears on [58]my blog.

***
   This is awesome, I always forget to pipe things through pv :-) I think my "stat" command works a bit
   differently, my (Linux) version of this script: [63]gist.github.com/unhammer/b0ab6a6aa8e1eeaf236b
   – [64]unhammer Jul 29 '14 at 12:46

   Great post, always love it when awk's into play! – [65]ShellFish May 29 '15 at 1:42
   add a comment |
   up vote 23 down vote

   use the linux command pv:

   [66]http://linux.die.net/man/1/pv

   it doesn't know the size if it's in the middle of the stream, but it gives a speed and total and from
   there you can figure out how long it should take and get feedback so you know it hasn't hung.

***
   You may also be interested in [70]how to do a spinner:

Can I do a spinner in Bash?

   Sure!
i=1
sp="/-\|"
echo -n ' '
while true
do
    printf "\b${sp:i++%${#sp}:1}"
done

   Each time the loop iterates, it displays the next character in the sp string, wrapping around as it
   reaches the end. (i is the position of the current character to display and ${#sp} is the length of
   the sp string).

   The \b string is replaced by a 'backspace' character. Alternatively, you could play with \r to go
   back to the beginning of the line.

   If you want it to slow down, put a sleep command inside the loop (after the printf).

   A POSIX equivalent would be:
sp='/-\|'
printf ' '
while true; do
    printf '\b%.1s' "$sp"
    sp=${sp#?}${sp%???}
done

   If you already have a loop which does a lot of work, you can call the following function at the
   beginning of each iteration to update the spinner:
sp="/-\|"
sc=0
spin() {
   printf "\b${sp:sc++:1}"
   ((sc==${#sp})) && sc=0
}
endspin() {
   printf "\r%s\n" "$@"
}

until work_done; do
   spin
   some_work ...
done
endspin

***
   Much shorter version, fully portable*: while :;do for s in / - \\ \|; do printf "\r$s";sleep
   .1;done;done (*: sleep may require ints rather than decimals) – [76]Adam Katz Aug 19 '15 at 20:13
   1
   @Daenyth. Thanks. Kindly where we should call the command that we need to watch it is progress using
   the previous code? – [77]goro Aug 24 '15 at 15:33
   add a comment |
   up vote 13 down vote

   [78]GNU tar has a useful option which gives a functionality of a simple progress bar.

   (...) Another available checkpoint action is ‘dot’ (or ‘.’). It instructs tar to print a
   single dot
   on the standard listing stream, e.g.:
$ tar -c --checkpoint=1000 --checkpoint-action=dot /var
...

   The same effect may be obtained by:
$ tar -c --checkpoint=.1000 /var

***
   A simpler method that works on my system using the pipeview ( pv ) utility.
srcdir=$1
outfile=$2


tar -Ocf - $srcdir | pv -i 1 -w 50 -berps `du -bs $srcdir | awk '{print $1}'` | 7za a -si $outfile

***
   Got an easy progress bar function that i wrote the other day:
#!/bin/bash
# 1. Create ProgressBar function
# 1.1 Input is currentState($1) and totalState($2)
function ProgressBar {
# Process data
    let _progress=(${1}*100/${2}*100)/100
    let _done=(${_progress}*4)/10
    let _left=40-$_done
# Build progressbar string lengths
    _fill=$(printf "%${_done}s")
    _empty=$(printf "%${_left}s")

# 1.2 Build progressbar strings and print the ProgressBar line
# 1.2.1 Output example:
# 1.2.1.1 Progress : [########################################] 100%
printf "\rProgress : [${_fill// /#}${_empty// /-}] ${_progress}%%"

}

# Variables
_start=1

# This accounts as the "totalState" variable for the ProgressBar function
_end=100

# Proof of concept
for number in $(seq ${_start} ${_end})
do
    sleep 0.1
    ProgressBar ${number} ${_end}
done
printf '\nFinished!\n'

   Or snag it from,
   [86]https://github.com/fearside/ProgressBar/

***
   This lets you visualize that a command is still executing:
while :;do echo -n .;sleep 1;done &
trap "kill $!" EXIT  #Die with parent if we die prematurely
tar zxf packages.tar.gz; # or any other command here
kill $! && trap " " EXIT #Kill the loop and unset the trap or else the pid might get reassigned and we
might e
nd up killing a completely different process

   This will create an infinite while loop that executes in the background and echoes a "." every
   second. This will display . in the shell. Run the tar command or any a command you want. When that
   command finishes executing then kill the last job running in the background - which is the infinite
   while loop.

***
   Couldn't another job start in the background during execution and potentially get killed instead of
   the progress loop? – [95]Dave Apr 24 '15 at 13:28

   I think the idea is you would put this in a script, so this would only trap an exit of that script.
   – [96]Iguananaut Feb 16 at 10:28
   add a comment |
   up vote 4 down vote

   First of all bar is not the only one pipe progress meter. The other (maybe even more known) is pv
   (pipe viewer).

   Secondly bar and pv can be used for example like this:
$ bar file1 | wc -l
$ pv file1 | wc -l

   or even:
$ tail -n 100 file1 | bar | wc -l
$ tail -n 100 file1 | pv | wc -l

   one useful trick if you want to make use of bar and pv in commands that are working with files given
   in arguments, like e.g. copy file1 file2, is to use [97]process substitution:
$ copy <(bar file1) file2
$ copy <(pv file1) file2

   Process substitution is a bash magic thing that creates temporary fifo pipe files /dev/fd/ and
   connect stdout from runned process (inside parenthesis) through this pipe and copy sees it just like
   an ordinary file (with one exception, it can only read it forwards).

   Update:

   bar command itself allows also for copying. After man bar:
bar --in-file /dev/rmt/1cbn --out-file \
     tape-restore.tar --size 2.4g --buffer-size 64k

   But process substitution is in my opinion more generic way to do it. An it uses cp program itself.

***
   My solution displays the percentage of the tarball that is currently being uncompressed and written.
   I use this when writing out 2GB root filesystem images. You really need a progress bar for these
   things. What I do is use gzip --list to get the total uncompressed size of the tarball. From that I
   calculate the blocking-factor needed to divide the file into 100 parts. Finally, I print a checkpoint
   message for each block. For a 2GB file this gives about 10MB a block. If that is too big then you can
   divide the BLOCKING_FACTOR by 10 or 100, but then it's harder to print pretty output in terms of a
   percentage.

   Assuming you are using Bash then you can use the following shell function
untar_progress ()
{
  TARBALL=$1
  BLOCKING_FACTOR=$(gzip --list ${TARBALL} |
    perl -MPOSIX -ane '$.==2 && print ceil $F[1]/50688')
  tar --blocking-factor=${BLOCKING_FACTOR} --checkpoint=1 \
    --checkpoint-action='ttyout=Wrote %u%  \r' -zxf ${TARBALL}
}

   [102]share|[103]improve this answer
   [104]edited Feb 12 '14 at 20:30
   [105]Steven Penny
   1
   answered Aug 24 '10 at 9:01
   [106]Noah Spurrier
   39546
   add a comment |
   up vote 2 down vote

   Most unix commands will not give you the sort of direct feedback from which you can do this. Some
   will give you output on stdout or stderr that you can use.

   For something like tar you could use the -v switch and pipe the output to a program that updates a
   small animation for each line it reads. As tar writes out a list of files it's unravelled the program
   can update the animation. To do a percent complete you would have to know the number of files and
   count the lines.

   cp doesn't give this sort of output as far as I know. To monitor the progress of cp you would have to
   monitor the source and destination files and watch the size of the destination. You could write a
   small c program using the [107]stat (2) system call to get the file size. This would read the size of
   the source then poll the destination file and update a % complete bar based on the size of the file
   written to date.

***
   for me easiest to use and best looking so far is command pv or bar like some guy already wrote

   for example: need to make a backup of entire drive with dd

   normally you use dd if="$input_drive_path" of="$output_file_path"

   with pv you can make it like this :

   dd if="$input_drive_path" | pv | dd of="$output_file_path"

   and the progress goes directly to STDOUT as this:
    7.46GB 0:33:40 [3.78MB/s] [  <=>                                            ]

   after it is done summary comes up
    15654912+0 records in
    15654912+0 records out
    8015314944 bytes (8.0 GB) copied, 2020.49 s, 4.0 MB/s

***
   I prefer to use dialog with the --gauge param. Is used very often in .deb package installations and
   other basic configuration stuff of many distros. So you don't need to reinvent the wheel... again

   Just put an int value from 1 to 100 @stdin. One basic and silly example:
for a in {1..100}; do sleep .1s; echo $a| dialog --gauge "waiting" 7 30; done

   I have this /bin/Wait file (with chmod u+x perms) for cooking purposes :P
#!/bin/bash
INIT=`/bin/date +%s`
NOW=$INIT
FUTURE=`/bin/date -d "$1" +%s`
[ $FUTURE -a $FUTURE -eq $FUTURE ] || exit
DIFF=`echo "$FUTURE - $INIT"|bc -l`

while [ $INIT -le $FUTURE -a $NOW -lt $FUTURE ]; do
    NOW=`/bin/date +%s`
    STEP=`echo "$NOW - $INIT"|bc -l`
    SLEFT=`echo "$FUTURE - $NOW"|bc -l`
    MLEFT=`echo "scale=2;$SLEFT/60"|bc -l`
    TEXT="$SLEFT seconds left ($MLEFT minutes)";
    TITLE="Waiting $1: $2"
    sleep 1s
    PTG=`echo "scale=0;$STEP * 100 / $DIFF"|bc -l`
    echo $PTG| dialog --title "$TITLE" --gauge "$TEXT" 7 72
done

if [ "$2" == "" ]; then msg="Espera terminada: $1";audio="Listo";
else msg=$2;audio=$2;fi

/usr/bin/notify-send --icon=stock_appointment-reminder-excl "$msg"
espeak -v spanish "$audio"

   So I can put:

   Wait "34 min" "warm up the oven"

   or

   Wait "dec 31" "happy new year"
   [116]share|[117]improve this answer
           [118]edited Jan 10 at 19:02
   answered Jan 10 at 17:40
   [119]Juan Eduardo Castaño Nestares
   493
   add a comment |
   up vote 1 down vote

   I did a pure shell version for an embedded system taking advantage of:
     * /usr/bin/dd's SIGUSR1 signal handling feature.
       Basically, if you send a 'kill SIGUSR1 $(pid_of_running_dd_process)', it'll output a summary of
       throughput speed and amount transferred.
     * backgrounding dd and then querying it regularly for updates, and generating hash ticks like
       old-school ftp clients used to.
     * Using /dev/stdout as the destination for non-stdout friendly programs like scp

   The end result allows you to take any file transfer operation and get progress update that looks like
   old-school FTP 'hash' output where you'd just get a hash mark for every X bytes.

   This is hardly production quality code, but you get the idea. I think it's cute.

   For what it's worth, the actual byte-count might not be reflected correctly in the number of hashes -
   you may have one more or less depending on rounding issues. Don't use this as part of a test script,
   it's just eye-candy. And, yes, I'm aware this is terribly inefficient - it's a shell script and I
   make no apologies for it.

   Examples with wget, scp and tftp provided at the end. It should work with anything that has emits
   data. Make sure to use /dev/stdout for programs that aren't stdout friendly.
#!/bin/sh
#
# Copyright (C) Nathan Ramella (nar+progress-script@remix.net) 2010
# LGPLv2 license
# If you use this, send me an email to say thanks and let me know what your product
# is so I can tell all my friends I'm a big man on the internet!

progress_filter() {

        local START=$(date +"%s")
        local SIZE=1
        local DURATION=1
        local BLKSZ=51200
        local TMPFILE=/tmp/tmpfile
        local PROGRESS=/tmp/tftp.progress
        local BYTES_LAST_CYCLE=0
        local BYTES_THIS_CYCLE=0

        rm -f ${PROGRESS}

        dd bs=$BLKSZ of=${TMPFILE} 2>&1 \
                | grep --line-buffered -E '[[:digit:]]* bytes' \
                | awk '{ print $1 }' >> ${PROGRESS} &

        # Loop while the 'dd' exists. It would be 'more better' if we
        # actually looked for the specific child ID of the running
        # process by identifying which child process it was. If someone
        # else is running dd, it will mess things up.

        # My PID handling is dumb, it assumes you only have one running dd on
        # the system, this should be fixed to just get the PID of the child
        # process from the shell.

        while [ $(pidof dd) -gt 1 ]; do

                # PROTIP: You can sleep partial seconds (at least on linux)
                sleep .5

                # Force dd to update us on it's progress (which gets
                # redirected to $PROGRESS file.
                #
                # dumb pid handling again
                pkill -USR1 dd

                local BYTES_THIS_CYCLE=$(tail -1 $PROGRESS)
                local XFER_BLKS=$(((BYTES_THIS_CYCLE-BYTES_LAST_CYCLE)/BLKSZ))

                # Don't print anything unless we've got 1 block or more.
                # This allows for stdin/stderr interactions to occur
                # without printing a hash erroneously.

                # Also makes it possible for you to background 'scp',
                # but still use the /dev/stdout trick _even_ if scp
                # (inevitably) asks for a password.
                #
                # Fancy!

                if [ $XFER_BLKS -gt 0 ]; then
                        printf "#%0.s" $(seq 0 $XFER_BLKS)
                        BYTES_LAST_CYCLE=$BYTES_THIS_CYCLE
                fi
        done

        local SIZE=$(stat -c"%s" $TMPFILE)
        local NOW=$(date +"%s")

        if [ $NOW -eq 0 ]; then
                NOW=1
        fi

        local DURATION=$(($NOW-$START))
        local BYTES_PER_SECOND=$(( SIZE / DURATION ))
        local KBPS=$((SIZE/DURATION/1024))
        local MD5=$(md5sum $TMPFILE | awk '{ print $1 }')

        # This function prints out ugly stuff suitable for eval()
        # rather than a pretty string. This makes it a bit more
        # flexible if you have a custom format (or dare I say, locale?)

        printf "\nDURATION=%d\nBYTES=%d\nKBPS=%f\nMD5=%s\n" \
            $DURATION \
            $SIZE \
            $KBPS \
            $MD5
}

   Examples:
echo "wget"
wget -q -O /dev/stdout http://www.blah.com/somefile.zip | progress_filter

echo "tftp"
tftp -l /dev/stdout -g -r something/firmware.bin 192.168.1.1 | progress_filter

echo "scp"
scp user@192.168.1.1:~/myfile.tar /dev/stdout | progress_filter

***
   Decent idea, as long as you have the file size ahead of time you can provide added value than pv this
   way, but blindly signaling the pidof dd is scary. – [123]A.Danischewski Dec 1 '15 at 15:09

   Attempted to call that out with '# My PID handling is dumb' – [124]synthesizerpatel Dec 3 '15 at 2:07

   You can perhaps capture $! from dd and wait on [[ -e /proc/${DD_PID} ]]. – [125]A.Danischewski Dec 3
   '15 at 2:26
   add a comment |
   up vote 1 down vote

   To indicate progress of activity, try the following commands:
while true; do sleep 0.25 && echo -ne "\r\\" && sleep 0.25 && echo -ne "\r|" && sleep 0.25 && echo -ne
"\r/" &
& sleep 0.25 && echo -ne "\r-"; done;

   OR
while true; do sleep 0.25 && echo -ne "\rActivity: \\" && sleep 0.25 && echo -ne "\rActivity: |" &&
sleep 0.25
 && echo -ne "\rActivity: /" && sleep 0.25 && echo -ne "\rActivity: -"; done;

   OR
while true; do sleep 0.25 && echo -ne "\r" && sleep 0.25 && echo -ne "\r>" && sleep 0.25 && echo -ne
"\r>>" &&
 sleep 0.25 && echo -ne "\r>>>"; sleep 0.25 && echo -ne "\r>>>>"; done;

   OR
while true; do sleep .25 && echo -ne "\r:Active:" && sleep .25 && echo -ne "\r:aCtive:" && sleep .25 &&
echo -
ne "\r:acTive:" && sleep .25 && echo -ne "\r:actIve:" && sleep .25 && echo -ne "\r:actiVe:" && sleep
.25 && ec
ho -ne "\r:activE:"; done;

   One can use flags/variables inside the while loop to check and display the value/extent of progress.

***
   I used an answer from [130]Creating string of repeated characters in shell script for char repeating.
   I have two relatively small bash versions for scripts that need to display progress bar (for example,
   a loop that goes through many files, but not useful for big tar files or copy operations). The faster
   one consists of two functions, one to prepare the strings for bar display:
preparebar() {
# $1 - bar length
# $2 - bar char
    barlen=$1
    barspaces=$(printf "%*s" "$1")
    barchars=$(printf "%*s" "$1" | tr ' ' "$2")
}

   and one to display a progress bar:
progressbar() {
# $1 - number (-1 for clearing the bar)
# $2 - max number
    if [ $1 -eq -1 ]; then
        printf "\r  $barspaces\r"
    else
        barch=$(($1*barlen/$2))
        barsp=$((barlen-barch))
        printf "\r[%.${barch}s%.${barsp}s]\r" "$barchars" "$barspaces"
    fi
}

   It could be used as:
preparebar 50 "#"

   which means prepare strings for bar with 50 "#" characters, and after that:
progressbar 35 80

   will display the number of "#" characters that corresponds to 35/80 ratio:
[#####################                             ]

   Be aware that function displays the bar on the same line over and over until you (or some other
   program) prints a newline. If you put -1 as first parameter, the bar would be erased:
progressbar -1 80

   The slower version is all in one function:
progressbar() {
# $1 - number
# $2 - max number
# $3 - number of '#' characters
    if [ $1 -eq -1 ]; then
        printf "\r  %*s\r" "$3"
    else
        i=$(($1*$3/$2))
        j=$(($3-i))
        printf "\r[%*s" "$i" | tr ' ' '#'
        printf "%*s]\r" "$j"
    fi
}

   and it can be used as (the same example as above):
progressbar 35 80 50

   If you need progressbar on stderr, just add >&2 at the end of each printf command.

***
   I have built on the answer provided by fearside

   This connects to an Oracle database to retrieve the progress of an RMAN restore.
#!/bin/bash

 # 1. Create ProgressBar function
 # 1.1 Input is currentState($1) and totalState($2)
 function ProgressBar {
 # Process data
let _progress=(${1}*100/${2}*100)/100
let _done=(${_progress}*4)/10
let _left=40-$_done
# Build progressbar string lengths
_fill=$(printf "%${_done}s")
_empty=$(printf "%${_left}s")

# 1.2 Build progressbar strings and print the ProgressBar line
# 1.2.1 Output example:
# 1.2.1.1 Progress : [########################################] 100%
printf "\rProgress : [${_fill// /#}${_empty// /-}] ${_progress}%%"

}

function rman_check {
sqlplus -s / as sysdba <<EOF
set heading off
set feedback off
select
round((sofar/totalwork) * 100,0) pct_done
from
v\$session_longops
where
totalwork > sofar
AND
opname NOT LIKE '%aggregate%'
AND
opname like 'RMAN%';
exit
EOF
}

# Variables
_start=1

# This accounts as the "totalState" variable for the ProgressBar function
_end=100

_rman_progress=$(rman_check)
#echo ${_rman_progress}

# Proof of concept
#for number in $(seq ${_start} ${_end})

while [ ${_rman_progress} -lt 100 ]
do

for number in _rman_progress
do
sleep 10
ProgressBar ${number} ${_end}
done

_rman_progress=$(rman_check)

done
printf '\nFinished!\n'

***
   If you don't mind against using additional packages - there is an awesome tool, which shows colored
   information bar while copying data stream - [137]http://clpbar.sourceforge.net/
   [138]share|[139]improve this answer
   answered Apr 26 '13 at 6:27
   [140]anatoly techtonik
   6,09014464

   easyer to install is Tom Feiner's answer: bar – [141]rubo77 Sep 30 '13 at 7:07
   add a comment |
   up vote -1 down vote

   Once I also had a busy script which was occupied for hours without showing any progress. So I
   implemented a function which mainly includes the techniques of the previous answers:
#!/bin/bash
# Updates the progress bar
# Parameters: 1. Percentage value
update_progress_bar()
{
  if [ $# -eq 1 ];
  then
    if [[ $1 == [0-9]* ]];
    then
      if [ $1 -ge 0 ];
      then
        if [ $1 -le 100 ];
        then
          local val=$1
          local max=100

          echo -n "["

          for j in $(seq $max);
          do
            if [ $j -lt $val ];
            then
              echo -n "="
            else
              if [ $j -eq $max ];
              then
                echo -n "]"
              else
                echo -n "."
              fi
            fi
          done

          echo -ne " "$val"%\r"

          if [ $val -eq $max ];
          then
            echo ""
          fi
        fi
      fi
    fi
  fi
}

update_progress_bar 0
# Further (time intensive) actions and progress bar updates
update_progress_bar 100

***
   You could roll up those first four ifs into a single if statement with a series of ANDs, since you
   don't have any specific code within any of them: if [ $# -eq 1 ] && [[ $1 == [0-9]* ]] && [ $1 -ge 0
   ] && [ $1 -le 100 ]; You could also circumvent the for loops and shorten your code with printf and
   command substitution: printf "["; printf "%.0=" $(seq $val); printf "%.0." $(seq $[ $val+1 ] $max);
   printf "] %s%%\r" $val; – [145]CaffeineConnoisseur Jul 22 '14 at 1:16
   add a comment |
   up vote -1 down vote

   This is only applicable using gnome zenity. Zenity provides a great native interface to bash scripts:
   [146]https://help.gnome.org/users/zenity/stable/

   From Zenity Progress Bar Example:
#!/bin/sh
(
echo "10" ; sleep 1
echo "# Updating mail logs" ; sleep 1
echo "20" ; sleep 1
echo "# Resetting cron jobs" ; sleep 1
echo "50" ; sleep 1
echo "This line will just be ignored" ; sleep 1
echo "75" ; sleep 1
echo "# Rebooting system" ; sleep 1
echo "100" ; sleep 1
) |
zenity --progress \
  --title="Update System Logs" \
  --text="Scanning mail logs..." \
  --percentage=0

if [ "$?" = -1 ] ; then
        zenity --error \
          --text="Update canceled."
fi

***
   In case you have to show a temporal progress bar (by knowing in advance the showing time), you can
   use Python as follows:
#!/bin/python
from time import sleep
import sys

if len(sys.argv) != 3:
    print "Usage:", sys.argv[0], "<total_time>", "<progressbar_size>"
    exit()

TOTTIME=float(sys.argv[1])
BARSIZE=float(sys.argv[2])

PERCRATE=100.0/TOTTIME
BARRATE=BARSIZE/TOTTIME

for i in range(int(TOTTIME)+1):
    sys.stdout.write('\r')
    s = "[%-"+str(int(BARSIZE))+"s] %d%% "
    sys.stdout.write(s % ('='*int(BARRATE*i), int(PERCRATE*i)))
    sys.stdout.flush()
    SLEEPTIME = 1.0
    if i == int(TOTTIME): SLEEPTIME = 0.1
    sleep(SLEEPTIME)
print ""

   Then, assuming you saved the Python script as progressbar.py, it's possible to show the progress bar
   from your bash script by running the following command:
python progressbar.py 10 50

   It would show a progress bar sized 50 characters and "running" for 10 seconds.

***
   To make a tar progress bar
tar xzvf pippo.tgz |xargs -L 19 |xargs -I@ echo -n "."

   Where "19" is the number of files in the tar divided the length of the intended progress bar.
   Example: the .tgz contains 140 files and you'll want a progress bar of 76 ".", you can put -L 2.

   You'll need nothing else.

***
   This is specific to tar, so unless the shell script only consist of tar command, it doesn't really
   apply to OP's case. – [156]doubleDown Oct 20 '12 at 4:30
   add a comment |
   up vote -3 down vote

   I had the same thing to do today and based on Diomidis answer, here is how I did it (linux debian
   6.0.7). Maybe, that could help you :
#!/bin/bash

echo "getting script inode"
inode=`ls -i ./script.sh | cut -d" " -f1`
echo $inode

echo "getting the script size"
size=`cat script.sh | wc -c`
echo $size

echo "executing script"
./script.sh &
pid=$!
echo "child pid = $pid"

while true; do
        let offset=`lsof -o0 -o -p $pid | grep $inode | awk -F" " '{print $7}' | cut -d"t" -f 2`
        let percent=100*$offset/$size
        echo -ne " $percent %\r"
done

***
   can you explain what offset calculate . – [160]deven98602 May 9 '13 at 7:46

   When I start this script as root, I get the error: lsof: WARNING: can't stat() fuse.gvfsd-fuse file
   system /home/rubo77/.gvfs Output information may be incomplete. – [161]rubo77 Sep 30 '13 at 11:30

   And, I get the error: progressbar: Zeile 17: let: offset=: Syntax Fehler: Operator erwartet.
   (Fehlerverursachendes Zeichen ist \"=\"). if I call this script progressbar.sh and call it with cd
   /tmp/; echo "sleep 5">script.sh; bash progressbar.sh on Ubuntu 13.04 – [162]rubo77 Sep 30 '13 at
   11:37



---
http://unix.stackexchange.com/questions/65077/is-it-possible-to-see-cp-speed-and-percent-copied

Is it possible to see cp speed and percent copied?

***
I'm having problems when copying large files using nautilus (it gets stuck). I need to copy, using cp. I
would like to know if there are any parameters that shows the % copied and also the transfer speed.

***
You could use rsync instead of cp. It has a --progress option. – frostschutz Feb 17 '13 at 14:15

Midnight Commander also works well, and has a pretty text-based UI with progress bars, but might not
be installed. Try mc on the command prompt. Also, obviously, it's not cp. – Michael Kjörling Feb 17
'13 at 14:24
Using rsync with --progress just made me figure out what is happening. It gets stuck when it reaches
the 100%, and then last a couple of minutes in end up. I think is the same that is happening with
nautilus. Anyway that is another question already, so the best answer for this question is the rsync
--progress, it shows size, %, speed and elapsed time. – yzT Feb 17 '13 at 15:16
I have a question about the rsync --progress. Assume that I have the directory A with files a and b and
the empty directory B, when I copy A to B it shows the progress of each file, i.e. the progress of a
and the progress of b. Is there any way to show the overall progress? – yzT Feb 17 '13 at 15:33
one problem with rsync is that it runs slower than a pure copy. On my big server, the difference is
60MB/s and 300MB/s respectively. – pdwalker Nov 15 '14 at 17:37

***
If you allow other tools than cp it's surely possible. For a single file you can use pv. It's a small
tool providing nice statistics.

pv inputfile > outputfile
If you have multiple files or directories you can use tar:

tar c sourceDirectory | pv | tar x -C destinationDirectory
You can wrap it in a shell function. It's less to type and you get semantics close to the ones of
cp. Here's a very simple (and not error-proof!) function:

cpstat () {
  tar c "$1" | pv | tar x -C "$2"
}
Note that some versions of tar don't support the abovementioned syntax (e.g. Solaris tar) and you have
to use the following variant:

cpstat () {
  tar cf - "$1" | pv | (cd "$2";tar xf -)
}
You call it like this

cpstat sourceDirectory destinationDirectory
You can enhance it further, so that pv provides an estimation of the remaining time.

Another solution (as frostschutz mentioned in a comment) is to use rsync with the --progress option:

rsync --progress -a sourceDirectory destinationDirectory

***
cpstat is going in the pastebin =) – Matt Feb 17 '13 at 14:57

This will give you transfer speed, but not ETA, because pv doesn't know how much data will come through
the pipe. You can specify this using -s. E.g. first do du -sh sourceDirectory to get a (rough) idea,
and then pass it to pv, like this: pv -s 100m. – Jan Fabry May 11 '14 at 15:25

--info=progress2 gives you directory level progress statistics. – AlexLordThorsen Dec 5 '14 at 23:40

vbuf (debian, ubuntu) is a good bit faster than pv, probably because of its virtual ring buffer –
Skaperen Oct 4 '15 at 10:56

@Skaperen I don't know vbuf. But as it seems it is in Debian unstable at the moment and therefore often
not available on Servers which are usually running Debian stable. – Marco Oct 4 '15 at 18:35

***
Rsync has a flag called progress2 which shows the overall %.

rsync --info=progress2 source dest

***
--info=progress2 still hasn't made it into a default repository and here it is 2015. Seems like a good
idea. – Lonniebiz Apr 1 '15 at 8:27

--info=progress2 finally included on version 3.1.0 protocol version 31. Maybe you could edit your answer,
yzT. – Sopalajo de Arrierez May 9 '15 at 21:14

nice but last 5 times longer than cp – xamiro-dev Dec 7 '15 at 19:27

***
rsync works the best for showing the progress during the copying progress.

ex:

rsync -avh --progress sourceDirectory destinationDirectory

***
As explained in other answers, cp doesn't provide that functionality. However, progress (formerly called
cv) is a small tool which is very helpful in providing this missing feature.

This tool can be described as a Tiny Dirty Linux Only* C command that looks for coreutils basic commands
(cp, mv, dd, tar, gzip/gunzip, cat, ...) currently running on your system and displays the percentage
of copied data.
I've been using it for the past few months and it's solid.

***
doesn't seem to work with all filesystems (e.g. cifs) but +1, didn't know such crazy ting exits –
akostadinov Mar 8 '15 at 17:23
1
Note that this project is now called "progress - Coreutils Progress Viewer (formerly known as cv)". –
chappjc Oct 2 '15 at 17:34

***
Noticed this posting was somewhat old. But as I made a solution to the issue at hand, I thought I'd post
my solution.

Scenario: We have a very large directory-structure we want to copy, so we issue the command cp -R
sourcedir destdir in one terminal window.

Open another terminal window or push the process to the background (Ctrl+Z,bg<CR>), then let's make a
progress indicator the ghetto way:

We first get the total size of the directory structure we want to copy, you do this with:

du -sh /path/sourcedirectory/

Convert the result to gigabytes (G), then substitute the n for the result you got in the variable
sourcesize. Once you've inserted the sourcesize and destdir (destination directory), run the command below.

while true; do sourcesize=n destdir=/path/destinationdirectory/ copyprogress="$(export | du -sh $destdir
| awk '{print $1}' | sed 's/[^0-9.]*//g' )" ; echo "scale=3 ; $copyprogress / $sourcesize * 100" | bc |
xargs echo -n ; echo % completed ; sleep 10 ; done
This will print the progress every 10 seconds with messages like:

0.100% completed
0.200% completed
0.300% completed
... etc
I'm aware that this solution did not address the speed of copying, but it would be possible to add
that by by expanding the commands above, possibly making it into a bash script so it would be easier to
read. For instance by checking how much data is copied pr. n time unit, the speed should be trivial to
calculate and display.

***
This is actually perfect for my use case, so thanks for posting it! I want to know about the progress
of copying a huge directory with thousands of files, not just one file, so the other solutions don't
really help me. – Ibrahim Apr 10 '15 at 18:09
add a comment
up vote
3
down vote
To improve on Marco's answer, today I wrote this version of cpstat, so you can copy many directories
and use the last parameter as the destination path. Note that if you use a relative deep path as source,
you can, thanks to tar, automatically create the same dependent directory tree.

function cpstat () {

    tar -cf - "${@: 1: $#-1}" |
    pv -s "$( du -cs -BK --apparent-size "${@: 1: $#-1}" |
	      tail -n 1 |
	      cut -d "$(echo -e "\t")" -f 1)" |
    ( cd "${@: $#}"; tar -xf - )

;}

***
Not in a standard version of cp.

You could background the cp and list the size while waiting for cp to finish.

I use this perl to monitor growth of a single file but it runs externally to the cp (or whatever else
I'm doing)

***
This tool is a Linux utility command that looks for coreutils basic commands (cp, mv, dd, tar, gzip/gunzip,
cat, etc.) currently running on your system and displays the percentage of copied data:

https://github.com/Xfennec/cv

***
This has already been suggested by @AmrMostafa in Nov '14. – Dubu May 12 '15 at 13:18

***
Another simple solution is to just watch the output folder as follows:

watch -n 10 --differences du -sk --apparent-size <WATCHED_FOLDER>

This handy utility will run du and highlight the differences.

One other potential solution would be to write a simple script that loops, calling du and spitting out
a rough estimate of the throughput.



---
http://askubuntu.com/questions/17275/progress-and-speed-with-cp

Progress and speed with 'cp'?

***
When copying files using cp, is it possible to display the progress and speed of the transfer? Otherwise,
is there any alternative command line utility that can achieve this?

command-line coreutils

***
While cp hasn't got this functionality, you can use pv to do this:

pv my_big_file > backup/my_big_file
Note: this method will lose the file's permissions and ownership. Files copied this way will have the
same permissions as if you'd created them yourself and will belong to you.

In this example, pv basically just outputs the file to stdout*, which you redirect to a file using the >
operator. Simultaniously, it prints information about the progress to the terminal when you do that.

This is what it looks like:

stefano@ubuntu:~/Data$ pv my_big_file > backup/my_big_file
 138MB 0:00:01 [73.3MB/s] [=================================>] 100%
You may need to  Install pv (alternatively, type sudo apt-get install pv) on your system.

*: The technical bit

There are three important streams of data in a unix-like system: stdout (standard output), stderr (standard
error) and stdin (standard input). Every program has all three, so to speak. The pipe-operator redirects
a programs output to another programs input. The > operator redirects a programs standard output to a
file. cp basically does nothing fancier than

cat source > destination
(where cat just reads a file and prints it to stdout). pv is just like cat, but if you redirect it's
output stream somewhere else, it will print progress information to stdout instead.

Take a look at man pv to learn more about it.

Another option, as alt textDoR suggests in this answer, is to use rsync instead:

rsync -ah --progress source-file destination

alt text
This will preserve the files permissions/ownership while showing progress.

***
It may or may no be significant (depending on the situation), but pv does not handle permissions the
same way as cp does... (based on one quick test I tried: pv didn't copy the execute bit across.. rsync
did. – Peter.O Dec 14 '10 at 15:55

IMO: alias cp="rsync -avz" cp is outdated. – Marco Ceppi♦ Dec 26 '10 at 1:26

If you're like me, and forget about pv, you can go snooping in /proc/PID of cp/fd and /proc/PID of
cp/fdinfo to figure out progress. (It's up to you to infer speed.) I use this technique to watch
updatedb. – Thanatos Dec 26 '10 at 1:30

@MarcoCeppi I copied you alias to my dot file but that didn't work out very well. -z makes copying files
3 times slower on my computer so I delete that option. – hrzhu May 17 '15 at 2:51

Yes, -z should probably only be used for network copies; compressing and decompressing the data for a
local copy is pure overhead. – Matthew Read Jun 17 '15 at 15:17

***
If you want to see if your files are transferring correctly you could use gcp and gcp is like cp but by
default gives you a progress bar so that you can see what is being copied. As the program's wiki notes,
gcp has several useful features such as

transfer progression indication
continuous copying on error (skip to next file)
copy status logging: gcp logs all its actions so that it is possible to know which files have been
successfully copied
name mangling to handle target filesystem limitations (for example deletion of incompatible characters
"*" or "?" on FAT)
However, even when the progress bar has reached 100% when using the tool, you must wait until your
terminal prompt reappears before safely removing your media so that you can ensure that the transfer
process has successfully finished.

gcp is used to copy files and has options such as --preserve so that various attributes and permissions
can be preserved and --recursive so that whole directories can be copied. More information on its options
can be found by entering man gcp or by going to the Ubuntu manpages online. A tutorial is also available
on this site.

Install gcp from the repositories with

sudo apt-get install gcp
(Note: in Ubuntu 12.10 the new automount point is, for example, /media/user/usbdisk)

You can copy a file to your media by entering

gcp /home/mike/file.mp4 /media/usb
and copy a folder to your media with

gcp -rv ~/Podcasts /media/Mik2
Sample output from gcp with the progress bar:

gcp ~/Videos_incIplayer/mars.flv /media/Mik2
Copying 168.57 MiB 100% |########################################################|   7.98 M/s Time: 00:00:22
You can of course specify multiple files or folders to copy to your disk, and there are a lot of other
options covered in man gcp.

***
Got error with it over ssh dbus.exceptions.DBusException: org.freedesktop.DBus.Error.NotSupported:
Unable to autolaunch a dbus-daemon without a $DISPLAY for X11 – msa7 Jan 17 at 23:29

***
There isn't. See here as to why. Although it does more than you need, rsync has one with --progress
parameter. The -a will keep permissions,etc, and -h will be human readable.

rsync -ah --progress source destination

***
This works great in the current Ubuntu (14.10). It also supports the -r flag to recurse directories. It
can even be aliased as a direct replacement for cp: alias cp="rsync -ah --progress" – rustyx Dec 23
'14 at 21:04

Works swell on OS X, with the bonus of being able to use tools included with the system. – Ivan X Apr 24
'15 at 20:11

***
I get a kick out of using cURL for this exact purpose. The man page lists the "FILE" protocol as supported,
so just use it like any other protocol in a URL:

curl -o destination FILE://source
Speed, progress, time remaining, and more -- all in a familiar format.

***
This is great especially in environments where you are prohibited from installing new tools and where
rsync is unavailable. – user190264 Sep 5 '13 at 7:00

+1 nice trick!. – Harikrishnan Jun 30 '15 at 10:53

Brilliant, this has got to be a must-known hack! – ionreflex Oct 20 '15 at 18:13

***
While it doesn't display speed, when copying multiple files, the -v option to the cp command will provide
you with progress info. e.g.

cp -rv old-directory new-directory

***
Progress info? This is just verbose output. To provide progress info you would at least need to now how
many files, or even which files, needs to be copied. – Julian F. Weinert Jul 3 '15 at 20:21

***
The kernel knows most of the data, like speed, and often also percentage. Modern kernels expose this
via their /proc filesystem.

showspeed from https://github.com/jnweiger/showspeed uses that info. It can attach to already running
programs, and give periodict updates like this:

$ dd if=bigfile of=/tmp/otherbigfile &
$ showspeed dd
dd looks like a process name. pid=4417 matches av0=dd.
p/4417/fd/0r /home/jw/bigfile 113MB/s (12%, 2.3GB)  9m:35
p/4417/fd/1w /tmp/otherbigfile 182MB/s (2.6GB)
p/4417/fd/0r /home/jw/bigfile 285MB/s (15%, 3.0GB)  8m:08
p/4417/fd/0r /home/jw/bigfile 115MB/s (16%, 3.2GB)  8m:01
p/4417/fd/0r /home/jw/bigfile 107MB/s (17%, 3.4GB)  7m:39
p/4417/fd/1w /tmp/otherbigfile 104MB/s (3.5GB)
p/4417/fd/0r /home/jw/bigfile 139MB/s (19%, 3.7GB)  7m:37
p/4417/fd/0r /home/jw/bigfile 116MB/s (20%, 3.9GB)  7m:18
p/4417/fd/1w /tmp/otherbigfile	67MB/s (4.0GB)
p/4417/fd/1w /tmp/otherbigfile 100MB/s (4.1GB)
...

***
Nice one. How does it work out percentages though? I guess only in case of file s open as read only? And
it will probably not work in case of scattered access. – j_kubik Dec 22 '14 at 17:29

In this case you can also use another terminal to run pkill -USR1 dd to make dd show its status, another
option would be watch -n 1 pkill -USR1 dd to make it show its progress periodically (every second). –
Yaron Mar 16 '15 at 9:23

***
While pv can deal with local cp tasks, using dd with pv can deal with both local (cp) and remote (scp) tasks.

dd if=path/to/source.mkv | pv | dd of=path/to/dest.mkv
Please ensure the path/to/dest.mkv exits by touch path/to/dest.mkv

This can show the progress, but if you want the percentage information,

dd if=path/to/source.mkv | pv -s 100M | dd of=path/to/dest.mkv
Replace 100M above with the real size of your source file.

Here Comes the Remote Part
While scp can hardly show current progress, using dd with pv is a piece of cake.

ssh onemach@myotherhost dd if=path/to/source.mkv | pv -s 100M | dd of=path/to/dest.mkv

***
There's a new tool called cv that can find any descriptor related to a running command and show progress
and speed: https://github.com/Xfennec/cv

cv -w
outputs the stats for all running cp,mv etc. operations

***
watch cv -q is even neater – wiak Jan 19 '15 at 0:42

It only show progress for an individual files, it does realise whether a cp is copying a directory
recursively or not. – Flimm Mar 31 at 9:27

***
As many said, cp does not include this functionality.

Just to throw my $0.02, what I usually do with trivial copying situations (i.e. no -R):

See how big the file is and remember
Start copying
Open another terminal
Run watch ls -lh DIR on the directory where the target is
This can keep me updated on target file size, with quite a minimum hassle.
As an alternative for less trivial situations, e.g. recursively copying directories, you can use watch
du -hs DIR to see summary of DIR size. However du can take long to compute and can even slow down the
copying, so you might want to use -n INTERVAL argument to watch so that trade-off is acceptable.
Update: In case you use wild-cards with command used with watch du, e.g. watch du -hs backup/*, don't
forget to quote:
watch "du -hs backup/*"
otherwise the wild-cards will be expanded only once, when watch is started so du will not look at new
files / subdirectories.

***
Does not answer the "speed" part, though... – Alois Mahdal Nov 16 '12 at 13:21

***
Use a shell script:

#!/bin/sh
cp_p()
{
   strace -q -ewrite cp -- "${1}" "${2}" 2>&1 \
      | awk '{
	count += $NF
	    if (count % 10 == 0) {
	       percent = count / total_size * 100
	       printf "%3d%% [", percent
	       for (i=0;i<=percent;i++)
		  printf "="
	       printf ">"
	       for (i=percent;i<100;i++)
		  printf " "
	       printf "]\r"
	    }
	 }
	 END { print "" }' total_size=$(stat -c '%s' "${1}") count=0
}
This will look like:

% cp_p /home/echox/foo.dat /home/echox/bar.dat
66% [===============================>			   ]
Source

***
Depending on what you want to do, Midnight Commander (mc) might be the answer. I'm surprised it's not
been mentioned yet.
Tools like pv or rsync are good to display progress of transfer of one huge file, but when it comes to
copying whole directories/trees, mc calculates the size and then displays the progress very nicely. Plus
it's available out of the box on majority of systems.

***
"it's available out of the box on majority of systems." ... not on any default Ubuntu installation. –
muru Jan 30 at 17:58

***
If you have rsync 3.1 or higher (rsync --version), you can copy (cp -Rpn) while preserving permissions
and ownership, recurse directories, "no clobber," and display overall progress (instead of just progress
by file), copy rate, and (very rough) estimated time remaining with:

sudo rsync -a --info=progress2 --no-i-r /source /destination
Note that sudo is only needed if dealing with directories/files you don't own. Also, without the --no-i-r,
the percentage may reset to a lower number at some point during the copy. Perhaps later versions of
rsync will default to no-i-r with info=progress2, but it does not in the current version of 3.1.2.

I've found that the percentage and time remaining are grossly overestimated when copying to a directory
that already contains files (ie. like when you would typically use cp -n "no clobber").


******************************
