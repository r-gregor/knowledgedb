filename: python_howto_args-and-kwargs-multif_20171020.txt
https://www.digitalocean.com/community/tutorials/how-to-use-args-and-kwargs-in-python-3

How To Use *args and **kwargs in Python 3
May 9, 2017

Introduction
   In function definitions, [36]parameters are named entities that specify an argument that a given
   function can accept.

   When programming, you may not be aware of all the possible use cases of your code, and may want to
   offer more options for future programmers working with the module, or for users interacting with the
   code. We can pass a variable number of arguments to a function by using *args and **kwargs in our
   code.

Understanding *args
   In Python, the single-asterisk form of *args can be used as a parameter to send a non-keyworded
   variable-length argument list to functions. It is worth noting that the asterisk (*) is the important
   element here, as the word args is the established conventional idiom, though it is not enforced by
   the language.

   Let’s look at a typical function that uses two arguments:
   lets_multiply.py
def multiply(x, y):
    print (x * y)

   In the code above, we built the function with x and y as arguments, and then when we call the
   function, we need to use numbers to correspond with x and y. In this case, we will pass the integer 5
   in for x and the integer 4 in for y:
   lets_multiply.py
def multiply(x, y):
    print (x * y)

multiply(5, 4)

   Now, we can run the above code:
     * python lets_multiply.py

   We’ll receive the following output, showing that the integers 5 and 4 were multiplied as per the
   multiply(x,y) function:

   Output
20

   What if, later on, we decide that we would like to multiply three numbers rather than just two? If we
   try to add an additional number to the function, as shown below, we’ll receive an error.
   lets_multiply.py
def multiply(x, y):
    print (x * y)

multiply(5, 4, 3)

   Output
TypeError: multiply() takes 2 positional arguments but 3 were given

   So, if you suspect that you may need to use more arguments later on, you can make use of *args as
   your parameter instead.

   We can essentially create the same function and code that we showed in the first example, by removing
   x and y as function parameters, and instead replacing them with *args:
   lets_multiply.py
def multiply(*args):
    z = 1
    for num in args:
        z *= num
    print(z)

multiply(4, 5)
multiply(10, 9)
multiply(2, 3, 4)
multiply(3, 5, 10, 6)

   When we run this code, we’ll receive the product for each of these function calls:

   Output
20
90
24
900

   Because we used *args to send a variable-length argument list to our function, we were able to pass
   in as many arguments as we wished into the function calls.

   With *args you can create more flexible code that accepts a varied amount of non-keyworded arguments
   within your function.

Understanding **kwargs
   The double asterisk form of **kwargs is used to pass a keyworded, variable-length argument
   [37]dictionary to a function. Again, the two asterisks (**) are the important element here, as the
   word kwargs is conventionally used, though not enforced by the language.

   Like *args, **kwargs can take however many arguments you would like to supply to it. However,
   **kwargs differs from *args in that you will need to assign keywords.

   First, let’s simply print out the **kwargs arguments that we pass to a function. We’ll create a short
   function to do this:
   print_kwargs.py
def print_kwargs(**kwargs):
        print(kwargs)

   Next, we’ll call the function with some keyworded arguments passed into the function:
   print_kwargs.py
def print_kwargs(**kwargs):
        print(kwargs)

print_kwargs(kwargs_1="Shark", kwargs_2=4.5, kwargs_3=True)

   Let’s run the program above and look at the output:
     * python print_kwargs.py

   Output
{'kwargs_3': True, 'kwargs_2': 4.5, 'kwargs_1': 'Shark'}

   Because the dictionary data type is unordered, we received the key-value pairs in a random order, but
   it is important to note that a dictionary called **kwargs is created and we can work with it just
   like we can work with other dictionaries.

   Let’s create another short program to show how we can make use of **kwargs. Here we’ll create a
   function to greet a dictionary of names. First, we’ll start with a dictionary of two names:
   print_values.py
def print_values(**kwargs):
    for key, value in kwargs.items():
        print("The value of {} is {}".format(key, value))

print_values(my_name="Sammy", your_name="Casey")

   We can now run the program and look at the output:
     * python print_values.py

   Output
The value of your_name is Casey
The value of my_name is Sammy

   Again, because dictionaries are unordered, your output may be with the name Casey first or with the
   name Sammy first.

   Let’s now pass additional arguments to the function to show that **kwargs will accept however many
   arguments you would like to include:
   print_values.py
def print_values(**kwargs):
    for key, value in kwargs.items():
        print("The value of {} is {}".format(key, value))

print_values(
            name_1="Alex",
            name_2="Gray",
            name_3="Harper",
            name_4="Phoenix",
            name_5="Remy",
            name_6="Val"
        )

   When we run the program at this point, we’ll receive the following output, which is again unordered:

   Output
The value of name_2 is Gray
The value of name_6 is Val
The value of name_4 is Phoenix
The value of name_5 is Remy
The value of name_3 is Harper
The value of name_1 is Alex

   Using **kwargs provides us with flexibility to use keyword arguments in our program. When we use
   **kwargs as a parameter, we don’t need to know how many arguments we would eventually like to pass to
   a function.

Ordering Arguments
   When ordering arguments within a function or function call, arguments need to occur in a particular
   order:
    1. Formal positional arguments
    2. *args
    3. Keyword arguments
    4. **kwargs

   In practice, when working with explicit positional parameters along with *args and **kwargs, your
   function would look like this:
def example(arg_1, arg_2, *args, **kwargs):
...

   And, when working with positional parameters along with named keyword parameters in addition to *args
   and **kwargs, your function would look like this:
def example2(arg_1, arg_2, *args, kw_1="shark", kw_2="blobfish", **kwargs):
...

   It is important to keep the order of arguments in mind when creating functions so that you do not
   receive a syntax error in your Python code.

Using *args and **kwargs in Function Calls

   We can also use *args and **kwargs to pass arguments into functions.

   First, let’s look at an example with *args.
   some_args.py
def some_args(arg_1, arg_2, arg_3):
    print("arg_1:", arg_1)
    print("arg_2:", arg_2)
    print("arg_3:", arg_3)

args = ("Sammy", "Casey", "Alex")
some_args(*args)

   In the function above, there are three parameters defined as arg_1, arg_, and arg_3. The function
   will print out each of these arguments. We then create a variable that is set to an iterable (in this
   case, a [38]tuple), and can pass that variable into the function with the asterisk syntax.

   When we run the program with the python some_args.py command, we’ll receive the following output:

   Output
arg_1: Sammy
arg_2: Casey
arg_3: Alex

   We can also modify the program above to an iterable [39]list data type with a different variable
   name. Let’s also combine the *args syntax with a [40]named parameter:
   some_args.py
def some_args(arg_1, arg_2, arg_3):
    print("arg_1:", arg_1)
    print("arg_2:", arg_2)
    print("arg_3:", arg_3)

my_list = [2, 3]
some_args(1, *my_list)

   If we run the program above, it will produce the following output:

   Output
arg_1: 1
arg_2: 2
arg_3: 3

   Similarly, the keyworded **kwargs arguments can be used to call a function. We will set up a variable
   equal to a dictionary with 3 key-value pairs (we’ll use kwargs here, but it can be called whatever
   you want), and pass it to a function with 3 arguments:
   some_kwargs.py
def some_kwargs(kwarg_1, kwarg_2, kwarg_3):
    print("kwarg_1:", kwarg_1)
    print("kwarg_2:", kwarg_2)
    print("kwarg_3:", kwarg_3)

kwargs = {"kwarg_1": "Val", "kwarg_2": "Harper", "kwarg_3": "Remy"}
some_kwargs(**kwargs)

   Let’s run the program above with the python some_kwargs.py command:

   Output
kwarg_1: Val
kwarg_2: Harper
kwarg_3: Remy

   When calling a function, you can use *args and **kwargs to pass arguments.

Conclusion
   We can use the special syntax of *args and **kwargs within a function definition in order to pass a
   variable number of arguments to the function.

   Creating functions that accept *args and **kwargs are best used in situations where you expect that
   the number of inputs within the argument list will remain relatively small. The use of *args and
   **kwargs is primarily to provide readability and convenience, but should be done with care.

Tutorial Series
[https://www.digitalocean.com/community/tutorial_series/how-to-code-in-python-3] How To Code in Python 3

   Python is an extremely readable and versatile programming language. With a name inspired by the
   British comedy group Monty Python, it was an important foundational goal of the Python development
   team to make the language fun to use. Written in a relatively straightforward style with immediate
   feedback on errors, Python has a lot to offer as a programming language.


---
https://pythontips.com/2013/08/04/args-and-kwargs-in-python-explained/

*args and **kwargs in python explained
August 4, 2013

   Hi there folks. I have come to see that most new python programmers have a hard time figuring out the
   *args and **kwargs magic variables. So what are they ? First of all let me tell you that it is not
   necessary to write *args or **kwargs. Only the * (aesteric) is necessary. You could have also written
   *var and **vars. Writing *args and **kwargs is just a convention. So now lets take a look at *args
   first.

   Usage of *args
   *args and **kwargs are mostly used in function definitions. *args and **kwargs allow you to pass a
   variable number of arguments to a function. What does variable mean here is that you do not know
   before hand that how many arguments can be passed to your function by the user so in this case you
   use these two keywords. *args is used to send a non-keyworded variable length argument list to the
   function. Here’s an example to help you get a clear idea:
def test_var_args(f_arg, *argv):
    print "first normal arg:", f_arg
    for arg in argv:
        print "another arg through *argv :", arg

test_var_args('yasoob','python','eggs','test')

   This produces the following result:
first normal arg: yasoob
another arg through *argv : python
another arg through *argv : eggs
another arg through *argv : test

   I hope this cleared away any confusion that you had. So now lets talk about **kwargs

   Usage of **kwargs
   **kwargs allows you to pass keyworded variable length of arguments to a function. You should use
   **kwargs if you want to handle named arguments in a function. Here is an example to get you going
   with it:
def greet_me(**kwargs):
    if kwargs is not None:
        for key, value in kwargs.iteritems():
            print "%s == %s" %(key,value)

>>> greet_me(name="yasoob")
name == yasoob

   So can you see how we handled a keyworded argument list in our function. This is just the basics of
   **kwargs and you can see how useful it is. Now lets talk about how you can use *args and **kwargs to
   call a function with a list or dictionary of arguments.

   Using *args and **kwargs to call a function
   So here we will see how to call a function using *args and **kwargs. Just consider that you have this
   little function:
def test_args_kwargs(arg1, arg2, arg3):
    print "arg1:", arg1
    print "arg2:", arg2
    print "arg3:", arg3

   Now you can use *args or **kwargs to pass arguments to this little function. Here’s how to do it:
# first with *args
>>> args = ("two", 3,5)
>>> test_args_kwargs(*args)
arg1: two
arg2: 3
arg3: 5

# now with **kwargs:
>>> kwargs = {"arg3": 3, "arg2": "two","arg1":5}
>>> test_args_kwargs(**kwargs)
arg1: 5
arg2: two
arg3: 3

   Order of using *args **kwargs and formal args
   So if you want to use all three of these in functions then the order is
some_func(fargs,*args,**kwargs)

   I hope you have understood the usage of *args and **kwargs. If you have got any problems or
   confusions with this then feel free to comment below. For further study i suggest the official
   python docs on defining functions and *args and **kwargs on stackoverflow.


---
https://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/

How to use *args and **kwargs in Python
2012-12-20

   Or, How to use variable length argument lists in Python.

   The special syntax, *args and **kwargs in function definitions is used to pass a variable number of
   arguments to a function. The single asterisk form (*args) is used to pass a non-keyworded,
   variable-length argument list, and the double asterisk form is used to pass a keyworded,
   variable-length argument list. Here is an example of how to use the non-keyworded form. This example
   passes one formal (positional) argument, and two more variable length arguments.
def test_var_args(farg, *args):
    print "formal arg:", farg
    for arg in args:
        print "another arg:", arg

test_var_args(1, "two", 3)

   Results:
formal arg: 1
another arg: two
another arg: 3

   Here is an example of how to use the keyworded form. Again, one formal argument and two keyworded
   variable arguments are passed.
def test_var_kwargs(farg, **kwargs):
    print "formal arg:", farg
    for key in kwargs:
        print "another keyword arg: %s: %s" % (key, kwargs[key])

test_var_kwargs(farg=1, myarg2="two", myarg3=3)

   Results:
formal arg: 1
another keyword arg: myarg2: two
another keyword arg: myarg3: 3

Using *args and **kwargs when calling a function[6]¶

   This special syntax can be used, not only in function definitions, but also when calling a function.
def test_var_args_call(arg1, arg2, arg3):
    print "arg1:", arg1
    print "arg2:", arg2
    print "arg3:", arg3

args = ("two", 3)
test_var_args_call(1, *args)

   Results:
arg1: 1
arg2: two
arg3: 3

   Here is an example using the keyworded form when calling a function:
def test_var_args_call(arg1, arg2, arg3):
    print "arg1:", arg1
    print "arg2:", arg2
    print "arg3:", arg3

kwargs = {"arg3": 3, "arg2": "two"}
test_var_args_call(1, **kwargs)

   Results:
arg1: 1
arg2: two
arg3: 3


---
http://thepythonguru.com/python-args-and-kwargs/

Python *args and **kwargs

What is *args ??
   *args  allows us to pass variable number of arguments to the function. Let’s take an example to make
   this clear.

   Suppose you created a function to add two number like this.

   def sum(a, b):
       print("sum is", a+b)

   As you can see this program only accepts two numbers, what if you want to pass more than two
   arguments, this is where *args  comes into play.

   def sum(*args):
       s = 0
       for i in args:
           s += i
       print("sum is", s)

   Now you can pass any number of arguments to the function like this,

   >>> sum(1, 2, 3)
   6
   >>> sum(1, 2, 3, 4, 5, 7)
   22
   >>> sum(1, 2, 3, 4, 5, 7, 8, 9, 10)
   49
   >>> sum()
   0

   Note: name of *args  is just a convention you can use anything that is a valid identifier. For e.g
   *myargs is perfectly valid.

What is **kwargs ?
   **kwargs allows us to pass variable number of keyword argument like this func_name(name='tim',
   team='school')

   def my_func(**kwargs):
       for i, j in kwargs.items():
           print(i, j)

   my_func(name='tim', sport='football', roll=19)

   Expected Output:

   sport football
   roll 19
   name tim

Using *args and **kwargs in function call
   You can use *args  to pass elements in an iterable variable to a function. Following example will
   clear everything.

   def my_three(a, b, c):
       print(a, b, c)

   a = [1,2,3]
   my_three(*a) # here list is broken into three elements

   Note: This works only when number of argument is same as number of elements in the iterable variable.

   Similarly you can use **kwargs  to call a function like this

   def my_three(a, b, c):
       print(a, b, c)

   a = {'a': "one", 'b': "two", 'c': "three" }
   my_three(**a)

   Note: For this to work 2 things are necessary:
    1. Names of arguments in function must match with the name of keys in dictionary.
    2. Number of arguments should be same as number of keys in the dictionary.


---
https://hackernoon.com/python-functions-args-kwargs-5d2d00f09c74

Python functions, *args, **kwargs

   Why use args and kwargs with python? A little while ago I did not understand kwargs, I find that to
   write about something helps build an understanding of a topic and it allows the information to be
   digested, much like rubber ducking. Also, because learning is fun and filling in knowledge gaps is
   better, here we go. [18]https://rubberduckdebugging.com/

   I am going to borrow a number of examples from the digital ocean tutorial about this because the way
   that they explained it really helped me to understand it.
   [19]https://www.digitalocean.com/community/tutorials/how-to-use-args-and-kwargs-in-python-3

   Variables in functions with python; in order to pass data to a function variables are setup and
   passed in a specific order. The example function is called with a string and a number, simple enough.
def profile_info(username, followers):
 print(“Username: “ + username)
 print(“Followers: “ + str(followers))
profile_info("chris",15)
>>Username: chris
>>Followers: 15

   Problem: This approach and function call mandates that the variables are passed in a specific order
   and all of the variables must always be passed.
   Solution: Add some default values which will let us pass none or some of the values without incurring
   an error.
def profile_info(username="name", followers=0):
 print(“Username: “ + username)
 print(“Followers: “ + str(followers))
profile_info()
profile_info(username="thor")
>>Username: name
>>Followers: 0
>>Username: thor
>>Followers: 0

   Benefit: Order doesn’t matter when passing via keyword. If we want to mix and match the order of the
   variables we can pass variables with the keyword attached.
def profile_info(username="name", followers=0):
 print(“Username: “ + username)
 print(“Followers: “ + str(followers))
profile_info(followers=6, username="thor")
>>Username: thor
>>Followers: 6

   Great, now what about many of variables ... Using *args we can pass an undisclosed number of
   variables as a tuple. Whats the difference between a tuple and a list? In python a tuple is
   immutable, where as a list is mutable.

     Some objects are mutable, meaning they can be altered. Others are immutable; they cannot be
     changed but rather return new objects when attempting to update.
     [20]https://codehabitude.com/2013/12/24/python-objects-mutable-vs-immutable/

   Why does mutability matter?
string_build = ""
for data in container:
    string_build += str(data)

   Simple enough but because a string is an immutable object, a new object is created on every concat,
   throwing away the old one and as a result using more memory.

   Solutions:
builder_list = []
for data in container:
    builder_list.append(str(data))
“”.join(builder_list)

### Another way is to use a list comprehension
“”.join([str(data) for data in container])

### or use the map function
“”.join(map(str, container))

   Another gotcha is using a list as a parameter for a function, otherwise known as the poor mans args.
def my_function(param=[]):
 param.append(“thing”)
 return param

my_function() # returns [“thing”]
my_function() # returns [“thing”, “thing”]

   Despite using the empty list as a default value, python only evaluates the definition once and
   therefore that empty list is only empty before the first time it is called. The function will reuse
   the same list every time it is called. *oops

   Back to *args, for functions. Lists are cool and all but using the *args option for function
   parameters is very useful. This way the function can accept any number of variables without having to
   rebuild the call for each permutation.
def multiply(*args):
    z = 1
    for num in args:
        z *= num
    print(z)
multiply(4, 5)
multiply(10, 9)

   That is pretty awesome but it lacks the ability to have a different order of params and to define
   specific params. This gives us more flexibility in one area but less in another. Whats the fix for
   that?

   **kwargs

   KWargs or “keyword arguments” allows you to pass the keyworded, dictionary as arguments. Because
   dictionaries are almost always super useful.
def print_values(**kwargs):
    for key, value in kwargs.items():
        print("The value of {} is {}".format(key, value))
print_values(my_name="thor", your_name="hulk")

   Key worded arguments are a pretty fantastic additional however, in order to leverage them effectively
   the code is going to have to handle dictionaries appropriately. Finally if the intent is to mix and
   match argument types the order of the declaration needs to work like this.
def example2(arg_1, arg_2, *args, kw_1="shark", kw_2="blobfish", **kwargs):
...

   What about passing to args and kwargs? Simple enough just build a list or a dictionary and pass it to
   the proper function.
def some_args(arg_1, arg_2, arg_3):
    print("arg_1:", arg_1)
    print("arg_2:", arg_2)
    print("arg_3:", arg_3)
my_list = [2, 3]
some_args(1, *my_list)
def some_kwargs(kwarg_1, kwarg_2, kwarg_3):
    print("kwarg_1:", kwarg_1)
    print("kwarg_2:", kwarg_2)
    print("kwarg_3:", kwarg_3)
kwargs = {"kwarg_1": "Val", "kwarg_2": "Harper", "kwarg_3": "Remy"}
some_kwargs(**kwargs)

   Conclusions, args and kwargs are fantastic for a number of cases, but of course they are not the end
   all be all solution. When writing functions and using them only use what is needed, don’t just use
   kwargs because it’s a new shiny toy because when all you have is a hammer then everything is a nail.
   Think about optimization, think about memory usage and think about maintainability as well as
   readability, then use the appropriate data type for the job.


---
https://wsvincent.com/python-args-kwargs/

Python *args and **kwargs
Sep 20, 2016

   Python has a special syntax, * (single asterisk) and ** (double asterisks), that lets you pass a
   variable number of arguments to a function. By convention, these are written as *args and **kwargs,
   but only the asterisks are important; you could equally write *vars and **vars to achieve the same
   result.

   *args is used to pass a non-keyworded variable-length argument list to your function. **kwargs lets
   you pass a keyworded variable-length of arguments to your function.

Python functions
   In a traditional Python function, you must explicitly define the number of arguments and parameters.
def func_one(x):
    print(x)

func_one(5)
# 5

   But what if the number of parameters does not match the number of arguments? For example, if we
   define one parameter but pass in none:
func_one()
# func_one() missing 1 required positional argument: 'x'

   And if we pass in two arguments but only define one parameter:
func_one(5, 10)
# TypeError: func_one() takes 1 positional argument but 2 were given

   In Python a function only works if the number of arguments matches the number of parameters.

*args example
   By using *args we can attach a variable-length number of arguments into our function.

   For example:
def func_var_args(*args):
    print(args)

func_var_args(1, 2, '3')
# (1, 2, '3')

   This is useful when we don’t know how many arguments we need to pass in.

**kwargs example
   If we want to pass a keyworded variable length of arguments to a function, we use **kwargs. It lets
   us handle named arguments in our function.

   As an example:
def func_keyword_arg(**kwargs):
    print(kwargs)

func_keyword_arg(keyword1=10, keyword2='foo')
# {'keyword2': 'foo', 'keyword1': 10}

   If we wanted to return just the key/value we can use the [4]items() method.
def func_keyword_arg_dict(\**kwargs):
    for key, value in kwargs.items():
        print(key,":",value)

func_keyword_arg_dict(keyword1=10, keyword2='foo')
# keyword2 : foo
# keyword1 : 1

*args and **kwargs together
   Often *args and **kwargs are used together in a function where we have at least one required
   argument. In these instances, order matters. Positional-only parameters must come first, so *args and
   **kwargs are placed after any required arguments.
def one_required_arg(required_arg, *args, **kwargs):
    print(required_arg)
    if args:
        print(args)
    if kwargs:
        print(kwargs)

   All three of the following will work with this function:
func("required argument")
func("required argument", 1, 2, '3')
func("required argument", 1, 2, '3', keyword1=4, keyword2="foo")

Final thoughts
   *args and **kwargs are powerful Python features that can make writing functions a much more enjoyable
   task. They are also common when [5]extending an existing method in a subclass.

   Just remember, normal, positional-only parameters come first. A simple way to remember this is always
   add *args and **kwargs at the end of your required arguments.

   So if we have one required argument, write:
def some_func(required_arg, *args, **kwargs):
    pass

   If there are two required arguments:
def some_func(required_arg1, required_arg2, *args, **kwargs):
    pass

   And so on!


---
http://agiliq.com/blog/2012/06/understanding-args-and-kwargs/

Understanding '*', '*args', '**' and '**kwargs'

   When i started learning Python, i was very confused regarding what args, kwargs, * and ** does. And i
   feel there are few like me who had this confusion and problem. With this post, i intend to reduce
   (hopefully i can eliminate) that confusion.

   Throughout this post, i will be using ipython and i suggest you to try everything on ipython as well.
   We will intentionally make some mistakes along the way, so that we can understand this topic better.

Let's divide our work under five sections:
    1. Understanding what '*' does from inside a function call.
    2. Understanding what '*args' mean inside a function definition.
    3. Understanding what '**' does from inside a function call.
    4. Understanding what '**kwargs' mean inside a function definition.
    5. A practical example of where we use 'args', 'kwargs' and why we use it.

Understanding what * does from inside a function call.

   Let's define a function "fun" which takes three positional arguments.
In [5]: def fun(a, b, c):
   ...:     print a, b, c
   ...:
   ...:

   Call this function passing three positional arguments
In [7]: fun(1,2,3)
1 2 3                     #Output

   So, calling this function by passing three positional arguments, prints the three arguments passed to
   the function.

   Let's make a list with three integer values in it.
In [8]: l = [1,2,3]

   Let's use '*' now.
In [9]: fun(*l)
1 2 3                     #Output

What did '*' do?

   It unpacked the values in list 'l' as positional arguments. And then the unpacked values were passed
   to function 'fun' as positional arguments.

   So, unpacking the values in list and changing it to positional arguments meant writing fun(*l) was
   equivalent to writing fun(1,2,3). Keep in mind that l=[1,2,3]. Let's try with some other value of
   'l'.
In [10]: l=[5,7,9]

In [11]: fun(*l)
5 7 9                     #Output

   Let's make some errors now. Let's put four values in "l".
In [12]: l=[3,5,6,9]

   Now, try to call function "fun".
In [13]: fun(*l)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/home/akshar/branding_git/netconference/<ipython console> in <module>()

TypeError: fun() takes exactly 3 arguments (4 given)

   So, in our last statement which is 'fun(*l)' we did not get a proper output and a TypeError was
   raised. See the error, it says "TypeError: fun() takes exactly 3 arguments (4 given)".

Why did it happen?
   list 'l' contains four values. So, when we tried 'fun(*l)', 'l' was unpacked so that its value could
   be sent as positional arguments. But, "l" has four values in it. So, writing 'fun(*l)' was equivalent
   to writing 'fun(3,5,6,9)'. But, 'fun' is defined to take only three positional arguments and hence we
   got this error. Similary, you can follow same steps with two values in list 'l' and notice the error.
In [14]: l=[5,6]

In [15]: fun(*l)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/home/akshar/branding_git/netconference/<ipython console> in <module>()

TypeError: fun() takes exactly 3 arguments (2 given)

   Let's mix '*l' with a positional argument.
In [16]: fun(1, *l)
1 5 6                  #Output.

   Here we gave one positional argument which is 1 and two values i.e 5 and 6 were unpacked from "l" and
   hence 1,5 and 6 were passed to 'fun'.

   Hope you were able to follow what '*' does when used inside a function call.

Understanding what '*args' mean inside a function definition.

   Let's change the function definition now.
In [18]: def fun(*args):
   ....:     print args
   ....:
   ....:

   Call this function with one positional argument.
In [19]: fun(1)
(1,)                  #Output

   Now call this function with two positional arguments or any number of positional arguments you wish.
In [20]: fun(1,2,3)
(1, 2, 3)

What does '*args' in a function definition do?
   It recieves a tuple containing the positional arguments beyond the formal parameter list. So, "args"
   is a tuple. Don't worry about the part "formal parameter list" in our explanation, it will be clear
   with next few examples. In our last example when we printed "args", it printed a tuple which
   contained all the values we passed while calling the function.

   Let's mix "*args" with some "formal parameter list". Note that in our last example we didn't have any
   formal parameter list. Let's redefine our function.
In [21]: def fun(a, *args):
   ....:     print "a is ", a
   ....:     print "args is ", args
   ....:
   ....:

   In this function definition, parameter "a" constitue the "formal parameter list". Let's call "fun"
   with four positional argument.
In [22]: fun(1, 2, 3, 4)
a is  1                                #Output
args is  (2, 3, 4)

   So, we can see that 'a' is assigned 1 which was the first positional argument. There is only one
   parameter "*args" defined after "a". So, "args" received a tuple containing the positional arguments
   beyond the formal parameter list. So, args received 2, 3 and 4 as a tuple.

   We can also call "fun" with just one positional argument. Let's do that.
In [23]: fun(1)
a is  1                                #Output
args is  ()                            #args received an empty tuple

   Here, we passed only one argument to the function which was assigned to the formal parameter 'a'. So,
   'args' received an empty tuple as can be seen from the output.

   After we have "args", we can extract the values and do whatever we want. Let's redefine "fun".
In [24]: def fun(a, *args):
   ....:     print a
   ....:     print "args can receive a tuple of any number of arguments. Let's print all that."
   ....:     for arg in args:
   ....:         print arg
   ....:
   ....:

   We can call "fun" with any number of arguments.
In [25]: fun(1,5,6,7)
1                                                                         #Output
args can receive a tuple of any number of arguments. Let's print all that.
5
6
7

   Since 'args' is a tuple, we could iterate over it.

   Now, let's consider a case where we use whatever we saw till here. Here we need to use two functions.
   First function has to take an arbitrary number of arguments and it has to calculate the sum of all
   the arguments except the first argument. Also, this function has to make use of another function to
   calculate the sum. Weird use case, but we just need to recap whatever we did till here. The objective
   here is to see how we get a variable number of arguments in a function and pass these arguments to
   another function.

   Let's first write the function which has to calculate the sum i.e the second function. For our use
   case, this function will be used in the first function which we are yet to write.
In [26]: def calculate_sum(*args):
   ....:     return sum(args)
   ....:

   Here we make use of 'sum'. Function 'sum' is an inbuilt function which takes a tuple or a list and
   return the sum of all the elements in the tuple. From our function definition we can see that 'args'
   will receive a tuple containing all the positional arguments passed to this function. So, 'args' will
   be a tuple and can be directly used as an argument to function 'sum'. Let's write the other function
   which takes any number of arguments and uses previous function to calulate the sum of all arguments
   except the first argument.
In [29]: def ignore_firstargs_calculate_sum(a, *iargs):
   ....:     required_sum = calculate_sum(*iargs)
   ....:     print "sum is", required_sum
   ....:
   ....:

   We can pass any number of arguments to this function. First argument will be recieved by 'a' which is
   a formal parameter. All other arguments will be recieved by 'iargs' as a tuple. As per the case we
   are considering, we want to calculate the sum of all arguments except the first. So, we leave 'a' as
   it receives the first argument. 'iargs' is the tuple containing all arguments except the first. We
   will make use of function 'calculate_sum'. But 'calculate_sum' expects number of positional arguments
   to be sent to it which it will receive in 'args' as a tuple. So, in function
   'ignore_firstargs_calculate_sum' we need to unpack 'iargs', as it is a tuple, and then send the
   unpacked positional arguments to 'calculate_sum'. Remember, we used '*' to unpack a list/tuple.

   So, we write 'required_sum=calculate_sum(*iargs)'.

   We can't write 'required_sum=calculate_sum(iargs)' because we need to unpack the values in the tuple
   'iargs' before sending to 'calculate_sum'. Not using '*' will not unpack the values and hence we
   won't have the desired behaviour. Let's use the function we wrote.
In [34]: ignore_firstargs_calculate_sum(3,1,2,6)
sum is 9                          #Output

   The output is the sum of all arguments except the first argument.

Understanding what '**' does when used from inside a function.
   Let's consider a simple example first. Let's define a function which takes three arguments.
In [35]: def fun(a, b, c):
   ....:     print a, b, c
   ....:
   ....:

   Let's call this function in various ways.
In [36]: fun(1,2,3)
1 2 3                            #Output

In [37]: fun(1, b=4, c=6)
1 4 6                            #Output

   Let's use "**" from inside the function call. For this we want a dictionary. Remember, while using
   "*" in the function call, we required a list/tuple. For using "**" in the function call, we require a
   dictionary.
In [38]: d={'b':5, 'c':7}

   Let's call "fun" using "**" in the function call.
In [39]: fun(1, **d)
1 5 7

What "**" did while being used in a function call?
   It unpacked the dictionary used with it, and passed the items in the dictionary as keyword arguments
   to the function. So writing "fun(1, **d)" was equivalent to writing "fun(1, b=5, c=7)".

   Let's try some more examples to understand it better.
In [40]: d={'c':3}

In [42]: fun(1,2,**d)           #This is equivalent to fun(1,2,c=3)
1 2 3

In [43]: d={'a':7,'b':8,'c':9}

In [44]: fun(**d)
7 8 9                           #Output

   Let's make some errors now.
In [45]: d={'a':1, 'b':2, 'c':3, 'd':4}

In [46]: fun(**d)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/home/akshar/branding_git/netconference/<ipython console> in <module>()

TypeError: fun() got an unexpected keyword argument 'd'

   Last statement was equivalent to fun(a=1, b=2, c=3, d=4). But, "fun" expected only three arguments
   and hence we got this error.
In [47]: d={'a':1, 'b':5, 'd':9}

In [48]: fun(**d)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/home/akshar/branding_git/netconference/<ipython console> in <module>()

TypeError: fun() got an unexpected keyword argument 'd'

   Last statement was equivalent to fun(a=1, b=5, d=9). Although it passed three arguments which is the
   number of arguments expected by "fun", but "fun" does not have 'd' in its parameter list. But, 'd'
   was passed as a keyword argument And hence we got this error.

   So, "**" unpacks the dictionary i.e the key values pairs in the dictionary as keyword arguments and
   these are sent as keyword arguments to the function being called. "*" unpacks a list/tuple i.e the
   values in the list as positional arguments and these are sent as positional arguments to the function
   being called.

Understanding "**kwargs" in a function definition.
   Let's redefine our function "fun".
In [49]: def fun(a, **kwargs):
   ....:     print a, kwargs
   ....:
   ....:

   So, this function can only take one positional argument since formal parameter list contains only one
   variable 'a'. But with "**kwargs", it can take any number of keyword arguments. Let's see some
   examples.
In [50]: fun(1, b=4, c=5)
1 {'c': 5, 'b': 4}                #Output

In [51]: fun(2, b=6, c=7, d=8)
2 {'c': 7, 'b': 6, 'd': 8}        #Output

What does "**kwargs" mean when used in a function definition?
   With "**kwargs" in the function definition, kwargs receives a dictionary containing all the keyword
   arguments beyond the formal parameter list. Remember 'kwargs' will be a dictionary. In our previous
   two examples, when we printed kwargs, it printed a dictionary containing all the keyword arguments
   beyond the formal parameter list.

   Let's again redefine our function.
In [54]: def fun(a, **kwargs):
   ....:     print "a is", a
   ....:     print "We expect kwargs 'b' and 'c' in this function"
   ....:     print "b is", kwargs['b']
   ....:     print "c is", kwargs['c']
   ....:
   ....:

   Let's call "fun" now.
In [55]: fun(1, b=3, c=5)
a is 1
We expect kwargs 'b' and 'c' in this function
b is 3
c is 5

   Let's make some errors now.
In [56]: fun(1, b=3, d=5)
a is 1
We expect kwargs 'b' and 'c' in this function
b is 3
c is---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)

/home/akshar/branding_git/netconference/<ipython console> in <module>()

/home/akshar/branding_git/netconference/<ipython console> in fun(a, **kwargs)

KeyError: 'c'

   We were able to call the function. First positional argument was printed. Keyword argument 'b' was
   printed. But the other keyword argument we passed was 'd'. Since function expected a keyword argument
   'c' and tried to access it from the dictionary "kwargs". But since we did not pass any keyword
   argument 'c', we got this error. If we add a keyword argument 'c' in the function call, we won't get
   the error anymore.
In [57]: fun(1, b=3, d=5, c=7)
a is 1
We expect kwargs 'b' and 'c' in this function
b is 3
c is 7

   Since having "**kwargs" in the function argument list, we can pass any number of keyword arguments.
   We passed 'd' but did not make any use of it in the function.

   Let's make one more error.
In [58]: fun(1, {'b':2, 'c':3})
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/home/akshar/branding_git/netconference/<ipython console> in <module>()

TypeError: fun() takes exactly 1 argument (2 given)

   As the error says, Function "fun" expected only one postional argument but was given two. So,
   although 'kwargs' receives the keyword arguments as a dictionary, you cannot pass a dictionary as a
   positional argument to 'kwargs'. Although you could have done somehing like:
In [59]: fun(1, **{'b':2, 'c':3})
a is 1
We expect kwargs 'b' and 'c' in this function
b is 2
c is 3

   Using "**" in front of the dictionary unpacks the dictionary and passes the items in dictionary as
   keyword arguments.

A practical example of where we use 'args', '*kwargs' and why we use it.
   Whenever we inherit a class and override some of the methods of inherited class, we should use
   '*args' and '**kwargs' and pass the received positional and keyword arguments to the superclass
   method. Can be better understood with an example.
In [4]: class Model(object):
   ...:     def __init__(self, name):
   ...:         self.name = name
   ...:     def save(self, force_update=False, force_insert=False):
   ...:         if force_update and force_insert:
   ...:             raise ValueError("Cannot perform both operations")
   ...:         if force_update:
   ...:             #Update an existing record
   ...:             print "Updated an existing record"
   ...:         if force_insert:
   ...:             #Create a new record
   ...:             print "Created a new record"
   ...:

   We defined a class. We can create objects of this class and objects of this class have a method
   "save()". Assume that the objects of this class can be saved in a database which is being done inside
   the save() method. Depending on the arguments we pass to save() method, it is determined whether new
   records need to be created in the database or an existing record need to be updated.

   We want a new class where we want 'Model' behaviour but we only want to have save the objects of this
   class after we have checked some conditions. So let's subclass 'Model' and override 'save()' of
   'Model'.
In [6]: class ChildModel(Model):
   ...:     def save(self, *args, **kwargs):
   ...:         if self.name=='abcd':
   ...:             super(ChildModel, self).save(*args, **kwargs)
   ...:         else:
   ...:             return None
   ...:

   Actual saving of object(as per our assumption, connecting with database and creating/updating)
   happens in the "save" method of "Model". So we need to call the "save()" method of superclass from
   save() method of ChildModel. Also, save() method of subclass i.e ChildModel should be able to accept
   any arguments that save() of superclass accepts and must pass through these arguments to the
   superclass save(). So we have "*args" and "**kwargs" in the argument list of subclass save() method
   to receive any positional arguments or keyword arguments beyond the formal parameter list.

   Let's create an instance of ChildModel and save it.
In [7]: c=ChildModel('abcd')

   So, we created an instance of ChildModel with name='abcd'.
In [9]: c.save(force_insert=True)
Created a new record       #Output

   Here, we passed a keyword argument to save() of the object. The save() we called is the subclass
   save(). It received a dictionary containing the keyword argument in "kwargs". Then it used "**" to
   unpack this dictionary as keyword arguments and then passed it to the superclass save(). So,
   superclass save() got a keyword argument 'force_insert' and acted accordingly.

   Let's try to pass another keyword argument.
In [10]: c.save(force_update=True)
Updated an existing record      #Output

   That was all about it. Hope you liked the post.
