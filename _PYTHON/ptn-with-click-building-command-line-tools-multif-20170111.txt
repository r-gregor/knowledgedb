filename: python-with-click_building-command-line-tools-multif_20170111.txt
https://kushaldas.in/posts/building-command-line-tools-in-python-with-click.html

Building command line tools in Python with click

   2017-01-09T12:33:13+05:30 on [12]Click [13]Fedora [14]Python

   Sometimes I get requests from new programmers to help them to learn to develop command line tools.
   They ask for any easy tutorial and howtos. My answer used to be argparse module, and the [15]official
   tutorial on the same topic is simple to understand.

   But now I recommend people use [16]click module. Like any other project from [17]Armin Ronacher, it
   has great documentation. In this post, I am going to write a beginners tutorial, you should the read
   the documentation for any more details and examples.

Installation, and development tips
   Using virtualenv is highly recommended for developing â€˜clickâ€™ applications. I am going to assume
   that we are in an empty directory and the continue from there. To start, we will have a simple
   hello.py file with the following content:
def cli():
        print("Hello World")

   Now we will need a setup.py file. This will help us to use the python module we are writing as a
   command line tool. It is also the recommended way to write command line tools in python, then
   directly using shebang based scripts.
from setuptools import setup

setup(
    name="myhello",
    version='0.1',
    py_modules=['hello'],
    install_requires=[
        'Click',
    ],
    entry_points='''
        [console_scripts]
        myhello=hello:cli
    ''',
)

   You can see that we mentioned the starting point of our tool in the entry_points, hello:cli points to
   the right function to start with. We can then install this on the virtualenv locally. I will also
   create the virtualenv below so that becomes easier others. To learn more, read this [18]chapter
   later.
$ python3 -m venv env
$ source env/bin/activate
$ pip install --editable .
Obtaining file:///home/kdas/code/practice/yoclick
Collecting Click (from myhello==0.1)
  Using cached click-6.7-py2.py3-none-any.whl
Installing collected packages: Click, myhello
  Running setup.py develop for myhello
Successfully installed Click-6.7 myhello

$ myhello
Hello World

   Now to convert the same script into a click based tool, we will make the following modifications. Now
   when we execute the command again, we see nothing changed visually, but it magically has a --help
   command line argument (which is optional).
$ myhello
Hello World
$ myhello --help
Usage: myhello [OPTIONS]

Options:
  --help  Show this message and exit.

Using echo for printing text
   The click module suggests using echo function to print, rather than the standard print function. So,
   we will make the required change in our code.
import click

@click.command()
def cli():
    click.echo("Hello World")

Boolean flags
   In a command line tool, we sometimes want to have a boolean option. If the option is provided then do
   something, if not provided, then do something else. In our example, we will call the flag as
   --verbose, it is provided, then we will print some extra text.
import click

@click.command()
@click.option('--verbose', is_flag=True, help="Will print verbose messages.")
def cli(verbose):
    if verbose:
        click.echo("We are in the verbose mode.")
    click.echo("Hello World")

   We added another decorator to the cli function. In click.option() decorator, first we passed the flag
   using "--verbose", then marked this option as a boolean flag, and then finally added the help
   text.
$ myhello --help
Usage: myhello [OPTIONS]

Options:
  --verbose  Will print verbose messages.
  --help     Show this message and exit.
$ myhello --verbose
We are in the verbose mode.
Hello World

   By default, any boolean flag is treated as false.

Standard options in the command line
   We can now add more options to our tool. For example, we will have a --name option which will take a
   string as input.
import click

@click.command()
@click.option('--verbose', is_flag=True, help="Will print verbose messages.")
@click.option('--name', default='', help='Who are you?')
def cli(verbose,name):
    if verbose:
        click.echo("We are in the verbose mode.")
    click.echo("Hello World")
    click.echo('Bye {0}'.format(name))

$ myhello --help
Usage: myhello [OPTIONS]

Options:
  --verbose    Will print verbose messages.
  --name TEXT  Who are you?
  --help       Show this message and exit.
$ myhello
Hello World
Bye
$ myhello --name kushal
Hello World
Bye kushal

Same option multiple times
   We may want to take the same option multiple times. Click has a very simple way to do so.
import click

@click.command()
@click.option('--verbose', is_flag=True, help="Will print verbose messages.")
@click.option('--name', '-n', multiple=True, default='', help='Who are you?')
def cli(verbose,name):
    if verbose:
        click.echo("We are in the verbose mode.")
    click.echo("Hello World")
    for n in name:
        click.echo('Bye {0}'.format(n))

   In the above example, you can see that we specified the --name as a multiple options. It also means
   the name parameter in the cli function is now a tuple.

Help text for the script
   We can add help text for the script using python docstrings. For example:
import click

@click.command()
@click.option('--verbose', is_flag=True, help="Will print verbose messages.")
@click.option('--name', '-n', multiple=True, default='', help='Who are you?')
def cli(verbose,name):
    """This is an example script to learn Click."""
    if verbose:
        click.echo("We are in the verbose mode.")
    click.echo("Hello World")
    for n in name:
        click.echo('Bye {0}'.format(n))

$ myhello --help
Usage: myhello [OPTIONS]

  This is an example script to learn Click.

Options:
  --verbose        Will print verbose messages.
  -n, --name TEXT  Who are you?
  --help           Show this message and exit.

Super fast way to accept password with confirmation
   Click provides a password_option() decorator, which can be used to accept a password over hidden
   prompt and second confirmation prompt. Btw, I am printing the password here as an example, never
   print the password to stdout in any tool.
import click

@click.command()
@click.option('--verbose', is_flag=True, help="Will print verbose messages.")
@click.option('--name', '-n', multiple=True, default='', help='Who are you?')
@click.password_option()
def cli(verbose,name, password):
    """This is an example script to learn Click."""
    if verbose:
        click.echo("We are in the verbose mode.")
    click.echo("Hello World")
    for n in name:
        click.echo('Bye {0}'.format(n))
    click.echo('We received {0} as password.'.format(password))

   The output looks like below:
$ myhello --help
Usage: myhello [OPTIONS]

  This is an example script to learn Click.

Options:
  --verbose        Will print verbose messages.
  -n, --name TEXT  Who are you?
  --password TEXT
  --help           Show this message and exit.
$ myhello
Password:
Repeat for confirmation:
Hello World
We received hello as password.

   To learn the full usage of password prompts, read [19]this section.

Must have arguments
   You can also add arguments to your tool. These are must haves, and if no default value is provided,
   they are assumed to be strings. In the below example, the script is expecting a county name to be
   specified.
import click

@click.command()
@click.option('--verbose', is_flag=True, help="Will print verbose messages.")
@click.option('--name', '-n', multiple=True, default='', help='Who are you?')
@click.argument('country')
def cli(verbose,name, country):
    """This is an example script to learn Click."""
    if verbose:
        click.echo("We are in the verbose mode.")
    click.echo("Hello {0}".format(country))
    for n in name:
        click.echo('Bye {0}'.format(n))

   The output looks like:
$ myhello
Usage: myhello [OPTIONS] COUNTRY

Error: Missing argument "country".
$ myhello India
Hello India

   Click has many other useful features, like yes parameter, file path input. I am not going to write
   about all of those here, but you can always from the [http://click.pocoo.org/]upstream documentation.


---
http://click.pocoo.org/5/setuptools/#setuptools-integration

Setuptools Integration[10]
   When writing command line utilities, it’s recommended to write them as modules that are distributed
   with setuptools instead of using Unix shebangs.

   Why would you want to do that? There are a bunch of reasons:
    1. One of the problems with the traditional approach is that the first module the Python interpreter
       loads has an incorrect name. This might sound like a small issue but it has quite significant
       implications.
       The first module is not called by its actual name, but the interpreter renames it to __main__.
       While that is a perfectly valid name it means that if another piece of code wants to import from
       that module it will trigger the import a second time under its real name and all of a sudden your
       code is imported twice.
    2. Not on all platforms are things that easy to execute. On Linux and OS X you can add a comment to
       the beginning of the file (#!/usr/bin/env python) and your script works like an executable
       (assuming it has the executable bit set). This however does not work on Windows. While on Windows
       you can associate interpreters with file extensions (like having everything ending in .py execute
       through the Python interpreter) you will then run into issues if you want to use the script in a
       virtualenv.
       In fact running a script in a virtualenv is an issue with OS X and Linux as well. With the
       traditional approach you need to have the whole virtualenv activated so that the correct Python
       interpreter is used. Not very user friendly.
    3. The main trick only works if the script is a Python module. If your application grows too large
       and you want to start using a package you will run into issues.

Introduction[11]
   To bundle your script with setuptools, all you need is the script in a Python package and a setup.py
   file.

   Imagine this directory structure:
yourscript.py
setup.py

   Contents of yourscript.py:
import click

@click.command()
def cli():
    """Example script."""
    click.echo('Hello World!')

   Contents of setup.py:
from setuptools import setup

setup(
    name='yourscript',
    version='0.1',
    py_modules=['yourscript'],
    install_requires=[
        'Click',
    ],
    entry_points='''
        [console_scripts]
        yourscript=yourscript:cli
    ''',
)

   The magic is in the entry_points parameter. Below console_scripts, each line identifies one console
   script. The first part before the equals sign (=) is the name of the script that should be generated,
   the second part is the import path followed by a colon (:) with the Click command.

   That’s it.

Testing The Script[12]
   To test the script, you can make a new virtualenv and then install your package:
$ virtualenv venv
$ . venv/bin/activate
$ pip install --editable .

   Afterwards, your command should be available:
$ yourscript
Hello World!

Scripts in Packages[13]
   If your script is growing and you want to switch over to your script being contained in a Python
   package the changes necessary are minimal. Let’s assume your directory structure changed to this:
yourpackage/
    __init__.py
    main.py
    utils.py
    scripts/
        __init__.py
        yourscript.py

   In this case instead of using py_modules in your setup.py file you can use packages and the automatic
   package finding support of setuptools. In addition to that it’s also recommended to include other
   package data.

   These would be the modified contents of setup.py:
from setuptools import setup, find_packages

setup(
    name='yourpackage',
    version='0.1',
    packages=find_packages(),
    include_package_data=True,
    install_requires=[
        'Click',
    ],
    entry_points='''
        [console_scripts]
        yourscript=yourpackage.scripts.yourscript:cli
    ''',
)


---
http://click.pocoo.org/5/options/#password-prompts

Options[10]
   Adding options to commands can be accomplished by the [11]option() decorator. Since options can come
   in various different versions, there are a ton of parameters to configure their behavior. Options in
   click are distinct from [12]positional arguments.

Basic Value Options[13]
   The most basic option is a value option. These options accept one argument which is a value. If no
   type is provided, the type of the default value is used. If no default value is provided, the type is
   assumed to be [14]STRING. By default, the name of the parameter is the first long option defined;
   otherwise the first short one is used.
@click.command()
@click.option('--n', default=1)
def dots(n):
    click.echo('.' * n)

   And on the command line:
$ dots --n=2
..

   In this case the option is of type [15]INT because the default value is an integer.

Multi Value Options[16]
   Sometimes, you have options that take more than one argument. For options, only a fixed number of
   arguments is supported. This can be configured by the nargs parameter. The values are then stored as
   a tuple.
@click.command()
@click.option('--pos', nargs=2, type=float)
def findme(pos):
    click.echo('%s / %s' % pos)

   And on the command line:
$ findme --pos 2.0 3.0
2.0 / 3.0

Tuples as Multi Value Options[17]
   New in version 4.0.

   As you can see that by using nargs set to a specific number each item in the resulting tuple is of
   the same type. This might not be what you want. Commonly you might want to use different types for
   different indexes in the tuple. For this you can directly specify a tuple as type:
@click.command()
@click.option('--item', type=(unicode, int))
def putitem(item):
    click.echo('name=%s id=%d' % item)

   And on the command line:
$ putitem --item peter 1338
name=peter id=1338

   By using a tuple literal as type, nargs gets automatically set to the length of the tuple and the
   [18]click.Tuple type is automatically used. The above example is thus equivalent to this:
@click.command()
@click.option('--item', nargs=2, type=click.Tuple([unicode, int]))
def putitem(item):
    click.echo('name=%s id=%d' % item)

Multiple Options[19]
   Similarly to nargs, there is also the case of wanting to support a parameter being provided multiple
   times to and have all values recorded – not just the last one. For instance, git commit -m foo -m bar
   would record two lines for the commit message: foo and bar. This can be accomplished with the
   multiple flag:

   Example:
@click.command()
@click.option('--message', '-m', multiple=True)
def commit(message):
    click.echo('\n'.join(message))

   And on the command line:
$ commit -m foo -m bar
foo
bar

Counting[20]
   In some very rare circumstances, it is interesting to use the repetition of options to count an
   integer up. This can be used for verbosity flags, for instance:
@click.command()
@click.option('-v', '--verbose', count=True)
def log(verbose):
    click.echo('Verbosity: %s' % verbose)

   And on the command line:
$ log -vvv
Verbosity: 3

Boolean Flags[21]
   Boolean flags are options that can be enabled or disabled. This can be accomplished by defining two
   flags in one go separated by a slash (/) for enabling or disabling the option. (If a slash is in an
   option string, Click automatically knows that it’s a boolean flag and will pass is_flag=True
   implicitly.) Click always wants you to provide an enable and disable flag so that you can change the
   default later.

   Example:
import sys

@click.command()
@click.option('--shout/--no-shout', default=False)
def info(shout):
    rv = sys.platform
    if shout:
        rv = rv.upper() + '!!!!111'
    click.echo(rv)

   And on the command line:
$ info --shout
LINUX2!!!!111
$ info --no-shout
linux2

   If you really don’t want an off-switch, you can just define one and manually inform Click that
   something is a flag:
import sys

@click.command()
@click.option('--shout', is_flag=True)
def info(shout):
    rv = sys.platform
    if shout:
        rv = rv.upper() + '!!!!111'
    click.echo(rv)

   And on the command line:
$ info --shout
LINUX2!!!!111

   Note that if a slash is contained in your option already (for instance, if you use Windows-style
   parameters where / is the prefix character), you can alternatively split the parameters through ;
   instead:
@click.command()
@click.option('/debug;/no-debug')
def log(debug):
    click.echo('debug=%s' % debug)

if __name__ == '__main__':
    log()

Feature Switches[22]
   In addition to boolean flags, there are also feature switches. These are implemented by setting
   multiple options to the same parameter name and defining a flag value. Note that by providing the
   flag_value parameter, Click will implicitly set is_flag=True.

   To set a default flag, assign a value of True to the flag that should be the default.
import sys

@click.command()
@click.option('--upper', 'transformation', flag_value='upper',
              default=True)
@click.option('--lower', 'transformation', flag_value='lower')
def info(transformation):
    click.echo(getattr(sys.platform, transformation)())

   And on the command line:
$ info --upper
LINUX2
$ info --lower
linux2
$ info
LINUX2

Choice Options[23]
   Sometimes, you want to have a parameter be a choice of a list of values. In that case you can use
   [24]Choice type. It can be instantiated with a list of valid values.

   Example:
@click.command()
@click.option('--hash-type', type=click.Choice(['md5', 'sha1']))
def digest(hash_type):
    click.echo(hash_type)

   What it looks like:
$ digest --hash-type=md5
md5

$ digest --hash-type=foo
Usage: digest [OPTIONS]

Error: Invalid value for "--hash-type": invalid choice: foo. (choose from md5, sha1)

$ digest --help
Usage: digest [OPTIONS]

Options:
  --hash-type [md5|sha1]
  --help                  Show this message and exit.

Prompting[25]
   In some cases, you want parameters that can be provided from the command line, but if not provided,
   ask for user input instead. This can be implemented with Click by defining a prompt string.

   Example:
@click.command()
@click.option('--name', prompt=True)
def hello(name):
    click.echo('Hello %s!' % name)

   And what it looks like:
$ hello --name=John
Hello John!
$ hello
Name: John
Hello John!

   If you are not happy with the default prompt string, you can ask for a different one:
@click.command()
@click.option('--name', prompt='Your name please')
def hello(name):
    click.echo('Hello %s!' % name)

   What it looks like:
$ hello
Your name please: John
Hello John!

Password Prompts[26]
   Click also supports hidden prompts and asking for confirmation. This is useful for password input:
@click.command()
@click.option('--password', prompt=True, hide_input=True,
              confirmation_prompt=True)
def encrypt(password):
    click.echo('Encrypting password to %s' % password.encode('rot13'))

   What it looks like:
$ encrypt
Password:
Repeat for confirmation:
Encrypting password to frperg

   Because this combination of parameters is quite common, this can also be replaced with the
   [27]password_option() decorator:
@click.command()
@click.password_option()
def encrypt(password):
    click.echo('Encrypting password to %s' % password.encode('rot13'))

Dynamic Defaults for Prompts[28]
   The auto_envvar_prefix and default_map options for the context allow the program to read option
   values from the environment or a configuration file. However, this overrides the prompting mechanism,
   so that the user does not get the option to change the value interactively.

   If you want to let the user configure the default value, but still be prompted if the option isn’t
   specified on the command line, you can do so by supplying a callable as the default value. For
   example, to get a default from the environment:
@click.command()
@click.option('--username', prompt=True,
              default=lambda: os.environ.get('USER', ''))
def hello(username):
    print("Hello,", username)

Callbacks and Eager Options[29]
   Sometimes, you want a parameter to completely change the execution flow. For instance, this is the
   case when you want to have a --version parameter that prints out the version and then exits the
   application.

   Note: an actual implementation of a --version parameter that is reusable is available in Click as
   [30]click.version_option(). The code here is merely an example of how to implement such a flag.

   In such cases, you need two concepts: eager parameters and a callback. An eager parameter is a
   parameter that is handled before others, and a callback is what executes after the parameter is
   handled. The eagerness is necessary so that an earlier required parameter does not produce an error
   message. For instance, if --version was not eager and a parameter --foo was required and defined
   before, you would need to specify it for --version to work. For more information, see [31]Callback
   Evaluation Order.

   A callback is a function that is invoked with two parameters: the current [32]Context and the value.
   The context provides some useful features such as quitting the application and gives access to other
   already processed parameters.

   Here an example for a --version flag:
def print_version(ctx, param, value):
    if not value or ctx.resilient_parsing:
        return
    click.echo('Version 1.0')
    ctx.exit()

@click.command()
@click.option('--version', is_flag=True, callback=print_version,
              expose_value=False, is_eager=True)
def hello():
    click.echo('Hello World!')

   The expose_value parameter prevents the pretty pointless version parameter from being passed to the
   callback. If that was not specified, a boolean would be passed to the hello script. The
   resilient_parsing flag is applied to the context if Click wants to parse the command line without any
   destructive behavior that would change the execution flow. In this case, because we would exit the
   program, we instead do nothing.

   What it looks like:
$ hello
Hello World!
$ hello --version
Version 1.0

   Callback Signature Changes

   In Click 2.0 the signature for callbacks changed. For more information about these changes see
   [33]Upgrading to 2.0.

Yes Parameters[34]
   For dangerous operations, it’s very useful to be able to ask a user for confirmation. This can be
   done by adding a boolean --yes flag and asking for confirmation if the user did not provide it and to
   fail in a callback:
def abort_if_false(ctx, param, value):
    if not value:
        ctx.abort()

@click.command()
@click.option('--yes', is_flag=True, callback=abort_if_false,
              expose_value=False,
              prompt='Are you sure you want to drop the db?')
def dropdb():
    click.echo('Dropped all tables!')

   And what it looks like on the command line:
$ dropdb
Are you sure you want to drop the db? [y/N]: n
Aborted!
$ dropdb --yes
Dropped all tables!

   Because this combination of parameters is quite common, this can also be replaced with the
   [35]confirmation_option() decorator:
@click.command()
@click.confirmation_option(help='Are you sure you want to drop the db?')
def dropdb():
    click.echo('Dropped all tables!')

   Callback Signature Changes

   In Click 2.0 the signature for callbacks changed. For more information about these changes see
   [36]Upgrading to 2.0.

Values from Environment Variables[37]
   A very useful feature of Click is the ability to accept parameters from environment variables in
   addition to regular parameters. This allows tools to be automated much easier. For instance, you
   might want to pass a configuration file with a --config parameter but also support exporting a
   TOOL_CONFIG=hello.cfg key-value pair for a nicer development experience.

   This is supported by Click in two ways. One is to automatically build environment variables which is
   supported for options only. To enable this feature, the auto_envvar_prefix parameter needs to be
   passed to the script that is invoked. Each command and parameter is then added as an uppercase
   underscore-separated variable. If you have a subcommand called foo taking an option called bar and
   the prefix is MY_TOOL, then the variable is MY_TOOL_FOO_BAR.

   Example usage:
@click.command()
@click.option('--username')
def greet(username):
    click.echo('Hello %s!' % username)

if __name__ == '__main__':
    greet(auto_envvar_prefix='GREETER')

   And from the command line:
$ export GREETER_USERNAME=john
$ greet
Hello john!

   The second option is to manually pull values in from specific environment variables by defining the
   name of the environment variable on the option.

   Example usage:
@click.command()
@click.option('--username', envvar='USERNAME')
def greet(username):
    click.echo('Hello %s!' % username)

if __name__ == '__main__':
    greet()

   And from the command line:
$ export USERNAME=john
$ greet
Hello john!

   In that case it can also be a list of different environment variables where the first one is picked.

Multiple Values from Environment Values[38]
   As options can accept multiple values, pulling in such values from environment variables (which are
   strings) is a bit more complex. The way Click solves this is by leaving it up to the type to
   customize this behavior. For both multiple and nargs with values other than 1, Click will invoke the
   [39]ParamType.split_envvar_value() method to perform the splitting.

   The default implementation for all types is to split on whitespace. The exceptions to this rule are
   the [40]File and [41]Path types which both split according to the operating system’s path splitting
   rules. On Unix systems like Linux and OS X, the splitting happens for those on every colon (:), and
   for Windows, on every semicolon (;).

   Example usage:
@click.command()
@click.option('paths', '--path', envvar='PATHS', multiple=True,
              type=click.Path())
def perform(paths):
    for path in paths:
        click.echo(path)

if __name__ == '__main__':
    perform()

   And from the command line:
$ export PATHS=./foo/bar:./test
$ perform
./foo/bar
./test

Other Prefix Characters[42]
   Click can deal with alternative prefix characters other than - for options. This is for instance
   useful if you want to handle slashes as parameters / or something similar. Note that this is strongly
   discouraged in general because Click wants developers to stay close to POSIX semantics. However in
   certain situations this can be useful:
@click.command()
@click.option('+w/-w')
def chmod(w):
    click.echo('writable=%s' % w)

if __name__ == '__main__':
    chmod()

   And from the command line:
$ chmod +w
writable=True
$ chmod -w
writable=False

   Note that if you are using / as prefix character and you want to use a boolean flag you need to
   separate it with ; instead of /:
@click.command()
@click.option('/debug;/no-debug')
def log(debug):
    click.echo('debug=%s' % debug)

if __name__ == '__main__':
    log()

Range Options[43]
   A special mention should go to the [44]IntRange type, which works very similarly to the [45]INT type,
   but restricts the value to fall into a specific range (inclusive on both edges). It has two modes:
     * the default mode (non-clamping mode) where a value that falls outside of the range will cause an
       error.
     * an optional clamping mode where a value that falls outside of the range will be clamped. This
       means that a range of 0-5 would return 5 for the value 10 or 0 for the value -1 (for example).

   Example:
@click.command()
@click.option('--count', type=click.IntRange(0, 20, clamp=True))
@click.option('--digit', type=click.IntRange(0, 10))
def repeat(count, digit):
    click.echo(str(digit) * count)

if __name__ == '__main__':
    repeat()

   And from the command line:
$ repeat --count=1000 --digit=5
55555555555555555555
$ repeat --count=1000 --digit=12
Usage: repeat [OPTIONS]

Error: Invalid value for "--digit": 12 is not in the valid range of 0 to 10.

   If you pass None for any of the edges, it means that the range is open at that side.

Callbacks for Validation[46]
   Changed in version 2.0.

   If you want to apply custom validation logic, you can do this in the parameter callbacks. These
   callbacks can both modify values as well as raise errors if the validation does not work.

   In Click 1.0, you can only raise the [47]UsageError but starting with Click 2.0, you can also raise
   the [48]BadParameter error, which has the added advantage that it will automatically format the error
   message to also contain the parameter name.

   Example:
def validate_rolls(ctx, param, value):
    try:
        rolls, dice = map(int, value.split('d', 2))
        return (dice, rolls)
    except ValueError:
        raise click.BadParameter('rolls need to be in format NdM')

@click.command()
@click.option('--rolls', callback=validate_rolls, default='1d6')
def roll(rolls):
    click.echo('Rolling a %d-sided dice %d time(s)' % rolls)

if __name__ == '__main__':
    roll()

   And what it looks like:
$ roll --rolls=42
Usage: roll [OPTIONS]

Error: Invalid value for "--rolls": rolls need to be in format NdM

$ roll --rolls=2d12
Rolling a 12-sided dice 2 time(s)


---
https://docs.python.org/3/howto/argparse.html

Argparse Tutorial[14]

   author: Tshepang Lekhonkhobe

   This tutorial is intended to be a gentle introduction to [15]argparse, the recommended command-line
   parsing module in the Python standard library.

   Note

   There are two other modules that fulfill the same task, namely [16]getopt (an equivalent for getopt()
   from the C language) and the deprecated [17]optparse. Note also that [18]argparse is based on
   [19]optparse, and therefore very similar in terms of usage.

Concepts[20]
   Let’s show the sort of functionality that we are going to explore in this introductory tutorial by
   making use of the ls command:
$ ls
cpython  devguide  prog.py  pypy  rm-unused-function.patch
$ ls pypy
ctypes_configure  demo  dotviewer  include  lib_pypy  lib-python ...
$ ls -l
total 20
drwxr-xr-x 19 wena wena 4096 Feb 18 18:51 cpython
drwxr-xr-x  4 wena wena 4096 Feb  8 12:04 devguide
-rwxr-xr-x  1 wena wena  535 Feb 19 00:05 prog.py
drwxr-xr-x 14 wena wena 4096 Feb  7 00:59 pypy
-rw-r--r--  1 wena wena  741 Feb 18 01:01 rm-unused-function.patch
$ ls --help
Usage: ls [OPTION]... [FILE]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.
...

   A few concepts we can learn from the four commands:
     * The ls command is useful when run without any options at all. It defaults to displaying the
       contents of the current directory.
     * If we want beyond what it provides by default, we tell it a bit more. In this case, we want it to
       display a different directory, pypy. What we did is specify what is known as a positional
       argument. It’s named so because the program should know what to do with the value, solely based
       on where it appears on the command line. This concept is more relevant to a command like cp,
       whose most basic usage is cp SRC DEST. The first position is what you want copied, and the second
       position is where you want it copied to.
     * Now, say we want to change behaviour of the program. In our example, we display more info for
       each file instead of just showing the file names. The -l in that case is known as an optional
       argument.
     * That’s a snippet of the help text. It’s very useful in that you can come across a program you
       have never used before, and can figure out how it works simply by reading its help text.

The basics[21]
   Let us start with a very simple example which does (almost) nothing:
import argparse
parser = argparse.ArgumentParser()
parser.parse_args()

   Following is a result of running the code:
$ python3 prog.py
$ python3 prog.py --help
usage: prog.py [-h]

optional arguments:
  -h, --help  show this help message and exit
$ python3 prog.py --verbose
usage: prog.py [-h]
prog.py: error: unrecognized arguments: --verbose
$ python3 prog.py foo
usage: prog.py [-h]
prog.py: error: unrecognized arguments: foo

   Here is what is happening:
     * Running the script without any options results in nothing displayed to stdout. Not so useful.
     * The second one starts to display the usefulness of the [22]argparse module. We have done almost
       nothing, but already we get a nice help message.
     * The --help option, which can also be shortened to -h, is the only option we get for free (i.e. no
       need to specify it). Specifying anything else results in an error. But even then, we do get a
       useful usage message, also for free.

Introducing Positional arguments[23]
   An example:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("echo")
args = parser.parse_args()
print(args.echo)

   And running the code:
$ python3 prog.py
usage: prog.py [-h] echo
prog.py: error: the following arguments are required: echo
$ python3 prog.py --help
usage: prog.py [-h] echo

positional arguments:
  echo

optional arguments:
  -h, --help  show this help message and exit
$ python3 prog.py foo
foo

   Here is what’s happening:
     * We’ve added the add_argument() method, which is what we use to specify which command-line options
       the program is willing to accept. In this case, I’ve named it echo so that it’s in line with its
       function.
     * Calling our program now requires us to specify an option.
     * The parse_args() method actually returns some data from the options specified, in this case,
       echo.
     * The variable is some form of ‘magic’ that [24]argparse performs for free (i.e. no need to specify
       which variable that value is stored in). You will also notice that its name matches the string
       argument given to the method, echo.

   Note however that, although the help display looks nice and all, it currently is not as helpful as it
   can be. For example we see that we got echo as a positional argument, but we don’t know what it does,
   other than by guessing or by reading the source code. So, let’s make it a bit more useful:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("echo", help="echo the string you use here")
args = parser.parse_args()
print(args.echo)

   And we get:
$ python3 prog.py -h
usage: prog.py [-h] echo

positional arguments:
  echo        echo the string you use here

optional arguments:
  -h, --help  show this help message and exit

   Now, how about doing something even more useful:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("square", help="display a square of a given number")
args = parser.parse_args()
print(args.square**2)

   Following is a result of running the code:
$ python3 prog.py 4
Traceback (most recent call last):
  File "prog.py", line 5, in <module>
    print(args.square**2)
TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'

   That didn’t go so well. That’s because [25]argparse treats the options we give it as strings, unless
   we tell it otherwise. So, let’s tell [26]argparse to treat that input as an integer:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("square", help="display a square of a given number",
                    type=int)
args = parser.parse_args()
print(args.square**2)

   Following is a result of running the code:
$ python3 prog.py 4
16
$ python3 prog.py four
usage: prog.py [-h] square
prog.py: error: argument square: invalid int value: 'four'

   That went well. The program now even helpfully quits on bad illegal input before proceeding.

Introducing Optional arguments[27]
   So far we, have been playing with positional arguments. Let us have a look on how to add optional
   ones:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--verbosity", help="increase output verbosity")
args = parser.parse_args()
if args.verbosity:
    print("verbosity turned on")

   And the output:
$ python3 prog.py --verbosity 1
verbosity turned on
$ python3 prog.py
$ python3 prog.py --help
usage: prog.py [-h] [--verbosity VERBOSITY]

optional arguments:
  -h, --help            show this help message and exit
  --verbosity VERBOSITY
                        increase output verbosity
$ python3 prog.py --verbosity
usage: prog.py [-h] [--verbosity VERBOSITY]
prog.py: error: argument --verbosity: expected one argument

   Here is what is happening:
     * The program is written so as to display something when --verbosity is specified and display
       nothing when not.
     * To show that the option is actually optional, there is no error when running the program without
       it. Note that by default, if an optional argument isn’t used, the relevant variable, in this case
       args.verbosity, is given None as a value, which is the reason it fails the truth test of the
       [28]if statement.
     * The help message is a bit different.
     * When using the --verbosity option, one must also specify some value, any value.

   The above example accepts arbitrary integer values for --verbosity, but for our simple program, only
   two values are actually useful, True or False. Let’s modify the code accordingly:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--verbose", help="increase output verbosity",
                    action="store_true")
args = parser.parse_args()
if args.verbose:
    print("verbosity turned on")

   And the output:
$ python3 prog.py --verbose
verbosity turned on
$ python3 prog.py --verbose 1
usage: prog.py [-h] [--verbose]
prog.py: error: unrecognized arguments: 1
$ python3 prog.py --help
usage: prog.py [-h] [--verbose]

optional arguments:
  -h, --help  show this help message and exit
  --verbose   increase output verbosity

   Here is what is happening:
     * The option is now more of a flag than something that requires a value. We even changed the name
       of the option to match that idea. Note that we now specify a new keyword, action, and give it the
       value "store_true". This means that, if the option is specified, assign the value True to
       args.verbose. Not specifying it implies False.
     * It complains when you specify a value, in true spirit of what flags actually are.
     * Notice the different help text.

Short options[29]
   If you are familiar with command line usage, you will notice that I haven’t yet touched on the topic
   of short versions of the options. It’s quite simple:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("-v", "--verbose", help="increase output verbosity",
                    action="store_true")
args = parser.parse_args()
if args.verbose:
    print("verbosity turned on")

   And here goes:
$ python3 prog.py -v
verbosity turned on
$ python3 prog.py --help
usage: prog.py [-h] [-v]

optional arguments:
  -h, --help     show this help message and exit
  -v, --verbose  increase output verbosity

   Note that the new ability is also reflected in the help text.

Combining Positional and Optional arguments[30]
   Our program keeps growing in complexity:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("square", type=int,
                    help="display a square of a given number")
parser.add_argument("-v", "--verbose", action="store_true",
                    help="increase output verbosity")
args = parser.parse_args()
answer = args.square**2
if args.verbose:
    print("the square of {} equals {}".format(args.square, answer))
else:
    print(answer)

   And now the output:
$ python3 prog.py
usage: prog.py [-h] [-v] square
prog.py: error: the following arguments are required: square
$ python3 prog.py 4
16
$ python3 prog.py 4 --verbose
the square of 4 equals 16
$ python3 prog.py --verbose 4
the square of 4 equals 16

     * We’ve brought back a positional argument, hence the complaint.
     * Note that the order does not matter.

   How about we give this program of ours back the ability to have multiple verbosity values, and
   actually get to use them:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("square", type=int,
                    help="display a square of a given number")
parser.add_argument("-v", "--verbosity", type=int,
                    help="increase output verbosity")
args = parser.parse_args()
answer = args.square**2
if args.verbosity == 2:
    print("the square of {} equals {}".format(args.square, answer))
elif args.verbosity == 1:
    print("{}^2 == {}".format(args.square, answer))
else:
    print(answer)

   And the output:
$ python3 prog.py 4
16
$ python3 prog.py 4 -v
usage: prog.py [-h] [-v VERBOSITY] square
prog.py: error: argument -v/--verbosity: expected one argument
$ python3 prog.py 4 -v 1
4^2 == 16
$ python3 prog.py 4 -v 2
the square of 4 equals 16
$ python3 prog.py 4 -v 3
16

   These all look good except the last one, which exposes a bug in our program. Let’s fix it by
   restricting the values the --verbosity option can accept:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("square", type=int,
                    help="display a square of a given number")
parser.add_argument("-v", "--verbosity", type=int, choices=[0, 1, 2],
                    help="increase output verbosity")
args = parser.parse_args()
answer = args.square**2
if args.verbosity == 2:
    print("the square of {} equals {}".format(args.square, answer))
elif args.verbosity == 1:
    print("{}^2 == {}".format(args.square, answer))
else:
    print(answer)

   And the output:
$ python3 prog.py 4 -v 3
usage: prog.py [-h] [-v {0,1,2}] square
prog.py: error: argument -v/--verbosity: invalid choice: 3 (choose from 0, 1, 2)
$ python3 prog.py 4 -h
usage: prog.py [-h] [-v {0,1,2}] square

positional arguments:
  square                display a square of a given number

optional arguments:
  -h, --help            show this help message and exit
  -v {0,1,2}, --verbosity {0,1,2}
                        increase output verbosity

   Note that the change also reflects both in the error message as well as the help string.

   Now, let’s use a different approach of playing with verbosity, which is pretty common. It also
   matches the way the CPython executable handles its own verbosity argument (check the output of python
   --help):
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("square", type=int,
                    help="display the square of a given number")
parser.add_argument("-v", "--verbosity", action="count",
                    help="increase output verbosity")
args = parser.parse_args()
answer = args.square**2
if args.verbosity == 2:
    print("the square of {} equals {}".format(args.square, answer))
elif args.verbosity == 1:
    print("{}^2 == {}".format(args.square, answer))
else:
    print(answer)

   We have introduced another action, “count”, to count the number of occurrences of a specific optional
   arguments:
$ python3 prog.py 4
16
$ python3 prog.py 4 -v
4^2 == 16
$ python3 prog.py 4 -vv
the square of 4 equals 16
$ python3 prog.py 4 --verbosity --verbosity
the square of 4 equals 16
$ python3 prog.py 4 -v 1
usage: prog.py [-h] [-v] square
prog.py: error: unrecognized arguments: 1
$ python3 prog.py 4 -h
usage: prog.py [-h] [-v] square

positional arguments:
  square           display a square of a given number

optional arguments:
  -h, --help       show this help message and exit
  -v, --verbosity  increase output verbosity
$ python3 prog.py 4 -vvv
16

     * Yes, it’s now more of a flag (similar to action="store_true") in the previous version of our
       script. That should explain the complaint.
     * It also behaves similar to “store_true” action.
     * Now here’s a demonstration of what the “count” action gives. You’ve probably seen this sort of
       usage before.
     * And if you don’t specify the -v flag, that flag is considered to have None value.
     * As should be expected, specifying the long form of the flag, we should get the same output.
     * Sadly, our help output isn’t very informative on the new ability our script has acquired, but
       that can always be fixed by improving the documentation for our script (e.g. via the help keyword
       argument).
     * That last output exposes a bug in our program.

   Let’s fix:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("square", type=int,
                    help="display a square of a given number")
parser.add_argument("-v", "--verbosity", action="count",
                    help="increase output verbosity")
args = parser.parse_args()
answer = args.square**2

# bugfix: replace == with >=
if args.verbosity >= 2:
    print("the square of {} equals {}".format(args.square, answer))
elif args.verbosity >= 1:
    print("{}^2 == {}".format(args.square, answer))
else:
    print(answer)

   And this is what it gives:
$ python3 prog.py 4 -vvv
the square of 4 equals 16
$ python3 prog.py 4 -vvvv
the square of 4 equals 16
$ python3 prog.py 4
Traceback (most recent call last):
  File "prog.py", line 11, in <module>
    if args.verbosity >= 2:
TypeError: '>=' not supported between instances of 'NoneType' and 'int'

     * First output went well, and fixes the bug we had before. That is, we want any value >= 2 to be as
       verbose as possible.
     * Third output not so good.

   Let’s fix that bug:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("square", type=int,
                    help="display a square of a given number")
parser.add_argument("-v", "--verbosity", action="count", default=0,
                    help="increase output verbosity")
args = parser.parse_args()
answer = args.square**2
if args.verbosity >= 2:
    print("the square of {} equals {}".format(args.square, answer))
elif args.verbosity >= 1:
    print("{}^2 == {}".format(args.square, answer))
else:
    print(answer)

   We’ve just introduced yet another keyword, default. We’ve set it to 0 in order to make it comparable
   to the other int values. Remember that by default, if an optional argument isn’t specified, it gets
   the None value, and that cannot be compared to an int value (hence the [31]TypeError exception).

   And:
$ python3 prog.py 4
16

   You can go quite far just with what we’ve learned so far, and we have only scratched the surface. The
   [32]argparse module is very powerful, and we’ll explore a bit more of it before we end this tutorial.

Getting a little more advanced[33]
   What if we wanted to expand our tiny program to perform other powers, not just squares:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("x", type=int, help="the base")
parser.add_argument("y", type=int, help="the exponent")
parser.add_argument("-v", "--verbosity", action="count", default=0)
args = parser.parse_args()
answer = args.x**args.y
if args.verbosity >= 2:
    print("{} to the power {} equals {}".format(args.x, args.y, answer))
elif args.verbosity >= 1:
    print("{}^{} == {}".format(args.x, args.y, answer))
else:
    print(answer)

   Output:
$ python3 prog.py
usage: prog.py [-h] [-v] x y
prog.py: error: the following arguments are required: x, y
$ python3 prog.py -h
usage: prog.py [-h] [-v] x y

positional arguments:
  x                the base
  y                the exponent

optional arguments:
  -h, --help       show this help message and exit
  -v, --verbosity
$ python3 prog.py 4 2 -v
4^2 == 16

   Notice that so far we’ve been using verbosity level to change the text that gets displayed. The
   following example instead uses verbosity level to display more text instead:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("x", type=int, help="the base")
parser.add_argument("y", type=int, help="the exponent")
parser.add_argument("-v", "--verbosity", action="count", default=0)
args = parser.parse_args()
answer = args.x**args.y
if args.verbosity >= 2:
    print("Running '{}'".format(__file__))
if args.verbosity >= 1:
    print("{}^{} == ".format(args.x, args.y), end="")
print(answer)

   Output:
$ python3 prog.py 4 2
16
$ python3 prog.py 4 2 -v
4^2 == 16
$ python3 prog.py 4 2 -vv
Running 'prog.py'
4^2 == 16

Conflicting options[34]
   So far, we have been working with two methods of an [35]argparse.ArgumentParser instance. Let’s
   introduce a third one, add_mutually_exclusive_group(). It allows for us to specify options that
   conflict with each other. Let’s also change the rest of the program so that the new functionality
   makes more sense: we’ll introduce the --quiet option, which will be the opposite of the --verbose
   one:
import argparse

parser = argparse.ArgumentParser()
group = parser.add_mutually_exclusive_group()
group.add_argument("-v", "--verbose", action="store_true")
group.add_argument("-q", "--quiet", action="store_true")
parser.add_argument("x", type=int, help="the base")
parser.add_argument("y", type=int, help="the exponent")
args = parser.parse_args()
answer = args.x**args.y

if args.quiet:
    print(answer)
elif args.verbose:
    print("{} to the power {} equals {}".format(args.x, args.y, answer))
else:
    print("{}^{} == {}".format(args.x, args.y, answer))

   Our program is now simpler, and we’ve lost some functionality for the sake of demonstration. Anyways,
   here’s the output:
$ python3 prog.py 4 2
4^2 == 16
$ python3 prog.py 4 2 -q
16
$ python3 prog.py 4 2 -v
4 to the power 2 equals 16
$ python3 prog.py 4 2 -vq
usage: prog.py [-h] [-v | -q] x y
prog.py: error: argument -q/--quiet: not allowed with argument -v/--verbose
$ python3 prog.py 4 2 -v --quiet
usage: prog.py [-h] [-v | -q] x y
prog.py: error: argument -q/--quiet: not allowed with argument -v/--verbose

   That should be easy to follow. I’ve added that last output so you can see the sort of flexibility you
   get, i.e. mixing long form options with short form ones.

   Before we conclude, you probably want to tell your users the main purpose of your program, just in
   case they don’t know:
import argparse

parser = argparse.ArgumentParser(description="calculate X to the power of Y")
group = parser.add_mutually_exclusive_group()
group.add_argument("-v", "--verbose", action="store_true")
group.add_argument("-q", "--quiet", action="store_true")
parser.add_argument("x", type=int, help="the base")
parser.add_argument("y", type=int, help="the exponent")
args = parser.parse_args()
answer = args.x**args.y

if args.quiet:
    print(answer)
elif args.verbose:
    print("{} to the power {} equals {}".format(args.x, args.y, answer))
else:
    print("{}^{} == {}".format(args.x, args.y, answer))

   Note that slight difference in the usage text. Note the [-v | -q], which tells us that we can either
   use -v or -q, but not both at the same time:
$ python3 prog.py --help
usage: prog.py [-h] [-v | -q] x y

calculate X to the power of Y

positional arguments:
  x              the base
  y              the exponent

optional arguments:
  -h, --help     show this help message and exit
  -v, --verbose
  -q, --quiet

Conclusion[36]
   The [37]argparse module offers a lot more than shown here. Its docs are quite detailed and thorough,
   and full of examples. Having gone through this tutorial, you should easily digest them without
   feeling overwhelmed.


---
