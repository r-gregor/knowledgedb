filename: python_combining-two-sorted-lists_20170622.txt
https://stackoverflow.com/questions/464342/combining-two-sorted-lists-in-python

Combining two sorted lists in Python

   I have two lists of objects. Each list is already sorted by a property of the object that is of the
   datetime type. I would like to combine the two lists into one sorted list. Is the best way just to do

***
   People seem to be over complicating this.. Just combine the two lists, then sort them:
>>> l1 = [1, 3, 4, 7]
>>> l2 = [0, 2, 5, 6, 8, 9]
>>> l1.extend(l2)
>>> sorted(l1)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

   ..or shorter (and without modifying l1):
>>> sorted(l1 + l2)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

   ..easy! Plus, it's using only two built-in functions, so assuming the lists are of a reasonable size,
   it should be quicker than implementing the sorting/merging in a loop. More importantly, the above is
   much less code, and very readable.

   If your lists are large (over a few hundred thousand, I would guess), it may be quicker to use an
   alternative/custom sorting method, but there are likely other optimisations to be made first (e.g not
   storing millions of datetime objects)

   Using the timeit.Timer().repeat() (which repeats the functions 1000000 times), I loosely benchmarked
   it against [39]ghoseb's solution, and sorted(l1+l2) is substantially quicker:

   merge_sorted_lists took..
[9.7439379692077637, 9.8844599723815918, 9.552299976348877]

   sorted(l1+l2) took..
[2.860386848449707, 2.7589840888977051, 2.7682540416717529]

***
   Finally a sane answer, taking actual benchmarking into account. :-) --- Also, 1 line to maintain
   instead of 15-20 is much to be preferred. – [45]Deestan Jan 21 '09 at 10:10

***
   Sorting a very short list created by appending two lists will indeed be very fast, as the constant
   overheads will dominate. Try doing this for lists with several million items, or files on disk with
   several billion items, and you'll soon find out why merging is preferable. – [46]Barry Kelly Jan 21
   '09 at 10:16

***
   @Barry: If you have "several billion items" and a speed requisite, anything in Python is the wrong
   answer. – [47]Deestan Jan 21 '09 at 10:24

***
   @Deestan: I disagree - there are times when speed will be dominated by other factors. Eg. if you're
   sorting data on-disk (merge 2 files), IO times will likely dominate and python's speed won't matter
   much, just the number of operations you do (and hence the algorithm). – [48]Brian Jan 21 '09 at 10:41

***
   Remember to either pass a function that can compare dates within an object or override the cmp method
   in the object. This is the same solution I gave below (though your benchmarks are very very welcome).

***
     is there a smarter way to do this in Python

   This hasn't been mentioned, so I'll go ahead - there is a [51]merge stdlib function in the heapq
   module of python 2.6+. If all you're looking to do is getting things done, this might be a better
   idea. Of course, if you want to implement your own, the merge of merge-sort is the way to go.
>>> list1 = [1, 5, 8, 10, 50]
>>> list2 = [3, 4, 29, 41, 45, 49]
>>> from heapq import merge
>>> list(merge(list1, list2))
[1, 3, 4, 5, 8, 10, 29, 41, 45, 49, 50]

   Here's the documentation [52]https://docs.python.org/2/library/heapq.html

***
   I've added link to heapq.py. merge() is implemented as a pure python function so It is easy to port
   it to older Python versions. – [58]J.F. Sebastian Jan 21 '09 at 20:36

   Does this work for dictionaries as well ?? – [59]KSM Oct 13 '14 at 16:02

   I added a link to the docs for convenience. – [60]demented hedgehog Apr 7 at 4:42

***
   Long story short, unless len(l1 + l2) ~ 1000000 use:
L = l1 + l2
L.sort()

   merge vs. sort comparison

   Description of the figure and source code can be found [61]here.

   The figure was generated by the following command:
$ python make-figures.py --nsublists 2 --maxn=0x100000 -s merge_funcs.merge_26 -s merge_funcs.sort_builtin

***
   This is simply merging. Treat each list as if it were a stack, and continuously pop the smaller of
   the two stack heads, adding the item to the result list, until one of the stacks is empty. Then add
   all remaining items to the resulting list.

***
   A merge sort is indeed the optimal solution. – [70]Ignacio Vazquez-Abrams Jan 21 '09 at 7:41

***
   But is it faster than using Python's built-in sort? – [71]akaihola Jan 21 '09 at 12:59

***
   [72]en.wikipedia.org/wiki/Merge_sort and [73]en.wikipedia.org/wiki/Merge_algorithm – [74]John Fouhy
   Jan 21 '09 at 21:36

***
   This is simply a merge, not a merge sort. – [75]Glenn Maynard Jul 21 '09 at 9:50

***
   @akaihola: If len(L1 + L2) < 1000000 then sorted(L1 + L2) is faster

***
   There is a slight flaw in [78]ghoseb's solution, making it O(n**2), rather than O(n).
   The problem is that this is performing:
item = l1.pop(0)

   With linked lists or deques this would be an O(1) operation, so wouldn't affect complexity, but since
   python lists are implemented as vectors, this copies the rest of the elements of l1 one space left,
   an O(n) operation. Since this is done each pass through the list, it turns an O(n) algorithm into an
   O(n**2) one. This can be corrected by using a method that doesn't alter the source lists, but just
   keeps track of the current position.

   I've tried out benchmarking a corrected algorithm vs a simple sorted(l1+l2) as suggested by [79]dbr
def merge(l1,l2):
    if not l1:  return list(l2)
    if not l2:  return list(l1)

    # l2 will contain last element.
    if l1[-1] > l2[-1]:
        l1,l2 = l2,l1

    it = iter(l2)
    y = it.next()
    result = []

    for x in l1:
        while y < x:
            result.append(y)
            y = it.next()
        result.append(x)
    result.append(y)
    result.extend(it)
    return result

   I've tested these with lists generated with
l1 = sorted([random.random() for i in range(NITEMS)])
l2 = sorted([random.random() for i in range(NITEMS)])

   For various sizes of list, I get the following timings (repeating 100 times):
# items:  1000   10000 100000 1000000
merge  :  0.079  0.798 9.763  109.044
sort   :  0.020  0.217 5.948  106.882

   So in fact, it looks like dbr is right, just using sorted() is preferable unless you're expecting
   very large lists, though it does have worse algorithmic complexity. The break even point being at
   around a million items in each source list (2 million total).

   One advantage of the merge approach though is that it is trivial to rewrite as a generator, which
   will use substantially less memory (no need for an intermediate list).

   [Edit] I've retried this with a situation closer to the question - using a list of objects containing
   a field "date" which is a datetime object. The above algorithm was changed to compare against .date
   instead, and the sort method was changed to:
return sorted(l1 + l2, key=operator.attrgetter('date'))

   This does change things a bit. The comparison being more expensive means that the number we perform
   becomes more important, relative to the constant-time speed of the implementation. This means merge
   makes up lost ground, surpassing the sort() method at 100,000 items instead. Comparing based on an
   even more complex object (large strings or lists for instance) would likely shift this balance even
   more.
# items:  1000   10000 100000  1000000[1]
merge  :  0.161  2.034 23.370  253.68
sort   :  0.111  1.523 25.223  313.20

   [1]: Note: I actually only did 10 repeats for 1,000,000 items and scaled up accordingly as it was
   pretty slow.

***
   Thanks for the fix. Would be great if you can exactly point out the flaw and your fix :)
   – [85]Baishampayan Ghose Jan 21 '09 at 11:24

***
   @ghoseb: I gave a brief description as a comment on your post, but I've now updated the answer to
   give more details - essentially l.pop() is an O(n) operation for lists. It's fixable by tracking
   position in some other manner (alternatively by popping from the tail instead, and reversing at the
   end) – [86]Brian Jan 21 '09 at 11:42

***
   Can you bench mark these same tests but comparing the dates like the question is requiring? I'm
   guessing this extra method will take up a fair amount of time relatively. – [87]Josh Smeaton Jan 21
   '09 at 11:57

***
   I'd say the difference is due to the fact that sort() is implemented in c/c++ and compiled vs our
   merge() that is being interpreted. merge() should be faster on equal terms. – [88]Drakosha Jan 21 '09
   at 12:09

***
   Good point Drakosha. Show's that benchmarking is indeed the only way to know for certain. – [89]Josh

***
from datetime import datetime
from itertools import chain
from operator import attrgetter

class DT:
    def __init__(self, dt):
        self.dt = dt

list1 = [DT(datetime(2008, 12, 5, 2)),
         DT(datetime(2009, 1, 1, 13)),
         DT(datetime(2009, 1, 3, 5))]

list2 = [DT(datetime(2008, 12, 31, 23)),
         DT(datetime(2009, 1, 2, 12)),
         DT(datetime(2009, 1, 4, 15))]

list3 = sorted(chain(list1, list2), key=attrgetter('dt'))
for item in list3:
    print item.dt

   The output:
2008-12-05 02:00:00
2008-12-31 23:00:00
2009-01-01 13:00:00
2009-01-02 12:00:00
2009-01-03 05:00:00
2009-01-04 15:00:00

   I bet this is faster than any of the fancy pure-Python merge algorithms, even for large data. Python
   2.6's heapq.merge is a whole another story.

***
   This is simple merging of two sorted lists. Take a look at the sample code below which merges two
   sorted lists of integers.
#!/usr/bin/env python
## merge.py -- Merge two sorted lists -*- Python -*-
## Time-stamp: "2009-01-21 14:02:57 ghoseb"

l1 = [1, 3, 4, 7]
l2 = [0, 2, 5, 6, 8, 9]

def merge_sorted_lists(l1, l2):
    """Merge sort two sorted lists

    Arguments:
    - `l1`: First sorted list
    - `l2`: Second sorted list
    """
    sorted_list = []

    # Copy both the args to make sure the original lists are not
    # modified
    l1 = l1[:]
    l2 = l2[:]

    while (l1 and l2):
        if (l1[0] <= l2[0]): # Compare both heads
            item = l1.pop(0) # Pop from the head
            sorted_list.append(item)
        else:
            item = l2.pop(0)
            sorted_list.append(item)

    # Add the remaining of the lists
    sorted_list.extend(l1 if l1 else l2)

    return sorted_list

if __name__ == '__main__':
    print merge_sorted_lists(l1, l2)

   This should work fine with datetime objects. Hope this helps.

***
   Unfortunately this is counterproductive - normally merge would be O(n), but because you're popping
   from the left of each list (an O(n) operation), you're actually making it an O(n**2) process - worse
   than the naive sorted(l1+l2) – [99]Brian Jan 21 '09 at 9:54

***
   @Brian I actually think that this solution is the cleanest of all and I believe you're right on O(n)
   complexity of popping the first element from the list. You can eliminate that problem by using deque
   from collections, which gives you O(1) when popping an item from either side.
   [100]docs.python.org/2/library/collections.html#collections.deque – [101]mohi666 May 8 '15 at 0:59

***
   @Brian, head, tail = l[0], l[1:] also will have O(n**2) complexity? – [102]Nikolay Fominyh Feb 12 '16

***
   Python's sort implementation "timsort" is specifically optimized for lists that contain ordered
   sections. Plus, it's written in C.

   http://bugs.python.org/file4451/timsort.txt
   http://en.wikipedia.org/wiki/Timsort

   As people have mentioned, it may call the comparison function more times by some constant factor (but
   maybe call it more times in a shorter period in many cases!).

     I would never rely on this, however. – Daniel Nadasi

   I believe the Python developers are committed to keeping timsort, or at least keeping a sort that's
   O(n) in this case.

     Generalized sorting (i.e. leaving apart radix sorts from limited value domains)
     cannot be done in less than O(n log n) on a serial machine. – Barry Kelly

   Right, sorting in the general case can't be faster than that. But since O() is an upper bound,
   timsort being O(n log n) on arbitrary input doesn't contradict its being O(n) given sorted(L1) +
   sorted(L2).

***
   Use the 'merge' step of merge sort, it runs in O(n) time.

   From [110]wikipedia (pseudo-code):
function merge(left,right)
    var list result
    while length(left) > 0 and length(right) > 0
        if first(left) ≤ first(right)
            append first(left) to result
            left = rest(left)
        else
            append first(right) to result
            right = rest(right)
    end while
    while length(left) > 0
        append left to result
    while length(right) > 0
        append right to result
    return result

   [111]share|[112]improve this answer
      answered [113]Jan 21 '09 at 7:49
   community wiki
   [114]Mongoose
   add a comment |
   up vote 1 down vote

   Recursive implementation is below. Average performance is O(n).
def merge_sorted_lists(A, B, sorted_list = None):
    if sorted_list == None:
        sorted_list = []

    slice_index = 0
    for element in A:
        if element <= B[0]:
            sorted_list.append(element)
            slice_index += 1
        else:
            return merge_sorted_lists(B, A[slice_index:], sorted_list)

    return sorted_list + B

   or generator with improved space complexity:
def merge_sorted_lists_as_generator(A, B):
    slice_index = 0
    for element in A:
        if element <= B[0]:
            slice_index += 1
            yield element
        else:
            for sorted_element in merge_sorted_lists_as_generator(B, A[slice_index:]):
                yield sorted_element
            return

    for element in B:
        yield element


***
   If you want to do it in a manner more consistent with learning what goes on in the iteration try this
def merge_arrays(a, b):
    l= []

    while len(a) > 0 and len(b)>0:
        if a[0] < b[0]: l.append(a.pop(0))
        else:l.append(b.pop(0))

    l.extend(a+b)
    print( l )


***
import random

    n=int(input("Enter size of table 1")); #size of list 1
    m=int(input("Enter size of table 2")); # size of list 2
    tb1=[random.randrange(1,101,1) for _ in range(n)] # filling the list with random
    tb2=[random.randrange(1,101,1) for _ in range(m)] # numbers between 1 and 100
    tb1.sort(); #sort the list 1
    tb2.sort(); # sort the list 2
    fus=[]; # creat an empty list
    print(tb1); # print the list 1
    print('------------------------------------');
    print(tb2); # print the list 2
    print('------------------------------------');
    i=0;j=0;  # varialbles to cross the list
    while(i<n and j<m):
        if(tb1[i]<tb2[j]):
            fus.append(tb1[i]);
            i+=1;
        else:
            fus.append(tb2[j]);
            j+=1;

    if(i<n):
        fus+=tb1[i:n];
    if(j<m):
        fus+=tb2[j:m];

    print(fus);

  # this code is used to merge two sorted lists in one sorted list (FUS) without
  #sorting the (FUS)


***
   It's not clear whether this is an answer to the question, let alone whether it actually does? Can you
   provide some sort of explanation? – [129]Ben Aug 30 '14 at 12:00

***
   Sory but I didn't understand what you whant ! – [130]Oussama Ďj Sbaa Aug 30 '14 at 12:10

***
   You'll note that the higher voted answers (and most of the others) have some text that explain what's
   happening in the answer and why that answer is an answer to the question.. – [131]Ben Aug 30 '14 at

***
   because it merge two list in one sorted list and this is the answer of the question – [132]Oussama Ďj

***
   Have used merge step of the merge sort. But I have used generators. Time complexity O(n)
def merge(lst1,lst2):
    len1=len(lst1)
    len2=len(lst2)
    i,j=0,0
    while(i<len1 and j<len2):
        if(lst1[i]<lst2[j]):
                yield lst1[i]
                i+=1
        else:
                yield lst2[j]
                j+=1
    if(i==len1):
        while(j<len2):
                yield lst2[j]
                j+=1
    elif(j==len2):
        while(i<len1):
                yield lst1[i]
                i+=1
l1=[1,3,5,7]
l2=[2,4,6,8,9]
mergelst=(val for val in merge(l1,l2))
print(*mergelst)


***
   Well, the naive approach (combine 2 lists into large one and sort) will be O(N*log(N)) complexity. On
   the other hand, if you implement the merge manually (i do not know about any ready code in python
   libs for this, but i'm no expert) the complexity will be O(N), which is clearly faster. The idea is
   described wery well in post by Barry Kelly.

***
   As a point of interest, the python sorting algorithm is very good, so the performance would likely be
   better than O(n log n), since the algorithm often takes advantage of regularities in the input data.
   I would never rely on this, however. – [141]Daniel Nadasi Jan 21 '09 at 7:45

***
   Then we both agree on it :) – [142]Drakosha Jan 21 '09 at 7:46

***
   Generalized sorting (i.e. leaving apart radix sorts from limited value domains) cannot be done in
   less than O(n log n) on a serial machine. – [143]Barry Kelly Jan 21 '09 at 10:17

***
def compareDate(obj1, obj2):
    if obj1.getDate() < obj2.getDate():
        return -1
    elif obj1.getDate() > obj2.getDate():
        return 1
    else:
        return 0

list = list1 + list2
list.sort(compareDate)

   Will sort the list in place. Define your own function for comparing two objects, and pass that
   function into the built in sort function.

   Do NOT use bubble sort, it has horrible performance.


---
https://stackoverflow.com/questions/4173225/my-implementation-of-merging-two-sorted-lists-in-linear-time-what-could-be-imp

...

Fromg Google's Python Class:

E. Given two lists sorted in increasing order, create and return a merged
list of all the elements in sorted order. You may modify the passed in lists.
Ideally, the solution should work in "linear" time, making a single
pass of both lists.
Here's my solution:

def linear_merge(list1, list2):
  merged_list = []
  i = 0
  j = 0

  while True:
    if i == len(list1):
        return merged_list + list2[j:]
    if j == len(list2):
        return merged_list + list1[i:]

    if list1[i] <= list2[j]:
        merged_list.append(list1[i])
        i += 1
    else:
        merged_list.append(list2[j])
        j += 1
        
First of all, is it okay to use an infinite loop here? Should I break out of the loop using the break keyword
when I'm done merging the list, or are the returns okay here?

I've seen similar questions asked here, and all the solutions look quite similar to mine, i.e. very C-like.
Is there no more python-like solution? Or is this because of the nature of the algorithm?

***
I appreciate that this is a "problem" and that you are supposed to solve it in a certain way. In all truth
however, if this were a "real" task i would just use extend() and sort(). It is true that it would be O(NlgN)
rather than O(N), but the speed advantage you would get by not doing per-item manipulations in python is quite
stunning. – drxzcl Nov 13 '10 at 15:30

***
Python's sorting is also very well optimized for a lot of common cases that naive sorts don't do well at: you
may get substantially better than that. (I don't know if it's specifically optimized for "sorting two sorted,
appended lists".) – Glenn Maynard Nov 13 '10 at 15:55

***
By the way, I'm not going to spend time with detailed answers to your questions any more when you're marking
non-answers like that as a solution. It's not even an answer (links to other answers with no original content
belong in a comment)--and nothing in the solution he linked actually show how to do the above algorithm in a
clean, generalized way in Python. – Glenn Maynard Nov 13 '10 at 16:17

***
+1 for the question -10 for the selected answer somehow works out to -1. Go figure SO math. – aaronasterling
Nov 13 '10 at 23:11

***
@Glenn Maynard If I had the rep at the time, I would have posted that as a comment. Also, read his question,
he isn't asking for someone to do it for him, he's asking general questions about it. So I would stand by what
I said, namely that [the selected answer] (stackoverflow.com/questions/464342/…) to the post I linked to
answers his question. It doesn't do so in code, but it does answer it. – aptwebapps Nov 14 '10 at 5:10

***
This question covers this in more detail than you probably need. ;) The chosen answer matches your requirement.
If I needed to do this myself, I would do it in the way that dbr described in his or her answer (add the lists
together, sort the new list) as it is very simple.

EDIT:

I'm adding an implementation below. I actually saw this in another answer here which seems to have been deleted.
I'm just hoping it wasn't deleted because it had an error which I'm not catching. ;)

def mergeSortedLists(a, b):
    l = []
    while a and b:
        if a[0] < b[0]:
            l.append(a.pop(0))
        else:
            l.append(b.pop(0))
    return l + a + b

...

---
