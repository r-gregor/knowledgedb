filename: /c/Users/gregor.redelonghi/Dropbox/ODPRTO/_PYTHON/python_for-digital-artists-multif_20170220.txt
https://opensource.com/life/16/9/how-to-automate-repetitive-tasks-artists

Advantages to learning Python for digital creatives

*** Automating repetitive tasks for digital artists with Python ***

Part 1: Python tricks for artists series

   Posted 15 Sep 2016

   Artists and designers should know how to code. There, I said it.

   Now, I could go into a good in-depth exposition on how the artist mindset and the developer/engineer
   mindset aren't all that different, or how the image of the "non-technical artist" is a relatively
   recent phenomenon. Those are topics for another article. For the purposes of this article, suffice it
   to say that knowing a little code will not only give you a better understanding of how your digital
   tools work, but that knowledge will help you create your work more efficiently.

   It doesn't matter if you're working on a large-scale collaborative project for a paying customer, or
   if you're using digital art as your freeform, free-wheeling catharsis engine. We all want to make the
   most effective use of our time. For myself, if I find that I'm doing some kind of monotonous task
   more than three times in a row, I'm already thinking about how I might be able to automate it and
   have my computer do the work for me.

   Automation means cobbling together a script. Coding. And when it comes to scripting tasks that relate
   to digital media, you'd be hard-pressed to find a more suitable language than Python. Python is
   hugely popular open source scripting language that's used to write all kinds of open source software.

   For digital creatives there are other advantages to learning Python. The language syntax is
   relatively easy to learn and Python is available on all major platforms. This means that your scripts
   can travel with you, regardless of whether you're running Linux, BSD, or one of those proprietary
   operating systems. Not only that, Python is well-integrated in a number of digital content creation
   tools like Blender and GIMP. Even some proprietary tools have integrated Python in them. This means
   that you can use Python to automate tasks in those programs, or even add new features that are
   specific to your particular way of working.

   "That's great and all," you might say, "but be specific. What can I actually do with Python?"

   I'm glad you asked.

   This series of articles is meant to answer that question, to let you dip your toe into the stream and
   get a sense of what's possible with just a little knowledge about scripting. Fair warning: if these
   articles do whet your appetite for scripting, I highly encourage you to go through one of the many
   Python courses available online, including the [158]tutorial that's part of the official Python
   documentation.

   I should also mention that the examples I give might make a "real" Python developer cringe. And
   that's fine. Worst case, we still have a script that does exactly what we need it to. Best case, we
   get suggestions for improvements in the comments section of this article.

   So let's start with something easy. We all know that command line tools like FFmpeg and ImageMagick
   are usually a faster way to do one-off video or image operations. Let's say all you want to do is
   encode a video or desaturate a PNG and convert it to a JPEG. It's way faster to fire off a single
   command than it is to launch a program with a full graphical interface, load your source media, and
   then perform that one little operation.

   The problem, however, is that powerful command line tools like FFmpeg and ImageMagick have a lot of
   options and flexibility. They do so many things, and they're all controlled by a dizzying array of
   flags and options that you need to type in correctly. It's difficult to remember the exact magical
   incantation you need for the one or two specific tasks you need to get done.

   For an example, let's say you have a directory full of PNG images generated by your [159]favorite
   animation software. There are hundreds, or even thousands of individual images in there. Now let's
   say that you realize that there's no need for all of those images to be saved as 16-bit RGBA PNGs.
   You could save a ton of disk space and have faster loading times if those images were all converted
   to 1-bit black-and-white PNG images. Sure, you could re-render, but the images are already there.
   With FFmpeg you could churn though those images and convert them in far less time... if you could
   only remember the exact command to do that.

   Fortunately, you've had to do this a few times before, so you took a little bit of time and scraped
   together a little Python script called make_1bit.py. It's way easier to remember make_1bit.py than
   ffmpeg -i something -flipflop -blah blah -please -o somethingelse or whatever. Here's the content of
   your script (with line breaks to fit in this column width; see below for the correct way to format
   your script):

import subprocess

subprocess.call(['ffmpeg', '-f', 'image2', '-i',
'%04d.png', '-pix_fmt', 'monob', '-threads', '0',
'%04d.png'])

   Let's take a quick moment to walk through the script and describe what it does. The first line,
   import subprocess, imports a Python module called subprocess. Think of modules as chunks of code that
   someone else has already written. You just need to make your script aware of that code. That's done
   with the import statement. In this case, you're importing the subprocess module, a Python module made
   specifically for launching commands as if you were typing them at the command line.

   In the next block of code (subprocess.call(['ffmpeg',...])), you actually use code in that module to
   run FFmpeg for you. The whole FFmpeg command is broken into a list of strings. In Python, a list is
   simply a collection of data. It's indicated by the square braces ([]) and each bit of data is
   separated by a comma. In this case, each bit of data is a string, or a bit of text wrapped in single
   quotes. Each string in the list is an argument (flag) from the FFmpeg command you want to run, in the
   correct order.

   In this particular example, we're assuming that the script is in the same directory as your images
   and that the images have numbered file names like 0001.png, 0002.png, 0003.png, and so on.

   For organizational sake, you may want to put each of those argument pairs on their own lines. That
   way it's a bit easier to see what's going on. (Note: Python is very particular about "whitespace"
   (spaces and tabs) in your code. So make sure you use either spaces or tabs don't mix!, and that you
   use the same number of them when indenting.) If you do that, your script might look like this:

import subprocess

subprocess.call(['ffmpeg',
                 '-f', 'image2',
                 '-i', '%04d.png',
                 '-pix_fmt', 'monob',
                 '-threads', '0',
                 '%04d.png'])

   Now all you have to do is run python make_1bit.py from within that directory and, BOOM, files
   converted! No need to remember all of those various flags for FFmpeg. The script has that remembered
   for you. Of course, if you want to run FFmpeg directly (or perhaps some variant of this command),
   it's easy to open your script file and have those flags available and clearly organized as a
   reference. You can even add comments to your script so you can more easily know what each flag does:

import subprocess

subprocess.call(['ffmpeg',
                 '-f', 'image2',      # Read input as images
                 '-i', '%04d.png',    # Input files (sequential PNGs)
                 '-pix_fmt', 'monob', # Output colorspace is 1-bit
                 '-threads', '0',     # Use all available CPU cores
                 '%04d.png'])         # Output files (overwrite input)

   So this is where we start. We make one little script at a time. The point is to save us time and keep
   us focused on getting work done by simplifying and automating repetitive or tedious tasks.

   There will be more in this series... but in the meantime, if you happen to use Python scripting to
   simplify tasks (whether for creative work or not), perhaps you can use the comments section to
   explain what you do.


---
https://opensource.com/life/16/10/python-file-management-tricks-digital-artists

*** Python file-management tricks for digital artists ***

Part 2: Python tricks for artists series

   Posted 26 Oct 2016

   If you've done digital artwork for any appreciable amount of time, then the importance of good file
   management should be apparent to you. This is even more true if you're collaborating with other
   artists. Everyone has their own favorite naming conventions and project directory structures. It can
   be pretty frustrating when you try to find files that are supposed to be named a certain way, but one
   of your collaboration partners thinks it'd be more interesting to name each after a Three Stooges
   pun. (Hey, it happens!)

   This frustration gets amplified once you start automating parts of your process with scripts. Now
   it's your code, rather than you, that can't find the right files. Worse still, most of those scripts
   won't look for a workaround for a slight naming change. They simply won't work at all.

   Fortunately, with a few relatively simple lines of code, you can help alleviate issues like this.
   Let's work with an example not caused by self-amused collaborators. Sometimes the problem could be
   your own fault. I personally never (ahem) make mistakes. But occasionally, the programs that I use do
   exactly what I tell them, rather than what I intend them to do.

Case in point
   Animation is a big part of what I do. When creating animation or visual effects, to output (render)
   each frame of your animated work as a separate image file is good practice. (Sometimes you render
   multiple images per frame, but allow me to simplify to start.) Typically, those frames of animation
   are all put in their own directory on your hard drive.

   Now, I'm not sure if this has happened to anyone else or if it's just a quirk of mine, but there have
   been times (in multiple software packages) in which I've picked the directory where my render files
   should go, but then there's a glitch. (Some may say "user error", but remember, I never make
   mistakes.) Rather than saving my renders to project/render/, the last slash gets left off and each
   rendered image file starts with the word "render" rather than going into the render directory. That
   is, I want frame 1 of my animation to be project/render/frame0001.png, but instead the program
   creates project/renderframe0001.png. Now my main project directory is flooded with thousands of
   render files. Gross.

   I have a couple options at my disposal. The simple solution would be to move all of those render
   files to the correct directory and simply tolerate the poor naming. However, this can be problematic
   if my post-production steps expect a naming structure without that render word at the start of each
   file name. It could get even more complicated if I need to re-render.

   Speaking of re-rendering, that could be another option. I could just delete the improperly named
   files, fix the output path in my animation program, and redo all of the rendering. The problem there,
   however, is that rendering frames of animation can sometimes be very time-consuming. For complex
   scenes, it may take well over an hour for a single frame. Multiply that by 24-30 frames per second of
   animation and we can quickly see how re-endering is not the quick and easy solution we wish it could
   be.

   Of course, there's always the manual option: Move all of the render files to the proper directory and
   then go through and change the name of each one. Sure, if you only have a couple dozen frames that
   might not be such a hassle. If you have thousands of frames of animation, it's very much a hassle.

Python script solution
   So what's left? That's right: Write a script! As with the [157]Part 1 in this series, we'll be doing
   this in Python. In Part 1, we used the subprocess module. This example doesn't require that, but it
   does use another one of Python's built-in modules, os. The os module provides a means of doing
   tasks—such as moving and renaming files—handled by your operating system. And because Python is
   multi-platform, the os module works everywhere Python does, regardless of the actual operating system
   you're using.

   So the quick and dirty version of your script might look like this:

import os

for filename in os.listdir('./'):
    if filename.startswith('renderframe'):
        os.rename(filename, filename[:6]+'/'+filename[6:])

   If you've never coded before, this script has a few things with which you might not be familiar.
   Let's start with what you do know. The first line, import os, makes your script aware of Python's
   built-in os module (similar to how you imported subprocess in the previous article).

   The next line of code (extra line break notwithstanding) indicates the start of a loop. Loops are one
   of the primary time-savers in scripting and programming. Basically, if there's a process that you
   need to do over and over (such as renaming a bunch of files), then loops are there to save the day
   (and your sanity).

   In this particular example, you're making use of a for loop, which is a particular kind of loop that
   you use to iterate through a series of things. In this case, you're iterating through the name of all
   of the files in your current directory. How are you doing that? Let me introduce you to os.listdir.

   The Python os module has a function named listdir. That function will take any directory path as
   input and give you back a list of all the files in that directory. In this example, you're using
   os.listdir('./'). The './' bit is a string of text (hence the quotes) that's shorthand for "the
   current directory I'm in right now."

   "Great," you might be saying, "So os.listdir('./') makes a list of all the files in my current
   directory, but what does that have to do with a for loop?"

   Good question! You don't want to work on the whole list of files at once. You need to address each
   one, one at a time. The for loop iterates through the list of files provided by os.listdir('./').
   Because your for loop needs a generic name to call each file while it's being worked on, we're using
   the variable filename as a stand-in.

   Knowing this, have a look at the full line that's setting up your for loop: for filename in
   os.listdir('./'):. An English translation of this line would be, "Make a list of every file in my
   current directory. Then loop through the list of file names. To keep things simple, just call every
   file filename while it's being worked on."

   On the next line of code in your script, you're in the loop (you can tell, because that line is
   indented). Because you're in the loop, everything you do here will be repeated for every single file
   in your current directory. Remember that we started this because my rendered files ended up in the
   wrong place—likely there are other files here that aren't my render frames. We need to make sure that
   this script isn't renaming and moving just any file; it needs to limit itself to only those rendered
   frames.

Filtering and renaming
   Fortunately, we have a good way of doing this. We can filter based on the horrible mistaken naming
   that I told my animation software to produce. All of the poorly placed, improperly named files in the
   current directory start with renderframe.

   For each file that the script loops through, it needs to check and see whether that file starts with
   renderframe. That's exactly what this line of code does: if filename.startswith('renderframe'):. This
   line of code uses another common construct in scripting and programming, the if statement, or
   conditional. It starts with the word if and is then followed by a test condition. That test condition
   must be either true or false. If the test condition is true, then the script can do a specific bit of
   code stipulated by the if statement. If the test condition is false, then that bit of code gets
   skipped.

   In this example, the test condition uses the startswith function that's built-in to all strings in
   Python. As its name indicates, if the string starts with whatever bit of text you give as input, the
   startswith function returns true. Otherwise, it returns false. So, to translate if
   filename.startswith('renderframe'): to English, it would read, "If the current file name in our list
   of file names starts with the text, 'renderframe', then do the next bit of code."

   Alright. You've got a list of files in the current directory and you've narrowed that list down to
   just our misplaced render files. Now for the actual work of renaming and moving those files to where
   they're supposed to be. Fortunately, this renaming and moving step can happen in a single line of
   code, using the os module's rename function.

   The os.rename function takes two input parameters: the file you want to rename and what you want to
   rename it to. The cool part, though, is that those input parameters treat the file's path like it's
   part of its name. So if you include a different path as part of the second input, you can rename and
   move your file in a single go. Hooray for less typing!

   Now, looking at that second line of text (os.rename(filename, filename[:6]+'/'+filename[6:])), the
   first half is pretty straightforward. The second half—after the comma—that's another little bit of
   funkiness that you may not have encountered before. It's not difficult to unpack, though. It's just a
   matter of understanding what you want to do.

   Let's say your script has started and it's working on the file renderframe0001.png. To rename and
   move your file, you just need to add a / character after the word render. That word, render, is six
   letters long. With that little tidbit of information, you can construct a new path for your file
   using what you already have in your filename variable. You just need the right notation.

   I've always liked Python's notation for getting a subset of a string of text. It's [start:end], where
   start is the first character of your subset and end is the character that's after last character in
   your subset. And like every sane programming language, Python starts counting at the number zero. So
   in our example where we're working with a filename variable that has the text renderframe0001.png,
   you could use filename[3:7] and Python would give you derf as the result.

   You might notice that your code not only uses this notation twice, but in each case, it's either
   missing the value for the start character or the end character. This is a cool little convenience
   trick. If you only provide a start character, but keep the colon in the notation, Python assumes you
   want every character in the string after that point. Likewise, if you only include the end character
   value, Python will give you all of the characters in the string that are before that. In our example,
   filename[:6] gets you render. The filename[6:] notation gets you frame0001.png.

   Using this technique, you split your filename in half after the word render. Now all you have to do
   is reassemble it with that additional slash (/). So, pulling it all together, this line of code
   (os.rename(filename, filename[:6]+'/'+filename[6:])) translates to, "Rename the my file by inserting
   a slash after the sixth character in the file name."

Adding user feedback
   That's it for describing your quick and dirty script for moving and renaming a whole bunch of
   misplaced files. The only thing that might be worth adding to it is a bit of user feedback. If you're
   moving and renaming thousands of files, it might take a minute or so. It would useful to know the
   file that your script is working on. You can do that with a little print statement just before your
   rename. Your finished script might look like this:

import os

for filename in os.listdir('./'):
    if filename.startswith('renderframe'):
        print('Moving and renaming:', filename)
        os.rename(filename, filename[:6]+'/'+filename[6:])

   And there you go! This little handful of lines of code can save you an immense amount of time if,
   like me, your software makes the mistake of doing exactly what you asked of it.

   This block of code also serves as a great starting point for other useful file-management scripts.
   For instance, I love the File Output node in [158]Blender's compositor. I even use it when rendering
   multiple passes of a still (non-animated) frame. The downside, however, is that the File Output node
   always tacks the current frame number to the end of every file it generates. That's fine for
   animations, but it's a bit annoying when I'm just rendering stills. I end up with a bunch of files
   that end in 0001.png.

   Fortunately, with a couple minor modifications to my move and rename script, I can easily trim off
   those 0001s in one go:

import os

for filename in os.listdir('./'):
    if filename.endswith('0001.png'):
        print('Renaming:', filename)
        os.rename(filename, filename[:-8]+filename[-4:])

   The differences between this script and the previous one are pretty minimal. Instead of dealing with
   the start of the file name, this script works from the back of it. So rather than
   filename.startswith, this script uses filename.endswith as its filtering mechanism. And instead of
   inserting a slash after the sixth character, this script modifies the characters before 0001.png
   (that is, every character until the eighth from the end). Notice the negative number in
   filename[:-8]. That negative value tells Python to start at the end of the string instead of the
   beginning.

   And there you go! Now you have a way to change the beginning or end (or middle!) of a bunch of files
   all at once. You save time and avoid doing boring, repetitive tasks so you can focus your energy on
   doing more interesting creative work.


---
https://opensource.com/article/17/2/python-tricks-artists

How to root out corruption in your image folders

Using Python to find corrupted images

   Posted 17 Feb 2017
   
   If you're working with images on a computer, you're bound to eventually run into corrupted files that
   ruin your day. I run into this with animation renders (remember, the best practice here is to render
   to a sequence of image files and not a single video file). However, animation and visual effects are
   not the only places where you see image corruption. You can just as easily run into this in other
   fields. Perhaps you're a photographer and you've shot a bunch of brackets HDRI (High Dynamic Range
   Imaging) tone mapping and something glitches when transferring files from your camera.

   The problem isn't so much the amount of effort to repair or replace a corrupted image, which is
   usually just a matter of re-rendering the image or re-copying the good image to your computer, rather
   the trick is to find those bad images as early in the process as possible. The longer you don't know,
   the greater the hassle you'll face when you do encounter a corrupt image.

   So, what do you do? Well, you could go through and open each file—one at a time—in your image editor
   or viewer of choice, and let that program tell you there's a problem. However, photograph images are
   large and it can be annoying and time-consuming to go through a whole set just to find one or two
   baddies. And although animation renders are typically smaller files, you often have a lot more of
   them to go through. In my case, I regularly produce renders that have over 44,000 frames in a render.
   (No, that's not a typo—forty-four thousand frames.)

   The solution? You guessed it. Write a script.

   As with previous articles in this series, you'll do your scripting in Python. Step one: get a listing
   of your files. Fortunately, if you've gone through the [158]last article in this series, you know
   that's a matter of using the os module. Assume that all of the image files you want to inspect are in
   a single directory on your hard drive. Furthermore, assume that you're going to run this script from
   within that directory. Using Python, you can get a list of those files with the following code:

import os

for filename in os.listdir('./'):
  print(filename)

   If you'd like, you can narrow down that list of images (or at least more clearly specify it; for
   instance, you don't want to include this script as one of those files) by looking just for files that
   end with the PNG extension:

import os

for filename in os.listdir('./'):
  if filename.endswith('.png'):
    print(filename)

   You now have a list of PNG image files in your current working directory. Now what? Well, now you
   need to figure out which, if any, of those images are corrupt. In the previous articles of this
   series, we exclusively used modules that ship with Python by default. Unfortunately, discovering if
   an image is corrupt without any image processing capability is difficult, and neither Python 2 nor
   Python 3 ship with any way to handle that out of the box. You'll need to get yourself an image
   processing module to view these files. Happily, the Python development community has made that easier
   for you.

   In fact, you have an entire library of packages available to you to install. You just need to know
   how to get them. Let me introduce you to pip, the recommended tool for installing Python packages.
   It's installed by default on most platforms when you install Python.

   Note: I'm using Python 3, but if you're using Python 2, nearly everything I've written in this series
   is transferable between both variations of the language. Also, many Linux distributions prefer that
   you use their own package management system over using pip to install Python packages. Feel free to
   stick to that if you prefer. The suggestion to use pip here is mostly in the interest of being
   consistent across all of the platforms you can use Python on.

   The specific package that I'm going to recommend that you install is called [159]Pillow. It's a
   "friendly fork" of the original PIL (Python Imaging Library) that works in current releases of both
   Python 3 and Python 2. All you need to install Pillow is to fire up a terminal window and type pip
   install Pillow. The Python package tool should handle the rest for you from there.

   Once you have Pillow installed you need to actually have a way of using it in your script. Because
   it's installed, you can treat it just like any module that comes with Python. You use import—in this
   case, you could use import PIL. However, to look for corrupt images, you don't really need to import
   the entirety of the Pillow library into our script. In Python, you can import just a single
   subcomponent of a module. This is good practice because it reduces the memory footprint of your
   script and, just as importantly, it makes it more clear what things your script is going to do right
   from the start. Plus, when you import subcomponents, you end up needing to type less once you get
   into the meat of your script. Which is always a nice bonus.

   To import a subcomponent of a module, you precede your import with a from directive. In the case of
   Pillow, your script really only needs to use the Image class. So, your import line would look like
   from PIL import Image. In fact, you can do the same thing with the os module. If you look back at the
   previous code, you might notice that you're only using the listdir function in the os module. So
   instead of import os, you could use from os import listdir. This means that when you get into your
   script, you no longer have to type os.listdir. Instead, you only need to type listdir, because that's
   all you've imported.

   Pulling all that together, your script should now look something like this:

from os import listdir
from PIL import Image

for filename in listdir('./'):
  if filename.endswith('.png'):
    print(filename)

   You've got the Image class in Pillow loaded, but your script still isn't doing anything with it yet.
   It's now time to get to the functional section of your script. What you're going to do is the
   scripted equivalent of opening each image file and checking to see if it's readable. If there's an
   error, then you've found a bad file. To do that, you're going to use a try/except block. In short,
   your script is going to try to run a function that opens a file. If that function returns an error,
   otherwise known as an exception, then you know that image has a problem. In particular, if the
   exception is of types IOError or SyntaxError, then you know you've got yourself a bad image.

   The syntax for doing a try/except is pretty straightforward. I've described it in code comments
   below:

try: # These next functions may produce an exception
  # <some function>
except (IOError, SyntaxError) as e: # These are the exceptions we're looking for
  # <do something... like print an intelligent error message>

   In the case of looking for corrupt image files, you'll want to test two functions: Image.open() and
   verify(). If you wrap those in a try/except block, your corrupt image-finding script should look like
   this:

from os import listdir
from PIL import Image

for filename in listdir('./'):
  if filename.endswith('.png'):
    try:
      img = Image.open('./'+filename) # open the image file
      img.verify() # verify that it is, in fact an image
    except (IOError, SyntaxError) as e:
      print('Bad file:', filename) # print out the names of corrupt files

   And there you go. Save this script in your directory of images. When you run it from the command
   line, you should get a list of all the corrupt image files in there. If nothing prints out, then you
   can assume all of those image files are good, valid images.

   Of course, being able to use this script on any arbitrary directory would be nice. And having the
   script prompt you to instruct it to go ahead and delete those corrupt files for you would be even
   nicer. Good news! You can make the script do exactly that. We'll cover that in the next articles in
   this series.

   In the meantime, have fun rooting out corruption in your image folders.
