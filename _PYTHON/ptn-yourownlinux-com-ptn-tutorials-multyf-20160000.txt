filename: python_yourownlinux-com_python-tutorials-multyf_20160000.txt
http://www.yourownlinux.com/2016/10/introduction-to-python-programming-on-linux.html

Introduction to Python Programming on Linux

   Posted on October 13, 2016 by Mandar Shinde

   Hello readers! We are happy to announce a new tutorial series on Python- 'Python on
   Terminal', and this is the first article of the series. In this tutorial series, we will
   learn the basic building blocks in Python Programming and Python Scripting. Python is a
   really very simple language, that anyone with or without any knowledge of coding can grasp
   it quickly. So, in short, it will be great fun learning Python. Here we begin!
   [18]introduction-to-python-on-linux

What are we going to cover in this article?
     * Introduction to Python
     * Origin of Python
     * Where do we use Python?
     * Why should everybody learn Python?
     * Some basic Python code sheet standards and code execution model

   You must be wondering, especially if you are an IT guy, that everyone around you is talking
   about Python. And if your quest to find out what exactly it is, then you have come to the
   right place. You don’t need any special prerequisites to try Python, anybody can take hold
   of it pretty quickly, may it be experienced professionals or newbies. Python syntax is so
   clear and simple, that anyone working on it gets a feel of reading English. I just said
   'try python', because some day, you will realize that, in order to accomplish something,
   where it needs a several pages of code in other languages, Python can do it in very minimal
   code and less time. As a result, your interest in Python will grow, day by day, making
   Python an integral part of your life.
          Enough of praise, before it seems like an exaggeration. We will start our discussion
   on Python straight away.

What is Python?
    1. This is a programming language as well as a scripting language, that supports OOP
       (object oriented programming) concept. In brief, we can call it as object oriented
       scripting-cum-programming language. OOP in Python- Don’t worry! We will be learning
       everything about it in the subsequent articles in this series.
    2. It is very easy to learn and use, improves developer productivity, provides quality
       codes.
    3. This is considered among the top 5 widely used programming languages in the world.
    4. This is open source language so does not need licensing.
    5. Two versions of Python are widely used in industry - Python2 and Python3.

Why should I learn Python?
    1. Every software engineer wants to enhance his/her skills, in order to maintain a
       continuous progress in his/her career, and basically wants to work on renowned
       technologies or ideas that are widely accepted all around the globe.
    2. So to lure you as to why you should learn python, here is some motivation.
          + Google, YouTube, Dropbox, Instagram - all of them use python extensively.
          + Intel, Cisco, HP, IBM use Python for hardware testing.
          + NASA use it for scientific programming tasks.
          + And used in lot many areas which I have not mentioned here. Feeling motivated?
    3. You can use python in Machine learning, Gaming, Image Processing, Robotics, Graphic
       designing, Web development, Search engines, etc..

Why is it named as Python?
   Despite being all the 'python' images over all the books and materials of Python, the fact
   is, it is named after the British comedy group "Monty Python", who are the makers of 1970's
   BBC comedy series "Monty Python’s Flying Circus". Guido van Rossum is the creator of
   Python.
   There are lot of technical differences between Python and other rivals that I have not
   mentioned here. These differences obviously makes Python the Winner in every bit of a
   specification. If you have a background in Software development life-cycle and want to know
   more distinguishing features of python then just Google it, you will get to know bunch of
   them. But in this tutorial series, we will unveil the Python features step by step, so that
   anyone new to programming world will find it easy to understand the concepts. Before
   starting the basics, we must know some background of how the Python code gets executed
   internally.

Our first Python code
   Before we jump into anything, let's check which version of Python we are using. To do this,
   simply open your Linux terminal and type python -V or python --version, in my case it's
   'Python 2.7.5'.
$ python -V
Python 2.7.5

$ python --version
Python 2.7.5

   A Python script is a simple text file containing all of our code. But on Linux, we should
   include the first line in our file as #!/usr/bin/python, and this is called as "Shebang" or
   "Hashbang". With this line, Linux shell will come to know that, the interpreter to be used
   to execute the code below it, is Python interpreter located at /usr/bin/python. Normally,
   this path will be common for most of us, but you can check the path to python interpreter
   by running which python command on your Linux terminal.
$ which python
/usr/bin/python

   So, for our first python code, we will use print command, that takes a parameter that will
   be printed on the terminal screen. Here is how the file contents look like-
$ cat myFirstCode.py

#!/usr/bin/python
print("I ride on a road with a code")

   Then, we need to make this file executable using [19]chmod command in Linux as below-
$ chmod +x myFirstCode.py

   Now, time to run our Python script. We can do this in two ways, as below-
$ ./myFirstCode.py

   or
$ python myFirstCode.py

   And we should get the following output-
I  ride on a road with a code

   Bamm! The print statement will display the contents included in the parenthesis.

Code execution overview
   Python is not just a programming language or not only a scripting language, but also an
   interpreter.

What is Interpreter?
   This is the software level sandwiched between the processor and the user. It understands
   the type of the program you want to execute. It reads the instruction from the program and
   execute it. As pointed out earlier, Python script is just a plain text file with the
   properly indented code and should be saved with extension .py. Indentation is a very
   crucial aspect in Python programming, if your code is not properly indented, Python will
   give out errors. I repeat -
   Remember : Whitespace indentation has a very important role to play in Python. If not used
   properly, it may throw syntax errors or even change the meaning of the code and the program
   might misbehave.
   Now, there is lot more happening in background with the execution of a Python code. When
   you run a Python code, it will be converted to something called Bytecode. Bytecode is
   platform-independent code which is not human readable, but machine understandable. This
   bytecode file is automatically saved onto the system by name with extension .pyc. So as you
   have guessed correctly our file myFirstCode.py is first converted to the myFirstCode.pyc
   internally and saved in the same directory as of the main file. This is the intermediate
   steps toward complete python code execution. Now this .pyc code (byte-code) is being run by
   something called PVM (Python virtual machine).
   PVM is just a big code which loops in the byte code to run through it, understands it and
   carries out the actual processing. Every time you run your python program with the source
   (.py file) unchanged, then the compilation step will be excluded from the processing and
   the Python uses byte-code directly saving the resources. To identify the source code
   change, python maintains the timestamp for last code changes. Python very well knows when
   to compile the source code to generate the byte code. And there are two instances when this
   happens, first- when the source code changes and the second- when the python version
   changes.
   That's all for the scope of this article. In the next article, we will learn how to install
   Python on Linux and create our first 'Hello World' program.


---
http://www.yourownlinux.com/2016/10/install-python-centos-ubuntu-linux.html

How to Install or Upgrade Python in Linux Systems

   Posted on October 14, 2016 by Mandar Shinde

   Hello readers! This is the second article of our tutorial series on Python - 'Python on
   Terminal' and in this article we will learn to install Python on your Linux system. In the
   last article of the series - [18]Introduction to Python, I have mentioned that, Python is
   available on most of the Linux distributions, nowadays, normally Python version 2.x.x. Even
   though Python2 is still being used by 85%-90% industries worldwide, someone might want to
   try his hands on Python3. Or some people, who have been using old Linux distributions,
   might wish to upgrade their existing Python version. This article will guide you to install
   Python or upgrade the Python version in your Linux systems. Here we go!
   [19][install-python-linux.JPG]

Installing or Upgrading Python in Linux
   First of all, we will see how Python can be installed on the Linux systems, if it is not
   already there. We do have plenty of package managers in different flavors of Linux
   distributions- apt-get and dpkg (for Ubuntu), yum (Yellowdog Update Manager, for
   CentOS/RHEL), zypper and yast (for SuSE Linux), to name a few. These package managers have
   made our life very easy, you just need to issue a command and they will search for the
   required packages and their dependencies, fetch them and install them for you. You need not
   download packages and their dependencies individually, which rather would have been a
   difficult task if there were no package managers.
   I have a system with CentOS 7 installed in it. I don't have Python installed in it. So, I
   can install it using yum command as shown below:
# If you are 'root' user
$ yum install python

# If you are 'non-root' user
$ sudo yum install python

   The command will not work for Ubuntu, as we have different package manager for that Linux
   distribution - apt-get, as mentioned earlier. So, for Ubuntu based systems, we can install
   Python using apt-get command as below:
$ sudo apt-get install python

   This will install Python in your Linux system. We can check the current version of Python
   installed in the system with the command - python -V (capital letter 'V') or python
   --version.
$ python -V
Python 2.7.5

$ python --version
Python 2.7.5

   Another way of installing Python is to download, build and install from source. This method
   can also be used to upgrade Python to a higher version. Let's say, we need to update the
   Python version from 2.7.5 to 3.5.2. For this, we need to download the source archive from
   the Python download page available at - [20]https://www.python.org/ftp/python/.
$ wget https://www.python.org/ftp/python/3.5.2/Python-3.5.2.tgz

   This file is an archive and needs to be extracted. This can be done using tar command as
   below-
$ tar -xvzf Python-3.5.2.tgz

   It will be extracted to a directory - Python-3.5.2, which you can verify using ls command.
   In the next step, we would need to configure, build and install Python. For that, we need
   to change to the directory where our archive is extracted, using cd command. Then, we
   configure the installation directory with the command - ./configure --prefix=/usr/local.
   For this, you need to have a C compiler installed in your system. If it's not there, it
   will display an error message. You can issue yum install gcc command in order to install
   GNU C Compiler in CentOS (sudo apt-get install gcc in case of Ubuntu). Now, we need to
   install Python and we do this by using make altinstall command. Thus, we have used below
   commands to configure and install Python using the extracted archive-
$ cd Python-3.5.2
$ ./configure --prefix=/usr/local
$ make altinstall

   It will take some moments for the installation to complete. When it is done, we can verify
   the Python versions installed by typing on terminal python[TAB][TAB]. It should show both
   the versions present in your system.
$ python
python    python2    python2.7    python3.5    python3.5m    python3.5m-config

$ python2.7 -V
Python 2.7.5

$ python3.5 -V
Python 3.5.2

   Thus, we now have two versions of Python with us, it's up to us which one to use. With
   this, we also came to an end of this article. In the next article, we would be learning
   Python variables, constants and datatypes in the next article of this tutorial series.
   Please let us know about your views and opinions in the comment section below.


---
http://www.yourownlinux.com/2016/10/python-constants-variables-built-in-data-types.html

Python - Constants, Variables and Built-in Data types

   Posted on October 15, 2016 by Mandar Shinde

   Hello readers! This is the third article of our tutorial series on Python - 'Python in
   Terminal' and we will be discussing about Constants, Variables and Basic data types in
   Python, in this article. In the previous two articles, we have had a brief [18]introduction
   to Python and learned about [19]Python installation on Linux systems. These two articles
   were very general, but from now on, we would be discussing Python Programming. Lets start
   our discussion with the definition of a Program.
   [20]python-constants-variables-built-in-data-types
   A program is a sequence of instructions, which process on input data and produces the
   desired output. Constant, variables and data types are the basic building blocks of any
   computer program. So, it is very essential to know about these terms and this is from where
   we start programming.

Constants
   Constants are fixed values that do not change during the execution of a program. Their
   properties are very much same as those in Mathematics. Python supports two types of
   constants that are listed below:
   1. Numeric constants : These are numbers, may it be positive number, negative number,
   complex number, floating point number or an exponential number. Thus, in Python, following
   numbers are valid numeric constants: 127, -128, 98.67, 4 + 3i, etc.
   2. String constants : These are the sequence of alphanumeric characters, special characters
   and underscores enclosed in a single or double quotes. This makes following valid string
   constants : "Your Own Linux!", "myString", 'I<3Python!', '', etc.

Variables
   A variable is a named location in memory that stores a value. In simpler words, when we
   create a variable and assign a value to it, the operating system reserves a memory location
   and stores the value in it. This memory location can then be identified or accessed with a
   variable name. Values can be numbers, text, images, audio clips or any other data. Unlike
   constants which remain unchanged during execution of a program, variables may take
   different values at different times during the execution of a program. Upon declaration,
   each variable belongs to a type that determines what type of value is stored in it, like
   numerals, literals or strings, etc. Whenever we choose a variable name, it should be
   meaningful for better readability of a code. For example, variable names such as ipAddr,
   firstName, team_size make more sense than variables ip, fname, ts.
   When we are to choose a variable name to store a value, we cannot simply select and use any
   alphanumeric string as a variable name, it must follow certain criteria. Following things
   must be taken care of while selecting a variable name:
     * A variable name consist of alphabets, digits and underscores, and it must start with a
       letter or underscore
     * No whitespaces are allowed
     * It should not be a keyword

   Note : Keywords are the reserved words in any programming language. They are predefined in
   libraries, have special meaning and purpose. Hence keywords are not allowed to be used as a
   variable names.
   Below are the keywords used in Python:
and, assert, break, class, continue, del, elif, else, except, exec, finally, for, from, global, if,
import, in, is, lambda, not, or, pass, print, raise, return, try, while, yield

   Considering above mentioned rules for a variable name, below are some valid and invalid
   variables names-
     * Valid variable names : firstName, test4, account_type, _serialNo
     * Invalid variable names : 24hours, #pin, total.20

   Variable Declaration
   We can assign a value to variable using the assignment operator =, using the syntax
   variable_name = value
>>> myValue = 5
>>> myValue
5

Built-in data types in Python
   A data type is the type of value a Python object has. Depending upon this, we have
   different built-in data types in Python, which are - bool, int, float, long, complex. There
   are some more built-in data types such as str, list, dict and tuple, but they can be
   related to data organization in Python, so we can refer to them as 'Python data
   structures'. We will definitely study them in later part of the tutorial series and for
   now, we concentrate on very basic data types and know each of them one-by-one. Meanwhile,
   we can check what type the value belongs to using Python built-in type() function.
   1. bool : A variable belonging to bool type can store only two possible values True and
   False. A bool type variable can be used only in logical operations.
>>> myBool = True
>>> type(myBool)
<type 'bool'>

>>> myBool = False
>>> type(myBool)
<type 'bool'>

   2. int : A variable belonging to int type stores only Integer values.
>>> myInt = 5
>>> type(myInt)
<type 'int'>

   3. float : A variable belonging to float type stores floating point value.
>>> myFloat = 10.50
>>> type(myFloat)
<type 'float'>

   4. long : A variable belonging to long type can store big big values. To declare value as a
   long, we have to append l to the numeric value.
>>> myLong = 10l
>>> type(myLong)
<type 'long'>

   5. complex : Complex numbers represents a real part and an imaginary part in the form
   (a+jb), a is real part and jb is imaginary part. Python provides built-in support for
   complex numbers.
>>> myComplex = 4 + 5j
>>> type(myComplex)
<type 'complex'>
>>> myComplex
(4+5j)

   Depending upon the type of the values, we have different types of operations those we can
   perform on them. So, knowing about Python built-in data types is of utmost importance.
   That's it for the scope of this article. We learned about Constants, Variables and
   different data types in Python, in this article. We are yet to be introduced to some other
   data types, like strings, lists, dictionaries and tuples, which we would be covering in a
   separate article, as they are more inclined towards data organization. In the next article,
   we will learn about basic arithmetic and logical operations in Python. Please let us know
   about your views and opinions in the comment section below and stay tuned. Thank you.


---
http://www.yourownlinux.com/2016/10/python-arithmetic-relational-logical-bitwise-operator.html

Python - Arithmetic, Relational, Logical and Bitwise Operators

   Posted on October 16, 2016 by Mandar Shinde

   Hello readers! This is the 4th article of our tutorial series on Python - 'Python on
   Terminal' and in this article, we are going to learn about different types of operations in
   Python. In the last article, we have had a brief overview on [18]Constants, Variables and
   Data types in Python and in this article, we will be needing them. Most of the part of this
   article is very simple and self-explanatory, this will be a refresher for you. So, without
   much a do, we will start our discussion on different kind of operators in Python, with
   which corresponding operations can be performed. Here we go !
   [19]python-arithmetic-relational-logical-bitwise-operator
   As you know, the basic building blocks of any programming language are variables and
   constants, using which we create a series of expressions. In order to write an expression,
   we require operators and operands. Operators are the symbols that are used to perform
   different type of computational tasks, while operands are the values (variables, constants,
   Python objects, etc.) on which we are performing operations. We are discussing operators in
   this tutorial.
   Depending on the type of operations they do, operators are classified as -
     * Assignment operators
     * Arithmetic operators
     * Relational operators
     * Logical operators
     * Bitwise operators

   Lets see them one-by-one.

Arithmetic operators
   We can assign a value to a variable using assignment statement. We can use the operator =
   for assigning values to variables.
>>> myNum = 5
>>> myNum
5

>>> myStr = "I Love Python <3"
>>> myStr
'I Love Python <3'

Arithmetic operators

   Basic arithmetic operations are addition, subtraction, multiplication, division, modulus
   and exponentiation. In Python, the operators (or symbols) used for these operations are as
   below:
     * + - Addition
     * - - Subtraction
     * * - Multiplication
     * / - Division
     * % - Modulus
     * ** - Exponentiation

   Example :
# Addition
>>> print 15 + 4
19

# Subtraction
>>> print 15 - 4
11

# Multiplication
>>> print 15 * 3
45

# Division
>>> print 15 / 3
5

# Modulus
>>> print 15 % 4
3

# Exponentiation
>>> print 15 ** 3
3375

Relational operators
   Relational operator uses two operands and returns a bool type, either True or False. We
   have six relational operators in Python (not only in Python, but everywhere else), which
   are as below:
     * < - Less than
     * <= - Less than or equal to
     * > - Greater than
     * >= - Greater than or equal to
     * == - Equal to
     * != - Not equal to

   Lets see each of them in examples below.
   Examples :
# Less than
>>> print 15 < 16
True

# Less or equals to
>>> print 15 <= 12
False

# Greater than
>>> print 15 > 12
True

# Greater or equals to
>>> print 15 >= 16
False

# Equals to
>>> print 15 == 16
False

>>> print 15 == 15
True

# Does not equal to
>>> print 15 != 15
False

>>> print 15 != 16
True

Logical operators
   There are three kinds of logical operations in Python. Each of them operates on one or more
   bool type and returns a bool type. They are listed as below:
     * and - Output is True, if all the operands are True, else False
     * or - Output is True, if any one of the operands is True, else False
     * not - Output is True if operand is False, else False.

   Example:
>>> x = True
>>> y = False

# NOT Operation
>>> print not x
False

>>> print not y
True

# AND operation
>>> print x and y
False

>>> print x and not y
True

>>> print not x and y
False

# OR Operation
>>> print x or y
True

>>> print not x or y
False

Bitwise operators
   So far, we have come across different kinds of operands and operators, but these operators
   are special ones. Bitwise operators process bits or bit patterns, unlike other operators.
   Basic bitwise operations are listed as below:
     * >> or Right Shift - Shift bits to right and adds '0's on left (Divide by 2 operation).
     * << or Left Shift - Shifts bits to left and add '0' on right (Multiply by 2 operation)
     * & or Bitwise AND - Performs AND operation on every bit and produces result
     * | or Bitwise OR - Performs OR operation on every bit and produces result
     * ^ or Bitwise XOR - Performs XOR operation on every bit and produces result
     * ~ or Bitwise NOT - Inverts all the bits

   Example :
# Right Shift
>>> print 15 >> 3
1                 # '1111' >> 3 = '0001'

>>> print 15 >> 1
7                 # '1111' >> 1 = '0111'

# Left Shift
>>> print 15 << 3
120               # '1111' << 3 = '1111000'

>>> print 15 << 1
30                # '1111' << 1 = '11110'

# Bitwise AND
>>> print 15 & 3
3                 # '1111' & '0011' = '0011'

>>> print 15 & 1
1                 # '1111' & '0001' = '0001'

# Bitwise OR
>>> print 15 | 3
15                # '1111' | '0011' = '1111'

>>> print 15 | 1
15                # '1111' | '0001' = '1111'

# Bitwise XOR
>>> print 15 ^ 3
12                # '1111' ^ '0011' = '1100'

>>> print 15 ^ 1
14                # '1111' ^ '0001' = '1110'

# Bitwise NOT
>>> print ~15
-16               # ~ '0000 1111' = '1111 0000'

>>> print ~3
-4                # ~ '0000 0011' = '1111 1100'

>>> print ~1
-2                # ~ '0000 0001' = '1111 1110'

   Thus, we can come to an end of this article. In this article, we learned about various
   operations/operators in Python. In the next article, we would be learning about some more
   data types (or built-in data structures) in Python. Please let us know about your views and
   opinions in the comment section below and stay tuned. Thank you.


---
http://www.yourownlinux.com/2016/10/introduction-python-list-tuple-dictionary-string-set-file-object.html

Python Built-in Data Structures : List, Dictionary, Tuple, Set, String, File Object

   Posted on October 19, 2016 by Mandar Shinde

   Hello again, readers! This is the 5th article in the series Python on Terminal and, this
   time, we are going to cover the basics of data structures in Python. Everything in Python
   that holds memory, in one or the other way, is considered as an Object and the type that
   the object belongs to is called as Data structure (or Data type, in other words). An object
   is a part of memory with related data, which may be assigned or predefined, and is
   associated with a set operations. There are two types of Data types (or Data Structures)-
   [18]python-built-in-data-structures
   1. Built-In Objects or Data Types
   There are four important built-in Objects in Python-
     * List
     * Dictionary
     * Tuple
     * Set

   2. User-Defined Objects or Data Types
   We will be knowing about these data types when we will be discussing about OOP (Object
   Oriented Programming) concept, wherein we can define and create our own data structures in
   Python and use them.
   When we speak about Python data structures, we need to look at the high to low level
   hierarchy of Python program. Lets look at the following figure.
  +-------------+
  |  Programs   |  Highest Level
  +-------------+
         |
  +-------------+
  |   Modules   |
  +-------------+
         |
  +-------------+
  | Statements  |
  +-------------+
         |
  +-------------+
  | Expressions |
  +-------------+
         |
  +-------------+
  |   Objects   |  Lowest Level
  +-------------+

   Python programs are made of modules, which, in turn, is made up from number of statements.
   Each of the statements contains expressions, which is the basic level of Python programming
   hierarchy. The expressions actually create objects and process them using some operations
   or methods. To do some task through programming languages, we have to deal with two
   important trade-offs -
   1. Data Structure:
   In this entity, we define our data types optimally, such that less memory should be
   consumed for the program execution. Along with this, we also have to take care of the time
   needed for program execution, which also depends on the logic used in writing the program.
   So, defining data structure is defining objects.
   2. Time-space:
   This trade off actually depends on the algorithm of your program. The ideal way to code a
   program is, one should write an algorithm which will use less space and less time to
   execute. This is where our data types come into the picture. Python programmer should
   identify which data structure is suitable to accomplish the task optimally.
   Lets elaborate each object in detail now.

Python Lists
   If you have any knowledge of C programming or C++, then we can relate this data type with
   Arrays. How? You will come to know when we will be learning them in more details.
     * Lists are the sequential data type. The data in the list is identified by its position
       (also known as offset) with respect to the base position starting from 0
     * Lists have no specific fixed size, they can be shrunk or extended
     * Lists are mutable, as they can be modified -

     * Assign the new value by using the position of the data in the list
     * Use the inbuilt functions to change or append the lists

   Unlike arrays in C, Python Lists can contain data of dissimilar type. In other words, you
   can have the first positional variable of float type, second as int, third as str and so
   on. Python intelligently identifies them and can validate the type of operations you want
   to do with each of the List item. For example, you can perform arithmetic operations on
   first and second item in the list, while concatenation on string object which is at third
   position. Hence,this is the best tool to represent the collection of dissimilar type of
   objects, like mailboxes, shopping carts etc.

Creating a List
   It doesn't need a lot efforts to create a Python list, you just need a bunch of Python
   objects separated by comma enclosed in a pair of square brackets [ ]. Consider the example
   as shown below:
>>> Friendlist = ['Ram', 'Mandar', 'Kumar', 'Mighty']

   In above example, Friendlist is the simple variable. It is assigned with the comma
   separated string values in square brackets ([]) to make it an object of type list.
   Now as I mentioned earlier, each of the list item is associated with a positional parameter
   called 'Index' starting from '0', counting from left to right in the list. So, 'Ram' is at
   the index '0', 'Mandar' at '1', 'Kumar' at '2' and 'Mighty' at '4'. Thus, 'Ram' and
   'Mighty' can be accessed using their indices as follows:
>>> Friendlist[0] # This returns Ram

>>> Friendlist[3] # This returns Mighty

   You might have noticed that, above list contains all the elements of a same kind i.e. all
   of them are strings. But, as I mentioned earlier that, this is not the limitation, you may
   also have objects of different types in a list as shown in below example:
>>> Mydata = ['Ram', 11.20, 400, 'India']

   It contains strings, float and integer type of data. We will be learning Python lists in
   more details in subsequent articles in this series.

Python Dictionaries
   Python dictionaries are the only data types which provide object relativity. In other
   words, unlike Python lists, the elements in Python dictionaries are identified using a
   'key', rather than any positional parameters. Dictionaries contain the data mapping,
   wherein the 'values' are mapped to their respective 'keys'. As an example, consider that we
   have to maintain the information about a product and the color of product being 'Red'. In a
   Python dictionary, we can represent this as 'Colour' : 'Red', where 'Color' is the key,
   which should be unique to the dictionary, and 'Red' is the value associated with it.
     * Dictionaries are also mutable i.e. their contents can be modified.
     * Unlike Lists, dictionary elements are accessed using their respective keys, instead of
       their position in the dictionary.
     * They are also called as 'Associative arrays' or 'Hashes'
     * Like lists, Python dictionaries can grow any further and can contain elements of
       dissimilar types.
     * Keys are unique and have only one associated value. This associated value can be any
       object, may it be a String, Integer, Float, Lists or even Dictionaries, and this can be
       nested to any number of times
     * Multiple keys in a Dictionary may have same values, but the keys must be unique and
       different
     * This is an unordered collection of data, so it is not associated with positional
       parameters

   Dictionaries are internally stored as Hash tables (It is type of data structure which
   starts with small size and grows extensively on demand facilitating the fast data
   retrieval) by Python. Python intelligently uses the optimized hashing algorithms to
   retrieve the stored data.

Creating Python Dictionaries
   You can create dictionaries in number of ways. The most common way to create Python
   dictionary, with comma separated Key:Value pairs enclosed in curly braces { }, is as
   follows:
>>> MyData = {'name': 'Vishal', 'age': 23}

   We have just created the dictionary object MyData, wherein the keys are 'name' and 'age'
   and there respective values are 'Vishal' and 23. Lets not get confused with the data
   presented in a single quote here, these are the string objects (which we will be discussing
   later in this article). Key and values in the dictionaries can be of any type, but the keys
   should be unique to that particular dictionary. You can see in the following dictionary 'D'
   that we have a Key:Value combination as 'integer type':'float type' which is valid.
>>> D = { 11:12.5, 12:'Mandar'}

   As mentioned earlier, the dictionary values can be accessed using their respective keys,
   which is demonstrated in below example:
>>> MyData['name'] # This would return 'Vishal'

>>> MyData['age'] # This would return 23

   This is how we access the value using key, in Python dictionaries. Please note that, the we
   have used square brackets (and not curly ones) to access the dictionary values. Now, to
   prove that Python dictionaries are mutable and hence can be modified and can have nested
   objects values, we have created a dictionary 'E' in the example given below:
>>> E = { 'India':{'City':'Mumbai','Street':50}}

   Here, in dictionary 'E', the key is 'India' and it points to other dictionary, which may
   again have further nesting in it. In such cases, how do we access the values using
   dictionary keys? Just have a look at example below:
>>> E['India'] ['Street'] # This would return 50

   In above examples, E['India'] would give us the value {'City':'Mumbai','Street':50}, an
   another dictionary. While the second key 'Street' points to the value 50 in that
   dictionary. In this way, using 'Double indexing', you can access a value in a dictionary
   enclosed in another dictionary (also called as 'Compound Objects').
   When you pass these dictionary names, E or D or MyData, as a parameter to built-in type()
   function, then it will return the 'type' (or 'Class') it belongs to. Lets try it then-
>>> type(E)
<type 'dict'>

   We will learn the operations and the built-in methods to manipulate the dictionaries in
   separate article.

Python Tuples
   Tuple is another data type (or Data structure or Object) in Python, which is almost similar
   to Python lists, with minute but crucial differences. There are lot more features a Tuple
   can provide, which we need to learn and we must find out the reason as to why this data
   type is introduced in Python, when the Python lists is available.
     * We can create a tuple by mentioning comma separated values enclosed in the parenthesis
       (( )). Tuple creation is almost the same as a List creation, with the brackets making
       the difference.
     * Like a Python list, tuple supports random collection of objects
     * The collection of elements is ordered, meaning that the individual elements are
       identified with their position in the sequence (Index), counting from left to right
       starting with '0'.
     * Tuple is a fixed length object i.e. we can't shrink it or update it. Hence they are
       immutable objects.
     * Tuple supports nesting of compound objects as in dictionary and list.
     * As the tuples are immutable, you can't change the size of a tuple without making a copy
       if it.

   Lets create Tuple named as T.
T = (0,'Ram','Nikhil',24.4)

   Tuple T contains objects of String, Integer and Float types. We can access these tuple
   items in the same way we accessed items in the list i.e. using indices inside square
   brackets.
T[1] # This returns 'Ram'

   So the pointing offset starts from 0. Hence T[0] will point to 0, T[2] points to 'Nikhil'
   and so on.
   One of the many things in which Python tuples differ from Python lists is that, we cannot
   make changes in a tuple, hence they are Immutable objects. But, of the many things which
   are common in tuples and lists, one is 'nesting'. As in lists, you can have a list within a
   list, you can have a tuple inside a tuple, or a list inside a tuple, or even a dictionary
   inside a tuple. Just have a look at the example below:
>>> M = ('dept',(23,'MG road'),[50,34,'India'])

   We have created tuple M with compound objects like string, tuple, lists. We can access the
   item 'MG Road' in tuple M, in the same way we did in case of dictionaries, remember 'Double
   indexing'?
>>> M[1][1] # This returns 'MG road'.

   First offset [1] in M[1][1] will point to object tuple (23,'MG road') and second offset [1]
   will point to the position of '1' inside this compound object. So, ultimately M[1][1] will
   point to 'MG road'.
   Let us check what type the tuple T belongs to, using type() function as follows:
>>> type(T)
<type 'tuple'>

   For more details about Python tuples, the operations and methods related to them, please
   check this article.

Python Sets
   This data type is used when the existence of an item is more important than its position.
   Simply, if we want to know whether 'Ankit' is present in a group of friends FriendSet,
   irrespective of it's position in the group, we can use Python Sets. In other words, a
   Python set is an unordered list of unique items (but it is not of type list). A set can be
   created using Python built-in set() and providing a list of items as a parameter to it.
   Lets create the set then -
>>> FriendSet = set(['Ram', 'Mandar', 'Jessica'])

   Here we have created the set named as FriendSet, which contains the list of friends. We
   have passed a list object to set() function in the above example, but it is not the only
   way. You can also create it - using a valueless dictionary - as shown below:
>>> Bestfriend = set({'Mandar'})

   The sets in Python logically resemble the sets in General Mathematics. You can find out
   Union and Intersection of two or more sets, as given below:
# This operation returns common items, called as 'Intersection'
>>> FriendSet & Bestfriend
set(['Mandar'])

   Same way, we can find out the difference between the sets, which will return unpaired
   values from both the sets.
# This operation returns set of uncommon items
>>> FriendSet - Bestfriend
set(['Ram', 'Jessica'])

   That's all about introduction to Python sets. We will learn more about them in later part
   of the series.

Python Numeric Data Types
   Numeric data types in Python are very straightforward. It provides variety of types of
   numbers which are needed for arithmetic and scientific calculations. This set of numeric
   objects includes -
     * Integers (numbers without decimal point)
     * Floats (with decimal points)
     * Complex numbers (with real and imaginary parts)

   You can perform basic arithmetic operations, like addition ('+' operator), subtraction ('-'
   operator), multiplication ('*' operator), division('/' operator) and exponential operation
   ('**' operator), on the objects of numeric data type. Python intelligently knows the type
   of number which is involved in the calculations. If we say a = 5 then variable 'a' will
   point to the memory which contains the integer value (or type int). Similarly, if we say a
   = 4.99 then a will be automatically considered as the floating point variable (or type
   float). Consider the examples below:
>>> a = 5 # Creating a variable which stores an integer value
>>> b = 1.234 # Creating a variable which stores a float value

   We must take care of the letter cases, as anything in Python is case sensitive. Thus,
   variable var and VAR will be treated as different objects by Python. As mentioned earlier,
   we don't have to declare the variables ahead of their use as Python dynamically decides the
   type of the objects based on assignment value. In the example given below, we have never
   declared variable c before using it. Then, we are adding an int type and a float type
   successfully, with Python giving out no errors.
>>> a = 5 # Variable 'a' of type 'int'

>>> b = 6.9 # Variable 'b' of type 'float'

>>> c = a + b # Addition of 'a' and 'b' stored in another variable 'c'

>>> print(c)
11.9

>>> type(c) # Checking it's type using  type() function
<type 'float'>

   While discussing about Numeric data types in Python, it is necessary to introduce the math
   module which provides extensive functions for vast numeric calculations. In the example
   given below, we have made use of sqrt() function available in math module. Before we can
   use it, we have to import math module, as shown in line 1.
>>> import math # 'math' is a built-in module
>>> math.sqrt(75) # sqrt() is a built-in function in math module
8.6602540378443873 # Output

   In the earlier article, we have discussed modules as - It is a package or a simple Python
   code saved with .py extension. When we have to use some functions from a module, then we
   have to import them explicitly in our Python code by writing import followed by the module
   name (math in above example).

Python Strings
   String is one of the most important data types in Python as it is almost needed in any
   Python program for recording the textual information or random collection of bytes (e.g. an
   Image file). String objects are ordered collection of data, which are indexed counting from
   '0' starting from left to right. Lets take a look at the following example to learn strings
   in easier way.
>>> S = 'Be like Ninja' # Creating a 13 character string and storing it to S

>>> S[0] # This returns 'B'

>>> S[3] # This returns 'l'

   So, as you can see in the above example, string is internally stored as Python sequences,
   like Lists. Thus, we can access it's elements in the same way as we did in case of lists.
   Strings are immutable (can't be modified). So, there is no way with which we can modify a
   string object, if we try to do so, Python will throw errors.
   We can operate and manipulate strings with a bunch of built-in functions like len() and
   methods like split(). We will be learning them all in later chapters in the series.

Python File Objects

   When we have to deal with data external to the program, in any programming language, we
   generally use Files and Python is no exception. File objects in Python are used to interact
   with all type of external data like mails, audio-video clips, documents, CSV files etc. The
   type of data defines the type of file, like for an audio file, Python will treat it as
   stream of bytes which is machine readable.
   In order to access/modify the files saved on our hard drive through a Python code, we have
   to open the file using a file object, then read from or write to the file using the file
   object and finally, close the file.
Open the file ---> Read or Write to the file ---> Close the file

   While opening a file, we must instruct Python in what mode the file has to be opened and
   the modes can be- Read ('r'), Write ('w'), Append ('a') or Binary ('b'), upon which Python
   will return a file object. There are built-in methods, associated with the file object, to
   open, read, write and close the files, which are open(), read(), write(), close()
   respectively. Lets create the 'Ninja.txt' file and write something to it. To create a new
   file, we have to provide the file name and mode as 'w' as a parameters to the open()
   function which will create a file object f for us. Python will create a new file with
   specified name in the current directory.
>>> f = open('Ninja.txt', 'w') # Creates a new file object 'f' by opening 'Ninja.txt' in Write mode

>>> f.write('Ninja is a coder,\n') # Writes a line to file

>>> f.write('Be like Ninja.\n') # Writes another line
>>> f.close() # Closes the file

   In order to read this file, we need to open it with the 'r' mode. Anyway, if no mode option
   is provided to open() function, the file will be opened in read mode, by default. Lets see
   the below example:
>>> f = open('Ninja.txt') # Opens the file in Read mode

>>> var = f.read() # Reads the file contents and stores it in 'var'

>>> print(var) # Prints the file contents
Ninja is a coder,
Be like Ninja.

   We must close the file object, using the close() method, whenever we are done with it.
   With this, we have come to an end of the scope of this article. We have learned about most
   of the Python data structures in this article. In the next few articles in the series, we
   will be exploring them all in more details. Please post your views and feedback in the
   comment section below and stay connected!


---
http://www.yourownlinux.com/2016/10/python-string-operations-concatenation-repetition-index-slice.html

Python String Operations - Concatenation, Repetition, Index and Slice

   Posted on October 22, 2016 by Mandar Shinde

   Hello readers! We are into 6th article of the series 'Python on Terminal' and it is
   intended to provide you exposure to Python Strings. In this article, we will learn about
   string properties and basic operations associated with them.
   [18]python-string-operations-concatenation-repetition-index-slice
   A string is a sequence of characters (or simply, some text) enclosed in single or double
   (or triple) quotes, that can include names, numbers, symbols, website's URL, this article's
   contents, ASCII and non-ASCII characters and so on. This makes strings - somestring, Some
   Other String, Only 1 String and What a String!, valid strings. Just like everything else in
   Python, a string is also an 'object' and it belongs to built-in str class, as we will see
   it shortly.

Creating Strings
   Creating strings is child's play! Just open your Python interpreter, type some random text
   enclosed in single or double quotes and hit Enter.
   Lets just begin with creating empty string using single and double quotes:
>>> ""
''

>>> ''
''

   Now, we create a non-empty string with some text enclosed in single quotes or double
   quotes:
>>> 'I<3Python!'
'I<3Python!'

>>> "I<3Python!"
'I<3Python!'

   Congrats, you've just created a string!
   One thing to be noted here is that, even if we used double quotes, it's output is the same
   as we saw in case of strings in single quotes. Then, why should we use double quotes?
   Just try creating a string I'm a big fool using single quotes and double quotes.
>>> 'I'm a big fool'
  File "<stdin>", line 1
    'I'm a big fool'
       ^
SyntaxError: invalid syntax

>>> "I'm a big fool"
"I'm a big fool"

   This is because, when we used 'I'm a big fool', Python sees that there are three 's and
   interprets that second ' is the ending quote. So, we somehow have to tell Python that, the
   second ' is not the original one, by escaping it with a \ as shown below:
>>> 'I\'m a big fool'
"I'm a big fool"

   This way, Python will realize that, the escaped ' isn't the closing one. Same is the case
   with double quotes. When using a string with "s inside double quotes, you have to escape
   them. Just have a look at the example below:
>>> ""You are a big fool", he said."
  File "<stdin>", line 1
    ""You are a big fool", he said."
        ^
SyntaxError: invalid syntax

>>> "\"You are a big fool\", he said."
'"You are a big fool", he said.'

   One more point to be noted here is that, you need not escape ' in double quotes and vice
   versa.
>>> "I'm a big fool"
"I'm a big fool"

>>> '"You are a big fool", he said.'
'"You are a big fool", he said.'

   In the first example above, we have used ' in double quotes, without escaping it, while in
   other example, we have used " inside single quotes. Another way is to use triple quotes,
   with which -
   1. One simply should not care about escaping special characters. Just put starting """ or
   ''' keep writing, put ending """ or ''' and relax. With """,
>>> """I'm a big fool"""
"I'm a big fool"

>>> """"You are a big fool", he said."""
'"You are a big fool", he said.'

   and with ''',
>>> '''I'm a big fool'''
"I'm a big fool"

>>> '''"You are a big fool", he said.'''
'"You are a big fool", he said.'

   2. One can use string that spans over multiple lines
>>> '''She: "What's your name?"
... He: "Bond, James Bond."
... She: "Nice name"
... '''
'She: "What\'s your name?"\nHe: "Bond, James Bond."\nShe: "Nice name"\n'

   Observe those \n in the output string, you never need to escape those, when you are using
   triple quotes. Also, if you assign this triple quoted string to variable, and then print
   that variable, you will get the expected output printed on the screen.
>>> myString = '''She: "What's your name?"
... He: "Bond, James Bond."
... She: "Nice name"
... '''
>>> print myString
She: "What's your name?"
He: "Bond, James Bond."
She: "Nice name"

   In above example, we have created a multiline string, using triple quotes, and saved it in
   a variable, which we named as myString.

String Operations
   Now that, having learned to create single and multiple line strings, its time to know about
   operations associated with them. These operations either give information about the objects
   (string in our case) or perform certain operations on them. Lets begin with the type method
   (or function, if 'method' does not sound good to you).
   The Python built-in type() function, when provided with an object (a string, in the context
   of this article) as a parameter, returns the type of that object. In order to verify this,
   let us create a string variable myNewString and pass it to type() function.
>>> myNewString = "Some stupid text here..."
>>> type(myNewString)
<type 'str'>

   or, simply pass the string directly to the type() function as a parameter.
>>> type('Old MacDonald Had a Farm...')
<type 'str'>

   The output <type 'str'> makes it clear that, the object (which is a string object) which
   you passed to the type() function as a parameter, is of the 'String type' (or belongs to
   class 'string', this will come when we will be learning about Python Classes).

String Concatenation and String Repetition
   Python strings can be concatenated with a + sign. For those, who do not know what
   concatenation is, it joins (or links or places side by side) two or more strings together.
   So, concatenation of words Hello and World will provide is a new string object -
   HelloWorld. Lets check this in the terminal:
>>> str1 = "Code"
>>> str2 = "Ninja"
>>> str3 = ".in"
>>> str1 + str2 + str3
'CodeNinja.in'

   Cool! We've just concatenated three strings. What if we have to concatenate two strings and
   one integer - 'He is', 60 and years old.? Will above trick work?
>>> str1 = 'He is '
>>> str2 = 60
>>> str3 = ' years old.'
>>> str1 + str2 + str3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: cannot concatenate 'str' and 'int' objects

   That's an exception (or error, simply) and it says - TypeError: cannot concatenate 'str'
   and 'int' objects. Meaning that, Python can never concatenate a str type (a string object)
   and an int type (an integer), it can only concatenate two or more strings. In this case, we
   need to convert that integer to a str type (string object) and this can be done using
   Python built-in str(). This function takes a parameters and returns its string version. So,
   when we pass the integer 777 to str() function, it returns us '777', a str object (look at
   those quotes there!). Now, we concatenate those two string objects with str type of the
   integer as below:
>>> str1 = 'He is '
>>> str2 = 60
>>> str3 = ' years old.'
>>> str1 + str(str2) + str3
'He is 60 years old.'

   Note : we can concatenate only string objects. If we need to concatenate object with any
   other type, that has to be converted to str type.
   We have another operator - "*", with which we can generate repetitive sequence of the
   string object. So, in order to repeat a string 'Zero' for N times, we use 'Zero' * N, which
   produces a single string ZeroZeroZero... repeating Zero N times. Lets do it on terminal:
>>> 'CodeNinja' * 6
'CodeNinjaCodeNinjaCodeNinjaCodeNinjaCodeNinjaCodeNinja'

>>> myString = 'CodeNinja'
>>> myString * 6
'CodeNinjaCodeNinjaCodeNinjaCodeNinjaCodeNinjaCodeNinja'

String Indexing and String Slicing
   Any string object, being sequence of characters, is associated with positional parameters,
   called 'Index' ('Indices' in plural). Using these indices, we can count number of items in
   the string (often called as 'length' of a string), access each item of the string (or
   'iterate' through a string) and to take out a sub-string from a string (or 'slice' a
   string). As you might have thought about, these indices start from offset zero, beginning
   from left, and string items can be accesses using a very popular syntax -
   stringName[index]. Thus, stringName[0] is the first string item and stringName[3] is the
   fourth one.
   String objects do support Negative Indexing with which we can access elements from the end
   of the string (counting backward), instead of beginning of the string. This is useful when
   you have a really long string (like 41 characters long) and have to access the third last
   element. In this case, if you don't prefer to use negative index, you must know the length
   of the string. Length of a string can be determined by passing string to len() function.
   With the string length known to you, you can start counting through the string items, till
   you reach the third last element (stringName[38]). As an alternative, you can use -3 as the
   offset to access the same item, in simple words, stringName[-3] makes more sense than
   stringName[38].
   Consider the example below:
>>> myString = "Here is a long, useless and boring stuff!"

# Determine the length of the string
>>> len(myString)
41

# Accesing 6th element
>>> myString[5]
'i'

# Accesing 4th element from last
>>> myString[-4]
'u'

   String slicing allows us to extract a portion of a string (sub-string) from the original
   string, we just need to mention from where to start and where to stop counting, using the
   syntax - stringName[START:END], where START is inclusive and END is non-inclusive. So, when
   we say myString[1:6], it will start slicing from the item at index '1' and till but not
   including the item at index '6'. Effectively, you will have a sub-string of items starting
   from index '1' up to the one at index '5'.
   If we do not mention the END index, we would get a sub-string starting at index START till
   the end. Similar is the case when we do not mention START index, we would get a sub-string
   starting from the item at index '0' till the one at index END. Apart from START and END, we
   have an optional parameter here - STEP, which gets added to the index when an item is
   extracted from the string. So, stringName[START:END:STEP] gives every STEPth element in the
   string stringName starting with item at index START till but not including item at index
   END.
   Have a look at below examples to have more clarity on above description.
>>> myString = "CodeNinjaDotIn"

# Checking length of the string
>>> len(myString)
14

# Slice from index '2' up to but not including index '7'
>>> myString[2:7]
'deNin'

# Slice from index '5' onwards
>>> myString[5:]
'injaDotIn'

# Slice up to but not including index '9'
>>> myString[:9]
'CodeNinja'

# Full slice
>>> myString[:]
'CodeNinjaDotIn'

# Slice including every other item starting from '0'th
>>> myString[0::2]
'CdNnaoI'

# Slice of every third element beginning from index at '0'
>>> myString[0:8:3]
'Cen'

# String reversal with a step of -1
>>> myString[::-1]
'moCtoDajniNedoC'

# Slice counting backwards starting at index '7'
# up to but not including index '2' and
# catching every other item
>>> myString[7:2:-2]
'jie'

Strings are 'Immutable'!
   Python objects are said to be 'Mutable', if their value is changeable i.e. they can be
   modified, otherwise they are called as 'Immutable'. Before we conclude (we have already
   concluded though, in the section title itself) whether a string object is mutable or
   immutable, we try to change its value from CodeNinjaDotIn to Cod3NinjaDotIn as below:
>>> myString = "CodeNinjaDotIn"

>>> myString[3] = '3'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment

   You can not change a string object and they are Immutable.
   So, in this article, we have learned about Python string objects, how they can be created,
   concatenation & repetition of strings and how strings are indexed and sliced. In the next
   article on Python strings, we would be learning about String Methods. Please post your
   feedback in the comment section below.


---
http://www.yourownlinux.com/2016/10/python-string-methods-find-join-replace.html

Python String Methods - find(), join(), replace(), etc.

   Posted on October 24, 2016 by Mandar Shinde

   Hello readers! This is the 7th article of our Python series 'Python on Terminal' and we
   will be learning about String Methods in Python in this tutorial. In the previous article
   on Python Strings, entitled as [18]Python Strings- Creation, Concatenation, Repetition,
   Indexing and Slicing, we learned to create strings, their concatenation and repetition,
   their indexing and slicing. This article is the continuum of the mentioned article and this
   time, we will be exploring Python string methods with examples.
   [19]python-string-methods-find-join-replace
   The term 'method' might sound unfamiliar to you, if you are a newbie. But no worries,
   that's why this article is being written. So, a method is a function (in C language
   context) which when called on an object, returns a value, that might be a modified version
   of that object or any information related to that. The key difference between functions and
   methods is that, methods are the functions in a class and are associated with the class
   objects. Whereas, a function is callable code fragment, which may or may not accept
   arguments, but is written to avoid redundancy in the code.
   As an example, consider a string object mySring. Being an object of a str class, it has a
   method upper() associated with it. This upper() method is just a function written inside
   str class and thus, can be used with str class objects only. So, in order to use any
   method, we have to qualify it with object name as - object_name.method(). Speaking about
   functions, they are the re-usable piece of code written in the body of the program.
   Note : All methods are functions, but vice-versa may not be always true.
   Starting our discussion on the string methods, we create a string myString and pass it as
   an argument to dir() function. When we pass an object to Python built-in dir() function, it
   provides a list (another Python object, which we will be studying later) of attributes
   (which will be covered in Object Oriented Programming Concepts), including methods,
   associated with them (Methods are callable attributes, which can be called on objects).
>>> myString = "CodeNinjaDotIn"

>>> dir(myString)
['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__',
 '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init_
_', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduc
e_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook
__', '_formatter_field_name_split', '_formatter_parser', 'capitalize', 'center', 'count', 'decode',
'encode', 'endswith', 'expandtabs', 'find', 'format', 'index', 'isalnum', 'isalpha', 'isdigit', 'isl
ower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace',
'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', '
strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']

   The above list includes some string methods beginning with double underscores, like
   __contains__, which are called 'Magic Methods' and they are used by Python internally (we
   will be discussing on this later). Let us have a look at some of the important string
   methods and see what they do with our Python object MyString.

1. capitalize() Method :
   It capitalizes only the first character of the string.
>>> myString = "codeninjadotin"

>>> type(myString.capitalize)
<type 'builtin_function_or_method'>

>>> myString.capitalize()
'Codeninjadotin'

   Just for our curiosity, we checked what type the object myString.capitalize belongs to and
   rightly so, it is a String Method!

2. count() Method :
   With this method, we can count number of occurrences of a sub-string (provided as a
   parameter) in the string on which this method is called.
   Syntax: stringName.count(substring, [START], [END]), where in START and END are optional
   parameters and are indices at which the search begins and ends, respectively.
>>> myString = "CodeNinjaDotIn"

# Search for string 'o' in entire myString
>>> myString.count('o')
2

# Search for string 'o' starting search from index '0' ending (but not including) at index '11'
>>> myString.count('o', 0, 11)
2

# Search for a string 'o' from index '3'
>>> myString.count('o', 3)
2

# Search for a string 'Dot' specified in a variable 'str'
>>> str = 'Dot'
>>> myString.count(str)
1

3. endswith() Method :
   This string method accepts a parameter of str type and returns True if the string object
   (on which this methods is called) ends with the specified string, else returns False.
   Syntax: stringName.endswith(substring, [START], [END]), where in START and END are optional
   parameters (as in case of last example) and are indices at which the search begins and
   ends, respectively.
>>> myString = "Welcome to CodeNinjaDotIn"

# Check if 'myString' ends with 'Org'
>>> myString.endswith('Org')
False

# Check if 'myString' ends with 'In'
>>> myString.endswith('In')
True

# Check if 'myString[0:9]' ends with 'to'
>>> myString.endswith('to', 0, 9)
False

# Check if 'myString[0:10]' ends with 'to'
>>> myString.endswith('to', 0, 10)
True

# Check if 'myString[5:]' ends with 'In'
>>> myString.endswith('In', 5)
True

4. startswith() Method :
   This string method is similar to endswith() methos, it accepts a parameter of str type and
   returns True if the string object (on which this methods is called) begins with the
   specified string, else returns False.
   Syntax: stringName.startswith(substring, [START], [END]), where in START and END are
   optional parameters and are indices at which the search begins and ends, respectively.
>>> myString = "Welcome to CodeNinjaDotIn"

# Check if 'myString' begins with 'Wel'
>>> myString.startswith('Wel')
True

# Check if 'myString[10:]' starts with 'Code'
>>> myString.startswith('Code', 10)
False

# Check if 'myString[11:]' starts with 'Code'
>>> myString.startswith('Code', 11)
True

# Check if 'myString[4:17]' starts with 'o'
>>> myString.startswith('o', 4, 17)
True

5. find() Method :
   This accepts a parameter of str type and returns index of the sub-string if the string
   object (on which this methods is called) contains the specified sub-string, else returns
   -1.
   Syntax: stringName.find(substring, [START], [END]), where in START and END are optional
   parameters and are indices at which the search begins and ends, respectively.
>>> myString = "Welcome to CodeNinjaDotIn"

# Find the index of 'come' if it is in 'myString', else return -1
>>> myString.find('come')
3

# Find the index of 'come' if it is in 'myString[7:]', else return -1
>>> myString.find('come', 7)
-1

# Find the index of 'ja' if it is in 'myString[5:20]', else return -1
>>> myString.find('ja', 5, 20)
18

# Find the index of substring saved in variable 'str',
# if it is in 'myString', else return -1
>>> str = 'Org'
>>> myString.find(str)
-1

>>> str = 'In'
>>> myString.find(str)
23

6. index() Method :
   Similar to find() method, it accepts a parameter of str type and returns index of the
   sub-string if the string object (on which this methods is called) contains the specified
   sub-string, the only difference is that it raises an Exception (or an error message, we
   will study exceptions in separate article) when it doesn't find the sub-string.
   Syntax: stringName.index(substring, [START], [END]), where in START and END are optional
   parameters and are indices at which the search begins and ends, respectively.
>>> myString = "CodeNinjaDotIn"

# Look for index of sub-string 'Nin' in 'myString'
>>> myString.index('Nin')
4

# Look for index of sub-string 'Dot' in 'myString[5:]'
>>> myString.index('Dot', 5)
9

# Look for index of sub-string stored in variable 'str' in 'myString[3:12]'
>>> str = 'ja'
>>> myString.index(str, 3, 12)
7

# Look for index of sub-string 'Net' in 'myString', else raise an Exception
>>> myString.index('Net')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: substring not found

7. isupper() Method :
   This method when called on a string object, returns True, if all the letters in that string
   object are upper-cased, else returns False.
   Syntax: stringName.isupper()
>>> myString = "codeninjadotin"
>>> myString.isupper()
False

>>> myString = "CodeNinjaDotIn"
>>> myString.isupper()
False

>>> myString = "CODENINJADOTIN"
>>> myString.isupper()
True

8. islower() Method :
   This method when called on a string object, returns True, if all the letters in that string
   object are lower-cased, else returns False.
   Syntax: stringName.islower()
>>> myString = "CODENINJADOTIN"
>>> myString.islower()
False
>>>
>>> myString = "CodeNinjaDotIn"
>>> myString.islower()
False
>>>
>>> myString = "codeninjadotin"
>>> myString.islower()
True

9. isalpha() Method :
   This method when called on a string object, returns True, if all the letters in that string
   object are alphabetic letters, else returns False.
   Syntax: stringName.isalpha()
# Below string has a special character
>>> myString = "CodeNinja.In"
>>> myString.isalpha()
False

# Below string has numbers and special characters
>>> myString = "C0d3N1nj@.In"
>>> myString.isalpha()
False

# Below string has only alphabetic characters
>>> myString = "CodeNinjaDotIn"
>>> myString.isalpha()
True

10. isdigit() Method :
   This method when called on a string object, returns True, if all the items in that string
   object are digits, else returns False.
   Syntax: stringName.isnum()
>>> myString = "CodeNinja.In"
>>> myString.isdigit()
False

>>> myString = "C0d3N1nj@.In"
>>> myString.isdigit()
False

>>> myString = "567890"
>>> myString.isdigit()
True

11. isalnum() Method :
   This method when called on a string object, returns True, if all the items in that string
   object are alphanumeric characters, else returns False.
   Syntax: stringName.isalnum()
>>> myString = "CodeNinja.In"
>>> myString.isalnum()
False

>>> myString = "CodeNinjaDotIn"
>>> myString.isalnum()
True

>>> myString = "C0d3N1nj@.In"
>>> myString.isalnum()
False

>>> myString = "C0d3N1njaD0t1n"
>>> myString.isalnum()
True

12. upper() Method :
   This method when called on a string object, converts all the characters in the string
   object to upper case, this doesn't change the string itself though (as strings are
   immutable).
   Syntax: stringName.upper()
>>> myString = "codeninjadotin"
>>> myString.upper()
'CODENINJADOTIN'

>>> myString = "CodeNinjaDotIn"
>>> myString.upper()
'CODENINJADOTIN'

>>> myString = "C0d3N1njaD0t1n"
>>> myString.upper()
'C0D3N1NJAD0T1N'

13. lower() Method :
   This method when called on a string object, converts all the characters in the string
   object to lower case, this doesn't change the string itself though (as strings are
   immutable).
   Syntax: stringName.lower()
>>> myString = "CodeNinjaDotIn"
>>> myString.lower()
'codeninjadotin'

# Strings are Immutable :)
>>> myString
'CodeNinjaDotIn'

>>> myString = "C0d3N1njaD0t1n"
>>> myString.lower()
'c0d3n1njad0t1n'

14. title() Method :
   This method when called on a string object, converts first letter of each word in the
   string object to upper case, this doesn't change the string itself though (as strings are
   immutable).
   Syntax: stringName.title()
>>> myString = "code ninja dot in"
>>> myString.title()
'Code Ninja Dot In'

# Strings are Immutable
>>> myString
'code ninja dot in'

15. swapcase() Method :
   This method when called on a string object, returns a string with all upper cased letters
   to lower case and vice versa as in the string object.
   Syntax: stringName.swapcase()
>>> myString = "codeninjadotin"
>>> myString.swapcase()
'CODENINJADOTIN'

>>> myString = "CODENINJADOTIN"
>>> myString.swapcase()
'codeninjadotin'

>>> myString = "CodeNinjaDotIn"
>>> myString.swapcase()
'cODEnINJAdOTiN'

17. join() Method :
   This method takes one argument - a sequence, and it is called on a str type, that acts as a
   separator. With this, join() method joins the strings in the sequence in the argument with
   the separator to create and return a string. A sequence can be a list type or a tuple type
   or any iterable/sequence, while separator has to be a str type. Please take a look at below
   examples if this sounds confusing.
   Syntax: <separator>.join(<sequence/iterable>)
>>> print ":".join(["00", "11", "22", "33", "44"])
00:11:22:33:44

# A List as a sequence
>>> mySequence = ["00", "11", "22", "33", "44"]
>>> print "-".join(mySequence)
00-11-22-33-44

# Sequence stored in a variable
>>> mySep = '-*-'
>>> mySep.join(mySequence)
'00-*-11-*-22-*-33-*-44'

# A Tuple as a sequence
>>> mySequence = ('Happy', 'Birthday')
>>> mySep.join(mySequence)
'Happy-*-Birthday'

18. replace() Method :
   This method accepts two mandatory parameters- SUBSTRING and REPLACEMENT and one optional
   parameter- COUNT. What this method does is, it replaces SUBSTRING in the string object, on
   which the method is called, with the REPLACEMENT string, while COUNT denotes the maximum
   number of replacements to be made, which defaults to 'all' (replacing all the instances of
   SUBSTRING).
   Syntax: stringName.replace(SUBSTRING, REPLACEMENT, [COUNT])
>>> myString = "this is the end"
>>> myString.replace('is', 'at')
'that at the end'

>>> myString.replace('is', 'at', 1)
'that is the end'

>>> subStr = 'is'
>>> repStr = 'at'
>>> myString.replace(subStr, repStr)
'that at the end'

   And indeed, we have reached at the end of this article. We have studied bunch of string
   methods and worked on them, we have not covered all of them though. But, I'm sure that, we
   will be covering most of them as we progress through the tutorial series. Thanks for
   stopping by and reading this article, please share your opinions & feedback in the comment
   section below and do stay connected.


---
http://www.yourownlinux.com/2016/10/python-list-comprehension-operations.html

Python List Comprehension, Concatenation, Repetition, Index and Slice

   Posted on October 28, 2016 by Mandar Shinde

   Hello readers! In some of our recent articles we have learned about [18]Python Strings -
   How they are created, how they are concatenated and repeated, how they are indexed and
   sliced, and a bunch of methods associated with them. In the similar way, we will be
   learning about another Python object here- Lists. In this article, we are going to know
   about Python lists properties and basic operations, including List creation, concatenation,
   repetition, etc., those can be performed on them. But, first of all, we see what lists are.
   [19][python-list-comprehension.JPG]
   A Python List is a sequence of Python objects (strings, integers, lists, dictionaries,
   tuples, etc), each of them being separated by comma, enclosed in square ([ ]) brackets.
   Everything in Python being an object, makes a Python list an object, and every list is an
   instance of Python built-in list class. In brief, its a Python object that is created with
   the help of a few or more Python objects (empty lists do not contain any element, though).
   Moreover, it being a sequence (like Python strings), each item contained within a list is
   assigned with an index, using which a list can easily be sliced (like Python strings,
   again). Let's dig deeper into the lists!

Creating Lists
   To begin with, lets create an empty list. As mentioned earlier, a list is a sequence of
   Python objects enclosed between two square brackets. When we don't mention anything inside
   the brackets, it creates an empty list for us. Another method is to use list() function, it
   receives a string parameter and returns a list type. When we do not specify any parameters
   to list() function, it returns an empty list.
>>> myList = []
>>> myList
[]

>>> myList2 = list()
>>> myList2
[]

   Simple! Now, we create a non-empty list by putting Python objects between the square
   brackets.
# A list of Integers
>>> myList = [1, 2, 3, 4, 5]
>>> myList
[1, 2, 3, 4, 5]

# A list of Strings
>>> myList = ['Real Madrid', 'Barcelona', 'Manchester United', 'Liverpool']
>>> myList
['Real Madrid', 'Barcelona', 'Manchester United', 'Liverpool']

# A list of Lists
>>> myList = [['a', 'b', 'c'], ['d', 'e', 'f'], ['x', 'y', 'z']]
>>> myList
[['a', 'b', 'c'], ['d', 'e', 'f'], ['x', 'y', 'z']]

# A list of Dictionaries
>>> myList = [{'String' : 'Apple', 'Integer' : 101}, {'Website' : 'CodeNinja', 'Topic' : 'Python Lis
ts'}]
>>> myList
[{'Integer': 101, 'String': 'Apple'}, {'Website': 'CodeNinja', 'Topic': 'Python Lists'}]

# A list of mixed objects
>>> myList = ['I<3Python', 7, ['Asia', 'America', 'Europe'], {'Movie': 'The Revenant', 'Year' : 2015
}]
>>> myList
['I<3Python', 7, ['Asia', 'America', 'Europe'], {'Movie': 'The Revenant', 'Year': 2015}]

   Awesome! We now check what type this list variable myList belongs to, by using built-in
   type() function.
>>> type(myList)
<type 'list'>

   Thus, myList is of type list or it is an instance of list class.
   Another way to create a list is using for-in statement. As we are new to for statement, I
   will demonstrate list creation using strings. The for statement uses a variable to iterate
   through each item of the string. Using this variable, we can put each item of the string
   inside square brackets, to create a list. Sounds difficult? No worries, just have a look at
   the example below, we will break the statement for easier understanding.
>>> myString = "ABCDEFXYZ"
>>> [var for var in myString]
['A', 'B', 'C', 'D', 'E', 'F', 'X', 'Y', 'Z']

   In above example, we start from right end and take out a portion of the command - for var
   in myString. In this statement, for uses a variable var to iterate over the items of the
   string myString. So, in the first iteration, var is assigned with the value of first item
   of the string i.e. A, while in the second iteration, var gets the value of second item of
   the string i.e. B and so on. But, we haven't made use of this variable var yet. So, in the
   entire command, we loop over each item of the string and using var before for, we actually
   use each value assigned to it, and enclosing it in square brackets returns us a list. In
   short, this is equivalent to [ sequence of values assigned to var ], an object of list
   type.
   I cannot stop myself from mentioning about a Python built-in function range() here. The
   syntax for using range() function is - range([START], STOP, [STEP]), where START and STEP
   are optional parameters. This function returns a list of numbers starting from START ('0'
   if not provided) up to but not including the number END, including every STEPth number.
   Lets see some examples on range() function.
# Starting from '0' ending but not including '7'
>>> range(7)
[0, 1, 2, 3, 4, 5, 6]

# Starting from '2' ending but not including '9'
>>> range(2, 9)
[2, 3, 4, 5, 6, 7, 8]

# Starting from '1' ending but not
# including '11', including every '3'rd element
>>> range(1, 11, 3)
[1, 4, 7, 10]

# What type of object does it return?
>>> type(range(1, 11, 3))
<type 'list'>

List Concatenation and Repetition
   Just like strings, Python lists can also be concatenated, using + sign. Lets check this
   over terminal.
>>> myList1 = ['Hello', 'World']
>>> myList2 = [1, 4, 9, 16, 25]
>>> myList3 = ['Ten', 20, 'Thirty', 40]

>>> myList1 + myList2 + myList3
['Hello', 'World', 1, 4, 9, 16, 25, 'Ten', 20, 'Thirty', 40]

>>> type(myList1 + myList2 + myList3)
<type 'list'>

   Easy! In above example, we concatenated three lists using + operator, which returns a list
   object. Now, we will check what would be the result if we concatenate a list object with a
   str object.
>>> myList = ['Code', 'Ninja', 'Dot', 'In']
>>> myStr = "Code Ninja Dot In"
>>> myList + myStr
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can only concatenate list (not "str") to list

   Aaanndd.. The result is an Exception which says - TypeError: can only concatenate list (not
   "str") to list. That means, we cannot concatenate a list object with a str object. In order
   to concatenate str object with list object, we must convert str object to listtype, using
   Python built-in list() function as shown below.
# This is the 'string' type object
>>> myStr = "Code Ninja"
>>> type(myStr)
<type 'str'>

# It becomes a list when passed to 'list()' function
>>> list(myStr)
['C', 'o', 'd', 'e', ' ', 'N', 'i', 'n', 'j', 'a']
>>> type(list(myStr))
<type 'list'>

# This is the 'list' type object
>>> myList = [1, 2, 3]
>>> type(myList)
<type 'list'>

# We concatenate both 'list' type objects
>>> myList + list(myStr)
[1, 2, 3, 'C', 'o', 'd', 'e', ' ', 'N', 'i', 'n', 'j', 'a']

   In the same manner, we can use * operator to create a repeated sequence of list elements as
   below:
>>> myList = ['One', 2, 'Three', 4]
>>> myList * 4
['One', 2, 'Three', 4, 'One', 2, 'Three', 4, 'One', 2, 'Three', 4, 'One', 2, 'Three', 4]

List Indexing and Slicing
   As we have already seen in the case of Python Strings, every Python List is also a sequence
   of elements and are associated with positional parameters, i.e. 'Index'. With these
   indices, we can determine the length of a list (number of elements in a list), we can
   access elements in a list, we can insert/remove list items and even slice the lists. The
   indexing in the list, like strings, starts from zero, counting from left to right. Thus,
   first list item is listName[0], second list item will be listName[1] and so on. Python
   lists also support negative indexing, for accessing list items from right to left. Thus,
   for long lists, we can access last list element using listName[-1], second last list
   element with listName[-1], without actually doing any mathematics.
   List slicing is the process of extracting a portion of list from an original list. We just
   have to mention the START index, STOP index and an optional parameter STEP (with default
   value as '1'). So, the syntax for List slicing becomes - listName[START : END [: STEP]].
   Thus, myList[2:8] will return a list object, including elements from the list myList,
   starting from element at index '2' (third element) up to but not including element at index
   '8'. If we do not mention the value for END index, it will default to the index of the last
   item in the list, while in case we do not mention the value for START index, it will
   default to the index of the first element i.e. '0'. Apparently, not mentioning START and
   END indices will return the original list.
   As mentioned earlier, we have an optional parameter - STEP, which gets added to the index
   whenever an item is extracted from the list. So, listName[START:END:STEP] extracts every
   STEPth element from the list listName starting with element at index START up to but not
   including element at index END.
   Below examples will provide a clearer view on what we have studied in this section.
>>> myList = ['I<3Python', 7, ['Asia', 'America', 'Europe'], {'Movie': 'The Revenant', 'Year': 2015}
]

# Accessing the first element of the list
>>> myList[0]
'I<3Python'

# Accessing the third element of the list
>>> myList[2]
['Asia', 'America', 'Europe']

# Index of the Index - Accessing the second element of third element of the list
>>> myList[2][1]
'America'

>>> myList[3]['Year']
2015

# We create a new list to demonstrate Negative Indexing and List Slicing
>>> myList = range(13)
>>> myList
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

# Determining length of the list using 'len()' function
>>> len(myList)
13

# Accessing the last element using index '-1'
>>> myList[-1]
12

# Accessing the fourth last element using index '-4'
>>> myList[-4]
9

# List slice starting from element at index '2'
# up to but excluding element at index '8'
>>> myList[2:8]
[2, 3, 4, 5, 6, 7]

# List slice starting from element at index '4' up to last element
>>> myList[4:]
[4, 5, 6, 7, 8, 9, 10, 11, 12]

# List slice starting from beginning,
# up to but not including element at index '9'
>>> myList[:9]
[0, 1, 2, 3, 4, 5, 6, 7, 8]

# The complete slice
>>> myList[:]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

# Slice of the list including every 3rd element
# starting from element at index '2'
>>> myList[2::3]
[2, 5, 8, 11]

# Slice of the list including every other element
# starting from element at index '1'
# up to but excluding the element at index '10'
>>> myList[1:10:2]
[1, 3, 5, 7, 9]

# List reversal using STEP = -1
>>> myList[::-1]
[12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

# Another example with negative STEP
>>> myList[10:0:-2]
[10, 8, 6, 4, 2]

Lists are 'Mutable'!
   Python objects are said to be 'Mutable', if their value is changeable i.e. they can be
   modified, otherwise they are called as 'Immutable'. To determine whether Lists are mutable
   or not (I've already determined it in the section title :)), we try to change the value of
   the list element as shown below:
>>> myList = ['I<3Python', 7, ['Asia', 'America', 'Europe'], {'Movie': 'The Revenant', 'Year': 2015}
]
>>> myList
['I<3Python', 7, ['Asia', 'America', 'Europe'], {'Movie': 'The Revenant', 'Year': 2015}]

>>> myList[2] = 'ReplacedValue'
>>> myList
['I<3Python', 7, 'ReplacedValue', {'Movie': 'The Revenant', 'Year': 2015}]

   Success, we have modified a List! With this, we can conclude that List objects are
   Mutable!.
   So, in this article, we have learned what Python lists are, how they can be created and
   basic operations, like concatenation, repetition, indexing & slicing, associated with them.
   In the next article on Python lists, we would be learning about the methods associated with
   them. If you have anything to say about this article, please share your views in the
   comment section below. Thank you!


---
http://www.yourownlinux.com/2016/10/python-list-methods-append-sort-remove-reverse.html

Python List Methods - append(), sort(), remove(), reverse(), etc.

   Posted on October 31, 2016 by Mandar Shinde

   Hello readers! This is the 9th article of our Python tutorial series 'Python on Terminal'
   and we will be learning about List Methods in Python in this tutorial. In the previous
   article on Python Lists - [18]Python Lists Creation, Concatenation, Repetition, Indexing
   and Slicing, we studied how to create lists, how two lists can be merged and repeated and
   how indexing and slicing works for Python lists. In this article, we will be learning about
   various methods associated with Python lists along with examples.
   [19][python-list-methods.JPG]
   In the last article on Python Lists, we have already seen that, like everything in Python,
   a list is also an object. It is an instance of the Python class named list. Thus, every
   list in Python is associated with a number of methods, which when called upon a list object
   (list_object_name.method_name()), do some processing on list object and returns another
   Python object (not necessarily a list type only).
   So, what all methods can we call on a Python list object? You can get the answer by passing
   a Python list as an argument to Python built-in dir() function. Lets create a list then and
   check this.
>>> myList = ['One', 2, 'Three', 4.00]
>>> dir(myList)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '_
_eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash
__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne
__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__'
, '__setitem__', '__setslice__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'count', 'ex
tend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

   Again, as we've seen earlier in case of Python strings, list are also associated with
   'Magic Methods' (the ones starting with double underscores, e.g. __add__ method), those
   Python uses internally. Let us now learn some important list methods in detail.

1. append() Method :
   This method appends (inserts at the end) an element (a Python object) to the Python list.
   To check this, we need to create a list and check how this method works.
>>> myList = ['One', 2, 'Three', 4.00]
>>> myList.append('Five')
>>> myList
['One', 2, 'Three', 4.0, 'Five']

>>> myList.append(3*2)
>>> myList
['One', 2, 'Three', 4.0, 'Five', 6]

>>> import math
>>> myNum = math.sqrt(49)
>>> myList.append(myNum)
>>> myList
['One', 2, 'Three', 4.0, 'Five', 6, 7.0]

   Thus, every time we call append() method on myList list object, the element is inserted at
   the end of myList. By the way, we have just grown a list object myList, meaning that a list
   is mutable. Let us be some more curious and check what if we provide another list as an
   argument. Will it concatenate both the lists or appends another list to myList -
>>> myList = ['One', 2, 'Three', 4.0]
>>> myList.append(['Five', 3*2 ])
>>> myList
['One', 2, 'Three', 4.0, ['Five', 6]]
>>> myList[-1]
['Five', 6]

   The later option - it will append. There is a method extend() which does the concatenation.

2. count() Method :
   This method counts the number of occurrences of an element in the list which the method is
   called on. So, myList.count('Foo') will count how many times the string Foo has occurred in
   the list object myList.
>>> myList = ['One', 2, 'Three', 4.0, 'One', 'Five', 2, 'One', 4.0, 'ONE', 4]

# Case-sensitive
>>> myList.count('One')
3

# 'int' and 'float'
>>> myList.count(4)
3
>>> type(4)
<type 'int'>
>>> type(4.0)
<type 'float'>
>>> 4 == 4.0
True

3. extend() Method :
   This method takes an iterable (always remember this) and appends each item to the list.
   Thus, if we call this method on myList with another list (which is an iterable) as an
   argument, all the elements will be appended to myList.
>>> myList = ['One', 2, 'Three', 4.0]

# List as an argument
>>> myList.extend(['Five', 3*2 ])
>>> myList
['One', 2, 'Three', 4.0, 'Five', 6]

# 'range()' function as an argument
>>> myList.extend(range(7, 10))
>>> myList
['One', 2, 'Three', 4.0, 'Five', 6, 7, 8, 9]

# String as an argument
>>> myList.extend('Ten')
>>> myList
['One', 2, 'Three', 4.0, 'Five', 6, 7, 8, 9, 'T', 'e', 'n']

   Please observe the last case very carefully. We have provided a string 'Ten' to the
   extend() method, expecting that the string object 'Ten' will be appended to myList. But,
   extend() accepts iterables and a Python string being an iterable, all the characters are
   appended to myList one-by-one and we can see the result.

4. index() Method :
   This method is similar to the string index() method. It accepts an element as an argument
   and returns the index of the first occurrence of the element in the list, if it is present
   in the list, otherwise it will give out an error.
>>> myList = ['One', 2, 'Three', 4.0, 'Five', 6, 7, 8, 9]

>>> myList.index('Five')
4

>>> myNum = 4
>>> myList.index(myNum)
3

>>> myList.index('Six')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: 'Six' is not in list

5. insert() Method :
   The append() method will always add an element to the last position of the list, whereas
   insert() method accepts an extra argument denoting the 'offset' at which the element has to
   be inserted.
>>> myList = ['One', 2, 'Three', 4.0, 'Five']

# Insert 'Zero' at index '0'
>>> myList.insert(0, 'Zero')
>>> myList
['Zero', 'One', 2, 'Three', 4.0, 'Five']

# 'append' using 'insert()' method
>>> myList.insert(len(myList), 'The End')
>>> myList
['Zero', 'One', 2, 'Three', 4.0, 'Five', 'The End']

6. pop() Method :
   This method when used without any argument, returns the last element in the list. It does
   accept an optional argument with which we can specify the offset of the list element to be
   returned. When the element is returned, it is also removed from the list.
>>> myList = ['One', 2, 'Three', 4.0, 'Five']

# 'pop()' without argument -> Last element is returned and list is modified
>>> myList.pop()
'Five'
>>> myList
['One', 2, 'Three', 4.0]

# Item at index '1' is returned and list is modified
>>> myList.pop(1)
2
>>> myList
['One', 'Three', 4.0]

# 'pop()' method on empty list gives out error
>>> [].pop()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: pop from empty list

7. remove() Method :
   Using pop() method, we can remove an element from a list using it's offset, while with
   remove() method, we can remove an element from a list using it's value. pop() method with
   no argument removes last list element, but this won't work in case of remove() method. We
   must provide the value of the element that needs to be removed.
>>> myList = ['One', 2, 'Three', 4.0, 'Five']

# It takes exactly one argument !
>>> myList.remove()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: remove() takes exactly one argument (0 given)

>>> myList.remove(4)
>>> myList
['One', 2, 'Three', 'Five']

>>> myStr = 'Three'
>>> myList.remove(myStr)
>>> myList
['One', 2, 'Five']

8. reverse() Method :
   This method when called on a list object, it reverses it in place, without returning
   anything. It means that, the contents of the original list are reversed and list is
   modified. In this context, let me also mention the built-in list reverse iterator object
   reversed, that returns a reversed list object, with the original list not getting modified.
>>> myList = ['One', 2, 'Three', 4.0, 'Five']

# 'reverse()' reverses the original list in-place
>>> myList.reverse()
>>> myList
['Five', 4.0, 'Three', 2, 'One']
>>> myList = ['One', 2, 'Three', 4.0, 'Five']

# With 'reversed()' original list is not modified
>>> list(reversed(myList))
['Five', 4.0, 'Three', 2, 'One']
>>> print reversed(myList)
<listreverseiterator object at 0x7ff2e1fdbe10>
>>> myList
['One', 2, 'Three', 4.0, 'Five']

9. sort() Method :
   This method when called on a list object, orders the list elements in ascending order by
   default, original list is modified in-place. This method can take arguments so as to change
   the behavior of the default sorting process.
>>> myList = ['One', 2, 'Three', 4.0, 'Five']
>>> myList.sort()
>>> myList
[2, 4.0, 'Five', 'One', 'Three']

# Sort in descending order
>>> myList = ['One', 2, 'Three', 4.0, 'Five']
>>> myList.sort(reverse=True)
>>> myList
['Three', 'One', 'Five', 4.0, 2]

   There is a Python built-in function sorted, which accepts a list type object as an argument
   and returns a sorted version of that list without modifying the original list. You can try
   that out - sorted(myList)
   With this, we have learned all the important list methods along with some examples. Python
   lists are very powerful and useful data structures and you would use them most of the
   times. So, it is very essential to know all the methods associated with them, study their
   behaviors and use them accordingly. Thank you for stopping by and going through this
   article. Please do share your views and opinions in the comment section below and stay
   tuned for more articles.

   
   
---
http://www.yourownlinux.com/2016/11/python-dictionary-comprehension-dict-type.html

Python Dictionary Comprehension - 'dict' type

   Posted on November 04, 2016 by Mandar Shinde

   Hello readers! This is another article of our tutorial series on Python 'Python on Terminal' and in
   this article we will have an introduction with another data structure or datatype in Python -
   'Dictionary' (Dictionaries, in plural form). In some of previous articles, we have learned about two
   other data structures - [18]Python Strings and [19]Python Lists, Python Lists being Ordered
   collection of data (or Python objects, in more correct words). Ordered as every element in a list is
   associated with a positional parameter or offset or index. But, in a Python Dictionary, there is no
   indexing. Instead, every element is stored and accessed using a unique 'key', in the dictionary. A
   key is just a human-readable and meaningful name used to identify a value stored in the dictionary,
   which in more expressive than using an index. In short, a Python dictionary is a collection of data
   in the form of key:value pairs enclosed in curly braces { }, analogous to 'hash tables', which makes
   search operations faster with the use of dictionaries.
   [20]python-dict
   Needless to mention here, Python dictionaries, just like everything in Python, are also objects and
   they belong to Python built-in dict class. Lets now know more about dictionary in more details.

Creating a Dictionary
   To begin with, let's create simplest dictionary in the world - a blank dictionary. To create so, we
   need to complete the formalities by including 'nothing' within curly braces. This can also be done
   using Python built-in function dict() as shown below-
>>> myDict = {}
>>> myDict
{}

# Using 'dict()' function
>>> myDict2 = dict()
>>> myDict2
{}

   Now, we use some key:value pairs to create a non-empty dictionary. These keys and values can be any
   Python object, but do remember that, a key must be unique across the dictionary or the value
   associated with it will be overwritten. Also, dictionary keys must be Python objects which are not
   mutable. That means, we can use strings and tuples as dictionary keys, but not lists.
>>> myDict = {'Spain' : 'Barcelona', 'England' : 'Leicester City'}
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}

   We learn an important property of Python dictionaries here. If you observe carefully, while creating
   the dictionary, we've mentioned 'Spain' : 'Barcelona' pair first and then 'England' : 'Leicester
   City'. But, it has not displayed them in the same order. This is because, unlike Python Lists, Python
   dictionaries are Unordered Collection of data, as there are no positional parameters associated with
   them. Let us create some more dictionaries-
# 'str' as Key and 'list' as Value
>>> myDict = {'Spain' : ['Barcelona', 'Real Madrid'], 'England' : ['Leicester City', 'Arsenal']}
>>> myDict
{'England': ['Leicester City', 'Arsenal'], 'Spain': ['Barcelona', 'Real Madrid']}

# Lists are mutable and cannot be used as keys
>>> myDict = {['Barcelona', 'Real Madrid']: 'Spain', ['Leicester City', 'Arsenal'] : 'England'  }
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'

# Nested dictionary - 'dict' as Value
>>> myDict = {'Ronaldo' : {'Club' : 'Real Madrid', 'Country' : 'Portugal', 'Jersey Number' : 7}, 'Messi' : {'C
lub' : 'Barcelona', 'Country' : 'Argentina', 'Jersey Number' : 10} }
>>> myDict
{'Messi': {'Club': 'Barcelona', 'Country': 'Argentina', 'Jersey Number': 10}, 'Ronaldo': {'Club': 'Real Madrid
', 'Country': 'Portugal', 'Jersey Number': 7}}

# 'int' type are non-mutable and can be used as Keys
>>> RealMadridDict = {7 : 'Cristiano Ronaldo', 11 : 'Gareth Bale', 9 : 'Karim Benzema'}
>>> RealMadridDict
{9: 'Karim Benzema', 11: 'Gareth Bale', 7: 'Cristiano Ronaldo'}

   Great! Now, we check what type the variable myDict belongs to, using type() function.
>>> type(myDict)
<type 'dict'>

   As we've seen earlier, there is a Python built-in dict() function, with which we can create
   dictionaries. We have already created an empty dictionary using it and this time we create a
   non-empty dictionary using the syntax dict(key1='value1', key2='value2') as shown below-
>>> myDict = dict(Spain='Barcelona', England='Leicester City')
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}

Basic Operations on a Dictionary

1. Adding elements to a dictionary
   First thing to note is that - Dictionaries are mutable Python objects, as they can be modified. Now
   we check this by modifying a dictionary, by adding elements to a dictionary. For this, we simply
   create a key:value pair as dict_name[key] = value. This will create a key with name key in a
   dictionary dict_name and assign a value value to it.
>>> myDict = {'England': 'Leicester City', 'Spain': 'Barcelona'}
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}
>>> myDict['Italy'] = 'Juventus'
>>> myDict
{'Italy': 'Juventus', 'England': 'Leicester City', 'Spain': 'Barcelona'}
>>> myDict['Germany'] = 'Bayern Munich'
>>> myDict
{'Italy': 'Juventus', 'Germany': 'Bayern Munich', 'England': 'Leicester City', 'Spain': 'Barcelona'}

   Again, dictionaries are not the ordered collections.

2. Accessing the elements of a dictionary
   To access the elements of a dictionary, we need to make use of dictionary keys as shown below. If the
   key is not present in the dictionary, a 'KeyError' exception (or error in simple words) is raised.
   The syntax for accessing dictionary items is - dict_name[key_name]
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}

>>> myDict['England']
'Leicester City'

>>> myDict['France']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'France'

3. Deleting elements from a dictionary
   We can add elements to a dictionary using a key, similarly, we make use of a dictionary key to delete
   the elements from that dictionary and Python built-in del function. The syntax for deletion is - del
   dict_name[key].
>>> myDict
{'Italy': 'Juventus', 'Germany': 'Bayern Munich', 'England': 'Leicester City', 'Spain': 'Barcelona'}

# Deleting 'Italy': 'Juventus' using key
>>> del myDict['Italy']
>>> myDict
{'Germany': 'Bayern Munich', 'England': 'Leicester City', 'Spain': 'Barcelona'}

# Deleting 'Germany': 'Bayern Munich' using key
>>> del myDict['Germany']
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}

4. Updating values in a dictionary
   Again, dictionary keys are very useful in this case. We can modify the value associated with a key
   using the key itself. Just assign a new value to the existing key - dict_name(key) = new_value.
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}

# Changing 'Leicester City' to 'Liverpool'
>>> myDict['England'] = 'Liverpool'
>>> myDict
{'England': 'Liverpool', 'Spain': 'Barcelona'}

5. Length of a dictionary
   Length of a dictionary is nothing but the number of key:value stored in the dictionary. We can get
   this count using the Python built-in function len() as - len(dict_name).
>>> myDict
{'England': 'Liverpool', 'Spain': 'Barcelona'}
>>> len(myDict)
2

>>> myDict['Germany'] = 'Bayern Munich'
>>> myDict
{'Germany': 'Bayern Munich', 'England': 'Liverpool', 'Spain': 'Barcelona'}
>>> len(myDict)
3

6. Check if a key exists in a dictionary
   We can use in keyword so as to check if a key exists in a dictionary. It will return boolean value
   True or False based on the situation. The syntax for this is - in
>>> myDict
{'Germany': 'Bayern Munich', 'England': 'Liverpool', 'Spain': 'Barcelona'}

# Is 'Germany' a dictionary key ?
>>> 'Germany' in myDict
True

# Is 'France' a dictionary key ?
>>> 'France' in myDict
False

7. Important dictionary methods
   For the scope of this article, we limit our discussion on only three important dictionary methods -
   keys(), values and items(). The name of former two methods hints at what they are used for. If you've
   guessed correctly, the keys() method when called on a dictionary, returns a list of all dictionary
   keys. Similar is the case for values() method, it returns a list of all dictionary values. The third
   method, items, returns a list of tuple pairs, wherein the first element in the tuple is a key and
   second element is the value associated with it.
>>> myDict
{'Germany': 'Bayern Munich', 'England': 'Liverpool', 'Spain': 'Barcelona'}

# 'keys()' returns a list of keys
>>> myDict.keys()
['Germany', 'England', 'Spain']

# 'values()' returns a list of values
>>> myDict.values()
['Bayern Munich', 'Liverpool', 'Barcelona']

# 'items()' returns a list of (key, value) tuple pairs
>>> myDict.items()
[('Germany', 'Bayern Munich'), ('England', 'Liverpool'), ('Spain', 'Barcelona')]

   Thus, as these methods return a list type object, we can iterate over it using a for .. in statement.
   Don't worry if you don't understand it, we will have a separate article on for loops. It's sufficient
   to know that keys(), values() and items(), all of them return an iterable - a list.
>>> for key in myDict.keys():
...     print key
...
Germany
England
Spain

>>> for value in myDict.values():
...     print value
...
Bayern Munich
Liverpool
Barcelona

>>> for key,value in myDict.items():
...     print key + ' = ' + value
...
Germany = Bayern Munich
England = Liverpool
Spain = Barcelona

   That's all for now! In this article, we learned some of the properties of Python dictionaries, we
   created dictionaries in different ways, we added elements in the dictionaries, we deleted the entries
   from dictionaries, we calculated the number of entries and we worked on three of the important
   methods related to dictionaries. In this next article, we would learn some more dictionary methods
   along with examples. I hope you enjoyed reading this article, please share your views and opinions in
   the comment section below. Thank you.



---
http://www.yourownlinux.com/2016/11/python-dictionary-methods.html

Python Dictionary Methods

   Posted on November 08, 2016 by Mandar Shinde

   Hello readers! This is the 11th article of our tutorial series on Python - 'Python on Terminal', and
   we will be studying 'Dictionary methods' in Python in this article. In the last article on [18]Python
   dictionaries, we learned to create dictionaries and basic operations associated with them. We also
   learned three of the important dictionary methods - keys(), values and items(). In this article, we
   will be covering some more dictionary methods with their examples. Let's begin !
   [19]Python dictionary methods
   First of all, we check what all methods are associated with Python dictionaries and we use Python
   built-in dir() function to list all of them. For this, we need to create a dictionary and provide it
   as an argument to dir() function.
>>> myDict = {'Spain' : 'Barcelona', 'England' : 'Leicester City'}
>>> dir(myDict)
['__class__', '__cmp__', '__contains__', '__delattr__', '__delitem__', '__doc__', '__eq__', '__format__', '__g
e__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '_
_lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeo
f__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'has_key', 'items', 'iteritems', 'ite
rkeys', 'itervalues', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values', 'viewitems', 'viewkeys', 'vi
ewvalues']

   As we've seen in case of Strings and Lists, there are Magic Methods for Python dictionaries too,
   which Python uses internally. We need not care about them now and start our discussion on dictionary
   methods, right away.

1. clear() Method :
   Well, the name of the method says it all. This method removes all the entries from the dictionary.
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}
>>> myDict.clear()
>>> myDict
{}

2. copy() Method :
   This method when called on a dictionary, returns a copy of the dictionary on which it is called. This
   method is used to create a copy of a dictionary, or to copy the contents of a dictionary to other
   dictionary.
>>> myDict1
{'England': 'Leicester City', 'Spain': 'Barcelona'}
>>> myDict1.copy()
{'England': 'Leicester City', 'Spain': 'Barcelona'}
>>> myDict2 = myDict1.copy()
>>> myDict2
{'England': 'Leicester City', 'Spain': 'Barcelona'}

3. fromkeys() Method :
   This method is used to create a new dictionary using Python built-in dict type (constructor is the
   more correct word). It accepts one mandatory argument of list type, say keylist and one optional
   argument, say value. With the list provided, it returns a dictionary having keys mentioned in the
   list. The value we mention in the optional argument is set as the default value of all the keys. If
   no value is mentioned, None will be the values set. The syntax to use this method is -
   dict.fromkeys(keylist[, value])
>>> dict.fromkeys(['England', 'Spain'])
{'England': None, 'Spain': None}

>>> dict.fromkeys(['England', 'Spain'], "I don't know!")
{'England': "I don't know!", 'Spain': "I don't know!"}

4. get() Method :
   This method also accepts a mandatory argument, say key and an optional argument, say default. When we
   call this method on a dictionary, it returns the value corresponding to the key mentioned. If key is
   not present in the dictionary and no optional argument is provided, it would return None. In this
   case, if optional value (default) is provided, it would return the default value. The syntax for
   using this method is - dict_name.get(key_name [, default_value]).
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}

>>> myDict.get('Germany')
>>> myDict.get('Germany', 'Bayern Munich')
'Bayern Munich'

5. has_key() Method :
   This method requires a mandatory argument, that refers to the key to be looked for in the a
   dictionary. When we call this method on a dictionary, it checks whether the key mentioned in the
   argument is present in the dictionary. It returns True if present, False otherwise. The syntax for
   this method is - dict_name.has_key(key_name).
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}

>>> myDict.has_key('Spain')
True

>>> myDict.has_key('France')
False

6. items() Method :
   If you have read the last article on Python dictionaries, you must have read about this method. This
   method when called on a dictionary, it returns a list of tuples of key-value pairs in the form
   [(key1, value1), (key2, value2), ... , (keyN, valueN)], where (key1, value1) is a tuple of key-value
   pair. Let's check this.
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}
>>> myDict.items()
[('England', 'Leicester City'), ('Spain', 'Barcelona')]

   One thing to be noted here, this method returns a list, i.e. an iterable. Thus, using this method
   along with for .. in, we can iterate over all the key-value pairs in the dictionary and perform
   operations on them.

7. iteritems() Method :
   We've seen items() returning a list of tuples of key-value pairs, which would require more memory, if
   dictionary was too long. Now, we have iteritems() method, that returns an iterator. This iterator
   lets us iterate over an item (key-value pair) at a time, so that memory is required to store only one
   key-value pair for that iteration. In the next iteration, the previously stored key-value pair is
   flushed and next pair is picked up and stored.
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}

>>> myDict.iteritems()
<dictionary-itemiterator object at 0x7f9c6deea208>

>>> type(myDict.iteritems())
<type 'dictionary-itemiterator'>

>>> for (key, val) in myDict.iteritems():
...     print 'Key is ' + str(key) + ' and Value is ' + str(val)
...
Key is England and Value is Leicester City
Key is Spain and Value is Barcelona

8. keys() Method :
   This method when called on a dictionary, returns a list of keys present in the dictionary. Similar to
   iteritems(), we have iterkeys() method also, that returns a key-iterator object.
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}

>>> myDict.keys()
['England', 'Spain']

>>> myDict.iterkeys()
<dictionary-keyiterator object at 0x7f9c6deea208>

>>> type(myDict.iterkeys())
<type 'dictionary-keyiterator'>

>>> for key in myDict.iterkeys():
...     print 'Key = ' + key
...
Key = England
Key = Spain

9. values() Method :
   This method when called on a dictionary, returns a list of values present in the dictionary. As we
   have iteritems() and iterkeys() methods, we also have itervalues() method, which returns a
   value-iterator object.
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}

>>> myDict.values()
['Leicester City', 'Barcelona']

>>> myDict.itervalues()
<dictionary-valueiterator object at 0x7f9c6deea208>

>>> type(myDict.itervalues())
<type 'dictionary-valueiterator'>

>>> for val in myDict.itervalues():
...     print 'Value is ' + val
...
Value is Leicester City
Value is Barcelona

10. pop() Method :
   The syntax for this method is - dict_name.pop(key_name [, default_value]), where default_value is
   optional argument. This method when called on a dictionary, it returns the the value associated with
   the key provided in the argument. If the key is not present in the dictionary and default_value is
   not mentioned, it will raise an exception (or an error). If the default_value argument is provided
   and if key is not present, it will return default_value instead of raising an exception.
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}

>>> myDict.pop('England')
'Leicester City'
>>> myDict
{'Spain': 'Barcelona'}

>>> myDict.pop('Germany')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'Germany'

>>> myDict.pop('Germany', 'Key not present !!')
'Key not present !!'

11. popitem() Method :
   This method does not need any arguments to be provided. It just returns a tuple of a random/arbitrary
   key-value pair and removes it from the dictionary. If the dictionary is empty, it will raise an
   exception, as there is nothing to pop out from the dictionary.
>>> myDict = {'England': 'Leicester City', 'Spain': 'Barcelona'}

# Call 'popitem()' and check the contents
>>> myDict.popitem()
('England', 'Leicester City')
>>> myDict
{'Spain': 'Barcelona'}

# Check the type of popped out item
>>> type(myDict.popitem())
<type 'tuple'>
>>> myDict
{}

# 'popitem()' method on an empty dictionary
>>> myDict.popitem()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'popitem(): dictionary is empty'

12. setdefault() Method :
   This method is very much similar to get() method. The difference is that, we have an optional
   parameter in case of get() method, which is returned if the key we are looking for is not present in
   the dictionary. While, setdefault() method does not only returns the 'default' value mentioned, but
   it also sets the value to the key mentioned (if key is not present in the dictionary).
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}

# 'get()' method - Key is not present, will return default value, but not set it
>>> myDict.get('Germany', 'Bayern Munich')
'Bayern Munich'
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}

# 'setdefault()' method with key present, returns the associated value
>>> myDict.setdefault('England', 'Bayern Munich')
'Leicester City'
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}

# 'setdefault()' method with key not present, returns the default value
>>> myDict.setdefault('Germany', 'Bayern Munich')
'Bayern Munich'
# also sets the value against the key
>>> myDict
{'Germany': 'Bayern Munich', 'England': 'Leicester City', 'Spain': 'Barcelona'}

13. update() Method :
   This method accepts another dictionary as a mandatory argument and merges all the key-value pairs
   into the dictionary on which the method is called, very similar to 'concatenation'. In this case, if
   some key is common to both the dictionaries, it's value will be overwritten.
>>> myDict
{'England': 'Leicester City', 'Spain': 'Barcelona'}
>>> myDict2 = {'Germany' : 'Bayern Munich'}
>>> myDict.update(myDict2)
>>> myDict
{'Germany': 'Bayern Munich', 'England': 'Leicester City', 'Spain': 'Barcelona'}

# A dictionary with common key 'England'
>>> myDict3 = {'England' : 'Manchester City'}
>>> myDict.update(myDict3)
>>> myDict
{'Germany': 'Bayern Munich', 'England': 'Manchester City', 'Spain': 'Barcelona'}

14. View Objects, viewkeys(), viewvalues() and viewitems() Methods :
   We have Python views in Python 2.7 onward. We can consider these methods to be very similar to
   iteritems(), iterkeys() and itervalues() methods. The difference being that, iteritems() method
   returns an iterator object while viewitems() returns dynamic view of the dictionary items. They are
   dynamic, as whenever changes are made in dictionary, those get reflected in the views.
>>> myDict = {'England': 'Leicester City', 'Spain': 'Barcelona'}
>>> myDict.viewitems()
dict_items([('England', 'Leicester City'), ('Spain', 'Barcelona')])
>>> myDict.viewkeys()
dict_keys(['England', 'Spain'])
>>> myDict.viewvalues()
dict_values(['Leicester City', 'Barcelona'])

>>> type(myDict.viewitems())
<type 'dict_items'>
>>> type(myDict.viewkeys())
<type 'dict_keys'>
>>> type(myDict.viewvalues())
<type 'dict_values'>

# A change is made to the dictionary
>>> myDict['Germany'] = 'Bayern Munich'
>>> myDict.viewitems()
dict_items([('Germany', 'Bayern Munich'), ('England', 'Leicester City'), ('Spain', 'Barcelona')])
>>> myDict.viewkeys()
dict_keys(['Germany', 'England', 'Spain'])
>>> myDict.viewvalues()
dict_values(['Bayern Munich', 'Leicester City', 'Barcelona'])

   With this, we have come to the end of this article. We have learned a bunch of dictionary methods in
   this article along with their examples. In the next article, we will be learning about another data
   structure in Python - Tuple. Please let us know about your views and opinions in the comment section
   below and stay tuned. Thank you.



---
http://www.yourownlinux.com/2016/11/python-tuple-concatenation-repetition-index-slice.html

Introduction to Python Tuple

   Posted on November 10, 2016 by Mandar Shinde

   Python Tuple- Hello readers! In some of recent articles, we have been discussing on built-in data
   structures (or data types) in Python. We have already covered [18]Python Strings, [19]Python Lists
   and [20]Python Dictionaries. In this article, we introduce you to another Python built-in data
   structure - Python Tuple. If you remember how Python lists behave, you can easily understand the
   behavior of Python Tuple, as they work in pretty similar way. They have a few dissimilar properties
   though, which we will be learning as we go through this article. Let's start!
   [21]python-tuple
   Like Python lists, Python tuples are ordered collection of Python objects (strings, lists,
   dictionaries, tuples, numbers, etc), separated by a comma (,) and enclosed in parenthesis (( )). I
   emphasized the word 'ordered', as every element in a tuple (again, like lists) is associated with a
   positional parameter, which we call as - index or offset. As a tuple is made up of zero or more
   Python objects, it is also a Python object and it's an instance of Python built-in tuple class. To
   know more about tuples, lets create one!

Creating Tuples
   The easiest tuple to create is the empty tuple - no elements in the tuple. To create an empty tuple,
   we do not put any elements in the parenthesis. This is one way and another was is to use Python
   built-in tuple() function, which when called with no arguments, returns an empty tuple.
>>> myTuple = ()
>>> myTuple
()

>>> myTuple = tuple()
>>> myTuple
()

   Success! We now move ahead an create an non-empty tuple. We just need to put bunch of Python objects
   we have studied by now, within the parenthesis.
# A tuple of Integers
>>> myTuple = (1, 4, 9, 16, 25)
>>> myTuple
(1, 4, 9, 16, 25)

# A tuple of Strings
>>> myTuple = ('One', 'Four', 'Nine', 'Sixteen', 'Twenty Five')
>>> myTuple
('One', 'Four', 'Nine', 'Sixteen', 'Twenty Five')

# A tuple of Lists
>>> myTuple = (['One', 'Four'], ['Nine', 'Sixteen'], ['Twenty Five'])
>>> myTuple
(['One', 'Four'], ['Nine', 'Sixteen'], ['Twenty Five'])

# A tuple of Dictionaries
>>> myTuple = ({'One' : 1, 'Four' : 2}, {'Nine' : 3, 'Sixteen' : 4, 'Twenty Five': 5})
>>> myTuple
({'Four': 2, 'One': 1}, {'Sixteen': 4, 'Nine': 3, 'Twenty Five': 5})

# A tuple of Tuples
>>> myTuple = ((1, 'One'), (2, 'Four'), (3, 'Nine'), (4, 'Sixteen'), (5, 'Twenty Five'))
>>> myTuple
((1, 'One'), (2, 'Four'), (3, 'Nine'), (4, 'Sixteen'), (5, 'Twenty Five'))

# A mixed tuple
>>> myTuple = ({1 : 'One', 2 : 'Four'}, [3, 'Nine', 4, 'Sixteen'], 5, 'Twenty Five')
>>> myTuple
({1: 'One', 2: 'Four'}, [3, 'Nine', 4, 'Sixteen'], 5, 'Twenty Five')

   Note : One very important thing to remember is that, a tuple with only one item can be created as
   (item,) and not (item). A comma must be mentioned or it will not be considered as a tuple type.
# Invalid one-item tuples
>>> myTuple = ('item')
>>> type(myTuple)
<type 'str'>

>>> myTuple = (101)
>>> type(myTuple)
<type 'int'>

# Valid one-item tuples
>>> myTuple = ('item',)
>>> type(myTuple)
<type 'tuple'>

>>> myTuple = (101,)
>>> type(myTuple)
<type 'tuple'>

   As mentioned earlier, another way to create a tuple is using tuple() built-in Python function. This
   function expects an iterable as an argument and returns a tuple of elements in that iterable.
# String as the iterable
>>> myTuple = tuple('CodeNinjaDotIn')
>>> myTuple
('C', 'o', 'd', 'e', 'N', 'i', 'n', 'j', 'a', 'D', 'o', 't', 'I', 'n')

# List as the iterable
>>> myTuple = tuple(['Code', 'Ninja', '.', 'In'])
>>> myTuple
('Code', 'Ninja', '.', 'In')

# Dictionary as the iterable
>>> myTuple = tuple({1 : 'One', 2 : 'Four', 3 : 'Nine'})
>>> myTuple
(1, 2, 3)

Tuple Indexing and Accessing Tuple Items
   Tuples being the Ordered collection of Python objects, any tuple item can be accessed using it's
   index in the tuple, the same way with which list items are accessed. As you might know by now that,
   indexing starts from zero, moving from left to right, in a tuple. So, the first tuple item can be
   accessed as tupleName[0], second tuple item as tupleName[1], and so on. As in lists, we have negative
   indexing in tuples, such that tuple items can be accessed in reverse order (right to left), using
   negative indices. Thus, last tuple item can be accessed as tupleName[-1] and last but one item as
   tupleName[-2]. This feature is very useful when we have very very long tuples. We also have Python
   built-in function len() to determine the length of a tuple.
# We create a mixed tuple
>>> myTuple = ({1 : 'One', 2 : 'Four'}, [3, 'Nine', 4, 'Sixteen'], (5, 'Twenty Five'), 6, 'Thirty Six')
>>> myTuple
({1: 'One', 2: 'Four'}, [3, 'Nine', 4, 'Sixteen'], (5, 'Twenty Five'), 6, 'Thirty Six')

# Accessing item at index '0' = 1st item
>>> myTuple[0]
{1: 'One', 2: 'Four'}

# Accessing item at index '2' = 3rd item
>>> myTuple[2]
(5, 'Twenty Five')

# Accessing item at index '1' of item at index '2'
>>> myTuple[2][1]
'Twenty Five'

# Accessing item at index '1' of item at index '2'
>>> myTuple[0][1]
'One'

# Accessing item at index '-1' = Last item
>>> myTuple[-1]
'Thirty Six'

# Last item is a String - Let's slice it
>>> myTuple[-1][-3:]
'Six'

# Negative indexing - another example
>>> myTuple[-3]
(5, 'Twenty Five')

# Some complex slicing
>>> myTuple[-3][1][-4:]
'Five'

# Size of the tuple using 'len()' function
>>> len(myTuple)
5

Concatenation and Repetition
   Like strings and lists, we can concatenate two or more tuples, using + operator, to produce an
   another tuple type. Needless to mention here that, the two objects we are concatenating need to be of
   same type, or TypeError will be displayed.
>>> myTuple1 = (1, 2, 3, 4)
>>> myTuple2 = ('One', 'Four', 'Nine', 'Sixteen')
>>> myTuple3 = (5, 'Twenty Five')

>>> myTuple1 + myTuple2 + myTuple3
(1, 2, 3, 4, 'One', 'Four', 'Nine', 'Sixteen', 5, 'Twenty Five')
>>> type(myTuple1 + myTuple2 + myTuple3)
<type 'tuple'>

   We have another operator * with which we can repeat an instance of a Python tuple, to produce a tuple
   of repeated sequence of tuple items. So, in order to create a tuple from repetition of another tuple,
   we can use the syntax tuple_name * N, where N is the number of times the sequence has to be repeated.
>>> (1, 'Two', 3, 'Four') * 4
(1, 'Two', 3, 'Four', 1, 'Two', 3, 'Four', 1, 'Two', 3, 'Four', 1, 'Two', 3, 'Four')

>>> myTuple = (1, 'Two', 3, 'Four')
>>> myTuple * 4
(1, 'Two', 3, 'Four', 1, 'Two', 3, 'Four', 1, 'Two', 3, 'Four', 1, 'Two', 3, 'Four')
>>> type(myTuple * 4)
<type 'tuple'>

Slicing
   With Slicing, we can cut-out a part of tuple and process it. Similar to slicing in strings and lists,
   we need to mention here following offsets- START indicating where should the slicing start from and
   END indicating where should slicing stop at (this won't include the element at index END). The
   default value of START is '0', while the default value of END is the index of last item of the tuple.
   When it comes to slicing, there is another optional parameter STEP, which will get us every STEPth
   element (i.e. skipping STEP-1 elements), starting from element at the index START till but not
   including element at index END. The default value of this parameter is '1'. So, the syntax used for
   slicing a tuple can be put as - tuple_name[START : END : STEP]
>>> myTuple = tuple(range(10))
>>> myTuple
(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

# Tuple slice starting from the item at index '3' till last item
>>> myTuple[3:]
(3, 4, 5, 6, 7, 8, 9)

# Tuple slice starting from beginning till but not including item at index '8'
>>> myTuple[:8]
(0, 1, 2, 3, 4, 5, 6, 7)

# Tuple slice starting from item at index '3' till but not including item at index '8'
>>> myTuple[3:8]
(3, 4, 5, 6, 7)

# A complete slice
>>> myTuple[:]
(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

# A tuple slice with step 2
>>> myTuple[3:8:2]
(3, 5, 7)

# Tuple reversal using STEP = -1
>>> myTuple[::-1]
(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)

# A reversed tuple containing every other item
>>> myTuple[::-2]
(9, 7, 5, 3, 1)

Tuples are not 'Mutable'
   Till now, we have studied different operations associated with Python tuples, but never tried to
   modify one. Let us try to add or modify the value of a tuple item, to check whether we are allowed to
   do so.
>>> myTuple = tuple(range(6))
>>> myTuple
(0, 1, 2, 3, 4, 5)

# Modifying a Tuple item
>>> myTuple[3] = 'Three'
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment

# Adding an item to a tuple
>>> myTuple[7] = 'Six'
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment

# Deleting a tuple item
>>> del myTuple[3]
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'tuple' object doesn't support item deletion

   No! We are not allowed to change the tuple items. So, Tuples are immutable Python objects.
   With this, we have come to an end of this article. In this article, we have had a brief introduction
   to Python tuples and studied different operations we can perform on them. In the next article, we
   would be learning the methods associated with Python tuples. Please share your views and opinions in
   the comment section below and stay tuned for more exciting articles. Thank you.

   
---
filename: /c/Users/gregor.redelonghi/Dropbox/ODPRTO/_PYTHON/__insert_python-yourownlinux_NEW-multif_20161118.txt
http://www.yourownlinux.com/2016/11/python-tuple-methods-count-index.html

Python Tuple Methods

   Posted on November 13, 2016 by Mandar Shinde

   Python Tuple Methods - Hello readers! This is the 13th article of our tutorial series on Python -
   Python on Terminal, and we are going to learn about Tuple methods in this one. In the last article on
   [18]Python Tuple, we have learned what tuples are, what properties they have and what operations we
   can perform on them. This article is all about the methods related to Python tuples, how they are
   used and their examples.
   [19]python-tuple-methods
   As usual, we try to know what all possible methods we can call on a tuple. For that, we create a
   tuple and provide it as an argument to Python built-in dir() function. For those, who do not know
   about dir() function - it accepts an argument (a Python object) and returns a list of all the methods
   associated with that Python object. Here, we will provide a Python tuple, so we will get a list of
   all the methods associated with any Python tuple. Let's check this now.
>>> myTuple = (1, 4, 9, 16, 25)
>>> dir(myTuple)
['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getatt
ribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init__', '__iter__', '__l
e__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul_
_', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index']

   We can see some methods with names in the form __methodName__, which are called as Magic methods.
   These methods are user by Python internally. For example, when we use Python built-in len() function
   to get length of a tuple, Python internally uses __len__ magic method. For now, we keep them aside
   and focus on rest of the methods. And, there are only two of them - count() and index(). Both the
   methods are very simple, let's study them one-by-one.

1. count() Method :
   This methods accepts a mandatory argument, say item, and returns the number for which the item item
   appears in the tuple on which this method is called. The syntax to use this method is -
   tuple_name.count(item).
   Example:
>>> myTuple = (1, 4, 9, 'One', 4, 'Nine', 1, 'Four', 'Nine', 1)
>>> myTuple.count('Nine')
2
>>> myTuple.count(1)
3
>>> myTuple.count(4)
2
>>> myTuple.count('One')
1

2. index() Method :
   Like previous method, this method also accepts a mandatory argument, say item, and returns the index
   of the item item in the tuple. If item is occurs in the tuple multiple times, index of the first
   occurrence is returned. The syntax to use this method is - tuple_name.index(item).
>>> myTuple = (1, 4, 9, 'One', 4, 'Nine', 1, 'Four', 'Nine', 1)
>>> myTuple
(1, 4, 9, 'One', 4, 'Nine', 1, 'Four', 'Nine', 1)
>>> myTuple.index('Four')
7
>>> myTuple.index('One')
3

# Index of the repeated element
>>> myTuple.index(1)
0
>>> myTuple.index(4)
1

   Thus, we have come to an end of this article. There wasn't much to learn about Python tuple methods
   as there are only two, but it was essential to know about them. Anyways, please share your views and
   opinions in the comment section below and please stay tuned for some more articles on Python. Thank
   you for stopping by.


---
http://www.yourownlinux.com/2016/11/python-open-read-write-append-to-file.html

Python File Handling - Open, Read, Write and Append to file

   Posted on November 14, 2016 by Mandar Shinde

   Python file handling : Open, Read, Write and Append to file - Hello readers! This is the 14th article
   of our Python tutorial series and we will be having an introduction to Python Files and File objects
   in this article. So far, we have covered [18]Python Strings, [19]Python Lists, [20]Python
   Dictionaries and [21]Python Tuples in earlier articles. These data structures were mostly numbers,
   strings, sequences of Python objects or key-value pairs of Python objects. But, File object in Python
   is very different from them, as it is more related to file handling. So, the operations related to
   file objects are also different from other Python objects, same as the operations we do with files.
   When I mean to say a file, it is actually the file present on some filesystem in your computer. You
   can consider a file object as a gateway to the actual file, with which we can read/write/append data
   from/to that file. So, without much a do, we start our discussion on Python file objects straight
   away.
   [22]python-open-read-write-append-to-file
   As mentioned earlier, Python file objects are the connectors to the file on your machine. If we have
   to read data from file, write or append something to the file, we have to use these file objects.
   Needless to mention, like everything else in Python, file objects are also Python objects and they
   belong to type file or in other words, every file object is the instance of the class file. In order
   to create a file object, we have to use a Python built-in function open(). This function returns a
   file object, when provided with file name as the argument. It being an instance of file class, it has
   some methods associated with it, which we would cover later. For now, let us create our first file
   object. To do so, I would use the log file /var/log/messages and pass it as an argument to open()
   function as below:
>>> myFileObject = open('/var/log/messages')
>>> type(myFileObject)
<type 'file'>
>>> myFileObject
<open file '/var/log/messages', mode 'r' at 0x7f13121ee5d0>

   As you can see on the last line, when we type the name of file object, it provides us some useful
   information - the file name, the mode in which it is opened and the memory location of the file
   object. In above example, we have provided only a single argument to the open() function. But, in
   fact, it can accept up to three arguments - a file name, the mode and buffering, out of which only
   first two are more commonly used. Among these two arguments, former (file name) is mandatory and
   later (mode) is optional. The file name argument is the absolute or relative path of the file, if
   path is not provided, file will be created in present (or current) working directory. The mode
   attribute defines the mode in which the file has been opened. There are three modes in which a file
   can be opened - 'r' (Read mode), 'w' (Write mode) and 'a' (Append mode). Please note that, both these
   arguments to open() function are of 'str' type.
   The Read mode is the default mode and used when you just need to read the contents from a file.
   Opening a file in Write mode will create a new file (or if it's already there, it will overwrite it's
   contents) and start writing to it. When Append mode is used, file contents are preserved and data can
   be added to the end of the file contents. Lets not go to terminal and check how open() function
   works.
# Opening a file in 'Read' mode
>>> myFileObject = open('/var/log/messages', 'r')
>>> myFileObject
<open file '/var/log/messages', mode 'r' at 0x7f6bb84b85d0>

# 'Read' mode is the default mode
>>> myFileObject = open('/var/log/messages')
>>> myFileObject
<open file '/var/log/messages', mode 'r' at 0x7f6bb84b8660>

# Opening a file in 'Write' mode
>>> myFileObject = open('/root/myFile.txt', 'w')
>>> myFileObject
<open file '/root/myFile.txt', mode 'w' at 0x7f6bb84b85d0>

# Opening a file in 'Append' mode
>>> myFileObject = open('/root/myFile.txt', 'a')
>>> myFileObject
<open file '/root/myFile.txt', mode 'a' at 0x7f6bb84b8660>

   In above examples, we have just verified that the open() function actually creates the object we wish
   to create.We are now able to create a Python file object that can read from a file, write to a file
   or append to a file. But, we haven't done any I/O operation yet. For this, we must know about two
   important file methods - read() and write. Both of these methods are called on file objects.
   The read() method when called on a Python file object, reads the entire file and returns a string
   containing file contents. It does accept an optional parameter N, where N is the number of bytes or
   characters to be read from the file. While, write() method accepts a mandatory argument data of str
   type and writes that string to the file. We have to use write() method, when the file is opened in
   'w' mode or in 'a' mode. To demonstrate this, let's create a file object, write some data to it,
   append some more and read everything from the file.
# We write two lines to the file 'myFile.txt'
>>> myFileObject = open('/root/myFile.txt', 'w')
>>> myDataString = 'This is the 1st line.\n'
>>> myFileObject.write(myDataString)
>>> myFileObject.write('This is the 2nd one.\n')

# We verify the contents of the file using 'cat' command in Linux
$ cat /root/myFile.txt
This is the 1st line.
This is the 2nd one.

# We append two lines to the file
>>> myFileObject = open('/root/myFile.txt', 'a')
>>> myDataString = 'This is the 1st appended line.\n'
>>> myFileObject.write(myDataString)
>>> myFileObject.write('This is the 2nd appended line.\n')

# We verify the file contents using 'cat' command in Linux
$ cat /root/myFile.txt
This is the 1st line.
This is the 2nd one.
This is the 1st appended line.
This is the 2nd appended line.

>>> myFileObject = open('/root/myFile.txt', 'r')
>>> myFileData = myFileObject.read()
>>> print myFileData
This is the 1st line.
This is the 2nd one.
This is the 1st appended line.
This is the 2nd appended line.

# We use the syntax 'read(N)' to read first 'N' characters from the file
>>> myFileObject = open('/root/myFile.txt', 'r')
>>> myFileData1 = myFileObject.read(30)
>>> print myFileData1
This is the 1st line.
This is

   When we create a file object using open() function, Python reserves some system resources to store
   this object. In the earlier part of this article, I've defined file objects as the connectors to the
   files present on the filesystem of your computer. This means that, whenever we are done working on a
   file and corresponding file object, the connection must be closed, so that the resources consumed by
   the file object would be released. This process is done automatically when we come out of Python
   interpreter or our Python program exits. But, a good programmer will always do it manually and that
   can be done by calling close() method on the file object. It would free up all the resources reserved
   by the file object on which the method is called. It won't delete the file object myFileObject
   though, as we are just closing the connection, until it is deleted manually.
# We open a file for reading
>>> myFileObject = open('/root/myFile.txt', 'r')
>>> myFileObject
<open file '/root/myFile.txt', mode 'r' at 0x7f0d2e0855d0>
>>> # We perform some operations here...
...

# We close the file after performing some operations
>>> myFileObject.close()

# We try to perform read operation on a closed file
>>> myDataString = myFileObject.read()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: I/O operation on closed file

# File object is not deleted
>>> myFileObject
<closed file '/root/myFile.txt', mode 'r' at 0x7f0d2e0855d0>

   With this, we have come to an end of this article. In this article, we have had a brief introduction
   to Python file objects. We've learned to create file objects with Python built-in open() function.
   Along with that, we have come across some very useful methods, viz. read() and write(), that can be
   called on file objects to perform I/O operations on files. And at last, we've seen how close() method
   can be used to free up system resources. In the next article, we would be learning about some more
   file object methods. Please share your feedback in the comment section below and stay tuned. Thank
   you!


---
http://www.yourownlinux.com/2016/11/install-numpy-pandas-matplotlib-scipy-linux.html

Install NumPy, Pandas, Matplotlib and SciPy in Linux

   Posted on November 15, 2016 by Mandar Shinde

   NumPy, SciPy, Pandas and Matplotlib are the crucial packages required in scientific computing with
   Python. NumPy (or Numeric Python) is a library of mathematical functions that helps us solving
   problems related to matrices, N-dimensional arrays, Fourier series and linear algebra. SciPy is a
   library that provides tools useful in science, engineering and scientific computing. It also contains
   modules to solve problems on integration, interpolation, linear algebra, fast Fourier transform,
   digital signal and image processing. Matplotlib is the visualization package and plotting library
   that is used to create high quality plots, graphs, charts and histograms. In this article, we will be
   installing these tools on our CentOS system.
   [18]numpy-pandas-matplotlib-scipy-installation
   First of all, we need Python installed on our system, which I have covered in our article on
   [19]Python installation. Then we need to have pip, a package management tool with which we can
   install, uninstall and manage other packages written in Python, installed in our system.

1. pip Installation
   There are multiple ways to install pip in linux. I preferred to use get-pip.py script to install pip.
   First, we need to download the script from the source and run it using python as we would run a
   normal script. The command to download the get-pip.py script is -
   curl "https://bootstrap.pypa.io/get-pip.py" -o "get-pip.py"
   Now, lets proceed with the installation.
# Downloading 'get-pip.py' using 'curl' command
[root@LinuxBox ~]$ curl "https://bootstrap.pypa.io/get-pip.py" -o "get-pip.py"
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 1558k  100 1558k    0     0   483k      0  0:00:03  0:00:03 --:--:--  483k

# Installing 'pip' using 'get-pip.py'
[root@LinuxBox ~]$ python get-pip.py
Collecting pip
  Downloading pip-9.0.1-py2.py3-none-any.whl (1.3MB)
    100% |████████████████████████████████| 1.3MB 134kB/s
Collecting setuptools
  Downloading setuptools-28.8.0-py2.py3-none-any.whl (472kB)
    100% |████████████████████████████████| 481kB 454kB/s
Collecting wheel
  Downloading wheel-0.29.0-py2.py3-none-any.whl (66kB)
    100% |████████████████████████████████| 71kB 954kB/s
Installing collected packages: pip, setuptools, wheel
Successfully installed pip-9.0.1 setuptools-28.8.0 wheel-0.29.0

   Now, with pip, we can install other packages written in Python as - pip install <package_name>

2. Installing NumPy
   We need to run pip install numpy as below:
[root@LinuxBox ~]$ pip install numpy
Collecting numpy
  Downloading numpy-1.11.2-cp27-cp27mu-manylinux1_x86_64.whl (15.3MB)
    100% |████████████████████████████████| 15.3MB 8.6kB/s
Installing collected packages: numpy
Successfully installed numpy-1.11.2

   To verify successful installation of the package, we enter the Python terminal, import the module and
   check it's version as below:
>>> import numpy
>>> print numpy.__version__
1.11.2

   We will follow the same procedure to install other packages - pandas, matplotlib and scipy.
   Alternately, you can mention all four packages in one command to save your time and efforts as - pip
   install numpy pandas matplotlib scipy

3. Installing Pandas
[root@LinuxBox ~]$ pip install pandas
Collecting pandas
  Downloading pandas-0.19.1-cp27-cp27mu-manylinux1_x86_64.whl (16.7MB)
    100% |████████████████████████████████| 16.7MB 17kB/s
Requirement already satisfied: numpy>=1.7.0 in /usr/lib64/python2.7/site-packages (from pandas)
Collecting python-dateutil (from pandas)
  Downloading python_dateutil-2.6.0-py2.py3-none-any.whl (194kB)
    100% |████████████████████████████████| 194kB 671kB/s
Collecting pytz>=2011k (from pandas)
  Downloading pytz-2016.7-py2.py3-none-any.whl (480kB)
    100% |████████████████████████████████| 481kB 646kB/s
Collecting six>=1.5 (from python-dateutil->pandas)
  Downloading six-1.10.0-py2.py3-none-any.whl
Installing collected packages: six, python-dateutil, pytz, pandas
Successfully installed pandas-0.19.1 python-dateutil-2.6.0 pytz-2016.7 six-1.10.0

>>> import pandas
>>> print pandas.__version__
0.19.1

4. Installing Matplotlib
[root@LinuxBox ~]$ pip install matplotlib
Collecting matplotlib
  Downloading matplotlib-1.5.3-cp27-cp27mu-manylinux1_x86_64.whl (13.7MB)
    100% |████████████████████████████████| 13.7MB 30kB/s
Requirement already satisfied: numpy>=1.6 in /usr/lib64/python2.7/site-packages (from matplotlib)
Requirement already satisfied: python-dateutil in /usr/lib/python2.7/site-packages (from matplotlib)
Collecting cycler (from matplotlib)
  Downloading cycler-0.10.0-py2.py3-none-any.whl
Requirement already satisfied: pytz in /usr/lib/python2.7/site-packages (from matplotlib)
Collecting pyparsing!=2.0.0,!=2.0.4,!=2.1.2,>=1.5.6 (from matplotlib)
  Downloading pyparsing-2.1.10-py2.py3-none-any.whl (56kB)
    100% |████████████████████████████████| 61kB 1.6MB/s
Requirement already satisfied: six>=1.5 in /usr/lib/python2.7/site-packages (from python-dateutil->matplotlib)
Installing collected packages: cycler, pyparsing, matplotlib
Successfully installed cycler-0.10.0 matplotlib-1.5.3 pyparsing-2.1.10

>>> import matplotlib
>>> print matplotlib.__version__
1.5.3

5. Installing SciPy
[root@LinuxBox ~]$ pip install scipy
Collecting scipy
  Downloading scipy-0.18.1-cp27-cp27mu-manylinux1_x86_64.whl (40.3MB)
    100% |████████████████████████████████| 40.3MB 6.3kB/s
Installing collected packages: scipy
Successfully installed scipy-0.18.1

>>> import scipy
>>> print scipy.__version__
0.18.1

   That's all. Thank you.

   
---
http://www.yourownlinux.com/2016/11/python-file-object-attributes-methods.html

Python File Object Attributes and Methods - readlines(), seek(), etc.

   Posted on November 21, 2016 by Mandar Shinde

   Python file object attributes and methods - This is the 15th article of our tutorial series on Python
   and it is all about most frequently used attributes and methods related to Python file objects. In
   the last article on [17]Python file objects, we've learned how file objects can be created with
   open() function and did basic operations on them with methods like read() and write(). In this
   article, we move a step further and know about useful attributes and methods associated with Python
   file objects.
   [18]python-file-object-attributes-and-methods
   To begin with, we create a file object using open() function and get a list of all possible methods
   that can be used with a file object, using Python built-in dir() function. As you might know by now
   that, the dir() function accepts a Python object as an argument and returns a list of attributes and
   methods related to them. Lets check this.
>>> myFileObject = open('/root/myFile.txt')
>>> dir(myFileObject)
['__class__', '__delattr__', '__doc__', '__enter__', '__exit__', '__format__', '__getattribute__', '__hash__',
 '__init__', '__iter__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '_
_str__', '__subclasshook__', 'close', 'closed', 'encoding', 'errors', 'fileno', 'flush', 'isatty', 'mode', 'na
me', 'newlines', 'next', 'read', 'readinto', 'readline', 'readlines', 'seek', 'softspace', 'tell', 'truncate',
 'write', 'writelines', 'xreadlines']

   In above output, we can see some attributes whose name starts and ends with double underscores in the
   form __attrName__, which are called as Magic attributes. These are used by Python internally and we
   do not discuss over them in this article. So, lets start our discussion on some more commonly used
   Python file object methods.

1. close() Method :
   As we observed in our last article, close() method will close the connection between a file and a
   file object, such that the file operations cannot be performed using a file object. It will also
   release the system resources consumed by the file object. But, the file object will still be present
   in the memory until it is deleted. The syntax to use this method is - file_object_name.close()
# We create a file object
>>> myFileObject = open('/root/myFile.txt')
>>> myFileObject
<open file '/root/myFile.txt', mode 'r' at 0x7f574e8e95d0>

# close() method is called on the file object
>>> myFileObject.close()

# We perform read() operation on it
>>> myFileObject.read()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: I/O operation on closed file

# File object still exists after closing the file
>>> myFileObject
<closed file '/root/myFile.txt', mode 'r' at 0x7f574e8e95d0>

2. closed Attribute :
   This attribute when qualified with a file object returns True if file state is closed, else False.
   This being the first time we are using an attribute, we must know how it is used. Attributes, just
   like methods, must be qualified with the object names. But, we don't use parenthesis while using an
   attribute. So, if the syntax for using a method is object_name.method_name(), then the syntax to use
   an attribute is simply object_name.attribute_name.
>>> myFileObject = open('/root/myFile.txt')
>>> myFileObject
<open file '/root/myFile.txt', mode 'r' at 0x7f574e8e9660>
>>> myFileObject.closed
False

>>> myFileObject.close()
>>> myFileObject
<closed file '/root/myFile.txt', mode 'r' at 0x7f574e8e9660>
>>> myFileObject.closed
True

3. mode Attribute :

   This attribute when used with a file object, returns the mode in which the file is opened.
>>> myFileObject = open('/root/myFile.txt', 'r')
>>> myFileObject.mode
'r'

>>> myFileObject = open('/root/myFile.txt', 'w')
>>> myFileObject.mode
'w'

>>> myFileObject = open('/root/myFile.txt', 'a')
>>> myFileObject.mode
'a'

4. name Attribute :
   This attribute, as the name suggests, returns the name of the file which the file object is linked
   to.
>>> myFileObject = open('/root/myFile.txt')
>>> myFileObject.name
'/root/myFile.txt'

5. next() Method :
   With this method, we can iterate over the lines in the file. This method when qualified with a file
   object, returns the next line. This means, when we call this method for the first time, it would
   return the first line. When last line is returned and next() method is called, it would raise
   StopIteration exception.
>>> myFileObject = open('/root/myFile.txt', 'r')
>>> line = myFileObject.next()
>>> print line
This is line no. 1.

>>> line = myFileObject.next()
>>> print line
This is line no. 2.

>>> line = myFileObject.next()
>>> print line
This is line no. 3.

>>> line = myFileObject.next()
>>> print line
This is line no. 4.

>>> line = myFileObject.next()
>>> print line
This is line no. 5.

# Last line has been printed and we now call next() method again
>>> line = myFileObject.next()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration

6. read() Method :
   We've already used this method in our last tutorial. This method when called on a file objects, all
   the file contents are returned as a string. It does accept an optional argument N which defines the
   number of bytes or characters to be read fro the file. So, the syntax for using this method becomes -
   file_object_name.read([N])
>>> myFileObject = open('/root/myFile.txt', 'r')
>>> fileData = myFileObject.read()
>>> print fileData
This is line no. 1.
This is line no. 2.
This is line no. 3.
This is line no. 4.
This is line no. 5.

>>> myFileObject = open('/root/myFile.txt', 'r')
>>> fileData = myFileObject.read(25)
>>> print fileData
This is line no. 1.
This

7. readline() Method :
   This method when called on a file object, reads a line from a file and returns it in a string format.
   Like read() method, it does accept an optional parameter N, where N is the number of characters to
   read from the file.
>>> myFileObject = open('/root/myFile.txt', 'r')
>>> line = myFileObject.readline()
>>> print line
This is line no. 1.

>>> line = myFileObject.readline()
>>> print line
This is line no. 2.

>>> line = myFileObject.readline()
>>> print line
This is line no. 3.

>>> line = myFileObject.readline(5)
>>> print line
This
>>> line = myFileObject.readline(12)
>>> print line
is line no.

8. readlines() Method :
   This method when called on a file object, returns a list in which each list item is a string and each
   string is a line from the file. So, we have entire file contents stored in a list, with each list
   item is a line from the file stored as a string.
>>> myFileObject = open('/root/myFile.txt')
>>> fileData = myFileObject.readlines()
>>> fileData
['This is line no. 1.\n', 'This is line no. 2.\n', 'This is line no. 3.\n', 'This is line no. 4.\n', 'This is
line no. 5.\n']

9. seek() Method :
   Whenever we create a file object for a file, suppose that, we have a pointer which keeps record of
   our current position in the opened file. For a newly created file object, its default value is '0'
   i.e. start of the file. With this method, we can move this pointer from one position to another
   within a file. This method accepts one mandatory argument offset which tells us that we need to move
   the pointer by these many places. It also accepts an optional argument which specifies the direction
   of movement of the pointer, for which valid values are '0', '1' and '2'. '0' is the default value and
   it specifies that the movement should be from absolute position i.e. from the beginning of the file.
   '1' indicates that the movement should from relative position i.e. from the current position. '2'
   signifies the movement to the offset with reference to the end of the file i.e. backward movement. To
   verify this, we should learn tell() method first.

10. tell() Method :
   As we already know that, our current position in the opened file is tracked by a pointer. With
   tell(), we can get to know about our current position in that opened file. We now have a look at some
   examples which will give us a clear view about seek() and tell() methods.
>>> myFileObject = open('/root/myFile.txt')

# Default position is '0'
>>> myFileObject.tell()
0

# Second argument defaults to '0'
>>> myFileObject.seek(128)
>>> myFileObject.tell()
128
>>> myFileObject.seek(256)
>>> myFileObject.tell()
256

# Moving 128 bytes from the beginning
>>> myFileObject.seek(128, 0)
>>> myFileObject.tell()
128

# Moving 128 bytes from current position
>>> myFileObject.seek(128, 1)
>>> myFileObject.tell()
256

# Moving 64 bytes backward from the end of the file
>>> myFileObject.seek(-64, 2)
>>> myFileObject.tell()
36

# Reading the file from this position
>>> myFileObject.read()
' 2.\nThis is line no. 3.\nThis is line no. 4.\nThis is line no. 5.\n'

11. truncate() Method :
   This method when called on a file object, it truncates (flushes) the data from the file. Remember,
   when we open a file in 'w', it flushes all the data by default. So, we can use read-write mode here
   to bypass default truncating process. Till this point, we have used 'r', 'w' and 'a' modes. We now
   introduce to some new modes that can be used in open() function.
     * 'r+' - It does not truncate the file completely (as in case of 'w' mode), but opens the file in
       'read-write' mode, with the current position '0' in the opened file.
     * 'w+' - File is opened in 'read-write' mode and truncated.
     * 'a+' - File is opened in 'read-write' mode, file is not truncated, with current position at the
       end in the opened file.

# 'r+' mode is 'read-write' mode
>>> myFileObject = open('/root/myFile.txt', 'r+')
>>> myFileObject
<open file '/root/myFile.txt', mode 'r+' at 0x7ff29220a5d0>
>>> myFileObject.truncate()
>>> myFileObject.close()

# We verify this with 'cat' command in Linux and we observe an empty file
$ cat myFile.txt
$

12. write() Method :
   This method accepts data in string format as an argument and writes the data to a file, if it is
   opened in 'w' mode, or appends the data to the file, if it is opened in 'a' mode.
>>> myFileObject = open('/root/myFile.txt', 'w')
>>> data = 'This is line no. 1.\n'
>>> myFileObject.write(data)
>>> data = 'This is line no. 2.\n'
>>> myFileObject.write(data)
>>> data = 'This is line no. 3.\n'
>>> myFileObject.write(data)
>>> data = 'This is line no. 4.\n'
>>> myFileObject.write(data)
>>> data = 'This is line no. 5.\n'
>>> myFileObject.write(data)
>>> myFileObject.close()
>>> myFileObject = open('/root/myFile.txt', 'r')

>>> myFileObject.read()
'This is line no. 1.\nThis is line no. 2.\nThis is line no. 3.\nThis is line no. 4.\nThis is line no. 5.\n'

13. writelines() Method :
   This method accepts an iterable wherein an item is a str type, typically a list of strings or a tuple
   of strings, and writes the data into the file.
>>> myFileObject = open('/root/myFile.txt', 'w')
>>> myDataList = ['This is line no. 1.\n', 'This is line no. 2.\n', 'This is line no. 3.\n', 'This is line no.
 4.\n', 'This is line no. 5.\n']
>>> myDataTuple = ('This is line no. 6.\n', 'This is line no. 7.\n', 'This is line no. 8.\n', 'This is line no
. 9.\n', 'This is line no. 10.\n')
>>> myFileObject.writelines(myDataList)
>>> myFileObject.writelines(myDataTuple)
>>> myFileObject.close()
>>> myFileObject = open('/root/myFile.txt', 'r')

>>> myFileObject.read()
'This is line no. 1.\nThis is line no. 2.\nThis is line no. 3.\nThis is line no. 4.\nThis is line no. 5.\nThis
 is line no. 6.\nThis is line no. 7.\nThis is line no. 8.\nThis is line no. 9.\nThis is line no. 10.\n'

   With this, we have come to an end of this discussion. In this article, we've learned some important
   and most commonly used file object attributes and methods, with their examples. In the next article,
   we will be learning about another Python data structure - Sets. Please post your views and feedback
   about this article in the comment section below and stay tuned for more articles on Python. Thank
   you.

   
---
http://www.yourownlinux.com/2016/11/python-set-frozenset-operations-union-intersection-symmetric-difference.html

Python Set & Frozenset - Union, Intersection, Difference, Symmetric Difference
   Posted on November 22, 2016 by Mandar Shinde

   Python Set & Frozenset - This is the 16th article of our tutorial series on Python and we are going
   to have an introduction to another Python data structure - Sets and Frozensets. Like Python Strings,
   Lists and Tuples, they are also sequences of Python objects, so having some knowledge of Python
   Strings, Lists and Tuples will be handy. I recommend you to have a look over our articles on
   [18]Python Strings, [19]Python Lists and [20]Python Tuples, as it would be very useful when we study
   Python Sets, their properties and basic operations on them. In this article, we will also cover
   similarities and dissimilarities between Python Sets and other sequences mentioned above. Let's go!
   [21]python-set-frozenset
   As already mentioned, Python sets are similar to Python Strings, Lists and Tuples, as they are
   sequence of Python objects. But, unlike all of them, Python sets are Unordered collections, just like
   [22]Python Dictionaries, as elements in Python sets are not associated with any positional parameters
   which we call as offset or index. Like Python Lists and unlike Python Strings and Tuples, Python sets
   are mutable, which means that, we can add, remove or modify the contents of a Python set. Unlike
   other Python data structures, Python sets have a unique and important property - every element in a
   Python set is unique across the sequence. To rephrase this, every element in a Python set can have
   only one occurrence in that particular set, no multiple occurrences are allowed. Also, another very
   important thing is that, every element in the Python set is a Python immutable object - which means
   it may be a str type or an int type, but it cannot be a list type. Too much information..? Don't
   worry, we will revisit all these properties as we proceed in subsequent portion of this article. For
   that, we need a Python set and let's create one.

Creating Python Sets
   Like we have str(), list(), dict() and tuple() functions, we also have a Python built-in set()
   function for creating a Python set. All we need to do is that, just provide set() function with a
   Python iterable as an argument, to get a set of unique elements in that iterable. So, we can create a
   Python set using a String, a List and a Tuple. Another way of creating a Python set is to use curly
   braces ({ }. We have used curly braces in Python dictionaries, but a dictionary is a collection of
   key : value pairs of Python objects, while sets being an unordered sequence. So, we just need to put
   in some immutable Python objects within curly braces to create a Python set. Lets learn how a set is
   created using set() function and { }.
# Creating a Set using a Python String
>>> mySet = set('CodeNinjaDotIn')
>>> print mySet
set(['a', 'C', 'e', 'd', 'i', 'j', 'o', 'N', 'I', 't', 'n', 'D'])

# Any Python set is of 'set' type or an instance of class 'set'
>>> type(mySet)
<type 'set'>

# Creating a Set using a Python List
>>> mySet = set(['Orange', 'Mango', 'Pinapple', 101, 777])
>>> print mySet
set(['Orange', 777, 'Mango', 101, 'Pinapple'])

# A Set always have unique elements from an iterable
>>> mySet = set(['Orange', 'Mango', 'Pinapple', 101, 777, 'Mango'])
>>> print mySet
set(['Orange', 777, 'Mango', 101, 'Pinapple'])

# Tuple as an iterable to create a Set
>>> mySet = set(('One', 2, 'Three', 4, 'One', 'Three'))
>>> print mySet
set([2, 4, 'Three', 'One'])

   In above example, it is very much clear that, every set belongs to type set or in other words, it is
   an instance of set class. Another observation is that, we have used an iterable - a String, a List
   and a Tuple, to create a Python set, and every item from that iterable is an immutable Python object.
   For example, the alphabets 'C', 'N', etc. are immutable Python objects, while every item in the list
   and the tuple, is either a string or an integer, again immutable objects. To verify this statement,
   we try to create a Python set using an iterable containing a mutable Python object - a List may be.
# [2, 3, 4] in the list below, is a mutable object
>>> mySet = set(['One', [2, 3, 4], 'Five'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'

   No, we cannot. Also, as mentioned earlier, if the iterable contains multiple occurrences of any
   items, a set created using that iterable will contain only one occurrence of that item. Thus, it is
   guaranteed that, every element in the list is unique across the set. One more thing, all the elements
   in the set may not occur in the same order as in the iterable provided, as a set is an Unordered
   collection. Let us now create s Python set using curly braces.
# Creating a Python Set using '{ }'
>>> mySet = {'Apple', 'Banana', 'Mango', 'Orange', 'Banana', 'Apple'}
>>> print mySet
set(['Orange', 'Mango', 'Apple', 'Banana'])
>>> type(mySet)
<type 'set'>

# We cannot use a mutable object ['Banana', 'Apple'] to create a Set
>>> mySet = {'Apple', 'Banana', 'Mango', 'Orange', ['Banana', 'Apple']}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'

   So far, we tried to create a set with immutable objects, like integers and strings, in an iterable.
   We couldn't create one with a list, a mutable object, as a set item. Can we create a set with a
   tuple, an immutable object, as an item in the set? Lets try this.
# Using '{ }' and tuple as an item
>>> mySet = {'Apple', 'Banana', 'Mango', 'Orange', ('Banana', 'Apple')}
>>> mySet
set(['Orange', 'Mango', ('Banana', 'Apple'), 'Apple', 'Banana'])

# With 'set()' function and tuple as an item
>>> mySet = set(['Apple', 'Banana', 'Mango', 'Orange', ('Banana', 'Apple')])
>>> mySet
set(['Orange', 'Mango', ('Banana', 'Apple'), 'Apple', 'Banana'])

   We could create it. Tuples being the immutable objects, can be used as set items.

Sets are Mutable!
   Whenever properties of various Python data structures are discussed, we have always talked about
   mutability of Python objects. Here, in case of sets, we will also discuss whether they are mutable or
   not. As the heading of the section tells, they are mutable. To verify the same, we make use of add()
   method of Python sets. This method accepts a Python object, obviously an immutable one, and adds it
   to the set. Lets check adding 'Pineapple' to our set of fruits.
>>> mySet = {'Apple', 'Banana', 'Mango', 'Orange'}
>>> mySet
set(['Orange', 'Mango', 'Banana', 'Apple'])
>>> mySet.add('Pineapple')
>>> mySet
set(['Orange', 'Mango', 'Banana', 'Pineapple', 'Apple'])

# Lists? No place for them
>>> mySet.add(['Guava', 'Watermelon'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'

   So, Pythons sets are mutable objects which contain immutable Python objects. Having discussed and
   proven mutability of sets, its right time to introduce Frozensets to you.

Frozensets
   Well, frozensets are exactly like sets, but they are different that them, as far as mutability is
   concerned - Frozensets are immutable. Before we check this, we need to create a frozenset using
   Python built-in frozenset() function, which works just like set() function as learned earlier, but
   returns a frozenset type.
>>> mySet = frozenset(['Apple', 'Banana', 'Mango', 'Orange', 'Apple'])
>>> mySet
frozenset(['Orange', 'Mango', 'Apple', 'Banana'])
>>> type(mySet)
<type 'frozenset'>

# Adding an element to a frozenset
>>> mySet.add('Potato')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'frozenset' object has no attribute 'add'

   Very simple! Now, we move ahead to know about some more common terms related to sets. These terms are
   the same as the ones which we studied in Set theory in Mathematics. These are - Union, Intersection,
   Difference, Symmetric difference and Subsets. Lets learn each of these in the following sections.

Union of Sets
   [23]union-of-sets
   Union of two sets A and B is another set that contains all the elements in sets A and B. In Python,
   Union operation can be performed on two Python sets using the operator | or by using the method
   union(). So, 'A Union B' can be done using the syntax A | B or A.union(B).
>>> A = {1, 2, 3, 4, 5, 6, 7}
>>> B = {5, 6, 7, 8, 9, 10}
>>> A | B
set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
>>> A.union(B)
set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

Intersection of Sets
   [24][A-Intersection-B.JPG]
   Intersection of two sets A and B is another set of elements those are present in both sets A and B
   (common to both of them). In Python, Intersection operation can be performed on two Python sets using
   the operator & or by using intersection() method. So, 'A Intersection B' can be done using the syntax
   A & B or A.intersection(B).
>>> A = {1, 2, 3, 4, 5, 6, 7}
>>> B = {5, 6, 7, 8, 9, 10}
>>> A & B
set([5, 6, 7])
>>> A.intersection(B)
set([5, 6, 7])

Difference of Sets
   [25][Difference.JPG]
   Difference of two sets A and B is a set of elements those are present in one set, but not in other.
   In Python, Difference of two Python sets can be obtained using the operator - or by using
   difference() method. So, 'A - B' is the set of elements which are present in A but not in B and this
   can be obtained using the syntax A - B or A.difference(B).
>>> A = {1, 2, 3, 4, 5, 6, 7}
>>> B = {5, 6, 7, 8, 9, 10}
>>> A - B
set([1, 2, 3, 4])
>>> A.difference(B)
set([1, 2, 3, 4])

Symmetric Difference of Sets
   [26][Symmetric-Difference.JPG]
   Symmetric difference of the sets is the set of elements those are not common to both the sets. In
   Python, we have the operator ^ which gives us the symmetric difference of two sets. We also have a
   method symmetric_difference() that would also give identical results. So, the syntax for this
   operation becomes A ^ B or A.symmetric_difference(B).
>>> A = {1, 2, 3, 4, 5, 6, 7}
>>> B = {5, 6, 7, 8, 9, 10}
>>> A ^ B
set([1, 2, 3, 4, 8, 9, 10])
>>> A.symmetric_difference(B)
set([1, 2, 3, 4, 8, 9, 10])

Subset and Superset of a Set
   [27][Subset.JPG]
   A set B is called a subset of set A if and only if all the elements in set B are present in set A. We
   can check if a set is a subset of another set using issubset() method. On the other hand, we can also
   check if a set is a superset of another set using superset(). Both the methods will return True if
   the condition follows, else False.
>>> A = {1, 2, 3, 4, 5, 6, 7}
>>> B = {5, 6, 7, 8, 9, 10}

>>> A.issubset(B)
False
>>> B.issubset(A)
False

>>> A = {5, 6, 7}
>>> B = {5, 6, 7, 8, 9, 10}
>>> A.issubset(B)
True
>>> B.issubset(A)
False

>>> A.issuperset(B)
False
>>> B.issuperset(A)
True

   With this, we end our discussion on Python sets. In this article, I've tried to explain Python sets
   and their properties in comparison to other Python data structures, so as to have an easier
   understanding of the sets and revision of other data structures. Meanwhile, we had a short
   introduction to Frozensets and learned how it is different from Python sets. We have also learned
   about basic operations those can be performed on Python sets, along with their examples, which also
   hold good for Python frozensets. In the next article, we will cover various methods associated with
   Python sets and frozensets. Please share your feedback and opinions in the comment section below and
   stay tuned. Thank you.

---
http://www.yourownlinux.com/2016/11/python-set-frozenset-methods.html

Python Set and Frozenset Methods

   Posted on November 29, 2016 by Mandar Shinde

   Python Set and Frozenset Methods - In this article we would learn methods related to Python Sets.
   Please take a look at our article on [18]Python Sets and Frozensets, in case you missed it. We have
   already learned some important set methods in the last article, viz. union(), intersection(),
   difference() and symmetric_difference(), with which we performed basic operations on the sets. In
   this article, we are going to learn some more methods, their syntax and their examples.
   [19]python-set-frozenset-methods
   To begin with we need to create a Python set, either using set() function or using { }. With the use
   of Python built-in function dir(), we can have a list of all the attributes associated with a Python
   set. For those who do not know about dir() function, it is a function that accepts a Python object as
   an argument and returns a list type of all the attributes associated with that object. Lets check
   what all attributes are there with Python sets.
>>> mySet = {'Apple', 'Banana', 'Mango', 'Orange'}
>>> dir(mySet)
['__and__', '__class__', '__cmp__', '__contains__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__'
, '__getattribute__', '__gt__', '__hash__', '__iand__', '__init__', '__ior__', '__isub__', '__iter__', '__ixor
__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__or__', '__rand__', '__reduce__', '__reduce_ex__',
'__repr__', '__ror__', '__rsub__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclassh
ook__', '__xor__', 'add', 'clear', 'copy', 'difference', 'difference_update', 'discard', 'intersection', 'inte
rsection_update', 'isdisjoint', 'issubset', 'issuperset', 'pop', 'remove', 'symmetric_difference', 'symmetric_
difference_update', 'union', 'update']

   Above is the list of attributes among which some attributes have names starting and ending with
   double underscores. These attributes are known as Magic Attributes and these are used by Python
   internally. We do not discuss these attributes for now and see other ones. Please note that, Python
   frozensets do not have all the methods mentioned above associated with them, they have only a few of
   them which are - copy(), difference(), intersection(), isdisjoint(), issubset(), issuperset(),
   symmetric_difference(), union(), which work in exactly the same way they work in case of Python sets.
   So, we concentrate more on Set methods here and learn them all one-by-one.

1. add() Method :
   We have seen and used this method in the last article while knowing whether Python sets are mutable
   or not. As the name of the method suggests, it adds elements to a Python set. A Python set being a
   collection of unique objects, if the object to be added is already present in the set, it won't get
   added to the set. The syntax to use this method is - setName.add(item), where item, as studied in
   last article, must be a immutable Python object.
>>> mySet = {'Apple', 'Banana', 'Mango', 'Orange'}
>>> mySet.add('Watermelon')
>>> mySet
set(['Orange', 'Mango', 'Watermelon', 'Banana', 'Apple'])

>>> mySet.add('Banana')
>>> mySet
set(['Orange', 'Mango', 'Watermelon', 'Banana', 'Apple'])

2. clear() Method :
   The name of this method is also self-explanatory. This method when called on a set, clears all the
   items to give us an empty set.
>>> mySet = {'Apple', 'Banana', 'Mango', 'Orange'}
>>> mySet
set(['Orange', 'Mango', 'Banana', 'Apple'])
>>> mySet.clear()
>>> mySet
set([])

3. copy() Method :
   This method when called on a set, returns a shallow copy of that set. This method can be used to
   create a copy of the set.
>>> mySet = {'Apple', 'Banana', 'Mango', 'Orange'}
>>> mySet.copy()
set(['Orange', 'Mango', 'Banana', 'Apple'])
>>> anotherSet = mySet.copy()
>>> mySet
set(['Orange', 'Mango', 'Banana', 'Apple'])
>>> anotherSet
set(['Orange', 'Mango', 'Banana', 'Apple'])

4. difference() Method :
   This method when called on a set A, accepts an argument, another set B, and returns a set which
   contains those elements which are present in A but not present B. When no argument is provided, an
   empty set is considered as an argument and the set A is returned.
>>> A = {1, 2, 3, 4, 5}
>>> B = {3, 4, 5, 6, 7, 8}

# Items in A but not in B
>>> A.difference(B)
set([1, 2])

# Items in B but not in A
>>> B.difference(A)
set([8, 6, 7])

# No argument provided -> Original set
>>> A.difference()
set([1, 2, 3, 4, 5])

5. difference_update() Method :
   Well, it might be very interesting to know about this method. When we use the difference() method,
   contents of the sets A and B are not altered. But, when we use difference_update() method, contents
   of set A are changed, considering that, method is called on set A. So, the set A will contain the
   result, which is the difference between set A and B. In mathematical term, set A would be - A = A -
   B.
>>> A = {1, 2, 3, 4, 5}
>>> B = {3, 4, 5, 6, 7, 8}
>>> A.difference_update(B)
>>> A
set([1, 2])
>>> B
set([3, 4, 5, 6, 7, 8])

6. discard() Method :
   This method accepts an argument item and removes it from the set if present, otherwise it does
   nothing.
>>> A = {1, 2, 3, 4, 5}
>>> A.discard(3)
>>> A
set([1, 2, 4, 5])

>>> A.discard(6)
>>> A
set([1, 2, 4, 5])

7. intersection() Method :
   As we've already seen in introductory article on Python sets and frozensets, Intersection of two sets
   is the set of common elements present in both the sets. In order to get intersection of two sets A
   and B, we can use intersection() method as A.intersection(B) or B.intersection(A).
>>> A = {1, 2, 3, 4, 5}
>>> B = {3, 4, 5, 6, 7, 8}
>>> A.intersection(B)
set([3, 4, 5])
>>> B.intersection(A)
set([3, 4, 5])

8. intersection_update() Method :
   This method when called on some set A with set B as an argument, the result is the intersection of
   both the sets and result in saved in the set on which method is called i.e. set A. Mathematically we
   can put this as : A = A & B, where & stands for Intersection.
# Calling 'intersection_update()' method on set 'A', will save result in set 'A'
>>> A = {1, 2, 3, 4, 5}
>>> B = {3, 4, 5, 6, 7, 8}
>>> A.intersection_update(B)
>>> A
set([3, 4, 5])
>>> B
set([3, 4, 5, 6, 7, 8])

# Calling 'intersection_update()' method on set 'B', will save result in set 'B'
>>> A = {1, 2, 3, 4, 5}
>>> B = {3, 4, 5, 6, 7, 8}
>>> B.intersection_update(A)
>>> A
set([1, 2, 3, 4, 5])
>>> B
set([3, 4, 5])

9. isdisjoint() Method :
   In set theory, a set A is a 'disjoint set' of another set B, if there are no common elements in them
   i.e. their intersection is an empty set. With this method, we can check if a set is a disjoint set of
   any other set. It will return True if condition is true, otherwise False.
>>> A = {1, 2, 3, 4, 5}
>>> B = {3, 4, 5, 6, 7, 8}
>>> A.isdisjoint(B)
False

>>> A = {1, 2}
>>> B = {3, 4, 5, 6, 7, 8}
>>> A.isdisjoint(B)
True
>>> B.isdisjoint(A)
True

10. issubset() Method :
   In set theory, when all the elements in some set A are present in some other set B, we can say that
   set A is the subset of set B. With this method, we can check whether a set is a subset of any other
   set. It will return a boolean type True if the condition is true, else False.
>>> A = {1, 2, 3, 4, 5}
>>> B = {3, 4, 5, 6, 7, 8}
>>> A.issubset(B)
False
>>> B.issubset(A)
False

>>> A = {3, 4, 5}
>>> B = {3, 4, 5, 6, 7, 8}
>>> A.issubset(B)
True
>>> B.issubset(A)
False

11. issuperset() Method :
   In set theory, when all the elements in some set A are present in some other set B, we can say that
   set B is the superset of set A. With this method, we can check whether a set is a superset of any
   other set. It will return a bool type True if the condition is true, else False.
>>> A = {1, 2, 3, 4, 5}
>>> B = {3, 4, 5, 6, 7, 8}
>>> A.issuperset(B)
False
>>> B.issuperset(A)
False

>>> A = {3, 4, 5}
>>> B = {3, 4, 5, 6, 7, 8}
>>> A.issuperset(B)
False
>>> B.issuperset(A)
True

12. pop() Method :
   We have studied pop() method in case of Python lists and it would take an index as an argument and
   return the element at that index from the list, also removing that element from the list. Here,
   Python sets are not ordered collection of data, thus we do not have indices associated with set
   elements, but we have pop() method. So, in case of sets, pop() method will return a random (or
   arbitrary) element from the set, also removing it from the set. It the set is empty, it will throw a
   KeyError exception.
>>> A = {1, 2, 3, 4, 5}
>>> A.pop()
1
>>> A
set([2, 3, 4, 5])
>>> A.pop()
2
>>> A
set([3, 4, 5])
>>> A.pop()
3
>>> A
set([4, 5])
>>> A.pop()
4
>>> A
set([5])
>>> A.pop()
5
>>> A
set([])
>>> A.pop()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'pop from an empty set'

13. remove() Method :
   With pop(), an arbitrary element is removed from the set, while with remove() method, we can remove a
   particular set item, by providing the item to be removed as an argument to the remove() method.
   Please note that, the item will only be removed if it is present in the set, otherwise it will raise
   a KeyError exception.
>>> A = {1, 2, 3, 4, 5}
>>> A.remove(3)
>>> A
set([1, 2, 4, 5])
>>> A.remove(4)
>>> A
set([1, 2, 5])
>>> A.remove(7)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 7

14. remove() Method :
   With pop(), an arbitrary element is removed from the set, while with remove() method, we can remove a
   particular set item, by providing the item to be removed as an argument to the remove() method.
   Please note that, the item will only be removed if it is present in the set, otherwise it will raise
   a KeyError exception.
>>> A = {1, 2, 3, 4, 5}
>>> A.remove(3)
>>> A
set([1, 2, 4, 5])
>>> A.remove(4)
>>> A
set([1, 2, 5])
>>> A.remove(7)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 7

15. symmetric_difference() Method :
   In our previous article on [20]Python sets and frozensets, we've learned about Symmetric Difference
   of two sets. It is the set of elements which are not common to both the sets, exactly opposite to
   Intersection. When we call this method on a set A and provide set B as an argument, it will return a
   set of elements which are not common to both sets A and B. We represent this operation using ^ symbol
   as A ^ B.
>>> A = {1, 2, 3, 4, 5}
>>> B = {3, 4, 5, 6, 7, 8}
>>> A.symmetric_difference(B)
set([1, 2, 6, 7, 8])
>>> B.symmetric_difference(A)
set([1, 2, 6, 7, 8])

16. symmetric_difference_update() Method :
   When this method is called on a set A with another set B as an argument, the symmetric difference of
   both the sets is calculated and stored in set A, while set B remains unchanged. We can put this
   operation as : A = A ^ B
>>> A = {1, 2, 3, 4, 5}
>>> B = {3, 4, 5, 6, 7, 8}
>>> A.symmetric_difference_update(B)
>>> A
set([1, 2, 6, 7, 8])
>>> B
set([3, 4, 5, 6, 7, 8])
>>> B.symmetric_difference_update(A)
>>> A
set([1, 2, 6, 7, 8])
>>> B
set([1, 2, 3, 4, 5])

17. union() Method :
   In set theory, Union of two sets is the set of all the elements present in both the sets. This method
   when called on a set A with set B as an argument, it returns a set which is union of both the sets A
   and B. The union operation can be represented by the symbol |. So, A | B is the union of two sets A
   and B.
>>> A = {1, 2, 3, 4, 5}
>>> B = {3, 4, 5, 6, 7, 8}
>>> A.union(B)
set([1, 2, 3, 4, 5, 6, 7, 8])
>>> B.union(A)
set([1, 2, 3, 4, 5, 6, 7, 8])

18. update() Method :
   When this method is called on a set A and provide another set B as an argument to this method, we get
   union of these sets stored in A, while set B remains unchanged. We can put this operation as A = A |
   B, where | represents Union operation.
>>> A = {1, 2, 3, 4, 5}
>>> B = {3, 4, 5, 6, 7, 8}
>>> A.update(B)
>>> A
set([1, 2, 3, 4, 5, 6, 7, 8])
>>> B
set([3, 4, 5, 6, 7, 8])

   With this, we end our discussion on Python Set and Frozenset methods. As already mentioned, set of
   all the methods associated with Python frozensets is subset of the set of methods associated with
   Python sets. Frozenset methods work exactly the same way as in case of Sets, so we have not covered
   them explicitly, so please consider this.
   Also, we have reached to the end of our discussion on data structures in Python, having covered
   [21]Python Strings, [22]Python Lists, [23]Python Tuples, [24]Python Dictionaries and [25]Python File
   Objects in earlier articles. I urge you to please have a quick read on each of them, as it is
   necessary to know them and their properties in order to understand further part of this tutorial
   series, as we will be covering the programming part. Please let us know about your feedback and
   opinions in comment section below and stay tuned for more articles. Thank you.
   This article is originally published at www.codeninja.in - [26]Python Set and Frozenset Methods



---
http://www.yourownlinux.com/2016/11/python-conditional-statement-nested-if-elif-else.html

Python Conditional Statements : if-elif-else & Nested if-else

   Posted on November 30, 2016 by Mandar Shinde

   Python if-elif-else statement - In the previous articles, we have learned about data structures in
   Python, viz. String, List, Dictionary, Tuple, File and Set. Now, this is the point from where we
   start performing certain operations on them. In this article, we will be knowing about the
   conditional statements in Python, which are if, if-else and if-elif-else statements. Before we
   proceed, I would like to remind you about the term Indentation, that we had mentioned in our
   introductory [18]article on Python.
   [19]python-if-elif-else-statement

Indentation
   In many other languages, in order to include a sequence of statements inside a block, a pair of curly
   braces ({ ... }) are used. This would not only add logic to your code, but also enhance the
   readability of the code, as indentation aligns our code vertically and gives an idea about which
   statement is a part of which block. Normally, the code would look like something as shown below (I've
   indented the code, but even if it was not indented, the meaning of the code would have remained
   intact.):
if (some_condition) {
    # Block of code begins
    ---- ;
    ---- ;
    ---- ;
    # Block of code ends
    if (some_other_condition) {
        # Block of code begins
        ---- ;
        ---- ;
        ---- ;
        # Block of code ends
    }
}

   In Python, we have white-space indented statements, in order to indicate that these statements belong
   to the same block. For this, we make use of TAB or four white-spaces at the beginning of each
   statement. Thus, end of indentation suggests that, the block has ended and subsequent statements are
   not the part of this block. So, immense care must be taken while coding in Python, as an error while
   indenting the statements will change the meaning of your entire code. In Python, above shown piece of
   code would look like (You need not bother about syntax at all, at this point of time) :
if (some_condition) :
    # Block of code begins
    ----
    ----
    ----
    # Block of code ends
    if (some_other_condition) :
        # Block of code begins
        ----
        ----
        ----
        # Block of code ends

   Please observe that, statements inside first if statement are indented with a single TAB character,
   while those inside second if statement are indented with two TAB characters. This depicts that, first
   block of statement are the part of first if statement, while other block belongs to the second one.
   Had I indented the second block with single TAB, it would have become the part of first if statement,
   changing the meaning of entire code. Thus, indentation in Python has a special meaning and can change
   the logic of your entire code.

if statement
   Generally, conditional statements are used when there is a need of doing something depending upon
   outcome of some event. As in any other programming language, Python if statement executes a block of
   statements, depending upon some condition and if it evaluates to True. The condition is an another
   Python statement, which returns a bool type, we have already seen [20]relational and logical
   operations that would return True or False. Lets now see the syntax for using an if statement.
   Syntax :
if (condition) :
    # Block of code starts
    ----
    ----
    ----
    # Block of code ends

   Example 1 :
>>> var = 5
>>> if var == 5:
...     print "Value of 'var' is 5."
...     print "So, 'if' statement has executed"
...
Value of 'var' is 5.
So, 'if' statement has executed

>>> var = 7
>>> if var == 5:
...     print "Value of 'var' is 5."
...     print "So, 'if' statement has executed"
...
>>>

   Example 2 : Check if a number is Even
>>> myNum = 63
>>> if myNum % 2 == 0 :
...     print 'myNum is Even'
...     print 'Executing "if" block'
...

>>> myNum = 16
>>> if myNum % 2 == 0 :
...     print 'myNum is Even'
...     print 'Executing "if" block'
...
myNum is Even
Executing "if" block

   You can observe in above example that, condition is var == 5 and block of the code comprises of two
   print statements. As we are using if statement, the block of code will only be executed if and only
   if the condition evaluates to True. In first case, var = 5 which makes condition True, so the two
   print statements are executed. While in other case, var = 7 makes the condition False because of
   which block of code is skipped from executing. Please note that, the condition needs not always be an
   expression like we used here. It can be a Python object also, a String, a List, a Tuple, a
   Dictionary, a number and so on. An empty Python object or a zero denotes False, while a non-empty and
   a non-zero Python object will always denote a True.
   Examples :
# A zero always denotes 'False'
>>> myInt = 0
>>> if myInt:
...     print 'This is a non-zero integer.'
...
# A non-zero number always denotes 'True'
>>> myInt = 12.34
>>> if myInt:
...     print 'This is a non-zero integer.'
...
This is a non-zero integer.

# An empty string always denotes 'False'
>>> myStr = ""
>>> if myStr:
...     print 'This is a non-empty string.'
...
>>> myStr = "CodeNinja"
>>> if myStr:
...     print 'This is a non-empty string.'
...
This is a non-empty string.

# An empty list always denotes 'False'
>>> myList = []
>>> if myList:
...     print 'This is a non-empty list.'
...
>>> myList = [1, 2, 3]
>>> if myList:
...     print 'This is a non-empty list.'
...
This is a non-empty list.

# An empty tuple always denotes 'False'
>>> myTuple = ()
>>> if myTuple:
...     print 'This is a non-empty tuple.'
...
>>> myTuple = (100,)
>>> if myTuple:
...     print 'This is a non-empty tuple.'
...
This is a non-empty tuple.

if-else statement
   As we've seen, if will execute the block of statements if the condition evaluates to True, but what
   if we want to perform some action if the condition doesn't follow? In that case, we need to make use
   of else block, which is optional one but can be used as and when required. With if-else statement, we
   check the condition in the if statement, if it evaluates to True, the if block is executed. But, if
   it evaluates to False, else block will be executed. The syntax to use if-else statement in Python is
   as below:
   Syntax :
if (condition) :
    # Block of code starts
    ----
    ----
    ----
    # Block of code ends
else :
    # Block of code starts
    ----
    ----
    ----
    # Block of code ends

   Example 1 :
# Condition evaluates to 'True' -> 'if' block will be executed
>>> myInt = 5
>>> if myInt == 5 :
...     print 'myInt is 5.'
...     print 'Executing "if" statement.'
... else:
...     print 'myInt is not equal to 5.'
...     print 'Executing "else" block.'
...
myInt is 5.
Executing "if" statement.

# Condition evaluates to 'False' -> 'else' block will be executed
>>> myInt = 55
>>> if myInt == 5 :
...     print 'myInt is 5.'
...     print 'Executing "if" statement.'
... else:
...     print 'myInt is not equal to 5.'
...     print 'Executing "else" block.'
...
myInt is not equal to 5.
Executing "else" block.

   Example 2 : Checking if a number is Even or Odd
>>> myNum = 63
>>> if myNum % 2 == 0:
...     print 'myNum is Even'
...     print 'Executing "if" block'
... else:
...     print 'myNum is Odd'
...     print 'Executing "else" block'
...
myNum is Odd
Executing "else" block

>>> myNum = 16
>>> if myNum % 2 == 0:
...     print 'myNum is Even'
...     print 'Executing "if" block'
... else:
...     print 'myNum is Odd'
...     print 'Executing "else" block'
...
myNum is Even
Executing "if" block

   Thus, with if-else statement, we can perform certain actions if the condition follows and if it
   doesn't. What if we have multiple conditions, e.g. to find out whether a number is divisible by 2 or
   3 or neither of them? We have another statement - if-elif-else, which we will see next.

if-elif-else statement
   So far, in if and if-else we have checked only one condition. Sometimes, it necessitates to check
   more than one condition, where we can use if-elif-else statement. In this statements, we have one if
   and one else block and one or more elif blocks. With each elif statement, we can check a condition,
   if it evaluates to True corresponding block of statements get executed. Thus, flow of the condition
   check is - first of all, it will check the condition in if statement, if False, it will check
   condition in elif statement(s) one-by-one. If none of the conditions evaluates to True, control goes
   to else statement and corresponding block is executed. The syntax for this statement is as below:
if (condition1) :
    ----
    ----
    ----
elif (condition2) :
    ----
    ----
    ----
elif (condition3) :
    ----
    ----
    ----
...
...
...
elif (conditionN) :
    ----
    ----
    ----
else :
    ----
    ----
    ----

   Example: Check a number is divisible by 2 or 3
>>> myNum = 7
>>> if myNum % 2 == 0 and myNum %3 == 0:
...     print 'myNum is divisible by both 2 and 3'
...     print 'Executing "if" block'
... elif myNum % 2 == 0:
...     print 'myNum is divisible by 2 only'
...     print 'Executing first "elif" block'
... elif myNum % 3 == 0:
...     print 'myNum is divisible by 3 only'
...     print 'Executing second "elif" block'
... else:
...     print 'myNum is neither divisible by 2 nor 3'
...     print 'Executing "else" block'
...
myNum is neither divisible by 2 nor 3
Executing "else" block

>>> myNum = 9
>>> if myNum % 2 == 0 and myNum %3 == 0:
...     print 'myNum is divisible by both 2 and 3'
...     print 'Executing "if" block'
... elif myNum % 2 == 0:
...     print 'myNum is divisible by 2 only'
...     print 'Executing first "elif" block'
... elif myNum % 3 == 0:
...     print 'myNum is divisible by 3 only'
...     print 'Executing second "elif" block'
... else:
...     print 'myNum is neither divisible by 2 nor 3'
...     print 'Executing "else" block'
...
myNum is divisible by 3 only
Executing second "elif" block

>>> myNum = 8
>>> if myNum % 2 == 0 and myNum %3 == 0:
...     print 'myNum is divisible by both 2 and 3'
...     print 'Executing "if" block'
... elif myNum % 2 == 0:
...     print 'myNum is divisible by 2 only'
...     print 'Executing first "elif" block'
... elif myNum % 3 == 0:
...     print 'myNum is divisible by 3 only'
...     print 'Executing second "elif" block'
... else:
...     print 'myNum is neither divisible by 2 nor 3'
...     print 'Executing "else" block'
...
myNum is divisible by 2 only
Executing first "elif" block

>>> myNum = 12
>>> if myNum % 2 == 0 and myNum %3 == 0:
...     print 'myNum is divisible by both 2 and 3'
...     print 'Executing "if" block'
... elif myNum % 2 == 0:
...     print 'myNum is divisible by 2 only'
...     print 'Executing first "elif" block'
... elif myNum % 3 == 0:
...     print 'myNum is divisible by 3 only'
...     print 'Executing second "elif" block'
... else:
...     print 'myNum is neither divisible by 2 nor 3'
...     print 'Executing "else" block'
...
myNum is divisible by both 2 and 3
Executing "if" block

Nested if-else statement
   In nested if-else statements, we can have one or more if-elif-else statement inside an if-elif-else
   statement. This is where indentation plays a very crucial role, as in order to introduce an if
   statement inside other, we need to indent it properly, or the entire logic will change.
   Syntax :
if (condition) :
    ---
    ---
    if (condition) :
        ---
        ---
    elif (condition) :
        ---
        ---
    else:
        ---
        ---
elif (condition) :
    ---
    ---
    if (condition) :
        ---
        ---
    else :
        ---
        ---
else :
    ---
    ---
    if (condition) :
        ---
        ---
    else :
        ---
        ---

   Example : Check whether a number is divisible by 2 or 3
>>> myNum = 7
>>> if myNum % 2 == 0 :
...     if myNum % 3 == 0 :
...             print 'myNum is divisible by both 2 and 3'
...     else:
...             print 'myNum is divisible by 2 only'
... elif myNum % 3 == 0 :
...     print 'myNum is divisible by 3 only'
... else :
...     if myNum % 5 == 0:
...             print 'myNum is neither divisible by 2 nor 3, but divisible by 5'
...     else:
...             print 'myNum is neither divisible by 2 nor by 3'
...
myNum is neither divisible by 2 nor by 3

>>> myNum = 25
>>> if myNum % 2 == 0 :
...     if myNum % 3 == 0 :
...             print 'myNum is divisible by both 2 and 3'
...     else:
...             print 'myNum is divisible by 2 only'
... elif myNum % 3 == 0 :
...     print 'myNum is divisible by 3 only'
... else :
...     if myNum % 5 == 0:
...             print 'myNum is neither divisible by 2 nor 3, but divisible by 5'
...     else:
...             print 'myNum is neither divisible by 2 nor by 3'
...
myNum is neither divisible by 2 nor 3, but divisible by 5

>>> myNum = 24
>>> if myNum % 2 == 0 :
...     if myNum % 3 == 0 :
...             print 'myNum is divisible by both 2 and 3'
...     else:
...             print 'myNum is divisible by 2 only'
... elif myNum % 3 == 0 :
...     print 'myNum is divisible by 3 only'
... else :
...     if myNum % 5 == 0:
...             print 'myNum is neither divisible by 2 nor 3, but divisible by 5'
...     else:
...             print 'myNum is neither divisible by 2 nor by 3'
...
myNum is divisible by both 2 and 3

   You can observe that, in the else block also, we have put an if-else just to check whether the number
   is divisible by 5 and print the result accordingly. Nothing so great about it, but it was just to
   give you a glimpse about how a nested if-else statement works.
   With this, we have come to an end of the discussion on if-elif-else statement in Python. After
   reading this article, one should be able to decide which statement must be used given a scenario and
   write those statements. Although very basic examples are provides, those should have given you a
   clear idea about how the control flow is switched depending on what the condition evaluates to. In
   the next article, we will be covering for loop, which is used to iterate over a Python iterable
   object or repeat a certain task for number of times. Please share your views and feedback on this
   article in the comment section below and stay tuned for more articles. Thank you!
   This article is originally published at www.codeninja.in - [21]Python Conditional Statements

   
---
http://www.yourownlinux.com/2016/12/python-loop-for-else-break-continue-statement.html

   Python 'for-else' loop with 'break' & 'continue' statements
   Posted on December 01, 2016 by Mandar Shinde

   Python for-else loop - We are going to cover for and for-else loop in this discussion. In the last
   article, we have learned about Python [18]conditional statements in which we had covered if, if-else
   and if-elif-else statements. Moving a step forward, we now try to understand Python loop statements
   which are for and while statements. In this article, we will be discussing about for and for-else
   loop along with their syntax and examples.
   [19]python-for-else-loop-with-break-continue-statements
   Generally, a for loop in any programming language is used to execute a block of statements for a
   specific number of times. We can also use break statement in order to exit from the loop based on
   some condition or even jump to the next iteration using continue statement. Without these two
   statements, a for loop will execute a fixed number of times. Normally, in order to create a for loop,
   you will need to include three things - Initialization (where you initialize the variable), Condition
   (where condition is checked, if False we come out of the loop) and Increment or Decrement (where the
   variable is incremented or decremented). All these things in a for statement will create a loop for
   you. Have a look at the syntax below:
for ( initialization, check_condition, increment/decrement)
{
    # Block of statements starts
    ----
    ----
    ----
    # Block of statements ends
}

   In the first step Initialization, we declare a variable (often known as 'loop control variable'). In
   the next step Condition check, a condition is checked whether it evaluates to True or False. If it
   evaluates to True, block of code is executed, else not. After completion of each iteration, the
   variable is incremented or decremented and condition is re-checked. Depending upon the situation, the
   block of statements is executed or loop is exited. Thus, as long as the condition evaluates to True,
   the block of statements will keep on executing. So, we have the increment/decrement option in order
   to ensure that the loop will exit at some point of time. If it was not there, we would have been
   caught inside an infinite loop that never exits.

Python for Loop
   In Python, we do not have Initialization, Condition check and Increment/Decrement. Instead, we have a
   Python object that can be iterated over, like a String, a List, a Tuple. We also have a variable that
   takes values from the Python iterable object, one-by-one, and runs the block of statements, till the
   last item in the iterable is reached. Once the last item from the Python object is processed, the for
   loop is exited. Take a look at the for loop syntax in Python.
   Syntax :
for variable_name in python_iterable_object :
    # Block of code starts
    ----
    ----
    ----
    # Block of code ends

   In the first iteration, the iterable variable variable_name will take the value equal to first item
   in python_iterable_object, execute the block of commands and control goes back to the for statement
   to start the second iteration. In second iteration, the iterable variable variable_name will take the
   value equal to second item in python_iterable_object, execute the block of commands and control is
   shifted back to the for statement. This process continues till last item in the iterable object is
   reached, after which loop is ended.
   Please take a look at below example, wherein we have used Python built-in range() function, which
   returns a list type and a Python iterable object. Please read our article Introduction to Python
   Lists for more information about range() function.
   Example 1 : Iteration using range() function
# range(6) returns [0, 1, 2, 3, 4, 5]
>>> for myVar in range(6):
...     print 'This is the iteration number : ' + str(myVar + 1)
...
This is the iteration number : 1
This is the iteration number : 2
This is the iteration number : 3
This is the iteration number : 4
This is the iteration number : 5
This is the iteration number : 6

   Example 2 : Calculation of squares of first 10 integers
>>> for myVar in range(10):
...     myVar += 1
...     print 'Square of ' + str(myVar) + ' = ' + str(myVar ** 2)
...
Square of 1 = 1
Square of 2 = 4
Square of 3 = 9
Square of 4 = 16
Square of 5 = 25
Square of 6 = 36
Square of 7 = 49
Square of 8 = 64
Square of 9 = 81
Square of 10 = 100

   Example 3 : Iterating through a String
>>> myStr = 'CodeNinjadotin'
>>> for myVar in myStr:
...     print 'This letter is ' + myVar.upper()
...
This letter is C
This letter is O
This letter is D
This letter is E
This letter is N
This letter is I
This letter is N
This letter is J
This letter is A
This letter is D
This letter is O
This letter is T
This letter is I
This letter is N

   Example 4 : Iterating through a List
>>> myList = [5, 10, 15, 20]
>>> for myVar in myList:
...     print 'Cube of ' + str(myVar) + ' = ' + str(myVar ** 3)
...
Cube of 5 = 125
Cube of 10 = 1000
Cube of 15 = 3375
Cube of 20 = 8000

   Example 5 : Iterating through a Tuple
>>> myTuple = ('Barcelona', 'Real Madrid', 'Liverpool', 'Bayern Munich')
>>> for myClub in myTuple:
...     print 'I Love ' + myClub + ' !'
...
I Love Barcelona !
I Love Real Madrid !
I Love Liverpool !
I Love Bayern Munich !

   Example 6 : Iterating through Key-Values in a Dictionary
>>> myDict = {'Italy': 'Juventus', 'Germany': 'Bayern Munich', 'England': 'Leicester City', 'Spain': \
	'Barcelona'}
>>> for (country, club) in myDict.items():
...     print club + ' -> ' + country
...
Bayern Munich -> Germany
Juventus -> Italy
Leicester City -> England
Barcelona -> Spain

[20]The break and continue Statements

   Any discussion on loop statements without mentioning break and continue statements is incomplete. The
   break statement are typically used inside an if statement in order to prematurely exit from the for
   loop based on certain condition. Whereas, continue statement will jump to the next iteration without
   executing subsequent block of code, based on a condition.
   Syntax :
for variable_name in python_iterable_object :
    ----
    ----
    ----
    if (condition) :
        ----
        ----
        break
    ----
    ----
    if (condition) :
        ----
        ----
        continue

   Example 1 : 'break' statement to stop counting at 5
>>> for myVar in range(1, 11):
...     if myVar > 5 :
...             break
...     print 'This number = ' + str(myVar)
...
This number = 1
This number = 2
This number = 3
This number = 4
This number = 5

   In above example, myVar is always kept in check whether it is greater than 5. Until it is less or
   equal to 5, if condition evaluates to False and print statement is executed. Once it reaches 6,
   condition evaluates to True which then executes break statement, thus exiting from the loop. In the
   end, we have all the numbers less or equal to 5.
   Example 2 : 'continue' statement to print only Even numbers
>>> for myVar in range(1, 11):
...     if myVar % 2 != 0 :
...             continue
...     print 'This number = ' + str(myVar)
...
This number = 2
This number = 4
This number = 6
This number = 8
This number = 10

   In this example, we keep a check on myVar whether it is Even or Odd with the expression myVar % 2 ==
   0. Whenever the condition evaluates to False, print statement is executed. When it evaluates to True,
   continue statement is executed, that jumps to next iteration skipping the execution of further
   statements, due to which print does not execute. As a result, we have all the even numbers printed on
   the terminal.

for-else Loop

   Well, this might seem to be very unusual, but we do have an optional else block in for statement in
   Python. This else block gets executed only when break statement is not executed. If there is no break
   statement in the code, else block will always execute.
>>> myNum = 9
>>> for myVar in range(15):
...     if myVar == myNum:
...             print 'Found !'
...             break
...     else:
...             continue
... else:
...     print 'Not found !'
...
Found !

>>> myNum = 21
>>> for myVar in range(15):
...     if myVar == myNum:
...             print 'Found !'
...             break
...     else:
...             continue
... else:
...     print 'Not found !'
...
Not found !

   In above example, we iterate through a list of 15 integers and compare if the number is myNum. If the
   number matches, we print Found! and execute break statement. If the number is not found, break
   statement is never executed, because of which else block gets executed, which eventually prints Not
   found !.
   With this, we end our discussion on Python for and for-else loops. In this article, we learned how
   both these loops can be constructed and used. We have also learned about loop control statements -
   break and continue, along with their examples. In the next article, we will learn about another
   Python loop statement - while loop. Note that, break and continue statements will have the same role
   in case of while loops also. Please share your opinions and feedback in the comment section below and
   stay tuned for more articles. Thank you.
   This article is originally published at www.codeninja.in - [21]Python for-else loop with break and
   continue statements


---
http://www.yourownlinux.com/2016/12/python-while-else-loop-break-continue-statement.html

   Python 'while-else' loop with 'break' & 'continue' statements
   Posted on December 05, 2016 by Mandar Shinde

   Python while-else loop - In the [18]last article, we have covered the first loop statement in Python,
   for-else statement. In this article, we are going to learn about another loop statement - while-else
   loop. There are some differences as far as syntax and their working patterns are concerned, which we
   will be studying in this tutorial. Lets begin!
   [19][python-while-else-loop.JPG]

Python while Loop
   The key difference between for and while loops is that, where for requires a Python iterable object
   to form a loop, while loop, we do not have any such prerequisites. It just needs a condition to be
   provided, which is tested at every iteration. As long as the condition is True, the block of
   statement is executed repeatedly. Once the condition becomes False, while loop is exited. Have a look
   at the while loop syntax below.
while (condition) :
    # Block of statements starts
    ----
    ----
    ----
    ----
    # Block of statements ends

   In this, when we enter the while loop for the first time, condition is checked, if it evaluates to
   False, it does not enter into the loop. If the condition evaluates to True, the block of statement is
   executed to finish the first iteration. After this, control goes back to the while (condition) :
   statement to re-check the condition and the process repeats. The block of statements will keep
   executing repeatedly as long as the condition evaluates to True, thus forming a loop. An immense care
   should be taken in order not to get caught into an infinite loop, while using while loop. Lets check
   out some examples of while loop.
   Example 1 : Printing numbers and their squares
>>> myNum = 11
>>> myVar = 0
>>> while myVar < myNum :
...     print 'Square of ' + str(myVar) + ' is ' + str(myVar ** 2)
...     myVar += 1
...
Square of 0 is 0
Square of 1 is 1
Square of 2 is 4
Square of 3 is 9
Square of 4 is 16
Square of 5 is 25
Square of 6 is 36
Square of 7 is 49
Square of 8 is 64
Square of 9 is 81
Square of 10 is 100

   In above example, we have a variable myVar which begins counting from 0 until its value is less than
   another variable myNum = 11. In the first iteration, myVar = 0 which is less than myNum and evaluates
   the condition to True and executes the print statement. After printing, the value of myVar is
   incremented by 1 to finish the first iteration. Now, control goes back to while statement where
   condition myVar < myNum is checked. Here, myVar = 1 and myNum = 11 evaluates the condition to True
   and block of statement is executed. This process will repeat till myVar reaches 10. At this point,
   myVar = 10 and myNum = 11 evaluates the condition to True, prints the statement and increments myVar
   by 1 to take a value 11. Now, when the control goes back to while statement, it evaluates the
   condition to False which terminates the loop.
   Example 2 : Factorial of a number
# Calculating 7!
>>> myNum = 7
>>> fact = 1
>>> while myNum :
...     fact *= myNum
...     myNum -= 1
...
>>> print fact
5040

# Calculating 5!
>>> myNum = 5
>>> fact = 1
>>> while myNum :
...     fact *= myNum
...     myNum -= 1
...
>>> print fact
120

   In above example, we use while loop such that the variable myNum takes the values ranging from it's
   initial value to 1 (Please observe the myNum -= 1 statement). We use these values to continuously
   keep multiplying another variable fact, that stores the result. Eventually, fact will contain 1 * 2 *
   3 * ... * myNum which is printed on the last line. Please note that, when the variable myNum reaches
   the value 0, condition evaluates to False to come out of while loop.

break and continue Statements Revisited

   As we've already seen in the last article on [20]Python for loops, break statements are used for
   terminating a loop prematurely, based on certain condition. The break statement can also be used in
   the same way in case of while loops. We also have continue statement, that is used to skip executing
   further code, by jumping straight to the next iteration, based on certain condition.
   Example 1 : Breaking the iteration
>>> myNum = 11
>>> myVar = 1
>>> while myVar < myNum :
...     print 'This is iteration #' + str(myVar)
...     if myVar == 6 :
...             print 'This is the last iteration and we stop here.'
...             break
...     myVar += 1
...
This is iteration #1
This is iteration #2
This is iteration #3
This is iteration #4
This is iteration #5
This is iteration #6
This is the last iteration and we stop here.

   In above example, we created a loop which starts with myVar = 1 and is expected to run till myVar
   reaches myNum. But, with the if condition mentioned, the loop is terminated prematurely when the
   value of myVar reaches 6.
   Example 2 : Printing only Even numbers using 'continue' statement
>>> myNum = 15
>>> myVar = 1
>>> while myVar < myNum :
...     if myVar % 2 != 0 :
...             myVar += 1
...             continue
...     print 'This number = ' + str(myVar)
...     myVar += 1
...
This number = 2
This number = 4
This number = 6
This number = 8
This number = 10
This number = 12
This number = 14

   In above example, we create a loop which is expected to print values from 1 to 14. But, with if
   statement, we check whether myVar is an Even number, if it is, we print the statement. If myVar is
   Odd, continue statement is executed, which jumps to the next iteration by skipping the execution of
   subsequent lines of code. As a result, we get only even numbers printed on the screen.

Python while-else Loop

   As in case of for loop, we have an optional else block in case of while loops. It does work in
   exactly the same way it works in case of for loop. The else block gets executed only when the break
   statement is not executed. This also means that, absence of break statement will execute the else
   block once. Please take a look at below examples.
   Example :
# 'break' is executed, hence 'else' will not be executed
>>> myNum = 6
>>> myVar = 1
>>> while myVar <= 10 :
...     if myVar == myNum :
...             print 'Breaking out of the loop'
...             break
...     print 'This number = ' + str(myVar)
...     myVar += 1
... else:
...     print 'Break statement is executed, printing "else" block'
...
This number = 1
This number = 2
This number = 3
This number = 4
This number = 5
Breaking out of the loop

# 'break' is not executed, hence 'else' will be executed
>>> myNum = 12
>>> myVar = 1
>>> while myVar <= 10 :
...     if myVar == myNum :
...             print 'Breaking out of the loop'
...             break
...     print 'This number = ' + str(myVar)
...     myVar += 1
... else:
...     print 'Break statement is executed, printing "else" block'
...
This number = 1
This number = 2
This number = 3
This number = 4
This number = 5
This number = 6
This number = 7
This number = 8
This number = 9
This number = 10
Break statement is executed, printing "else" block

   In above examples, we try to print numbers from 1 to 10. In first example, we introduce a break
   statement when myVar reaches 6. Due to this, the program will print numbers from 1 to 5 and as soon
   as myVar takes value equal to 6, program executes break, due to which else block is skipped from
   being executed. In the second example, the loop will be broken when myVar reaches 12, which it will
   never reach and break statement will never get executed. As break is not executed, else block is
   executed.
   With this, we have come to an end of this discussion on Python while loops. In this article, we've
   learned how while are constructed and how the control flow works. We have also revised how break and
   continue statements work in while loops. After that we studied the while-else loop along with its
   examples. Having covered for and while loops, we have finished the loop statements in Python. In the
   next article, we will be discussing on Python functions. Please share your views and feedback on this
   article in the comments section below and stay tuned. Thank you!
   This article is originally published at www.codeninja.in - [21]Python while-else Loop with break and
   continue Statement

   
---
http://www.yourownlinux.com/2016/12/python-function-define-call-arguments-parameters.html

   Python Function - Definition, Call, Arguments and Parameters
   Posted on December 06, 2016 by Mandar Shinde

   Python Function - In our recent articles, we have discussed on loop statements - for-else loop
   and while-else loop. In this article, we will be learning about what functions are, how we can
   create our own function and how we can use it.

   Functions in any programming language is a group of statements, identified by a name, that perform a
   specific task. Whenever we want to re-use these statements in the code, instead of writing them all
   every time, we can invoke them using the name specified. This will not only save our copy-paste
   efforts but also reduce the code redundancy in the program. Also, for any correction to be made to
   any statement in the group, one need not correct every occurrence of it. Instead, it would be
   sufficient to make appropriate corrections in the defined function. Things will be clear when we go
   through some examples of functions. But to start with, lets learn how functions are created or
   defined.

Function definition
   To define a function, Python has a keyword def, which gives us a function type or an object of class
   function. Please have a look at the basic syntax first, then we will try to unfold everything.
def function_name():
    # Block of code starts
    ...
    ...
    ...
    ...
    # Block of code ends

   In the syntax above, the line starting with def is often called as function header and it consists of
   the keyword def, the name of the function and a pair of parenthesis. In the parenthesis, we can
   mention zero or more parameters, which we will discuss about later. After that, we have an indented
   block of statements, which we can call as 'function body', that will be executed at every run of the
   function. So, if we were to define our own function myFirstFunction which does nothing, we can have a
   pass statement in the function body as shown below:
>>> def myFirstFunction() :
... pass
...

   Congrats, you've just created your first Python function. Had we replaced the pass statement with
   print 'Hello World', it would have printed Hello World on the screen. Shall we check the what type
   object a Python function is? We require a Python built-in function for this, which is dir() function.
>>> type(myFirstFunction)
<type 'function'>

   As I said earlier, the resultant object is of function type. Now, we have created a function, but how
   to use it? Lets see this in following section.

Function Call
   A function call is nothing but making use of the function you have created. Well, to do this, you
   just need to mention the function name followed by a pair of parenthesis. Remember, with the def
   keyword, you just created a function. Unless you create a function, you cannot call it. So, the
   function definition must come before the function call or you will face an error message. Lets try
   defining a function myFunction, that prints Congrats! You have just executed a function, and calling
   it.
>>> def myFunction() :
...    print "Congrats! You have just executed a function"
...

>>> myFunction()
Congrats! You have just executed a function

   As mentioned above, in order to call a function, we just mentioned it's name followed by the
   parenthesis and we have the function executed. Next, we need to know about two important terms
   related to Python functions, which I might have mentioned earlier, but have to be understood in
   detail - Function Argument and Function Parameter

Function Argument and Function Parameter
   We have already used some functions like dir() and len() in our previous articles, in which dir and
   len are the function names. We have used them to get a list of attributes and methods associated with
   the object and to find length of the object respectively. So, in order to get the attribute list of a
   list myList, we would use dir(myList) or to find its length, we would use len(myList), where we call
   myList as an Argument to dir() and len() functions. With an argument, we send some information, in
   the form of variable or a value, to a function. On the other hand, function receives these values
   using another variable, declared in the function header, which is called as a Parameter.
   To understand this, lets take an example of any Python built-in function, say dir() function. The
   built-in functions are defined somewhere in the Python library and they must be defined in somewhat
   similar syntax as seen earlier. So, the dir() function might look like :
def dir( param ) :
    ....
    ....
    ....
    ....

   Thus, the variable param is the parameter of the function. When we actually use the function as
   dir(myList), by providing an argument myList to that function, the function reads the value stored in
   the variable myList and assigns it to the variable param. After some processing on it, we finally get
   appropriate output. Take a look at below examples.
   Example 1 : Table of a number
>>> def table(myNum) :
...     print '1 * ' + str(myNum) + ' = ' + str(1 * myNum)
...     print '2 * ' + str(myNum) + ' = ' + str(2 * myNum)
...     print '3 * ' + str(myNum) + ' = ' + str(3 * myNum)
...     print '4 * ' + str(myNum) + ' = ' + str(4 * myNum)
...     print '5 * ' + str(myNum) + ' = ' + str(5 * myNum)
...     print '6 * ' + str(myNum) + ' = ' + str(6 * myNum)
...     print '7 * ' + str(myNum) + ' = ' + str(7 * myNum)
...     print '8 * ' + str(myNum) + ' = ' + str(8 * myNum)
...     print '9 * ' + str(myNum) + ' = ' + str(9 * myNum)
...     print '10 * ' + str(myNum) + ' = ' + str(10 * myNum)
...

>>> table(5)
1 * 5 = 5
2 * 5 = 10
3 * 5 = 15
4 * 5 = 20
5 * 5 = 25
6 * 5 = 30
7 * 5 = 35
8 * 5 = 40
9 * 5 = 45
10 * 5 = 50

   In above example, we have created a function with name table which prints the table of a number
   provided as an argument. It uses the parameter myNum to store the number. After some operations on
   myNum, we print the result. We also checked calling it with number 5 as an argument and it prints the
   table of 5. Now, in order to print the table of 7, we need not write the statements again, just call
   the function as table(7) and you are done. Conclusion - Functions improve the re-usability of the
   code and reduces redundancy.
   Example 2 : Power of a number
>>> def power(base, exp) :
...     print str(base) + ' to the power of ' + str(exp) + ' is ' + str(base ** exp)
...

>>> power(2, 3)
2 to the power of 3 is 8
>>> power(3, 4)
3 to the power of 4 is 81
>>> power(6, 3)
6 to the power of 3 is 216

   In this examples, we have created a function with name power that has two parameters base to store
   the value of base and exp to store the value of exponent. This function will calculate the expth
   power of base and print it on the screen. While calling the function, we have mentioned two arguments
   every time and got appropriate results in the output.
   In this way, we have come to an end of this discussion of this article. This article was intended to
   provide you very basic knowledge about functions, in which we studies to define a function and call a
   function. Meanwhile, we also learned about arguments and parameters and used them in our function
   definition and function call. Although, we are not finished with functions, I recommend you to
   practice on whatever we have studied and start writing some functions of yours. Please write your
   reviews and feedback in the comment section below. In the next article, we will cover scope of the
   variables. Till then, stay tuned. Thank you.
   This article is originally published at www.codeninja.in - [21]Python Function Basics

---
filename: /c/Users/gregor.redelonghi/Dropbox/ODPRTO/_PYTHON/__insert_python_yourownlinux-multif_20161212.txt
http://www.yourownlinux.com/2016/12/python-namespace-variable-scope-local-global-enclosed.html

Python Namespace & Variable Scope - Local, Enclosed, Global

   Posted on December 07, 2016 by Mandar Shinde

   Python Namespace and Variable Scope - In this article, we will be learning about local and global
   variables. This article is related to our last article on [18]Python function, so I recommend to have
   a read over it, so that things will be easier to understand. In this article, we are going to
   understand namespace first, where all the declared variables are actually stored and retrieved as and
   when required. Then we will be knowing about two important terms - local variables and global
   variables.

Name and Namespace
   We know that, everything in Python is an object and to identify an object easily, we assign a name to
   it, which we call as a variable. In our article on [20]Python variables, we studied that, a variable
   is an identifier of an object and the object can be accessed using the name assigned to it. Consider
   that, we have declared a variable as myString = "I <3 Python!". With this, a str type of object "I <3
   Python!" is stored in the memory, which can also be accesses using the name myString. Now, we can
   perform any operation on the object or call corresponding methods on it, by using it's name. For
   example, in order to capitalize every letter in the string, we can use myString.upper().
   Now, if we create some more objects and assign names to them, those will be stored in memory
   locations and will be available to be accessed using the names assigned to them. With this, you can
   consider a 'namespace' to be a place where all these names are stored. In simple words, a namespace
   is the collection of all the names in the form of dictionary items as name : object. To more
   understand this, I would like to introduce globals() function here, that will display the mapping.
   For now, don't bother about why the name globals() and all, we will see it later. This is just to
   show you how the namespace looks like.
>>> myString = "I <3 Python!"
>>> myList = [1, 2, 3, 4]
>>> myTuple = ('A', 'B', 'C')
>>> globals()
{'myTuple': ('A', 'B', 'C'), 'myList': [1, 2, 3, 4], '__builtins__': <module '__builtin__' (built-in)>, '__pac
kage__': None, 'myString': 'I <3 Python!', '__name__': '__main__', '__doc__': None}

   In above example, we have created three objects and assigned names myString, myList and myTuple to
   them. To display the namespace, we called Python built-in function globals(), which returned a dict
   type, with items in name : object format, 'myTuple': ('A', 'B', 'C') being one of them. Thus, as soon
   as we create a name and assign a value to it, it becomes a part of namespace. We have zero or more
   local namespaces and a global namespace. Based on where in the code the assignment happens, the
   namespace which the variable will be a part of, is decided. Let us discuss this in the next section.

Global Namespace and Local Namespace
   As mentioned above, a name is a part of which namespace, is decided by where the variable is declared
   in the program. This arises one more question in our mind that, Where can we declare a name?. Answer
   will be, a name can be defined in the main program body, in a function or in a module (a module can
   be considered as a pre-existing Python program file, from where an object can be imported). If a name
   is declared in the main program body, it will be a part of global namespace, while a name definition
   inside a function makes it a part of local namespace. Every function declared has its own local
   namespace, so that the values assigned to a name inside a function do not get overwritten with the
   names declared in other functions or main program body (global namespace). In conclusion -
   1. We have a global namespace, where all the names declared in the main program body reside.
   2. Every function is associated with its own namespace, known as local namespace. We can have
   multiple local namespaces in a program, as we can have zero or more functions in our piece of code.
   3. A name declared in a function can only be accessed within that function
   4. A name can be a part of one or more namespaces, but their values do not collide with each other.
   For example, name myVar declared in main program body (global namespace) and a name myVar declared in
   a function myFunc are absolutely different entities and their value do not clash with one another.
   5. This also means that, in case of nested functions (function inside another function) will have
   individual namespaces associated with each of them. In this case, the namespace of enclosing function
   is often called as Enclosed namespace.
   6. Every call to a function creates a new local namespace.
   7. We also have Built-in namespace, which is reserved by Python, consisting mainly of exceptions and
   built-in functions.
   There might be numerous namespaces created in a program, but all the namespaces are not available to
   be accessed from anywhere in the program. This introduces a new term Scope, that defines the section
   of the program from where the namespace can be accessed. We discuss this in the next section.

Scope
   In the above section, we have come to know that a program may have a number of namespaces, which are
   independent from each other and not accessible from everywhere in the program. A scope decides the
   part of the program from where the name can be accessible. So, based on where the name is referenced
   in the program, the name is searched in the namespaces in a specific order as per LEGB (Local ->
   Enclosed -> Global -> Built-in) rule.
   As per LEGB rule, the order of search should be -
   1. Local scope (or namespace) - The name is searched in the local namespace, if it is referenced
   inside a def.
   2. Enclosed scope - If not present in local namespace, the namespace of enclosing def is searched.
   3. Global scope - If not found, global namespace - the top level namespace in a file, is looked into.
   4. Built-in scope - If still not found, it searches the Built-in scope, which is nothing but the
   Python builtin module.
   5. If the name is not found in any of above mentioned scopes, a KeyError exception is raised. We see
   some examples in order to verify everything we studied in this article, so far.
   Example 1 : Local and Global Scope
>>> myVar = "Global"
>>> def myFunction() :
...     myVar = "Local"
...     print 'Value of myVar inside function = ' + myVar
...
>>> print 'Value of myVar outside function = ' + myVar
Value of myVar outside function = Global
>>> myFunction()
Value of myVar inside function = Local

   In above example, we have declared a name myVar = "Global" in the main program body and myVar =
   "Local" inside a function myFunction. When we use the variable in the main program, its value from
   the global namespace is referred, whereas when the function is called, it's value from local
   namespace is referred, as per LEGB rule.
   Example 2 : Local, Enclosed and Global Scope
>>> myVar = "Global"
>>> def outerFunction():
...     myVar = "Enclosed"
...     print 'Value of myVar in outerFunction() = ' + myVar
...     def innerFunction():
...             myVar = "Local"
...             print 'Value of myVar in innerFunction() = ' + myVar
...     innerFunction()
...
>>> print 'Value of myVar in main program = ' + myVar
Value of myVar in main program = Global
>>> outerFunction()
Value of myVar in outerFunction() = Enclosed
Value of myVar in innerFunction() = Local

   In above example, we have myVar declared thrice with values "Global" in the main program body,
   "Enclosed" inside outerFunction and "Local" in innerFunction, to indicate which namespace value myVar
   takes when referenced at different locations in the program.
   Example 3 : Local, Enclosed, Global and Built-in Scope
   As discussed earlier, the __builtin__ module contains all keywords reserved by Python. To check the
   all of them, we import the module and provide it as an argument to dir() function. We will observe
   some exceptions and built-in functions in the long list returned.
# Snipping the long list
>>> dir(__builtin__)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BufferError', ... , 'tuple', 'type',
 'unichr', 'unicode', 'vars', 'xrange', 'zip']

   Now, we create our own pow() function that does the reverse operation i.e. Exponent to the power Base
   and check if it gets executed before the one in built-in scope.
>>> def pow(base, exp):
...     print 'Result from the pow function = ' + str(exp ** base)
...
>>> def myFunction(base, exp):
...     print 'Calling pow() from myFunction...'
...     pow(base, exp)
...     print 'Result from myFunction = ' + str(base ** exp)
...
>>> myFunction(3, 4)
Calling pow() from myFunction...
Result from the pow function = 64
Result from myFunction = 81

   From the above results, we observe that, the pow() function from the global scope is executed before
   the pow() function in the built-in scope.
   With this, we've come to an end of this article. In this article, we learned mainly about namespace
   and scope. Essentially, we understood how the names are searched in the scopes, based on where they
   are referenced in the program. In the next article, we study about return values and return
   statement. Please share your views and opinions in the comment section below and stay tuned for more
   articles. Thank you.



---
http://www.yourownlinux.com/2016/12/python-funtion-return-statement.html

Python Funtion : 'return' Statement

   Posted on December 08, 2016 by Mandar Shinde

   Python function 'return' statement - In two of our previous articles, we've learned about [18]Python
   function definition & calls and [19]Python namespace & scope. Just like these articles, this one is
   also related to Python as we are going to know about return values and the return statement. I
   recommend you to go through the mentioned articles, to have a clearer idea about this article, as it
   is linked to them.
   [20]python-function-return-statement
   Lets start this discussion with the important takeaways from the earlier articles on Python function:
    1. A function can be defined using the def keyword, the name of the function, followed by a pair of
       parenthesis.
    2. A function can have parameters to store the value of the argument, when the function is called.
    3. Then follows indented block of statements, where the entire logic is incorporated.
    4. We can call a function with its name and the parenthesis like myFunc().
    5. We can define arguments to send some information to the function.
    6. Any variables used inside a function are stored in its local namespace.
    7. We have global namespace where all the variable names declared in the program body (outside
       functions) reside.
    8. We have enclosed namespace when two or more functions are nested, the variable names used in
       enclosing functions are stored in enclosed namespace.
    9. The built-in namespace consists mainly of Python keywords, functions and exceptions.
   10. A name is searched in these namespaces in a specific order as per LEGB rule i.e. Local, Enclosed,
       Global and Built-in.

Return Values and return Statement
   So far, we have used functions to perform some tasks and print the result, may it be a simple string
   or the table of a number or some power of some number, using the print statement. A print statement
   writes the output to the screen (stdout), which cannot be used for further processing. Say, if we
   have two functions power(base, exp) that calculates expth power of base and another function
   cubert(num) to calculate cube root of a number. We wish to calculate a number using power() and pass
   it as an argument to cubert() function. As we are printing out the result on the stdout, we cannot
   use it in another function, even if we had stored it in a variable (remember local namespace and
   global namespace?). So, we need to have a mechanism with which the result from one function can be
   used in the program, as and when needed. And we have return statement.
   The return statement is optional to use. When used, it comes out of the current function and returns
   to the position where it was called i.e. the caller. It also sends back a value to the caller, which
   then can be used anywhere in the program or by another function. The value which needs to be handed
   back (known as return value), is decided by the programmer and it is the argument to the return
   statement, e.g. return object_name. When return is not used, the function returns None by default. To
   demonstrate this, lets check the example of our power() function created in the previous article.
   Example 1 : If return is not used, None is returned.
>>> def power(base, exp) :
...     print str(base) + ' to the power of ' + str(exp) + ' is ' + str(base ** exp)
...
>>> myResult = power(3, 4)
3 to the power of 4 is 81
>>> print myResult
None

   In above example, the function power() just prints the result on the screen, return statement not
   being used. Knowing that the print statement doesn't return anything and return not used, the default
   value None is returned to the caller, which then gets assigned to global variable myResult and
   displayed.
   Example 2 : Returning a value
>>> def power(base, exp) :
...     print str(base) + ' to the power of ' + str(exp) + ' is ' + str(base ** exp)
...     return base ** exp
...
>>> myResult = power(3, 4)
3 to the power of 4 is 81
>>> print myResult
81

   In above example, we actually used the return statement, that returns the result of exponentiation
   operation to the caller. Thus, myResult is assigned with the value returned by the power() and the
   same is printed. Had we written any statements after return, they would not have executed.
   Example 3 : Using return values from another function
# Function fo calculate 'n'th power of a number
>>> def power(base, exp) :
...     return base ** exp
...

# Function to add two numbers
>>> def addition(a, b) :
...     return a + b
...

# Function that user power() and addition() to add squares to two numbers
>>> def myFunction(num1, num2):
...     sqr_num1 = power(num1, 2)
...     sqr_num2 = power(num2, 2)
...     result = addition(sqr_num1, sqr_num2)
...     return result
...
# Function call
>>> myFunction(3, 4)
25
>>> myFunction(8, 6)
100

   In this example, we have two functions power() and addition(), those return the results of
   exponentiation and addition operations respectively. The third function myFunction used these two
   functions to calculate sum of the squares of two numbers and return the result.
   With this, we end our discussion on Python function return values and return statement. In this
   article, we learned how the result of the operations done by a function can be used to be processed
   in the program using return values, which we cannot achieve using print statement. We have already
   discussed on the basics of function arguments, we will be learning about them much more details, in
   the next article. Please share your opinions and views in the comment section below and stay tuned
   for more interesting articles on Python. Thank you!



---
http://www.yourownlinux.com/2016/12/python-function-keyword-defaults-optional-arguments.html

Python Function : Keyword Arguments, Defaults and Optional Arguments

   Posted on December 09, 2016 by Mandar Shinde

   Python function keyword and optional arguments - In the last article on [18]Python functions, we have
   learned about basics of Python functions. The key takeaways from that article are as listed below:
   [19][python-keyword-defaults-arguments.JPG]
     * Function is a sequence of statements grouped together, intended to be re-used in the program.
     * Functions are used to avoid repetition of the code in your program. Functions reduces redundancy
       and improves re-usability. Once you define a function, it can be used any number of times in the
       entire program, or even in other programs (we are yet to see 'Modules', where we can learn more
       about it).
     * We need the def keyword to create a function. It creates an object of function type and assigns a
       name to it, at the runtime. The syntax for defining a function is as below:
def function_name():
    # Block of code starts
    ...
    ...
    ...
    ...
    # Block of code ends

     * When we need to pass some information to a function, we need to use 'parameters' in the function
       definition. While calling the function, we provide information to the function through
       'arguments'.
     * A function, after performing some operations, gives control back to the caller. While doing so, a
       function might return a value (or rather 'an object') to the caller using return statement. A
       function without any return value returns None to the caller.

   In this article, we are going to learn more about Function Arguments in more details. To begin with,
   lets start our discussion be revisiting basics of function arguments.

Function Arguments
   With function arguments, we can pass some information to a function. In order to store these
   arguments, function uses names in the function definition, called as Parameters. These parameters are
   the variables in the local scope of that function, to which values of passed in objects (through
   arguments) are assigned. When we pass the arguments in a function call, the sequence in which objects
   are passed matters a lot. The objects in the argument are assigned to the parameters from left to
   right. Also, the number of arguments being passed must be equal to number of parameters in the
   function definition. Lets verify this with some examples.
>>> def myFunction(x, y):
...     print "Value of 'x' = " + str(x)
...     print "Value of 'y' = " + str(y)
...

>>> myFunction(20, 30)
Value of 'x' = 20
Value of 'y' = 30

>>> myFunction(30, 20)
Value of 'x' = 30
Value of 'y' = 20

   In above example, we have created a function myFunction which can accept two arguments, which then
   will be assigned to variables x and y. In order to verify whether the assignment will be from left to
   right or otherwise, we print the values of x and y. In our first function call myFunction(20,30), x
   (which is the first parameter) is assigned with the value 20 (which is the first argument) and y is
   assigned with the value 30. In our second function call, we swap the order of the arguments and
   observe that, those are matched to the parameters from left to right. So, you can't just randomly
   pass arguments in a function call, the order they are passed in matters a lot. This is the normal way
   of passing arguments. With Keyword arguments, we can specify which parameter must be assigned which
   value, in the function call itself, without bothering about the order, which we see next.

Keyword Arguments
   While making a function call, you can mention the parameter name and assign a value to it, with
   param_name=value syntax, to explicitly instruct the function about the variable assignments. In this
   case, the arguments can be passed in any order.
>>> def myFunction(a, b, c):
...     print "Value of 'a' = " + str(a)
...     print "Value of 'b' = " + str(b)
...     print "Value of 'c' = " + str(c)
...

>>> myFunction(b=20, c=50, a=10)
Value of 'a' = 10
Value of 'b' = 20
Value of 'c' = 50

>>> myFunction(c=20, a=50, b=10)
Value of 'a' = 50
Value of 'b' = 10
Value of 'c' = 20

   In above examples, we have assigned values to the function parameters in the function call itself.
   What would have happened, had we passed only two arguments, instead of three?
>>> myFunction(b=20, c=50)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: myFunction() takes exactly 3 arguments (2 given)

   It throws in exception, saying that 'you have provided only 2 arguments when I expect 3 from you'.
   But what if we want to provide only two arguments or even one, expecting that the function should
   display None if a value is absent? This leads us to discuss on Defaults or Optional arguments.

Optional Arguments

   With defaults, we can assign a default value to a function parameter. While making a function call,
   if the argument is not provided, the parameter takes the default value assigned to it. This not only
   avoids an exception, but makes the argument optional. When the values are specified, default values
   will be overwritten and parameters will be assigned with the values provided in the argument.
# Function with two optional arguments
>>> def welcome(name='User', country='India'):
...     print 'Hello ' + name + '! Welcome to ' + country + '.'
...

# We specify no argument, default arguments will be taken
>>> welcome()
Hello User! Welcome to India.

# We do not mention 'country' here, default value will be taken
>>> welcome(name='Mandar')
Hello Mandar! Welcome to India.

# We overwrite both the default values, using keyword arguments
>>> welcome(name='Mandar', country='America')
Hello Mandar! Welcome to America.

# With non-keyword arguments - order is crucial
>>> welcome('Mandar', 'Russia')
Hello Mandar! Welcome to Russia.

# We specify the name in a variable
>>> name = 'Mandar'
>>> welcome(name, 'Australia')
Hello Mandar! Welcome to Australia.

   In above example, we created a function welcome() that takes two arguments name and country. We
   assign both these variables with default values 'User' and 'India' respectively, making both of these
   arguments optional. If we do not specify any of the argument, it's default value will be printed. If
   we specify it, the default values are overwritten with the values specified. Please observe the
   default value 'User' getting overwritten with the value 'Mandar' and the value 'India' with
   'America'.

Putting it together

   Having learned Keyword arguments and defaults, we create a list of items which we need to purchase
   from market. We consider items 'tomato' and 'onion' as mandatory ones and 'pizza' and 'burger' as
   optional arguments. So, our function accepts at least two and at most four arguments and prints the
   list of items & their quantities we should buy from market.
>>> def itemList(tomato, onion, pizza=0, burger=0):
...     print 'Tomato : ' + str(tomato)
...     print 'Onion : ' + str(onion)
...     print 'Pizza : ' + str(pizza)
...     print 'Burger : ' + str(burger)
...

>>> itemList(2,4)
Tomato : 2
Onion : 4
Pizza : 0
Burger : 0

>>> itemList(2,4,1)
Tomato : 2
Onion : 4
Pizza : 1
Burger : 0

>>> itemList(2,4,burger=1)
Tomato : 2
Onion : 4
Pizza : 0
Burger : 1

>>> itemList(2,4,1,5)
Tomato : 2
Onion : 4
Pizza : 1
Burger : 5

>>> itemList(onion=2,tomato=3)
Tomato : 3
Onion : 2
Pizza : 0
Burger : 0

   With this we close our discussion on passing arguments to functions. We started with normal way of
   passing arguments to a function, in which order of arguments plays the critical role. We then
   discussed on keyword arguments, with which we can pass arguments with parameters assigned with
   values, irrespective of the order they appear in the function definition. We then discussed about
   defaults, which help us create optional arguments. We aren't yet done with arguments though, as we
   are yet to discuss on variable length arguments to a function. We see them in the next article.
   Please share your views and opinions in the comments section below and stay connected. Thank you.



---
http://www.yourownlinux.com/2016/12/python-function-args-kwargs.html

Python Function - Variable Length Arguments with *args and **kwargs

   Posted on December 10, 2016 by Mandar Shinde

   Python *args and **kwargs - We have been discussing Python functions and we have already covered
   [18]Python function definition & call, [19]Variable scopes and [20]Function return values. In the
   last article, we started our discussion on Python function arguments and learned about how arguments
   can be passed in a function call, which also covers keyword arguments and optional arguments. In this
   article, we will study about how a function can take variable length arguments and process them. This
   requires knowledge of Keyword arguments and non-keyword arguments (or normal arguments), so I
   recommend you to go through the last article on [21]Keyword Arguments, Defaults and Optional
   Arguments.

Variable Length Arguments
   A Python function can use * and ** operators to accept or pass variable length argument lists. With
   the * operator, function can accept or pass non-keyworded variable length argument list, while with
   ** a function can accept keyworded variable length argument list. We can mention both of these
   operators in the function definition or function call. Please remember *args and **kwargs are just
   the naming conventions, so as to store non-keyworded argument list into args variable and keyworded
   argument list into kwargs variable. If you use something like *myVar and **myKWVar, that's absolutely
   fine.
   Let's have a look on some examples to have more clarity on *args and **kwargs.
>>> def myFunction(*args):
...     print args
...

>>> myFunction(1, 2, 'Three', 'Four')
(1, 2, 'Three', 'Four')

   In above example, we have created a simple function myFunction() that prints the value stored in args
   variable. When we call it with any number of non-keyworded arguments, it forms a tuple of those
   objects and stored it in variable args. We can check this in output. So, args being a tuple object,
   we can perform all tuple operations - including indexing, slicing, iterating - on it. Please check
   our article on Tuple - [23]Introduction to Python Tuple
   To more elaborate on this, we see another example, in which we create a function sum(), which will
   print the sum of the numbers provided as an argument to it. We know that, all the numbers will be
   stored in a tuple, available in the variable args. We then iterate over this, compute the result and
   print it.
>>> def sum(*args):
...     result = 0
...     for i in args:
...             result += i
...     print 'Sum = ' + str(result)
...

# We pass 6 arguments to 'sum()' function
>>> sum(1, 2, 3, 4, 5, 6)
Sum = 21

# Now, only 3 arguments
>>> sum(7, 8, 9)
Sum = 24

   We now move on to explore **kwargs. As stated above, it stores keyworded variable list arguments,
   hence expects keyworded arguments, in the var_name = value format, to be provided in our function
   call. Lets see what will be the contents of the variable kwargs.
>>> def myFunction(**kwargs):
...     print kwargs
...

>>> myFunction(name='Mandar', country='India', age=25)
{'country': 'India', 'age': 25, 'name': 'Mandar'}

   Well, that's a dictionary! We have already studied about dictionary and basic operations in our
   article - [24]Python Dictionary Comprehension - 'dict' type. kwargs being a Python dictionary object,
   we can perform all dictionary operations on it.
   So far, we have used *args and **kwargs in a function definition. I've already mentioned that, both
   of them can be used in a function call also. How? Lets see this in the following section.

Using *args and **kwargs in a Function call

   To demonstrate this, we create a function which accepts 5 arguments, calculates their sum and prints
   the result. This is very simple.
>>> def sum(a, b, c, d, e):
...     print 'Sum = ' + str( a + b + c + d + e )
...

   As we know, when we used *args in function definition, a tuple is created and stored in the variable
   args. In the similar manner, we create a tuple args containing 5 numbers and provide it in a function
   call as *args, so that Python unpacks them in individual arguments and assigns them to the
   parameters.
>>> args = (10, 20, 30, 40, 50)

>>> sum(*args)
Sum = 150

   Similarly, we create a dictionary kwargs and use **kwargs in the function call, so that Python
   unpacks the dictionary into keyworded argument list and computes the result.
>>> kwargs = {'a':10, 'b':20, 'c':30, 'd':40, 'e':50}

>>> sum(**kwargs)
Sum = 150

Putting it together

   Till now, we have learned normal arguments and variable length arguments. In variable length
   arguments, we have non-keyworded and keyworded arguments. Lets now see how we can use all of them in
   a function definition. While using all of them together, a specific order has to be followed which is
   -
   normal_arg1, normal_arg2, ... , *args, **kwargs
>>> def myFunction(arg1, arg2, arg3, *args, **kwargs):
...     print 'First Normal Argument : ' + str(arg1)
...     print 'Second Normal Argument : ' + str(arg2)
...     print 'Third Normal Argument : ' + str(arg3)
...     print 'Non-keyworded Argument : ' + str(args)
...     print 'Keyworded Argument : ' + str(kwargs)
...

>>> myFunction(1, 2, 3, 4, 5, 6, 7, name='Mandar', country='India', age=25)
First Normal Argument : 1
Second Normal Argument : 2
Third Normal Argument : 3
Non-keyworded Argument : (4, 5, 6, 7)
Keyworded Argument : {'country': 'India', 'age': 25, 'name': 'Mandar'}

   With this, we have come to an end of this discussion on variable length arguments. We also close our
   discussion on Python function arguments. Next, we will see two types of functions- Iterative
   functions and Recursive functions. Please put your views and opinions in the comment section below
   and stay tuned. Thank you!

---
http://www.yourownlinux.com/2016/12/python-recursion-recursive-function-fibonacci-factorial.html

Python Recursion or Recursive Function

   Posted on December 13, 2016 by Mandar Shinde
   
   Python Recursion or Recursive Function - We have been exploring Python functions and we have covered
   Python function basics, Keyword & optional arguments, function return values and variable length
   arguments, so far. Now, we start our discussion on types of function, there are two of them -
   Recursive function and Iterative function. In this article, we will be studying the former one -
   Recursive function or Recursion.
   [18]python-recursion-recursive-function
   In any program, when a function calls itself, we call it Recursive function or Recursion. We can put
   this statement in syntactical form as below:
def myFunction( params ):
    ...
    ...
    ...
    myFunction( params )
    ...
    ...
    ...

   In above syntax, we define a function, perform some operations and call the function again. At each
   step, the function calls itself recursively and performs some operations. So, this obeys the rule of
   recursion and can be called a Recursive function. Looking at this syntax, it might seem to be a never
   ending loop, it may not exit anytime soon. But, in a recursive function, at each step, the problem
   becomes smaller and simpler. So, with each recursive call, function calls itself with a smaller
   version of the main problem statement. At some point, the problem statement should converge at base
   case, where a value is returned and recursion stops. Thus, we can modify above syntax and put it as:
def myFunction( params ):

    # Base case
    if ( base_case_1 ):
        return <some_value>
    elif ( base_case_2 ):
        return <some_other_value>

    ...
    ...
    ...
    myFunction( params )
    ...
    ...
    ...

   Things will be pretty clear when we see a couple of examples of recursion. The first and the most
   popular example is to calculate factorial of a number. A factorial of 'n' is nothing but the product
   of all non-zero positive integers less or equal to n. So, factorial(4) = 4*3*2*1 = 24. In this case,
   we can identify the base case first, which is factorial(1) = 1. So, as soon as n reaches '1', we
   return '1'.
factorial(4) = 4 * 3 * 2 * 1
             = 4 * (3!)
             = 4 * (3 * [2!])
             = 4 * 3 * [2 * 1!]

   If you observe carefully, our main problem is getting disintegrated into small problem, at every
   step. At every step other than base case, we get n * (n-1)!, and our new problem is to solve (n-1)!.
   This way, we approach towards our base case n = 1, which we know is '1'.
>>> def factorial(n):
...     if n == 1:
...             return 1
...     return n * factorial(n-1)

   We have implemented the same logic in above code. If n > 1, it returns n * factorial(n-1), which
   gives us factorial(n-1) - a new sub-problem to solve. Lets us modify the code a bit, to debug what
   exactly is happening inside.
   Example 1: Factorial of a number using recursion
>>> def factorial(n):
...     print 'Calculating factorial(' + str(n) + ')...'
...     if n == 1:
...             return 1
...     result = n * factorial(n-1)
...     print 'Result of ' + str(n) + '* factorial(' + str(n-1) + ') = ' + str(result)
...     return result
...

   Output:
>>> factorial(6)
Calculating factorial(6)...
Calculating factorial(5)...
Calculating factorial(4)...
Calculating factorial(3)...
Calculating factorial(2)...
Calculating factorial(1)...
Result of 2* factorial(1) = 2
Result of 3* factorial(2) = 6
Result of 4* factorial(3) = 24
Result of 5* factorial(4) = 120
Result of 6* factorial(5) = 720
720

   In above output, we can easily see how our problem got decomposed till the base case, which then got
   us the final result returned. We now take a look at another example - Fibonacci series. In a
   Fibonacci series, each number is a sum of its two preceding numbers, first two numbers being 0 and 1.
   So, the series looks like 0, 1, 1, 2, 3, 5, 8, 13, 21, .... Normally, the problem statement is to
   find 'n'th term in the Fibonacci series.
   Example 2: 'n'th term in Fibonacci sequence using recursion
   Considering that our function name fib(n), we have two base cases as fib(0) = 0 and fib(1) = 1. If
   value of n does not match these base cases, we return the sum of n-1th term and n-2th term. It is
   clear that, if nth term in a Fibonacci series is fib(n), then n-1th term would be fib(n-1) and n-2th
   term would be fib(n-2). Thus, we return fib(n-1) + fib(n-2).
>>> def fib(n):
...     if n == 0:
...             return 0
...     elif n == 1:
...             return 1
...     return fib(n-1) + fib(n-2)
...

>>> fib(5)
5

>>> fib(6)
8

>>> fib(8)
21

   Recursion has its own advantages and disadvantages. It takes less code to write recursive functions,
   thus less time. With recursion, a complex task is decomposed into simpler sub-tasks and code to
   perform simpler sub-tasks can be written and implemented for complex task. On the other hand,
   recursion is very hard to understand and debug. Recursive calls consume lot of memory, hence
   considered as expensive. An infinite recursive function may lead to system crash. So, it is very
   crucial to incorporate base cases in recursive functions.
   With this, we end our discussion on Recursion.
   


---
http://www.yourownlinux.com/2016/12/python-lambda-anonymous-function.html

Python 'lambda' or Anonymous Functions

   Posted on December 15, 2016 by Mandar Shinde
   
   Python lambda or anonymous function - We are still learning Python functions and the discussion would
   be incomplete unless there is a mention about Python 'anonymous' functions. We have already studied
   in one of our previous articles, on [18]Function definition, about the def construct. We define a
   function with def followed by the function name and the parameters, if any. With this, Python creates
   an object of type function, which can be used later with the name assigned to it. Besides this,
   Python lets us creates functions, which can be called later, but are not bound or assigned to a name
   – hence called as ’Anonymous’ or Unnamed functions. How to create them?, we learn in this article.
   [19][python-lambda-function.JPG]
   Just like def, in Python, we have another construct lambda that returns a function type without
   assigning a name to it. This return value (a function) can be assigned a name later. As they produce
   a value, they are considered as Expressions, not Statements. (Expressions produce a value, while
   statements perform some task. But, one must remember that, expression is [or a part of] statement.)
   Moreover, where normal function may consist of a block of statements, lambda functions contains only
   one expression. This is because, lambdas are intended to create simple functions. To perform heavier
   tasks, one should definitely create functions using def. While lambda, like normal function, can have
   any number of parameters in the definition. Lets take a look at lambda’s syntax.
   Note: lambda can have only one expression, but any number of parameters in its definition. It is an
   expression, not a statement
   Syntax:
lambda param1, param2, ..., paramN : expression

Using lambda Functions
   Even though there are a few dissimilarities between normal functions and anonymous ones, they being
   of the same type function, do the same tasks for us. Let us write a function to obtain square of a
   number.
>>> def square(num):
...     return num ** 2
...

>>> print square(11)
121
>>> print square(13)
169

   Let’s achieve the same thing using a lambda function. Remember, lambda do not have return statements,
   they have expression, mind that singular form. In this case, we create a lambda function and assign
   the return value (which is a function type) to a name, say sqr.
>>> sqr = lambda num : num ** 2

>>> type(sqr)
<type 'function'>
>>> sqr(11)
121
>>> sqr(13)
169

   Arguments to lambda function work same as that in case of normal functions. We can have keyword
   arguments, defaults and optional arguments in case of lambdas. Let’s check with the keyword arguments
   first.
# lambda function to calculate 'n' power of a number
>>> power = lambda base, exponent : base ** exponent

# 10 ** 2 = 100
>>> print power(10, 2)
100

# This becomes 2 ** 10 = 1024
>>> print power(exponent=10, base=2)
1024

   And, now the defaults.
# lambda function to welcome a user, with default value
>>> welcome = lambda user="Whosoever you are" : 'Welcome, ' + user + ' !!'

# This will take the default value and a rude welcome
>>> welcome()
'Welcome, Whosoever you are !!'

# This will override the default value
>>> welcome('Mandar')
'Welcome, Mandar !!'

   We can also use lambdas in lists and dictionaries in order to choose between several actions to be
   performed. Take a look at below example, in which we have used a dictionary with action name as key
   and lambda function as its value. When you access a key, it will be a function, while if you provide
   it with argument(s), you will get appropriate result.
>>> functions = {'power' : lambda x, y: x**y, 'tenTimes' : lambda x : 10 * x, 'sqrt' : lambda x : x ** 0.5 }

>>> type(functions['tenTimes'])
<type 'function'>

>>> functions['power'](10, 2)
100

>>> functions['tenTimes'](20)
200

>>> functions['sqrt'](224)
14.966629547095765

   Let us now see how we can use lists in the similar context.
>>> funcList = [ lambda x, y: x**y, lambda x : 10 * x, lambda x : x ** 0.5 ]

>>> type(funcList[1])
<type 'function'>

# Power
>>> funcList[0](6, 3)
216

# 'tenTimes'
>>> funcList[1](12)
120

# 'sqrt'
>>> funcList[2](124)
11.135528725660043

   So, we have come to an end of the scope of this article. This article was intended to provide a
   primer on lambdas. The scope for the lambdas to be used is very vast. In the upcoming articles, we
   would be learning about some important functions often useful in functional programming, which would
   also be using lambda functions.

---
http://www.yourownlinux.com/2016/12/python-map-function-examples.html

[17]Python map() Function

   Posted on December 17, 2016 by Mandar Shinde
   Python map() function - Many of times, we may require to execute same operation on different elements
   of a sequence. For this, we create an empty list, write a for loop, perform the operation and append
   result in the list. Python provides a built-in function - map(), to perform the similar operation. It
   receives at least two arguments - a function and one or more iterable objects, applies the function
   on each item of the iterables and returns a list with results of the operation. When we say, map()
   accepts function as an argument, it may be a built-in function or a normal function created using def
   construct or it can be a lambda. We will be learning how each of them can be used in the map
   function. But, I recommend you to have a read over our article on [18]Python lambda function, if you
   haven't already.

Python map() function

   As mentioned above, the map() function accepts a function (without parenthesis) and one or more
   iterables as arguments. So, we can write its syntax as below:
   Syntax:
map(function, iterable1, iterable2, ...)

   Example 1 : Converting an integer to binary equivalent, with built-in function 'bin()'
>>> myList = range(1, 11)

>>> myList
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

>>> print map(bin, myList)
['0b1', '0b10', '0b11', '0b100', '0b101', '0b110', '0b111', '0b1000', '0b1001', '0b1010']

   In above example, map function takes a function bin() (without parenthesis), which returns binary
   equivalent of a number, and a list myList. It applies bin() function on every list item and returns a
   list of result values. If this seems confusing, we take another example. Before that, we see what we
   would have done, if we weren't aware about map() function - a for loop may be.
# Create a list of numbers
>>> myList = range(1, 11)
>>> myList
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Create an empty list to store the result
>>> result = []

# Iterate over each item, run 'bin()' function on it and append result to 'result' list
>>> for num in myList:
...     result.append(bin(num))
...

>>> print result
['0b1', '0b10', '0b11', '0b100', '0b101', '0b110', '0b111', '0b1000', '0b1001', '0b1010']

   Example 2: Square root of numbers using 'math.sqrt()' function
# Create a list
>>> myList = range(1,6)
>>> myList
[1, 2, 3, 4, 5]

# Import 'math' module
>>> import math

# Run 'math.sqrt()' on each list item
>>> print map(math.sqrt, myList)
[1.0, 1.4142135623730951, 1.7320508075688772, 2.0, 2.23606797749979]

   Simple, isn't it? We just had to import math module, in order to use sqrt() function within a map()
   function. Now, we create a function using def and use it in map(). Our function cube() accepts an
   argument and returns it's cube i.e. it's 3rd power.
   Example 3 : Cube of numbers using 'cube()' function created using def
# Define the function
>>> def cube(num):
...     return num ** 3
...

# Create a list
>>> myList = range(1, 11)
>>> myList
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Use function and list in 'map()' function
>>> map(cube, myList)
[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]

   Another example we take, in which we determine if a number in a list is even or odd. This would be a
   very simple function to create, which returns 'Even' or 'Odd' as per the input received.
   Example 4: Determining a number is Even or Odd
# Create the test data
>>> myList = range(1, 11)
>>> myList
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Create our 'evenOdd()' function
>>> def evenOdd(num) :
...     if num % 2 == 0:
...             return'Even'
...     return 'Odd'
...

# Use them in 'map()' function
>>> print map(evenOdd, myList)
['Odd', 'Even', 'Odd', 'Even', 'Odd', 'Even', 'Odd', 'Even', 'Odd', 'Even']

   As we have seen in our article on [20]lambdas, lambdas return a function type. So, we can use them in
   map() function also.
   Example 5: Determine whether a number is perfectly divisible by 5
# Create a list of numbers
>>> myList = range(1, 21, 3)
>>> myList
[1, 4, 7, 10, 13, 16, 19]

# Crate a lambda function and assign it to the name 'div5'.
# Function should return 'Yes' if number is divisible by 5, else 'No'
>>> div5 = lambda num : 'Yes' if (num % 5 == 0) else 'No'

# Use 'div5()' and 'myList' in 'map()' function
>>> print map(div5, myList)
['No', 'No', 'No', 'Yes', 'No', 'No', 'No']

   Instead of assigning a lambda to a name, we can directly use it in map(), as it returns a function
   object, as shown below.
# lambda function as the argument
>>> print map(lambda num : 'Yes' if (num % 5 == 0) else 'No', myList)
['No', 'No', 'No', 'Yes', 'No', 'No', 'No']

   We can also provide multiple iterable objects to map() functions. In this case, items from all
   iterables are taken in parallel to create a sequence and the sequence is provided as arguments to the
   function. Seems confusing? Lets create three lists and let our function be a lambda that returns a
   tuple of the arguments provided. As a result, we get a list of tuples.
# We create three lists
>>> numList = [1, 2, 3, 4]
>>> strList = ['One', 'Two', 'Three', 'Four']
>>> rankList = ['1st', '2nd', '3rd', '4th']

# lambda function that returns a tuple of it's arguments
>>> lambda x, y, z : (x, y, z)

# Using them in 'map()' function
>>> map(lambda x, y, z : (x, y, z), numList, strList, rankList)
[(1, 'One', '1st'), (2, 'Two', '2nd'), (3, 'Three', '3rd'), (4, 'Four', '4th')]

   In this way, an item each from every list is taken out in parallel and the sequences L1[0], L2[0],
   L3[0], L1[1], L2[1], L3[1], etc. are provided as arguments to the function. If the lengths of the
   lists are unequal, None would be passed as an argument.
# 'rankList' has 5 elements now, 'numList' and 'strList' have 4 each
>>> rankList = ['1st', '2nd', '3rd', '4th', '5th']

>>> map(lambda x, y, z : (x, y, z), numList, strList, rankList)
[(1, 'One', '1st'), (2, 'Two', '2nd'), (3, 'Three', '3rd'), (4, 'Four', '4th'), (None, None, '5th')]

   map() inside another map() - As we know, map() function accepts list as one of the arguments and
   returns a list. So, we can use a list returned by a map() function as an argument to another map()
   function, so that there will be nesting of two map() functions.
# Create a list of numbers
>>> myList = range(1,11)
>>> myList
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Import 'math' module
>>> import math

# First 'map()' function calculate square root of each number
>>> map(math.sqrt, myList)
[1.0, 1.4142135623730951, 1.7320508075688772, 2.0, 2.23606797749979, 2.449489742783178, 2.6457513110645907, 2.
8284271247461903, 3.0, 3.1622776601683795]

# Second 'map()' function will covert float to integer using 'int()' function
>>> print map(int, map(math.sqrt, myList) )
[1, 1, 1, 2, 2, 2, 2, 2, 3, 3]

   We now close our discussion on Python map() function. We have learned how a function, may it be
   built-in or created using def or lambda, can be applied on one or more iterable objects in an
   efficient way, thus avoiding use of for loops. In the next article, we learn about another important
   function used in functional programming - reduce() function.


---
http://www.yourownlinux.com/2016/12/python-reduce-function-examples.html

[17]Python reduce() Function

   Posted on December 20, 2016 by Mandar Shinde
   Python reduce() Function - In one of the recent articles, we have learned about [18]anonymous
   function that can be created using lambda construct. Now we have been learning the functions which
   can be used along with lambda to ease things for us – which are map(), reduce and filter(). We have
   already covered map() function in our [19]last article and in this article, we will learn about
   reduce() function. Let’s begin with the discussion straight away.
   [20][python-reduce-function.JPG]

Using reduce() with lambdas

   As we learned in our article on [21]map() function, it receives minimum of two arguments – a function
   and one or more iterable objects, and run the function on each element of the iterable. It returns a
   list object containing the result of the computation. In the same manner, reduce accepts a function,
   with two arguments and an iterable. It then applies the function on the iterable elements from left
   to right and returns a single value.
   Of the two arguments in the function, say lambda x, y : x + y, first value x is the accumulator,
   which stores the result of the operation and is updated at each step. While the second value y is the
   item from the iterable. We also have an optional third argument initializer to the reduce() function,
   which can be considered as the default accumulator value or it can be thought as if it is placed
   before first element in the iterable. As a result, when we provide an empty iterable and an
   initializer, we get default value returned. If initializer is not mentioned, x takes the value of
   first item in the iterable and y starts iterating from second item onwards.
   Don’t panic if it seems confusing. We will work on some examples and dig them deeper. Let’s start
   with simpler example at first.
   Syntax:
reduce( function, iterable [, initializer] )

   Example :
# Create the iterable object containing numbers
>>> myList = range(1, 11)
>>> myList
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Our lambda function return addition on two numbers
>>> lambda x, y: x + y

# We use our lambda function and the iterable in 'reduce()' function
>>> print reduce( lambda x, y: x + y, myList )
55

   How it works
   In the above example, we have not used the initializer. Due to this, for the first time, x is
   assigned with the first value in the iterable, so x = 1. Now, y starts iterating from second item in
   the iterable onwards. Thus, in the first iteration, x = 1 and y = 2. With this, we call our lambda
   function, which returns the sum 1 + 2 = 3. Now, for the second iteration, result value is stored in
   x, so x = 3 and y gets the next item, means y = 3. Function gets called with this and returns 3 + 3 =
   6. For next iteration, x = 6 and y = 4, the next item from the iterable, and this continues till we
   get the final result.
# Analysis

myList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Iteration - 1
x = 1  -> 1st list item
y = 2  -> 2nd list item
result = 3

# Iteration - 2
x = 3  -> Result from last iteration
y = 3  -> 3rd list item
result = 6

# Iteration - 3
x = 6  -> Result from last iteration
y = 4  -> 4th list item
result = 10

# Iteration - 4
x = 10  -> Result from last iteration
y = 5  -> 5th list item
result = 15

# Iteration - 5
x = 15  -> Result from last iteration
y = 6  -> 6th list item
result = 21

# Iteration - 6
x = 21  -> Result from last iteration
y = 7  -> 4th list item
result = 28

...
...
...

# Last iteration
x = 45  -> Result from last iteration
y = 10  -> 10th list item
result = 55  -> Final result

   We now use third argument in reduce() function - Initializer. With the same example, we assign the
   value 1000 to the initializer.
>>> sum = lambda x, y: x + y
>>> sum
<function <lambda> at 0x7fcfc9c7bcf8>

>>> print reduce( sum, myList, 1000 )
1055

# Analysis

myList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Iteration - 1
x = 1000  -> Initializer
y = 1  -> 1st list item
result = 1001

# Iteration - 2
x = 1001  -> Result from last iteration
y = 2  -> 2nd list item
result = 1003

# Iteration - 3
x = 1003  -> Result from last iteration
y = 3  -> 3rd list item
result = 1006

# Iteration - 4
x = 1006  -> Result from last iteration
y = 4  -> 4th list item
result = 1010

...
...
...

# Last iteration
x = 1045  -> Result from last iteration
y = 10  -> 10th list item
result = 1055  -> Final result

   As we can observe from the result we’ve got, initializer value has made the difference. We now see
   another example of product of the numbers in the list, using reduce function. There will be only one
   change, that too in our lambda function.
# lambda function
>>> product = lambda x, y: x * y

# Iterable object
>>> myList
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Result of 'reduce()' function
>>> print reduce( product, myList )
3628800

# Verifying the result - It's a factorial, isn't it?
>>> 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10
3628800

   In Python, we have operator module that provides functions equivalent to built-in arithmetic (like +,
   -, /, *) and logical operations (like and, or, not). So, for addition, we have operator.add, for
   multiplication, we have operator.mul, and so on. You can check all available options by importing
   operator module and then running dir(operator). For now, we stick to our examples and use functions
   from operator module in place of lambda function.
>>> import operator

>>> myList
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Addition
>>> print reduce( operator.add, myList )
55

# Product / Multiplication
>>> print reduce( operator.mul, myList )
3628800

   We can also have a list of string as the iterator object, for which operator.add would return
   concatenated value of string items, as + operator concatenates two strings. Whereas operator.mul,
   just like * operator, will do the repetition of the string.
# String Concatenation with '+' operator and 'operator.add'

>>> myList = ['My', 'Name', 'Is', 'Bond', ',', 'James', 'Bond' ]

>>> print reduce( operator.add, myList )
MyNameIsBond,JamesBond

>>> print reduce( lambda x , y : x + y, myList )
MyNameIsBond,JamesBond

# String Repetition with '*' operator and 'operator.mul'

>>> myList = ['String ', 1, 2, 3]

# It will print 'String' 6 (1*2*3) times
>>> print reduce( operator.mul, myList )
String String String String String String

>>> print reduce( lambda x, y : x * y, myList )
String String String String String String

   With this, we end our discussion on reduce() function. Its syntax is just like map() function, but
   where map() returns a list, it returns a single value. In the next article, we will be learning about
   another important function useful in functional programming - filter().


---
http://www.yourownlinux.com/2016/12/python-filter-function.html

[17]Python filter() Function

   Posted on December 29, 2016 by Mandar Shinde
   Python filter() Function - We have been learning some of the important utilities used in function
   programming that includes functions – map(), reduce() and filter(). We have already covered [18]map()
   function and [19]reduce() in our recent articles. In this article, we will learn about filter()
   function. Let’s begin with the discussion straight away.

Using filter() with lambdas

   As the name suggests, filter() function filters out some elements from a sequence. Just like map()
   and reduce() functions, this function receives two arguments – a function and an iterable object. The
   function is usually called as filter and returns either True or False. This function is then executed
   on each element of the iterable. As a result, we get a list of items for which the filter returns
   True.
   Don’t be afraid, if its difficult to understand, we will see some examples and explain them in
   details. To begin with, we try to extract even number from a list of numbers. We need to create the
   filter, at first. We can use a normal function or a lambda, but it should return either True or False
   only, nothing else.
   Syntax:
filter( function, iterable_object )

   Example :
# Create the data set
>>> myList = range(1,16)
>>> myList
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

# A very simple filter
>>> def filterEven(num):
...     if num % 2 == 0:
...             return True
...     else:
...             return False
...

# Output
>>> print filter(filterEven, myList)
[2, 4, 6, 8, 10, 12, 14]

# A better version of above filter
>>> def filterEven(num):
...     return num % 2 == 0
...

# Output
>>> print filter(filterEven, myList)
[2, 4, 6, 8, 10, 12, 14]

# Using a lambda function
>>> filterEven = lambda num : num % 2 == 0

# Output
>>> print filter(filterEven, myList)
[2, 4, 6, 8, 10, 12, 14]

# Using lambda directly inside 'filter()'
>>> print filter(lambda num : num % 2 == 0, myList)
[2, 4, 6, 8, 10, 12, 14]

   How it works
   In the above examples, we have a function that returns True if a number is even, False otherwise. So,
   it will start iterating through the iterable, and pass the item to the function as an argument. If
   for a particular item, function returns True, it is added to the output list, otherwise skipped. In
   the end, we get a list of all those items for which function has retuned True. If we were to write an
   equivalent code to have the same behavior, code would have looked like -
>>> def myFilter(varList):
...     result = []
...     for i in varList:
...             if i % 2 == 0:
...                     result.append(i)
...     return result
...

>>> myList
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

>>> myFilter(myList)
[2, 4, 6, 8, 10, 12, 14]

   We take another simple example. In this, we will filter the non-negative numbers from a sequence of
   numbers. The logic to construct a filter is very simply and should be clear.
# Create the test data
>>> myList = range(-10,11)
>>> myList
[-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Create the filter
>>> def filterNonNegative(num):
...     return num >= 0
...

# Use filter with the list in 'filter()'
>>> print filter(filterNonNegative, myList)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Using lambda inside 'filter()'
>>> print filter(lambda num : num >= 0, myList)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

   In the next example, we work on a list of strings, may be a list of names of continents, and filter
   out the ones who have less than 8 characters in them. Pretty simple, isn’t it?
# List of continents
>>> myList = ['Asia', 'Africa', 'Australia', 'Europe', 'North America', 'South America', 'Antarctica']

# The filter
>>> def filterSmall(myStr):
...     return len(myStr) < 8
...

# Output
>>> print filter(filterSmall, myList)
['Asia', 'Africa', 'Europe']

# With lambda inside 'filter()'
>>> print filter(lambda myStr : len(myStr) < 8, myList)
['Asia', 'Africa', 'Europe']

   With this, we close our discussion on filter() function. It was pretty straight forward to understand
   and use. We just need a
   filter - a function which returns Boolean values and an iterable. As a result, we get a list with
   items for which filter returned True.

   
   
---
http://www.yourownlinux.com/2017/06/python-bubble-sort-algorithm.html

Monday, 26 June 2017
Python - Bubble Sort Algorithm Implementation

   Bubble sort algorithm - In this article, we will learn about one of the sorting algorithms - Bubble
   sort. Time complexity of this algorithm is O(n^2) and space complexity being O(1).

Bubble Sort Algorithm

for i = 0 to [length(array) - 1]
begin
    # To keep track of whether a swap has happened
    flag = 0

    # Last 'i' elements will always be sorted
    for j = 0 to [length(array) - i - 1]
    begin

        # Check if array[j] > array[j+1], Swap if True
        if array[j] > array[j+1]
        begin
            swap array[j] and array[j+1]
            flag = 1
        endif
    endfor

    if flag == 0
    begin
        break
    endif

endfor

return array

Example

   Consider the following list-
   [13][1-bubble-sort.JPG]
   Here, length of the array is 8, hence there outer loop, which we will refer to as a pass, will be
   executed 8 times, while inner loop will be executed (8 - 0 - 1) times. Lets see the first pass.
   Pass 1-1:
i = 0, j = 0
array[0] = 5, array[0+1] = 3
array[0] > array[1]
Result - 5 and 3 will be swapped.

   [14][2-bubble-sort.JPG]
   Pass 1-2:
i = 0, j = 1
array[1] = 5, array[1+1] = 7
array[1] < array[2]
Result - Nothing happens

   [15][3-bubble-sort.JPG]
   Pass 1-3:
i = 0, j = 2
array[2] = 7, array[2+1] = 1
array[2] > array[3]
Result - 7 and 1 will be swapped

   [16][4-bubble-sort.JPG]
   Pass 1-4:
i = 0, j = 3
array[3] = 7, array[3+1] = 4
array[3] > array[4]
Result - 7 and 4 will be swapped

    [17] [5-bubble-sort.JPG]
   Pass 1-5:
i = 0, j = 4
array[4] = 7, array[4+1] = 8
array[4] < array[5]
Result - Nothing happens

   [18][6-bubble-sort.JPG]
   Pass 1-6:
i = 0, j = 5
array[5] = 8, array[5+1] = 2
array[5] > array[6]
Result - 8 and 2 will be swapped

   [19][7-bubble-sort.JPG]
   Pass 1-7:
i = 0, j = 6
array[6] = 8, array[6+1] = 6
array[7] > array[7]
Result - 8 and 6 will be swapped

   Observation - After once complete pass, it can be observed that, the largest element in the array is
   bubbled up to the last position in the array. In another words, after one pass, one element in the
   array is sorted. Also, if no swap happens, it can be concluded that the array is sorted and we can
   break out of the loop. To keep track of this, we have introduced variable flag in the algorithm.
   Similarly, after subsequent passes, array will look like -
   [21][9-bubble-sort.JPG]
   After the 5th pass, there will be no swapping. Hence there is no need for more iterations and the
   process can be stopped.

Python Implementation:

def bubble_sort(array):
    n = len(array)

    for i in range(n):
        flag = 0

        for j in range(n-i-1):
            if array[j] > array[j+1]:
                array[j], array[j+1] = array[j+1], array[j]
                flag = 1

        if flag == 0:
            break

my_array = [5, 3, 7, 1, 4, 8, 2, 6]
bubble_sort(my_array)
print my_array

   Output:
[1, 2, 3, 4, 5, 6, 7, 8]


---
http://www.yourownlinux.com/2017/06/python-selection-sort-algorithm.html


Monday, 26 June 2017
Python - Selection Sort Algorithm Implementation

   Selection sort algorithm - In this article, we will learn about another sorting algorithm - Selection
   sort. Just like Bubble sort, time complexity of this algorithm is O(n^2) and space complexity being
   O(1).

Selection Sort Algorithm

i = 0

while i < length(array)
begin
    search for minimum element in the list array[i:]
    exchange the minimum element with array[i]
    increment i by 1
end

Example

   Consider the following list-
   [13][1-bubble-sort.JPG]
   Iteration 1:
   [14][1-selection-sort.JPG]
   Iteration 2:
   [15][2-selection-sort.JPG]
   Iteration 3:
   [16][3-selection-sort.JPG]
   Iteration 4:
   [17][4-selection-sort.JPG]
   Iteration 5:
   [18][5-selection-sort.JPG]
   Iteration 6:
   [19][6-selection-sort.JPG]
   Iteration 7:
   [20][7-selection-sort.JPG]
   Iteration 8:
   [21][8-selection-sort.JPG]

Python Implementation:

def selection_sort(array):
    n = len(array)

    for i in range(n):

        # Index of smallest element
        min_index = i

        for j in range(i+1, n):
            if array[j] < array[min_index]:
                min_index = j

        array[min_index], array[i] = array[i], array[min_index]

my_array = [5, 3, 7, 1, 4, 8, 2, 6]
selection_sort(my_array)
print my_array

   Output:
[1, 2, 3, 4, 5, 6, 7, 8]


---
http://www.yourownlinux.com/2017/06/python-insertion-sort-algorithm.html

Tuesday, 27 June 2017
Python - Insertion Sort Algorithm Implementation

   Insertion sort algorithm - In the last couple of articles, we studied Bubble sort and Selection sort
   algorithms. In this article, we will learn about another sorting algorithm - Insertion sort. Just
   like Bubble sort and selection sort, time complexity of this algorithm is O(n^2) and space complexity
   being O(1).

Selection Sort Algorithm

1. First element i.e. element at index 0 is always sorted and is the part of sorted sub-list
2. Select next element
3. Compare it with all elements in sorted sub-list
4. If the value of the element is smaller, swap it with the element(s) in sorted sub-list
5. Continue till we get an element from sorted sub-list which is smaller than the element
6. Insert the element in the sorted sub-list
7. Get the next element
7. Repeat this process for selected element

Example

   Consider the following list-
   [13][1-insertion-sort.JPG]
   Initially, the first element in the list is already sorted. Hence we add that to sorted sub-list
   identified with green color.
   [14][1-1-Insertion-sort.JPG]
   Iteration 1:
   Compare element at index 1 with the elements in sorted sub-list and insert at appropriate location.
   Here, array[0] > array[1], so array[1] should appear before array[0]. Hence we swap them to adjust
   their positions.
   [15][2-insertion-sort.JPG]
   Iteration 2:
   In this case, array[2] > array[1], hence nothing needs to be required as it is already at appropriate
   position.
   [16][3-insertion-sort.JPG]
   Iteration 3:
   In this case, array[3] < array[2], so we swap them so that array[3]=7 and array[2]=1. Now, array[2]
   which is 1 is again less than array[1], so we swap them again such that array[1]=1 and array[2]=5.
   Now also, array[1] > array[0], so we swap these elements such that array[0]=1 and array[1]=3 and we
   are done.
   [17][4-insertion-sort.JPG]
   Iteration 4:
   [18][5-insertion-sort.JPG]
   Iteration 5:
   [19][6-insertion-sort.JPG]
   Iteration 6:
   [20][7-insertion-sort.JPG]
   Iteration 7:
   [21][8-insertion-sort.JPG]

Python Implementation:

def insertion_sort(array):

    n = len(array)

    for i in range(1, n):
        j = i
        current = array[j]
        while j > 0 and array[j-1] > current:
            array[j] = array[j-1]
            j -= 1
        array[j] = current


my_array = [5, 3, 7, 1,4, 8, 2, 6]
insertion_sort(my_array)
print my_array

   Output:
[1, 2, 3, 4, 5, 6, 7, 8]



---
