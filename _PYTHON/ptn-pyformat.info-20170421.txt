filename: pyformat.info_20170421.txt
https://pyformat.info/

PyFormat Using % and .format() for great good!

   Python has had awesome string formatters for many years but the documentation on them is far too
   theoretic and technical. With this site we try to show you the most common use-cases covered by the
   [2]old and [3]new style string formatting API with practical examples.

   All examples on this page work out of the box with with Python 2.7, 3.2, 3.3, 3.4, and 3.5 without
   requiring any additional libraries.

   Further details about these two formatting methods can be found in the official Python documentation:

   * [4]old style:
--------------------------------------------------------------------------------------------------------------
https://docs.python.org/2/library/stdtypes.html#string-formatting
...
     
     5.6.2. String Formatting Operations
String and Unicode objects have one unique built-in operation: the % operator (modulo). This is also known as
the string formatting or interpolation operator. Given format % values (where format is a string or Unicode
object), % conversion specifications in format are replaced with zero or more elements of values. The effect
is similar to the using sprintf() in the C language. If format is a Unicode object, or if any of the objects
being converted using the %s conversion are Unicode objects, the result will also be a Unicode object.

If format requires a single argument, values may be a single non-tuple object. [5] Otherwise, values must be a
tuple with exactly the number of items specified by the format string, or a single mapping object (for example,
a dictionary).

A conversion specifier contains two or more characters and has the following components, which must occur in
this order:

The '%' character, which marks the start of the specifier.
Mapping key (optional), consisting of a parenthesised sequence of characters (for example, (somename)).
Conversion flags (optional), which affect the result of some conversion types.
Minimum field width (optional). If specified as an '*' (asterisk), the actual width is read from the next
element of the tuple in values, and the object to convert comes after the minimum field width and optional 
.
Precision (optional), given as a '.' (dot) followed by the precision. If specified as '*' (an asterisk), the
actual width is read from the next element of the tuple in values, and the value to convert comes after the precision.
Length modifier (optional).
Conversion type.
When the right argument is a dictionary (or other mapping type), then the formats in the string must include a
parenthesised mapping key into that dictionary inserted immediately after the '%' character. The mapping key
selects the value to be formatted from the mapping. For example:

>>>
>>> print '%(language)s has %(number)03d quote types.' % \
...       {"language": "Python", "number": 2}
Python has 002 quote types.
In this case no * specifiers may occur in a format (since they require a sequential parameter list).

The conversion flag characters are:

Flag	Meaning
'#'	The value conversion will use the “alternate form” (where defined below).
'0'	The conversion will be zero padded for numeric values.
'-'	The converted value is left adjusted (overrides the '0' conversion if both are given).
' '	(a space) A blank should be left before a positive number (or empty string) produced by a signed
	conversion.
'+'	A sign character ('+' or '-') will precede the conversion (overrides a “space” flag).

A length modifier (h, l, or L) may be present, but is ignored as it is not necessary for Python – so e.g. %ld
	is identical to %d.

The conversion types are:

Conversion	Meaning	Notes
'd'	Signed integer decimal.	 
'i'	Signed integer decimal.	 
'o'	Signed octal value.	(1)
'u'	Obsolete type – it is identical to 'd'.	(7)
'x'	Signed hexadecimal (lowercase).	(2)
'X'	Signed hexadecimal (uppercase).	(2)
'e'	Floating point exponential format (lowercase).	(3)
'E'	Floating point exponential format (uppercase).	(3)
'f'	Floating point decimal format.	(3)
'F'	Floating point decimal format.	(3)
'g'	Floating point format. Uses lowercase exponential format if exponent is less than -4 or not less than
	precision, decimal format otherwise.	(4)
'G'	Floating point format. Uses uppercase exponential format if exponent is less than -4 or not less than
	precision, decimal format otherwise.	(4)
'c'	Single character (accepts integer or single character string).	 
'r'	String (converts any Python object using repr()).	(5)
's'	String (converts any Python object using str()).	(6)
'%'	No argument is converted, results in a '%' character in the result.

Notes:
(1) The alternate form causes a leading zero ('0') to be inserted between left-hand padding and the formatting
    of the number if the leading character of the result is not already a zero.
(2) The alternate form causes a leading '0x' or '0X' (depending on whether the 'x' or 'X' format was used) to be
    inserted before the first digit.
(3) The alternate form causes the result to always contain a decimal point, even if no digits follow it.
    The precision determines the number of digits after the decimal point and defaults to 6.
(4) The alternate form causes the result to always contain a decimal point, and trailing zeroes are not removed
    as they would otherwise be.
    The precision determines the number of significant digits before and after the decimal point and defaults to 6.
(5) The %r conversion was added in Python 2.0.
    The precision determines the maximal number of characters used.
(6) If the object or format provided is a unicode string, the resulting string will also be unicode.
    The precision determines the maximal number of characters used.
(7) See PEP 237.

Since Python strings have an explicit length, %s conversions do not assume that '\0' is the end of the string.

Changed in version 2.7: %f conversions for numbers whose absolute value is over 1e50 are no longer replaced by %g conversions.

Additional string operations are defined in standard modules string and re.
--------------------------------------------------------------------------------------------------------------
     
     * [5]new style --> se at the end of this article ...

Basic formatting
   Simple positional formatting is probably the most common use-case. Use it if the order of your
   arguments is not likely to change and you only have very few elements you want to concatenate.

   Since the elements are not represented by something as descriptive as a name this simple style should
   only be used to format a relatively small number of elements.

Old
'%s %s' % ('one', 'two')

New
'{} {}'.format('one', 'two')

Output
one two

Old
'%d %d' % (1, 2)

New
'{} {}'.format(1, 2)

Output
1 2

   With new style formatting it is possible (and in Python 2.6 even mandatory) to give placeholders an
   explicit positional index.
   This allows for re-arranging the order of display without changing the arguments.
   This operation is not available with old-style formatting.

New
'{1} {0}'.format('one', 'two')

Output
two one

Value conversion
   The new-style simple formatter calls by default the [20]__format__() method of an object for its
   representation. If you just want to render the output of str(...) or repr(...) you can use the !s or
   !r conversion flags.

   In %-style you usually use %s for the string representation but there is %r for a repr(...)
   conversion.

Setup
class Data(object):

    def __str__(self):
        return 'str'

    def __repr__(self):
        return 'repr'

Old
'%s %r' % (Data(), Data())

New
'{0!s} {0!r}'.format(Data())

Output
str repr

   In Python 3 there exists an additional conversion flag that uses the output of repr(...) but uses
   ascii(...) instead.

Setup
class Data(object):

    def __repr__(self):
        return 'rÃ¤pr'

Old
'%r %a' % (Data(), Data())

New
'{0!r} {0!a}'.format(Data())

Output
rÃ¤pr r\xe4pr

Padding and aligning strings
   By default values are formatted to take up only as many characters as needed to represent the
   content. It is however also possible to define that a value should be padded to a specific length.

   Unfortunately the default alignment differs between old and new style formatting. The old style
   defaults to right aligned while for new style it's left.

   Align right:

Old
'%10s' % ('test',)

New
'{:>10}'.format('test')

Output
------test

   Align left:

Old
'%-10s' % ('test',)

New
'{:10}'.format('test')

Output
test------

   Again, new style formatting surpasses the old variant by providing more control over how values are
   padded and aligned.
   You are able to choose the padding character:
   This operation is not available with old-style formatting.

New
'{:_<10}'.format('test')

Output
test______

   And also center align values:

   This operation is not available with old-style formatting.

New

'{:^10}'.format('test')

Output
---test---

   When using center alignment where the length of the string leads to an uneven split of the padding
   characters the extra character will be placed on the right side:

   This operation is not available with old-style formatting.

New
'{:^6}'.format('zip')

Output
-zip--

Truncating long strings
   Inverse to padding it is also possible to truncate overly long values to a specific number of
   characters.

   The number behind a . in the format specifies the precision of the output. For strings that means
   that the output is truncated to the specified length. In our example this would be 5 characters.

Old
'%.5s' % ('xylophone',)

New
'{:.5}'.format('xylophone')

Output
xylop

Combining truncating and padding

   It is also possible to combine truncating and padding:

Old
'%-10.5s' % ('xylophone',)

New
'{:10.5}'.format('xylophone')

Output

xylop-----

Numbers
   Of course it is also possible to format numbers.

   Integers:

Old
'%d' % (42,)

New
'{:d}'.format(42)

Output

42

   Floats:

Old
'%f' % (3.141592653589793,)

New
'{:f}'.format(3.141592653589793)

Output
3.141593

Padding numbers
   Similar to strings numbers can also be constrained to a specific width.

Old
'%4d' % (42,)

New
'{:4d}'.format(42)

Output
--42

   Again similar to truncating strings the precision for floating point numbers limits the number of
   positions after the decimal point.

   For floating points the padding value represents the length of the complete output. In the example
   below we want our output to have at least 6 characters with 2 after the decimal point.

Old
'%06.2f' % (3.141592653589793,)

New
'{:06.2f}'.format(3.141592653589793)

Output

003.14

   For integer values providing a precision doesn't make much sense and is actually forbidden in the new
   style (it will result in a ValueError).

Old
'%04d' % (42,)

New
'{:04d}'.format(42)

Output
0042

Signed numbers
   By default only negative numbers are prefixed with a sign. This can be changed of course.

Old
'%+d' % (42,)

New
'{:+d}'.format(42)

Output
+42

   Use a space character to indicate that negative numbers should be prefixed with a minus symbol and a
   leading space should be used for positive ones.

Old
'% d' % ((- 23),)

New
'{: d}'.format((- 23))

Output
-23

Old
'% d' % (42,)

New
'{: d}'.format(42)

Output

-42

   New style formatting is also able to control the position of the sign symbol relative to the padding.
   This operation is not available with old-style formatting.

New
'{:=5d}'.format((- 23))

Output
-..23

New
'{:=+5d}'.format(23)

Output
+..23

Named placeholders
   Both formatting styles support named placeholders.

Setup
data = {'first': 'Hodor', 'last': 'Hodor!'}

Old
'%(first)s %(last)s' % data

New
'{first} {last}'.format(**data)

Output
Hodor Hodor!

   .format() also accepts keyword arguments.

   This operation is not available with old-style formatting.

New
'{first} {last}'.format(first='Hodor', last='Hodor!')

Output
Hodor Hodor!

Getitem and Getattr
   New style formatting allows even greater flexibility in accessing nested data structures.
   It supports accessing containers that support __getitem__ like for example dictionaries and lists:
   This operation is not available with old-style formatting.

Setup
person = {'first': 'Jean-Luc', 'last': 'Picard'}

New
'{p[first]} {p[last]}'.format(p=person)

Output
Jean-Luc Picard

Setup
data = [4, 8, 15, 16, 23, 42]

New
'{d[4]} {d[5]}'.format(d=data)

Output
23 42

   As well as accessing attributes on objects via getattr():
   This operation is not available with old-style formatting.

Setup
class Plant(object):
    type = 'tree'

New
'{p.type}'.format(p=Plant())

Output
tree

   Both type of access can be freely mixed and arbitrarily nested:

   This operation is not available with old-style formatting.

Setup
class Plant(object):
    type = 'tree'
    kinds = [{'name': 'oak'}, {'name': 'maple'}]

New
'{p.type}: {p.kinds[0][name]}'.format(p=Plant())

Output
tree: oak

Datetime
   New style formatting also allows objects to control their own rendering. This for example allows
   datetime objects to be formatted inline:
   This operation is not available with old-style formatting.

Setup
from datetime import datetime

New
'{:%Y-%m-%d %H:%M}'.format(datetime(2001, 2, 3, 4, 5))

Output
2001-02-03 04:05

Parametrized formats
   Additionally, new style formatting allows all of the components of the format to be specified
   dynamically using parametrization. Parametrized formats are nested expressions in braces that can
   appear anywhere in the parent format after the colon.
   Old style formatting also supports some parametrization but is much more limited. Namely it only
   allows parametrization of the width and precision of the output.
   Parametrized alignment and width:

   This operation is not available with old-style formatting.

New
'{:{align}{width}}'.format('test', align='^', width='10')

Output
---test---

   Parametrized precision:

Old
'%.*s = %.*f' % (3, 'Gibberish', 3, 2.7182)

New
'{:.{prec}} = {:.{prec}f}'.format('Gibberish', 2.7182, prec=3)

Output
Gib = 2.718

   Width and precision:

Old
'%*.*f' % (5, 2, 2.7182)

New
'{:{width}.{prec}f}'.format(2.7182, width=5, prec=2)

Output
 2.72

   The nested format can be used to replace any part of the format spec, so the precision example above
   could be rewritten as:

   This operation is not available with old-style formatting.

New
'{:{prec}} = {:{prec}}'.format('Gibberish', 2.7182, prec='.3')

Output
Gib = 2.72

   The components of a date-time can be set separately:

   This operation is not available with old-style formatting.

Setup
from datetime import datetime
dt = datetime(2001, 2, 3, 4, 5)

New
'{:{dfmt} {tfmt}}'.format(dt, dfmt='%Y-%m-%d', tfmt='%H:%M')

Output
2001-02-03 04:05

   The nested formats can be positional arguments. Position depends on the order of the opening curly
   braces:

   This operation is not available with old-style formatting.

New
'{:{}{}{}.{}}'.format(2.7182818284, '>', '+', 10, 3)

Output
.....+2.72

   And of course keyword arguments can be added to the mix as before:

   This operation is not available with old-style formatting.

New
'{:{}{sign}{}.{}}'.format(2.7182818284, '>', 10, 3, sign='+')

Output
.....+2.72

Custom objects
   The datetime example works through the use of the __format__() magic method. You can define custom
   format handling in your own objects by overriding this method. This gives you complete control over
   the format syntax used.

   This operation is not available with old-style formatting.

Setup
class HAL9000(object):

    def __format__(self, format):
        if (format == 'open-the-pod-bay-doors'):
            return "I'm afraid I can't do that."
        return 'HAL 9000'

New
'{:open-the-pod-bay-doors}'.format(HAL9000())

Output
I'm afraid I can't do that.


---
https://docs.python.org/3/library/string.html#string-formatting

6.1. string — Common string operations
   Source code: Lib/string.py

   [19]String Methods

6.1.1. String constants

   The constants defined in this module are:

   string.ascii_letters
          The concatenation of the [22]ascii_lowercase and [23]ascii_uppercase constants described
          below. This value is not locale-dependent.

   string.ascii_lowercase
          The lowercase letters 'abcdefghijklmnopqrstuvwxyz'. This value is not locale-dependent and
          will not change.

   string.ascii_uppercase
          The uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. This value is not locale-dependent and
          will not change.

   string.digits
          The string '0123456789'.

   string.hexdigits
          The string '0123456789abcdefABCDEF'.

   string.octdigits
          The string '01234567'.

   string.punctuation
          String of ASCII characters which are considered punctuation characters in the C locale.

   string.printable
          String of ASCII characters which are considered printable. This is a combination of
          [31]digits, [32]ascii_letters, [33]punctuation, and [34]whitespace.

   string.whitespace
          A string containing all ASCII characters that are considered whitespace. This includes the
          characters space, tab, linefeed, return, formfeed, and vertical tab.

6.1.2. Custom String Formatting

   The built-in string class provides the ability to do complex variable substitutions and value
   formatting via the [37]format() method described in [38]PEP 3101. The [39]Formatter class in the
   [40]string module allows you to create and customize your own string formatting behaviors using the
   same implementation as the built-in [41]format() method.

   class string.Formatter
          The Formatter class has the following public methods:

        format(format_string, *args, **kwargs)
                The primary API method. It takes a format string and an arbitrary set of positional and
                keyword arguments. It is just a wrapper that calls [45]vformat().

                Deprecated since version 3.5: Passing a format string as keyword argument format_string
                has been deprecated.

        vformat(format_string, args, kwargs)
                This function does the actual work of formatting. It is exposed as a separate function
                for cases where you want to pass in a predefined dictionary of arguments, rather than
                unpacking and repacking the dictionary as individual arguments using the *args and
                **kwargs syntax. [47]vformat() does the work of breaking up the format string into
                character data and replacement fields. It calls the various methods described below.

          In addition, the [48]Formatter defines a number of methods that are intended to be replaced by
          subclasses:

        parse(format_string)[49]
                Loop over the format_string and return an iterable of tuples (literal_text, field_name,
                format_spec, conversion). This is used by [50]vformat() to break the string into either
                literal text, or replacement fields.

                The values in the tuple conceptually represent a span of literal text followed by a
                single replacement field. If there is no literal text (which can happen if two
                replacement fields occur consecutively), then literal_text will be a zero-length string.
                If there is no replacement field, then the values of field_name, format_spec and
                conversion will be None.

        get_field(field_name, args, kwargs)[51]
                Given field_name as returned by [52]parse() (see above), convert it to an object to be
                formatted. Returns a tuple (obj, used_key). The default version takes strings of the
                form defined in [53]PEP 3101, such as “0[name]” or “label.title”. args and kwargs are as
                passed in to [54]vformat(). The return value used_key has the same meaning as the key
                parameter to [55]get_value().

        get_value(key, args, kwargs)[56]
                Retrieve a given field value. The key argument will be either an integer or a string. If
                it is an integer, it represents the index of the positional argument in args; if it is a
                string, then it represents a named argument in kwargs.

                The args parameter is set to the list of positional arguments to [57]vformat(), and the
                kwargs parameter is set to the dictionary of keyword arguments.

                For compound field names, these functions are only called for the first component of the
                field name; Subsequent components are handled through normal attribute and indexing
                operations.

                So for example, the field expression ‘0.name’ would cause [58]get_value() to be called
                with a key argument of 0. The name attribute will be looked up after [59]get_value()
                returns by calling the built-in [60]getattr() function.

                If the index or keyword refers to an item that does not exist, then an [61]IndexError or
                [62]KeyError should be raised.

        check_unused_args(used_args, args, kwargs)[63]
                Implement checking for unused arguments if desired. The arguments to this function is
                the set of all argument keys that were actually referred to in the format string
                (integers for positional arguments, and strings for named arguments), and a reference to
                the args and kwargs that was passed to vformat. The set of unused args can be calculated
                from these parameters. [64]check_unused_args() is assumed to raise an exception if the
                check fails.

        format_field(value, format_spec)[65]
                [66]format_field() simply calls the global [67]format() built-in. The method is provided
                so that subclasses can override it.

        convert_field(value, conversion)[68]
                Converts the value (returned by [69]get_field()) given a conversion type (as in the
                tuple returned by the [70]parse() method). The default version understands ‘s’ (str),
                ‘r’ (repr) and ‘a’ (ascii) conversion types.

6.1.3. Format String Syntax[71]

   The [72]str.format() method and the [73]Formatter class share the same syntax for format strings
   (although in the case of [74]Formatter, subclasses can define their own format string syntax). The
   syntax is related to that of [75]formatted string literals, but there are differences.

   Format strings contain “replacement fields” surrounded by curly braces {}. Anything that is not
   contained in braces is considered literal text, which is copied unchanged to the output. If you need
   to include a brace character in the literal text, it can be escaped by doubling: {{ and }}.

   The grammar for a replacement field is as follows:

replacement_field ::=  "{" [[76]field_name] ["!" [77]conversion] [":" [78]format_spec] "}"
field_name        ::=  arg_name ("." [79]attribute_name | "[" [80]element_index "]")*
arg_name          ::=  [[81]identifier | [82]integer]
attribute_name    ::=  [83]identifier
element_index     ::=  [84]integer | [85]index_string
index_string      ::=  <any source character except "]"> +
conversion        ::=  "r" | "s" | "a"
format_spec       ::=  <described in the next section>

   In less formal terms, the replacement field can start with a field_name that specifies the object
   whose value is to be formatted and inserted into the output instead of the replacement field. The
   field_name is optionally followed by a conversion field, which is preceded by an exclamation point
   '!', and a format_spec, which is preceded by a colon ':'. These specify a non-default format for the
   replacement value.

   See also the [86]Format Specification Mini-Language section.

   The field_name itself begins with an arg_name that is either a number or a keyword. If it’s a number,
   it refers to a positional argument, and if it’s a keyword, it refers to a named keyword argument. If
   the numerical arg_names in a format string are 0, 1, 2, ... in sequence, they can all be omitted (not
   just some) and the numbers 0, 1, 2, ... will be automatically inserted in that order. Because
   arg_name is not quote-delimited, it is not possible to specify arbitrary dictionary keys (e.g., the
   strings '10' or ':-]') within a format string. The arg_name can be followed by any number of index or
   attribute expressions. An expression of the form '.name' selects the named attribute using
   [87]getattr(), while an expression of the form '[index]' does an index lookup using
   [88]__getitem__().

   Changed in version 3.1: The positional argument specifiers can be omitted, so '{} {}' is equivalent
   to '{0} {1}'.

   Some simple format string examples:
"First, thou shalt count to {0}"  # References first positional argument
"Bring me a {}"                   # Implicitly references the first positional argument
"From {} to {}"                   # Same as "From {0} to {1}"
"My quest is {name}"              # References keyword argument 'name'
"Weight in tons {0.weight}"       # 'weight' attribute of first positional arg
"Units destroyed: {players[0]}"   # First element of keyword argument 'players'.

   The conversion field causes a type coercion before formatting. Normally, the job of formatting a
   value is done by the [89]__format__() method of the value itself. However, in some cases it is
   desirable to force a type to be formatted as a string, overriding its own definition of formatting.
   By converting the value to a string before calling [90]__format__(), the normal formatting logic is
   bypassed.

   Three conversion flags are currently supported: '!s' which calls [91]str() on the value, '!r' which
   calls [92]repr() and '!a' which calls [93]ascii().

   Some examples:
"Harold's a clever {0!s}"        # Calls str() on the argument first
"Bring out the holy {name!r}"    # Calls repr() on the argument first
"More {!a}"                      # Calls ascii() on the argument first

   The format_spec field contains a specification of how the value should be presented, including such
   details as field width, alignment, padding, decimal precision and so on. Each value type can define
   its own “formatting mini-language” or interpretation of the format_spec.

   Most built-in types support a common formatting mini-language, which is described in the next
   section.

   A format_spec field can also include nested replacement fields within it. These nested replacement
   fields may contain a field name, conversion flag and format specification, but deeper nesting is not
   allowed. The replacement fields within the format_spec are substituted before the format_spec string
   is interpreted. This allows the formatting of a value to be dynamically specified.

   See the [94]Format examples section for some examples.

6.1.3.1. Format Specification Mini-Language[95]

   “Format specifications” are used within replacement fields contained within a format string to define
   how individual values are presented (see [96]Format String Syntax and [97]Formatted string literals).
   They can also be passed directly to the built-in [98]format() function. Each formattable type may
   define how the format specification is to be interpreted.

   Most built-in types implement the following options for format specifications, although some of the
   formatting options are only supported by the numeric types.

   A general convention is that an empty format string ("") produces the same result as if you had
   called [99]str() on the value. A non-empty format string typically modifies the result.

   The general form of a standard format specifier is:
format_spec     ::=  [[[100]fill][101]align][[102]sign][#][0][[103]width][[104]grouping_option][.\
	[105]precision][[106]type]
fill            ::=  <any character>
align           ::=  "<" | ">" | "=" | "^"
sign            ::=  "+" | "-" | " "
width           ::=  [107]integer
grouping_option ::=  "_" | ","
precision       ::=  [108]integer
type            ::=  "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"

   If a valid align value is specified, it can be preceded by a fill character that can be any character
   and defaults to a space if omitted. It is not possible to use a literal curly brace (“{” or “}”) as
   the fill character in a [109]formatted string literal or when using the [110]str.format() method.
   However, it is possible to insert a curly brace with a nested replacement field. This limitation
   doesn’t affect the [111]format() function.

   The meaning of the various alignment options is as follows:

   Option Meaning
   '<' Forces the field to be left-aligned within the available space (this is the default for most
   objects).
   '>' Forces the field to be right-aligned within the available space (this is the default for
   numbers).
   '=' Forces the padding to be placed after the sign (if any) but before the digits. This is used for
   printing fields in the form ‘+000000120’. This alignment option is only valid for numeric types. It
   becomes the default when ‘0’ immediately precedes the field width.
   '^' Forces the field to be centered within the available space.

   Note that unless a minimum field width is defined, the field width will always be the same size as
   the data to fill it, so that the alignment option has no meaning in this case.

   The sign option is only valid for number types, and can be one of the following:

   Option Meaning
   '+' indicates that a sign should be used for both positive as well as negative numbers.
   '-' indicates that a sign should be used only for negative numbers (this is the default behavior).
   space indicates that a leading space should be used on positive numbers, and a minus sign on negative
   numbers.

   The '#' option causes the “alternate form” to be used for the conversion. The alternate form is
   defined differently for different types. This option is only valid for integer, float, complex and
   Decimal types. For integers, when binary, octal, or hexadecimal output is used, this option adds the
   prefix respective '0b', '0o', or '0x' to the output value. For floats, complex and Decimal the
   alternate form causes the result of the conversion to always contain a decimal-point character, even
   if no digits follow it. Normally, a decimal-point character appears in the result of these
   conversions only if a digit follows it. In addition, for 'g' and 'G' conversions, trailing zeros are
   not removed from the result.

   The ',' option signals the use of a comma for a thousands separator. For a locale aware separator,
   use the 'n' integer presentation type instead.

   Changed in version 3.1: Added the ',' option (see also [112]PEP 378).

   The '_' option signals the use of an underscore for a thousands separator for floating point
   presentation types and for integer presentation type 'd'. For integer presentation types 'b', 'o',
   'x', and 'X', underscores will be inserted every 4 digits. For other presentation types, specifying
   this option is an error.

   Changed in version 3.6: Added the '_' option (see also [113]PEP 515).

   width is a decimal integer defining the minimum field width. If not specified, then the field width
   will be determined by the content.

   When no explicit alignment is given, preceding the width field by a zero ('0') character enables
   sign-aware zero-padding for numeric types. This is equivalent to a fill character of '0' with an
   alignment type of '='.

   The precision is a decimal number indicating how many digits should be displayed after the decimal
   point for a floating point value formatted with 'f' and 'F', or before and after the decimal point
   for a floating point value formatted with 'g' or 'G'. For non-number types the field indicates the
   maximum field size - in other words, how many characters will be used from the field content. The
   precision is not allowed for integer values.

   Finally, the type determines how the data should be presented.

   The available string presentation types are:

   Type                                 Meaning
   's'  String format. This is the default type for strings and may be omitted.
   None The same as 's'.

   The available integer presentation types are:

   Type Meaning
   'b' Binary format. Outputs the number in base 2.
   'c' Character. Converts the integer to the corresponding unicode character before printing.
   'd' Decimal Integer. Outputs the number in base 10.
   'o' Octal format. Outputs the number in base 8.
   'x' Hex format. Outputs the number in base 16, using lower- case letters for the digits above 9.
   'X' Hex format. Outputs the number in base 16, using upper- case letters for the digits above 9.
   'n' Number. This is the same as 'd', except that it uses the current locale setting to insert the
   appropriate number separator characters.
   None The same as 'd'.

   In addition to the above presentation types, integers can be formatted with the floating point
   presentation types listed below (except 'n' and None). When doing so, [114]float() is used to convert
   the integer to a floating point number before formatting.

   The available presentation types for floating point and decimal values are:

   Type Meaning
   'e' Exponent notation. Prints the number in scientific notation using the letter ‘e’ to indicate the
   exponent. The default precision is 6.
   'E' Exponent notation. Same as 'e' except it uses an upper case ‘E’ as the separator character.
   'f' Fixed point. Displays the number as a fixed-point number. The default precision is 6.
   'F' Fixed point. Same as 'f', but converts nan to NAN and inf to INF.
   'g'

   General format. For a given precision p >= 1, this rounds the number to p significant digits and then
   formats the result in either fixed-point format or in scientific notation, depending on its
   magnitude.

   The precise rules are as follows: suppose that the result formatted with presentation type 'e' and
   precision p-1 would have exponent exp. Then if -4 <= exp < p, the number is formatted with
   presentation type 'f' and precision p-1-exp. Otherwise, the number is formatted with presentation
   type 'e' and precision p-1. In both cases insignificant trailing zeros are removed from the
   significand, and the decimal point is also removed if there are no remaining digits following it.

   Positive and negative infinity, positive and negative zero, and nans, are formatted as inf, -inf, 0,
   -0 and nan respectively, regardless of the precision.

   A precision of 0 is treated as equivalent to a precision of 1. The default precision is 6.
   'G' General format. Same as 'g' except switches to 'E' if the number gets too large. The
   representations of infinity and NaN are uppercased, too.
   'n' Number. This is the same as 'g', except that it uses the current locale setting to insert the
   appropriate number separator characters.
   '%' Percentage. Multiplies the number by 100 and displays in fixed ('f') format, followed by a
   percent sign.
   None Similar to 'g', except that fixed-point notation, when used, has at least one digit past the
   decimal point. The default precision is as high as needed to represent the particular value. The
   overall effect is to match the output of [115]str() as altered by the other format modifiers.

6.1.3.2. Format examples[116]

   This section contains examples of the [117]str.format() syntax and comparison with the old
   %-formatting.

   In most of the cases the syntax is similar to the old %-formatting, with the addition of the {} and
   with : used instead of %. For example, '%03.2f' can be translated to '{:03.2f}'.

   The new format syntax also supports new and different options, shown in the follow examples.

   Accessing arguments by position:
>>> '{0}, {1}, {2}'.format('a', 'b', 'c')
'a, b, c'
>>> '{}, {}, {}'.format('a', 'b', 'c')  # 3.1+ only
'a, b, c'
>>> '{2}, {1}, {0}'.format('a', 'b', 'c')
'c, b, a'
>>> '{2}, {1}, {0}'.format(*'abc')      # unpacking argument sequence
'c, b, a'
>>> '{0}{1}{0}'.format('abra', 'cad')   # arguments' indices can be repeated
'abracadabra'

   Accessing arguments by name:
>>> 'Coordinates: {latitude}, {longitude}'.format(latitude='37.24N', longitude='-115.81W')
'Coordinates: 37.24N, -115.81W'
>>> coord = {'latitude': '37.24N', 'longitude': '-115.81W'}
>>> 'Coordinates: {latitude}, {longitude}'.format(**coord)
'Coordinates: 37.24N, -115.81W'

   Accessing arguments’ attributes:
>>> c = 3-5j
>>> ('The complex number {0} is formed from the real part {0.real} '
...  'and the imaginary part {0.imag}.').format(c)
'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.'
>>> class Point:
...     def __init__(self, x, y):
...         self.x, self.y = x, y
...     def __str__(self):
...         return 'Point({self.x}, {self.y})'.format(self=self)
...
>>> str(Point(4, 2))
'Point(4, 2)'

   Accessing arguments’ items:
>>> coord = (3, 5)
>>> 'X: {0[0]};  Y: {0[1]}'.format(coord)
'X: 3;  Y: 5'

   Replacing %s and %r:
>>> "repr() shows quotes: {!r}; str() doesn't: {!s}".format('test1', 'test2')
"repr() shows quotes: 'test1'; str() doesn't: test2"

   Aligning the text and specifying a width:
>>> '{:<30}'.format('left aligned')
'left aligned                  '
>>> '{:>30}'.format('right aligned')
'                 right aligned'
>>> '{:^30}'.format('centered')
'           centered           '
>>> '{:*^30}'.format('centered')  # use '*' as a fill char
'***********centered***********'

   Replacing %+f, %-f, and % f and specifying a sign:
>>> '{:+f}; {:+f}'.format(3.14, -3.14)  # show it always
'+3.140000; -3.140000'
>>> '{: f}; {: f}'.format(3.14, -3.14)  # show a space for positive numbers
' 3.140000; -3.140000'
>>> '{:-f}; {:-f}'.format(3.14, -3.14)  # show only the minus -- same as '{:f}; {:f}'
'3.140000; -3.140000'

   Replacing %x and %o and converting the value to different bases:
>>> # format also supports binary numbers
>>> "int: {0:d};  hex: {0:x};  oct: {0:o};  bin: {0:b}".format(42)
'int: 42;  hex: 2a;  oct: 52;  bin: 101010'
>>> # with 0x, 0o, or 0b as prefix:
>>> "int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}".format(42)
'int: 42;  hex: 0x2a;  oct: 0o52;  bin: 0b101010'

   Using the comma as a thousands separator:
>>> '{:,}'.format(1234567890)
'1,234,567,890'

   Expressing a percentage:
>>> points = 19
>>> total = 22
>>> 'Correct answers: {:.2%}'.format(points/total)
'Correct answers: 86.36%'

   Using type-specific formatting:
>>> import datetime
>>> d = datetime.datetime(2010, 7, 4, 12, 15, 58)
>>> '{:%Y-%m-%d %H:%M:%S}'.format(d)
'2010-07-04 12:15:58'

   Nesting arguments and more complex examples:
>>> for align, text in zip('<^>', ['left', 'center', 'right']):
...     '{0:{fill}{align}16}'.format(text, fill=align, align=align)
...
'left<<<<<<<<<<<<'
'^^^^^center^^^^^'
'>>>>>>>>>>>right'
>>>
>>> octets = [192, 168, 0, 1]
>>> '{:02X}{:02X}{:02X}{:02X}'.format(*octets)
'C0A80001'
>>> int(_, 16)
3232235521
>>>
>>> width = 5
>>> for num in range(5,12):
...     for base in 'dXob':
...         print('{0:{width}{base}}'.format(num, base=base, width=width), end=' ')
...     print()
...
    5     5     5   101
    6     6     6   110
    7     7     7   111
    8     8    10  1000
    9     9    11  1001
   10     A    12  1010
   11     B    13  1011

6.1.4. Template strings[118]

   Templates provide simpler string substitutions as described in [119]PEP 292. Instead of the normal
   %-based substitutions, Templates support $-based substitutions, using the following rules:
     * $$ is an escape; it is replaced with a single $.
     * $identifier names a substitution placeholder matching a mapping key of "identifier". By default,
       "identifier" is restricted to any case-insensitive ASCII alphanumeric string (including
       underscores) that starts with an underscore or ASCII letter. The first non-identifier character
       after the $ character terminates this placeholder specification.
     * ${identifier} is equivalent to $identifier. It is required when valid identifier characters
       follow the placeholder but are not part of the placeholder, such as "${noun}ification".

   Any other appearance of $ in the string will result in a [120]ValueError being raised.

   The [121]string module provides a [122]Template class that implements these rules. The methods of
   [123]Template are:

   class string.Template(template)[124]
          The constructor takes a single argument which is the template string.

        substitute(mapping, **kwds)[125]
                Performs the template substitution, returning a new string. mapping is any
                dictionary-like object with keys that match the placeholders in the template.
                Alternatively, you can provide keyword arguments, where the keywords are the
                placeholders. When both mapping and kwds are given and there are duplicates, the
                placeholders from kwds take precedence.

        safe_substitute(mapping, **kwds)[126]
                Like [127]substitute(), except that if placeholders are missing from mapping and kwds,
                instead of raising a [128]KeyError exception, the original placeholder will appear in
                the resulting string intact. Also, unlike with [129]substitute(), any other appearances
                of the $ will simply return $ instead of raising [130]ValueError.

                While other exceptions may still occur, this method is called “safe” because
                substitutions always tries to return a usable string instead of raising an exception. In
                another sense, [131]safe_substitute() may be anything other than safe, since it will
                silently ignore malformed templates containing dangling delimiters, unmatched braces, or
                placeholders that are not valid Python identifiers.

          [132]Template instances also provide one public data attribute:

        template[133]
                This is the object passed to the constructor’s template argument. In general, you
                shouldn’t change it, but read-only access is not enforced.

   Here is an example of how to use a Template:
>>> from string import Template
>>> s = Template('$who likes $what')
>>> s.substitute(who='tim', what='kung pao')
'tim likes kung pao'
>>> d = dict(who='tim')
>>> Template('Give $who $100').substitute(d)
Traceback (most recent call last):
...
ValueError: Invalid placeholder in string: line 1, col 11
>>> Template('$who likes $what').substitute(d)
Traceback (most recent call last):
...
KeyError: 'what'
>>> Template('$who likes $what').safe_substitute(d)
'tim likes $what'

   Advanced usage: you can derive subclasses of [134]Template to customize the placeholder syntax,
   delimiter character, or the entire regular expression used to parse template strings. To do this, you
   can override these class attributes:
     * delimiter – This is the literal string describing a placeholder introducing delimiter. The
       default value is $. Note that this should not be a regular expression, as the implementation will
       call [135]re.escape() on this string as needed.
     * idpattern – This is the regular expression describing the pattern for non-braced placeholders
       (the braces will be added automatically as appropriate). The default value is the regular
       expression [_a-z][_a-z0-9]*.
     * flags – The regular expression flags that will be applied when compiling the regular expression
       used for recognizing substitutions. The default value is re.IGNORECASE. Note that re.VERBOSE will
       always be added to the flags, so custom idpatterns must follow conventions for verbose regular
       expressions.
       New in version 3.2.

   Alternatively, you can provide the entire regular expression pattern by overriding the class
   attribute pattern. If you do this, the value must be a regular expression object with four named
   capturing groups. The capturing groups correspond to the rules given above, along with the invalid
   placeholder rule:
     * escaped – This group matches the escape sequence, e.g. $$, in the default pattern.
     * named – This group matches the unbraced placeholder name; it should not include the delimiter in
       capturing group.
     * braced – This group matches the brace enclosed placeholder name; it should not include either the
       delimiter or braces in the capturing group.
     * invalid – This group matches any other delimiter pattern (usually a single delimiter), and it
       should appear last in the regular expression.

6.1.5. Helper functions[136]

   string.capwords(s, sep=None)[137]
          Split the argument into words using [138]str.split(), capitalize each word using
          [139]str.capitalize(), and join the capitalized words using [140]str.join(). If the optional
          second argument sep is absent or None, runs of whitespace characters are replaced by a single
          space and leading and trailing whitespace are removed, otherwise sep is used to split and join
          the words.
