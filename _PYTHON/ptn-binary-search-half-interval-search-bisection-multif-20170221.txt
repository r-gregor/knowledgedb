filename: /c/Users/gregor.redelonghi/Dropbox/ODPRTO/_PYTHON/python_binary-search_half-interval-search_bisection-multif_20170221.txt
https://interactivepython.org/runestone/static/pythonds/SortSearch/TheBinarySearch.html

5.4. The Binary Search
   It is possible to take greater advantage of the ordered list if we are clever with our comparisons.
   In the sequential search, when we compare against the first item, there are at most \(n-1\) more
   items to look through if the first item is not what we are looking for. Instead of searching the list
   in sequence, a binary search will start by examining the middle item. If that item is the one we are
   searching for, we are done. If it is not the correct item, we can use the ordered nature of the list
   to eliminate half of the remaining items. If the item we are searching for is greater than the middle
   item, we know that the entire lower half of the list as well as the middle item can be eliminated
   from further consideration. The item, if it is in the list, must be in the upper half.

   We can then repeat the process with the upper half. Start at the middle item and compare it against
   what we are looking for. Again, we either find it or split the list in half, therefore eliminating
   another large part of our possible search space. Figure 3 shows how this algorithm can quickly
   find the value 54. The complete function is shown in CodeLens 3.
   ../_images/binsearch.png

   Figure 3: Binary Search of an Ordered List of Integers
   
  +------+------+------+------+------+------+------+------+------+------+
  |  17  |  20  |  26  |  31  |  44  |  54  |  55  |  65  |  77  |  93  |
  +------+------+------+------+------+------+------+------+------+------+
                                ^ |     ^            | ^
                                | |     |            | |
                                | |     +------------+ |
                                | |                    |
                                | +--------------------+
                          start |
   
   
   Binary Search of an Ordered List (search3)

   Before we move on to the analysis, we should note that this algorithm is a great example of a divide
   and conquer strategy. Divide and conquer means that we divide the problem into smaller pieces, solve
   the smaller pieces in some way, and then reassemble the whole problem to get the result. When we
   perform a binary search of a list, we first check the middle item. If the item we are searching for
   is less than the middle item, we can simply perform a binary search of the left half of the original
   list. Likewise, if the item is greater, we can perform a binary search of the right half. Either way,
   this is a recursive call to the binary search function passing a smaller list. CodeLens 4 shows
   this recursive version.

   A Binary Search--Recursive Version (search4)

5.4.1. Analysis of Binary Search
   To analyze the binary search algorithm, we need to recall that each comparison eliminates about half
   of the remaining items from consideration. What is the maximum number of comparisons this algorithm
   will require to check the entire list? If we start with n items, about \(\frac{n}{2}\) items will be
   left after the first comparison. After the second comparison, there will be about \(\frac{n}{4}\).
   Then \(\frac{n}{8}\), \(\frac{n}{16}\), and so on. How many times can we split the list? Table 3
   helps us to see the answer.

   CAPTION: Table 3: Tabular Analysis for a Binary Search¶

   Comparisons Approximate Number of Items Left
   1           n/2
   2           n/4
   3           n/8
   ...
   i           n/2^i
   
   When we split the list enough times, we end up with a list that has just one item. Either that is the
   item we are looking for or it is not. Either way, we are done. The number of comparisons necessary to
   get to this point is i where \(\frac {n}{2^i} =1\). Solving for i gives us \(i=\log n\). The maximum
   number of comparisons is logarithmic with respect to the number of items in the list. Therefore, the
   binary search is \(O(\log n)\).

   One additional analysis issue needs to be addressed. In the recursive solution shown above, the
   recursive call,

	binarySearch(alist[:midpoint],item)

   uses the slice operator to create the left half of the list that is then passed to the next
   invocation (similarly for the right half as well). The analysis that we did above assumed that the
   slice operator takes constant time. However, we know that the slice operator in Python is actually
   O(k). This means that the binary search using slice will not perform in strict logarithmic time.
   Luckily this can be remedied by passing the list along with the starting and ending indices. The
   indices can be calculated as we did in Listing 3. We leave this implementation as an exercise.

   Even though a binary search is generally better than a sequential search, it is important to note
   that for small values of n, the additional cost of sorting is probably not worth it. In fact, we
   should always consider whether it is cost effective to take on the extra work of sorting to gain
   searching benefits. If we can sort once and then search many times, the cost of the sort is not so
   significant. However, for large lists, sorting even once can be so expensive that simply performing a
   sequential search from the start may be the best choice.


---
http://stackoverflow.com/questions/9501337/binary-search-algorithm-in-python

Binary search algorithm in python

   I am trying to implement the binary search in python and have written it as follows. However, I can't
   make it stop whenever needle_element is larger than the largest element in the array.

   Can you help? Thanks.
<code>
def binary_search(array, needle_element):
    mid = (len(array)) / 2
    if not len(array):
        raise "Error"
    if needle_element == array[mid]:
        return mid
    elif needle_element > array[mid]:
        return mid + binary_search(array[mid:],needle_element)
    elif needle_element < array[mid]:
        return binary_search(array[:mid],needle_element)
    else:
        raise "Error"
</code>

***
   I would try to avoid creating lots of partial copies of the array, and pass in a lower and upper
   index instead. Then you simply stop if lower>upper. – Lasse V. Karlsen Feb 29 '12 at 14:58

***
   In the case that needle_element > array[mid], you currently pass array[mid:] to the recursive call.
   But you know that array[mid] is too small, so you can pass array[mid+1:] instead (and adjust the
   returned index accordingly).

   If the needle is larger than all the elements in the array, doing it this way will eventually give
   you an empty array, and an error will be raised as expected.

   Note: Creating a sub-array each time will result in bad performance for large arrays. It's better to
   pass in the bounds of the array instead.

***
   It would be much better to work with a lower and upper indexes as Lasse V. Karlsen was suggesting in
   a comment to the question.

   This would be the code:
<code>
def binary_search(array, target):
    lower = 0
    upper = len(array)
    while lower < upper:   # use < instead of <=
        x = lower + (upper - lower) // 2
        val = array[x]
        if target == val:
            return x
        elif target > val:
            if lower == x:   # this two are the actual lines
                break        # you're looking for
            lower = x
        elif target < val:
            upper = x
</code>

     * lower < upper will stop once you reached the smaller number (from the left side)
     * if lower == x: break will stop once you've reached the higher number (from the right side)

   Example:
>>> binary_search([1,5,8,10], 5)   # return 1
1
>>> binary_search([1,5,8,10], 0)   # return None
>>> binary_search([1,5,8,10], 15)  # return None

***
   This doesn't work. Try a list: [7,9,2,4,8,6,5,1,8,5,3]. – user1342336 Jan 17 at 20:13

***
   You can improve your algorithm as the others suggested, but let's first look at why it doesn't work:

   You're getting stuck in a loop because if needle_element > array[mid], you're including element mid
   in the bisected array you search next. So if needle is not in the array, you'll eventually be
   searching an array of length one forever. Pass array[mid+1:] instead (it's legal even if mid+1 is not
   a valid index), and you'll eventually call your function with an array of length zero. So len(array)
   == 0 means "not found", not an error. Handle it appropriately.

***
   Why not use the bisect module? It should do the job you need---less code for you to maintain and
   test.

***
   array[mid:] creates a new sub-copy everytime you call it = slow. Also you use recursion, which in
   Python is slow, too.

   Try this:
<code>
def binarysearch(sequence, value):
    lo, hi = 0, len(sequence) - 1
    while lo <= hi:
        mid = (lo + hi) // 2
        if sequence[mid] < value:
            lo = mid + 1
        elif value < sequence[mid]:
            hi = mid - 1
        else:
            return mid
    return None
</code>

***
   Not only recursion is slow - it will actually blow up in your face if the array is long enough,
   because Python has no tail recursion optimization and will run out of stack frames given a large
   enough input array. – Shnatsel Mar 25 '16 at 15:42

***
   @Shnatsel ad "large enough input array" - given we are talking about "binary" search and CPython has
   by default recursion limit set to 1000 (can be set to more by sys.setrecursionlimit) we are
   talking about arrays of sizes up to 2**1000, also know as ~10^300... – Ecir Hana Mar 26 '16 at

***
   If you're doing a binary search, I'm guessing the array is sorted. If that is true you should be able
   to compare the last element in the array to the needle_element. As octopus says, this can be done
   before the search begins.

***
   You can just check to see that needle_element is in the bounds of the array before starting at all.
   This will make it more efficient also, since you won't have to do several steps to get to the end.
if needle_element < array[0] or needle_element > array[-1]:
    # do something, raise error perhaps?

***
   All the answers above are true , but I think it would help to share my code
<code>
def binary_search(number):
numbers_list = range(20, 100)
i = 0
j = len(numbers_list)
while i < j:
    middle = int((i + j) / 2)
    if number > numbers_list[middle]:
        i = middle + 1
    else:
        j = middle
return 'the index is '+str(i)
</code>

***
   It returns the index of key in array by using recursive.

   round() is a function convert float to integer and make code fast and goes to expected case[O(logn)].
<code>
A=[1,2,3,4,5,6,7,8,9,10]
low = 0
hi = len(A)
v=3
def BS(A,low,hi,v):
    mid = round((hi+low)/2.0)
    if v == mid:
        print ("You have found dude!" + " " + "Index of v is ", A.index(v))
    elif v < mid:
        print ("Item is smaller than mid")
        hi = mid-1
        BS(A,low,hi,v)
    else :
        print ("Item is greater than mid")
        low = mid + 1
        BS(A,low,hi,v)
BS(A,low,hi,v)
</code>

***
<code>
   def binary_search(array, target): low = 0 mid = len(array) / 2 upper = len(array)
if len(array) == 1:
    if array[0] == target:
        print target
        return array[0]
    else:
        return False
if target == array[mid]:
    print array[mid]
    return mid
else:
    if mid > low:
        arrayl = array[0:mid]
        binary_search(arrayl, target)

    if upper > mid:
        arrayu = array[mid:len(array)]
        binary_search(arrayu, target)

   if name == "main": a = [3,2,9,8,4,1,9,6,5,9,7] binary_search(a,9)
</code>

***
   Without the lower/upper indexes this should also do:
<code>
def exists_element(element, array):
    if not array:
        yield False

    mid = len(array) // 2
    if element == array[mid]:
        yield True
    elif element < array[mid]:
        yield from exists_element(element, array[:mid])
    else:
        yield from exists_element(element, array[mid + 1:])
</code>



---
http://stackoverflow.com/questions/212358/binary-search-bisection-in-python

Binary search (bisection) in Python

   Is there a library function that performs binary search on a list/tuple and return the position of
   the item if found and 'False' (-1, None, etc.) if not?

   I found the functions bisect_left/right in the bisect module, but they still return a position
   even if the item is not in the list. That's perfectly fine for their intended usage, but I just want
   to know if an item is in the list or not (don't want to insert anything).

   I thought of using bisect_left and then checking if the item at that position is equal to what I'm
   searching, but that seems cumbersome (and I also need to do bounds checking if the number can be
   larger than the largest number in my list). If there is a nicer method I'd like to know about it.

   Edit To clarify what I need this for: I'm aware that a dictionary would be very well suited for this,
   but I'm trying to keep the memory consumption as low as possible. My intended usage would be a sort
   of double-way look-up table. I have in the table a list of values and I need to be able to access the
   values based on their index. And also I want to be able to find the index of a particular value or
   None if the value is not in the list.

   Using a dictionary for this would be the fastest way, but would (approximately) double the memory
   requirements.

   I was asking this question thinking that I may have overlooked something in the Python libraries. It
   seems I'll have to write my own code, as Moe suggested.

***
   What is it you're trying to accomplish? If the values are unique, consider using a set and "if value
   in set: something". – Kirk Strauser Oct 17 '08 at 15:03

   For what it's worth, "-1" is considered true; "0" would be false. – Glyph Oct 18 '08 at 5:12

***
   I mentioned -1 because a function that returns the index of the searched item in the array can return
   0 already so -1 is returned if the item is not found (similar to substring search). – rslite Oct
   18 '08 at 11:00

***
   If you use numpy, np.searchsorted is useful. docs.scipy.org/doc/numpy/reference/generated/…

***
<code>
from bisect import bisect_left

def binary_search(a, x, lo=0, hi=None):   # can't use a to specify default for hi
    hi = hi if hi is not None else len(a) # hi defaults to len(a)
    pos = bisect_left(a,x,lo,hi)          # find insertion position
    return (pos if pos != hi and a[pos] == x else -1) # don't walk off the end
</code>

***
   This is the only correct answer - I am quite baffled. Everyone's presenting new code - code which
   might or might not be correct (particular for edge cases and special cases). But you know for sure
   that the library code is correct - because it's been around for over a decade and used countless
   times. And what's his objection to it? That he has to add two lines of test code! – Tom Swirly

   Oh, and you can replace the second line by hi = hi or len(a) - much simpler. – Tom Swirly Oct 24

***
   @TomSwirly, I haven't thought it through but are you sure about that simplification? hi could turn
   out to be zero. – Dave Abrahams Nov 17 '12 at 2:50

***
   My original thought was that hi=0 made no sense, but now I don't think it's right and looking at it
   now, it would be unexpected to pass hi=0 and then get a search of the whole array, so I think you're
   right that I'm wrong about the simplification. – Tom Swirly Nov 18 '12 at 3:24

***
   @volcano So does binsearch in general. – cubuspl42 Jul 5 '14 at 20:13

***
   Why not look at the code for bisect_left/right and adapt it to suit your purpose.

   like this:
<code>
def binary_search(a, x, lo=0, hi=None):
    if hi is None:
        hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        midval = a[mid]
        if midval < x:
            lo = mid+1
        elif midval > x:
            hi = mid
        else:
            return mid
    return -1
</code>

***
   I originally +1'ed this, but now I've come to the conclusion this isn't a good thing. If this answer
   is followed, it'll cause a lot of code duplication, and as we all know, it's really simple to f*ck up
   binary search. – abyx Oct 30 '09 at 16:23

   shouldn't it be hi = mid - 1 in the elif? – Paweł Prażak Feb 5 '11 at 18:50

***
   @Paweł: they are two equivalent variants, depending on whether the upper bound is inclusive or
   exclusive. you can change hi = mid to hi = mid-1 and hi = len(a) to hi = len(a)-1 and while lo < hi:
   to while lo <= hi, and it would be equivalently correct – user102008 Apr 6 '11 at 10:42

***
   why not do something like: def binary_search(a, x, lo = 0, hi = None): i = bisect(a, x, lo, hi)
   return i if a[i] == x else -1 sorry for the formatting - not sure how to do this properly in the
   comment arrea – Vitali Feb 29 '12 at 1:44

***
   You should use bisect.bisect_left() rather than this. – alastair Nov 7 '12 at 11:26

***
   This is a little off-topic (since Moe's answer seems complete to the OP's question), but it might be
   worth looking at the complexity for your whole procedure from end to end. If you're storing thing in
   a sorted lists (which is where a binary search would help), and then just checking for existence,
   you're incurring (worst-case, unless specified):

   Sorted Lists
     * O( n log n) to initially create the list (if it's unsorted data. O(n), if it's sorted )
     * O( log n) lookups (this is the binary search part)
     * O( n ) insert / delete (might be O(1) or O(log n) average case, depending on your pattern)

   Whereas with a set(), you're incurring
     * O(n) to create
     * O(1) lookup
     * O(1) insert / delete

   The thing a sorted list really gets you are "next", "previous", and "ranges" (including inserting or
   deleting ranges), which are O(1) or O(|range|), given a starting index. If you aren't using those
   sorts of operations often, then storing as sets, and sorting for display might be a better deal
   overall. set() incurs very little additional overhead in python.

***
   There is one other thing a sorted list gets you. O(n) ordered traversal. With a set that's O(n log n)
   and you end up having to copy references to the data into a list. – Omnifarious Mar 30 '10 at

***
   True enough! Thank you for expanding on what I meant by range search. Fwiw, a full traversal is the
   same a range query between min,max, which is O(k) where k = n :) – Gregg Lind Mar 31 '10 at 12:35

***
   It might be worth mentioning that the bisect docs now provide searching examples:
   http://docs.python.org/library/bisect.html#searching-sorted-lists

   (Raising ValueError instead of returning -1 or None is more pythonic – list.index() does it, for
   example. But of course you can adapt the examples to your needs.)

***
   Simplest is to use bisect and check one position back to see if the item is there:
<code>
def binary_search(a,x,lo=0,hi=-1):
    i = bisect(a,x,lo,hi)
    if i == 0:
        return -1
    elif a[i-1] == x:
        return i-1
    else:
        return -1
</code>

***
   Nice, but the code barfs if you do not pass in the 'hi' value. I'd write it like this: "def
   binary_search(a,x,lo=0,hi=None): from bisect import bisect i = bisect(a,x,lo,hi or len(a)) return
   (i-1 if a[i-1] == x else -1) " and test it like this: " for i in range(1, 20): a = list(range(i)) for
   aa in a: j = binary_search(a, aa) if j != aa: print i, aa, j" – hughdbrown Aug 6 '09 at 20:02

***
   I agree that @DaveAbrahams's answer using the bisect module is the correct approach. He did not
   mention one important detail in his answer.

   From the docs bisect.bisect_left(a, x, lo=0, hi=len(a))

   The bisection module does not require the search array to be precomputed ahead of time. You can just
   present the endpoints to the bisect.bisect_left instead of it using the defaults of 0 and len(a).

   Even more important for my use, looking for a value X such that the error of a given function is
   minimized. To do that, I needed a way to have the bisect_left's algorithm call my computation
   instead. This is really simple.

   Just provide an object that defines __getitem__ as a

   For example, we could use the bisect algorithm to find a square root with arbitrary precision!
<code>
import bisect

class sqrt_array(object):
    def __init__(self, digits):
        self.precision = float(10**(digits))
    def __getitem__(self, key):
        return (key/self.precision)**2.0

sa = sqrt_array(4)

# "search" in the range of 0 to 10 with a "precision" of 0.0001
index = bisect.bisect_left(sa, 7, 0, 10*10**4)
print 7**0.5
print index/(10**4.0)
</code>

***
   This is not clean. Use scipy.optimize for this. – Neil G Oct 30 '15 at 9:51

***
   This is right from the manual:
   http://docs.python.org/2/library/bisect.html

   8.5.1. Searching Sorted Lists
   The above bisect() functions are useful for finding insertion points but can be tricky or awkward to
   use for common searching tasks. The following five functions show how to transform them into the
   standard lookups for sorted lists:
def index(a, x):
    'Locate the leftmost value exactly equal to x'
    i = bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    raise ValueError

   So with the slight modification your code should be:
def index(a, x):
    'Locate the leftmost value exactly equal to x'
    i = bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    return -1

***
   If you just want to see if it's present, try turning the list into a dict:
# Generate a list
l = [n*n for n in range(1000)]

# Convert to dict - doesn't matter what you map values to
d = dict((x, 1) for x in l)

count = 0
for n in range(1000000):
    # Compare with "if n in l"
    if n in d:
        count += 1

   On my machine, "if n in l" took 37 seconds, while "if n in d" took 0.4 seconds.

***
   set(l) could do the job. – J.F. Sebastian Oct 17 '08 at 15:06

***
   That's not always a good option for a couple of reasons: 1) dicts/sets take up more memory. 2) if he
   doesn't have much in the list, a binary search may be faster. 3) converting the list to a dict is an
   O(n) operation while a binary search is O(log n). – Jason Baker Oct 17 '08 at 15:10

***
   As an FYI, the "set" overhead in python compared to python lists, is very very low. And they are
   extremely fast for lookups. Where binary search really excels is for looking up ranges. – Gregg
   Lind Oct 17 '08 at 16:43

   Converting the list may be O(n) but sorting the data in the list, which you'd have to do before
   binary searching it, is worse. Where's the data coming from, you can probably insert it into a
   dictionary as you go. I agree that the memory may be an issue. – Mark Baker Oct 20 '08 at 15:56

***
   While there's no explicit binary search algorithm in Python, there is a module - bisect - designed to
   find the insertion point for an element in a sorted list using a binary search. This can be "tricked"
   into performing a binary search. The biggest advantage of this is the same advantage most library
   code has - it's high-performing, well-tested and just works (binary searches in particular can be
   quite difficult to implement successfully - particularly if edge cases aren't carefully
   considered).

Basic Types

   For basic types like Strings or ints it's pretty easy - all you need is the bisect module and a
   sorted list:
>>> import bisect
>>> names = ['bender', 'fry', 'leela', 'nibbler', 'zoidberg']
>>> bisect.bisect_left(names, 'fry')
1
>>> keyword = 'fry'
>>> x = bisect.bisect_left(names, keyword)
>>> names[x] == keyword
True
>>> keyword = 'arnie'
>>> x = bisect.bisect_left(names, keyword)
>>> names[x] == keyword
False

   You can also use this to find duplicates:
...
>>> names = ['bender', 'fry', 'fry', 'fry', 'leela', 'nibbler', 'zoidberg']
>>> keyword = 'fry'
>>> leftIndex = bisect.bisect_left(names, keyword)
>>> rightIndex = bisect.bisect_right(names, keyword)
>>> names[leftIndex:rightIndex]
['fry', 'fry', 'fry']

   Obviously you could just return the index rather than the value at that index if desired.

Objects
   For custom types or objects, things are a little bit trickier: you have to make sure to implement
   rich comparison methods to get bisect to compare correctly.
>>> import bisect
>>> class Tag(object):  # a simple wrapper around strings
...     def __init__(self, tag):
...         self.tag = tag
...     def __lt__(self, other):
...         return self.tag < other.tag
...     def __gt__(self, other):
...         return self.tag > other.tag
...
>>> tags = [Tag('bender'), Tag('fry'), Tag('leela'), Tag('nibbler'), Tag('zoidbe
rg')]
>>> key = Tag('fry')
>>> leftIndex = bisect.bisect_left(tags, key)
>>> rightIndex = bisect.bisect_right(tags, key)
>>> print([tag.tag for tag in tags[leftIndex:rightIndex]])
['fry']

   This should work in at least Python 2.7 -> 3.3

***
   This one is:
     * not recursive (which makes it more memory-efficient than most recursive approaches)
     * actually working
     * fast since it runs without any unnecessary if's and conditions
     * based on a mathematical assertion that the floor of (low + high)/2 is always smaller than high
       where low is the lower limit and high is the upper limit.
     * tested :D
     ________________________________________________________________________________________________

def binsearch(t, key, low = 0, high = len(t) - 1):
    # bisecting the range
    while low < high:
        mid = (low + high)//2
        if t[mid] < key:
            low = mid + 1
        else:
            high = mid
    # at this point 'low' should point at the place
    # where the value of 'key' is possibly stored.
    return low if t[low] == key else -1

***
   Using a dict wouldn't like double your memory usage unless the objects you're storing are really
   tiny, since the values are only pointers to the actual objects:
>>> a = 'foo'
>>> b = [a]
>>> c = [a]
>>> b[0] is c[0]
True

   In that example, 'foo' is only stored once. Does that make a difference for you? And exactly how many
   items are we talking about anyway?

***
   It's about numbers and lots of them :) I'd like to use an array almost as big as the computer memory.
   I know the base of my problem could be wrong, but I was curious about the lack of a binary search
   method. – rslite Oct 18 '08 at 11:07

***
   You can't have a key object small enough to qualify as "really tiny" here. An object would have a
   minimum cost of 3 words (type, refcount, payload), while a list adds 1 word, a set adds 1 word, and a
   dict adds 2 words. All three (list/set/dict) preallocate space in some fashion as well, which is
   another multiplier, but still not enough to matter. – Rhamphoryncus Nov 9 '09 at 20:37

***
   This code works with integer lists in a recursive way. Looks for the simplest case scenario, which
   is: list length less than 2. It means the answer is already there and a test is performed to check
   for the correct answer. If not, a middle value is set and tested to be the correct, if not bisection
   is performed by calling again the function, but setting middle value as the upper or lower limit, by
   shifting it to the left or right
def binary_search(intList, intValue, lowValue, highValue):
    if(highValue - lowValue) < 2:
        return intList[lowValue] == intValue or intList[highValue] == intValue
    middleValue = lowValue + ((highValue - lowValue)/2)
    if intList[middleValue] == intValue:
        return True
    if intList[middleValue] > intValue:
        return binary_search(intList, intValue, lowValue, middleValue - 1)
   return binary_search(intList, intValue, middleValue + 1, highValue)

***
   Dave Abrahams' solution is good. Although I have would have done it minimalistic:
def binary_search(L, x):
    i = bisect.bisect_left(L, x)
    if i == len(L) or L[i] != x:
        return -1
    return i

***
   Check out the examples on Wikipedia http://en.wikipedia.org/wiki/Binary_search_algorithm
def binary_search(a, key, imin=0, imax=None):
    if imax is None:
        # if max amount not set, get the total
        imax = len(a) - 1

    while imin <= imax:
        # calculate the midpoint
        mid = (imin + imax)//2
        midval = a[mid]

        # determine which subarray to search
        if midval < key:
            # change min index to search upper subarray
            imin = mid + 1
        elif midval > key:
            # change max index to search lower subarray
            imax = mid - 1
        else:
            # return index number
            return mid
    raise ValueError

***
<code>
'''
Only used if set your position as global
'''
position #set global

def bst(array,taget): # just pass the array and target
        global position
        low = 0
        high = len(array)
    while low <= high:
        mid = (lo+hi)//2
        if a[mid] == target:
            position = mid
            return -1
        elif a[mid] < target:
            high = mid+1
        else:
            low = mid-1
    return -1
</code>

   I guess this is much better and effective. please correct me :) . Thank you

***
     * s is a list.
     * binary(s, 0, len(s) - 1, find) is the initial call.
     * Function returns an index of the queried item. If there is no such item it returns -1.
def binary(s,p,q,find):
    if find==s[(p+q)/2]:
        return (p+q)/2
    elif p==q-1 or p==q:
        if find==s[q]:
            return q
        else:
            return -1
    elif find < s[(p+q)/2]:
        return binary(s,p,(p+q)/2,find)
    elif find > s[(p+q)/2]:
        return binary(s,(p+q)/2+1,q,find)


---
http://code.activestate.com/recipes/81188-binary-search/

Binary search (Python recipe) by Karl Schärlund

   ActiveState Code (http://code.activestate.com/recipes/81188/)

   A straightforward implementation of the binary search algorithm.
   Python, 13 lines
<code>
def binary_search(seq, t):
    min = 0
    max = len(seq) - 1
    while True:
        if max < min:
            return -1
        m = (min + max) // 2
        if seq[m] < t:
            min = m + 1
        elif seq[m] > t:
            max = m - 1
        else:
            return m
</code>

   Binary search is a fast algorithm for searching sorted sequences. It runs in about log2 N time, as
   opposed to an average run time of N/2 for linear search. For large lists that you need to search
   multiple times, it might well be more efficient to sort and use binary search instead of sticking to
   a linear search.

   Binary search is described in every introductory book on algorithms I have encountered, and is very
   well documented. There are som pitfalls in implementing it, though, and Jon Bentley discusses this in
   his wonderful book "Programming Pearls". Thats Pearls, not Perl. Recommended reading.

   Revision 2 is updated to use floor division as suggested by Gillian Matthews.

***
   available in a standard python module. There's a standard Python library for binary searches,
   'bisect.' Tim Peters once called this the best underused Python module.
>>> import bisect
>>> bisect.bisect_right([1, 5, 9, 12, 18, 35], 5)
   2
   
>>> bisect.bisect_left([1, 5, 9, 12, 18, 35], 5)
   1
   
>>> bisect.bisect_left([1, 5, 9, 12, 18, 35], 15)
   4

     >

***
   this is a useful demonstration of the algorithm but the line = (min + max) / 2 should use integer
   division m = (min + max)//2 because m needs to be an integer not a float

***
   Indeed, thanks for pointing that out!

   In my defense (I wrote the recipe, but I have lost my original account details and also changed my
   surname...), the recipe was written a couple of months before the introduction of the floor division
   operator. :-)

   Also, as Andrew pointed out, in practice it's better to use the bisect module.

***
   Got my password reset email, sorry if the comment above does not make much sense any longer. :-)

***
   Indeed! The bisect module is very powerful. It's the basis for the sortedcontainers module which
   implements sorted list, sorted set, and sorted dict data types in pure-Python but is fast-as-C
   implementations. Read the implementation details for a description if interested.


---
https://rosettacode.org/wiki/Binary_search

Binary search

   From Rosetta Code

   Binary search
   You are encouraged to solve this task according to the task description, using any language you
   may know.

   A binary search divides a range of values into halves, and continues to narrow down the field of
   search until the unknown value is found. It is the classic example of a "divide and conquer"
   algorithm.

   As an analogy, consider the children's game "guess a number." The scorer has a secret number, and
   will only tell the player if their guessed number is higher than, lower than, or equal to the secret
   number. The player then uses this information to guess a new number.

   As the player, an optimal strategy for the general case is to start by choosing the range's midpoint
   as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If
   the guess was too high, one would select the point exactly between the range midpoint and the
   beginning of the range. If the original guess was too low, one would ask about the point exactly
   between the range midpoint and the end of the range. This process repeats until one has reached the
   secret number.

   The Task

   Given the starting point of a range, the ending point of a range, and the "secret value", implement a
   binary search through a sorted integer array for a certain number. Implementations can be recursive
   or iterative (both if you can). Print out whether or not the number was in the array afterwards. If
   it was, print the index also.

   There are several binary search algorithms commonly seen. They differ by how they treat multiple
   values equal to the given value, and whether they indicate whether the element was found or not. For
   completeness we will present pseudocode for all of them.

   All of the following code examples use an "inclusive" upper bound (i.e. high = N-1 initially). Any of
   the examples can be converted into an equivalent example using "exclusive" upper bound (i.e. high = N
   initially) by making the following simple changes (which simply increase high by 1):
     * change high = N-1 to high = N
     * change high = mid-1 to high = mid
     * (for recursive algorithm) change if (high < low) to if (high <= low)
     * (for iterative algorithm) change while (low <= high) to while (low < high)

   Traditional algorithm

   The algorithms are as follows (from Wikipedia). The algorithms return the index of some element
   that equals the given value (if there are multiple such elements, it returns some arbitrary one). It
   is also possible, when the element is not found, to return the "insertion point" for it (the index
   that the value would have if it were inserted into the array).

   Recursive Pseudocode:
  // initially called with low = 0, high = N-1
  BinarySearch(A[0..N-1], value, low, high) {
      // invariants: value > A[i] for all i < low
                     value < A[i] for all i > high
      if (high < low)
          return not_found // value would be inserted at index "low"
      mid = (low + high) / 2
      if (A[mid] > value)
          return BinarySearch(A, value, low, mid-1)
      else if (A[mid] < value)
          return BinarySearch(A, value, mid+1, high)
      else
          return mid
  }

   Iterative Pseudocode:
  BinarySearch(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value > A[i] for all i < low
                         value < A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] > value)
              high = mid - 1
          else if (A[mid] < value)
              low = mid + 1
          else
              return mid
      }
      return not_found // value would be inserted at index "low"
  }

   Leftmost insertion point

   The following algorithms return the leftmost place where the given element can be correctly inserted
   (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements
   that are equal to the given value (if any). Equivalently, this is the lowest index where the element
   is greater than or equal to the given value (since if it were any lower, it would violate the
   ordering), or 1 past the last index if such an element does not exist. This algorithm does not
   determine if the element is actually found. This algorithm only requires one comparison per level.

   Recursive Pseudocode:
  // initially called with low = 0, high = N - 1
  BinarySearch_Left(A[0..N-1], value, low, high) {
      // invariants: value > A[i] for all i < low
                     value <= A[i] for all i > high
      if (high < low)
          return low
      mid = (low + high) / 2
      if (A[mid] >= value)
          return BinarySearch_Left(A, value, low, mid-1)
      else
          return BinarySearch_Left(A, value, mid+1, high)
  }

   Iterative Pseudocode:
  BinarySearch_Left(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value > A[i] for all i < low
                         value <= A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] >= value)
              high = mid - 1
          else
              low = mid + 1
      }
      return low
  }

   Rightmost insertion point

   The following algorithms return the rightmost place where the given element can be correctly inserted
   (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements
   that are equal to the given value (if any). Equivalently, this is the lowest index where the element
   is greater than the given value, or 1 past the last index if such an element does not exist. This
   algorithm does not determine if the element is actually found. This algorithm only requires one
   comparison per level. Note that these algorithms are almost exactly the same as the
   leftmost-insertion-point algorithms, except for how the inequality treats equal values.

   Recursive Pseudocode:
  // initially called with low = 0, high = N - 1
  BinarySearch_Right(A[0..N-1], value, low, high) {
      // invariants: value >= A[i] for all i < low
                     value < A[i] for all i > high
      if (high < low)
          return low
      mid = (low + high) / 2
      if (A[mid] > value)
          return BinarySearch_Right(A, value, low, mid-1)
      else
          return BinarySearch_Right(A, value, mid+1, high)
  }

   Iterative Pseudocode:
  BinarySearch_Right(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value >= A[i] for all i < low
                         value < A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] > value)
              high = mid - 1
          else
              low = mid + 1
      }
      return low
  }

   Extra credit

   Make sure it does not have overflow bugs.

   The line in the pseudocode above to calculate the mean of two integers:
mid = (low + high) / 2

   could produce the wrong result in some programming languages when used with a bounded integer type,
   if the addition causes an overflow. (This can occur if the array size is greater than half the
   maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative
   number, and dividing by 2 will still result in a negative number. Indexing an array with a negative
   number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers
   are used, an overflow will result in losing the largest bit, which will produce the wrong result.

   One way to fix it is to manually add half the range to the low number:
mid = low + (high - low) / 2

   Even though this is mathematically equivalent to the above, it is not susceptible to overflow.

   Another way for signed integers, possibly faster, is the following:
mid = (low + high) >>> 1

   where >>> is the logical right shift operator. The reason why this works is that, for signed
   integers, even though it overflows, when viewed as an unsigned number, the value is still the correct
   sum. To divide an unsigned number by 2, simply do a logical right shift.

Contents

     * 1 ACL2
     * 2 Ada
     * 3 ALGOL 68
     * 4 AutoHotkey
     * 5 AWK
     * 6 Axe
     * 7 BASIC
     * 8 BBC BASIC
     * 9 Brat
     * 10 C
     * 11 C++
     * 12 C#
     * 13 Chapel
     * 14 Clojure
     * 15 COBOL
     * 16 CoffeeScript
     * 17 Common Lisp
     * 18 D
     * 19 E
     * 20 Eiffel
     * 21 Elixir
     * 22 Erlang
     * 23 Euphoria
          + 23.1 Recursive
          + 23.2 Iterative
     * 24 F#
     * 25 FBSL
     * 26 Factor
     * 27 Forth
     * 28 Fortran
          + 28.1 Iterative, exclusive bounds, three-way test.
               o 28.1.1 Statistics
               o 28.1.2 An alternative version
     * 29 Futhark
     * 30 GAP
     * 31 Go
     * 32 Groovy
          + 32.1 Recursive Solution
          + 32.2 Iterative Solution
     * 33 Haskell
     * 34 HicEst
     * 35 Icon and Unicon
     * 36 J
     * 37 Java
     * 38 JavaScript
     * 39 jq
     * 40 Julia
     * 41 K
     * 42 Kotlin
     * 43 Liberty BASIC
     * 44 Logo
     * 45 Lua
     * 46 M4
     * 47 Maple
     * 48 Mathematica / Wolfram Language
     * 49 MATLAB
     * 50 Maxima
     * 51 MAXScript
     * 52 Nim
     * 53 Niue
     * 54 Objeck
     * 55 Objective-C
     * 56 OCaml
     * 57 Octave
     * 58 ooRexx
     * 59 Oz
     * 60 PARI/GP
     * 61 Pascal
     * 62 Perl
     * 63 Perl 6
     * 64 Phix
     * 65 PHP
     * 66 PicoLisp
     * 67 PL/I
     * 68 Pop11
     * 69 PowerShell
     * 70 Prolog
     * 71 PureBasic
#########################################################
#    * 72 Python                                   #
#         + 72.1 Python: Iterative                 #
#         + 72.2 Python: Recursive                 #
#         + 72.3 Python: Library                   #
#              o 72.3.1 Python: Alternate          #
#         + 72.4 Python: Approximate binary search #
#########################################################
     * 73 R
     * 74 Racket
     * 75 REXX
          + 75.1 recursive version
          + 75.2 iterative version
     * 76 Ring
     * 77 Ruby
     * 78 Run BASIC
     * 79 Rust
     * 80 Scala
     * 81 Scheme
     * 82 Seed7
     * 83 SequenceL
     * 84 Sidef
     * 85 UNIX Shell
     * 86 SPARK
     * 87 Standard ML
     * 88 Swift
     * 89 Tcl
     * 90 TI-83 BASIC
     * 91 uBasic/4tH
     * 92 UnixPipes
     * 93 VBA
     * 94 Vedit macro language
     * 95 Visual Basic .NET
     * 96 VBScript
     * 97 Wortel
     * 98 zkl
     * 99 ZX Spectrum Basic

...

Python
Python: Iterative

def binary_search(l, value):
    low = 0
    high = len(l)-1
    while low <= high:
        mid = (low+high)//2
        if l[mid] > value: high = mid-1
        elif l[mid] < value: low = mid+1
        else: return mid
    return -1

Python: Recursive

def binary_search(l, value, low = 0, high = -1):
    if not l: return -1
    if(high == -1): high = len(l)-1
    if low >= high:
        if l[low] == value: return low
        else: return -1
    mid = (low+high)//2
    if l[mid] > value: return binary_search(l, value, low, mid-1)
    elif l[mid] < value: return binary_search(l, value, mid+1, high)
    else: return mid

Python: Library

   Python's bisect module provides binary search functions
index = bisect.bisect_left(list, item) # leftmost insertion point
index = bisect.bisect_right(list, item) # rightmost insertion point
index = bisect.bisect(list, item) # same as bisect_right

# same as above but actually insert the item into the list at the given place:
bisect.insort_left(list, item)
bisect.insort_right(list, item)
bisect.insort(list, item)

Python: Alternate

   Complete binary search function with python's bisect module:
from bisect import bisect_left

def binary_search(a, x, lo=0, hi=None):   # can't use a to specify default for hi
    hi = hi if hi is not None else len(a) # hi defaults to len(a)
    pos = bisect_left(a,x,lo,hi)          # find insertion position
    return (pos if pos != hi and a[pos] == x else -1) # don't walk off the end

Python: Approximate binary search

   Returns the nearest item of list l to value.
def binary_search(l, value):
    low = 0
    high = len(l)-1
    while low + 1 < high:
        mid = (low+high)//2
        if l[mid] > value:
            high = mid
        elif l[mid] < value:
            low = mid
        else:
            return mid
    return high if abs(l[high] - value) < abs(l[low] - value) else low

...
