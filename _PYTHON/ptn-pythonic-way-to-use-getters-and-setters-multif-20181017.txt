filename: ptn_pythonic-way-to-use-getters-and-setters-multif_20181017.txt
https://www.programiz.com/python-programming/property

Python @property

   You will learn about Python @property; pythonic way to use getters and setters.

   Python has a great concept called property which makes the life of an object oriented programmer much
   simpler.

   Before defining and going into details of what @property is, let us first build an intuition on why
   it would be needed in the first place.

An Example To Begin With
   Let us assume that you decide to [19]make a class that could store the temperature in degree Celsius.
   It would also implement a method to convert the temperature into degree Fahrenheit. One way of doing
   this is as follows.
class Celsius:
    def __init__(self, temperature = 0):
        self.temperature = temperature

    def to_fahrenheit(self):
        return (self.temperature * 1.8) + 32

   We could make objects out of this class and manipulate the attribute temperature as we wished. Try
   these on Python shell.
>>> # create new object
>>> man = Celsius()

>>> # set temperature
>>> man.temperature = 37

>>> # get temperature
>>> man.temperature
37

>>> # get degrees Fahrenheit
>>> man.to_fahrenheit()
98.60000000000001

   The extra decimal places when converting into Fahrenheit is due to the floating point arithmetic
   error (try 1.1 + 2.2 in the Python interpreter).

   Whenever we assign or retrieve any object attribute like temperature, as show above, Python searches
   it in the object's __dict__ dictionary.
>>> man.__dict__
{'temperature': 37}

   Therefore, man.temperature internally becomes man.__dict__['temperature'].

   Now, let's further assume that our class got popular among clients and they started using it in their
   programs. They did all kinds of assignments to the object.

   One fateful day, a trusted client came to us and suggested that temperatures cannot go below -273
   degree Celsius (students of thermodynamics might argue that it's actually -273.15), also called the
   absolute zero. He further asked us to implement this value constraint. Being a company that strive
   for customer satisfaction, we happily heeded the suggestion and released version 1.01 (an upgrade of
   our existing class).

Using Getters and Setters
   An obvious solution to the above constraint will be to hide the attribute temperature (make it
   private) and define new getter and setter interfaces to manipulate it. This can be done as follows.
class Celsius:
    def __init__(self, temperature = 0):
        self.set_temperature(temperature)

    def to_fahrenheit(self):
        return (self.get_temperature() * 1.8) + 32

    # new update
    def get_temperature(self):
        return self._temperature

    def set_temperature(self, value):
        if value < -273:
            raise ValueError("Temperature below -273 is not possible")
        self._temperature = value

   We can see above that new methods get_temperature() and set_temperature() were defined and
   furthermore, temperature was replaced with _temperature. An underscore (_) at the beginning is used
   to denote private variables in Python.
>>> c = Celsius(-277)
Traceback (most recent call last):
...
ValueError: Temperature below -273 is not possible

>>> c = Celsius(37)
>>> c.get_temperature()
37
>>> c.set_temperature(10)

>>> c.set_temperature(-300)
Traceback (most recent call last):
...
ValueError: Temperature below -273 is not possible

   This update successfully implemented the new restriction. We are no longer allowed to set temperature
   below -273.

   Please note that private variables don't exist in Python. There are simply norms to be followed. The
   language itself don't apply any restrictions.
>>> c._temperature = -300
>>> c.get_temperature()
-300

   But this is not of great concern. The big problem with the above update is that, all the clients who
   implemented our previous class in their program have to modify their code from obj.temperature to
   obj.get_temperature() and all assignments like obj.temperature = val to obj.set_temperature(val).

   This refactoring can cause headaches to the clients with hundreds of thousands of lines of codes.

   All in all, our new update was not backward compatible. This is where property comes to rescue.

The Power of @property
   The pythonic way to deal with the above problem is to use property. Here is how we could have
   achieved it.
class Celsius:
    def __init__(self, temperature = 0):
        self.temperature = temperature

    def to_fahrenheit(self):
        return (self.temperature * 1.8) + 32

    def get_temperature(self):
        print("Getting value")
        return self._temperature

    def set_temperature(self, value):
        if value < -273:
            raise ValueError("Temperature below -273 is not possible")
        print("Setting value")
        self._temperature = value

    temperature = property(get_temperature,set_temperature)

   And, issue the following code in shell once you run it.
>>> c = Celsius()

   We added a print() function inside get_temperature() and set_temperature() to clearly observe that
   they are being executed.

   The last line of the code, makes a property object temperature. Simply put, property attaches some
   code (get_temperature and set_temperature) to the member attribute accesses (temperature).

   Any code that retrieves the value of temperature will automatically call get_temperature() instead of
   a dictionary (__dict__) look-up. Similarly, any code that assigns a value to temperature will
   automatically call set_temperature(). This is one cool feature in Python.

   We can see above that set_temperature() was called even when we created an object.

   Can you guess why?

   The reason is that when an object is created, __init__() method gets called. This method has the line
   self.temperature = temperature. This assignment automatically called set_temperature().
>>> c.temperature
Getting value
0

   Similarly, any access like c.temperature automatically calls get_temperature(). This is what property
   does. Here are a few more examples.
>>> c.temperature = 37
Setting value

>>> c.to_fahrenheit()
Getting value
98.60000000000001

   By using property, we can see that, we modified our class and implemented the value constraint
   without any change required to the client code. Thus our implementation was backward compatible and
   everybody is happy.

   Finally note that, the actual temperature value is stored in the private variable _temperature. The
   attribute temperature is a property object which provides interface to this private variable.

Digging Deeper into Property
   In Python, property() is a built-in function that creates and returns a property object. The
   signature of this function is
property(fget=None, fset=None, fdel=None, doc=None)

   where, fget is function to get value of the attribute, fset is function to set value of the
   attribute, fdel is function to delete the attribute and doc is a string (like a comment). As seen
   from the implementation, these function arguments are optional. So, a property object can simply be
   created as follows.
>>> property()
<property object at 0x0000000003239B38>

   A property object has three methods, getter(), setter(), and deleter() to specify fget, fset and fdel
   at a later point. This means, the line
temperature = property(get_temperature,set_temperature)

   could have been broken down as
# make empty property
temperature = property()
# assign fget
temperature = temperature.getter(get_temperature)
# assign fset
temperature = temperature.setter(set_temperature)

   These two pieces of codes are equivalent.

   Programmers familiar with [https://www.programiz.com/python-programming/decorator]decorators in Python can
   recognize that the above construct can be implemented as decorators.

   We can further go on and not define names get_temperature and set_temperature as they are unnecessary
   and pollute the class namespace. For this, we reuse the name temperature while defining our getter
   and setter functions. This is how it can be done.
class Celsius:
    def __init__(self, temperature = 0):
        self._temperature = temperature

    def to_fahrenheit(self):
        return (self.temperature * 1.8) + 32

    @property
    def temperature(self):
        print("Getting value")
        return self._temperature

    @temperature.setter
    def temperature(self, value):
        if value < -273:
            raise ValueError("Temperature below -273 is not possible")
        print("Setting value")
        self._temperature = value

   The above implementation is both, simple and recommended way to make properties. You will most likely
   encounter these types of constructs when looking for property in Python.


---
https://www.programiz.com/python-programming/methods/built-in/property

Python property()

   The property() method a returns a property attribute.

   The syntax of property() method is:
property(fget=None, fset=None, fdel=None, doc=None)

property() Parameters
   The property() method takes four optional parameters:
     * fget (Optional) - function for getting the attribute value
     * fset (Optional) - function for setting the attribute value
     * fdel (Optional) - function for deleting the attribute value
     * doc (Optional) - string that contains the documentation (docstring) for the attribute

Return value from property()
   The property() method returns a property attribute from the given getter, setter and deleter.
     * If no arguments are given, property() method returns a base property attribute that doesn't
       contain any getter, setter or deleter.
     * If doc isn't provided, property() method takes the docstring of the getter function.

Example 1: Create attribute with getter, setter and deleter using property()

class Person:
    def __init__(self, name):
        self._name = name

    def getName(self):
        print('Getting name')
        return self._name

    def setName(self, value):
        print('Setting name to ' + value)
        self._name = value

    def delName(self):
        print('Deleting name')
        del self._name

    # Set property to use getName, setName
    # and delName methods
    name = property(getName, setName, delName, 'Name property')


p = Person('Adam')
print(p.name)

p.name = 'John'

del p.name

   When you run the program, the output will be:
Getting name
The name is: Adam
Setting name to John
Deleting name

   Here, _name is used as the private variable for storing the name of a Person.

   We also set:
     * a getter method getName() to get the name of the person,
     * a setter method setName() to set the name of the person,
     * a deleter method delName() to delete the name of the person.

   Now, we set a new property attribute name by calling the property() method.

   As shown in the program, referencing p.name internally calls getName() as getter, setName() as setter
   and delName() as deleter through the printed output present inside the methods.

   We also set the docstring of the attribute to 'Name property'.

Example 2: Create attribute with getter, setter and deleter using @property decorator

   Instead of using the property() method, you can use the [16]Python decorator @property to assign the
   getter, setter and deleter.
class Person:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        print('Getting name')
        return self._name

    @name.setter
    def name(self, value):
        print('Setting name to ' + value)
        self._name = value

    @name.deleter
    def name(self):
        print('Deleting name')
        del self._name

p = Person('Adam')
print('The name is:', p.name)

p.name = 'John'

del p.name

   When you run the program, the output will be:
Getting name
The name is: Adam
Setting name to John
Deleting name

   Here, instead of using the property() method, we've used the @property decorator.

   First, we specify that name() method is also an attribute of Person. This is done by using @property
   before the getter method as shown in the program.

   Next, we use the attribute name to specify the setter and the deleter.

   This is done by using @<name-of-attribute>.setter (@name.setter) for setter method and
   @<name-of-attribute>.deleter (@name.deleter) for deleter method.

   Notice, we've used the same method name() with different definitions for defining the getter, setter
   and deleter.

   Now, whenever we use p.name, it internally calls the appropriate getter, setter and deleter as shown
   by the printed output present inside the method.


---
https://stackoverflow.com/questions/17330160/how-does-the-property-decorator-work

How does the @property decorator work?

   I would like to understand how the built-in function property works. What confuses me is that
   property can also be used as a decorator, but it only takes arguments when used as a built-in
   function and not when used as a decorator.

   This example is from the documentation:
class C(object):
    def __init__(self):
        self._x = None

    def getx(self):
        return self._x
    def setx(self, value):
        self._x = value
    def delx(self):
        del self._x
    x = property(getx, setx, delx, "I'm the 'x' property.")

   property's arguments are getx, setx, delx and a doc string.

   In the code below property is used as decorator. The object of it is the x function, but in the code
   above there is no place for an object function in the arguments.
class C(object):
    def __init__(self):
        self._x = None

    @property
    def x(self):
        """I'm the 'x' property."""
        return self._x

    @x.setter
    def x(self, value):
        self._x = value

    @x.deleter
    def x(self):
        del self._x

   And, how are the x.setter and x.deleter decorators created? I am confused.

***   
       property is actually a class (not a function), although it does probably does call the __init__()
       method when you make an object, of course. Using help(property) from the terminal is insightful.
       help is also a class for some reason.

***
   The property() function returns a special [48]descriptor object:
>>> property()
<property object at 0x10ff07940>

   It is this object that has extra methods:
>>> property().getter
<built-in method getter of property object at 0x10ff07998>
>>> property().setter
<built-in method setter of property object at 0x10ff07940>
>>> property().deleter
<built-in method deleter of property object at 0x10ff07998>

   These act as decorators too. They return a new property object:
>>> property().getter(None)
<property object at 0x10ff079f0>

   that is a copy of the old object, but with one of the functions replaced.

   Remember, that the @decorator syntax is just syntactic sugar; the syntax:
@property
def foo(self): return self._foo

   really means the same thing as
def foo(self): return self._foo
foo = property(foo)

   so foo the function is replaced by property(foo), which we saw above is a special object. Then when
   you use @foo.setter(), what you are doing is call that property().setter method I showed you above,
   which returns a new copy of the property, but this time with the setter function replaced with the
   decorated method.

   The following sequence also creates a full-on property, by using those decorator methods.

   First we create some functions and a property object with just a getter:
>>> def getter(self): print 'Get!'
...
>>> def setter(self, value): print 'Set to {!r}!'.format(value)
...
>>> def deleter(self): print 'Delete!'
...
>>> prop = property(getter)
>>> prop.fget is getter
True
>>> prop.fset is None
True
>>> prop.fdel is None
True

   Next we use the .setter() method to add a setter:
>>> prop = prop.setter(setter)
>>> prop.fget is getter
True
>>> prop.fset is setter
True
>>> prop.fdel is None
True

   Last we add a deleter with the .deleter() method:
>>> prop = prop.deleter(deleter)
>>> prop.fget is getter
True
>>> prop.fset is setter
True
>>> prop.fdel is deleter
True

   Last but not least, the property object acts as a [49]descriptor object, so it has .__get__(),
   .__set__() and .__delete__() methods to hook into instance attribute getting, setting and
   deleting:
>>> class Foo(object): pass
...
>>> prop.__get__(Foo(), Foo)
Get!
>>> prop.__set__(Foo(), 'bar')
Set to 'bar'!
>>> prop.__delete__(Foo())
Delete!

   The Descriptor Howto includes a pure python sample implementation of the property() type:

class Property(object):
    "Emulate PyProperty_Type() in Objects/descrobject.c"

    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        if doc is None and fget is not None:
            doc = fget.__doc__
        self.__doc__ = doc

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError("unreadable attribute")
        return self.fget(obj)

    def __set__(self, obj, value):
        if self.fset is None:
            raise AttributeError("can't set attribute")
        self.fset(obj, value)

    def __delete__(self, obj):
        if self.fdel is None:
            raise AttributeError("can't delete attribute")
        self.fdel(obj)

    def getter(self, fget):
        return type(self)(fget, self.fset, self.fdel, self.__doc__)

    def setter(self, fset):
        return type(self)(self.fget, fset, self.fdel, self.__doc__)

    def deleter(self, fdel):
        return type(self)(self.fget, self.fset, fdel, self.__doc__)

***
       Very good. You could add the fact that after Foo.prop = prop you can do Foo().prop = 5; pront
       Foo().prop; del Foo().prop with the desired outcome. – [58]glglgl Jun 27 '13 at 7:25

***
       Method objects are created on the fly and can reuse the same memory location if available.
       – [59]Martijn Pieters♦ Jun 12 '14 at 19:15

***
       @MarkusMeskanen: I rather use type() as accessing dunder attributes and methods are meant to be
       used as extension points by the standard functions and operators. – [60]Martijn Pieters♦ Mar 10
       '15 at 21:46

***
       @MarkusMeskanen: because the object is immutable, and if you mutated it in place you could not
       specialise it in a subclass. – [61]Martijn Pieters♦ Jun 13 '15 at 14:25

***
       @MarkusMeskanen: see [62]Python overriding getter without setter; if @human.name.getter altered
       the property object in-place rather than return a new, the human.name attribute would be altered,
       changing the behaviour of that superclass. – [63]Martijn Pieters♦ Jun 13 '15 at 14:33

***
   [65]Documentation says it's just a shortcut for creating readonly properties. So
@property
def x(self):
    return self._x

   is equivalent to
def getx(self):
    return self._x
x = property(getx)

   [66]share|[67]improve this answer
   [68]edited Jul 15 '16 at 20:45
   [69]λuser
   654511
   answered Jun 26 '13 at 20:52
   [70]J0HN
   19k33773

   add a comment |
   up vote 64 down vote

   The first part is simple:
@property
def x(self): ...

   is the same as
def x(self): ...
x = property(x)

     * which, in turn, is the simplified syntax for creating a property with just a getter.

   The next step would be to extend this property with a setter and a deleter. And this happens with the
   appropriate methods:
@x.setter
def x(self, value): ...

   returns a new property which inherits everything from the old x plus the given setter.

   x.deleter works the same way.

***
   Here is a minimal example of how @property can be implemented:
class Thing:
    def __init__(self, my_word):
        self._word = my_word
    @property
    def word(self):
        return self._word

>>> print( Thing('ok').word )
'ok'

   Otherwise word remains a method instead of a property.
class Thing:
    def __init__(self, my_word):
        self._word = my_word
    def word(self):
        return self._word

>>> print( Thing('ok').word() )
'ok'

***
   This following:
class C(object):
    def __init__(self):
        self._x = None

    @property
    def x(self):
        """I'm the 'x' property."""
        return self._x

    @x.setter
    def x(self, value):
        self._x = value

    @x.deleter
    def x(self):
        del self._x

   Is the same as:
class C(object):
    def __init__(self):
        self._x = None

    def _x_get(self):
        return self._x

    def _x_set(self, value):
        self._x = value

    def _x_del(self):
        del self._x

    x = property(_x_get, _x_set, _x_del,
                    "I'm the 'x' property.")

   Is the same as:
class C(object):
    def __init__(self):
        self._x = None

    def _x_get(self):
        return self._x

    def _x_set(self, value):
        self._x = value

    def _x_del(self):
        del self._x

    x = property(_x_get, doc="I'm the 'x' property.")
    x = x.setter(_x_set)
    x = x.deleter(_x_del)

   Is the same as:
class C(object):
    def __init__(self):
        self._x = None

    def _x_get(self):
        return self._x
    x = property(_x_get, doc="I'm the 'x' property.")

    def _x_set(self, value):
        self._x = value
    x = x.setter(_x_set)

    def _x_del(self):
        del self._x
    x = x.deleter(_x_del)

   Which is the same as :
class C(object):
    def __init__(self):
        self._x = None

    @property
    def x(self):
        """I'm the 'x' property."""
        return self._x

    @x.setter
    def x(self, value):
        self._x = value

    @x.deleter
    def x(self):
        del self._x

***
   I read all the posts here and realized that we may need a real life example, Why, actually, we have
   @property? So, consider a Flask app where you use authentication system. You declare a model User in
   models.py:
class User(UserMixin, db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(64), unique=True, index=True)
    username = db.Column(db.String(64), unique=True, index=True)
    password_hash = db.Column(db.String(128))

    ...

    @property
    def password(self):
        raise AttributeError('password is not a readable attribute')

    @password.setter
    def password(self, password):
        self.password_hash = generate_password_hash(password)

    def verify_password(self, password):
        return check_password_hash(self.password_hash, password)

   In this code we've "hidden" attribute password by using @property which triggers AttributeError
   assertion when you try to access it directly, while we used @property.setter to set the actual
   instance variable password_hash.

   Now in auth/views.py we can instantiate a User with:
...
@auth.route('/register', methods=['GET', 'POST'])
def register():
    form = RegisterForm()
    if form.validate_on_submit():
        user = User(email=form.email.data,
                    username=form.username.data,
                    password=form.password.data)
        db.session.add(user)
        db.session.commit()
...

   Notice attribute password that comes from a registration form when a user fills the form. Password
   confirmation happens on the front end with EqualTo('password', message='Passwords must match') (in
   case if you are wondering, but it's a different topic related Flask forms).

   I hope this example will be useful

***
   Let's start with Python decorators.

   A Python decorator is a function that helps to add some additional functionalities to an already
   defined function.

   In Python everything is an object, In Python, everything is an object. Functions in Python are
   first-class objects which means that they can be referenced by a variable, added in the lists, passed
   as arguments to another function etc.

   Consider the following code snippet.
def decorator_func(fun):
    def wrapper_func():
        print("Wrapper function started")
        fun()
        print("Given function decorated")
        # Wrapper function add something to the passed function and decorator
        # returns the wrapper function
    return wrapper_func

def say_bye():
    print("bye!!")

say_bye = decorator_func(say_bye)
say_bye()

# Output:
#  Wrapper function started
#  bye
#  Given function decorated

   Here, we can say that decorator function modified our say_hello function and added some extra lines
   of code in it.

   Python syntax for decorator
def decorator_func(fun):
    def wrapper_func():
        print("Wrapper function started")
        fun()
        print("Given function decorated")
        # Wrapper function add something to the passed function and decorator
        # returns the wrapper function
    return wrapper_func

@decorator_func
def say_bye():
    print("bye!!")

say_bye()

   Let's Concluded everything than with a case scenario, but before that let's talk about some oops
   priniciples.

   Getters and setters are used in many object oriented programming languages to ensure the principle of
   data encapsulation(is seen as the bundling of data with the methods that operate on these data.)

   These methods are of course the getter for retrieving the data and the setter for changing the data.

   According to this principle, the attributes of a class are made private to hide and protect them from
   other code.

   Yup, @property is basically a pythonic way to use getters and setters.

   Python has a great concept called property which makes the life of an object-oriented programmer much
   simpler.

   Let us assume that you decide to make a class that could store the temperature in degree Celsius.
class Celsius:
def __init__(self, temperature = 0):
    self.set_temperature(temperature)

def to_fahrenheit(self):
    return (self.get_temperature() * 1.8) + 32

def get_temperature(self):
    return self._temperature

def set_temperature(self, value):
    if value < -273:
        raise ValueError("Temperature below -273 is not possible")
    self._temperature = value

   Refactored Code, Here is how we could have achieved it with property.

   In Python, property() is a built-in function that creates and returns a property object.

   A property object has three methods, getter(), setter(), and delete().
class Celsius:
def __init__(self, temperature = 0):
    self.temperature = temperature

def to_fahrenheit(self):
    return (self.temperature * 1.8) + 32

def get_temperature(self):
    print("Getting value")
    return self.temperature

def set_temperature(self, value):
    if value < -273:
        raise ValueError("Temperature below -273 is not possible")
    print("Setting value")
    self.temperature = value

temperature = property(get_temperature,set_temperature)

   Here,
temperature = property(get_temperature,set_temperature)

   could have been broken down as,
# make empty property
temperature = property()
# assign fget
temperature = temperature.getter(get_temperature)
# assign fset
temperature = temperature.setter(set_temperature)

   Point To Note:
     * get_temperature remains a property instead of a method.

   Now you can access the value of temperature by writing.
C = Celsius()
C.temperature
# instead of writing C.get_temperature()

   We can further go on and not define names get_temperature and set_temperature as they are unnecessary
   and pollute the class namespace.

   The pythonic way to deal with the above problem is to use @property.
class Celsius:
    def __init__(self, temperature = 0):
        self.temperature = temperature

    def to_fahrenheit(self):
        return (self.temperature * 1.8) + 32

    @property
    def temperature(self):
        print("Getting value")
        return self.temperature

    @temperature.setter
    def temperature(self, value):
        if value < -273:
            raise ValueError("Temperature below -273 is not possible")
        print("Setting value")
        self.temperature = value

   Points to Note -
    1. A method which is used for getting a value is decorated with "@property".
    2. The method which has to function as the setter is decorated with "@temperature.setter", If the
       function had been called "x", we would have to decorate it with "@x.setter".
    3. We wrote "two" methods with the same name and a different number of parameters "def
       temperature(self)" and "def temperature(self,x)".

   As you can see, the code is definitely less elegant.

   Now,let's talk about one real-life practical scenerio.

   Let's say you have designed a class as follows:
class OurClass:

    def __init__(self, a):
        self.x = a


y = OurClass(10)
print(y.x)

   Now, let's further assume that our class got popular among clients and they started using it in their
   programs, They did all kinds of assignments to the object.

   And One fateful day, a trusted client came to us and suggested that "x" has to be a value between 0
   and 1000, this is really a horrible scenario!

   Due to properties it's easy: We create a property version of "x".
class OurClass:

    def __init__(self,x):
        self.x = x

    @property
    def x(self):
        return self.__x

    @x.setter
    def x(self, x):
        if x < 0:
            self.__x = 0
        elif x > 1000:
            self.__x = 1000
        else:
            self.__x = x

   This is great, isn't it: You can start with the simplest implementation imaginable, and you are free
   to later migrate to a property version without having to change the interface! So properties are not
   just a replacement for getters and setter!

***
     * Your Celsius class is going to infinitely recurse when setting (which means upon instantiation).
       – [92]Ted Petrou Sep 23 at 12:25

***
       @Ted Petrou I Didn't get you? How it will infinitely recurse when setting? – [93]Divyanshu Rawat
       Sep 23 at 12:37

***
   A property can be declared in two ways.
     * Creating the getter, setter methods for an attribute and then passing these as argument to
       property function
     * Using the @property decorator.

***
   Here is another example:
##
## Python Properties Example
##
class GetterSetterExample( object ):
    ## Set the default value for x ( we reference it using self.x, set a value using self.x = value )
    __x = None


##
## On Class Initialization - do something... if we want..
##
def __init__( self ):
    ## Set a value to __x through the getter / setter... Since __x is defined above, this doesn't need to be s
et...
    self.x = 1234

    return None


##
## Define x as a property, ie a getter - All getters should have a default value arg, so I added it - it will
not be passed in when setting a value, so you need to set the default here so it will be used..
##
@property
def x( self, _default = None ):
    ## I added an optional default value argument as all getters should have this - set it to the default valu
e you want to return...
    _value = ( self.__x, _default )[ self.__x == None ]

    ## Debugging - so you can see the order the calls are made...
    print( '[ Test Class ] Get x = ' + str( _value ) )

    ## Return the value - we are a getter afterall...
    return _value


##
## Define the setter function for x...
##
@x.setter
def x( self, _value = None ):
    ## Debugging - so you can see the order the calls are made...
    print( '[ Test Class ] Set x = ' + str( _value ) )

    ## This is to show the setter function works.... If the value is above 0, set it to a negative value...
	otherwise keep it as is ( 0 is the only non-negative number, it can't be negative or positive anyway )
    if ( _value > 0 ):
        self.__x = -_value
    else:
        self.__x = _value


##
## Define the deleter function for x...
##
@x.deleter
def x( self ):
    ## Unload the assignment / data for x
    if ( self.__x != None ):
        del self.__x


##
## To String / Output Function for the class - this will show the property value for each property we add...
##
def __str__( self ):
    ## Output the x property data...
    print( '[ x ] ' + str( self.x ) )


    ## Return a new line - technically we should return a string so it can be printed where we want it,
	instead of printed early if _data = str( C( ) ) is used....
    return '\n'

##
##
##
_test = GetterSetterExample( )
print( _test )

## For some reason the deleter isn't being called...
del _test.x

   Basically, the same as the C( object ) example except I'm using x instead... I also don't initialize
   in __init - ... well.. I do, but it can be removed because __x is defined as part of the class....

   The output is:
[ Test Class ] Set x = 1234
[ Test Class ] Get x = -1234
[ x ] -1234

   and if I comment out the self.x = 1234 in init then the output is:
[ Test Class ] Get x = None
[ x ] None

   and if I set the _default = None to _default = 0 in the getter function ( as all getters should have
   a default value but it isn't passed in by the property values from what I've seen so you can define
   it here, and it actually isn't bad because you can define the default once and use it everywhere )
   ie: def x( self, _default = 0 ):
[ Test Class ] Get x = 0
[ x ] 0

   Note: The getter logic is there just to have the value be manipulated by it to ensure it is
   manipulated by it - the same for the print statements...

   Note: I'm used to Lua and being able to dynamically create 10+ helpers when I call a single function
   and I made something similar for Python without using properties and it works to a degree, but, even
   though the functions are being created before being used, there are still issues at times with them
   being called prior to being created which is strange as it isn't coded that way... I prefer the
   flexibility of Lua meta-tables and the fact I can use actual setters / getters instead of essentially
   directly accessing a variable... I do like how quickly some things can be built with Python though -
   for instance gui programs. although one I am designing may not be possible without a lot of
   additional libraries - if I code it in AutoHotkey I can directly access the dll calls I need, and the
   same can be done in Java, C#, C++, and more - maybe I haven't found the right thing yet but for that
   project I may switch from Python..

   Note: The code output in this forum is broken - I had to add spaces to the first part of the code for
   it to work - when copy / pasting ensure you convert all spaces to tabs.... I use tabs for Python
   because in a file which is 10,000 lines the filesize can be 512KB to 1MB with spaces and 100 to 200KB
   with tabs which equates to a massive difference for file size, and reduction in processing time...

   Tabs can also be adjusted per user - so if you prefer 2 spaces width, 4, 8 or whatever you can do it
   meaning it is thoughtful for developers with eye-sight deficits.

   Note: All of the functions defined in the class aren't indented properly because of a bug in the
   forum software - ensure you indent it if you copy / paste

***
   Below is another example on how @property can help when one has to refactor code (I only summarize it below):

   Imagine you created a class Money like this:
class Money:
    def __init__(self, dollars, cents):
        self.dollars = dollars
        self.cents = cents

   and an user creates a library depending on this class where he/she uses e.g.
money = Money(27, 12)

print("I have {} dollar and {} cents.".format(money.dollars, money.cents))
# prints I have 27 dollar and 12 cents.

   Now let's suppose you decide to change your Money class and get rid of the dollars and cents
   attributes but instead decide to only track the total amount of cents:
class Money:
    def __init__(self, dollars, cents):
        self.total_cents = dollars * 100 + cents

   If the above mentioned user now tries to run his/her library as before
money = Money(27, 12)

print("I have {} dollar and {} cents.".format(money.dollars, money.cents))

   it will result in an error

     AttributeError: 'Money' object has no attribute 'dollars'

   That means that now everyone who relies on your original Money class would have to change all lines
   of code where dollars and cents are used which can be very painful... So, how could this be avoided?
   By using @property!

   That is how:
class Money:
    def __init__(self, dollars, cents):
        self.total_cents = dollars * 100 + cents

    # Getter and setter for dollars...
    @property
    def dollars(self):
        return self.total_cents // 100

    @dollars.setter
    def dollars(self, new_dollars):
        self.total_cents = 100 * new_dollars + self.cents

    # And the getter and setter for cents.
    @property
    def cents(self):
        return self.total_cents % 100

    @cents.setter
    def cents(self, new_cents):
        self.total_cents = 100 * self.dollars + new_cents

   when we now call from our library
money = Money(27, 12)

print("I have {} dollar and {} cents.".format(money.dollars, money.cents))
# prints I have 27 dollar and 12 cents.

   it will work as expected and we did not have to change a single line of code in our library! In fact,
   we would not even have to know that the library we depend on changed.

   Also the setter works fine:
money.dollars += 2
print("I have {} dollar and {} cents.".format(money.dollars, money.cents))
# prints I have 29 dollar and 12 cents.

money.cents += 10
print("I have {} dollar and {} cents.".format(money.dollars, money.cents))
# prints I have 29 dollar and 22 cents.


---
https://stackoverflow.com/questions/6304040/real-world-example-about-how-to-use-property-feature-in-python

Real world example about how to use property feature in python?

   I am interested in how to use @property in Python. I've read the python docs and the example there,
   in my opinion, is just a toy code:
class C(object):
    def __init__(self):
        self._x = None

    @property
    def x(self):
        """I'm the 'x' property."""
        return self._x

    @x.setter
    def x(self, value):
        self._x = value

    @x.deleter
    def x(self):
        del self._x

   I do not know what benefit(s) I can get from wrapping the _x filled with the property decorator. Why
   not just implement as:
class C(object):
    def __init__(self):
        self.x = None

   I think, the property feature might be useful in some situations. But when? Could someone please give
   me some real-world examples?

   Thanks.

***
   Other examples would be validation/filtering of the set attributes (forcing them to be in bounds or
   acceptable) and lazy evaluation of complex or rapidly changing terms.

   Complex calculation hidden behind an attribute:
class PDB_Calculator(object):
    ...
    @property
    def protein_folding_angle(self):
        # number crunching, remote server calls, etc
        # all results in an angle set in 'some_angle'
        # It could also reference a cache, remote or otherwise,
        # that holds the latest value for this angle
        return some_angle

>>> f = PDB_Calculator()
>>> angle = f.protein_folding_angle
>>> angle
44.33276

   Validation:
class Pedometer(object)
    ...
    @property
    def stride_length(self):
        return self._stride_length

    @stride_length.setter
    def stride_length(self, value):
        if value > 10:
            raise ValueError("This pedometer is based on the human stride - a stride length above 10m is not
			supported")
        else:
            self._stride_length = value

***
       Nice. Also i'm strongly against side effects in a not designated place. it's better to throw an
       exception here – [53]Stanislav Ageev Jun 10 '11 at 9:10
     * True, probably should've raised an Exception there ... lazyness strikes ;) – [54]benosteen Jun 10

***
       I like the PDB_Calculator example -- complicated things are abstracted away, the whole thing
       works and the user can enjoy simplicity! – [55]Adam Kurkiewicz Jun 5 '13 at 20:33

***
   One simple use case will be to set a read only instance attribute , as you know leading a variable
   name with one underscore _x in python usually mean it's private (internal use) but sometimes we want
   to be able to read the instance attribute and not to write it so we can use property for this:
>>> class C(object):

        def __init__(self, x):
            self._x = x

        @property
        def x(self):
            return self._x

>>> c = C(1)
>>> c.x
1
>>> c.x = 2
AttributeError        Traceback (most recent call last)

AttributeError: can't set attribute

***
   One thing I've used it for is caching slow-to-look-up, but unchanging, values stored in a database.
   This generalises to any situation where your attributes require computation or some other long
   operation (eg. database check, network communication) which you only want to do on demand.
class Model(object):

  def get_a(self):
    if not hasattr(self, "_a"):
      self._a = self.db.lookup("a")
    return self._a

  a = property(get_a)

   This was in a web app where any given page view might only need one particular attribute of this
   kind, but the underlying objects themselves might have several such attributes - initialising them
   all on construction would be wasteful, and properties allow me to be flexible in which attributes are
   lazy and which aren't.

***
     * Can't you use @cached_property for this? – [71]adarsh Nov 11 '14 at 15:27

***	 
     * @adarsh - Sounds interesting. Where is that? – [72]detly Nov 11 '14 at 21:41

***  * I've been using it but I forgot that it wasn't a built in, but you can use it with this,
       pypi.python.org/pypi/cached-property/0.1.5 – [74]adarsh Nov 11 '14 at 21:54

***  * 2
       Interesting. I think it was first published after this answer, but anyone reading this should
       probably use it instead. – [75]detly Nov 11 '14 at 21:58

***
   Property is just an abstraction around a field which give you more control on ways that a specific
   field can be manipulated and to do middleware computations. Few of the usages that come to mind is
   validation and prior initialization and access restriction
@property
def x(self):
    """I'm the 'x' property."""
    if self._x is None:
        self._x = Foo()

    return self._x

***
   Reading through the answers and comments, the main theme seems to be the answers seem to be missing a
   simple, yet useful example. I have included a very simple one here that demonstrates the simple use
   of the @property decorator. It's a class that allows a user to specify and get distance measurement
   using a variety of different units, i.e. in_feet or in_metres.
class Distance(object):
    def __init__(self):
        # This private attribute will store the distance in metres
        # All units provided using setters will be converted before
        # being stored
        self._distance = 0.0

    @property
    def in_metres(self):
        return self._distance

    @in_metres.setter
    def in_metres(self, val):
        try:
            self._distance = float(val)
        except:
            raise ValueError("The input you have provided is not recognised "
                             "as a valid number")

    @property
    def in_feet(self):
        return self._distance * 3.2808399

    @in_feet.setter
    def in_feet(self, val):
        try:
            self._distance = float(val) / 3.2808399
        except:
            raise ValueError("The input you have provided is not recognised "
                             "as a valid number")

    @property
    def in_parsecs(self):
        return self._distance * 3.24078e-17

    @in_parsecs.setter
    def in_parsecs(self, val):
        try:
            self._distance = float(val) / 3.24078e-17
        except:
            raise ValueError("The input you have provided is not recognised "
                             "as a valid number")

   Usage:
>>> distance = Distance()
>>> distance.in_metres = 1000.0
>>> distance.in_metres
1000.0
>>> distance.in_feet
3280.8399
>>> distance.in_parsecs
3.24078e-14

***
   The short answer to your question, is that in your example, there is no benefit. You should probably
   use the form that doesn't involve properties.

   The reason properties exists, is that if your code changes in the future, and you suddenly need to do
   more with your data: cache values, protect access, query some external resource... whatever, you can
   easily modify your class to add getters and setters for the data without changing the interface, so
   you don't have to find everywhere in your code where that data is accessed and change that too.

***
   Yes, for the original example posted, the property will work exactly the same as simply having an
   instance variable 'x'.

   This is the best thing about python properties. From the outside, they work exactly like instance
   variables! Which allows you to use instance variables from outside the class.

   This means your first example could actually use an instance variable. If things changed, and then
   you decide to change your implementation and a property is useful, the interface to the property
   would still be the same from code outside the class. A change from instance variable to property has
   no impact on code outside the class.

   Many other languages and programming courses will instruct that a programmer should never expose
   instance variables, and instead use 'getters' and 'setters' for any value to be accessed from outside
   the class, even the simple case as quoted in the question.

   Code outside the class with many languages (e.g. Java) use
object.get_i()
    #and
object.set_i(value)

#in place of (with python)
object.i
    #and
object.i = value

   And when implementing the class there are many 'getters' and 'setters' that do exactly as your first
   example: replicate a simply instance variable. These getters and setters are required because if the
   class implementation changes, all the code outside the class will need to change. But python
   properties allow code outside the class to be the same as with instance variables. So code outside
   the class does not need to be changed if you add a property, or have a simple instance variable. So
   unlike most Object Oriented languages, for your simple example you can use the instance variable
   instead of 'getters' and 'setters' that are really not needed, secure in the knowledge that if you
   change to a property in the future, the code using your class need not change.

   This means you only need create properties if there is complex behaviour, and for the very common
   simple case where, as described in the question, a simple instance variable is all that is needed,
   you can just use the instance variable.

***
   Something that many do not notice at first is that you can make your own subclasses of property. This
   I have found very useful for exposing read only object attributes or attribute you can read and write
   but not remove. It is also an excellent way to wrap functionality like tracking modifications to
   object fields.
class reader(property):
    def __init__(self, varname):
        _reader = lambda obj: getattr(obj, varname)
        super(reader, self).__init__(_reader)

class accessor(property):
    def __init__(self, varname, set_validation=None):
        _reader = lambda obj: getattr(obj, varname)
        def _writer(obj, value):
            if set_validation is not None:
               if set_validation(value):
                  setattr(obj, varname, value)
        super(accessor, self).__init__(_reader, _writer)

#example
class MyClass(object):
   def __init__(self):
     self._attr = None

   attr = reader('_attr')

***
     * I like this. Am I reading this correctly in that reader is read only while accessor is read/write
       without deletion capability? How would you add data validation though? I'm fairly new to Python
       but I'm thinking there is probably a way to add a callback to the attr = reader('_attr') line or
       some form of prechecking like attr = if self.__isValid(value): reader('_attr'). Suggestions?
       – [94]Gabe Spradlin Sep 23 '14 at 15:57
     * Sorry just realized I was asking about data validation for a read only variable. But obviously
       this would only apply to the setter portion of the accessor class. So change attr =
       reader('_attr') to attr = accessor('_attr'). Thanks – [95]Gabe Spradlin Sep 23 '14 at 16:08
     * You are right that if you wanted validation then you would add a function to validate and raise
       Exception if invalid (or whatever behavior you liked including doing nothing) to the init. I
       modified the above with one possible pattern. The validator should return True|False to guide
       whether the set happens or not. – user1969453 Oct 15 '14 at 23:33

***
   another nice feature of properties over using setters and getters it that they allow you to continue
   to use OP= operators (eg +=, -=, *= etc) on your attributes while still retaining any validation,
   access control, caching, etc that the setters and getters would supply.

   for example if you wrote the class Person with a setter setage(newage), and a getter getage(), then
   to increment the age you would have to write:
bob = Person('Robert', 25)
bob.setage(bob.getage() + 1)

   but if you made age a property you could write the much cleaner:
bob.age += 1

***
   Python has a great concept called property which makes the life of an object-oriented programmer much
   simpler.

   Before defining and going into details of what @property is, let us first build an intuition on why
   it would be needed in the first place.

   An Example To Begin With Let us assume that you decide to make a class that could store the
   temperature in degree Celsius. It would also implement a method to convert the temperature into
   degree Fahrenheit. One way of doing this is as follows.
class Celsius:
    def __init__(self, temperature = 0):
        self.temperature = temperature
    def to_fahrenheit(self):
        return (self.temperature * 1.8) + 32

   We could make objects out of this class and manipulate the attribute temperature as we wished. Try
   these on Python shell.
>>> # create new object
>>> man = Celsius()

>>> # set temperature
>>> man.temperature = 37

>>> # get temperature
>>> man.temperature
37

>>> # get degrees Fahrenheit
>>> man.to_fahrenheit()
98.60000000000001

   The extra decimal places when converting into Fahrenheit is due to the floating point arithmetic
   error (try 1.1 + 2.2 in the Python interpreter).

   Whenever we assign or retrieve any object attribute like temperature, as show above, Python searches
   it in the object's dict dictionary.
>>> man.__dict__
{'temperature': 37}

   Therefore, man.temperature internally becomes man.dict['temperature'].

   Now, let's further assume that our class got popular among clients and they started using it in their
   programs. They did all kinds of assignments to the object.

   One fateful day, a trusted client came to us and suggested that temperatures cannot go below -273
   degree Celsius (students of thermodynamics might argue that it's actually -273.15), also called the
   absolute zero. He further asked us to implement this value constraint. Being a company that strive
   for customer satisfaction, we happily heeded the suggestion and released version 1.01 (an upgrade of
   our existing class).

   Using Getters and Setters An obvious solution to the above constraint will be to hide the attribute
   temperature (make it private) and define new getter and setter interfaces to manipulate it. This can
   be done as follows.
class Celsius:
    def __init__(self, temperature = 0):
        self.set_temperature(temperature)
    def to_fahrenheit(self):
        return (self.get_temperature() * 1.8) + 32
    # new update
    def get_temperature(self):
        return self._temperature
    def set_temperature(self, value):
        if value < -273:
            raise ValueError("Temperature below -273 is not possible")
        self._temperature = value

   We can see above that new methods get_temperature() and set_temperature() were defined and
   furthermore, temperature was replaced with _temperature. An underscore (_) at the beginning is used
   to denote private variables in Python.
>>> c = Celsius(-277)
Traceback (most recent call last):
...
ValueError: Temperature below -273 is not possible

>>> c = Celsius(37)
>>> c.get_temperature()
37
>>> c.set_temperature(10)

>>> c.set_temperature(-300)
Traceback (most recent call last):
...
ValueError: Temperature below -273 is not possible

   This update successfully implemented the new restriction. We are no longer allowed to set temperature
   below -273.

   Please note that private variables don't exist in Python. There are simply norms to be followed. The
   language itself don't apply any restrictions.
>>> c._temperature = -300
>>> c.get_temperature()
-300

   But this is not of great concern. The big problem with the above update is that, all the clients who
   implemented our previous class in their program have to modify their code from obj.temperature to
   obj.get_temperature() and all assignments like obj.temperature = val to obj.set_temperature(val).

   This refactoring can cause headaches to the clients with hundreds of thousands of lines of codes.

   All in all, our new update was not backward compatible. This is where property comes to rescue.

   The Power of @property The pythonic way to deal with the above problem is to use property. Here is
   how we could have achieved it.
class Celsius:
    def __init__(self, temperature = 0):
        self.temperature = temperature
    def to_fahrenheit(self):
        return (self.temperature * 1.8) + 32
    def get_temperature(self):
        print("Getting value")
        return self._temperature
    def set_temperature(self, value):
        if value < -273:
            raise ValueError("Temperature below -273 is not possible")
        print("Setting value")
        self._temperature = value
    temperature = property(get_temperature, set_temperature)

   And, issue the following code in shell once you run it.
>>> c = Celsius()

   We added a print() function inside get_temperature() and set_temperature() to clearly observe that
   they are being executed.

   The last line of the code makes a property object temperature. Simply put, property attaches some
   code (get_temperature and set_temperature) to the member attribute accesses (temperature).

   Any code that retrieves the value of temperature will automatically call get_temperature() instead of
   a dictionary (dict) look-up. Similarly, any code that assigns a value to temperature will
   automatically call set_temperature(). This is one cool feature in Python.

   Property method should contain getter then the setter. Not the vice versa, Python will call first
   method(get_temperature) as getter and second method(set_temperature) as setter.
temperature = property(get_temperature, set_temperature)

   Possible Recursive setter

   In setter method, if we didn't use Underscore before the object attribute like below, it would result
   in Recursive calling of setter and RecursionError occurs.
def set_temperature(self, value):
    if value < -273:
        raise ValueError("Temperature below -273 is not possible")
    print("Setting value")
    self.temperature = value


---
https://stackabuse.com/the-python-property-decorator/

The Python Property Decorator
January 25, 2016

   It is often considered best practice to create getters and setters for a class's public properties.
   Many languages allow you to implement this in different ways, either by using a function (like
   person.getName()), or by using a language-specific get or set construct. In Python, it is done using
   @property.

   In this article I'll be describing they Python property decorator, which you may have seen being used
   with the @decorator syntax:
class Person(object):
    def __init__(self, first_name, last_name):
        self.first_name = first_name
        self.last_name = last_name

    @property
    def full_name(self):
        return self.first_name + ' ' + self.last_name

    @full_name.setter
    def full_name(self, value):
        first_name, last_name = value.split(' ')
        self.first_name = first_name
        self.last_name = last_name

    @full_name.deleter
    def full_name(self):
        del self.first_name
        del self.last_name

   This is Python's way of creating getters, setters, and deleters (or mutator methods) for a
   property in a class.

   In this case, the @property decorator makes it so you call the full_name(self) method like it is just
   a normal property, when in reality it is actually a method that contains code to be run when the
   property is set.

   Using a getter/setter/deleter like this provides us with quite a few advantages, a few of which I've
   listed here:
     * Validation: Before setting the internal property, you can validate that the provided value meets
       some criteria, and have it throw an error if it doesn't.
     * Lazy loading: Resources can by [12]lazily loaded to defer work until it is actually needed,
       saving time and resources
     * Abstraction: Getters and setters allow you to abstract out the internal representation of data.
       Like our example above, for example, the first and last names are stored separately, but the
       getters and setters contain the logic that uses the first and last names to create the full name.
     * Debugging: Since mutator methods can encapsulate any code, it becomes a great place for
       interception when debugging (or logging) your code. For example, you could log or inspect each
       time that a property's value is changed.

   Python achieves this functionality with decorators, which are special methods used to change the
   behavior of another function or class. In order to describe how the @property decorator works, let's
   take a look at a simpler decorator and how it works internally.

   A decorator is simply a function that takes another function as an argument and adding to its
   behavior by wrapping it. Here is a simple example:
# decorator.py

def some_func():
    print 'Hey, you guys'

def my_decorator(func):
    def inner():
        print 'Before func!'
        func()
        print 'After func!'

    return inner

print 'some_func():'
some_func()

print ''

some_func_decorated = my_decorator(some_func)

print 'some_func() with decorator:'
some_func_decorated()

   Running this code gives you:
$ python decorator.py
some_func():
Hey, you guys

some_func() with decorator:
Before func!
Hey, you guys
After func!

   As you can see, the my_decorator() function dynamically creates a new function to return using the
   input function, adding code to be executed before and after the original function runs.

   The property decorator is implemented with a pattern similar to the my_decorator function. Using the
   Python @decorator syntax, it receives the decorated function as an argument, just like in my example:
   some_func_decorated = my_decorator(some_func).

   So, going back to my first example, this code:
@property
def full_name_getter(self):
    return self.first_name + ' ' + self.last_name

   Is roughly equivalent to this:
def full_name_getter(self):
    return self.first_name + ' ' + self.last_name

full_name = property(full_name_getter)

   Note that I changed some function names for clarity.

   Then, later on when you want to use @full_name.setter as we do in the example, what you're really
   calling is:
def full_name_setter(self, value):
    first_name, last_name = value.split(' ')
    self.first_name = first_name
    self.last_name = last_name

full_name = property(full_name_getter)
full_name = full_name.setter(full_name_setter)

   Now this new full_name object (an instance of the property object) has both getter and setter
   methods.

   In order to use these with our class, Person, the property object acts as a descriptor, which means
   it has its own [13]__get__(), [14]__set__() and [15]__delete__() methods. The __get__() and __set__()
   methods are triggered on an object when a property is retrieved or set, and __delete__() is triggered
   when a property is deleted with del.

   So person.full_name = 'Billy Bob' triggers the __set__() method, which was inherited from object.
   This brings us to an important point - your class must inherit from object in order for this to work.
   So a class like this would not be able to use setter properties since it doesn't inherit from object:
class Person:
    pass

   Thanks to property, these methods now correspond to our full_name_getter and full_name_setter methods
   from above:
full_name.fget is full_name_getter    # True
full_name.fset is full_name_setter    # True

   fget and fset are now wrapped by .__get__() and .__set__(), respectively.

   And finally, these descriptor objects can be accessed by passing a reference to our class, Person:
>>> person = Person('Billy', 'Bob')
>>>
>>> full_name.__get__(person)
Billy Bob
>>>
>>> full_name.__set__(person, 'Timmy Thomas')
>>>
>>> person.first_name
Timmy
>>> person.last_name
Thomas

   This is essentially how properties work under the surface.

   
---
