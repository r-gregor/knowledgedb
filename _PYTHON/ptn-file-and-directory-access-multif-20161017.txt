filename: /c/Users/gregor.redelonghi/Dropbox/ODPRTO/_TXT/python_file-and-directory-access-multif_20161017.txt
https://docs.python.org/2/library/filesys.html

10. File and Directory Access?
The modules described in this chapter deal with disk files and directories. For example, there are modules
for reading the properties of files, manipulating paths in a portable way, and creating temporary files. The
full list of modules in this chapter is:

  * 10.1. os.path ? Common pathname manipulations
  * 10.2. fileinput ? Iterate over lines from multiple input streams
  * 10.3. stat ? Interpreting stat() results
  * 10.4. statvfs ? Constants used with os.statvfs()
  * 10.5. filecmp ? File and Directory Comparisons
      + 10.5.1. The dircmp class
  * 10.6. tempfile ? Generate temporary files and directories
  * 10.7. glob ? Unix style pathname pattern expansion
  * 10.8. fnmatch ? Unix filename pattern matching
  * 10.9. linecache ? Random access to text lines
  * 10.10. shutil ? High-level file operations
      + 10.10.1. Directory and files operations
          o 10.10.1.1. copytree example
      + 10.10.2. Archiving operations
          o 10.10.2.1. Archiving example
  * 10.11. dircache ? Cached directory listings
  * 10.12. macpath ? Mac OS 9 path manipulation functions


---
https://docs.python.org/2/library/os.path.html

10.1. os.path ? Common pathname manipulations?
This module implements some useful functions on pathnames. To read or write files see open(), and for
accessing the filesystem see the os module.

Note
On Windows, many of these functions do not properly support UNC pathnames. splitunc() and ismount() do handle
them correctly.

Unlike a unix shell, Python does not do any automatic path expansions. Functions such as expanduser() and
expandvars() can be invoked explicitly when an application desires shell-like path expansion. (See also the
glob module.)

Note
Since different operating systems have different path name conventions, there are several versions of this
module in the standard library. The os.path module is always the path module suitable for the operating
system Python is running on, and therefore usable for local paths. However, you can also import and use the
individual modules if you want to manipulate a path that is always in one of the different formats. They all
have the same interface:

  * posixpath for UNIX-style paths
  * ntpath for Windows paths
  * macpath for old-style MacOS paths
  * os2emxpath for OS/2 EMX paths

os.path.abspath(path)?
    Return a normalized absolutized version of the pathname path. On most platforms, this is equivalent to
    calling the function normpath() as follows: normpath(join(os.getcwd(), path)).
    New in version 1.5.2.

os.path.basename(path)?
    Return the base name of pathname path. This is the second element of the pair returned by passing path to
    the function split(). Note that the result of this function is different from the Unix basename program;
    where basename for '/foo/bar/' returns 'bar', the basename() function returns an empty string ('').

os.path.commonprefix(list)?
    Return the longest path prefix (taken character-by-character) that is a prefix of all paths in list. If
    list is empty, return the empty string (''). Note that this may return invalid paths because it works a
    character at a time.

os.path.dirname(path)?
    Return the directory name of pathname path. This is the first element of the pair returned by passing
    path to the function split().

os.path.exists(path)?
    Return True if path refers to an existing path. Returns False for broken symbolic links. On some
    platforms, this function may return False if permission is not granted to execute os.stat() on the
    requested file, even if the path physically exists.

os.path.lexists(path)?
    Return True if path refers to an existing path. Returns True for broken symbolic links. Equivalent to
    exists() on platforms lacking os.lstat().
    New in version 2.4.

os.path.expanduser(path)?
    On Unix and Windows, return the argument with an initial component of ~ or ~user replaced by that user?s
    home directory.

    On Unix, an initial ~ is replaced by the environment variable HOME if it is set; otherwise the current
    user?s home directory is looked up in the password directory through the built-in module pwd. An initial 
    ~user is looked up directly in the password directory.

    On Windows, HOME and USERPROFILE will be used if set, otherwise a combination of HOMEPATH and HOMEDRIVE
    will be used. An initial ~user is handled by stripping the last directory component from the created user
    path derived above.

    If the expansion fails or if the path does not begin with a tilde, the path is returned unchanged.

os.path.expandvars(path)?
    Return the argument with environment variables expanded. Substrings of the form $name or ${name} are
    replaced by the value of environment variable name. Malformed variable names and references to
    non-existing variables are left unchanged.
    On Windows, %name% expansions are supported in addition to $name and ${name}.

os.path.getatime(path)?
    Return the time of last access of path. The return value is a number giving the number of seconds since
    the epoch (see the time module). Raise os.error if the file does not exist or is inaccessible.
    New in version 1.5.2.

    Changed in version 2.3: If os.stat_float_times() returns True, the result is a floating point number.

os.path.getmtime(path)?
    Return the time of last modification of path. The return value is a number giving the number of seconds
    since the epoch (see the time module). Raise os.error if the file does not exist or is inaccessible.
    New in version 1.5.2.

    Changed in version 2.3: If os.stat_float_times() returns True, the result is a floating point number.

os.path.getctime(path)?
    Return the system?s ctime which, on some systems (like Unix) is the time of the last metadata change,
    and, on others (like Windows), is the creation time for path. The return value is a number giving the
    number of seconds since the epoch (see the time module). Raise os.error if the file does not exist or is
    inaccessible.
    New in version 2.3.

os.path.getsize(path)?
    Return the size, in bytes, of path. Raise os.error if the file does not exist or is inaccessible.
    New in version 1.5.2.

os.path.isabs(path)?
    Return True if path is an absolute pathname. On Unix, that means it begins with a slash, on Windows that
    it begins with a (back)slash after chopping off a potential drive letter.

os.path.isfile(path)?
    Return True if path is an existing regular file. This follows symbolic links, so both islink() and isfile
    () can be true for the same path.

os.path.isdir(path)?
    Return True if path is an existing directory. This follows symbolic links, so both islink() and isdir()
    can be true for the same path.

os.path.islink(path)?
    Return True if path refers to a directory entry that is a symbolic link. Always False if symbolic links
    are not supported by the Python runtime.

os.path.ismount(path)?
    Return True if pathname path is a mount point: a point in a file system where a different file system has
    been mounted. The function checks whether path?s parent, path/.., is on a different device than path, or
    whether path/.. and path point to the same i-node on the same device ? this should detect mount points
    for all Unix and POSIX variants.

os.path.join(path, *paths)?
    Join one or more path components intelligently. The return value is the concatenation of path and any
    members of *paths with exactly one directory separator (os.sep) following each non-empty part except the
    last, meaning that the result will only end in a separator if the last part is empty. If a component is
    an absolute path, all previous components are thrown away and joining continues from the absolute path
    component.

    On Windows, the drive letter is not reset when an absolute path component (e.g., r'\foo') is encountered.
    If a component contains a drive letter, all previous components are thrown away and the drive letter is
    reset. Note that since there is a current directory for each drive, os.path.join("c:", "foo") represents
    a path relative to the current directory on drive C: (c:foo), not c:\foo.

os.path.normcase(path)?
    Normalize the case of a pathname. On Unix and Mac OS X, this returns the path unchanged; on
    case-insensitive filesystems, it converts the path to lowercase. On Windows, it also converts forward
    slashes to backward slashes.

os.path.normpath(path)?
    Normalize a pathname by collapsing redundant separators and up-level references so that A//B, A/B/, A/./B
    and A/foo/../B all become A/B. This string manipulation may change the meaning of a path that contains
    symbolic links. On Windows, it converts forward slashes to backward slashes. To normalize case, use
    normcase().

os.path.realpath(path)?
    Return the canonical path of the specified filename, eliminating any symbolic links encountered in the
    path (if they are supported by the operating system).
    New in version 2.2.

os.path.relpath(path[, start])?
    Return a relative filepath to path either from the current directory or from an optional start directory.
    This is a path computation: the filesystem is not accessed to confirm the existence or nature of path or
    start.
    start defaults to os.curdir.
    Availability: Windows, Unix.
    New in version 2.6.

os.path.samefile(path1, path2)?
    Return True if both pathname arguments refer to the same file or directory (as indicated by device number
    and i-node number). Raise an exception if an os.stat() call on either pathname fails.
    Availability: Unix.

os.path.sameopenfile(fp1, fp2)?
    Return True if the file descriptors fp1 and fp2 refer to the same file.
    Availability: Unix.

os.path.samestat(stat1, stat2)?
    Return True if the stat tuples stat1 and stat2 refer to the same file. These structures may have been
    returned by os.fstat(), os.lstat(), or os.stat(). This function implements the underlying comparison used
    by samefile() and sameopenfile().
    Availability: Unix.

os.path.split(path)?
    Split the pathname path into a pair, (head, tail) where tail is the last pathname component and head is
    everything leading up to that. The tail part will never contain a slash; if path ends in a slash, tail
    will be empty. If there is no slash in path, head will be empty. If path is empty, both head and tail are
    empty. Trailing slashes are stripped from head unless it is the root (one or more slashes only). In all
    cases, join(head, tail) returns a path to the same location as path (but the strings may differ). Also
    see the functions dirname() and basename().

os.path.splitdrive(path)?
    Split the pathname path into a pair (drive, tail) where drive is either a drive specification or the
    empty string. On systems which do not use drive specifications, drive will always be the empty string. In
    all cases, drive + tail will be the same as path.
    New in version 1.3.

os.path.splitext(path)?
    Split the pathname path into a pair (root, ext) such that root + ext == path, and ext is empty or begins
    with a period and contains at most one period. Leading periods on the basename are ignored; splitext
    ('.cshrc') returns ('.cshrc', '').

    Changed in version 2.6: Earlier versions could produce an empty root when the only period was the first
    character.

os.path.splitunc(path)?
    Split the pathname path into a pair (unc, rest) so that unc is the UNC mount point (such as r'\\host\
    mount'), if present, and rest the rest of the path (such as r'\path\file.ext'). For paths containing
    drive letters, unc will always be the empty string.
    Availability: Windows.

os.path.walk(path, visit, arg)?
    Calls the function visit with arguments (arg, dirname, names) for each directory in the directory tree
    rooted at path (including path itself, if it is a directory). The argument dirname specifies the visited
    directory, the argument names lists the files in the directory (gotten from os.listdir(dirname)). The
    visit function may modify names to influence the set of directories visited below dirname, e.g. to avoid
    visiting certain parts of the tree. (The object referred to by names must be modified in place, using del
    or slice assignment.)

    Note
    Symbolic links to directories are not treated as subdirectories, and that walk() therefore will not visit
    them. To visit linked directories you must identify them with os.path.islink(file) and os.path.isdir
    (file), and invoke walk() as necessary.

    Note
    This function is deprecated and has been removed in Python 3 in favor of os.walk().

os.path.supports_unicode_filenames?
    True if arbitrary Unicode strings can be used as file names (within limitations imposed by the file
    system).
    New in version 2.3.


---
https://docs.python.org/2/library/filecmp.html

10.5. filecmp ? File and Directory Comparisons?
Source code: Lib/filecmp.py
-------------------------------------------------------------------------------------------------------------
The filecmp module defines functions to compare files and directories, with various optional time/correctness
trade-offs. For comparing files, see also the difflib module.

The filecmp module defines the following functions:

filecmp.cmp(f1, f2[, shallow])?
    Compare the files named f1 and f2, returning True if they seem equal, False otherwise.
    Unless shallow is given and is false, files with identical os.stat() signatures are taken to be equal.
    Files that were compared using this function will not be compared again unless their os.stat() signature
    changes.
    Note that no external programs are called from this function, giving it portability and efficiency.

filecmp.cmpfiles(dir1, dir2, common[, shallow])?
    Compare the files in the two directories dir1 and dir2 whose names are given by common.
    Returns three lists of file names: match, mismatch, errors. match contains the list of files that match,
    mismatch contains the names of those that don?t, and errors lists the names of files which could not be
    compared. Files are listed in errors if they don?t exist in one of the directories, the user lacks
    permission to read them or if the comparison could not be done for some other reason.
    The shallow parameter has the same meaning and default value as for filecmp.cmp().
    For example, cmpfiles('a', 'b', ['c', 'd/e']) will compare a/c with b/c and a/d/e with b/d/e. 'c' and 'd/
    e' will each be in one of the three returned lists.

Example:
>>> import filecmp
>>> filecmp.cmp('undoc.rst', 'undoc.rst')
True
>>> filecmp.cmp('undoc.rst', 'index.rst')
False

10.5.1. The dircmp class?
dircmp instances are built using this constructor:

class filecmp.dircmp(a, b[, ignore[, hide]])?
    Construct a new directory comparison object, to compare the directories a and b. ignore is a list of
    names to ignore, and defaults to ['RCS', 'CVS', 'tags']. hide is a list of names to hide, and defaults to
    [os.curdir, os.pardir].
    The dircmp class compares files by doing shallow comparisons as described for filecmp.cmp().
    
    The dircmp class provides the following methods:
    report()?

        Print (to sys.stdout) a comparison between a and b.

    report_partial_closure()?
        Print a comparison between a and b and common immediate subdirectories.

    report_full_closure()?
        Print a comparison between a and b and common subdirectories (recursively).

    The dircmp class offers a number of interesting attributes that may be used to get various bits of
    information about the directory trees being compared.

    Note that via __getattr__() hooks, all attributes are computed lazily, so there is no speed penalty if
    only those attributes which are lightweight to compute are used.

    left?
        The directory a.

    right?
        The directory b.

    left_list?
        Files and subdirectories in a, filtered by hide and ignore.

    right_list?
        Files and subdirectories in b, filtered by hide and ignore.

    common?
        Files and subdirectories in both a and b.

    left_only?
        Files and subdirectories only in a.

    right_only?
        Files and subdirectories only in b.

    common_dirs?
        Subdirectories in both a and b.

    common_files?
        Files in both a and b

    common_funny?
        Names in both a and b, such that the type differs between the directories, or names for which os.stat
        () reports an error.

    same_files?
        Files which are identical in both a and b, using the class?s file comparison operator.

    diff_files?
        Files which are in both a and b, whose contents differ according to the class?s file comparison
        operator.

    funny_files?
        Files which are in both a and b, but could not be compared.

    subdirs?
        A dictionary mapping names in common_dirs to dircmp objects.

Here is a simplified example of using the subdirs attribute to search recursively through two directories to
show common different files:

>>> from filecmp import dircmp
>>> def print_diff_files(dcmp):
...     for name in dcmp.diff_files:
...         print "diff_file %s found in %s and %s" % (name, dcmp.left,
...               dcmp.right)
...     for sub_dcmp in dcmp.subdirs.values():
...         print_diff_files(sub_dcmp)
...
>>> dcmp = dircmp('dir1', 'dir2')
>>> print_diff_files(dcmp)



---
https://docs.python.org/2/library/tempfile.html

10.6. tempfile ? Generate temporary files and directories?

Source code: Lib/tempfile.py
-------------------------------------------------------------------------------------------------------------
This module generates temporary files and directories. It works on all supported platforms.

In version 2.3 of Python, this module was overhauled for enhanced security. It now provides three new
functions, NamedTemporaryFile(), mkstemp(), and mkdtemp(), which should eliminate all remaining need to use
the insecure mktemp() function. Temporary file names created by this module no longer contain the process ID;
instead a string of six random characters is used.

Also, all the user-callable functions now take additional arguments which allow direct control over the
location and name of temporary files. It is no longer necessary to use the global tempdir and template
variables. To maintain backward compatibility, the argument order is somewhat odd; it is recommended to use
keyword arguments for clarity.

The module defines the following user-callable functions:
tempfile.TemporaryFile([mode='w+b'[, bufsize=-1[, suffix=''[, prefix='tmp'[, dir=None]]]]])?

    Return a file-like object that can be used as a temporary storage area. The file is created using mkstemp
    (). It will be destroyed as soon as it is closed (including an implicit close when the object is garbage
    collected). Under Unix, the directory entry for the file is removed immediately after the file is
    created. Other platforms do not support this; your code should not rely on a temporary file created using
    this function having or not having a visible name in the file system.

    The mode parameter defaults to 'w+b' so that the file created can be read and written without being
    closed. Binary mode is used so that it behaves consistently on all platforms without regard for the data
    that is stored. bufsize defaults to -1, meaning that the operating system default is used.

    The dir, prefix and suffix parameters are passed to mkstemp().

    The returned object is a true file object on POSIX platforms. On other platforms, it is a file-like
    object whose file attribute is the underlying true file object. This file-like object can be used in a
    with statement, just like a normal file.

tempfile.NamedTemporaryFile([mode='w+b'[, bufsize=-1[, suffix=''[, prefix='tmp'[, \
	dir=None[, delete=True]]]]]])?
    This function operates exactly as TemporaryFile() does, except that the file is guaranteed to have a
    visible name in the file system (on Unix, the directory entry is not unlinked). That name can be
    retrieved from the name attribute of the returned file-like object. Whether the name can be used to open
    the file a second time, while the named temporary file is still open, varies across platforms (it can be
    so used on Unix; it cannot on Windows NT or later). If delete is true (the default), the file is deleted
    as soon as it is closed.

    The returned object is always a file-like object whose file attribute is the underlying true file object.
    This file-like object can be used in a with statement, just like a normal file.
    New in version 2.3.
    New in version 2.6: The delete parameter.

tempfile.SpooledTemporaryFile([max_size=0[, mode='w+b'[, bufsize=-1[, suffix=''[, \
	prefix='tmp'[, dir=None]]]]]])?
    This function operates exactly as TemporaryFile() does, except that data is spooled in memory until the
    file size exceeds max_size, or until the file?s fileno() method is called, at which point the contents
    are written to disk and operation proceeds as with TemporaryFile(). Also, it?s truncate method does not
    accept a size argument.

    The resulting file has one additional method, rollover(), which causes the file to roll over to an
    on-disk file regardless of its size.

    The returned object is a file-like object whose _file attribute is either a StringIO object or a true
    file object, depending on whether rollover() has been called. This file-like object can be used in a with
    statement, just like a normal file.
    New in version 2.6.

tempfile.mkstemp([suffix=''[, prefix='tmp'[, dir=None[, text=False]]]])?
    Creates a temporary file in the most secure manner possible. There are no race conditions in the file?s
    creation, assuming that the platform properly implements the os.O_EXCL flag for os.open(). The file is
    readable and writable only by the creating user ID. If the platform uses permission bits to indicate
    whether a file is executable, the file is executable by no one. The file descriptor is not inherited by
    child processes.

    Unlike TemporaryFile(), the user of mkstemp() is responsible for deleting the temporary file when done
    with it.

    If suffix is specified, the file name will end with that suffix, otherwise there will be no suffix.
    mkstemp() does not put a dot between the file name and the suffix; if you need one, put it at the
    beginning of suffix.

    If prefix is specified, the file name will begin with that prefix; otherwise, a default prefix is used.

    If dir is specified, the file will be created in that directory; otherwise, a default directory is used.
    The default directory is chosen from a platform-dependent list, but the user of the application can
    control the directory location by setting the TMPDIR, TEMP or TMP environment variables. There is thus no
    guarantee that the generated filename will have any nice properties, such as not requiring quoting when
    passed to external commands via os.popen().

    If text is specified, it indicates whether to open the file in binary mode (the default) or text mode. On
    some platforms, this makes no difference.

    mkstemp() returns a tuple containing an OS-level handle to an open file (as would be returned by os.open
    ()) and the absolute pathname of that file, in that order.
    New in version 2.3.

tempfile.mkdtemp([suffix=''[, prefix='tmp'[, dir=None]]])?
    Creates a temporary directory in the most secure manner possible. There are no race conditions in the
    directory?s creation. The directory is readable, writable, and searchable only by the creating user ID.

    The user of mkdtemp() is responsible for deleting the temporary directory and its contents when done with
    it.

    The prefix, suffix, and dir arguments are the same as for mkstemp().

    mkdtemp() returns the absolute pathname of the new directory.
    New in version 2.3.

tempfile.mktemp([suffix=''[, prefix='tmp'[, dir=None]]])?
    Deprecated since version 2.3: Use mkstemp() instead.

    Return an absolute pathname of a file that did not exist at the time the call is made. The prefix, suffix,
    and dir arguments are the same as for mkstemp().

    Warning
    Use of this function may introduce a security hole in your program. By the time you get around to doing
    anything with the file name it returns, someone else may have beaten you to the punch. mktemp() usage can
    be replaced easily with NamedTemporaryFile(), passing it the delete=False parameter:

    >>> f = NamedTemporaryFile(delete=False)
    >>> f
    <open file '<fdopen>', mode 'w+b' at 0x384698>
    >>> f.name
    '/var/folders/5q/5qTPn6xq2RaWqk+1Ytw3-U+++TI/-Tmp-/tmpG7V1Y0'
    >>> f.write("Hello World!\n")
    >>> f.close()
    >>> os.unlink(f.name)
    >>> os.path.exists(f.name)
    False

The module uses a global variable that tell it how to construct a temporary name. They are initialized at the
first call to any of the functions above. The caller may change them, but this is discouraged; use the
appropriate function arguments, instead.

tempfile.tempdir?
    When set to a value other than None, this variable defines the default value for the dir argument to all
    the functions defined in this module.

    If tempdir is unset or None at any call to any of the above functions, Python searches a standard list of
    directories and sets tempdir to the first one which the calling user can create files in. The list is:

     1. The directory named by the TMPDIR environment variable.
     2. The directory named by the TEMP environment variable.
     3. The directory named by the TMP environment variable.
     4. A platform-specific location:
          o On RiscOS, the directory named by the Wimp$ScrapDir environment variable.
          o On Windows, the directories C:\TEMP, C:\TMP, \TEMP, and \TMP, in that order.
          o On all other platforms, the directories /tmp, /var/tmp, and /usr/tmp, in that order.
     5. As a last resort, the current working directory.

tempfile.gettempdir()?
    Return the directory currently selected to create temporary files in. If tempdir is not None, this simply
    returns its contents; otherwise, the search described above is performed, and the result returned.
    New in version 2.3.

tempfile.template?
    Deprecated since version 2.0: Use gettempprefix() instead.

    When set to a value other than None, this variable defines the prefix of the final component of the
    filenames returned by mktemp(). A string of six random letters and digits is appended to the prefix to
    make the filename unique. The default prefix is tmp.

    Older versions of this module used to require that template be set to None after a call to os.fork();
    this has not been necessary since version 1.5.2.

tempfile.gettempprefix()?
    Return the filename prefix used to create temporary files. This does not contain the directory component.
    Using this function is preferred over reading the template variable directly.
    New in version 1.5.2.

    

---
https://docs.python.org/2/library/fnmatch.html

10.8. fnmatch ? Unix filename pattern matching?

Source code: Lib/fnmatch.py
-------------------------------------------------------------------------------------------------------------
This module provides support for Unix shell-style wildcards, which are not the same as regular expressions
(which are documented in the re module). The special characters used in shell-style wildcards are:

+-----------------------------------------+
|Pattern|             Meaning             |
|-------+---------------------------------|
|*      |matches everything               |
|-------+---------------------------------|
|?      |matches any single character     |
|-------+---------------------------------|
|[seq]  |matches any character in seq     |
|-------+---------------------------------|
|[!seq] |matches any character not in seq |
+-----------------------------------------+

For a literal match, wrap the meta-characters in brackets. For example, '[?]' matches the character '?'.

Note that the filename separator ('/' on Unix) is not special to this module. See module glob for pathname
expansion (glob uses fnmatch() to match pathname segments). Similarly, filenames starting with a period are
not special for this module, and are matched by the * and ? patterns.

fnmatch.fnmatch(filename, pattern)?
    Test whether the filename string matches the pattern string, returning True or False. If the operating
    system is case-insensitive, then both parameters will be normalized to all lower- or upper-case before
    the comparison is performed. fnmatchcase() can be used to perform a case-sensitive comparison, regardless
    of whether that?s standard for the operating system.

    This example will print all file names in the current directory with the extension .txt:

    import fnmatch
    import os

    for file in os.listdir('.'):
        if fnmatch.fnmatch(file, '*.txt'):
            print file

fnmatch.fnmatchcase(filename, pattern)?
    Test whether filename matches pattern, returning True or False; the comparison is case-sensitive.

fnmatch.filter(names, pattern)?
    Return the subset of the list of names that match pattern. It is the same as [n for n in names if fnmatch
    (n, pattern)], but implemented more efficiently.
    New in version 2.2.

fnmatch.translate(pattern)?
    Return the shell-style pattern converted to a regular expression.

    Example:

    >>> import fnmatch, re
    >>>
    >>> regex = fnmatch.translate('*.txt')
    >>> regex
    '.*\\.txt\\Z(?ms)'
    >>> reobj = re.compile(regex)
    >>> reobj.match('foobar.txt')
    <_sre.SRE_Match object at 0x...>



---
https://docs.python.org/2/library/shutil.html

10.10. shutil ? High-level file operations?

Source code: Lib/shutil.py
-------------------------------------------------------------------------------------------------------------
The shutil module offers a number of high-level operations on files and collections of files. In particular,
functions are provided which support file copying and removal. For operations on individual files, see also
the os module.

Warning
Even the higher-level file copying functions (shutil.copy(), shutil.copy2()) can?t copy all file metadata.

On POSIX platforms, this means that file owner and group are lost as well as ACLs. On Mac OS, the resource
fork and other metadata are not used. This means that resources will be lost and file type and creator codes
will not be correct. On Windows, file owners, ACLs and alternate data streams are not copied.

10.10.1. Directory and files operations?

shutil.copyfileobj(fsrc, fdst[, length])?
    Copy the contents of the file-like object fsrc to the file-like object fdst. The integer length, if
    given, is the buffer size. In particular, a negative length value means to copy the data without looping
    over the source data in chunks; by default the data is read in chunks to avoid uncontrolled memory
    consumption. Note that if the current file position of the fsrc object is not 0, only the contents from
    the current file position to the end of the file will be copied.

shutil.copyfile(src, dst)?
    Copy the contents (no metadata) of the file named src to a file named dst. dst must be the complete
    target file name; look at shutil.copy() for a copy that accepts a target directory path. If src and dst
    are the same files, Error is raised. The destination location must be writable; otherwise, an IOError
    exception will be raised. If dst already exists, it will be replaced. Special files such as character or
    block devices and pipes cannot be copied with this function. src and dst are path names given as strings.

shutil.copymode(src, dst)?
    Copy the permission bits from src to dst. The file contents, owner, and group are unaffected. src and dst
    are path names given as strings.

shutil.copystat(src, dst)?
    Copy the permission bits, last access time, last modification time, and flags from src to dst. The file
    contents, owner, and group are unaffected. src and dst are path names given as strings.

shutil.copy(src, dst)?
    Copy the file src to the file or directory dst. If dst is a directory, a file with the same basename as
    src is created (or overwritten) in the directory specified. Permission bits are copied. src and dst are
    path names given as strings.

shutil.copy2(src, dst)?
    Similar to shutil.copy(), but metadata is copied as well ? in fact, this is just shutil.copy() followed
    by copystat(). This is similar to the Unix command cp -p.

shutil.ignore_patterns(*patterns)?
    This factory function creates a function that can be used as a callable for copytree()?s ignore argument,
    ignoring files and directories that match one of the glob-style patterns provided. See the example below.
    New in version 2.6.

shutil.copytree(src, dst, symlinks=False, ignore=None)?
    Recursively copy an entire directory tree rooted at src. The destination directory, named by dst, must
    not already exist; it will be created as well as missing parent directories. Permissions and times of
    directories are copied with copystat(), individual files are copied using shutil.copy2().

    If symlinks is true, symbolic links in the source tree are represented as symbolic links in the new tree,
    but the metadata of the original links is NOT copied; if false or omitted, the contents and metadata of
    the linked files are copied to the new tree.

    If ignore is given, it must be a callable that will receive as its arguments the directory being visited
    by copytree(), and a list of its contents, as returned by os.listdir(). Since copytree() is called
    recursively, the ignore callable will be called once for each directory that is copied. The callable must
    return a sequence of directory and file names relative to the current directory (i.e. a subset of the
    items in its second argument); these names will then be ignored in the copy process. ignore_patterns()
    can be used to create such a callable that ignores names based on glob-style patterns.

    If exception(s) occur, an Error is raised with a list of reasons.
    The source code for this should be considered an example rather than the ultimate tool.
    Changed in version 2.3: Error is raised if any exceptions occur during copying, rather than printing a
    message.
    Changed in version 2.5: Create intermediate directories needed to create dst, rather than raising an
    error. Copy permissions and times of directories using copystat().
    Changed in version 2.6: Added the ignore argument to be able to influence what is being copied.

shutil.rmtree(path[, ignore_errors[, onerror]])?
    Delete an entire directory tree; path must point to a directory (but not a symbolic link to a directory).
    If ignore_errors is true, errors resulting from failed removals will be ignored; if false or omitted,
    such errors are handled by calling a handler specified by onerror or, if that is omitted, they raise an
    exception.

    If onerror is provided, it must be a callable that accepts three parameters: function, path, and excinfo.
    The first parameter, function, is the function which raised the exception; it will be os.path.islink(),
    os.listdir(), os.remove() or os.rmdir(). The second parameter, path, will be the path name passed to
    function. The third parameter, excinfo, will be the exception information return by sys.exc_info().
    Exceptions raised by onerror will not be caught.
    Changed in version 2.6: Explicitly check for path being a symbolic link and raise OSError in that case.

shutil.move(src, dst)?
    Recursively move a file or directory (src) to another location (dst).

    If the destination is an existing directory, then src is moved inside that directory. If the destination
    already exists but is not a directory, it may be overwritten depending on os.rename() semantics.

    If the destination is on the current filesystem, then os.rename() is used. Otherwise, src is copied
    (using shutil.copy2()) to dst and then removed.
    New in version 2.3.

exception shutil.Error?
    This exception collects exceptions that are raised during a multi-file operation. For copytree(), the
    exception argument is a list of 3-tuples (srcname, dstname, exception).
    New in version 2.3.

10.10.1.1. copytree example?
This example is the implementation of the copytree() function, described above, with the docstring omitted.
It demonstrates many of the other functions provided by this module.

def copytree(src, dst, symlinks=False, ignore=None):
    names = os.listdir(src)
    if ignore is not None:
        ignored_names = ignore(src, names)
    else:
        ignored_names = set()

    os.makedirs(dst)
    errors = []
    for name in names:
        if name in ignored_names:
            continue
        srcname = os.path.join(src, name)
        dstname = os.path.join(dst, name)
        try:
            if symlinks and os.path.islink(srcname):
                linkto = os.readlink(srcname)
                os.symlink(linkto, dstname)
            elif os.path.isdir(srcname):
                copytree(srcname, dstname, symlinks, ignore)
            else:
                copy2(srcname, dstname)
            # XXX What about devices, sockets etc.?
        except (IOError, os.error) as why:
            errors.append((srcname, dstname, str(why)))
        # catch the Error from the recursive copytree so that we can
        # continue with other files
        except Error as err:
            errors.extend(err.args[0])
    try:
        copystat(src, dst)
    except WindowsError:
        # can't copy file access times on Windows
        pass
    except OSError as why:
        errors.extend((src, dst, str(why)))
    if errors:
        raise Error(errors)

Another example that uses the ignore_patterns() helper:
	from shutil import copytree, ignore_patterns
	copytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*'))

This will copy everything except .pyc files and files or directories whose name starts with tmp.

Another example that uses the ignore argument to add a logging call:
	from shutil import copytree
	import logging

	def _logpath(path, names):
	    logging.info('Working in %s' % path)
	    return []   # nothing will be ignored

	copytree(source, destination, ignore=_logpath)

10.10.2. Archiving operations?
High-level utilities to create and read compressed and archived files are also provided. They rely on the
zipfile and tarfile modules.

shutil.make_archive(base_name, format[, root_dir[, base_dir[, verbose[, dry_run[, owner[, \
	group[, logger]]]]]]])?

    Create an archive file (eg. zip or tar) and returns its name.

    base_name is the name of the file to create, including the path, minus any format-specific extension.
    format is the archive format: one of ?zip?, ?tar?, ?bztar? or ?gztar?.

    root_dir is a directory that will be the root directory of the archive; ie. we typically chdir into
    root_dir before creating the archive.

    base_dir is the directory where we start archiving from; ie. base_dir will be the common prefix of all
    files and directories in the archive.

    root_dir and base_dir both default to the current directory.

    owner and group are used when creating a tar archive. By default, uses the current owner and group.

    logger must be an object compatible with PEP 282, usually an instance of logging.Logger.
    New in version 2.7.

shutil.get_archive_formats()?
    Return a list of supported formats for archiving. Each element of the returned sequence is a tuple (name,
    description).

    By default shutil provides these formats:
      + gztar: gzip?ed tar-file
      + bztar: bzip2?ed tar-file
      + tar: uncompressed tar file
      + zip: ZIP file

    You can register new formats or provide your own archiver for any existing formats, by using
    register_archive_format().
    New in version 2.7.

shutil.register_archive_format(name, function[, extra_args[, description]])?
    Register an archiver for the format name. function is a callable that will be used to invoke the
    archiver.

    If given, extra_args is a sequence of (name, value) that will be used as extra keywords arguments when
    the archiver callable is used.

    description is used by get_archive_formats() which returns the list of archivers. Defaults to an empty
    list.
    New in version 2.7.

shutil.unregister_archive_format(name)?
    Remove the archive format name from the list of supported formats.
    New in version 2.7.

10.10.2.1. Archiving example?
In this example, we create a gzip?ed tar-file archive containing all files found in the .ssh directory of the
user:
	>>> from shutil import make_archive
	>>> import os
	>>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))
	>>> root_dir = os.path.expanduser(os.path.join('~', '.ssh'))
	>>> make_archive(archive_name, 'gztar', root_dir)
	'/Users/tarek/myarchive.tar.gz'

The resulting archive contains:
	$ tar -tzvf /Users/tarek/myarchive.tar.gz
	drwx------ tarek/staff       0 2010-02-01 16:23:40 ./
	-rw-r--r-- tarek/staff     609 2008-06-09 13:26:54 ./authorized_keys
	-rwxr-xr-x tarek/staff      65 2008-06-09 13:26:54 ./config
	-rwx------ tarek/staff     668 2008-06-09 13:26:54 ./id_dsa
	-rwxr-xr-x tarek/staff     609 2008-06-09 13:26:54 ./id_dsa.pub
	-rw------- tarek/staff    1675 2008-06-09 13:26:54 ./id_rsa
	-rw-r--r-- tarek/staff     397 2008-06-09 13:26:54 ./id_rsa.pub
	-rw-r--r-- tarek/staff   37192 2010-02-06 18:23:10 ./known_hosts



---
https://docs.python.org/2/library/stdtypes.html#bltin-file-objects

5.9. File Objects?

File objects are implemented using C?s stdio package and can be created with the built-in open() function.
File objects are also returned by some other built-in functions and methods, such as os.popen() and
os.fdopen() and the makefile() method of socket objects. Temporary files can be created using the tempfile
module, and high-level file operations such as copying, moving, and deleting files and directories can be
achieved with the shutil module.

When a file operation fails for an I/O-related reason, the exception IOError is raised. This includes
situations where the operation is not defined for some reason, like seek() on a tty device or writing a file
opened for reading.

Files have the following methods:

file.close()?
    Close the file. A closed file cannot be read or written any more. Any operation which requires that the
    file be open will raise a ValueError after the file has been closed. Calling close() more than once is
    allowed.

    As of Python 2.5, you can avoid having to call this method explicitly if you use the with statement. For
    example, the following code will automatically close f when the with block is exited:
    from __future__ import with_statement # This isn't required in Python 2.6

    with open("hello.txt") as f:
        for line in f:
            print line,

    In older versions of Python, you would have needed to do this to get the same effect:
    f = open("hello.txt")
    try:
        for line in f:
            print line,
    finally:
        f.close()

    Note
    Not all ?file-like? types in Python support use as a context manager for the with statement. If your code
    is intended to work with any file-like object, you can use the function contextlib.closing() instead of
    using the object directly.

file.flush()?
    Flush the internal buffer, like stdio?s fflush(). This may be a no-op on some file-like objects.

    Note
    flush() does not necessarily write the file?s data to disk. Use flush() followed by os.fsync() to ensure
    this behavior.

file.fileno()?
    Return the integer ?file descriptor? that is used by the underlying implementation to request I/O
    operations from the operating system. This can be useful for other, lower level interfaces that use file
    descriptors, such as the fcntl module or os.read() and friends.

    Note
    File-like objects which do not have a real file descriptor should not provide this method!

file.isatty()?
    Return True if the file is connected to a tty(-like) device, else False.

    Note
    If a file-like object is not associated with a real file, this method should not be implemented.

file.next()?
    A file object is its own iterator, for example iter(f) returns f (unless f is closed). When a file is
    used as an iterator, typically in a for loop (for example, for line in f: print line.strip()), the next()
    method is called repeatedly. This method returns the next input line, or raises StopIteration when EOF is
    hit when the file is open for reading (behavior is undefined when the file is open for writing). In order
    to make a for loop the most efficient way of looping over the lines of a file (a very common operation),
    the next() method uses a hidden read-ahead buffer. As a consequence of using a read-ahead buffer,
    combining next() with other file methods (like readline()) does not work right. However, using seek() to
    reposition the file to an absolute position will flush the read-ahead buffer.
    New in version 2.3.

file.read([size])?
    Read at most size bytes from the file (less if the read hits EOF before obtaining size bytes). If the
    size argument is negative or omitted, read all data until EOF is reached. The bytes are returned as a
    string object. An empty string is returned when EOF is encountered immediately. (For certain files, like
    ttys, it makes sense to continue reading after an EOF is hit.) Note that this method may call the
    underlying C function fread() more than once in an effort to acquire as close to size bytes as possible.
    Also note that when in non-blocking mode, less data than was requested may be returned, even if no size
    parameter was given.

    Note
    This function is simply a wrapper for the underlying fread() C function, and will behave the same in
    corner cases, such as whether the EOF value is cached.

file.readline([size])?
    Read one entire line from the file. A trailing newline character is kept in the string (but may be absent
    when a file ends with an incomplete line). [6] If the size argument is present and non-negative, it is a
    maximum byte count (including the trailing newline) and an incomplete line may be returned. When size is
    not 0, an empty string is returned only when EOF is encountered immediately.

    Note
    Unlike stdio?s fgets(), the returned string contains null characters ('\0') if they occurred in the
    input.

file.readlines([sizehint])?
    Read until EOF using readline() and return a list containing the lines thus read. If the optional
    sizehint argument is present, instead of reading up to EOF, whole lines totalling approximately sizehint
    bytes (possibly after rounding up to an internal buffer size) are read. Objects implementing a file-like
    interface may choose to ignore sizehint if it cannot be implemented, or cannot be implemented
    efficiently.

file.xreadlines()?
    This method returns the same thing as iter(f).
    New in version 2.1.

    Deprecated since version 2.3: Use for line in file instead.

file.seek(offset[, whence])?
    Set the file?s current position, like stdio?s fseek(). The whence argument is optional and defaults to 
    os.SEEK_SET or 0 (absolute file positioning); other values are os.SEEK_CUR or 1 (seek relative to the
    current position) and os.SEEK_END or 2 (seek relative to the file?s end). There is no return value.

    For example, f.seek(2, os.SEEK_CUR) advances the position by two and f.seek(-3, os.SEEK_END) sets the
    position to the third to last.

    Note that if the file is opened for appending (mode 'a' or 'a+'), any seek() operations will be undone at
    the next write. If the file is only opened for writing in append mode (mode 'a'), this method is
    essentially a no-op, but it remains useful for files opened in append mode with reading enabled (mode 
    'a+'). If the file is opened in text mode (without 'b'), only offsets returned by tell() are legal. Use
    of other offsets causes undefined behavior.
    Note that not all file objects are seekable.
    Changed in version 2.6: Passing float values as offset has been deprecated.

file.tell()?
    Return the file?s current position, like stdio?s ftell().

    Note
    On Windows, tell() can return illegal values (after an fgets()) when reading files with Unix-style
    line-endings. Use binary mode ('rb') to circumvent this problem.

file.truncate([size])?

    Truncate the file?s size. If the optional size argument is present, the file is truncated to (at most)
    that size. The size defaults to the current position. The current file position is not changed. Note that
    if a specified size exceeds the file?s current size, the result is platform-dependent: possibilities
    include that the file may remain unchanged, increase to the specified size as if zero-filled, or increase
    to the specified size with undefined new content. Availability: Windows, many Unix variants.

file.write(str)?
    Write a string to the file. There is no return value. Due to buffering, the string may not actually show
    up in the file until the flush() or close() method is called.

file.writelines(sequence)?
    Write a sequence of strings to the file. The sequence can be any iterable object producing strings,
    typically a list of strings. There is no return value. (The name is intended to match readlines();
    writelines() does not add line separators.)

Files support the iterator protocol. Each iteration returns the same result as readline(), and iteration ends
when the readline() method returns an empty string.

File objects also offer a number of other interesting attributes. These are not required for file-like
objects, but should be implemented if they make sense for the particular object.

file.closed?
    bool indicating the current state of the file object. This is a read-only attribute; the close() method
    changes the value. It may not be available on all file-like objects.

file.encoding?
    The encoding that this file uses. When Unicode strings are written to a file, they will be converted to
    byte strings using this encoding. In addition, when the file is connected to a terminal, the attribute
    gives the encoding that the terminal is likely to use (that information might be incorrect if the user
    has misconfigured the terminal). The attribute is read-only and may not be present on all file-like
    objects. It may also be None, in which case the file uses the system default encoding for converting
    Unicode strings.
    New in version 2.3.

file.errors?
    The Unicode error handler used along with the encoding.
    New in version 2.6.

file.mode?
    The I/O mode for the file. If the file was created using the open() built-in function, this will be the
    value of the mode parameter. This is a read-only attribute and may not be present on all file-like
    objects.

file.name?
    If the file object was created using open(), the name of the file. Otherwise, some string that indicates
    the source of the file object, of the form <...>. This is a read-only attribute and may not be present on
    all file-like objects.

file.newlines?
    If Python was built with universal newlines enabled (the default) this read-only attribute exists, and
    for files opened in universal newline read mode it keeps track of the types of newlines encountered while
    reading the file. The values it can take are '\r', '\n', '\r\n', None (unknown, no newlines read yet) or
    a tuple containing all the newline types seen, to indicate that multiple newline conventions were
    encountered. For files not opened in universal newlines read mode the value of this attribute will be 
    None.

file.softspace?
    Boolean that indicates whether a space character needs to be printed before another value when using the
    print statement. Classes that are trying to simulate a file object should also have a writable softspace
    attribute, which should be initialized to zero. This will be automatic for most classes implemented in
    Python (care may be needed for objects that override attribute access); types implemented in C will have
    to provide a writable softspace attribute.

    Note
    This attribute is not used to control the print statement, but to allow the implementation of print to
    keep track of its internal state.

    
---
