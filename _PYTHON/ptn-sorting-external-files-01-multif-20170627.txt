filename: python_sorting-external-files-01-multif_20170627.txt
http://www.compciv.org/guides/python/fundamentals/sorting-collections-with-sorted/

Sorting Python collections with the sorted method

   Sorting a list of items is not as simple as it seems. But it is also far more important than it
   seems.

Summary
   In Excel, sorting data is as “easy” as clicking a column-header. But of course, it’s much more
   complicated in the programming-land to do sorting. We have to write our own functions to tell
   Python’s sorting functions exactly how each item in a collection should be ranked.

   It’s annoying at first, but the necessity of such explicitness becomes evident when working with
   data. Not everything in the world can be ranked in alphabetical order.

Why is sorting important and difficult
   In Python, as in most high-level programming languages, it's very easy to sort a list of simple
   objects such as numbers or text strings:
>>> sorted([3, 0, 2])
[0, 2, 3]
>>> sorted(['oranges', 'apples'])
['apples', 'oranges']

   It's when we want to sort a collection of objects that are not all the same that things get slightly
   more complicated:
>>> sorted(["apples", 42])
TypeError: unorderable types: int() < str()

   Or, if the objects are all the same type of thing, but there's no obvious way that they should be
   sorted. How should a list of lists be sorted? By length of list? By the alphabetical/numerical order
   of the things in each list?

   A real-life analogy would be trying to sort a list of movies. Sorting movie titles in alphabetical
   order is pretty straightforward. But how would we write a program that sorts a list of movies by
   quality? It's ultimately a problem as hard as defining what "quality" means – is it number of Oscar
   awards? The box office receipts? The average of critics' reviews scores? But the core concept is that
   when we want to sort by something more ephemeral or abstract than the alphabetical order of a name,
   we have to do a little more work.

   This guide focuses on the built-in sorted function. The Python documentation has a nice how-to
   tutorial that has even more ways and examples of how to do sorting.

The built-in sorted function

   Python has a built-in function named sorted which, given an iterable collection, such as a list,
   will return a new list of items, but in sorted order:
>>> mylist = [42, -5, 0]
>>> sorted(mylist)
[-5, 0, 42]

   Note: by "iterable collection", I mean that sorted can deal with sequences other than lists. Strings,
   for example, are iterable:
>>> sorted("Hello World!")
[' ', '!', 'H', 'W', 'd', 'e', 'l', 'l', 'l', 'o', 'o', 'r']

   …but, for the most part, we'll be dealing with lists.

Sorting alphabetically and numerically with sorted
   By default, sorted will return numbers and text strings in ascending order, i.e. from lowest to
   highest, and alphabetically.

   Of course, even that is more complicated than you might think. Since every digital object is
   ultimately just a bunch of ones and zeros, letters and numbers are actually sorted by their binary
   values, e.g. 1000001 (i.e. 65) for "A", and 1100001 (i.e. 97) for "a". Which should explain this
   result:
>>> sorted(["alpha", "Zed"])
['Zed', 'alpha']

   And when numbers are represented as strings, they are not sorted in numerical order, but by their
   binary/hexadecimal value, e.g. the character "1" has a value of 49:
>>> sorted(["hundred", "100"])
['100', 'hundred']

   Try to apply that factoid in explaining this seemingly contradictory result:
>>> sorted([9, 10])
[9, 10]
>>> sorted(["9", "10"])
['10', '9']

Sorting in reverse with sorted
   The sorted function takes a named argument, reverse, which is set to False by default. If we want
   things to be sorted in reverse-order (which would be descending order for character strings and
   numbers), pass True to the reverse argument:
>>> mylist = [42, -9, 0]
>>> sorted(mylist)
[-9, 0, 42]
>>> sorted(mylist, reverse=True)
[42, 0, -9]

Defining a key function
   Besides a reverse argument, the sorted function takes one other named argument: key.

   However, the key argument does not take a simple value, such as True. Instead, we have to pass in the
   name of a function, a function that defines how each object in the collection should be evaluated as
   for sorting purposes:
sorted(["a", 2, "z"], key=some_function_name)

   Which means that a function by that name has to actually be defined:
def some_function_name(item):
    return do_something(item)
# obviously, do_something is some other hypothetical function
# that also has to be defined
sorted(["a", 2, "z"], key=some_function_name)

How to sort apples and oranges and numbers
   Here's an actual example: how do we sort a list of text strings that have different kinds of
   capitalization?
mylist = ['apples', 'Oranges', 'bananas']

   Remember that while text strings are seemingly sorted in alphabetical order, uppercase characters
   take precedence:
>>> sorted(mylist)
['Oranges', 'apples', 'bananas']

   And maybe that's what we want. But in other situations, we might want the strings to be sorted
   alphabetically without regard to capitalization.

   One way to do this is to convert everything to either all-upper or all-lower case characters:
>>> my_big_list = ['APPLES', 'ORANGES', 'BANANAS']
>>> sorted(my_big_list)
['APPLES', 'BANANAS', 'ORANGES']

   Of course, doing that manual conversion has a lot of disadvantages, the primary one being that you
   have to manually convert each item in the list.

   What a key function allows us to do is delegate that work to the sorted function. Essentially, we
   tell the sorted function: hey, sort each item in this list not by the item's actual value, but by
   some transformation of its value.

   For the current scenario, the "transformation" of the value is simply: the uppercased version of the
   string. That function is fairly trivial to write:
def my_foo(item):
    return item.upper()

   And now we can pass my_foo into the sorted function. Here's all the code, all together:
def my_foo(item):
    return item.upper()

mylist = ['Oranges', 'apples', 'bananas']

sorted(mylist, key=my_foo)

   The result of that sort will be:
['apples', 'bananas', 'Oranges']

   Note how the resulting list contains the original values, but sorted according to the result of
   my_foo being called upon each item. The sorted function – and the key function that it calls – never
   alters the original list.

   How about sorting a list that contains numbers and strings?
['apples', 42, 'Oranges']

   Note that this kind of scenario is a bit unusual in that…well, what is the purpose of sorting a list
   that contains text strings and numbers? The answer: um…I don't know. Which is exactly what the Python
   interpreter is thinking when it throws you an error if you try to sort the list without a key
   function:
>>> mylist = ['apples', 42, 'Oranges']
>>> sorted(mylist)
TypeError: unorderable types: int() < str()

   It just doesn't know how to order a number compared to a string. So, let's give it a simple key
   function which simply transforms any given value into a string, using the str() constructor function:
def my_foofoo(item):
    return str(item)

   With my_foofoo (or whatever you want to call it), we can use it as the key function:
>>> mylist = ['apples', 42, 'Oranges']
>>> sorted(mylist, key=my_foofoo)
[42, 'Oranges', 'apples']

Sorting lists of lists
   Suppose we have a list of lists. Each sub-list contains two values: a name (as a str) and an age (an
   int):
list_o_peeps = [
  ['Lisa', 42],
  ['Bart', 9],
  ['Maggie', 2]
]

   If we want to sort by the second value of each list, we simply define a function that, given an item
   that is ostensibly a collection or sequence, attempts to return the second value:
def sort_foo(x):
    return x[1]

>>> sorted(list_o_peeps, key=sort_foo)
[['Maggie', 2], ['Bart', 9], ['Lisa', 42]]

Sorting lists of dictionaries

   Pretty much the same thing as sorting lists, except of course we have to change how we reference the
   values, i.e. using keys instead of numerical indexes:
dict_o_peeps = [
  {'name': 'Lisa', 'age': 42},
  {'name': 'Bart', 'age': 9},
  {'name': 'Maggie', 'age': 2}
]

def foo2(x):
    return x['age']

>>> sorted(dict_o_peeps, key=foo2)
[{'age': 2, 'name': 'Maggie'},
 {'age': 9, 'name': 'Bart'},
 {'age': 42, 'name': 'Lisa'}]

Example: sorting by length of a string
   Let's try a more complicated key function. Instead of simply pulling out a value via index, e.g. sort
   by name.

   Let's sort by length of the name value in descending order (i.e. reverse the standard sort):
def foo_len(item):
    name = item['name']
    return len(name)

peeps = [
  {'name': 'Lisa', 'age': 42},
  {'name': 'Homer', 'age': 70},
  {'name': 'Maggie', 'age': 2}
]

>>> sorted(peeps, key=foo_len, reverse=True)
[{'age': 2, 'name': 'Maggie'},
 {'age': 70, 'name': 'Homer'},
 {'age': 42, 'name': 'Lisa'}]

How to break a tie
   As the collections of things we want to sort get bigger and more complicated, so do the criteria we
   use to rank them. Given a collection of dictionaries that looks like this:
peeps = [
  {'name': 'Mary', 'age': 42},
  {'name': 'Mary', 'age': 9},
  {'name': 'John', 'age': 42},
  {'name': 'Mary', 'age': 2}
]

   If we want to sort by the name in each dictionary, how does sorted know what to do with all the
   identical "Mary"'s? It doesn't know, so it will return them in an arbitrary order.

   If we want it to sort by name, and then by age for when the name is the same, we define the key
   function to return a tuple of values:
def foo3(x):
    return (x['name'], x['age'])

>>> sorted(peeps, key=foo3)
[{'age': 42, 'name': 'John'},
 {'age': 2, 'name': 'Mary'},
 {'age': 9, 'name': 'Mary'},
 {'age': 42, 'name': 'Mary'}]

   Alternatively, if we wanted to sort by age, then by name:
def foo4(x):
    return (x['age'], x['name'])

>>> sorted(peeps, key=foo4)
[{'age': 2, 'name': 'Mary'},
 {'age': 9, 'name': 'Mary'},
 {'age': 42, 'name': 'John'},
 {'age': 42, 'name': 'Mary'}]

Variations and common patterns of key functions
   If you've understood everything up until now, e.g. what a list and dictionary are, what the sorted
   function does, and what a key function is – then you're good to go. This section reviews other ways
   of writing out the same concepts, with cleaner-looking code at the cost of having to learn more about
   Python's standard library.

Using operator.itemgetter to sort lists of lists
   Consider this previous example:
peeps = [
  ['Lisa', 42],
  ['Bart', 9],
  ['Maggie', 2]
]

def foo(x):
    return x[1]

sorted(peeps, key=foo)

   It's such a common pattern to sort dictionaries by a single key that we can pass the itemgetter
   method (from the operator module) as the key function, along with a number that refers to which value
   from each list that we want to sort by:
from operator import itemgetter
peeps = [
  ['Lisa', 42],
  ['Bart', 9],
  ['Maggie', 2]
]

sorted(peeps, key=itemgetter(1))
# [['Maggie', 2], ['Bart', 9], ['Lisa', 42]]

Using operator.itemgetter to sort lists of lists

   Consider this previous example:
peeps = [
  {'name': 'Lisa', 'age': 42},
  {'name': 'Bart', 'age': 9},
  {'name': 'Maggie', 'age': 2}
]

def foo(x):
    return x['age']

sorted(peeps, key=foo)

   It's such a common pattern to sort dictionaries by a single key that we can pass the itemgetter
   method (from the operator module) as the key function, along with a string that refers to the key in
   the dictionary that we want to sort by:
from operator import itemgetter
peeps = [
  {'name': 'Lisa', 'age': 42},
  {'name': 'Bart', 'age': 9},
  {'name': 'Maggie', 'age': 2}
]

sorted(peeps, key=itemgetter('age'))
# [{'age': 2, 'name': 'Maggie'},
#  {'age': 9, 'name': 'Bart'},
#  {'age': 42, 'name': 'Lisa'}]

sorted vs sort
   Note that the sorted is not an in-place function, i.e. it does not modify the list that's passed into
   it:
>>> mylist = [8, 3, 12]
>>> newlist = sorted(mylist)
>>> mylist
[8, 3, 12]
>>> newlist
[3, 8, 12]

   This is in contrast to the sort method that the list object has. It actually changes the calling
   list. And it returns a NoneType value:
>>> mylist = [8, 3, 12]
>>> returnvalue = mylist.sort()
>>> type(returnvalue)
NoneType
>>>  mylist
[3, 8, 12]

   For many intents and purposes, the fact that sort mutates a list may not matter…except it can be hard
   to infer from reading the code (as a human) to see that the mylist list has actually changed.

   For our purposes, it's just a lot easier to call the sorted method.

   Automate the Boring Stuff with Python has examples on using the list's sort method.

Example: Sorting earthquakes
   Let's try sorting some real-world data. The U.S. Geological Survey has real-time earthquake feeds
   in CSV form.

   I've downloaded a snapshot of M4.5+ earthquakes over a recent 7-day period:

   http://www.compciv.org/files/datadumps/apis/usgs/4.5_week.csv

   To preview the data in a spreadsheet-like form, you can view it on Github here.

Deserializing a CSV file into a list of dictionaries

   CSV is just text that, passed through the appropriate deserialization function, can be turned into a
   Python collection. For our purposes, we need the csv.DictReader function:
from csv import DictReader
import requests
DATA_URL = 'http://www.compciv.org/files/datadumps/apis/usgs/4.5_week.csv'
resp = requests.get(DATA_URL)
txt = resp.text
lines = txt.splitlines()
datarows = list(DictReader(lines))
# or obviously, do it all in one go
# datarows = list(DictReader(resp.text.splitlines()))

   datarows is a list of dictionaries. Inspect the first element in datarows, i.e. datarows[0]:
{'depth': '10.99',
 'depthError': '4.2',
 'dmin': '28.964',
 'gap': '120',
 'horizontalError': '12.8',
 'id': 'us20004zj3',
 'latitude': '-25.6731',
 'locationSource': 'us',
 'longitude': '-13.7383',
 'mag': '5.2',
 'magError': '0.064',
 'magNst': '81',
 'magSource': 'us',
 'magType': 'mb',
 'net': 'us',
 'nst': '',
 'place': 'Southern Mid-Atlantic Ridge',
 'rms': '1.01',
 'status': 'reviewed',
 'time': '2016-02-11T17:00:32.920Z',
 'type': 'earthquake',
 'updated': '2016-02-11T17:42:15.185Z'}

   It's a dictionary. But note how all the columns that contain numbers are actually denoted as strings.
   This is because, well, a CSV file is a text file…and, without further instruction, the Python
   csv.DictReader function is just going to treat everything as text strings. Note how this is much
   different than if you had imported the CSV file into Excel…in which case, Excel will try to guess
   what's in a column.

   Which is sometimes good. And sometimes catastrophic (which is why we're not using Excel).

Find top 5 earthquakes by biggest magnitude
   The USGS dataset has a mag column that specifies the magnitude of the earthquake as a float.

   To sort the dataset in descending order of magnitude, we need to write a function that extracts the
   value from an object's mag key. We also have to convert that value into a float object, because all
   values by default are just strings:
def foo(quake):
    return float(quake['mag'])

sortedquakes = sorted(datarows, key=foo, reverse=True)[0:5]

for q in sortedquakes:
    print(q['mag'], q['place'], q['time'])

# 6.4 92km WSW of Panguna, Papua New Guinea 2016-02-08T16:19:13.090Z
# 6.4 24km SSE of Yujing, Taiwan 2016-02-05T19:57:27.390Z
# 6.3 40km W of Ovalle, Chile 2016-02-10T00:33:05.690Z
# 5.8 89km NNE of Hihifo, Tonga 2016-02-07T02:03:40.400Z
# 5.5 276km WNW of Nadi, Fiji 2016-02-06T01:39:18.300Z

Sorting by distance from a point

   Let's say we have a geospatial point. Such as the location of Stanford, California, which is at the
   longitude/latitude coordinates of:
    longitude       latitude
   -122.1660756 37.42410599999999

   How do we find the earthquakes nearest to that point? We need whatever distance formula is
   appropriate for, given two points on a X/Y plane returns a value that represents the distance between
   those two points

   You can read about the haversine function here:

     The haversine formula is an equation important in navigation, giving great-circle distances
     between two points on a sphere from their longitudes and latitudes. It is a special case of a more
     general formula in spherical trigonometry, the law of haversines, relating the sides and angles of
     spherical triangles.

   And here's a Python implementation that I almost certainly copied from this StackOverflow answer,
   which I found by Googling for "haversine python":
def haversine(lon1, lat1, lon2, lat2):
    from math import radians, cos, sin, asin, sqrt
    lon1 = radians(lon1)
    lon2 = radians(lon2)
    lat1 = radians(lat1)
    lat2 = radians(lat2)
    # haversine formula
    dlon = lon2 - lon1
    dlat = lat2 - lat1
    a = sin(dlat /2 ) ** 2 + cos(lat1) * cos(lat2) * sin(dlon / 2) ** 2
    c = 2 * asin(sqrt(a))
    r = 6371 # Radius of earth in kilometers.
    # return the final calculation
    return c * r

   Here's one way to approach this problem: Use the haversine function, but write another function that
   calls haversine and provides the known coordinates (i.e. longitude/latitude of Stanford, CA):
STANFORD_LNG = -122.1660756
STANFORD_LAT = 37.42410599999999

def haver_foo(item):
    # remember that each record in the CSV
    # has to have its numerical columns converted to numbers:
    lng = float(item['longitude'])
    lat = float(item['latitude'])

    return haversine(STANFORD_LNG, STANFORD_LAT, lng, lat)


nearest_quakes = sorted(datarows, key=haver_foo)[0:5]
for quake in nearest_quakes:
    print(quake['mag'], quake['place'])
# 4.6 13km SSW of Teziutlan, Mexico
# 4.9 18km N of Chicomuselo, Mexico
# 4.6 33km WSW of La Libertad, El Salvador
# 5 77km SSW of Masachapa, Nicaragua
# 5.3 72km S of Semisopochnoi Island, Alaska



---
https://stackoverflow.com/questions/72899/how-do-i-sort-a-list-of-dictionaries-by-values-of-the-dictionary-in-python

How do I sort a list of dictionaries by values of the dictionary in Python?

   I got a list of dictionaries and want that to be sorted by a value of that dictionary.

   This
[{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]

   sorted by name, should become
[{'name':'Bart', 'age':10}, {'name':'Homer', 'age':39}]

***
   It may look cleaner using a key instead a cmp:
newlist = sorted(list_to_be_sorted, key=lambda k: k['name'])

   or as J.F.Sebastian and others suggested,
from operator import itemgetter
newlist = sorted(list_to_be_sorted, key=itemgetter('name'))

   For completeness (as pointed out in comments by fitzgeraldsteele), add reverse=True to sort
   descending
newlist = sorted(l, key=itemgetter('name'), reverse=True)

***
   Using key is not only cleaner but more effecient too. – J.F. Sebastian Sep 16 '08 at 15:03

***
   lambda k: k['name'] could be replaced by operator.itemgetter('name'). – J.F. Sebastian Sep 16 '08
   at 15:05

***
   What would you change to make it sort descending? – NealWalters Oct 13 '09 at 4:14

***
   To sort descending: newlist = sorted(l, key=itemgetter('name'), reverse=True) – fitzgeraldsteele

***
   itemgetter accepts more than one argument: itemgetter(1,2,3) is a function that return a tuple like
   obj[1], obj[2], obj[3], so you can use it to do complex sorts. – Bakuriu Sep 7 '12 at 17:59

***
import operator

   To sort the list of dictionaries by key='name':
list_of_dicts.sort(key=operator.itemgetter('name'))

   To sort the list of dictionaries by key='age':
list_of_dicts.sort(key=operator.itemgetter('age'))

***
   Anyway to combine name and age ? (like in SQL ORDER BY name,age ?) – monojohnny Feb 17 '10 at

***
   what is the advantage of itemgetter over lambda ? – njzk2 May 29 '13 at 13:29

***
   @monojohnny: yes, just have the key return a tuple, key=lambda k: (k['name'], k['age']). (or
   key=itemgetter('name', 'age')). tuple's cmp will compare each element in turn. it's bloody brilliant.

***
   In the documentation (docs.python.org/2/tutorial/datastructures.html) the optional key argument
   for list.sort() is not described. Any idea where to find that? – TTT Feb 21 '14 at 15:21

***
   @TTT: See the library documentation for list and friends. – Kevin Feb 19 '15 at 14:56

***
   If you want to sort the list by multiple keys you can do the following:
my_list = [{'name':'Homer', 'age':39}, {'name':'Milhouse', 'age':10}, {'name':'Bart', 'age':10} ]
sortedlist = sorted(my_list , key=lambda elem: "%02d %s" % (elem['age'], elem['name']))

   It is rather hackish, since it relies on converting the values into a single string representation
   for comparison, but it works as expected for numbers including negative ones (although you will need
   to format your string appropriately with zero paddings if you are using numbers)

***
   sorted using timsort which is stable, you can call sorted several times to have a sort on several
   criteria – njzk2 May 29 '13 at 13:41

   njzk2's comment wasn't immediately clear to me so I found the following. You can just sort twice as
   njzk2 suggests, or pass multiple arguments to operator.itemgetter in the top answer. Link:
   stackoverflow.com/questions/5212870/… – Permafacture Aug 23 '13 at 21:05

***
   No need to convert to string. Just return a tuple as the key. – Winston Ewert Dec 15 '13 at 4:55

   Sorting multiple times is the easiest generic solution without hacks:
   stackoverflow.com/a/29849371/1805397 – wouter bolsterlee Apr 24 '15 at 13:59

***
my_list = [{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]

my_list.sort(lambda x,y : cmp(x['name'], y['name']))

   my_list will now be what you want.

   (3 years later) Edited to add:

   The new key argument is more efficient and neater. A better answer now looks like:
my_list = sorted(my_list, key=lambda k: k['name'])

   ...the lambda is, IMO, easier to understand than operator.itemgetter, but YMMV.

***
import operator
a_list_of_dicts.sort(key=operator.itemgetter('name'))

   'key' is used to sort by an arbitrary value and 'itemgetter' sets that value to each item's 'name'
   attribute.

***
   You have to implement your own comparison function that will compare the dictionaries by values of
   name keys. See Sorting Mini-HOW TO from PythonInfo Wiki

***
   I guess you've meant:
[{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]

   This would be sorted like this:
sorted(l,cmp=lambda x,y: cmp(x['name'],y['name']))

***
   You could use a custom comparison function, or you could pass in a function that calculates a custom
   sort key. That's usually more efficient as the key is only calculated once per item, while the
   comparison function would be called many more times.

   You could do it this way:
def mykey(adict): return adict['name']
x = [{'name': 'Homer', 'age': 39}, {'name': 'Bart', 'age':10}]
sorted(x, key=mykey)

   But the standard library contains a generic routine for getting items of arbitrary objects:
   itemgetter. So try this instead:
from operator import itemgetter
x = [{'name': 'Homer', 'age': 39}, {'name': 'Bart', 'age':10}]
sorted(x, key=itemgetter('name'))

***
   Using Schwartzian transform from Perl,
py = [{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]

   do
sort_on = "name"
decorated = [(dict_[sort_on], dict_) for dict_ in py]
decorated.sort()
result = [dict_ for (key, dict_) in decorated]

   gives
>>> result
[{'age': 10, 'name': 'Bart'}, {'age': 39, 'name': 'Homer'}]

   More on Perl Schwartzian transform

     In computer science, the Schwartzian transform is a Perl programming idiom used to improve the
     efficiency of sorting a list of items. This idiom is appropriate for comparison-based sorting when
     the ordering is actually based on the ordering of a certain property (the key) of the elements,
     where computing that property is an intensive operation that should be performed a minimal number
     of times. The Schwartzian Transform is notable in that it does not use named temporary arrays.

***
   Python has supported the key= for .sort since 2.4, that is year 2004, it does the Schwartzian
   transform within the sorting code, in C; thus this method is useful only on Pythons 2.0-2.3. all of
   which are more than 12 years old. – Antti Haapala Feb 15 '15 at 20:11

***
   I tried something like this:
my_list.sort(key=lambda x: x['name'])

   It worked for integers as well.

***
   Here is the alternative general solution - it sorts elements of dict by keys and values. The
   advantage of it - no need to specify keys, and it would still work if some keys are missing in some
   of dictionaries.
def sort_key_func(item):
    """ helper function used to sort list of dicts

    :param item: dict
    :return: sorted list of tuples (k, v)
    """
    pairs = []
    for k, v in item.items():
        pairs.append((k, v))
    return sorted(pairs)
sorted(A, key=sort_key_func)

***
   Lets Say I h'v a Dictionary D with elements below. To sort just use key argument in sorted to pass
   custom function as below
D = {'eggs': 3, 'ham': 1, 'spam': 2}

def get_count(tuple):
    return tuple[1]

sorted(D.items(), key = get_count, reverse=True)
or
sorted(D.items(), key = lambda x: x[1], reverse=True)  avoiding get_count function call

***
   Using the pandas package is another method, though it's runtime at large scale is much slower than
   the more traditional methods proposed by others:
import pandas as pd

listOfDicts = [{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]
df = pd.DataFrame(listOfDicts)
df = df.sort_values('name')
sorted_listOfDicts = df.T.to_dict().values()

   Here are some benchmark values for a tiny list and a large (100k+) list of dicts:
setup_large = "listOfDicts = [];\
[listOfDicts.extend(({'name':'Homer', 'age':39}, {'name':'Bart', 'age':10})) for _ in range(50000)];\
from operator import itemgetter;import pandas as pd;\
df = pd.DataFrame(listOfDicts);"

setup_small = "listOfDicts = [];\
listOfDicts.extend(({'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}));\
from operator import itemgetter;import pandas as pd;\
df = pd.DataFrame(listOfDicts);"

method1 = "newlist = sorted(listOfDicts, key=lambda k: k['name'])"
method2 = "newlist = sorted(listOfDicts, key=itemgetter('name')) "
method3 = "df = df.sort_values('name');\
sorted_listOfDicts = df.T.to_dict().values()"

import timeit
t = timeit.Timer(method1, setup_small)
print('Small Method LC: ' + str(t.timeit(100)))
t = timeit.Timer(method2, setup_small)
print('Small Method LC2: ' + str(t.timeit(100)))
t = timeit.Timer(method3, setup_small)
print('Small Method Pandas: ' + str(t.timeit(100)))

t = timeit.Timer(method1, setup_large)
print('Large Method LC: ' + str(t.timeit(100)))
t = timeit.Timer(method2, setup_large)
print('Large Method LC2: ' + str(t.timeit(100)))
t = timeit.Timer(method3, setup_large)
print('Large Method Pandas: ' + str(t.timeit(1)))

#Small Method LC: 0.000163078308105
#Small Method LC2: 0.000134944915771
#Small Method Pandas: 0.0712950229645
#Large Method LC: 0.0321750640869
#Large Method LC2: 0.0206089019775
#Large Method Pandas: 5.81405615807

***
   I ran your code and found a mistake in the the timeit.Timer args for Large Method Pandas: you specify
   "setup_small" where it should be "setup_large". Changing that arg caused the program to run without
   finishing, and I stopped it after more than 5 minutes. When I ran it with "timeit(1)", the Large
   Method Pandas finished in 7.3 sec, much worse than LC or LC2. – clp2 Nov 7 '16 at 4:05

***
   You're quite right, that was quite an oversight on my part. I no longer recommend it for large cases!
   I have edited the answer to simply allow it as a possibility, the use case is still up for debate.

***
   Here is my answer to a related question on sorting by multiple columns. It also works for the
   degenerate case where the number of columns is only one.

***
a = [{'name':'Homer', 'age':39}, ...]

# This changes the list a
a.sort(key=lambda k : k['name'])

# This returns a new list (a is not modified)
sorted(a, key=lambda k : k['name'])


---
https://stackoverflow.com/questions/30817007/python-how-do-i-sort-data-in-a-text-file

Python: How do i sort data in a text file?

   i am trying to write inside a .txt file and then sort in alphabetical order the names inside, then
   print. How would i do this? If it can't be done is there any alternative?
print("Well done " + name + "! your total score is: {}/10 :)\n".format(score))
#os.system("color 0a")
time.sleep(3)
file = open(str(age) + ".txt" , "a") # Creates a file.txt if it hasn't already been created and ammends it 'a'
file.write(name + " " + str(age) + " {}\n".format(score)) # Writes into the file, .format(x) replaces {} with
                                                          # the variable x
file.close
f = open(str(age) + ".txt" , "r")
lines = f.readlines()
f.close()
lines.sort()
f = open(str(age) + ".txt" , "w")
for line in lines:
    f.write(line)
print(lines)
f.flush()
f.close()

***
   Why are you sleeping? Use list.sort() or sorted(iterable) – James Mills Jun 13 '15 at 9:20

***
   please tell us what the file looks like? – Anand S Kumar Jun 13 '15 at 9:24

***
   Could you show me in code form, cause this is for lists i think – flyingpython Jun 13 '15 at 9:26

***
   @JamesMills Where is the list? or Iterable – Bharadwaj Jun 13 '15 at 9:26

***
   The file is text file(.txt) when it writes in the file it starts a new line, and so on.
   – flyingpython Jun 13 '15 at 9:27

***
   i am guessing the input looks like -
a 10 1
b 10 2
c 10 8
d 10 5

   Making sure that each name is on a separate line, which does not seem to be the case with your code,
   since file.write() does not automatically append a \n to the end, you have to manually do it -
file.write(name + " " + str(age) + " {}\n".format(score))

   Then you can do -
f = open(str(age) + ".txt" , "r")
lines = f.readlines()
f.close()
lines.sort()
f = open(str(age) + ".txt" , "w")
for line in lines:
    f.write(line)
f.flush()
f.close()

***
   <_io.TextIOWrapper name='3.txt' mode='w' encoding='cp1252'> >>> – flyingpython Jun 13 '15 at 9:32

***
   I got that when i put: print(f) – flyingpython Jun 13 '15 at 9:33

***
   yes, correct, maybe you want to do print(lines) in above code, or if you only have f , then
   print(f.readlines()) . Do not print the file object itself , that would not give you any meaningful
   information. – Anand S Kumar Jun 13 '15 at 9:34

***
   I done print(lines) and it works :D – flyingpython Jun 13 '15 at 9:37

***
   Where are you doing this? What line ? Can you show the complete code you are using? Regarding the
   IOUnsupportedError , you must have tried doing f.readlines() after you openned f with mode as "w" ,
   you cannot do that. – Anand S Kumar Jun 13 '15 at 9:39

***
import random, time, operator, os # Import modules required for specific tasks

def quiz():
    score = 0
    for q in range (1,11): # 'for' loop: Repeats the lines between 0 to 11 times- 10 times
        ops = {'+':operator.add,
               '-':operator.sub,
               '*':operator.mul}
        op = random.choice(list(ops.keys()))
        if op != '*': # != means 'not equal'
            r1 = random.randint (-1, 100) # Randomises a number from -1 to 100
            r2 = random.randint (-1, 100)
            answer = ops.get(op)(r1,r2)
        else:
            r1 = random.randint(-1,12)
            r2 = random.randint(-1,12)
            answer = ops.get(op)(r1,r2)
        if equ == answer :
            score += 1
            print("Correct, Well done, your score is: " + str(score))
        elif end - start >= 20:
            print("You took too long to answer.")
        else:
            print("Incorrect, Sorry. Your score is: " + str(score))

    print("Well done " + name + "! your total score is: {}/10 :)\n".format(score))
    time.sleep(3)
    file = open(str(age) + ".txt" , "a") # Creates a file.txt if it hasn't already been created and ammends it
 'a'
    file.write(name + " " + str(age) + " {}".format(score)) # Writes into the file, .format(x) replaces {} wit
h the variable x
    file.close
    f = open(str(age) + ".txt" , "r")
    lines = f.readlines()
    f.close()
    lines.sort()
    f = open(str(age) + ".txt" , "w")
    for line in lines:
        f.write(line)
    print(lines)
    f.flush()
    f.close()

start = "" # Defines a variable
while start not in ('Y', 'y', 'yes', 'Yes') : # Repeats the lines beneath until the condition is met i.e.: inp
ut = 'y'
    name = input("Welcome to the Maths Quiz! Please enter your name: \n").upper()
    age = input("Enter your class number: 1, 2 or 3 \n")
    while age not in ('1', '2', '3') :
        age = input("Enter your class number: 1, 2 or 3 \n")
    start = input("You are " + name + " in class: " + str(age) + "\nIs this right? Enter y=Yes or n=No \n" )
time.sleep(2)
print("Get ready! The Quiz will now begin!") # Displays on the screen
time.sleep(2)
quiz() # Runs the function quiz


---
https://stackoverflow.com/questions/13577194/python-sorting-text-file-from-highest-to-lowest-based-on-column-values

Python Sorting Text File From Highest To Lowest Based On Column Values

   I have a very large text file that contains lines of data like:
('#DownWithAssad', '1')
('#DownYoTLParty', '1')
('#Download', '8')
('#Download:', '2')
('#Downloads', '2')
('#DownstairsMixtape', '1')
('#DowntonAbbey', '12')
('#DowntonAbbey?', '1')
('#DowntonPBS', '23')
('#Downtonabbey', '1')
('#DowntownAbbey', '1')

   This may seem like a simple problem but I want to soft the data from highest to lowest so it looks
   like:
('#DowntonPBS', '23')
('#DowntonAbbey', '12')
('#Download', '8')
('#Download:', '2')
('#Downloads', '2')
('#DownstairsMixtape', '1')
('#DownWithAssad', '1')
('#DownYoTLParty', '1')
('#DowntonAbbey?', '1')
('#Downtonabbey', '1')
('#DowntownAbbey', '1')

   I gather that I can eliminate the brackets () and split the data with:
import sys

f = open(sys.argv[1])
for line in f:
    line = str(line)[1 : -1]
    for sect in line.split(','):
        print sect

   However I'm not sure where to go from here.

***
   You can parse your text file quite easily using ast.literal_eval:
with open(datafile) as f:
    file_sorted = sorted((ast.literal_eval(x) for x in f),
                         key=lambda z:(int(z[1]),z[0]),
                         reverse=True)

   How it works:
(ast.literal_eval(x) for x in f)  #turn each line in your file into a tuple
key=lambda z:(int(z[1]),z[0])     #function to determine how things are sorted.  Basically
                                  #sort as tuples:  `( int(z[1]),z[0] )`
reverse=True                      #descending order instead of ascending

***
   can you explain how this works? – secumind Nov 27 '12 at 4:09

***
   Thank you very much, and thanks for the explanation, I was unclear as to what the key=lambda did but
   I get it now. – secumind Nov 27 '12 at 4:21

***
   This is along the lines of what you are trying to do. Note that parsing the lines this way is quite
   fragile (misformatted lines may break it)
from operator import itemgetter
import sys

result=[]
with open(sys.argv[1]) as f:
    for line in f:
        line = str(line.strip())[1: -1]
        sect1, sect2 = line.split(', ')
        sect1 = sect1[1: -1]
        sect2 = int(sect2[1: -1])
        result.append((sect1, sect2))

for line in sorted(result, key=itemgetter(1), reverse=True):
    print line

   Better ways to parse it would be to use literal_eval or regular expressions. Do you know if there is
   any special treatment when quote characters or commas appear in the strings?


---
https://stackoverflow.com/questions/13528800/python-sort-file-by-arbitrary-column-where-column-contains-time-values

Python : Sort file by arbitrary column, where column contains time values

   I have a .txt file for a person, and next to each person they have two times. This is the .txt file
 Xantippe 09:00 11:00
 Erica 10:00 12:06
 Marcia 09:30 11:45
 Elizabeth 10:15 12:10
 Angela 11:30 13:45
 Freda 12:00 14:20
 Maria 12:30 14:10

   I am required to read the file, then get each line, read it, and sort the whole list by the second
   time. Remember in the file the numbers are string objects. So basically the time that is the earliest
   i.e. 11:00 Should be at the top of the list along with their previous time and name. eg. Xantippe
   09:00 11:00 and then on another line the next one etc.

   So far I have done:
from Practise1 import timeCalc
with open('LadiesRace.txt', 'r') as f:
  readf = f.read();
  timeX = timeCalc()
  lis = readf.split('\n')
  with open('sortByFinishTime.txt','w') as w:
    def compare(x,y):
      if x[1] > y[1]:
        return 1
      if x[1] < y[1]:
        return -1
      return 0
    #lis.sort()
    for l in lis:
      #line = l.strip()
      slist = l.split(' ')
      print slist[2]

   The problem is that I cannot use a dictionary, only a list. I have managed to sort the list by name
   in ascending order, but how do I sort with the last time?

***
   Is this actually your code? If you have written this, surely you should already know the answer.

***
   This is actually my code. I was working with dictionaries before, and with lists now, but im finding
   it difficult to get this solution – Muhammed Bhikha Nov 23 '12 at 12:18

***
   You've already managed to sort for column index 1 pretty nicely - why not change that to 2? Or am I
   completely misunderstanding the question? – Deestan Nov 23 '12 at 12:19

***
   Is this homework? – vladr Nov 23 '12 at 16:57

***
   lol im a 23 year old man, im just new to all this thats all – Muhammed Bhikha Nov 24 '12 at 0:30

***
   Firstly, you need to get your data into a usable format... So let's load it into a list in memory -
   it's important to note that dicts do not inherently have order, so we want to use a list.
with open('myfile.txt') as fin:
    lines = [line.split() for line in fin]

   This will remove any trailing newlines and break it up by the space character... so we end up with:
[['Xantippe', '09:00', '11:00'], ['Erica', '10:00', '12:06'], ['Marcia', '09:30', '11:45'], ['Elizabeth', \
'10:15', '12:10'], ['Angela', '11:30', '13:45'], ['Freda', '12:00', '14:20'], ['Maria', '12:30', '14:10']]

   Then, we can use the .sort method of a list - itemgetter is a handy method for getting the nth
   element of a sequence, so we have name, start, end, where end is the 2nd index (based on zero being
   the first, which will be the name)
from operator import itemgetter
lines.sort(key=itemgetter(2))

   And we end up with:
[['Xantippe', '09:00', '11:00'], ['Marcia', '09:30', '11:45'], ['Erica', '10:00', '12:06'], ['Elizabeth', \
'10:15', '12:10'], ['Angela', '11:30', '13:45'], ['Maria', '12:30', '14:10'], ['Freda', '12:00', '14:20']]

   Then write it back out:
with open('output.txt', 'w') as fout:
    for el in lines:
        fout.write('{0}\n'.format(' '.join(el)))

***
   How do I write these as lines on a txt file? – Muhammed Bhikha Nov 23 '12 at 12:31

***
   @Alfe Off The Top Of My Head – Jon Clements♦ Nov 23 '12 at 12:39

***
   @Alfe print >> fout, ' '.join(el) would work, and so would yours, but there's no need to pre-build
   the entire output file as string before writing it – Jon Clements♦ Nov 23 '12 at 12:47

***
   @MuhammedBhikha If it's already in your input file, it'll automatically be in your list as another
   element - if you want to look at adding elements - then look at list.append – Jon Clements♦ Nov

***
   @alfe yup, the "functional" way, assuming map is lazy (3.x) or using imap, is fmt = '{}\n'.format;
   fout.writelines(map(fmt, lines)) or to ensure it across version fout.writelines(fmt(line) for line in
   lines)) – Jon Clements♦ Nov 23 '12 at 13:00


---
https://stackoverflow.com/questions/22361802/sorting-a-numeric-column-in-a-text-file-with-python

Sorting a numeric column in a text file with python

   I am trying to sort a text file by the 4th column that contains over 1000 numbers. I can isolate the
   number column fine but I am unable to sort in ascending order. Here is what I believed was correct.
   But I keep getting the following error:

   'str' object has no attribute 'sort'

   Any advise would be great!
   
file = open("MyFile.txt")

column = []

for line in file:
    column = line[1:].split("\t")[3]

    print (column.sort())

***
   try this code:
file = open("a")
column = []

for line in file:
    column.append(int(line.split("\t")[3]))

column.sort()
print(column)

file.close()

   what changed:
    1. line.split("\t") returns a list of strings, so doing column.append(int(line.split("\t")[3])) we
       select the fourth element of this list, transform it into an integer and add this integer to our
       list (column)
    2. doing print (column.sort()) would print the output of the sort method, which is None so we first
       have to sort the list before we print it. Another solution would be to use the sorted function
       print(sorted(column)) (see here too undestand the difference)
    3. we close the file we opened, no memory leak

***
   If I'm right, you're trying to sort the rows, using the 4th column as an index, no?
sorted(open("MyFile.txt").readlines(), key=lambda line: int(line.split('\t')[3]))

   Should give you the lines, sorted by the integer value of their 4th tab-split column.

***
   line.split() returns a string, as does reading a line from a file. You cannot sort a string because
   it is immutable. You can say:
for line in file:
    column.append(float(line[1:].split("\t")[3]))

column.sort()

***
   "line.split() returns a string": no, line.split() returns a list. – DSM Mar 12 '14 at 19:48

***
   Since you say that the file contains numbers separated by the tab character, you could use the csv
   module to process it. Note that I show 'statistic' since csv files contain headers that allow keys.
   If you do not have that or do not want to use it, just substitute the column index (in your case 3).
   If there is no header line, use the fieldnames parameter to set the column names.
import csv
ifile = open('file.csv', 'rb')
infile = csv.DictReader(ifile, delimiter='\t')
# If the first line does not contain the header then specify the header
try:
  sortedlist = sorted(infile, key=lambda d: float(d['statistic']))
except ValueError:
  #First line was the header, go back and skip it
  ifile.seek(0)
  ifile.next()
  sortedlist = sorted(infile, key=lambda d: float(d['statistic']))
ifile.close()

# now process sortedlist and build an output file to write using csv.DictWriter()


---
https://stackoverflow.com/questions/33768109/python-sorting-data-from-a-text-file-in-an-order-based-upon-a-new-variable

Python: Sorting data from a text file in an order based upon a new variable

   I have a text file that stores data in the following format:
Mike 6 4 3
Terry 4 3 4
Paul 10 7 8

   jvecsei helped me yesterday with some code to retrieve the data and identify the highest score
   for each person. I've modified it slightly so that it now selects the scores and prints an average
   for each person.
with open ("classa.txt") as f:
    content = f.read().splitlines()
    for line in content:
        splitline = line.split(" ")
        name = splitline[0]
        score = splitline[1:]
        total = int(splitline[-1]) + int(splitline[-2]) + int(splitline[-3])
        average = int(total/3)
        print("{} : {}".format (name, average))

   It outputs like this, which is great:
Mike : 4
Terry : 3
Paul : 8

   Question: I'd really like it to sort the three people into order of highest score so that they appear
   with the highest scoring person at the top and the lowest scoring at the bottom, like this:
Paul : 8
Mike : 4
Terry : 3

   I have used this in the past to retrieve from a text file and sort into order alphabetically but
   since the average is a new variable and isn't stored in the text file with the original numbers, I
   don't know how to reference/implement it.
with open('classc.txt', 'r') as r:
    for line in sorted(r):
        print(line, end='')

   Thanks very much for your help. I'm slowly becomeing more familiar with this stuff but I have a long
   way to go yet.

***
   Check this link stackoverflow.com/questions/9001509/… . Although, a dictionary doesn't accept
   duplicates so if the score is unique you can use a ordered dictionary. Remember also that the
   dictionary data structure does not have inherent order. Also, take a look of this link
   stackoverflow.com/questions/613183/… because you could print the dictionary "sorted" by value (in
   case you have multiple scores with the same value) – davideberdin Nov 17 '15 at 22:22

   That's an interesting link. I hadn't seen that before but chances are, it won't be unique i'm afraid
   so i'm not sure it will work in this scenario. This is only a sample of the data and there would be
   instances of a user with scores such as 5 5 5 which may end up causing a problem. Edit: Your second
   link is pretty helpful too. I'm going to give a proper look into this in the morning when i'm more
   awake. Thanks – mjolnir Nov 17 '15 at 22:27

***
   Try my solution, there is a 2.7 compatible one now. – Sebastian Wozny Nov 17 '15 at 22:51

***
   Store your Name : Average output into a dictionary and then use the operator.itemgetter to sort
   your dictionary
d = {}
with open ("file.txt") as f:
    content = f.read().splitlines()
    for line in content:
        splitline = line.split(" ")
        name = splitline[0]
        score = splitline[1:]
        total = int(splitline[-1]) + int(splitline[-2]) + int(splitline[-3])
        average = int(total/3)
        print("{} : {}".format (name, average))
        d[name] = average

sorted_d = sorted(d.items(), key=operator.itemgetter(1), reverse= True)

for i in sorted_d:
    print '{} : {}'.format(*i)

   Output:
Paul : 8
Mike : 4
Terry : 3

***
   With this way of doing it, would I need to have the new 'average' variable written to the file so
   that I can read it into the dictionary? would name = key and average = val? I'm just thinking, or
   rather, you've given me an idea, that I could write the new data to a temp text file and then split
   the data into name/average and sort on the -1 column. What do you think? EDIT: Just seen your edit.
   That looks good. I'll give it a try and let you know how it goes. Thanks very much. – mjolnir Nov

***
   I took this problem to illustrate some of the nice new features in Python 3.5. You can use the
   new statistics module and generalized unpacking to solve this in a very pythonic way:
>>> from statistics import mean # Cool new module!

>>> lines =(l.split() for l in open ("classa.txt")) #  Generator consuming the file
# Now split the list by unpacking into name, *scores
>>> persons = ((mean(int(x) for x in scores), name) for name, *scores in lines)
>>> for score in sorted(persons,  reverse=True): #  Some boring I/O
       print("{} : {}".format (score[1], int(score[0])))
>>>
Paul : 8
Mike : 4
Terry : 3 #  Terry really needs to step up his game

   The following is more traditional python code:
>>> def mean(x):
       return sum(x)/len(x)
>>> lines =(l.split() for l in open ("classa.txt"))
>>> persons = ((mean([int(x) for x in l[1:]]), l[0]) for l in lines)
>>> for score in sorted(persons, reverse=True):
       print("{} : {}".format (score[1], int(score[0])))
>>>
Paul : 8
Mike : 4
Terry : 3

***
   Unfortunately, I'm a little restricted to 3.3.4 at work at the moment although I'm going to try this
   out at home and see how it goes. – mjolnir Nov 17 '15 at 22:37

***
   The traditional Python method looks a little more possible for me. I'll give it a try and report
   back. Thank you. – mjolnir Nov 17 '15 at 22:56

***
   You're a star! p.s. Terry is a big strapping bloke but he definitely need to try harder. I don't know
   how Paul ended up with the highest average, he's always drunk :-) – mjolnir Nov 17 '15 at 23:00

***
   I'm getting the error: TypeError: mean() missing 1 required positional argument. – mjolnir Nov 18
   '15 at 13:03

***
   I know it's not the most efficient way to do it but I put the contents of the text file in a new
   temp.txt file so the data is currently averaged and formatted but not sorted. It looks like this:
   Dave 6 Is there a way to simply sort them now based on the value of the second column using the split
   function? – mjolnir Nov 18 '15 at 13:05


---
https://stackoverflow.com/questions/2100353/sort-csv-by-column

sort csv by column

   I want to sort a CSV table by date. Started out being a simple task:
import sys
import csv

reader = csv.reader(open("files.csv"), delimiter=";")

for id, path, title, date, author, platform, type, port in reader:
    print date

   I used Python's CSV module to read in a file with that structure:
id;file;description;date;author;platform;type;port

     * The date is ISO-8601, therefore I can sort it quite easily without parsing: 2003-04-22 e. g.
     * I want to sort the by date, newest entries first
     * How do I get this reader into a sortable data-structure? I think with some effort I could make a
       datelist: datelist += date, split and sort. However I have to re-identify the complete entry in
       the CSV table. It's not just sorting a list of things.
     * csv doesn't seem to have a built in sorting function

   The optimal solution would be to have a CSV client that handles the file like a database. I didn't
   find anything like that.

   I hope somebody knows some nice sorting magic here ;)

   Thanks,

***
import operator
sortedlist = sorted(reader, key=operator.itemgetter(3), reverse=True)

   or use lambda
sortedlist = sorted(reader, key=lambda row: row[3], reverse=True)

***
   Does this re-write the file, or just save the sorted list in the variable? – Jeff Apr 16 '14 at

***
   @Jeff: It does not touch the original file. If you want to write out the results then you must do so
   as a separate operation. – Ignacio Vazquez-Abrams Apr 16 '14 at 20:50

***
   The reader acts like a generator. On a file with some fake data:
>>> import sys, csv
>>> data = csv.reader(open('data.csv'),delimiter=';')
>>> data
<_csv.reader object at 0x1004a11a0>
>>> data.next()
['a', ' b', ' c']
>>> data.next()
['x', ' y', ' z']
>>> data.next()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration

   Using operator.itemgetter as Ignacio suggests:
>>> data = csv.reader(open('data.csv'),delimiter=';')
>>> import operator
>>> sortedlist = sorted(data, key=operator.itemgetter(2), reverse=True)
>>> sortedlist
[['x', ' y', ' z'], ['a', ' b', ' c']]

***
   in case of MULTIPLE COLUMN sorting:
with open('xxx.csv',newline='') as csvfile:
    spamreader = csv.DictReader(csvfile, delimiter=";")
    sortedlist = sorted(spamreader, key=lambda row:(row['title'],row['date']), reverse=False)

   It would first sorting by title, and then sorting by date.


---
https://stackoverflow.com/questions/10972925/python-sorting-a-text-file-by-fields

Python Sorting a text file by fields

   I'm having some trouble sorting data from a text file by a certain field. Possibly by multiple fields
   later. The .txt is several thousands of lines of code. I'm brand new to python so my code is probably
   a bit messy. For example, this is the textfile i would read from:
stuff
123 1200 id-aaaa stuart@test.com
322 1812 id-wwww machine-switch@test.com
839 1750 id-wwww gary2-da@test.com
500 0545 id-aaaa abc123@test.com
525 1322 id-bbbb zyx321@test.com

   my code so far is as follows:
filelist = open("info.txt").readlines()
splitlist = list()

class data:
    def __init__(self, eventName, time, identity, domain):
        self.evenName = eventName
        self.time = time
        self.identity = identity
        self.domain = domain

for line in filelist:
    filelist = list.split(', ')
    splitlist.append(filelist)

for column in splitlist:
    if (len(column) > 1): #to skip the first line
        eventName = column[0].strip()
        time = column[1].strip()
        identity = column[2].strip()
        domain = column[3].strip()

   I want to sort the .txt file line by line by the identity, then maybe by time. I saw that this could
   be done by classes in the python tutorial, so i'm trying to go that route. Please advise. Thank you!

***
   Is stuff in the text file, or the name of the text file? – Hugh Bothwell Jun 10 '12 at 22:50

***
   It is in the textfile. – user1443368 Jun 10 '12 at 22:59

***
   Is there only one such non-data line (ie a header), or might they occur anywhere? – Hugh Bothwell

***
   There is two to be exact. The first and the last line. – user1443368 Jun 10 '12 at 23:10

***
with open("info.txt") as inf:
    data = []
    for line in inf:
        line = line.split()
        if len(line)==4:
            data.append(line)

data.sort(key=lambda s:(s[2],s[1]))

   If you want to get a bit fancier,
from collections import namedtuple
Input = namedtuple('Input', ('name', 'time', 'identity', 'domain'))

with open("info.txt") as inf:
    inf.next()  # skip header
    data = [Input(*(line.split()) for line in inf]

data.sort(key=lambda s:(s['identity'],s['time']))

   If you really, really want to use a class, try:
import time

class Data(object):
    def __init__(self, event, time_, identity, domain):
        self.event = event
        self.time = time.strptime(time_, "%H%M")
        self.identity = identity
        self.domain = domain

with open("info.txt") as inf:
    data = []
    for line in inf:
        try:
            data.append(Data(*(line.split()))
        except TypeError:
            # wrong number of arguments (ie header or footer)
            pass

data.sort(key=lambda s:(s.identity,s.time))

***
   Hi Hugh. I seem to be getting a "*** non-keyword arg after keyword arg" error on line data.sort(...

***
   Sorry - missed a closing-quote on 'time'. – Hugh Bothwell Jun 10 '12 at 23:12

***
   It was actually on the first block of code you have written down. Is there a certain library that i
   need to include to perform .sort? – user1443368 Jun 10 '12 at 23:14

***
   Nope, sort is built in. I think that either I needed brackets on the s[2],s[1] or it was choking on
   the footer line. – Hugh Bothwell Jun 10 '12 at 23:20

***
   thanks for all the help hugh!! I referred to this a few times and it helped me understand python
   syntax and better coding techniques. – user1443368 Jun 19 '12 at 23:30

***
   This is a common mistake made, what you have done it opened it without actually reading the file in
   the proper syntax, here is what I think:
filelist = open("info.txt", "r")
print filelist
filelist.read() # reads the entire file
splitlist = list()

class data:
    def __init__(self, eventName, time, identity, domain):
        self.evenName = eventName
        self.time = time
        self.identity = identity
        self.domain = domain

for line in filelist:
    filelist = list.split(', ')
    splitlist.append(filelist)

for column in splitlist:
    if (len(column) > 1): #to skip the first line
        eventName = column[0].strip()
        time = column[1].strip()
        identity = column[2].strip()
        domain = column[3].strip()

   Hope that works! Source: http://docs.python.org/tutorial/inputoutput.html

***
   filelist.read() brings the entire file line in as a single line of data... not what is wanted.

***
   To sort by id then date:
text = ["123 1200 id-aaaa stuart@test.com",
        "322 1812 id-wwww machine-switch@test.com",
        "839 1750 id-wwww gary2-da@test.com",
        "500 0545 id-aaaa abc123@test.com",
        "525 1322 id-bbbb zyx321@test.com"]
text = [i.split() for i in text]
text.sort(key=lambda line: (line[2],line[1]))
text = [' '.join(i) for i in text]
print text
#Output:
['500 0545 id-aaaa abc123@test.com',
'123 1200 id-aaaa stuart@test.com',
'525 1322 id-bbbb zyx321@test.com',
'839 1750 id-wwww gary2-da@test.com',
'322 1812 id-wwww machine-switch@test.com']

***
   If you're going to do text = sorted(text), it would use half as much memory to just text.sort().

***
   @Hugh Bothwell - thankyou, I have amended, but you were way faster on the trigger! – fraxel Jun

***
   The following Python code should put together the information you want, which is then sorted.
rows = []
for line in open("info.txt"):
    line = line.split()
    if len(line) != 4:
        continue

    eventName, time, identity, domain = line

    # Add them in the order you want to sort by
    rows.append((identity, time, eventName, domain))

rows.sort()
