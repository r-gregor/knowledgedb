filename: Quora_RUST-is-the-most-preferred-programming-language_20170829.txt
https://www.quora.com/What-is-the-most-preferred-programming-language

   According to Stack Overflow Developer Survey 2017 it is Rust, and I share that view. Rust is a
   (currently) unique programming languages that gets incredible love because it is reverse Javascript /
   PHP / whatever.

   Let me explain this:

   Normally, people start programming with a simple language. Most these days Python or Java. Soon after
   they will start learning how these languages are shit, and how design patterns are used to work
   around the shitty parts.

   Over time people will recognize that they will ultimately learn more languages: Probably Python,
   Java, C/C++, maybe C#, SQL of course, Javascript. Because in the end, newcomers soon learn that
   libraries and frameworks are everything. That’s why Java is still the king in enterprise software,
   and will continue to be so for the next 10 years (after that, who knows).

   At this point, languages are interchangeable. No language is inherently more powerful than any other.
   But all of them contains shitty parts, and therefore require design patterns for effective work.
   Afterwards you will learn about the Tier 2 languages: Scala, Go, Kotlin, TypeScript, etc.. Those are
   languages who have been developed by taking some Tier 1 language and embedding design patterns into
   the language - in a sense, it’s evolution. Most of these languages still fail because they are
   missing libraries and frameworks and will probably never catch up with the big players because of
   fragmentation and the economy of software development scale. Scala, Kotlin, TypeScript etc. cheat in
   that regard: TypeScript is basically Javascript and can use mostly any Javascript framework out
   there. Kotlin and Scala compile to JVM code and can therefore be used with any other Java library.

   Now you will continue using these Tier 2 languages, but most of us only in personal projects -
   enterprise development isn’t about productivity on a language level, but on the tool level, so Tier 1
   languages (especially Java) still dominate the market.

   This is the point where you develop nihilistic pessimism about languages - every month or so, a new
   small language appears. And it makes small improvements compared to other languages, speeding up
   common software patterns, etc. etc.. But they are never something really new. Swift is a good
   example. Objective-C devs loved it and saw it as the prince promised, but in reality, Swift is just
   like Scala / Go / Kotlin, and the only reason iOS developers love it so much is that Objective-C is
   reeeaally bad, and shouldn’t be regarded even as a Tier 1 language (but it is, because iPhones are
   the product of the century I fear).

   Suddenly your IT news is reporting over a new language. Its name is Rust. It is not inherently
   designed for declarative programming, or functional programming, and does not use only immutable
   datatypes. But Mozilla is behind the project, and you start to dig deeper. Suddenly you understand
   that the word ‘ownership’ in regards to Rust objects is not a buzzword as in other languages, or a
   design pattern that has to be uphold to write good software.

   Your interest is piqued, and you felt like that time you tried your first Tier 2 language. Suddenly a
   whole new world awaits you. But Rust is not easy. Rust is fucking hard. Rust is probably one of the
   hardest general purpose non-joke programming languages that has been invented in the last 15 years.

   But it’s not hard because of its syntax, or because of some weird specialty. It’s hard because it
   enforces software development concepts on the compiler level. You cannot break those concepts and
   rules at all. A compiler is the language, and Rust is good software development.

   Rust is not another Scala, or another C++. Rust is the next generation of programming languages. And
   there’s a gravity to it.

   The community of Rust understands that good software requires hard work. That no abstraction can ever
   hide complexity forever. And they still see it as special, and they work hard on making it even
   better. That’s why Rust has a great tool. Cargo is the best on-board build system I have ever
   witnessed. The Rust Language Server is the first implementation of the LS specification.
   Crosscompiling becomes a matter of adding a compilation flag to the cargo call, and nothing more. And
   in the middle of all of that? The compiler itself.

   Once you wrote your second Rust program, you will be hooked. Not because it becomes easy, but because
   it keeps being hard.

   Writing good software is always hard. But Rust stops you from making shortcuts, from taking on
   technical debt.

   And in the end, this kind of behavior makes it different from all those other languages. They try to
   make programming easy, but in the process they hide complexity, and that complexity will never stay
   hidden forever. But Rust forces you to deal with that complexity. To deal with the fact that you are
   writing computer programs.

   And it will make you a better programmer in the process, both in high level and low level
   programming.

***
   Some people will cite the StackOverflow survey and suggest that JavaScript is the most preferred
   programming language. However, this is extremely misleading…

   JavaScript may be the most preferred web programming language, but if you look at the whole of the IT
   industry, JavaScript is most assuredly NOT the most preferred.

   Java is the enterprise standard programming language, and there are far, far more job postings for
   Java than for JavaScript at Indeed.com.

   The StackOverflow survey is seriously skewed by the number of web fanatics who participate. Think
   about it. There are 18.5 million professional software developers worldwide. Is it reasonable that
   62.5% of them use JavaScript and the rest use Java, Python, C++, PHP, C#, Ruby, C, Scala, Groovy, Go,
   Objective-C, Perl, Kotlin, etc.? You’d have to be drinking some serious Kool-Aid to think so.

   Similarly, GitHub stats seriously overrepresent JavaScript. Since JavaScript is the only language
   native to the web browser, it is necessarily a part of every web project repo at GitHub, whether that
   web project is based on PHP, Java, Python, C#, Ruby, Scala, Groovy, or Perl. GitHub greatly inflates
   JavaScript’s numbers.

   And let’s keep in mind that GitHub only represents open source projects.

   The only reasonable metric is the set of non-GitHub-related language rankings on the web where
   JavaScript is #8 at TIOBE, #7 at IEEE Spectrum, #5 at PYPL, #6 at CodeEval, #4 at Coding Dojo, and #7
   at HackerRank. These rankings are roughly consistent with one another, and that tells me they’re more
   trustworthy.

   As I said, even the job postings from Indeed.com (and from Trendy Skills) do not suggest that
   JavaScript is #1.

***
   Nonetheless, high prevalence of interpreted dialects doesn't mean they are great. It implies they are
   simply ware dialects to take care of business rapidly. For genuine programming development you need
   to compose using C or C++. Arranged from C with streamlining banners empowered, the created code is
   very nearly 90% as quick and asset productive as writing in constructing agent.

   Rust is the nearest dialect to the execution of C, it notoriety is growing quick and it is extremely
   promising dialect. Be that as it may, it takes a considerable measure to arrange. Along these lines,
   on the off chance that you need to invest genuinely in programming development you need to begin
   writing in C. C Programmers are likewise the best-paid software engineers.

***
   The question you’re asking is highly controversial. Different programmers prefer different
   technologies, and my experience is that their preference is usually driven by accident — yet they
   have very strong feelings towards the technology of “their” choice, which eventually makes them
   divide into tribes or camps that fight with one another.

   The typical arguments that appear in such discussions often resort either to popularity (i.e.
   “language X is better than Y because it is more often used”) or to some arbitrary features, sometimes
   mutually exclusive (like “language X is better than Y because it has a garbage collector/type
   inference/lambdas/duck typing/latent binding/transactional memory/actors/…”). A frequent argument
   resorts to “speed”, as in “language X is better than Y because it is faster” — of course, since it
   makes no sense to talk about the speed of abstract notations, the authors of such arguments usually
   mean that the languages have implementations which allow to execute the code written in those
   languages efficiently.

   Since the field of programming languages is highly opinionated, I guess the only way to find out
   which language is “preferred” by you is to specify your goals and then try some of these languages
   for yourself, hopefully keeping an open mind not to get stuck with the first technology that you
   happen to run into.
