filename: ptn_logging_20180814.txt
https://docs.python.org/3/howto/logging.html

Logging HOWTO

Basic Logging Tutorial
Logging is a means of tracking events that happen when some software runs. The software’s developer adds
logging calls to their code to indicate that certain events have occurred. An event is described by a
descriptive message which can optionally contain variable data (i.e. data that is potentially different for
each occurrence of the event). Events also have an importance which the developer ascribes to the event; the
importance can also be called the level or severity.

When to use logging
Logging provides a set of convenience functions for simple logging usage. These are debug(), info(), warning
(), error() and critical(). To determine when to use logging, see the table below, which states, for each of
a set of common tasks, the best tool to use for it.

┌──────────────────────────────────────────────────┬────────────────────────────────────────────────────────┐
│             Task you want to perform             │               The best tool for the task               │
├──────────────────────────────────────────────────┼────────────────────────────────────────────────────────┤
│Display console output for ordinary usage of a    │print()                                                 │
│command line script or program                    │                                                        │
├──────────────────────────────────────────────────┼────────────────────────────────────────────────────────┤
│Report events that occur during normal operation  │logging.info() (or logging.debug() for very detailed    │
│of a program (e.g. for status monitoring or fault │output for diagnostic purposes)                         │
│investigation)                                    │                                                        │
├──────────────────────────────────────────────────┼────────────────────────────────────────────────────────┤
│                                                  │warnings.warn() in library code if the issue is         │
│                                                  │avoidable and the client application should be modified │
│Issue a warning regarding a particular runtime    │to eliminate the warning                                │
│event                                             │                                                        │
│                                                  │logging.warning() if there is nothing the client        │
│                                                  │application can do about the situation, but the event   │
│                                                  │should still be noted                                   │
├──────────────────────────────────────────────────┼────────────────────────────────────────────────────────┤
│Report an error regarding a particular runtime    │Raise an exception                                      │
│event                                             │                                                        │
├──────────────────────────────────────────────────┼────────────────────────────────────────────────────────┤
│Report suppression of an error without raising an │logging.error(), logging.exception() or logging.critical│
│exception (e.g. error handler in a long-running   │() as appropriate for the specific error and application│
│server process)                                   │domain                                                  │
└──────────────────────────────────────────────────┴────────────────────────────────────────────────────────┘

The logging functions are named after the level or severity of the events they are used to track. The
standard levels and their applicability are described below (in increasing order of severity):

┌────────┬──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ Level  │                                          When it’s used                                          │
├────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│DEBUG   │Detailed information, typically of interest only when diagnosing problems.                        │
├────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│INFO    │Confirmation that things are working as expected.                                                 │
├────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│WARNING │An indication that something unexpected happened, or indicative of some problem in the near future│
│        │(e.g. ‘disk space low’). The software is still working as expected.                               │
├────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│ERROR   │Due to a more serious problem, the software has not been able to perform some function.           │
├────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│CRITICAL│A serious error, indicating that the program itself may be unable to continue running.            │
└────────┴──────────────────────────────────────────────────────────────────────────────────────────────────┘

The default level is WARNING, which means that only events of this level and above will be tracked, unless
the logging package is configured to do otherwise.

Events that are tracked can be handled in different ways. The simplest way of handling tracked events is to
print them to the console. Another common way is to write them to a disk file.

A simple example
A very simple example is:

import logging
logging.warning('Watch out!')  # will print a message to the console
logging.info('I told you so')  # will not print anything

If you type these lines into a script and run it, you’ll see:

WARNING:root:Watch out!

printed out on the console. The INFO message doesn’t appear because the default level is WARNING. The printed
message includes the indication of the level and the description of the event provided in the logging call,
i.e. ‘Watch out!’. Don’t worry about the ‘root’ part for now: it will be explained later. The actual output
can be formatted quite flexibly if you need that; formatting options will also be explained later.

Logging to a file
A very common situation is that of recording logging events in a file, so let’s look at that next. Be sure to
try the following in a newly-started Python interpreter, and don’t just continue from the session described
above:

import logging
logging.basicConfig(filename='example.log',level=logging.DEBUG)
logging.debug('This message should go to the log file')
logging.info('So should this')
logging.warning('And this, too')

And now if we open the file and look at what we have, we should find the log messages:

DEBUG:root:This message should go to the log file
INFO:root:So should this
WARNING:root:And this, too

This example also shows how you can set the logging level which acts as the threshold for tracking. In this
case, because we set the threshold to DEBUG, all of the messages were printed.

If you want to set the logging level from a command-line option such as:

--log=INFO

and you have the value of the parameter passed for --log in some variable loglevel, you can use:

getattr(logging, loglevel.upper())

to get the value which you’ll pass to basicConfig() via the level argument. You may want to error check any
user input value, perhaps as in the following example:

# assuming loglevel is bound to the string value obtained from the
# command line argument. Convert to upper case to allow the user to
# specify --log=DEBUG or --log=debug
numeric_level = getattr(logging, loglevel.upper(), None)
if not isinstance(numeric_level, int):
    raise ValueError('Invalid log level: %s' % loglevel)
logging.basicConfig(level=numeric_level, ...)

The call to basicConfig() should come before any calls to debug(), info() etc. As it’s intended as a one-off
simple configuration facility, only the first call will actually do anything: subsequent calls are
effectively no-ops.

If you run the above script several times, the messages from successive runs are appended to the file
example.log. If you want each run to start afresh, not remembering the messages from earlier runs, you can
specify the filemode argument, by changing the call in the above example to:

logging.basicConfig(filename='example.log', filemode='w', level=logging.DEBUG)

The output will be the same as before, but the log file is no longer appended to, so the messages from
earlier runs are lost.

Logging from multiple modules
If your program consists of multiple modules, here’s an example of how you could organize logging in it:

# myapp.py
import logging
import mylib

def main():
    logging.basicConfig(filename='myapp.log', level=logging.INFO)
    logging.info('Started')
    mylib.do_something()
    logging.info('Finished')

if __name__ == '__main__':
    main()

# mylib.py
import logging

def do_something():
    logging.info('Doing something')

If you run myapp.py, you should see this in myapp.log:

INFO:root:Started
INFO:root:Doing something
INFO:root:Finished

which is hopefully what you were expecting to see. You can generalize this to multiple modules, using the
pattern in mylib.py. Note that for this simple usage pattern, you won’t know, by looking in the log file,
where in your application your messages came from, apart from looking at the event description. If you want
to track the location of your messages, you’ll need to refer to the documentation beyond the tutorial level –
see Advanced Logging Tutorial.

Logging variable data
To log variable data, use a format string for the event description message and append the variable data as
arguments. For example:

import logging
logging.warning('%s before you %s', 'Look', 'leap!')

will display:

WARNING:root:Look before you leap!

As you can see, merging of variable data into the event description message uses the old, %-style of string
formatting. This is for backwards compatibility: the logging package pre-dates newer formatting options such
as str.format() and string.Template. These newer formatting options are supported, but exploring them is
outside the scope of this tutorial: see Using particular formatting styles throughout your application for
more information.

Changing the format of displayed messages

To change the format which is used to display messages, you need to specify the format you want to use:

import logging
logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.DEBUG)
logging.debug('This message should appear on the console')
logging.info('So should this')
logging.warning('And this, too')

which would print:

DEBUG:This message should appear on the console
INFO:So should this
WARNING:And this, too

Notice that the ‘root’ which appeared in earlier examples has disappeared. For a full set of things that can
appear in format strings, you can refer to the documentation for LogRecord attributes, but for simple usage,
you just need the levelname (severity), message (event description, including variable data) and perhaps to
display when the event occurred. This is described in the next section.

Displaying the date/time in messages
To display the date and time of an event, you would place ‘%(asctime)s’ in your format string:

import logging
logging.basicConfig(format='%(asctime)s %(message)s')
logging.warning('is when this event was logged.')

which should print something like this:

2010-12-12 11:41:42,612 is when this event was logged.

The default format for date/time display (shown above) is like ISO8601 or RFC 3339. If you need more control
over the formatting of the date/time, provide a datefmt argument to basicConfig, as in this example:

import logging
logging.basicConfig(format='%(asctime)s %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p')
logging.warning('is when this event was logged.')

which would display something like this:

12/12/2010 11:46:36 AM is when this event was logged.

The format of the datefmt argument is the same as supported by time.strftime().

Next Steps
That concludes the basic tutorial. It should be enough to get you up and running with logging. There’s a lot
more that the logging package offers, but to get the best out of it, you’ll need to invest a little more of
your time in reading the following sections. If you’re ready for that, grab some of your favourite beverage
and carry on.

If your logging needs are simple, then use the above examples to incorporate logging into your own scripts,
and if you run into problems or don’t understand something, please post a question on the comp.lang.python
Usenet group (available at https://groups.google.com/forum/#!forum/comp.lang.python) and you should receive
help before too long.

Still here? You can carry on reading the next few sections, which provide a slightly more advanced/in-depth
tutorial than the basic one above. After that, you can take a look at the Logging Cookbook.

Advanced Logging Tutorial
The logging library takes a modular approach and offers several categories of components: loggers, handlers,
filters, and formatters.

  - Loggers expose the interface that application code directly uses.
  - Handlers send the log records (created by loggers) to the appropriate destination.
  - Filters provide a finer grained facility for determining which log records to output.
  - Formatters specify the layout of log records in the final output.

Log event information is passed between loggers, handlers, filters and formatters in a LogRecord instance.

Logging is performed by calling methods on instances of the Logger class (hereafter called loggers). Each
instance has a name, and they are conceptually arranged in a namespace hierarchy using dots (periods) as
separators. For example, a logger named ‘scan’ is the parent of loggers ‘scan.text’, ‘scan.html’ and
‘scan.pdf’. Logger names can be anything you want, and indicate the area of an application in which a logged
message originates.

A good convention to use when naming loggers is to use a module-level logger, in each module which uses
logging, named as follows:

logger = logging.getLogger(__name__)

This means that logger names track the package/module hierarchy, and it’s intuitively obvious where events
are logged just from the logger name.

The root of the hierarchy of loggers is called the root logger. That’s the logger used by the functions debug
(), info(), warning(), error() and critical(), which just call the same-named method of the root logger. The
functions and the methods have the same signatures. The root logger’s name is printed as ‘root’ in the logged
output.

It is, of course, possible to log messages to different destinations. Support is included in the package for
writing log messages to files, HTTP GET/POST locations, email via SMTP, generic sockets, queues, or
OS-specific logging mechanisms such as syslog or the Windows NT event log. Destinations are served by handler
classes. You can create your own log destination class if you have special requirements not met by any of the
built-in handler classes.

By default, no destination is set for any logging messages. You can specify a destination (such as console or
file) by using basicConfig() as in the tutorial examples. If you call the functions debug(), info(), warning
(), error() and critical(), they will check to see if no destination is set; and if one is not set, they will
set a destination of the console (sys.stderr) and a default format for the displayed message before
delegating to the root logger to do the actual message output.

The default format set by basicConfig() for messages is:

severity:logger name:message

You can change this by passing a format string to basicConfig() with the format keyword argument. For all
options regarding how a format string is constructed, see Formatter Objects.

Logging Flow
The flow of log event information in loggers and handlers is illustrated in the following diagram.

../_images/logging_flow.png

Loggers
Logger objects have a threefold job. First, they expose several methods to application code so that
applications can log messages at runtime. Second, logger objects determine which log messages to act upon
based upon severity (the default filtering facility) or filter objects. Third, logger objects pass along
relevant log messages to all interested log handlers.

The most widely used methods on logger objects fall into two categories: configuration and message sending.

These are the most common configuration methods:

  - Logger.setLevel() specifies the lowest-severity log message a logger will handle, where debug is the
    lowest built-in severity level and critical is the highest built-in severity. For example, if the
    severity level is INFO, the logger will handle only INFO, WARNING, ERROR, and CRITICAL messages and will
    ignore DEBUG messages.
  - Logger.addHandler() and Logger.removeHandler() add and remove handler objects from the logger object.
    Handlers are covered in more detail in Handlers.
  - Logger.addFilter() and Logger.removeFilter() add and remove filter objects from the logger object.
    Filters are covered in more detail in Filter Objects.

You don’t need to always call these methods on every logger you create. See the last two paragraphs in this
section.

With the logger object configured, the following methods create log messages:
  - Logger.debug(), Logger.info(), Logger.warning(), Logger.error(), and Logger.critical() all create log
    records with a message and a level that corresponds to their respective method names. The message is
    actually a format string, which may contain the standard string substitution syntax of %s, %d, %f, and so
    on. The rest of their arguments is a list of objects that correspond with the substitution fields in the
    message. With regard to **kwargs, the logging methods care only about a keyword of exc_info and use it to
    determine whether to log exception information.
  - Logger.exception() creates a log message similar to Logger.error(). The difference is that
    Logger.exception() dumps a stack trace along with it. Call this method only from an exception handler.
  - Logger.log() takes a log level as an explicit argument. This is a little more verbose for logging
    messages than using the log level convenience methods listed above, but this is how to log at custom log
    levels.

getLogger() returns a reference to a logger instance with the specified name if it is provided, or root if
not. The names are period-separated hierarchical structures. Multiple calls to getLogger() with the same name
will return a reference to the same logger object. Loggers that are further down in the hierarchical list are
children of loggers higher up in the list. For example, given a logger with a name of foo, loggers with names
of foo.bar, foo.bar.baz, and foo.bam are all descendants of foo.

Loggers have a concept of effective level. If a level is not explicitly set on a logger, the level of its
parent is used instead as its effective level. If the parent has no explicit level set, its parent is
examined, and so on - all ancestors are searched until an explicitly set level is found. The root logger
always has an explicit level set (WARNING by default). When deciding whether to process an event, the
effective level of the logger is used to determine whether the event is passed to the logger’s handlers.

Child loggers propagate messages up to the handlers associated with their ancestor loggers. Because of this,
it is unnecessary to define and configure handlers for all the loggers an application uses. It is sufficient
to configure handlers for a top-level logger and create child loggers as needed. (You can, however, turn off
propagation by setting the propagate attribute of a logger to False.)

Handlers
Handler objects are responsible for dispatching the appropriate log messages (based on the log messages’
severity) to the handler’s specified destination. Logger objects can add zero or more handler objects to
themselves with an addHandler() method. As an example scenario, an application may want to send all log
messages to a log file, all log messages of error or higher to stdout, and all messages of critical to an
email address. This scenario requires three individual handlers where each handler is responsible for sending
messages of a specific severity to a specific location.

The standard library includes quite a few handler types (see Useful Handlers); the tutorials use mainly
StreamHandler and FileHandler in its examples.

There are very few methods in a handler for application developers to concern themselves with. The only
handler methods that seem relevant for application developers who are using the built-in handler objects
(that is, not creating custom handlers) are the following configuration methods:

  - The setLevel() method, just as in logger objects, specifies the lowest severity that will be dispatched
    to the appropriate destination. Why are there two setLevel() methods? The level set in the logger
    determines which severity of messages it will pass to its handlers. The level set in each handler
    determines which messages that handler will send on.
  - setFormatter() selects a Formatter object for this handler to use.
  - addFilter() and removeFilter() respectively configure and deconfigure filter objects on handlers.

Application code should not directly instantiate and use instances of Handler. Instead, the Handler class is
a base class that defines the interface that all handlers should have and establishes some default behavior
that child classes can use (or override).

Formatters
Formatter objects configure the final order, structure, and contents of the log message. Unlike the base
logging.Handler class, application code may instantiate formatter classes, although you could likely subclass
the formatter if your application needs special behavior. The constructor takes three optional arguments – a
message format string, a date format string and a style indicator.

logging.Formatter.__init__(fmt=None, datefmt=None, style='%')

If there is no message format string, the default is to use the raw message. If there is no date format
string, the default date format is:

%Y-%m-%d %H:%M:%S

with the milliseconds tacked on at the end. The style is one of %, ‘{‘ or ‘$’. If one of these is not
specified, then ‘%’ will be used.

If the style is ‘%’, the message format string uses %(<dictionary key>)s styled string substitution; the
possible keys are documented in LogRecord attributes. If the style is ‘{‘, the message format string is
assumed to be compatible with str.format() (using keyword arguments), while if the style is ‘$’ then the
message format string should conform to what is expected by string.Template.substitute().

Changed in version 3.2: Added the style parameter.
The following message format string will log the time in a human-readable format, the severity of the
message, and the contents of the message, in that order:

'%(asctime)s - %(levelname)s - %(message)s'

Formatters use a user-configurable function to convert the creation time of a record to a tuple. By default,
time.localtime() is used; to change this for a particular formatter instance, set the converter attribute of
the instance to a function with the same signature as time.localtime() or time.gmtime(). To change it for all
formatters, for example if you want all logging times to be shown in GMT, set the converter attribute in the
Formatter class (to time.gmtime for GMT display).

Configuring Logging
Programmers can configure logging in three ways:
 1. Creating loggers, handlers, and formatters explicitly using Python code that calls the configuration
    methods listed above.
 2. Creating a logging config file and reading it using the fileConfig() function.
 3. Creating a dictionary of configuration information and passing it to the dictConfig() function.

For the reference documentation on the last two options, see Configuration functions. The following example
configures a very simple logger, a console handler, and a simple formatter using Python code:

import logging

# create logger
logger = logging.getLogger('simple_example')
logger.setLevel(logging.DEBUG)

# create console handler and set level to debug
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)

# create formatter
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# add formatter to ch
ch.setFormatter(formatter)

# add ch to logger
logger.addHandler(ch)

# 'application' code
logger.debug('debug message')
logger.info('info message')
logger.warn('warn message')
logger.error('error message')
logger.critical('critical message')

Running this module from the command line produces the following output:

$ python simple_logging_module.py
2005-03-19 15:10:26,618 - simple_example - DEBUG - debug message
2005-03-19 15:10:26,620 - simple_example - INFO - info message
2005-03-19 15:10:26,695 - simple_example - WARNING - warn message
2005-03-19 15:10:26,697 - simple_example - ERROR - error message
2005-03-19 15:10:26,773 - simple_example - CRITICAL - critical message

The following Python module creates a logger, handler, and formatter nearly identical to those in the example
listed above, with the only difference being the names of the objects:

import logging
import logging.config

logging.config.fileConfig('logging.conf')

# create logger
logger = logging.getLogger('simpleExample')

# 'application' code
logger.debug('debug message')
logger.info('info message')
logger.warn('warn message')
logger.error('error message')
logger.critical('critical message')

Here is the logging.conf file:

[loggers]
keys=root,simpleExample

[handlers]
keys=consoleHandler

[formatters]
keys=simpleFormatter

[logger_root]
level=DEBUG
handlers=consoleHandler

[logger_simpleExample]
level=DEBUG
handlers=consoleHandler
qualname=simpleExample
propagate=0

[handler_consoleHandler]
class=StreamHandler
level=DEBUG
formatter=simpleFormatter
args=(sys.stdout,)

[formatter_simpleFormatter]
format=%(asctime)s - %(name)s - %(levelname)s - %(message)s
datefmt=

The output is nearly identical to that of the non-config-file-based example:

$ python simple_logging_config.py
2005-03-19 15:38:55,977 - simpleExample - DEBUG - debug message
2005-03-19 15:38:55,979 - simpleExample - INFO - info message
2005-03-19 15:38:56,054 - simpleExample - WARNING - warn message
2005-03-19 15:38:56,055 - simpleExample - ERROR - error message
2005-03-19 15:38:56,130 - simpleExample - CRITICAL - critical message

You can see that the config file approach has a few advantages over the Python code approach, mainly
separation of configuration and code and the ability of noncoders to easily modify the logging properties.

Warning
The fileConfig() function takes a default parameter, disable_existing_loggers, which defaults to True for
reasons of backward compatibility. This may or may not be what you want, since it will cause any loggers
existing before the fileConfig() call to be disabled unless they (or an ancestor) are explicitly named in the
configuration. Please refer to the reference documentation for more information, and specify False for this
parameter if you wish.

The dictionary passed to dictConfig() can also specify a Boolean value with key disable_existing_loggers,
which if not specified explicitly in the dictionary also defaults to being interpreted as True. This leads to
the logger-disabling behaviour described above, which may not be what you want - in which case, provide the
key explicitly with a value of False.

Note that the class names referenced in config files need to be either relative to the logging module, or
absolute values which can be resolved using normal import mechanisms. Thus, you could use either
WatchedFileHandler (relative to the logging module) or mypackage.mymodule.MyHandler (for a class defined in
package mypackage and module mymodule, where mypackage is available on the Python import path).

In Python 3.2, a new means of configuring logging has been introduced, using dictionaries to hold
configuration information. This provides a superset of the functionality of the config-file-based approach
outlined above, and is the recommended configuration method for new applications and deployments. Because a
Python dictionary is used to hold configuration information, and since you can populate that dictionary using
different means, you have more options for configuration. For example, you can use a configuration file in
JSON format, or, if you have access to YAML processing functionality, a file in YAML format, to populate the
configuration dictionary. Or, of course, you can construct the dictionary in Python code, receive it in
pickled form over a socket, or use whatever approach makes sense for your application.

Here’s an example of the same configuration as above, in YAML format for the new dictionary-based approach:

version: 1
formatters:
  simple:
    format: '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
handlers:
  console:
    class: logging.StreamHandler
    level: DEBUG
    formatter: simple
    stream: ext://sys.stdout
loggers:
  simpleExample:
    level: DEBUG
    handlers: [console]
    propagate: no
  root:
    level: DEBUG
    handlers: [console]

For more information about logging using a dictionary, see Configuration functions.

What happens if no configuration is provided
If no logging configuration is provided, it is possible to have a situation where a logging event needs to be
output, but no handlers can be found to output the event. The behaviour of the logging package in these
circumstances is dependent on the Python version.

For versions of Python prior to 3.2, the behaviour is as follows:

  - If logging.raiseExceptions is False (production mode), the event is silently dropped.
  - If logging.raiseExceptions is True (development mode), a message ‘No handlers could be found for logger
    X.Y.Z’ is printed once.

In Python 3.2 and later, the behaviour is as follows:

  - The event is output using a ‘handler of last resort’, stored in logging.lastResort. This internal handler
    is not associated with any logger, and acts like a StreamHandler which writes the event description
    message to the current value of sys.stderr (therefore respecting any redirections which may be in
    effect). No formatting is done on the message - just the bare event description message is printed. The
    handler’s level is set to WARNING, so all events at this and greater severities will be output.

To obtain the pre-3.2 behaviour, logging.lastResort can be set to None.

Configuring Logging for a Library
When developing a library which uses logging, you should take care to document how the library uses logging -
for example, the names of loggers used. Some consideration also needs to be given to its logging
configuration. If the using application does not use logging, and library code makes logging calls, then (as
described in the previous section) events of severity WARNING and greater will be printed to sys.stderr. This
is regarded as the best default behaviour.

If for some reason you don’t want these messages printed in the absence of any logging configuration, you can
attach a do-nothing handler to the top-level logger for your library. This avoids the message being printed,
since a handler will be always be found for the library’s events: it just doesn’t produce any output. If the
library user configures logging for application use, presumably that configuration will add some handlers,
and if levels are suitably configured then logging calls made in library code will send output to those
handlers, as normal.

A do-nothing handler is included in the logging package: NullHandler (since Python 3.1). An instance of this
handler could be added to the top-level logger of the logging namespace used by the library (if you want to
prevent your library’s logged events being output to sys.stderr in the absence of logging configuration). If
all logging by a library foo is done using loggers with names matching ‘foo.x’, ‘foo.x.y’, etc. then the
code:

import logging
logging.getLogger('foo').addHandler(logging.NullHandler())

should have the desired effect. If an organisation produces a number of libraries, then the logger name
specified can be ‘orgname.foo’ rather than just ‘foo’.

Note
It is strongly advised that you do not add any handlers other than NullHandler to your library’s loggers.
This is because the configuration of handlers is the prerogative of the application developer who uses your
library. The application developer knows their target audience and what handlers are most appropriate for
their application: if you add handlers ‘under the hood’, you might well interfere with their ability to carry
out unit tests and deliver logs which suit their requirements.

Logging Levels
The numeric values of logging levels are given in the following table. These are primarily of interest if you
want to define your own levels, and need them to have specific values relative to the predefined levels. If
you define a level with the same numeric value, it overwrites the predefined value; the predefined name is
lost.

┌────────┬──────────────┐
│ Level  │Numeric value │
├────────┼──────────────┤
│CRITICAL│50            │
├────────┼──────────────┤
│ERROR   │40            │
├────────┼──────────────┤
│WARNING │30            │
├────────┼──────────────┤
│INFO    │20            │
├────────┼──────────────┤
│DEBUG   │10            │
├────────┼──────────────┤
│NOTSET  │0             │
└────────┴──────────────┘

Levels can also be associated with loggers, being set either by the developer or through loading a saved
logging configuration. When a logging method is called on a logger, the logger compares its own level with
the level associated with the method call. If the logger’s level is higher than the method call’s, no logging
message is actually generated. This is the basic mechanism controlling the verbosity of logging output.

Logging messages are encoded as instances of the LogRecord class. When a logger decides to actually log an
event, a LogRecord instance is created from the logging message.

Logging messages are subjected to a dispatch mechanism through the use of handlers, which are instances of
subclasses of the Handler class. Handlers are responsible for ensuring that a logged message (in the form of
a LogRecord) ends up in a particular location (or set of locations) which is useful for the target audience
for that message (such as end users, support desk staff, system administrators, developers). Handlers are
passed LogRecord instances intended for particular destinations. Each logger can have zero, one or more
handlers associated with it (via the addHandler() method of Logger). In addition to any handlers directly
associated with a logger, all handlers associated with all ancestors of the logger are called to dispatch the
message (unless the propagate flag for a logger is set to a false value, at which point the passing to
ancestor handlers stops).

Just as for loggers, handlers can have levels associated with them. A handler’s level acts as a filter in the
same way as a logger’s level does. If a handler decides to actually dispatch an event, the emit() method is
used to send the message to its destination. Most user-defined subclasses of Handler will need to override
this emit().

Custom Levels
Defining your own levels is possible, but should not be necessary, as the existing levels have been chosen on
the basis of practical experience. However, if you are convinced that you need custom levels, great care
should be exercised when doing this, and it is possibly a very bad idea to define custom levels if you are
developing a library. That’s because if multiple library authors all define their own custom levels, there is
a chance that the logging output from such multiple libraries used together will be difficult for the using
developer to control and/or interpret, because a given numeric value might mean different things for
different libraries.

Useful Handlers
In addition to the base Handler class, many useful subclasses are provided:
 1. StreamHandler instances send messages to streams (file-like objects).
 2. FileHandler instances send messages to disk files.
 3. BaseRotatingHandler is the base class for handlers that rotate log files at a certain point. It is not
    meant to be instantiated directly. Instead, use RotatingFileHandler or TimedRotatingFileHandler.
 4. RotatingFileHandler instances send messages to disk files, with support for maximum log file sizes and
    log file rotation.
 5. TimedRotatingFileHandler instances send messages to disk files, rotating the log file at certain timed
    intervals.
 6. SocketHandler instances send messages to TCP/IP sockets. Since 3.4, Unix domain sockets are also
    supported.
 7. DatagramHandler instances send messages to UDP sockets. Since 3.4, Unix domain sockets are also
    supported.
 8. SMTPHandler instances send messages to a designated email address.
 9. SysLogHandler instances send messages to a Unix syslog daemon, possibly on a remote machine.
10. NTEventLogHandler instances send messages to a Windows NT/2000/XP event log.
11. MemoryHandler instances send messages to a buffer in memory, which is flushed whenever specific criteria
    are met.
12. HTTPHandler instances send messages to an HTTP server using either GET or POST semantics.
13. WatchedFileHandler instances watch the file they are logging to. If the file changes, it is closed and
    reopened using the file name. This handler is only useful on Unix-like systems; Windows does not support
    the underlying mechanism used.
14. QueueHandler instances send messages to a queue, such as those implemented in the queue or
    multiprocessing modules.
15. NullHandler instances do nothing with error messages. They are used by library developers who want to use
    logging, but want to avoid the ‘No handlers could be found for logger XXX’ message which can be displayed
    if the library user has not configured logging. See Configuring Logging for a Library for more
    information.

New in version 3.1: The NullHandler class.

New in version 3.2: The QueueHandler class.

The NullHandler, StreamHandler and FileHandler classes are defined in the core logging package. The other
handlers are defined in a sub- module, logging.handlers. (There is also another sub-module, logging.config,
for configuration functionality.)

Logged messages are formatted for presentation through instances of the Formatter class. They are initialized
with a format string suitable for use with the % operator and a dictionary.

For formatting multiple messages in a batch, instances of BufferingFormatter can be used. In addition to the
format string (which is applied to each message in the batch), there is provision for header and trailer
format strings.

When filtering based on logger level and/or handler level is not enough, instances of Filter can be added to
both Logger and Handler instances (through their addFilter() method). Before deciding to process a message
further, both loggers and handlers consult all their filters for permission. If any filter returns a false
value, the message is not processed further.

The basic Filter functionality allows filtering by specific logger name. If this feature is used, messages
sent to the named logger and its children are allowed through the filter, and all others dropped.

Exceptions raised during logging
The logging package is designed to swallow exceptions which occur while logging in production. This is so
that errors which occur while handling logging events - such as logging misconfiguration, network or other
similar errors - do not cause the application using logging to terminate prematurely.

SystemExit and KeyboardInterrupt exceptions are never swallowed. Other exceptions which occur during the emit
() method of a Handler subclass are passed to its handleError() method.

The default implementation of handleError() in Handler checks to see if a module-level variable, 
raiseExceptions, is set. If set, a traceback is printed to sys.stderr. If not set, the exception is
swallowed.

Note
The default value of raiseExceptions is True. This is because during development, you typically want to be
notified of any exceptions that occur. It’s advised that you set raiseExceptions to False for production
usage.

Using arbitrary objects as messages

In the preceding sections and examples, it has been assumed that the message passed when logging the event is
a string. However, this is not the only possibility. You can pass an arbitrary object as a message, and its
__str__() method will be called when the logging system needs to convert it to a string representation. In
fact, if you want to, you can avoid computing a string representation altogether - for example, the
SocketHandler emits an event by pickling it and sending it over the wire.

Optimization
Formatting of message arguments is deferred until it cannot be avoided. However, computing the arguments
passed to the logging method can also be expensive, and you may want to avoid doing it if the logger will
just throw away your event. To decide what to do, you can call the isEnabledFor() method which takes a level
argument and returns true if the event would be created by the Logger for that level of call. You can write
code like this:

if logger.isEnabledFor(logging.DEBUG):
    logger.debug('Message with %s, %s', expensive_func1(),
                                        expensive_func2())

so that if the logger’s threshold is set above DEBUG, the calls to expensive_func1() and expensive_func2()
are never made.

Note
In some cases, isEnabledFor() can itself be more expensive than you’d like (e.g. for deeply nested loggers
where an explicit level is only set high up in the logger hierarchy). In such cases (or if you want to avoid
calling a method in tight loops), you can cache the result of a call to isEnabledFor() in a local or instance
variable, and use that instead of calling the method each time. Such a cached value would only need to be
recomputed when the logging configuration changes dynamically while the application is running (which is not
all that common).

There are other optimizations which can be made for specific applications which need more precise control
over what logging information is collected. Here’s a list of things you can do to avoid processing during
logging which you don’t need:

┌─────────────────────┬─────────────────────────────────────────────────────────────────────────────────────┐
│ What you don’t want │                             How to avoid collecting it                              │
│     to collect      │                                                                                     │
├─────────────────────┼─────────────────────────────────────────────────────────────────────────────────────┤
│Information about    │Set logging._srcfile to None. This avoids calling sys._getframe(), which may help to │
│where calls were made│speed up your code in environments like PyPy (which can’t speed up code that uses    │
│from.                │sys._getframe()), if and when PyPy supports Python 3.x.                              │
├─────────────────────┼─────────────────────────────────────────────────────────────────────────────────────┤
│Threading            │Set logging.logThreads to 0.                                                         │
│information.         │                                                                                     │
├─────────────────────┼─────────────────────────────────────────────────────────────────────────────────────┤
│Process information. │Set logging.logProcesses to 0.                                                       │
└─────────────────────┴─────────────────────────────────────────────────────────────────────────────────────┘

Also note that the core logging module only includes the basic handlers. If you don’t import logging.handlers
and logging.config, they won’t take up any memory.


==============================================================================================================
https://docs.python.org/3/library/logging.html#logrecord-attributes

16.6. logging — Logging facility for Python

Source code: Lib/logging/__init__.py

Important
This page contains the API reference information. For tutorial information and
discussion of more advanced topics, see

  - Basic Tutorial
  - Advanced Tutorial
  - Logging Cookbook

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

This module defines functions and classes which implement a flexible event
logging system for applications and libraries.

The key benefit of having the logging API provided by a standard library module
is that all Python modules can participate in logging, so your application log
can include your own messages integrated with messages from third-party
modules.

The module provides a lot of functionality and flexibility. If you are
unfamiliar with logging, the best way to get to grips with it is to see the
tutorials (see the links on the right).

The basic classes defined by the module, together with their functions, are
listed below.

  - Loggers expose the interface that application code directly uses.
  - Handlers send the log records (created by loggers) to the appropriate
    destination.
  - Filters provide a finer grained facility for determining which log records
    to output.
  - Formatters specify the layout of log records in the final output.

16.6.1. Logger Objects
Loggers have the following attributes and methods. Note that Loggers are never
instantiated directly, but always through the module-level function 
logging.getLogger(name). Multiple calls to getLogger() with the same name will
always return a reference to the same Logger object.

The name is potentially a period-separated hierarchical value, like foo.bar.baz
(though it could also be just plain foo, for example). Loggers that are further
down in the hierarchical list are children of loggers higher up in the list.
For example, given a logger with a name of foo, loggers with names of foo.bar, 
foo.bar.baz, and foo.bam are all descendants of foo. The logger name hierarchy
is analogous to the Python package hierarchy, and identical to it if you
organise your loggers on a per-module basis using the recommended construction 
logging.getLogger(__name__). That’s because in a module, __name__ is the
module’s name in the Python package namespace.

class logging.Logger
    propagate

        If this attribute evaluates to true, events logged to this logger will
        be passed to the handlers of higher level (ancestor) loggers, in
        addition to any handlers attached to this logger. Messages are passed
        directly to the ancestor loggers’ handlers - neither the level nor
        filters of the ancestor loggers in question are considered.

        If this evaluates to false, logging messages are not passed to the
        handlers of ancestor loggers.

        The constructor sets this attribute to True.

        Note
        If you attach a handler to a logger and one or more of its ancestors,
        it may emit the same record multiple times. In general, you should not
        need to attach a handler to more than one logger - if you just attach
        it to the appropriate logger which is highest in the logger hierarchy,
        then it will see all events logged by all descendant loggers, provided
        that their propagate setting is left set to True. A common scenario is
        to attach handlers only to the root logger, and to let propagation take
        care of the rest.

    setLevel(level)
        Sets the threshold for this logger to level. Logging messages which are
        less severe than level will be ignored; logging messages which have
        severity level or higher will be emitted by whichever handler or
        handlers service this logger, unless a handler’s level has been set to
        a higher severity level than level.

        When a logger is created, the level is set to NOTSET (which causes all
        messages to be processed when the logger is the root logger, or
        delegation to the parent when the logger is a non-root logger). Note
        that the root logger is created with level WARNING.

        The term ‘delegation to the parent’ means that if a logger has a level
        of NOTSET, its chain of ancestor loggers is traversed until either an
        ancestor with a level other than NOTSET is found, or the root is
        reached.

        If an ancestor is found with a level other than NOTSET, then that
        ancestor’s level is treated as the effective level of the logger where
        the ancestor search began, and is used to determine how a logging event
        is handled.

        If the root is reached, and it has a level of NOTSET, then all messages
        will be processed. Otherwise, the root’s level will be used as the
        effective level.

        See Logging Levels for a list of levels.

        Changed in version 3.2: The level parameter now accepts a string
        representation of the level such as ‘INFO’ as an alternative to the
        integer constants such as INFO. Note, however, that levels are
        internally stored as integers, and methods such as e.g.
        getEffectiveLevel() and isEnabledFor() will return/expect to be passed
        integers.

    isEnabledFor(lvl)
        Indicates if a message of severity lvl would be processed by this
        logger. This method checks first the module-level level set by 
        logging.disable(lvl) and then the logger’s effective level as
        determined by getEffectiveLevel().

    getEffectiveLevel()
        Indicates the effective level for this logger. If a value other than 
        NOTSET has been set using setLevel(), it is returned. Otherwise, the
        hierarchy is traversed towards the root until a value other than NOTSET
        is found, and that value is returned. The value returned is an integer,
        typically one of logging.DEBUG, logging.INFO etc.

    getChild(suffix)
        Returns a logger which is a descendant to this logger, as determined by
        the suffix. Thus, logging.getLogger('abc').getChild('def.ghi') would
        return the same logger as would be returned by logging.getLogger
        ('abc.def.ghi'). This is a convenience method, useful when the parent
        logger is named using e.g. __name__ rather than a literal string.

        New in version 3.2.

    debug(msg, *args, **kwargs)
        Logs a message with level DEBUG on this logger. The msg is the message
        format string, and the args are the arguments which are merged into msg
        using the string formatting operator. (Note that this means that you
        can use keywords in the format string, together with a single
        dictionary argument.)

        There are three keyword arguments in kwargs which are inspected:
        exc_info, stack_info, and extra.

        If exc_info does not evaluate as false, it causes exception information
        to be added to the logging message. If an exception tuple (in the
        format returned by sys.exc_info()) or an exception instance is
        provided, it is used; otherwise, sys.exc_info() is called to get the
        exception information.

        The second optional keyword argument is stack_info, which defaults to 
        False. If true, stack information is added to the logging message,
        including the actual logging call. Note that this is not the same stack
        information as that displayed through specifying exc_info: The former
        is stack frames from the bottom of the stack up to the logging call in
        the current thread, whereas the latter is information about stack
        frames which have been unwound, following an exception, while searching
        for exception handlers.

        You can specify stack_info independently of exc_info, e.g. to just show
        how you got to a certain point in your code, even when no exceptions
        were raised. The stack frames are printed following a header line which
        says:

        Stack (most recent call last):

        This mimics the Traceback (most recent call last): which is used when
        displaying exception frames.

        The third keyword argument is extra which can be used to pass a
        dictionary which is used to populate the __dict__ of the LogRecord
        created for the logging event with user-defined attributes. These
        custom attributes can then be used as you like. For example, they could
        be incorporated into logged messages. For example:

        FORMAT = '%(asctime)-15s %(clientip)s %(user)-8s %(message)s'
        logging.basicConfig(format=FORMAT)
        d = {'clientip': '192.168.0.1', 'user': 'fbloggs'}
        logger = logging.getLogger('tcpserver')
        logger.warning('Protocol problem: %s', 'connection reset', extra=d)

        would print something like

        2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset

        The keys in the dictionary passed in extra should not clash with the
        keys used by the logging system. (See the Formatter documentation for
        more information on which keys are used by the logging system.)

        If you choose to use these attributes in logged messages, you need to
        exercise some care. In the above example, for instance, the Formatter
        has been set up with a format string which expects ‘clientip’ and
        ‘user’ in the attribute dictionary of the LogRecord. If these are
        missing, the message will not be logged because a string formatting
        exception will occur. So in this case, you always need to pass the
        extra dictionary with these keys.

        While this might be annoying, this feature is intended for use in
        specialized circumstances, such as multi-threaded servers where the
        same code executes in many contexts, and interesting conditions which
        arise are dependent on this context (such as remote client IP address
        and authenticated user name, in the above example). In such
        circumstances, it is likely that specialized Formatters would be used
        with particular Handlers.

        New in version 3.2: The stack_info parameter was added.

        Changed in version 3.5: The exc_info parameter can now accept exception
        instances.

    info(msg, *args, **kwargs)
        Logs a message with level INFO on this logger. The arguments are
        interpreted as for debug().

    warning(msg, *args, **kwargs)
        Logs a message with level WARNING on this logger. The arguments are
        interpreted as for debug().

        Note
        There is an obsolete method warn which is functionally identical to 
        warning. As warn is deprecated, please do not use it - use warning
        instead.

    error(msg, *args, **kwargs)
        Logs a message with level ERROR on this logger. The arguments are
        interpreted as for debug().

    critical(msg, *args, **kwargs)
        Logs a message with level CRITICAL on this logger. The arguments are
        interpreted as for debug().

    log(lvl, msg, *args, **kwargs)
        Logs a message with integer level lvl on this logger. The other
        arguments are interpreted as for debug().

    exception(msg, *args, **kwargs)
        Logs a message with level ERROR on this logger. The arguments are
        interpreted as for debug(). Exception info is added to the logging
        message. This method should only be called from an exception handler.

    addFilter(filter)
        Adds the specified filter filter to this logger.

    removeFilter(filter)
        Removes the specified filter filter from this logger.

    filter(record)
        Applies this logger’s filters to the record and returns a true value if
        the record is to be processed. The filters are consulted in turn, until
        one of them returns a false value. If none of them return a false
        value, the record will be processed (passed to handlers). If one
        returns a false value, no further processing of the record occurs.

    addHandler(hdlr)
        Adds the specified handler hdlr to this logger.

    removeHandler(hdlr)
        Removes the specified handler hdlr from this logger.

    findCaller(stack_info=False)
        Finds the caller’s source filename and line number. Returns the
        filename, line number, function name and stack information as a
        4-element tuple. The stack information is returned as None unless
        stack_info is True.

    handle(record)
        Handles a record by passing it to all handlers associated with this
        logger and its ancestors (until a false value of propagate is found).
        This method is used for unpickled records received from a socket, as
        well as those created locally. Logger-level filtering is applied using
        filter().

    makeRecord(name, lvl, fn, lno, msg, args, exc_info, func=None, extra=None, 
        sinfo=None)

        This is a factory method which can be overridden in subclasses to
        create specialized LogRecord instances.

    hasHandlers()
        Checks to see if this logger has any handlers configured. This is done
        by looking for handlers in this logger and its parents in the logger
        hierarchy. Returns True if a handler was found, else False. The method
        stops searching up the hierarchy whenever a logger with the ‘propagate’
        attribute set to false is found - that will be the last logger which is
        checked for the existence of handlers.

        New in version 3.2.

    Changed in version 3.7: Loggers can now be pickled and unpickled.

16.6.2. Logging Levels
The numeric values of logging levels are given in the following table. These
are primarily of interest if you want to define your own levels, and need them
to have specific values relative to the predefined levels. If you define a
level with the same numeric value, it overwrites the predefined value; the
predefined name is lost.

┌────────┬──────────────┐
│ Level  │Numeric value │
├────────┼──────────────┤
│CRITICAL│50            │
├────────┼──────────────┤
│ERROR   │40            │
├────────┼──────────────┤
│WARNING │30            │
├────────┼──────────────┤
│INFO    │20            │
├────────┼──────────────┤
│DEBUG   │10            │
├────────┼──────────────┤
│NOTSET  │0             │
└────────┴──────────────┘

16.6.3. Handler Objects
Handlers have the following attributes and methods. Note that Handler is never
instantiated directly; this class acts as a base for more useful subclasses.
However, the __init__() method in subclasses needs to call Handler.__init__().

class logging.Handler

    __init__(level=NOTSET)
        Initializes the Handler instance by setting its level, setting the list
        of filters to the empty list and creating a lock (using createLock())
        for serializing access to an I/O mechanism.

    createLock()
        Initializes a thread lock which can be used to serialize access to
        underlying I/O functionality which may not be threadsafe.

    acquire()
        Acquires the thread lock created with createLock().

    release()
        Releases the thread lock acquired with acquire().

    setLevel(level)
        Sets the threshold for this handler to level. Logging messages which
        are less severe than level will be ignored. When a handler is created,
        the level is set to NOTSET (which causes all messages to be processed).

        See Logging Levels for a list of levels.

        Changed in version 3.2: The level parameter now accepts a string
        representation of the level such as ‘INFO’ as an alternative to the
        integer constants such as INFO.

    setFormatter(fmt)
        Sets the Formatter for this handler to fmt.

    addFilter(filter)
        Adds the specified filter filter to this handler.

    removeFilter(filter)
        Removes the specified filter filter from this handler.

    filter(record)
        Applies this handler’s filters to the record and returns a true value
        if the record is to be processed. The filters are consulted in turn,
        until one of them returns a false value. If none of them return a false
        value, the record will be emitted. If one returns a false value, the
        handler will not emit the record.

    flush()
        Ensure all logging output has been flushed. This version does nothing
        and is intended to be implemented by subclasses.

    close()
        Tidy up any resources used by the handler. This version does no output
        but removes the handler from an internal list of handlers which is
        closed when shutdown() is called. Subclasses should ensure that this
        gets called from overridden close() methods.

    handle(record)
        Conditionally emits the specified logging record, depending on filters
        which may have been added to the handler. Wraps the actual emission of
        the record with acquisition/release of the I/O thread lock.

    handleError(record)
        This method should be called from handlers when an exception is
        encountered during an emit() call. If the module-level attribute 
        raiseExceptions is False, exceptions get silently ignored. This is what
        is mostly wanted for a logging system - most users will not care about
        errors in the logging system, they are more interested in application
        errors. You could, however, replace this with a custom handler if you
        wish. The specified record is the one which was being processed when
        the exception occurred. (The default value of raiseExceptions is True,
        as that is more useful during development).

    format(record)
        Do formatting for a record - if a formatter is set, use it. Otherwise,
        use the default formatter for the module.

    emit(record)
        Do whatever it takes to actually log the specified logging record. This
        version is intended to be implemented by subclasses and so raises a
        NotImplementedError.

For a list of handlers included as standard, see logging.handlers.

16.6.4. Formatter Objects
Formatter objects have the following attributes and methods. They are
responsible for converting a LogRecord to (usually) a string which can be
interpreted by either a human or an external system. The base Formatter allows
a formatting string to be specified. If none is supplied, the default value of 
'%(message)s' is used, which just includes the message in the logging call. To
have additional items of information in the formatted output (such as a
timestamp), keep reading.

A Formatter can be initialized with a format string which makes use of
knowledge of the LogRecord attributes - such as the default value mentioned
above making use of the fact that the user’s message and arguments are
pre-formatted into a LogRecord’s message attribute. This format string contains
standard Python %-style mapping keys. See section printf-style String
Formatting for more information on string formatting.

The useful mapping keys in a LogRecord are given in the section on LogRecord
attributes.

class logging.Formatter(fmt=None, datefmt=None, style='%')

    Returns a new instance of the Formatter class. The instance is initialized
    with a format string for the message as a whole, as well as a format string
    for the date/time portion of a message. If no fmt is specified, '%(message)
    s' is used. If no datefmt is specified, a format is used which is described
    in the formatTime() documentation.

    The style parameter can be one of ‘%’, ‘{‘ or ‘$’ and determines how the
    format string will be merged with its data: using one of %-formatting,
    str.format() or string.Template. See Using particular formatting styles
    throughout your application for more information on using {- and
    $-formatting for log messages.

    Changed in version 3.2: The style parameter was added.

    format(record)
        The record’s attribute dictionary is used as the operand to a string
        formatting operation. Returns the resulting string. Before formatting
        the dictionary, a couple of preparatory steps are carried out. The
        message attribute of the record is computed using msg % args. If the
        formatting string contains '(asctime)', formatTime() is called to
        format the event time. If there is exception information, it is
        formatted using formatException() and appended to the message. Note
        that the formatted exception information is cached in attribute
        exc_text. This is useful because the exception information can be
        pickled and sent across the wire, but you should be careful if you have
        more than one Formatter subclass which customizes the formatting of
        exception information. In this case, you will have to clear the cached
        value after a formatter has done its formatting, so that the next
        formatter to handle the event doesn’t use the cached value but
        recalculates it afresh.

        If stack information is available, it’s appended after the exception
        information, using formatStack() to transform it if necessary.

    formatTime(record, datefmt=None)
        This method should be called from format() by a formatter which wants
        to make use of a formatted time. This method can be overridden in
        formatters to provide for any specific requirement, but the basic
        behavior is as follows: if datefmt (a string) is specified, it is used
        with time.strftime() to format the creation time of the record.
        Otherwise, the format ‘%Y-%m-%d %H:%M:%S,uuu’ is used, where the uuu
        part is a millisecond value and the other letters are as per the
        time.strftime() documentation. An example time in this format is 
        2003-01-23 00:29:50,411. The resulting string is returned.

        This function uses a user-configurable function to convert the creation
        time to a tuple. By default, time.localtime() is used; to change this
        for a particular formatter instance, set the converter attribute to a
        function with the same signature as time.localtime() or time.gmtime().
        To change it for all formatters, for example if you want all logging
        times to be shown in GMT, set the converter attribute in the Formatter
        class.

        Changed in version 3.3: Previously, the default format was hard-coded
        as in this example: 2010-09-06 22:38:15,292 where the part before the
        comma is handled by a strptime format string ('%Y-%m-%d %H:%M:%S'), and
        the part after the comma is a millisecond value. Because strptime does
        not have a format placeholder for milliseconds, the millisecond value
        is appended using another format string, '%s,%03d' — and both of these
        format strings have been hardcoded into this method. With the change,
        these strings are defined as class-level attributes which can be
        overridden at the instance level when desired. The names of the
        attributes are default_time_format (for the strptime format string) and
        default_msec_format (for appending the millisecond value).

    formatException(exc_info)
        Formats the specified exception information (a standard exception tuple
        as returned by sys.exc_info()) as a string. This default implementation
        just uses traceback.print_exception(). The resulting string is
        returned.

    formatStack(stack_info)
        Formats the specified stack information (a string as returned by
        traceback.print_stack(), but with the last newline removed) as a
        string. This default implementation just returns the input value.

16.6.5. Filter Objects
Filters can be used by Handlers and Loggers for more sophisticated filtering
than is provided by levels. The base filter class only allows events which are
below a certain point in the logger hierarchy. For example, a filter
initialized with ‘A.B’ will allow events logged by loggers ‘A.B’, ‘A.B.C’,
‘A.B.C.D’, ‘A.B.D’ etc. but not ‘A.BB’, ‘B.A.B’ etc. If initialized with the
empty string, all events are passed.

class logging.Filter(name='')

    Returns an instance of the Filter class. If name is specified, it names a
    logger which, together with its children, will have its events allowed
    through the filter. If name is the empty string, allows every event.

    filter(record)

        Is the specified record to be logged? Returns zero for no, nonzero for
        yes. If deemed appropriate, the record may be modified in-place by this
        method.

Note that filters attached to handlers are consulted before an event is emitted
by the handler, whereas filters attached to loggers are consulted whenever an
event is logged (using debug(), info(), etc.), before sending an event to
handlers. This means that events which have been generated by descendant
loggers will not be filtered by a logger’s filter setting, unless the filter
has also been applied to those descendant loggers.

You don’t actually need to subclass Filter: you can pass any instance which has
a filter method with the same semantics.

Changed in version 3.2: You don’t need to create specialized Filter classes, or
use other classes with a filter method: you can use a function (or other
callable) as a filter. The filtering logic will check to see if the filter
object has a filter attribute: if it does, it’s assumed to be a Filter and its
filter() method is called. Otherwise, it’s assumed to be a callable and called
with the record as the single parameter. The returned value should conform to
that returned by filter().

Although filters are used primarily to filter records based on more
sophisticated criteria than levels, they get to see every record which is
processed by the handler or logger they’re attached to: this can be useful if
you want to do things like counting how many records were processed by a
particular logger or handler, or adding, changing or removing attributes in the
LogRecord being processed. Obviously changing the LogRecord needs to be done
with some care, but it does allow the injection of contextual information into
logs (see Using Filters to impart contextual information).

16.6.6. LogRecord Objects
LogRecord instances are created automatically by the Logger every time
something is logged, and can be created manually via makeLogRecord() (for
example, from a pickled event received over the wire).

class logging.LogRecord(name, level, pathname, lineno, msg, args, exc_info, 
    func=None, sinfo=None)

    Contains all the information pertinent to the event being logged.

    The primary information is passed in msg and args, which are combined using
    msg % args to create the message field of the record.
                  - name – The name of the logger used to log the event
                    represented by this LogRecord. Note that this name will
                    always have this value, even though it may be emitted by a
                    handler attached to a different (ancestor) logger.
                  - level – The numeric level of the logging event (one of
                    DEBUG, INFO etc.) Note that this is converted to two
                    attributes of the LogRecord: levelno for the numeric value
                    and levelname for the corresponding level name.
                  - pathname – The full pathname of the source file where the
                    logging call was made.
                  - lineno – The line number in the source file where the
    Parameters:     logging call was made.
                  - msg – The event description message, possibly a format
                    string with placeholders for variable data.
                  - args – Variable data to merge into the msg argument to
                    obtain the event description.
                  - exc_info – An exception tuple with the current exception
                    information, or None if no exception information is
                    available.
                  - func – The name of the function or method from which the
                    logging call was invoked.
                  - sinfo – A text string representing stack information from
                    the base of the stack in the current thread, up to the
                    logging call.

    getMessage()
        Returns the message for this LogRecord instance after merging any
        user-supplied arguments with the message. If the user-supplied message
        argument to the logging call is not a string, str() is called on it to
        convert it to a string. This allows use of user-defined classes as
        messages, whose __str__ method can return the actual format string to
        be used.

    Changed in version 3.2: The creation of a LogRecord has been made more
    configurable by providing a factory which is used to create the record. The
    factory can be set using getLogRecordFactory() and setLogRecordFactory()
    (see this for the factory’s signature).

    This functionality can be used to inject your own values into a LogRecord
    at creation time. You can use the following pattern:

    old_factory = logging.getLogRecordFactory()

    def record_factory(*args, **kwargs):
        record = old_factory(*args, **kwargs)
        record.custom_attribute = 0xdecafbad
        return record

    logging.setLogRecordFactory(record_factory)

    With this pattern, multiple factories could be chained, and as long as they
    don’t overwrite each other’s attributes or unintentionally overwrite the
    standard attributes listed above, there should be no surprises.

16.6.7. LogRecord attributes
The LogRecord has a number of attributes, most of which are derived from the
parameters to the constructor. (Note that the names do not always correspond
exactly between the LogRecord constructor parameters and the LogRecord
attributes.) These attributes can be used to merge data from the record into
the format string. The following table lists (in alphabetical order) the
attribute names, their meanings and the corresponding placeholder in a %-style
format string.

If you are using {}-formatting (str.format()), you can use {attrname} as the
placeholder in the format string. If you are using $-formatting (
string.Template), use the form ${attrname}. In both cases, of course, replace 
attrname with the actual attribute name you want to use.

In the case of {}-formatting, you can specify formatting flags by placing them
after the attribute name, separated from it with a colon. For example: a
placeholder of {msecs:03d} would format a millisecond value of 4 as 004. Refer
to the str.format() documentation for full details on the options available to
you.

┌───────────────┬─────────────────┬───────────────────────────────────────────┐
│Attribute name │     Format      │                Description                │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│               │You shouldn’t    │The tuple of arguments merged into msg to  │
│args           │need to format   │produce message, or a dict whose values are│
│               │this yourself.   │used for the merge (when there is only one │
│               │                 │argument, and it is a dictionary).         │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│               │                 │Human-readable time when the LogRecord was │
│               │                 │created. By default this is of the form    │
│asctime        │%(asctime)s      │‘2003-07-08 16:49:45,896’ (the numbers     │
│               │                 │after the comma are millisecond portion of │
│               │                 │the time).                                 │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│created        │%(created)f      │Time when the LogRecord was created (as    │
│               │                 │returned by time.time()).                  │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│               │You shouldn’t    │Exception tuple (à la sys.exc_info) or, if │
│exc_info       │need to format   │no exception has occurred, None.           │
│               │this yourself.   │                                           │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│filename       │%(filename)s     │Filename portion of pathname.              │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│funcName       │%(funcName)s     │Name of function containing the logging    │
│               │                 │call.                                      │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│levelname      │%(levelname)s    │Text logging level for the message ('DEBUG'│
│               │                 │, 'INFO', 'WARNING', 'ERROR', 'CRITICAL'). │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│levelno        │%(levelno)s      │Numeric logging level for the message (    │
│               │                 │DEBUG, INFO, WARNING, ERROR, CRITICAL).    │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│lineno         │%(lineno)d       │Source line number where the logging call  │
│               │                 │was issued (if available).                 │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│               │                 │The logged message, computed as msg % args.│
│message        │%(message)s      │This is set when Formatter.format() is     │
│               │                 │invoked.                                   │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│module         │%(module)s       │Module (name portion of filename).         │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│msecs          │%(msecs)d        │Millisecond portion of the time when the   │
│               │                 │LogRecord was created.                     │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│               │You shouldn’t    │The format string passed in the original   │
│msg            │need to format   │logging call. Merged with args to produce  │
│               │this yourself.   │message, or an arbitrary object (see Using │
│               │                 │arbitrary objects as messages).            │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│name           │%(name)s         │Name of the logger used to log the call.   │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│pathname       │%(pathname)s     │Full pathname of the source file where the │
│               │                 │logging call was issued (if available).    │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│process        │%(process)d      │Process ID (if available).                 │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│processName    │%(processName)s  │Process name (if available).               │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│               │%                │Time in milliseconds when the LogRecord was│
│relativeCreated│(relativeCreated)│created, relative to the time the logging  │
│               │d                │module was loaded.                         │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│               │                 │Stack frame information (where available)  │
│               │You shouldn’t    │from the bottom of the stack in the current│
│stack_info     │need to format   │thread, up to and including the stack frame│
│               │this yourself.   │of the logging call which resulted in the  │
│               │                 │creation of this record.                   │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│thread         │%(thread)d       │Thread ID (if available).                  │
├───────────────┼─────────────────┼───────────────────────────────────────────┤
│threadName     │%(threadName)s   │Thread name (if available).                │
└───────────────┴─────────────────┴───────────────────────────────────────────┘

Changed in version 3.1: processName was added.

16.6.8. LoggerAdapter Objects
LoggerAdapter instances are used to conveniently pass contextual information
into logging calls. For a usage example, see the section on adding contextual
information to your logging output.

class logging.LoggerAdapter(logger, extra)
    Returns an instance of LoggerAdapter initialized with an underlying Logger
    instance and a dict-like object.

    process(msg, kwargs)
        Modifies the message and/or keyword arguments passed to a logging call
        in order to insert contextual information. This implementation takes
        the object passed as extra to the constructor and adds it to kwargs
        using key ‘extra’. The return value is a (msg, kwargs) tuple which has
        the (possibly modified) versions of the arguments passed in.

In addition to the above, LoggerAdapter supports the following methods of
Logger: debug(), info(), warning(), error(), exception(), critical(), log(),
isEnabledFor(), getEffectiveLevel(), setLevel() and hasHandlers(). These
methods have the same signatures as their counterparts in Logger, so you can
use the two types of instances interchangeably.

Changed in version 3.2: The isEnabledFor(), getEffectiveLevel(), setLevel() and
hasHandlers() methods were added to LoggerAdapter. These methods delegate to
the underlying logger.

16.6.9. Thread Safety
The logging module is intended to be thread-safe without any special work
needing to be done by its clients. It achieves this though using threading
locks; there is one lock to serialize access to the module’s shared data, and
each handler also creates a lock to serialize access to its underlying I/O.

If you are implementing asynchronous signal handlers using the signal module,
you may not be able to use logging from within such handlers. This is because
lock implementations in the threading module are not always re-entrant, and so
cannot be invoked from such signal handlers.

16.6.10. Module-Level Functions
In addition to the classes described above, there are a number of module- level
functions.

logging.getLogger(name=None)
    Return a logger with the specified name or, if name is None, return a
    logger which is the root logger of the hierarchy. If specified, the name is
    typically a dot-separated hierarchical name like ‘a’, ‘a.b’ or ‘a.b.c.d’.
    Choice of these names is entirely up to the developer who is using logging.

    All calls to this function with a given name return the same logger
    instance. This means that logger instances never need to be passed between
    different parts of an application.

logging.getLoggerClass()
    Return either the standard Logger class, or the last class passed to
    setLoggerClass(). This function may be called from within a new class
    definition, to ensure that installing a customized Logger class will not
    undo customizations already applied by other code. For example:

    class MyLogger(logging.getLoggerClass()):
        # ... override behaviour here

logging.getLogRecordFactory()
    Return a callable which is used to create a LogRecord.

    New in version 3.2: This function has been provided, along with
    setLogRecordFactory(), to allow developers more control over how the
    LogRecord representing a logging event is constructed.

    See setLogRecordFactory() for more information about the how the factory is
    called.

logging.debug(msg, *args, **kwargs)
    Logs a message with level DEBUG on the root logger. The msg is the message
    format string, and the args are the arguments which are merged into msg
    using the string formatting operator. (Note that this means that you can
    use keywords in the format string, together with a single dictionary
    argument.)

    There are three keyword arguments in kwargs which are inspected: exc_info
    which, if it does not evaluate as false, causes exception information to be
    added to the logging message. If an exception tuple (in the format returned
    by sys.exc_info()) is provided, it is used; otherwise, sys.exc_info() is
    called to get the exception information.

    The second optional keyword argument is stack_info, which defaults to False
    . If true, stack information is added to the logging message, including the
    actual logging call. Note that this is not the same stack information as
    that displayed through specifying exc_info: The former is stack frames from
    the bottom of the stack up to the logging call in the current thread,
    whereas the latter is information about stack frames which have been
    unwound, following an exception, while searching for exception handlers.

    You can specify stack_info independently of exc_info, e.g. to just show how
    you got to a certain point in your code, even when no exceptions were
    raised. The stack frames are printed following a header line which says:

    Stack (most recent call last):

    This mimics the Traceback (most recent call last): which is used when
    displaying exception frames.

    The third optional keyword argument is extra which can be used to pass a
    dictionary which is used to populate the __dict__ of the LogRecord created
    for the logging event with user-defined attributes. These custom attributes
    can then be used as you like. For example, they could be incorporated into
    logged messages. For example:

    FORMAT = '%(asctime)-15s %(clientip)s %(user)-8s %(message)s'
    logging.basicConfig(format=FORMAT)
    d = {'clientip': '192.168.0.1', 'user': 'fbloggs'}
    logging.warning('Protocol problem: %s', 'connection reset', extra=d)

    would print something like:

    2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset

    The keys in the dictionary passed in extra should not clash with the keys
    used by the logging system. (See the Formatter documentation for more
    information on which keys are used by the logging system.)

    If you choose to use these attributes in logged messages, you need to
    exercise some care. In the above example, for instance, the Formatter has
    been set up with a format string which expects ‘clientip’ and ‘user’ in the
    attribute dictionary of the LogRecord. If these are missing, the message
    will not be logged because a string formatting exception will occur. So in
    this case, you always need to pass the extra dictionary with these keys.

    While this might be annoying, this feature is intended for use in
    specialized circumstances, such as multi-threaded servers where the same
    code executes in many contexts, and interesting conditions which arise are
    dependent on this context (such as remote client IP address and
    authenticated user name, in the above example). In such circumstances, it
    is likely that specialized Formatters would be used with particular Handler
    s.

    New in version 3.2: The stack_info parameter was added.

logging.info(msg, *args, **kwargs)
    Logs a message with level INFO on the root logger. The arguments are
    interpreted as for debug().

logging.warning(msg, *args, **kwargs)
    Logs a message with level WARNING on the root logger. The arguments are
    interpreted as for debug().

    Note
    There is an obsolete function warn which is functionally identical to 
    warning. As warn is deprecated, please do not use it - use warning instead.

logging.error(msg, *args, **kwargs)
    Logs a message with level ERROR on the root logger. The arguments are
    interpreted as for debug().

logging.critical(msg, *args, **kwargs)
    Logs a message with level CRITICAL on the root logger. The arguments are
    interpreted as for debug().

logging.exception(msg, *args, **kwargs)
    Logs a message with level ERROR on the root logger. The arguments are
    interpreted as for debug(). Exception info is added to the logging message.
    This function should only be called from an exception handler.

logging.log(level, msg, *args, **kwargs)
    Logs a message with level level on the root logger. The other arguments are
    interpreted as for debug().

    Note
    The above module-level convenience functions, which delegate to the root
    logger, call basicConfig() to ensure that at least one handler is
    available. Because of this, they should not be used in threads, in versions
    of Python earlier than 2.7.1 and 3.2, unless at least one handler has been
    added to the root logger before the threads are started. In earlier
    versions of Python, due to a thread safety shortcoming in basicConfig(),
    this can (under rare circumstances) lead to handlers being added multiple
    times to the root logger, which can in turn lead to multiple messages for
    the same event.

logging.disable(lvl=CRITICAL)
    Provides an overriding level lvl for all loggers which takes precedence
    over the logger’s own level. When the need arises to temporarily throttle
    logging output down across the whole application, this function can be
    useful. Its effect is to disable all logging calls of severity lvl and
    below, so that if you call it with a value of INFO, then all INFO and DEBUG
    events would be discarded, whereas those of severity WARNING and above
    would be processed according to the logger’s effective level. If 
    logging.disable(logging.NOTSET) is called, it effectively removes this
    overriding level, so that logging output again depends on the effective
    levels of individual loggers.

    Note that if you have defined any custom logging level higher than CRITICAL
    (this is not recommended), you won’t be able to rely on the default value
    for the lvl parameter, but will have to explicitly supply a suitable value.

    Changed in version 3.7: The lvl parameter was defaulted to level CRITICAL.
    See Issue #28524 for more information about this change.

logging.addLevelName(lvl, levelName)
    Associates level lvl with text levelName in an internal dictionary, which
    is used to map numeric levels to a textual representation, for example when
    a Formatter formats a message. This function can also be used to define
    your own levels. The only constraints are that all levels used must be
    registered using this function, levels should be positive integers and they
    should increase in increasing order of severity.

    Note
    If you are thinking of defining your own levels, please see the section on
    Custom Levels.

logging.getLevelName(lvl)
    Returns the textual representation of logging level lvl. If the level is
    one of the predefined levels CRITICAL, ERROR, WARNING, INFO or DEBUG then
    you get the corresponding string. If you have associated levels with names
    using addLevelName() then the name you have associated with lvl is
    returned. If a numeric value corresponding to one of the defined levels is
    passed in, the corresponding string representation is returned. Otherwise,
    the string ‘Level %s’ % lvl is returned.

    Note
    Levels are internally integers (as they need to be compared in the logging
    logic). This function is used to convert between an integer level and the
    level name displayed in the formatted log output by means of the %
    (levelname)s format specifier (see LogRecord attributes).

    Changed in version 3.4: In Python versions earlier than 3.4, this function
    could also be passed a text level, and would return the corresponding
    numeric value of the level. This undocumented behaviour was considered a
    mistake, and was removed in Python 3.4, but reinstated in 3.4.2 due to
    retain backward compatibility.

logging.makeLogRecord(attrdict)

    Creates and returns a new LogRecord instance whose attributes are defined
    by attrdict. This function is useful for taking a pickled LogRecord
    attribute dictionary, sent over a socket, and reconstituting it as a
    LogRecord instance at the receiving end.

logging.basicConfig(**kwargs)
    Does basic configuration for the logging system by creating a StreamHandler
    with a default Formatter and adding it to the root logger. The functions
    debug(), info(), warning(), error() and critical() will call basicConfig()
    automatically if no handlers are defined for the root logger.

    This function does nothing if the root logger already has handlers
    configured for it.

    Note
    This function should be called from the main thread before other threads
    are started. In versions of Python prior to 2.7.1 and 3.2, if this function
    is called from multiple threads, it is possible (in rare circumstances)
    that a handler will be added to the root logger more than once, leading to
    unexpected results such as messages being duplicated in the log.

    The following keyword arguments are supported.

    ┌────────┬────────────────────────────────────────────────────────────────┐
    │ Format │                          Description                           │
    ├────────┼────────────────────────────────────────────────────────────────┤
    │filename│Specifies that a FileHandler be created, using the specified    │
    │        │filename, rather than a StreamHandler.                          │
    ├────────┼────────────────────────────────────────────────────────────────┤
    │filemode│If filename is specified, open the file in this mode. Defaults  │
    │        │to 'a'.                                                         │
    ├────────┼────────────────────────────────────────────────────────────────┤
    │format  │Use the specified format string for the handler.                │
    ├────────┼────────────────────────────────────────────────────────────────┤
    │datefmt │Use the specified date/time format, as accepted by time.strftime│
    │        │().                                                             │
    ├────────┼────────────────────────────────────────────────────────────────┤
    │        │If format is specified, use this style for the format string.   │
    │style   │One of '%', '{' or '$' for printf-style, str.format() or        │
    │        │string.Template respectively. Defaults to '%'.                  │
    ├────────┼────────────────────────────────────────────────────────────────┤
    │level   │Set the root logger level to the specified level.               │
    ├────────┼────────────────────────────────────────────────────────────────┤
    │        │Use the specified stream to initialize the StreamHandler. Note  │
    │stream  │that this argument is incompatible with filename - if both are  │
    │        │present, a ValueError is raised.                                │
    ├────────┼────────────────────────────────────────────────────────────────┤
    │        │If specified, this should be an iterable of already created     │
    │        │handlers to add to the root logger. Any handlers which don’t    │
    │handlers│already have a formatter set will be assigned the default       │
    │        │formatter created in this function. Note that this argument is  │
    │        │incompatible with filename or stream - if both are present, a   │
    │        │ValueError is raised.                                           │
    └────────┴────────────────────────────────────────────────────────────────┘

    Changed in version 3.2: The style argument was added.

    Changed in version 3.3: The handlers argument was added. Additional checks
    were added to catch situations where incompatible arguments are specified
    (e.g. handlers together with stream or filename, or stream together with
    filename).

logging.shutdown()
    Informs the logging system to perform an orderly shutdown by flushing and
    closing all handlers. This should be called at application exit and no
    further use of the logging system should be made after this call.

logging.setLoggerClass(klass)
    Tells the logging system to use the class klass when instantiating a
    logger. The class should define __init__() such that only a name argument
    is required, and the __init__() should call Logger.__init__(). This
    function is typically called before any loggers are instantiated by
    applications which need to use custom logger behavior.

logging.setLogRecordFactory(factory)
    Set a callable which is used to create a LogRecord.

    Parameters: factory – The factory callable to be used to instantiate a log
                record.

    New in version 3.2: This function has been provided, along with
    getLogRecordFactory(), to allow developers more control over how the
    LogRecord representing a logging event is constructed.

    The factory has the following signature:

    factory(name, level, fn, lno, msg, args, exc_info, func=None, sinfo=None, 
    **kwargs)

          name:   The logger name.
         level:   The logging level (numeric).
           fn:    The full pathname of the file where the logging call was
                  made.
          lno:    The line number in the file where the logging call was made.
          msg:    The logging message.
          args:   The arguments for the logging message.
        exc_info: An exception tuple, or None.
          func:   The name of the function or method which invoked the logging
                  call.
         sinfo:   A stack traceback such as is provided by
                  traceback.print_stack(), showing the call hierarchy.
         kwargs:  Additional keyword arguments.

16.6.11. Module-Level Attributes
logging.lastResort
    A “handler of last resort” is available through this attribute. This is a
    StreamHandler writing to sys.stderr with a level of WARNING, and is used to
    handle logging events in the absence of any logging configuration. The end
    result is to just print the message to sys.stderr. This replaces the
    earlier error message saying that “no handlers could be found for logger
    XYZ”. If you need the earlier behaviour for some reason, lastResort can be
    set to None.

    New in version 3.2.

16.6.12. Integration with the warnings module
The captureWarnings() function can be used to integrate logging with the
warnings module.

logging.captureWarnings(capture)
    This function is used to turn the capture of warnings by logging on and
    off.

    If capture is True, warnings issued by the warnings module will be
    redirected to the logging system. Specifically, a warning will be formatted
    using warnings.formatwarning() and the resulting string logged to a logger
    named 'py.warnings' with a severity of WARNING.

    If capture is False, the redirection of warnings to the logging system will
    stop, and warnings will be redirected to their original destinations (i.e.
    those in effect before captureWarnings(True) was called).
