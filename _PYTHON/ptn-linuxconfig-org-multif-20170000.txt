filename: /c/Users/gregor.redelonghi/Dropbox/ODPRTO/_TXT/python_linuxconfig-org-multif_20170000.txt
https://linuxconfig.org/python-files-and-the-interpreter

Python Files and the Interpreter
November 1, 2016

1. Introduction
Python is an interpreted language, meaning that it is compiled every time that it is run. There are a number
of pros and cons when talking about an interpreted language like this.

First, on a positive note, they tend to be easier to debug. They fail immediately when they are run, and tell
you what went wrong, which is nice compared to compiled languages like C/C++, which can compile just fine,
but fail silently when run.

Interpreted languages are also very portable. All you have to do is install the interpreter on a system, and
most code written in that language can run fine, regardless of the operating system. There are some
exceptions when dealing with operating system specific code and libraries, but if you've planned for
portability, you can work around those situations.

There is one major downside, though, and that's speed. Interpreted languages are slow, and compiling code
every time it's run is very inefficient. There's really not way around that fact, and that's the reason why
you will never find Python or any other interpreted language running low level operations or large resource
intense applications. That's okay. There are plenty of other places with Python shines.

Because Python is an interpreted language, there are two ways you can run it. First, you can write your code
in a file, and launch it from the command line after you're done. As an alternative, you can open up a real
time interpreter and code as you go. Now, the second option is great for learning, but couldn't possibly work
well for real world scenarios. The first option can be tough to get into when you're just starting, but it
allows you to go back and review something tangible. You can start out with either one, and this guide will
cover both to begin with.

2. Running Python
Whichever way you go, you need to be mindful of spaces. In Python, spaces are very important. The dictate
they entire structure of your code, and they must be consistent throughout your code. So, be sure that you
select something that you know that you're going to remember. Most Python programmers prefer to use four
spaces for indentation. It's probably a good idea to configure tabbing in your terminal or text editor to
match. It will save you a lot of headaches going forward.

2.1. Python File
The file extension for Python is .py. There isn't anything else special there, so you can create one by
opening it up in your favorite text editor or using touch.

	$ touch testing.py
///// OR //////
	$ vim testing.py
	$ chmod +x testing.py

Either way, when you open up your Python file, you should add a shebang line to specify your Python
interpreter. If your distribution needed a python3 package to install Python 3, be sure to specify that.
Otherwise, if your distribution uses Python 3 by default, you can just generally specify Python.
	#! /usr/bin/python3

2.2. Real Time Interpreter
Getting the real time interpreter running is somewhat easier than getting a Python file set up. To run the
Python interpreter, open up a terminal and run the command below.
	$ python3

Yes, Python provides its own command for the interpreter. If your distribution was one that used Python 3 by
default, just leave the "3" off the end of the command.

When the interpreter opens up, it will print some information in the terminal window and drop you into a
different prompt. It should look similar to to the lines below.
	Python 3.4.3 (default, Jul 16 2016, 20:19:21)
	[GCC 4.9.3] on linux
	Type "help", "copyright", "credits" or "license" for more information.
	>>>

As long as you're in the Python interpreter, you will see the >>> prompt.

When you're done with the interpreter, you can exit by pressing Ctrl+d or typing exit() and pressing Enter.

If you've been keeping up, you're now ready to start familiarizing yourself with Python and experimenting
with the language. Know that at some point, you are going to have to use both the interpreter and Python
files, so it's best to familiarize yourself with both.
     

---
https://linuxconfig.org/experimenting-with-numbers-and-text-in-python

Experimenting With Numbers and Text In Python
November 2, 2016

1. Introduction
You probably want to jump in and start coding right away. That's a great attitude to have, but it's much
better to experiment with the language and your programming environment first. If you've never programmed or
never worked with an interpreted language like Python before, it's important to get a feel for the way Python
works and start to develop a workflow. One great aspect of Python being interpreted is the ability to write a
couple of quick lines of code and test them out in real time. There really isn't much setup beyond what
you've already done.

2. Playing With Numbers
Without knowing anything about the language, you can use Python like a basic calculator. Open up either your
.py file or the interpreter. Type in a basic math problem and run it.
	>>> 10+25
	35

If you used a file, you're probably wondering what happened. That's one main difference between the methods
of running Python. The interpreter will display the value of commands that you entered, files won't. In the
interpreter, just type one number and hit Enter,
	>>> 15
	15

It's just the value of what you entered. So, what about files? Well, there's an easy way to handle that. You
just have to tell Python to print what you entered.
	print(10+25)

Now, when you run the file, it will correctly output 35. Don't worry too much about the parenthesis yet. They
will come into play later, but just know that whatever you put between them is what Python will output. Also,
in case you were wondering, print works in the interpreter too, and you will need it. The interpreter shows
that output as a convenience, but it doesn't actually mean anything. Using print is the "right" way to
display output.

You can continue to play around with numbers in Python and try to string together as complex of equations as
you'd like. Obviously, more complex math is going to require more some more help, and there are math
libraries available in Python for that, but that's something for a later time.
	print(5*10/25-3**3)

The more you practice, the better your understanding of how Python handles numbers will be. For a bit of a
challenge, divide numbers that do not divide evenly. You might notice something odd.

3. Playing With Letters
You can't do as much with text yet as you can with numbers, but you can do some. One thing remains the same
between text and numbers, if you're using a Python file, you're going to need to use print to show your
output. One quick difference to note is that text needs to be wrapped in quotes. In Python and just about any
programming language, text and individual letters need to be wrapped in quotes. So, try getting Python to
print out some text.
	>>> "Hello World!"
	'Hello World!'

If you're using a file:
	print("Hello World!")
	Hello World!
	
Did you notice the difference? Remember from the previous section that the interpreter just spits back out
the same thing that you entered. The single quotes from the interpreter example are a great demonstration of
this. Python didn't really process anything. In the print example the quotes are gone. That's because print
knows that you're interested in the words, not the quotes.

In Python you can add pieces of text together. Well, that's sort of true. The actual term is "string
concatenation," but you don't care about that right now. Try adding a couple of words together in print.
	print("Hello"+"World!")

Did you get what you expected? All text is literal. That's part of the reason for using quotes. Python has no
idea that those are two words and humans expect a space between them. That part's up to you. Try it again
with a space.
	print("Hello"+" World!")

That's better. Experiment some more with text, and see what you can do. Python allows you to do a ton of
interesting things with text, but this is just a small taste.


---
https://linuxconfig.org/python-variables

Python Variables
November 3, 2016


1. Introduction
Do you remember variables from math class in school? Variables in programming are actually very similar.
Variables are just symbols that that represent a value and that value can be changed; thus the name variable.
Unlike in math, variables in programming can be much more free form. Variables don't just have to be a
letter. Variables can be a single character, but they are more commonly a word or a short descriptive phrase
in lower case with words separated by underscores. It's actually best to name variables something descriptive
so the you and anyone else that you're working with knows exactly what that variable is, even much later on
in the code.

2. Types of Variables
Python is a dynamic duck typed language. Don't worry too much about the terminology, but that means that
Python doesn't force you to specify which types variables are when you create them. Oh yeah, there are types
of variables. Even though you don't necessarily have to specify their type when you create them, it's a good
idea to know what type you want them to be. Later on, having the wrong type of variable will invariably get
you into big trouble.

There are six major types of variables that you need to know about right now. Four of them are simple, or
primitive, variables. The other two are more complex and involve collections of data. There are integers,
which are whole numbers. Floats, or floating-point numbers, are numbers with decimals. Text is referred to as
a string. There are also booleans, which hold true or false values.

On the more complex side, there are tuples and lists(arrays in other languages), both of which hold
collections of information. Tuples hold groups of different types of information and cannot be changed. In
programming terms, the inability to change tuples means that they are immutable. Lists, in contrast, hold
groups of the same type of date and can be changed at any time.

3. Assigning Variables
To assign a value to variables and create them, just tell Python what they are equal to. For example, if you
wanted to create a variable called say_hello that is a string and holds the phase, "Hello World!" take a look
at the example below.
	say_hello = "Hello World!"

If you're working with numbers, it's nearly the same thing. Just set the variable name equal to whatever
number you want.
	this_integer = 5
	this_float = 5.5

When dealing with numbers, you can even set a variable equal to an equation, and the variable will equal the
solution.
	the_answer = 6 * 7

Now, check out the values of some variables by printing them out. You can give print the name of a variable,
and it will give you back the value.
	print(the_answer)

You can change the values of variables just as easily. All you need to do is set them equal to something
else. Try it out, and print the values in between.
	a = 5
	print(a)
	a = 10
	print(a)

See? It just changes. The same is (sort of) true for strings. They are technically immutable, like tuples, so
you're not actually modifying the existing value. You're pointing the variable at a new one. That really
isn't some thing to worry about right now, though.
	a_string = "Hello!"
	print(a_string)
	a_string = "Goodbye!"
	print(a_string)

It still works the way you'd expect. Later on in more advanced use, you'll want to keep the immutability of
strings in mind.

4. Comparing Variables
Python also gives you the ability to compare the values of variables and gives you a value of either true or
false depending on the comparison. Comparing variables is a very important concept in programming, and will
come into play quite a lot later on. Thankfully, Python uses the symbols for comparison from math to handle
comparing variables.

The first thing that you'd probably want to check is whether or not two variables are equal to one another.
So, you do that with two equal signs next to each other, like this; ==. There are two instead on one to
differentiate checking equality for assigning value.
	a = 6
	b = 2 * 3
	print(a == b)

It printed out "True" because three times two does equal six. You can compare strings too. Python will just
check that the text in the strings is the same.
	a_string = "Hello"
	another_string = "Hello"
	print(a_string == another_string)

Again, it came back "True" because they were the same. If you change one, the results will be different.
	a_string = "Hello"
	another_string = "Hello!"
	print(a_string == another_string)

Now it's "False" because another_string has an exclamation point. Again, Python and other programming
languages are very literal. They don't care that it means the same thing because it is not literally exactly
the same.

There are other ways to compare variables or values, like; >, <, >=, <=, and !=. You've probably seen all of
those before, except maybe the last one. So, the first few are greater than, less than, greater than or equal
to, and less than or equal to. The last one that you may not have seen is "not equal." Here are a few
examples:
	>>> 5 > 7
	False
	>>> 7 > 5
	True
	>>> 5 * 2 >= 11
	False
	>>> 6 * 2 >= 11
	True
	>>> 6 * 2 >= 12
	True
	>>> 6 * 2 <= 13
	True
	>>> "Hello" != "Hello!"
	True

The >(greater than) and the <(less than) just compare two values directly. If the two values are equal to one
another, the comparison will return "False," since two equal values are neither greater than or less than one
another.

The >=(greater than or equal to) and the <=(less than or equal to) do nearly the same thing, but they will
evaluate to "True," if the values are equal.

!= is the exact opposite of ==. It will only evaluate to "True" when the two values are not equal to each
other.

5. Closing
There is a lot more that can be done with variables. Play around with what you've done here. There are tons
of possibilities with comparison operators. You can see how complex of statements you can make. The upcoming
guides will explore each type of variable much greater depth and get you familiar with the capabilities of
each.


---
https://linuxconfig.org/working-with-number-variables-in-python

Working With Number Variables In Python
November 4, 2016

1. Introduction
Obviously working with numbers in programming is important. Python as excellent mathematical capabilities,
and there are tons of additional libraries available to extend Python's built in functionality for even the
most advanced calculations. Of course, the basics are important too, and numbers and some basic calculations
come into play when controlling the flow of programs and making selections. That's why knowing your way
around working with numbers in Python is especially important.

As previously stated in the last guide, there are two basic types of number variables that you will
encounter. Whole numbers, or , and numbers with decimals, or floats.

2. Integers
Since you don't specify variable types when you create them in Python, it will just assume that it is working
only with integers unless a decimal point is present. This works well most of the time, and provides clean
output. There's one pretty obvious exception. Take a look at this division problem.
	>>> 10/5
	2.0

Notice how there's a decimal point even though the problem divides evenly? The integers were converted into a
float. In Python 2 and many other programming languages, the language would ignore anything after the last
whole number. Check out this Python 2 example.
	>>> 15 / 4
	3

Python 2 just drops everything after the last whole number. It's pretty easy to make mistakes this way.
That's way Python 3 decided that every time division was performed, it would automatically convert to float.

3. Floats
Any number with a decimal place is considered a float in Python. Since Python assumes that any number is
going to be an integer unless there's a decimal place present, you have to add a decimal place, if you want
to tell Python that you're working with a float.
	>>> 20 + 10.5
	30.5

Even if there is only one decimal place present, Python will convert the output to a float to ensure that the
results are kept as accurate as possible. Generally speaking, if you aren't sure that your calculations are
going to result in whole numbers, throw a decimal place in to ensure that you receive accurate results.

4. Math
Python supports all of the basic math operations without adding anything. In the previous guides, you've used
many of them. The table below provides a breakdown of each one.

Math Operators
+              Addition
-              Subtraction
*              Multiplication
/              Division
**             Exponents

You've already tried using some of them, but try some more. String together as many as you can. Python's math
operators follow the same order of operations as regular mathematics. That includes the use of parenthesis.
	>>> 25 * 3 / (5 ** 2 - 20)
	15.0

You can see a couple of things going on there, one of which is the conversion from an integer to a float
during division. The parenthesis also come into play to force order of operations. Look what happens when
they are removed.
	>>> 25 * 3 / 5 ** 2 - 20
	-17.0

Since it's not possible to type a numerator above a denominator, Python must be told that the -20 is part of
the denominator. Otherwise, it just prioritizes the subtraction after the exponent, multiplication and
division.

4.1. Changing Variable Values
Instances are going to arise when you want to modify the value of a variable mathematically. In fact, its a
very important thing to be able to do. The most straightforward way to go about this is to set the variable
equal to itself being modified by an expression.
	a = a + 5

Python will recall the current value of a and add five to it. Then, it will reassign the newly computed value
to a. This will work with other mathematical operations as well.
	a = (a ** 2) / 5

You can even throw in the values of other variables as well.
	a = 2
	b = 5
	a = (a ** a) / b

You can have an entire expression made up only of variables, as long as they have been assigned values.

Most of the time, you'll only be performing a single operation to modify a variable. Using an entire
expression like the example above tends to be a rarer occurrence. Since writing a = a + 1 is tends to be both
redundant and tedious, Python gives you a shortened way. Instead of writing, a = a + 1, you can write a += 1.
These shorthand assignment operators exist for all of the other basic math operations as well.
	a += 1
	a -= 5
	a *= 3
	a /= 4
	a **= 2

They all work in roughly the same way. For example, a *= 3 is the same as a = a * 3.

4.2. The Math Library
It'd be pretty hard to talk about numbers in Python and doing math without talking about the math library.
The Python math library contains many of the tools that you'd need to do more complex mathematical
operations. A very common example of a reason to use the math library is finding the square root of a number.
So, it's probably a good idea to try that out.

In order to get access to the math library, you have to import it. Importing a library only involves adding a
single import line to your code. If you're using a Python file, it's best to add imports first, right below
the shebang line.
	import math

Now that the math library is imported, you can use it. The square root functionality is called sqrt(). To use
it, you need to place the number or expression that you want to take the square root of in the parenthesis.
	import math
	math.sqrt(10 + 15)

You have to add math. in from to tell Python that that's where that functionality is coming from.

There are a ton of other things that you can do with the math library. If you'd like to read about them, you
can find the official documentation here.

5. Closing
Familiarize yourself with the different functionality that Python provides for working with numbers and the
way that it handles integers and floats. Practice running different mathematical equations and working with
the assignment operators for changing the values of variables. If you want to go more in-depth with math,
explore the math library and the functions that it provides.


---
https://linuxconfig.org/python-string-basics

Python String Basics
November 5, 2016

1. Introduction
Strings are called what they are because they are strings of characters. It doesn't matter if those
characters are letters, numbers, symbols or spaces. They are all taken literally and not processed within a
string. That's why strings are sometimes referred to as string literals.

2. String Basics
If you've been following along with the previous guides, you've already experimented with some strings.
You've typed in some, and you've printed them back out. What about getting user input when the Python script
runs? Python has built in functionality to take in user input and assign it to a variable. Try it out.

user_input = input("Please enter some text: ")
print(user_input)

The script will begin by asking, "Please enter some text: " and waiting for the user to do so. It will then
print out whatever the user entered. This method doesn't just work with strings. You can get numbers or other
variables from it too, but you have to tell it what type you're working with.

2.1. Adding Strings Together
That's a nice trick, but you've got to be bored with just entering strings, either way. What about actually
doing something with them? Well, you can do a lot with strings. The easiest thing that you can do is
something that you already tried earlier on, combining strings. Try making your script ask a user for their
name, and say "Hello" to them.
	name = input("What's your name? ")
	print("Hello " + name + "!")

Not bad, right? You don't have to just print out that new user input variable either. You can add strings
together before you print them out.
	name = input("What's your name? ")
	message_greeting = "Hello " + name + "!"
	message_compliment = name + " is a nice name."
	message = message_greeting + message_compliment
	print(message)

Notice something? Python just smashed the message parts together again. There's a way around that, but it
sort of breaks that idea of strings being completely literal.
	name = input("What's your name? ")
	message_greeting = "Hello " + name + "!"
	message_compliment = name + " is a nice name."
	message = message_greeting + "\n " +  message_compliment
	print(message)

Python didn't smash them together again, but you're probably wondering what the deal is with that weird \n.
Occasionally, there will be instances where you can't express what you need to exactly in a literal string.
What would happen if you had to output text with quotes in it, for example? That's why there are special
characters called escape sequences. Escape sequences allow you to insert problematic characters into strings,
and they are always preceded by a \. So, if you wanted to include quotes, you would just escape the quotation
marks like this, \"This is a quote\". That character that you saw in the last example was the newline
character. It tells Python that it should break the text up onto the next line. Since you can't just hit
"Enter" in the middle of a string, you include "\n".

2.2. Combining Strings and Numbers
So, what if you wanted to add a number to a string? Try this out.
	print("The answer is " + 42)

That didn't go well, did it?
	>>> print("The answer is " + 42)
	Traceback (most recent call last):
	  File "", line 1, in
	TypeError: Can't convert 'int' object to str implicitly

You can't just add numbers and strings together, but there are some ways to tell Python that you want it to
treat the number like a string. The first way is to convert the number to a string.
	print("The answer is " + str(42))

Using str() temporarily converts the number in the parenthesis to a string. It doesn't save those changes to
a variable if you're using it on one. You can use it to save changes to a variable, though.
	answer = 42
	# The variable "answer" is now an integer
	answer = str(answer)
	# Now it's a string

Using str() can be sort of cumbersome when you just want to print out a line of information, plus it requires
more code to run. It also can get confusing if you have multiple numbers in one string of text. There's
another way to put placeholders into a string and specify what variables they correspond to. This is a much
cleaner and more dynamic way of handling numbers in strings.
	answer = 42
	print("The answer is %d" % answer)

In the above example, %d is a placeholder for an integer. There are other placeholders too. %f is a
placeholder for floats, and %s is a placeholder for strings. The % separates that string from the variable(s)
that will be substituted in.

You can use multiple placeholders and multiple variables in the same string. All that you have to do is
specify them in a set of parenthesis after the % character. Be sure that they are in order and the types
match their placeholders.
	first_number = 10
	second_number = 12.5
	sum = first_number + second_number
	print("The sum of %d and %f is %f" % (first_number, second_number, sum))
	
The floats are a bit long, but you can see that it works. If you want shorter floats in your string, you can
specify the decimal place like this, %.2f. That limits the float to the second decimal place.

3. Conclusion
This first part of the guide focused on some of the most basic things that you can use strings for in Python.
It covered combining strings and incorporating other variable types into strings. Practice the different ways
of combining strings, especially using the %. The next guide is going to go much deeper into strings and will
begin pulling them apart... quite literally.


---
https://linuxconfig.org/advanced-python-strings

Advanced Python Strings
November 6, 2016

1. Introduction
In the previous guide, you learned the basics of handling strings in Python. In this guide, you will explore
some of the more complex things that strings are capable of. There are tools built into Python, called string
methods, that help you to handle strings and do some very powerful things. Through the use of string methods,
you can masterfully manipulate text and use it to its fullest potential without writing a ton of code.

2. Navigating a String
Strings aren't words. They aren't sentences, phrases, and believe it or not, they aren't even a collection of
text. Strings are just a lists of characters. Those characters can be letter, numbers, symbols, spaces, and
escape characters. Python sees strings by their parts(the characters) and uses those parts to manipulate
strings. This is actually true of almost any programming language. So, that means that you can select
individual characters out of a string. Try this:
	phrase_string = "This phrase is a string!"
	print(phrase_string[0])

The letter T was printed out. If you've never programmed before, you have to know that computers are weird.
They start counting at zero. So, whenever you are dealing with a situation where a computer has to count
through something, it will start at zero. The zero, or first, place in phrase_string is the letter T.

Try this next one:
	phrase_string = "This phrase is a string!"
	print(phrase_string[4])

Did it do anything? Actually, it did. Notice what is in the fifth(4) place in the string. It's the space.
Python is outputting that, since spaces are characters.

You can also count backward. It might not seem that reasonable at first, but some strings are very long. It
can be helpful be able to access the opposite end of a string easily. Counting from the opposite end of the
string still assumes that the string starts at zero, but goes backward into the negatives. So, to quickly
access the last character of a string, select negative one.
	phrase_string = "This phrase is a string!"
	print(phrase_string[-1])

Depending on the position of the character that you need, you can access it by either its positive or
negative value, making accessing any character in a string simple and efficient.

3. The Length of Strings
Instances will arise when you need to know how long a string is. Thankfully, Python has made finding out
especially easy with the len() method. All that you have to do is place the string or variable representing
the string in the parenthesis.
	phrase_string = "This phrase is a string!"
	print(len(phrase_string))

You should see an output of 24. Keep in mind that the last character of the string is accessible at 23 or -1,
since Python starts counting at zero.

4. Slicing Strings
You can select more than just one character from a string. You can slice out sections of a string using the
positions of the first and last characters of the area that you'd like to select. To get just the word
"phrase" in "This phrase is a string," you could do the following:
	phrase_string = "This phrase is a string!"
	print(phrase_string[5:11])

That statement is saying to start slicing the string before the fifth character and stop before the eleventh.
To think of it another way; you are telling it to start on the fifth character and stop before the eleventh.
The starting point is inclusive and the ending is exclusive.

In order to start at the beginning of the string, just leave off the first number.
	phrase_string = "This phrase is a string!"
	print(phrase_string[:4])

If you want to continue to the end, leave off the last number.
	phrase_string = "This phrase is a string!"
	print(phrase_string[17:])

This also works backward.
	phrase_string = "This phrase is a string!"
	print(phrase_string[-7:])

The above example results in the same thing as the example before, string!.

5. Upper and Lower Case
Python makes capitalizing or lower casing strings very easy. There are two built in methods, upper() and
lower() that will either capitalize or lowercase the entire string. Give them a try.
	phrase_string = "This phrase is a string!"
	print(phrase_string.upper())
	print(phrase_string.lower())

Notice that these methods are different than len(). They are tacked on at the end with a .. This means that
they are built into the strings themselves, and aren't coming from elsewhere in Python. That's an important
distinction to make later on, and it applies to more than just strings.

6. Find and Replace
Find and find and replace are very useful tools in word processing programs. Python makes their functionality
available in dealing with strings. They aren't exactly the same, though, so it's best to try them out and get
a feel for how they work.

The find() method actually just finds the first occurrence of the set of characters in the parenthesis and
tells you the character where it begins.
	phrase_string = "This phrase is a string!"
	print(phrase_string.find("is"))

Do you see what happened? It returned 2. That's the position of the first time the pattern "is" appears.
Python wasn't looking for the word, "is." It was looking for the patter of the letter "i" followed by the
letter "s." It's important to be careful when searching through strings when using find().

replace() finds every occurrence of a set of characters and replaces them with another set. This works the
same way that find() does and finds a pattern, regardless of where it is in a word. The way around this is to
add the space characters into the set that you're finding and replacing them in the changed text.
	phrase_string = "This phrase is a string!"
	print(phrase_string.replace(" is ", " was "))

7. Conclusion
There are more string methods available, and you can look them up as you need them. The goal of this guide
and the preceding one is so provide you with a strong basis for working with strings in Python. Now, you
should be able to proceed confidently, knowing that you can handle text when you need to.


---
https://linuxconfig.org/python-comments

Python Comments
November 7, 2016


1. Introduction
This guide isn't about programming. In fact, there is no new code involved at all. However, it does have
everything to do with making sure that the code that you write is understandable to both yourself and anyone
else that might look at it down the line.

If you've looked at any open source projects, you've probably noticed notes placed in by the programmers.
Those notes are just plain text. The programming language doesn't compile or interpret them in any way. It
just ignores them. It knows that those comments are for humans, not computers.

Comments are very important. Even if you aren't sharing your code with anyone else, you will run into an
instance where you look back at something that you wrote a long time ago and wonder, "What did I do here?" If
you are interested in working on an open source project, which, chances are, you are, since you're reading
this on a Linux website, commenting is even more important. The last thing that you want is for your commit
to be rejected because it's not commented and the maintainer doesn't want to waste time figuring out what it
does. Comments are also important in system scripting. There very few single-person IT departments out there,
and your coworkers aren't going to be happy if they don't know what's going on in your scripts.

2. Commenting in Python
Like many other languages, Python has two different kinds of comments, single and multi line. Single line
comments are excellent for adding a quick comment before a block of code or right after a line of code
explaining what it does. Multi-line comments are useful for adding a header or a more detailed description to
a piece of code. They are also great for commenting out a block of code so that it doesn't run, which is
great for debugging.

2.1. Single Line Comments
In Python, a single line comment begins with a #. This is a fairly common symbol to use in scripting
languages. Here's an example of how you'd use a single line comment as a description.
	a = 10
	b = 15
	a = b # Set a equal to b
	print( a + b )

The code will run exactly like it would if the comment wasn't there. The comment is just there for you.

You can also use a single line comment to say what the next few lines of code will do.
	# Import the Math library
	import math

	# Run the Pythagorean Theorem
	a = 3
	b = 4
	c = math.sqrt(a**2 + b**2)

Even though it's a simple example that you could probably figure out jut by looking at it, the comments make
looking at it much quicker. Imagine the time that would be saved on a more complex project.

Now, take a look at how you can use a single line comment to stop a line of code from running.
	a = 10
	b = 15
	# a = b  What happens if a isn't set equal to b
	print( a + b )

The line that set a equal to b didn't run, giving a different result than the previous example

2.2. Multi-Line Comments
In Python, you can denote a multi-line comment by using """ before and after the code that you want to
comment out. Of course, you can also use this for longer text comments like header information.
	"""
	PYTHON TEST
	AUTHOR = Your Name
	LAST UPDATED = 1 November, 2016
	PYTHON VERSION - 3.4.3
	VERSION NUMBER = 1.0.0
	"""

None of that means anything to a computer, but it is excellent for documenting the progress of a project.
Keeping information like that in project files doesn't impact the actual program, but it enables you and
anyone else working on the project to have quick and easy access to vital information. This is great for
documenting collaborative projects with multiple files and multiple authors. Remember that most real-world
projects will be complex, so documenting your code this way is a good habit to get into.

Multi-line comments are also essential for debugging. Say you just implemented a new feature to your project,
but that new code is causing an error. You can comment out entire sections of it to test the new feature's
functionality piece by piece, until you finally find out where the problem is. Say the "Pythagorean Theorem"
example from above was part of a feature that was failing. You could do something like the code below.
	# Import the Math library
	import math

	"""
	FAILING - PLEASE DEBUG

	# Run the Pythagorean Theorem
	a = 3
	b = 4
	c = sqrt(a**2 + b**2)

	"""

You can also use multi-line comments to stop an old piece of code while you replace it. Just deleting code
isn't usually the best practice. After all, once you delete it, it's gone. Commenting out that code stops it
from running, but also preserves it as a reference or fall-back just in case you need to look at it again.

3. Conclusion
Commenting code is important. That can't be overstated. It may seem tedious and boring. It doesn't have the
flash of writing a new killer line that implements a feature, but in the long run, you're going to be happy
that those comments are there. Comments are also an invaluable debugging tool that can provide you with a
solid procedure for testing out a failing piece of code. Keep practicing using comments and seeing how they
can impact the flow of code when eliminating lines or blocks of code.


---
https://linuxconfig.org/python-lists

Python Lists
November 8, 2016

1. Introduction
Lists are a big deal. It really can't be overemphasized what a big deal they are. Lists are not only used for
iterating through data, but they are also a popular data storage and categorization method used for handling
data as a program is running. For anyone who's programmed in another language, lists are often known as
arrays.

Lists may be either very simple or very complex, but they all follow the same rules. First, lists must store
only one type of data. If you have a list with a string it it, everything else in that list must be a string.
If you have a list full of floats, you can only add floats to it. You can even have a list of lists, but
that's a topic for later.

Remember when the string guides said that strings were just a list of characters. Well, now's the time to be
glad that you paid attention to strings. You can do many of the same things that you did with strings with
lists, and you can do them in the same way. So, some of this is going to feel like a repeat of the string
guide, but don't break focus. There are differences, and there are list specific methods, so assuming that
strings and lists are the exact same this will get you into trouble.

2. Creating a List
Creating a list is a bit different than the other variables that you've learned about so far. You can create
a list with absolutely no values in it at all. This is useful for situations where you don't exactly know
what will be added to the list because the data isn't in the program yet. There will also be plenty of
situations where you won't be sure how many entries will be in a list, so again, creating an empty one and
adding data later is the right move.

To create a list, give it a name, just like any other variable, but set that name equal to a set of square
brackets.
	my_list = []

Square brackets are the indication of a list, so Python will know that even though there isn't any data
there, it is still a list, and it will accept data eventually.

If you do know what you want to put into the list, you can do that too. You can add and subtract entries from
a list at any time, so it's not permanent, and you don't have to know all of the entries to start with.
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']

Since the name of each distribution is a string, they are all placed in quotes. In this case, the difference
between single and double quotes is insignificant. Single quotes generally look cleaner in lists. If this was
a list of integers or floats, there would be no quotes. Each entry is separated by a comma to ensure that
they are read independently.

3. Navigating Lists
Navigating through a list is the same as navigating through a string. Each entry has a value, referred to as
an index, and they count up from zero going down the list.
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	print(linux_distros[0])

The example above returns, "Debian," because it is the first entry in the list and has an index of zero.

For another example, try printing out the entry at index three.
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	print(linux_distros[3])

Did you get "CentOS?" Good.

Lists, like strings, can count backward from zero to access the other end of the data set. Check which entry
is at index negative two.
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	print(linux_distros[-2])

That's be "Arch." If "Debian" is the starting point at zero, "Gentoo is at negative one, and "Arch" is at
negative two.

So, it's important to keep in mind that each entry in a list actually has to indexes, a positive and a
negative. There is nothing wrong with choosing one over the other.
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	print(linux_distros[0])
	print(linux_distros[-7])

They both print out "Debian." That means that the entry, "Debian," can be found at the index of zero and the
index of negative seven.

4. Slicing Lists
Slicing lists is another area where lists and strings are nearly the same. You can slice out sections of a
list much like you can sections of a string. It is done by specifying a start and end point in the same way
as well. Just like with strings, you specify the first index to include in the slice followed by the index to
stop before.
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	debian_distros = linux_distros[:2]
	print(debian_distros)

The main difference in the output is that slicing a string results in another string, while slicing a list
results in a new shorter list.

Of course, you can also slice out the middle of the list too.
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	rh_distros = linux_distros[2:4]
	print(rh_distros)

Going backwards works here as well.
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	rh_distros = linux_distros[-5:-3]
	print(rh_distros)

Either way that you go about it, slicing out substrings of data from a list is a fairly easy way to retrieve
multiple pieces of information from a list and place them into another.

5. Conclusion
So, from what you've seen, lists and strings are nearly identical. In the next guide, you will explore some
of the differences in the form of the methods available to lists. There are powerful tools available for
handle the data held in list form that can make manipulating listed data a breeze.


---
https://linuxconfig.org/python-list-methods

Python List Methods
November 9, 2016

1. Introduction
Using methods with lists gives you the power to manipulate the data stored in the lists quickly and
effectively. Many of these methods are concerned with finding, adding, and removing pieces of data stored
within the list they are being called on. Others are more concerned with the structure of the list itself.

In any case, they will make your experience using lists a lot less frustrating by saving you time and effort
writing and rewriting the same code.

2. Finding the Length
Yes, this does start off with some more overlap with strings. The len() method works on lists as well. So, in
order to find the amount of elements in a list, just place it in the len() method.
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	print(len(linux_distros))

Again, keep in mind that the result is the number of elements in the list. The last element is available at
the index of six. You can also use the len() method to access elements in the list, if you have to.
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	print(linux_distros[len(linux_distros) - 1])

Adding the - 1 at the end is necessary, because there is no index of seven, since the list starts counting at
zero. Using this method is another way to access elements based on the length of the list. In some cases, it
may be preferable to using the negative numbers.

3. Append and Pop
What happens when you need to add elements to the list or pop them off of the end? Well, there are two
methods, append() and pop(), that make doing so very simple.

3.1. Append
In order append() an element onto an array, call the method with the element in the parenthesis.
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	linux_distros.append("Mint")
	print(linux_distros)

Now, "Mint" is the last element at the end of the list.

3.2. Pop
The pop() method can work in two different ways. If you leave the parenthesis empty, it works as the opposite
of append().
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	linux_distros.pop()
	print(linux_distros)

After running pop(), "Gentoo" is missing off of the end end of the list.

You can also specify what element you want to remove by giving it the index of that element.
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	linux_distros.pop(4)
	print(linux_distros)

Now, "OpenSUSE" is gone. Using pop() this way is an excellent way to remove elements that you know the index
of.

4. Insert and Remove
There are other ways to insert and remove elements from a list. append() and pop() are concerned mostly with
the end of the list. Aside from passing pop() and index, they don't help much for handling elements anywhere
else in the list. That's why insert() and remove exist. They offer ways to insert and remove elements from
anywhere in a list.

4.1. Insert
In order to use insert() to place a new element into a list, you have to specify the index where you want to
insert your new element and the element that you want to insert.
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	linux_distros.insert(2, "Mint")
	print(linux_distros)

"Mint" becomes the element at the index two and pushes the other elements back. Take a look at what's at
index four now.
	print(linux_distros[4])

"CentOS" is now at four because "Mint" took the place of "Fedora" at two, pushing it to three, where "CentOS"
was previously.

4.2. Remove
remove() works sort of like giving pop an index to remove, but instead of giving remove() an index you give
it the actual value of the element. It will find and remove the first occurrence of that value in the list.
So, be sure that the first occurrence is the one that you want to remove. Otherwise, it's probably best to
figure out the index of the element that you do want to remove and use pop().
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	linux_distros.remove("Arch")
	print(linux_distros)

"Arch" has been removed from the list, and the index of "Gentoo" has been adjusted accordingly.

5. Extend
extend() adds two lists together. It adds the list in parenthesis to the list that it is being called on.
	linux_distros = ['Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	debian_distros = ['Debian', 'Ubuntu', 'Mint']
	linux_distros.extend(debian_distros)
	print(linux_distros)

The elements from debian_distros have been added on to the end of linux_distros.

6. Index
There is a way to find out the index of an element, and that's the index() method. Like with the others,
index() finds the first occurrence of an element, not every occurrence.
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	print(linux_distros.index("Arch"))

It just prints out the index number of the element.

7. Sort
If you need to sort a list, either alphabetically or numerically, Python has you covered there as well. Just
call the sort() method on the list, and it will be saved in the new order. This will overwrite the previous
list, so create a copy to sort, if you need to preserve the original.
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	linux_distros.sort()
	print(linux_distros)

The list is now in alphabetical order.

It also works well with numbers. sort() will take a list of numbers and place them in order by value.
	numbers_to_sort = [1, 5, 8, 16, 3, 75, 4, 23, 9, 15, 8, 32]
	numbers_to_sort.sort()
	print(numbers_to_sort)

8. Reverse
reverse() is a bit of an odd method. It reverses the order of elements in a list in place and saves it. It
doesn't put them in any kind of special order, it just flips the list around.
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	linux_distros.reverse()
	print(linux_distros)

If you want to put a list in reverse alphabetical order, just call both sort() and reverse().
	linux_distros = ['Debian', 'Ubuntu', 'Fedora', 'CentOS', 'OpenSUSE', 'Arch', 'Gentoo']
	linux_distros.sort()
	linux_distros.reverse()
	print(linux_distros)

9. Conclusion
By making use of these methods, you can master the manipulation of lists in Python. Again, lists are an
integral part of programming, and are something to be practiced at length. The accompanying methods are no
exception. Try using them in conjunction with one another to get the most out of their potential. The next
guide will explore a new "dimension" of lists.



---
https://linuxconfig.org/python-multidimensional-lists

Python Multidimensional Lists
November 10, 2016

1. Introduction
Now it's time to take lists to a new dimension. No, you don't need to learn how to code in "The Upside Down,"
but there are additional degrees of complexity to lists. Lists are used to hold data, but they are also used
to categorize it. Values inside a list can be further broken down into other sets. That's essentially what a
multidimensional list is.

2. Two Dimensional Lists
What is a list that holds lists? That's all a two dimensional list is. The list below consists of three
lists. Each of the three lists has five elements. Don't worry about numbers quite yet. Just focus on the top
level elements, the lists. You can access them the way you would any element in a normal list.
	number_sets = [[2, 4, 6, 8, 10], [3, 6, 9, 12, 15], [4, 8, 12, 16, 20]]
	print(number_sets[1])

The second list of numbers will print out. In order to access those lower elements, you need to use a second
set of square brackets. In the first set of square brackets, specifies the top level element that you want to
access.

In the example below, that is the first list. Then, in the second set of brackets, specifies the element
within that initial top level element that you want. In that same example, it's the second element, or the
number "4."
	number_sets = [[2, 4, 6, 8, 10], [3, 6, 9, 12, 15], [4, 8, 12, 16, 20]]
	print(number_sets[0][1])

It's just as easy to access any of the other elements of either to top level lists or the numbers within.
Multidimensional lists behave just like regular, single dimensional, lists. Anything that is true of a single
dimensional list also applies here.

3. Three Dimensional Lists
There can be more than one additional dimension to lists. Keeping in mind that a list can hold other lists,
that basic principle can be applied over and over. In a three dimensional list, there is a list which
contains a number of lists, each of which also contains a number of lists.
	number_sets = [[[1, 2, 3, 4],[5, 6, 7, 8,],[9, 10, 11, 12],], [[13, 14, 15, 16],[17, 18, 19, 20],\
	[21, 22, 23, 24]], [[25, 26, 27, 28], [29, 30, 31, 32], [33, 34, 35, 36]]]
	print(number_sets[0][1][2])

The example above is a three dimensional list. It consists of a list of three lists. Each of those three
lists also consists of three lists of four numbers. The numbers of elements in the lists have nothing to do
with which dimension the list is. A three dimensional list only means that there are three levels of lists.

You can have a three dimensional list consisting of one list holding a single list which also holds only a
single list. You can access an element at the lowest level by specifying indexes in each of the three sets of
square brackets. In this case, it's the third number from the second list within the first list.
	number_sets = [[[[1, 2],[3, 4]], [[5, 6], [7, 8]], [[9, 10], [11, 12]]], [[[13, 14], [15, 16]], \
	[[17, 18], [19, 20]], [[21, 22], [23, 24]]], [[[25, 26], [27, 28]], [[29, 30], [31, 32]], \
	[[33, 34], [35, 36]]]]
	print(number_sets[0][1][1][1])

Yes. That Lovecraftian monstrosity is a real thing. They can actually get more complex than that. Really,
it's just here to illustrate a point. You can also see that as more dimensions are added, so are sets of
square brackets to access elements. Multidimensional lists can be complex, and can theoretically go on for
quite a while, and even that can be extended by using external libraries.

4. Multidimensional Lists and Methods
Remember where it said that anything that's true for single dimensional lists is also true for
multidimensional ones? Well, that goes for methods too. Here are a few examples of using methods on the two
dimensional list from before.
	number_sets = [[2, 4, 6, 8, 10], [3, 6, 9, 12, 15], [4, 8, 12, 16, 20]]
	number_sets.append([5, 10, 15, 20, 25])
	print(number_sets)

Python had no problem appending the new list of number on.

Methods work for elements within elements as well. As long as the element is properly accessed, it can be
used, regardless of its position.
	number_sets = [[2, 4, 6, 8, 10], [3, 6, 9, 12, 15], [4, 8, 12, 16, 20]]
	number_sets[1].pop(3)
	print(number_sets)

Because the first element in number_sets is itself a list, pop() can be called on it, just like any other
list.

It doesn't matter which methods are called or where. You can still combine methods and modify multiple
different parts of the list.
	number_sets = [[2, 4, 6, 8, 10], [3, 6, 9, 12, 15], [4, 8, 12, 16, 20]]
	number_sets[2].reverse()
	number_sets[1].append(18)
	number_sets[0].extend([12, 14, 16, 18])
	print(number_sets)

You probably get the idea. Each list is more-or-less independent, aside from being part of the same list.
Feel free to work with them as though they are.

5. Conclusion
If you've never seen multidimensional lists before, your head's probably spinning right about now. It's a lot
to take in, and even worse to try to visualize. Up until four dimensional lists, they can be drawn to
correspond with physical dimensions.

A single dimension list is simply a line. If you draw lists dropping down from that line in a two dimensional
list it becomes a rectangle or a plane. Then, if you draw lists coming out the back of the drop down lists,
it forms a sort of cube. That's still sort of difficult to picture, but it helps some people to think of it
that way.

In any case, it's a good idea to get some practice here with these. If you're struggling, don't worry too
much. Chances are, you won't see anything beyond the odd two dimensional list for some time, and even those
tend to be rare for beginners.


---
https://linuxconfig.org/python-tuples

Python Tuples
November 11, 2016

1. Introduction
Tuples are immutable data sets made up of data of different types. While tuples are very similar to lists,
they are different in those key ways.

Tuples cannot be changed once they are created. The data they hold can be passed to a different tuple, but
the original tuple cannot be changed. This means that tuples don't have methods for manipulating them like
lists do because they cannot be manipulated.

Tuples can also contain data of different types. Lists are restricted to one type of data throughout. With
tuples, it doesn't matter. Tuples can contain strings, integers, floats, booleans, and even lists. Because
tuples are immutable, they aren't meant to be manipulated, so data types don't matter nearly as much.

So, what are tuples even good for then. The answer is mostly storage. Tuples are great for storing sets of
information that doesn't need to or isn't supposed to change. Projects like the Django web framework use
tuples to store settings, for example.

2. Creating Tuples
Creating tuples is a lot like creating a list with values already in it. Creating an empty tuple would be
pointless, since they can't be changed. Also, unlike lists, tuples use regular parenthesis to enclose their
data.
	file_directories = ('/home/user/Pictures', '/var/www/siteroot/uploads', '/var/www/siteroot/staticfiles',)

The above example is similar to a configuration line that you may see in a program like Django. A set of file
directories is not something that you'd want the program to be able to change, so they are hard coded into a
configuration file by the user. The user is still able to change them, but the program isn't.

There's something else to not there. There is a comma trailing after the last entry. In tuples, every element
must be followed by a comma, regardless of its position.

Again, a tuple doesn't have to store all of the same thing. The example below is a nonsensical demonstration
of that, but is still valid Python.
	random_junk = ('Bacon', 7, True, 11, 'Your mother was a hamster!',)

3. Using Tuples
Tuples mostly just behave like limited lists. They can do many of the same basic things, but lack much of the
more advanced functionality that modifies the contents of the list.

3.1. Navigating Tuples
Navigating a tuple is just like navigating a list. Try accessing a couple of elements from that junk tuple.
	random_junk = ('Bacon', 7, True, 11, 'Your mother was a hamster!',)
	print(random_junk[2])

Indexes are more predictable in tuples because the values don't change. Even still, you can still navigate
backward through a tuple.
	random_junk = ('Bacon', 7, True, 11, 'Your mother was a hamster!',)
	print(random_junk[-2])

3.2. Length of Tuples
The len() method works on tuples too. It works exactly the way it does with both strings and lists. Just put
the list in the parenthesis.
	random_junk = ('Bacon', 7, True, 11, 'Your mother was a hamster!',)
	print(len(random_junk))

Also, like with lists, you can use the len() to help navigate through a tuple.
	random_junk = ('Bacon', 7, True, 11, 'Your mother was a hamster!',)
	print(random_junk[len(random_junk) - 1])

4. Conclusion
Tuples are a sequential structure designed for storage and categorization. They aren't meant to be
manipulated like lists are, since they can't be changed after they are created. They can, however, store
different data types that can be easily retrieved. If you are looking to implement a set of data in a program
that should not be changed and could stand to be protected from change from the program, a tuple is the right
way to go.
filename: /c/Users/gregor.redelonghi/Dropbox/ODPRTO/_PYTHON/__insert_linuxconfig-multif_20161118.txt
https://linuxconfig.org/python-boolean-operators

   November 13, 2016

1. Introduction
   If you've been following along, you're probably tired of hearing about lists right about now. Well,
   this guide has nothing to do with lists! Remember back when you first leaned about variables; how
   there was one that just held True or False called a Boolean? There hasn't been a guide on them
   because Booleans are actually that simple. However, there are symbols called Boolean Operators that
   are used to evaluate whether a statement is true or false. They compare statements and return either
   true or false. It sounds simple, and in a way it is, but it can get more complex when more
   comparisons get added.

2. And
   The first comparison operator is and. You can use and to test in one statement and another statement
   are both true.
is_it_true = (3 * 4 > 10) and (5 + 5 >= 10)
print(is_it_true)

   The code prints out True because both 3 * 4 > 10 and 5 + 5 >= 10 are true.
   Try one out where one of the statements is true and the other is false.
is_it_true = (3 * 4 > 10) and (5 + 5 > 10)
print(is_it_true)

   Because 5 + 5 > 10 is not true, the code prints out False. In order for an and expression to return
   True, both statements on either side of and must be true.
   You can have multiple Boolean Operators in one statement.
is_it_true = (3 * 4 > 10) and (5 + 5 >= 10) and (4 * 4 > 15)
print(is_it_true)

   It doesn't matter that there are multiple statements. Each statement must be true in order for the
   whole to evaluate to True.
   There can be any number of statements. Python is always going to look at what two things are on
   either side of and and return True if the are both true or False if any or all of them are false.
is_it_true = (3 * 4 > 10) and (5 + 5 >= 10) and (4 * 4 > 15) and (5 + 4 < 10)
print(is_it_true)

3. Or
   The or operator also compares the statements on either side of it. In the case of or it evaluates if
   one statement or the other is true. If either one is, the entire expression will evaluate to True. In
   order for an or expression to return False, both statements must be false.
is_it_true = (3 * 4 > 10) or (5 + 5 > 10)
print(is_it_true)

   The expression is True because even though 5 + 5 > 10 is not true, 3 * 4 > 10 is.
   Like with and, these can also be combined.
is_it_true = (3 * 4 < 10) or (5 + 5 > 10) or (4 * 4 > 15) or (5 + 4 > 10)
print(is_it_true)

   Even though only one of the statements is true, the expression as a whole is true. Using or only
   requires that one statement be true for the entire expression to also be true.

4. Not
   The not operator checks if something is not true. If the expression that it is evaluating is not
   true, not will evaluate True. That might seem weird, so here's an example.
is_it_true = not (3 * 4 > 10)
print(is_it_true)

   Since the statement that not is evaluating is true, it returns False.

5. Combining Them
   You can combine different Boolean Operators into the same expression. Using them in conjunction with
   one another allows you to create finer grained control over the logic in your programming, but it
   also adds a new degree of complexity.
is_it_true = (3 * 4 > 10) or (5 + 5 > 10) and (4 * 4 > 15) or (5 + 4 > 10)
print(is_it_true)

   It evaluated True even though there were false statements. Python compared what was on either side of
   the or operators first. Because or only requires one of the statements that it's evaluating to be
   true, each or evaluated to True. Then, and checked if the statements on either side of it were true.
   The or expressions were on either side of the and, and they were both true, so the and and the
   expression as a whole are also true.
is_it_true = (2 * 6 <= 10) and (32 / 8 >= 4) or not (5 ** 2 < 25)
print(is_it_true)

   Again, this one came back True. (2 * 6 <= 10) and (32 / 8 >= 4) is false because 2 * 6 <= 10 is
   false. 5 ** 2 < 25 is false, but not evaluates True when given a false statement. So, with a false
   statement on one side of the or and a true one on the other, or will evaluate True along with the
   entire expression.

6. Conclusion
   Boolean Operators operate based on logic. That's probably the best thing to keep in mind when dealing
   with them. Think through exactly how statements are compared with on another in a logical procedure.
   You can also think of the operators in very simple terms. and means both must be true. or means that
   one must be true. not just evaluates to the opposite.
   It's good practice to come up with as complex of these expressions as you can and try to figure out
   how they will ultimately evaluate. It takes some getting used to, but the more that you do it, the
   more familiar you will become with Boolean Operators and Boolean Logic.



---
https://linuxconfig.org/python-if-statements

Python If Statements
November 14, 2016

1. Introduction
   How can a program make a decision? Can a program choose between two or more options. Actually, it
   can. This isn't some kind of advanced AI concept, it's just a matter of evaluating whether or not
   certain conditions have been met and choosing a response.
   The way that a program can evaluate a condition comes down to true and false. If something is true,
   do this. If it isn't true do, that. The if statement is the structure for a program to pose these
   questions and evaluate whether or not they are true. if statements can check multiple conditions and
   provide multiple responses. They can be used to divert code down one path or another and control the
   overall flow of a program. They can also be used as a gating mechanism to determine whether certain
   blocks of code run. Have you ever gotten a message telling you that you needed to log in to continue?
   That was the result of if.

2. If
   if has a very simple structure. The word, if, is followed by a set of parenthesis containing a
   statement that needs to be evaluated for truthfulness and a colon. The following line is indented and
   contains the action to be performed if the statement is true. There can be multiple actions following
   if as long as they are all indented.
if (5 ** 2 >= 25):
        print("It's true!")
        print("If is awesome!")

   You can resume the normal flow of the program following if by returning to unindented lines of code.
   You can, and should, use Boolean Operators in if as well.
if( (5 ** 2 >= 25) and (4 * 2 < 8) or (35 / 7 > 4) ):
        print("Booleans make If more powerful!")

   Boolean Operators allow if to evaluate more and more complex conditions in a single line of code.
   Chances of having more than one factor impacting whether a block of code should run are pretty high.
   Using Boolean Operators is an elegant way to handle this without needing multiple if statements and
   many more lines of code.
   When the if condition is false, the indented code below just doesn't run. Take a look at an example
   where that happens.
if (4 * 2 < 8):
        print("This won't run")

print("This is isn't part of if, so it will")

3. Else
   What happens if you want to run a piece of code only if if isn't true. You could use not like the
   example below.
if (not (5 ** 2 >= 25)):
        print("Bizarro!")

   That's weird and counter intuitive. It also creates problems with more complex situations. What if
   you want the program to do one thing if a statement is true and another if it's not? That's where
   else comes in. else is placed on the same indent level as if following the code that you want run if
   if is true. It is also followed by a colon and indented code that will run if if isn't true.
if (5 ** 2 > 25):
        print("Your math looks a bit off...")
else:
        print("That makes sense.")

   else is the best way to run code if if is false. It can also be a good way to make sure that things
   are going along the way they should be.
if ( (5 ** 2 >= 25) and (35 / 7 > 4) and ( 4 * 2 >= 10) and (3 ** 2 < 10) ):
        print("Everything looks good.")
else:
        print("Your math is wrong somewhere.")

4. Elif
   Python supports multiple independent conditions in the same if block. Say you want to test for one
   condition first, but if that one isn't true, there's another one that you want to test. Then, if
   neither is true, you want the program to do something else. There's no good way to do that using just
   if and else. elif is a mashup of the words if and else and is used to test other conditions following
   the original if before the block defaults to else.
if (5 ** 2 > 25):
        print("The first one is right.")
elif(5 ** 2 = 25):
        print("It was the second one.")
else:
        print("Something went wrong.")

   That example is sort of nonsense because >= exists, but you can see the flow of logic from it.
   You can have as many elif statements as you need.
if (5 ** 2 > 25):
        print("It is greater.")
elif (5 ** 2 < 25):
        print("It is less.")
elif(5 ** 2 = 25):
        print("It is equal.")
else:
        print("That makes no sense")

   Again, that's nonsense, but it still illustrates the point. That last else could actually be left off
   because it's not really possible to ever get there. That is something else that you can do with elif.
   If you know that one of multiple conditions must be met, you can use if and elif to funnel your
   program down the right path.

5. Nesting If
   You can ask a second question only if the first question was answered affirmatively. It works that
   way in real life, and it works that way in Python. if statements can be nested within other if
   statements. This can actually be done indefinitely, and it doesn't matter where they are nested. You
   could put a second if within the initial if. You could put it in one of the elif blocks. You can even
   put it in the else.
a = 10
b = 15
c = 20
d = 25

if (a > b):
        if (a + b >= d):
                d -= c
        elif (a + >= c):
                c -=b
        else:
                b -= a
elif (b > c):
        print(b - c)
else:
        print(d)

   As you can see, the flow diverts on the first condition down a nested if. The nested if follows the
   exact same pattern as any other if statement.

6. Conclusion
   By using if you can divert the flow of your program and control the way that it runs in a logical
   manner. Using conditional logic, you can crate tests that your program will use to make decisions and
   adapt to circumstances and data values.



---
https://linuxconfig.org/python-while-loops

Python While Loops
November 15, 2016

1. Introduction
   Many times in programming, you will need to repeat the same task many times. In fact, looping through
   and repeating an operation is one of the cornerstones of programming. After all, one of the things
   that computers are way better than humans at is performing repetitive tasks without getting tired or
   making mistakes.
   One of the simplest ways to make a program repeat the same task is to use a while loop. A while loop
   repeats the same block of code while a condition is true. When that condition becomes false, the loop
   will break, and the regular flow of code will resume.
   The structure of a while loop is similar to what you encountered in the last guide with if. A while
   loop begins with the word while followed by parenthesis containing the condition of the loop and a
   colon. The following lines are indented and will execute in the loop.

2. Infinite While
   Check out this while loop. Try it yourself in your interpreter to see exactly what it does. You might
   be somewhat surprised.
# Import time for sleep
import time

# While loop
while(True):
        print("looping...")
        time.sleep(2)

   What happened? Rather, what is happening? If you haven't figured out how to stop it yet, just press
   Ctrl+C. A while loop will run indefinitely as long as the condition that it is given remains True.
   The loop above was given True as its condition, which will never not be true.
   Occasionally, you will need to run an infinite loop. They are useful for things like monitoring data
   for changes. If that is the case, passing True is a sure fire way to do that.
   There is another piece of this puzzle. sleep() is a method that causes Python to pause for a
   specified number of seconds. Give sleep() the number of seconds that you want it to pause for in its
   parenthesis, and it will stall the execution of your program. It's fairly common to see sleep() in
   loops, especially infinite ones.

3. Counting Down
   One way to stop a while loop is to use a counting variable. Set the condition of the loop to the
   number where you want the loop to stop iterating, and increment the counting variable every time the
   loop runs.
count = 0
while(count < 10):
        print("loop number: %d" % (count + 1))
        count += 1

   The count variable starts off as zero. The condition specified to the loop states that it will run as
   long as count is less than ten. It will not run while count is ten. Notice that the loop runs ten
   times, though. That's because the loop runs while count equals zero. The output is able to say that
   the first run is number one and the last is ten because the variable being substituted in to the
   string is count + 1, so it displays one more than the current count value. After the print(), one is
   added to count.

4. Break
   You can also break a while loop from inside the loop using break. It usually works best in
   conjunction with if, and a specific circumstance that would cause an otherwise endless loop to break.
# Import Random for random number generator
import random

# Infinite while loop with break condition
while(True):
        num = random.randint(1, 10)
        print(num)

        if(num == 7):
                print("Stopping...")
                break
        else:
                print("Still looping...")

   The loop is set up to run indefinitely by passing True as the condition of the loop. However, there
   is a condition in which the loop can break. If the variable num is equal to seven during one of the
   iterations, the code will arrive at break and break the loop.
   This example isn't entirely realistic. The random library was imported, and a random number generator
   was used to create the value of num on each iteration. That particular code random.randint(1, 10), is
   a method from the random library that chooses a random number between one and ten. The range can be
   specified by changing the start and end numbers. In a real world scenario, it would probably be user
   input or a signal from another part of the program that would break the loop. In fact, infinite loops
   like this are often used to listen for user input.

5. Conclusion
   While loops are one of the most important tools in repeating operations in Python. They can be used
   to iterate a set number of times, until a signal or condition is met, or indefinitely. While their
   structure is very simple, it is important to keep track of what is in the loop and exactly when it is
   supposed to end. It is very easy to allow one of these while loops get away from you. In improperly
   constructed loop can cause excessive resource usage, hanging, and in incorrect program flow. Just
   make sure to keep an eye on the path your loop is taking.



---
https://linuxconfig.org/python-for-loops

Python For Loops
November 4, 2016

1. Introduction
   There is yet another type of loop. That loop is designed for iterating sets of data. That's right,
   lists. Unlike while loops, these for loops have a defined length based on the data set that they are
   iterating over.
   Generally, for loops are used to access and modify each element in a list. To do this, they
   temporarily represent each element as a new variable used only within the loop.
   for loops have a slightly different structure than while loops do. They begin with the word for,
   which is followed by the temporary variable being created for the loop. Then there is the keyword in
   specifying the set of data being used, followed by the data set itself and, ultimately, a colon.

2. For With Range
   There is a method called range() that either takes a single number and behaves like a list of numbers
   going from zero until the number before the one specified or takes two numbers separated by a comma
   and acts like a slice starting at the first number and listing all numbers until the number before
   the last one.
   Below is an example of a for loop that uses range() and multiplies each number in it by two.
for x in range(1, 11):
        print(x * 2)

   It hasn't changed anything. It only prints out the results. However, it can be used to create a new
   list.
times_two = []

for x in range(1, 11):
        times_two.append(x * 2)
        print(x * 2)

print(times_two)

   Even though you didn't start with a complete list, you can use range() to create one. To break it
   down a bit; range() outputs each number from one to ten. Then, each number is individually
   temporarily assigned to x. The result of x * 2 is passed to the append() method on the newly created
   times_two list.

3. For With Lists
   range() is great, but it's only really useful when working with numbers. Most of the time, you will
   be passing existing lists to a for loop. Take a look at this example that capitalizes the names of a
   list of Linux distributions.
# Create the list of distributions
linux_distros = ['Debian', 'Ubuntu', 'Mint', 'Fedora', 'CentOS', 'OpenSUSE', 'Slackware', 'Arch', 'Gentoo']

distros_caps = []

# loop through them, capitalize, insert into new
for distro in linux_distros:
        print(distro.upper())
        distros_caps.append(distro.upper())

# print the original
print(linux_distros)
# print the new list
print(distros_caps)

   This simple for takes each distribution name from the list, temporarily assigns it to the distro
   variable, calls the upper() method to capitalize and print it before calling the method again to
   append it on to the new distros_caps list. In the end, it prints out both lists.

4. For With Multidimensional Lists
   for loops have no problem iterating through multidimensional lists as well. Doing so involves nesting
   for loops within one another. In a two dimensional list, the outer for loop iterates through the
   lists within the multidimensional list, and the inner for loop iterates through the elements of each
   list. It's much easier to see through some actual running code.
# Create original list
number_sets = [[2, 4, 6], [3, 6, 9], [4, 8, 12]]

# Create empty list to copy into
square_sets = []

# Start outer for loop to iterate over inner lists
for number_set in number_sets:

        # Add a new empty list to the new list for each iteration
    square_sets.append([])

        # Start inner for loop to iterate over numbers and append them into the new list
    for number in number_set:
        print("The original number is %d, and the result is %d." % (number, number ** 2))
        square_sets[number_sets.index(number_set)].append(number ** 2)

print(square_sets)

   The example above provides a better breakdown of exactly what it is doing when. The best way to think
   of it is that you need one for loop to iterate over the outer list and another to iterate over each
   inner list.
   The last line of the inner for might be tripping some people up, but it's not as complicated as it
   looks. All that it does is use append() to add the value of the current number squared to the new
   list, square_sets. Inside the square brackets is a call to index(), which is taking in the current
   number and returning its position in the original list. That is done to ensure that each squared
   number is added to the right list within square_sets.

5. Conclusion
   You may find that for loops are more useful more often than while loops. They tend to be used very
   frequently. There is a reason why there were three guides on lists. They are important. They are
   constantly used. for loops go hand-in-hand with lists. They are absolutely the best way to get all of
   the information out of a list. One of the most crucial components of WordPress is its custom for loop
   that it uses to display just about everything on its pages. If you are still feeling uncertain about
   for loops, you need to go back and take another look at lists, come back to this guide, and run some
   examples. Experiment until you feel confident. There's no point in going forward if you're not.



---
https://linuxconfig.org/python-dictionaries

Python Dictionaries
November 18, 2016

1. Introduction
   Somebody hit lists with gamma rays. Okay, so Dictionaries aren't the Incredible Hulk, but they are
   supercharged in what they can do. In other languages, dictionaries are referred to as hashes,
   associative arrays, and associative lists. It's probably best to think of them as associative lists
   because that's exactly what they are. Dictionaries are lists that associate two values with one
   another. To think of it in terms of an actual dictionary, they associate a word, or key with a
   definition, or value. They function sort of like a list with custom indexes.
   Dictionaries allow you to associate information in a way that no other data structure will. They
   allow you store and retrieve related information in a way that means something both to humans and
   computers.

2. Creating Dictionaries
   Creating dictionaries is very similar to creating lists. One main difference is that dictionaries use
   curly brackets {} instead of square ones.

2.1. Empty
   Like lists, dictionaries can be created with nothing in them. This makes sense because values can be
   populated from an external source any time. Dictionaries are great for this, especially when it comes
   to databases.
new_dictionary = {}

2.2. With Entries
   Dictionaries can also be created with as many or as few entries as you'd like. Since dictionaries can
   be expanded or shrunk at any time, it doesn't matter exactly how much data you start with, but if you
   know exactly what you need to start, you can absolutely set the dictionary up that way.
distro_install_command = {'Debian': 'apt-get', 'Ubuntu': 'apt-get', 'Fedora': 'dnf', 'CentOS': 'yum', 'OpenSUS
E': 'zypper', 'Arch': 'pacman', 'Gentoo': 'emerge'}

   As you can see, the dictionary values are wrapped in curly brackets. Inside, each key is separated
   from its accompanying value with a colon, and each set is separated by a comma. It's sort of
   difficult to see the way it is presented above. Often times, dictionaries use spaces and line breaks
   to organize entries.
distro_install_command = {'Debian': 'apt-get',
                                                'Ubuntu': 'apt-get',
                                                'Fedora': 'dnf',
                                                'CentOS': 'yum',
                                                'OpenSUSE': 'zypper',
                                                'Arch': 'pacman',
                                                'Gentoo': 'emerge'
}

   Organizing the dictionary the way it is above is much more readable. While it may seem like
   formatting it this way violates Python's strict spacing rules, in reality, it doesn't because the
   dictionary has it's own structure delineated by the brackets and commas.

3. Navigating Dictionaries
   Navigating dictionaries is a lot like navigating lists. Instead of specifying an index, you must
   specify a key to access a value.
distro_install_command = {'Debian': 'apt-get',
                        'Ubuntu': 'apt-get',
                        'Fedora': 'dnf',
                        'CentOS': 'yum',
                        'OpenSUSE': 'zypper',
                        'Arch': 'pacman',
                        'Gentoo': 'emerge'
}

print(distro_install_command['Gentoo'])

   Navigating using numeric indexes will not work with dictionaries. You must use keys. Therefore, it is
   also important to know what keys are being used in order to successfully navigate through
   dictionaries.

4. Adding and Removing
   Adding and removing entries from dictionaries is very simple. Keep in mind that dictionaries are not
   necessarily ordered, so it doesn't really matter what position entries are added at.

4.1. Adding Items
   Adding entries to a dictionary is more like defining a new variable than adding a new element to a
   list. To do so, you must first specify the name of the dictionary that the entry is being added to,
   then the key. Then, you can set that key equal to its value.
distro_install_command = {}
distro_install_command['Debian'] = 'apt-get'

   Even though only stings have been used so far, both strings and numbers can be used as keys, and
   values can be nearly any type. Take a look at the example below.
test_dict = {}
test_dict[3] = "Boat"
test_dict['Green'] = 42
test_dict['a list'] = [2, 4, 6, 8, 10]
other_dict = {'a': 1, 'b': 2, 'c': 3}
test_dict['a dict'] = other_dict
print(test_dict)
print(test_dict['a dict'])
print(test_dict['a list'][1])

   As you can see, dictionaries are incredibly flexible in what they can store and how they can be used.
   The lack of restrictions placed on values allows nearly any data type and structure to be associated
   with a number or string to be stored and retrieved.

4.2. Removing Items
   The easiest way to remove entries from a dictionary is to use the del operator. The del operator
   actually works on lists too, but there are other methods for that, so it hasn't been covered until
   now. del will just delete the specified entry.
distro_install_command = {'Debian': 'apt-get',
                        'Ubuntu': 'apt-get',
                        'Fedora': 'dnf',
                        'CentOS': 'yum',
                        'OpenSUSE': 'zypper',
                        'Arch': 'pacman',
                        'Gentoo': 'emerge'
}
del distro_install_command['Ubuntu']
print(distro_install_command)

5. Conclusion
   Dictionaries are yet another useful and dynamic weapon in Python's arsenal. They are an excellent
   data storage structure and can be used for a lot more. Practice accessing, adding, and removing
   entries from dictionaries, and try to get a feel for how they operate. The next guide will delve
   deeper into dictionaries and explore how to use methods with them and iterate over them with the for
   loop.

   
   
---
https://linuxconfig.org/python-advanced-dictionaries

Python Advanced Dictionaries
November 19, 2016

1. Introduction
   You've already gotten acquainted with dictionaries, but just like the other data structures Python
   supports, there are methods and more powerful ways to use them. There aren't as many methods for
   working with dictionaries as there are for lists, but that's because dictionaries just don't need
   them. Plus, many of the ones that do exist, work to break down dictionaries into lists and tuples to
   make them easier to manage. So, those list methods can be used in conjunction with the dictionary
   ones to create an efficient machine for handling data.

2. Dictionary Methods

2.1. Items, Keys, and Values
   These methods work to break down dictionaries into other data structures to make working with them
   much more manageable. Doing so also gives access to the methods of those data structures. Through
   these combinations of methods and loops, you can access and manipulate data with ease.
   The first method is items(). It breaks down each entry in the dictionary into a tuple and stores them
   all in a list.
distro_install_command = {'Debian': 'apt-get',
                        'Ubuntu': 'apt-get',
                        'Fedora': 'dnf',
                        'CentOS': 'yum',
                        'OpenSUSE': 'zypper',
                        'Arch': 'pacman',
                        'Gentoo': 'emerge'
}
distro_install_list = distro_install_command.items()
print(distro_install_list)
print(distro_install_list[3][1])

   It all breaks down exactly the way you would expect it to.
   The next method gives you access to the keys in the dictionary in the form of a list.
distro_install_command = {'Debian': 'apt-get',
                        'Ubuntu': 'apt-get',
                        'Fedora': 'dnf',
                        'CentOS': 'yum',
                        'OpenSUSE': 'zypper',
                        'Arch': 'pacman',
                        'Gentoo': 'emerge'
}
distro_names = distro_install_command.keys()

for distro in distro_names:
        print(distro)

   The new distro_names list behaves just like any other and can be looped through just the same.
   The last method is the same the one before it, but instead of retrieving the keys, this one get the
   values. It should be pretty obvious by now that it is called values().
distro_install_command = {'Debian': 'apt-get',
                        'Ubuntu': 'apt-get',
                        'Fedora': 'dnf',
                        'CentOS': 'yum',
                        'OpenSUSE': 'zypper',
                        'Arch': 'pacman',
                        'Gentoo': 'emerge'
}
distro_commands = distro_install_command.values()

for command in distro_commands:
    print(command)

3. Dictionary Values in Strings
   This isn't a method or anything too complex, but situations will arise when you want to insert values
   directly from a hash into a string, and it doesn't work quite like you'd think. The % operator
   actually looks at the dictionary as a whole and pulls values from keys within it to substitute them
   into a string.
book_info = { 'title': 'Learning Python',
                        'pages': 342,
                        'pub_date': 'November 2016',
                        'chapters': 14,
}
print("The book is called %(title)s, and it was released on %(pub_date)s.  It is %(pages)d pages long with %(c
hapters)d chapters." % book_info)

   As you can see, it's just a more convenient way of handling inserting the values from a dictionary.
   Using the regular method can get very repetitive and cumbersome, even with only a few entries.

4. Iterating Over Dictionaries
   Iterating over dictionaries isn't as simple as you'd probably think. Because dictionaries operate
   using pairs of values, the numerically based way of looping through lists doesn't quite work. Give it
   a shot, and see what happens.
distro_install_command = {'Debian': 'apt-get',
                        'Ubuntu': 'apt-get',
                        'Fedora': 'dnf',
                        'CentOS': 'yum',
                        'OpenSUSE': 'zypper',
                        'Arch': 'pacman',
                        'Gentoo': 'emerge'
}
for distro in distro_install_command:
        print(distro)

   So, what happened? It sort of worked, but the only things outputted were the keys. You can probably
   guess one way to get the values too, and it will work, but it's not all that elegant of a solution.
distro_install_command = {'Debian': 'apt-get',
                        'Ubuntu': 'apt-get',
                        'Fedora': 'dnf',
                        'CentOS': 'yum',
                        'OpenSUSE': 'zypper',
                        'Arch': 'pacman',
                        'Gentoo': 'emerge'
}
for distro in distro_install_command:
    print("The distro is %s, and it uses the command %s." % (distro, distro_install_command[distro]))

   There is a better way to handle this, and it makes use of the items() method. If you remember from
   before, the items() method creates a list of tuples containing the keys and values from the
   dictionary.
distro_install_command = {'Debian': 'apt-get',
                        'Ubuntu': 'apt-get',
                        'Fedora': 'dnf',
                        'CentOS': 'yum',
                        'OpenSUSE': 'zypper',
                        'Arch': 'pacman',
                        'Gentoo': 'emerge'
}
for distro, command in distro_install_command.items():
    print("The distro is %s, and it uses the command %s." % (distro, command))

   That seems to fly in the face of something you learned previously, doesn't it? How is that for loop
   creating two temporary variables to access the elements in a two dimensional list? Well, this is
   actually functionality built into Python for just this sort of thing. Unfortunately, it doesn't
   always work well with multidimensional lists because it requires that every list within the
   multidimensional list be the same size. With a dictionary, you know that you are always going to be
   working with pairs of values, but multidimensional lists could contain lists of any size. That's why
   this is really only a great solution when working with dictionaries.

5. Conclusion
   By using methods and iteration, you can break dictionaries into a form that is much easier to work
   with. By combining the functionality of dictionaries with the functionality available to lists and
   tuples, you gain incredibly powerful tools for handling data.



---
https://linuxconfig.org/python-functions

Python Functions
November 21, 2016

1. Introduction
   Code would quickly become an ugly and unruly mess if there wasn't a way to easily repeat and reuse
   it. You've already seen some of that with loops. They're great for repeating the same task multiple
   times right away. What if you wanted to reuse a block of code whenever you wanted? Well, that's where
   functions come in.
   Here's another trip back to math class. If you remember, functions took in a number, did something to
   it, then outputted the new value. They were often represented in tables with the input on one side
   and the output on the other. Functions in programming are similar. Sometimes they take input.
   Sometimes they don't. Much of the time they return a value as well, but they don't always have to. In
   every case, they are used to repeat an operation whenever they are used, and that's the greatest
   similarity with the math concept.
   Actually, you've already been using functions through much of this guide. Every time you've put a
   string or a list in len() or called pop() on a list, you were using a function. Yes, they were called
   methods then, but methods are just a special type of function used in object oriented programming.
   There's no need to get too far into that now, though. All you need to remember is that functions
   aren't hard or scary, and they make the lives of programmers a whole lot easier.

2. Creating Functions
   Creating functions is a lot like creating loops. Python uses the colon and indentation to denote the
   beginning of a code block, and functions are no different. Instead of using a loop keyword to begin
   the block, though; functions use def.
def print_hello():
        print("Hello World!")

   The structure of a function is like a cross between a loop and a variable. You start off with a
   keyword, def then assign it a name. Function names are exactly like variable names. They should be
   lower case with words separated by underscores. While you would name a variable by what it is, you
   name a function by what it does. In that way, variables are like nouns, and functions are like verbs.
   If you tried to run that, you noticed something pretty odd. Nothing happened. Functions are building
   blocks that you store for later. When you create them, they aren't automatically used. Creating a
   function simply opens up the possibility to use it later.

3. Calling Functions
   Using a function is called calling it. You always call a function by its name. So, take a look at the
   function from before and call it to see exactly what it does.
def print_hello():
        print("Hello World!")

print_hello()

   Now, you can see that it prints out Hello World!. With functions, you can use them as many times as
   you'd like and include them in the regular flow of code.
def print_hello():
    print("Hello World!")

print_hello()
new_list = [[2, 4, 6], [3, 6, 9], [4, 8, 12]]
for list in new_list:
        for x in list:
                print(x)
                print_hello()

   Because functions are meant to be reusable, they can be used repeatedly with ease. Given that this
   function only contains one line, it's not a great example of the time and space that they save, but
   imagine if the function contained ten or more lines of code. It'd be terrible to have to write all of
   that every time it needed to be used, and it would make your code more prone to mistakes.

4. Passing Data To Functions
   Using functions without giving them anything to work with only utilizes a fraction of their true
   capabilities. Functions are designed to take in data, manipulate it, and return it in a changed form.
   Remember in the past when you gave methods information by adding it to the parenthesis? Well, that's
   how you pass data to a function. So, take a look at how this works.
def square(x):
        return x ** 2

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for number in numbers:
        print(square(number))

   There's a lot going on there. First, in the definition of the function, x is placed in the
   parenthesis. This is called a parameter. Parameters are function specific variables. Notice how x is
   being used in the function without being explicitly defined elsewhere.
   Then, there is the keyword return. It specifies what the function should give out when it's done.
   Because of that, it also immediately ends the function. The next bit might seem somewhat abstract.
   The value of the function itself is the same as what the return statement is. So, in the example,
   print() returns the value of of x ** 2 when given square(number) because the value of square(number)
   is equal to its return statement.
   There is one more major thing going on there. Look at the function call. It is being passed number.
   This is referred to as a function argument. Arguments are given to functions when they are called and
   take the place of the function parameters when they are run.
   Functions can have multiple parameters and take multiple arguments. The order of the parameters
   corresponds directly to the order of the arguments. Make sure they match.
def multiply_numbers(x, y):
        return x * y

print(multiply_numbers(5, 4))

   It really is that simple. Just separate both the parameters and the arguments with a comma.
   One final point should be made about return. It isn't strictly needed. If you want a function that
   takes in information and saves it to a variable or something along those lines, it doesn't need to
   return anything.

5. Conclusion
   Functions are the first step in making programming truly modular. They make your code simpler, easier
   to read, and more reusable. Understanding functions is key to taking your programming skills to a
   more professional level. Practice using functions to reuse code. Also, try combining them with loops,
   lists, and dictionaries to see how you can create powerful yet simple arrangements.

   
---
https://linuxconfig.org/python-classes

Python Classes
24 February 2017

Introduction
   Classes are the cornerstone of Object Oriented Programming. They are the blueprints used to create
   objects. And, as the name suggests, all of Object Oriented Programming centers around the use of
   objects to build programs.
   You don't write objects, not really. They are created, or instantiated, in a program using a class as
   their basis. So, you design objects by writing classes. That means that the most important part of
   understanding Object Oriented Programming is understanding what classes are and how they work.

Real World Examples
   This next part if going to get abstract. You can think of objects in programming just like objects in
   the real world. Classes are then the way you would describe those objects and the plans for what they
   can do.
   Start off by thinking about a car. Car is a fairly general term, but there are some universal
   concepts that you can apply to just about any car. They all have four wheels, a motor, transmission,
   doors, a steering wheel, etc. Additionally, they all have a make and model. Couldn't each of those
   pieces of information be stored in a variable to describe a specific car?
   What about what they can do? Nearly every car can do the same basic things, but they just might do
   them differently or at different speeds. You could then describe the actions that a car can perform
   using functions. In Object Oriented Programming, though, functions are called methods.
   So, if you were looking to use "car" objects in your program, you would create a "car" class to serve
   as a blueprint with all of the variables that you would want to hold information about your "car"
   objects and all of the methods to describe what you would like your cars to be able to do.

A Python Class
   Now that you have a general idea of what a class is, it's best to take a look at a real Python class
   and study how it is structured.
class Car(object):
    make = 'Ford'
    model = 'Pinto'
    year = '1971'
    mileage = 253812

    engine = '4 cylinder'
    transmission = 'manual'
    horsepower = 100

    color = 'orange'

    def move_forward(self, speed):
        print("Moving forward at %s" % speed)


    def move_backward(self, speed):
        print("Moving backward at %s" % speed)

   Creating a class looks a lot like creating a function. Instead of def you use the keyword, class.
   Then, you give it a name, just like you would a function. It also has parenthesis like a function,
   but they don't work the way you think. For a class the parenthesis allow it to extend an existing
   class. Don't worry about this right now, just understand that you have to put object there because
   it's the base of all other classes.
   From there, you can see a bunch of familiar things that you'd see floating around any Python program,
   variables and functions. There are a series of variables with information about the car and a couple
   of methods(functions) describing what the car can do. You can see that each of the methods takes two
   parameters, self and speed. You can see that "speed" is used in the methods to print out how fast the
   car is going, but "self" is different.

What is Self?
   Alright, so "self" is the biggest quirk in the way that Python handles Object Oriented Programming.
   In most languages, classes and objects are just aware of their variables in their methods. Python
   needs to be told to remember them. When you pass "self" to a method, you are essentially passing that
   object to its method to remind it of all of the variables and other methods in that object. You also
   need to use it when using variables in methods. For example, if you wanted to output the model of the
   car along with the speed, it looks like this.
print("Your %s is moving forward at %s" % (self.model, speed))

   It's awkward and odd, but it works, and it's really not worth worrying about. Just remember to
   include "self" as the first parameter of your methods and "self." in front of your variables, and
   you'll be alright.

Using A Class
   You're ready to start using the car class. Create a new Python file and paste the class in. Below,
   you can create an object using it. Creating, or instantiating, an object in Python looks like the
   line below.
mycar = Car()

   That's it. To create a new object, you just have to make a new variable and set it equal to class
   that you are basing your object on.
   Test out your brand new 1971 Ford Pinto. Get your car object to print out its make and model.
print("%s %s" % (mycar.make mycar.model))

   The use of a . between an object and its internal components is called the dot notation. It's very
   common in OOP. It works for methods the same way it does for variables. Try putting your car in
   reverse at 5mph.
mycar.move_backward('5mph')

   What if you want to change the color of your car? You can definitely do that too, and it works just
   like changing the value of any other variable. Try printing out the color of your car first. Then,
   change the color, and print it out again.
print("The color of my car is %s" % mycar.color)
mycar.color = "green"
print("The color of my car is %s" % mycar.color)

   Your car is green now. What about a new car? If you made a new car object, would it be green? Give it
   a shot.
mynewcar = Car()
print("The color of my new car is %s" % mynewcar.color)

   That one's orange. New objects are copied from the class, and the class still says that the color is
   orange. Objects exist in the computer's memory while a program is running. When you change the values
   within an object, they are specific to that object as it exists in memory. The changes won't persist
   once the program stops and won't change the class that it was created from.

Closing Thoughts
   That's enough on classes for now. Obviously, there's a lot more to cover, but you should take some
   time to familiarize with everything covered so far. Try the exercises below to manipulate the "car"
   class and familiarize yourself with how classes and objects work in Python.

Practice

    1. Create a new car object and change its color to red.
    2. Make your car move forward at 15mph.
    3. Put an automatic transmission in your car.
    4. Create a new car. Use a boolean operator to compare the colors of the cars.
    5. Change the move_backward method to include the model of the car.


---
https://linuxconfig.org/python-constructors

Python Constructors
24 February 2017

Introduction
   By now, you should be familiar with the way [24]basic classes work in Python. If classes were just
   what you've seen, they'd be fairly rigid and not all that useful.
   Thankfully, classes are much more than just that. They are designed to be much more adaptable and can
   take in information to shape the way they look initially. Not every car starts off exactly the same,
   and neither should classes. After all, how awful would it be if every car was an orange 71' Ford
   Pinto? That's not a good situation.

Writing A Class
   Start off by setting up a class like the one in the last guide. This class will evolve over the
   course of this guide. It will move from being a rigid, photocopy-like, situation to a template that
   can generate multiple unique objects within the outline of the class.
   Write the first line of the class, defining it as a class and naming it. This guide is going to stick
   with the car analogy from before. Don't forget to pass your class object so that it extends the base
   object class.
class Car(object):

   Below that, indent and create your variables. Usually, class variables are grouped near the top of
   the class and the methods are kept below. It's not strictly mandatory, but it helps to keep the code
   neat. Only create variables for make, model, year, mileage, and color. There's no point in building a
   super detailed class.
make = "Ford"
model = "Pinto"
year = "1971"
mileage = "253812"
color = "orange"

   At this point, you can test out your variables to make sure that your class is working properly.
   Create and object, and try to print out your car's model. Then, reassign the model variable, and
   print it out again.
mycar = Car()
print("My car is a %s" % mycar.model)
mycar.model = "Mustang"
print("My car is a %s" % mycar.model)

   That's an upgrade, but your car still can't do anything. It's time to add a method. Create a new
   method in your class called move_forward that accepts a variable called, "speed." Then, have it print
   out the model of your car and how fast it's going. Don't forget to include self.
def move_forward(self, speed):
        print("Your %s is moving forward at %s" % (self.model, speed))

   Test that out with your class.
mycar.move_forward("25mph")

   Everything should be going well, and your car should be running.

Creating A Constructor
   Changing variables after an object is created is clunky and inefficient. Not only do you waste time,
   but it bloats up your code too. This is especially true if you are creating multiple instances of the
   same class and altering each one.
   There is a concept in Object Oriented Programming called a constructor. Constructors are special
   methods that allow an object to take arguments when it is created and automatically carry out
   actions. They are usually used for assigning variables at the time an object is instantiated.
   In the case of Python, you create a constructor like you would any other method, using dev, but every
   constructor has the same name, __init__. You can think of __init__ as being short for initialize
   because it is run when the object is initialized.
   Create a constructor for your car that takes in all of the variables as parameters and assigns them
   to instance variables with self. An instance variable is just a variable that exists in a specific
   instance of an object.
def __init__(self, make, model, year, mileage, color):
        self.make = make
    self.model = model
    self.year = year
    self.mileage = mileage
    self.color = color

   Make sure to delete the old variable declarations. You don't need them anymore.

Using The Constructor
   Run your code again, and see what happens. If you got an error, you're doing it right. Now, every
   time you create an instance of Car(), you need to pass it enough arguments to match the parameters
   that you specified.
   Go back and modify the instantiation of the mycar to pass it the required arguments.
mycar = Car('Dodge', 'Challenger', '2017', 1500, 'black')

   Run your code again. Everything should work, and you should have a different car running.
   As you already saw, this isn't the perfect system. What if you still want a default template, so you
   don't have to pass in every argument? You can absolutely do that too. You just have to set every
   parameter in your constructor equal to the value that you want to be its default.
def __init__(self, make = 'Ford', model = 'Pinto', year = '1971', mileage = '253812',      color = 'orange'):
    self.make = make
    self.model = model
    self.year = year
    self.mileage = mileage
    self.color = color

   If you create a new instance of Car() and don't pass it anything, it will create your good old Ford
   Pinto again. Try comparing them side by side to see the difference.
mycar = Car()
mynewcar = Car('Dodge', 'Challenger', '2017', 1500, 'black')

mycar.move_forward('25mph')
mynewcar.move_forward('85mph')

Closing Thoughts
   It would suck if every car was a 71' Ford Pinto. It's the same thing for objects. If you had to
   create a new class as a template for every variation of an object, there really wouldn't be any value
   in Object Oriented Programming. Constructors allow classes to be much more fluid and adaptable. You
   can create as many different new instances of an object as you need from the same class without ever
   having to go back and change anything.
   Practice making a new class and adding a constructor, then using that class a bit in your script.

Exercises

    1. Create a new class called "Computer."
    2. Create a constructor for "Computer" that takes four variables.
    3. Print out one of your variables. Reassign its value, and print it again.
    4. Make a method that uses at least two of your variables.
    5. Implement a constructor for "Computer" that accepts all of your variables.
    6. Create a new instance of "Computer" and pass it the correct arguments.
    7. Run your method on the new instance of "Computer."
    8. Add default values to the "Computer" constructor.
    9. Create an empty instance of "Computer."
   10. Run your method on the new empty instance.


---
https://linuxconfig.org/python-encapsulation

Python Encapsulation
27 February 2017

Introduction
   Encapsulation is one of the fundamental aspects of Object Oriented Programming. It allows programmers
   better control of how data flows in their programs, and it protects that data. Encapsulation also
   makes objects into more self-sufficient and independently functioning pieces.
   The concept of encapsulation builds on what you did in the last two guides with classes and
   constructors. Constructors usually are usually used in close conjunction with encapsulation and
   actually aid in making encapsulation work seamlessly.

Access Modifiers
   Before you can take advantage of encapsulation, you have to understand how Python restricts access to
   the data stored in variables and methods.
   Python has different levels of restriction that control how data can be accessed and from where.
   Variables and methods can be public, private, or protected. Those designations are made by the number
   of underscores before the variable or method.

Public
   Every variable and method that you've seen so far with the exception of the constructors has been
   public. Public variables and methods can be freely modified and run from anywhere, either inside or
   outside of the class. To create a public variable or method, don't use any underscores.

Private
   The private designation only allows a variable or method to be accessed from within its own class or
   object. You cannot modify the value of a private variable from outside of a class. Private variables
   and methods are preceded by two underscores. Take a look at the example below.
__make = 'Dodge'

   Try using that class from before. Set the variables in the constructor to private. Then try to print
   one of the variables after an object has been instantiated.
class Car(object):

    def __init__(self, make = 'Ford', model = 'Pinto', year = '1971', mileage = '253812',      color = 'orange
'):
        self.__make = make
        self.__model = model
        self.__year = year
        self.__mileage = mileage

        self.__color = color


    def move_forward(self, speed):
        print("Your %s is moving forward at %s" % (self.__model, speed))


    def move_backward(self, speed):
        print("Moving backward at %s" % speed)


mycar = Car()

print(mycar.__model)


   You will receive an error message stating that the variable doesn't exist. This is because that
   variable is private. Now try running the move_forward method.
mycar.move_forward

   Everything works fine. That's because the variable is being accessed by a method within the class,
   not externally.
   There is a catch here. Python doesn't exactly handle protected variables as well as other object
   oriented languages. Instead of actually protecting variables, it changes the name of them within the
   interpreter. This allows for different copies of the variable to be created and exist. Try changing
   one of the protected variables in your mycar object and printing it out.
mycar.__model = 'Mustang'
print(mycar.__model)

   Now, it seems to work, but what you've printed out is a strange copy of the protected variable. Try
   using the move_forward method again.
mycar.move_forward

   It printed out the original value of __model. The variables exist independently. You can further
   illustrate this by printing out the object as a dictionary. You will see two different variables.
print(mycar.__dict__)

Protected
   Protected variables and methods are very similar to private ones. You probably won't use protected
   variables or methods very often, but it's still worth knowing what they are. A variable that is
   protected can only be accessed by its own class and any classes derived from it. That is more a topic
   for later, but just be aware that if you are using a class as the basis of another one, protected
   variables may be a good option. Protected variables begin with a single underscore.

What Is Encapsulation
   So, now that you know how access modifiers work, this next part is going to seem pretty obvious.
   Encapsulation is the process of using private variables within classes to prevent unintentional or
   potentially malicious modification of data. By containing and protecting variables within a class, it
   allows the class and the objects that it creates to function as independent, self contained, parts
   functioning within the machine of the program itself.
   Through encapsulation variables and certain methods can only be interacted with through the
   interfaces designated by the class itself.

Setters and Getters
   The interfaces that are used for interacting with encapsulated variables are generally referred to as
   setter and getter methods because the are used to set and retrieve the values of variables. Because
   methods exist within a class or object, they are able to access and modify private variables, while
   you will not be able to do so from outside the class. When you instantiated your mycar object, you
   essentially used its constructor as an initial setter method. Try writing a set of methods to set and
   get the value of one of the mycar variables.
def set_model(self, new_model):
        self.__model = new_model

def get_model(self):
        return self.__model

   It might seem like a lot of extra work, but it's really not hard at all. Generally speaking, this is
   how you should structuring your classes and working with class variables.

Closing Thoughts
   Encapsulation is a major part of Object Oriented Programming. It's a big part of what makes objects
   in programming perform more like physical objects in the real world. It also serves to protect the
   data stored within your objects and provides control and conventions for how you should handle the
   flow of data in and out of classes.

Exercises

    1. Make all of the variables in the Car class private.
    2. Try to print one from outside the class.
    3. Modify the move_forward method to use the private variable model, and call it.
    4. Create a setter method for one of the variables.
    5. Use the setter method that you created to change the value of a variable.
    6. Create a getter method for the same variable as the setter method.
    7. Use your getter method to access and print out that variable.


---
https://linuxconfig.org/python-inheritance

Python Inheritance
26 March 2017

Introduction
   Inheritance is yet another key concept in Object Oriented Programming, and it plays a vital role in
   building classes. It allows a class to be based off on an existing one.
   When you first started writing Python classes, you were told to just put "Object" in the parenthesis
   of the class definition and not think too much about it. Well, now's the time to start thinking about
   it.
   "Object" is actually the base class that all Python classes inherit from. It defines a basic set of
   functionality that all Python classes should have. By inheriting from it when you create a new class,
   you ensure that that class has that basic functionality.
   In short, inheritance is a nice way of categorizing classes and making sure that you don't needlessly
   repeat yourself.

What Is Inheritance?
   Inheritance exists in the real world too. The first couple of guides used a car as the example of a
   class. Well, what if you want more specific types of cars that all share those basic principles of a
   car? Inheritance can help.
   You can start out with a basic "Car" class that has all of the properties that every car shares.
   These would all be very general.
   After you have your "Car," you can create new classes and pass them "Car." They will all have the
   same properties as the base "Car" class. Then, you can add any additional properties that you want to
   those more specialized classes. For example, you can have "Truck," "Muscle Car," and "SUV" classes
   that all inherit from "Car."
   When you think about it in real world terms, trucks, muscle cars, and SUVs all have the same basic
   properties as any other car, but they have specialized properties too.
   You can also further specialize. There are tons of different types of trucks. So, you can create more
   specialized classes that inherit from "Truck." The will all start out with everything form "Car" and
   everything from "Truck."

Using Inheritance In Python
   Alright, so now you can try this out with some real code. Set up a basic "Car" class that inherits
   from "Object." Try working with the example below.
class Car(object):
    def __init__(self, make = 'Ford', model = 'Pinto', year = '1971', mileage = 253812, color = 'orange'):
        self.__make = make
        self.__model = model
        self.__year = year
        self.__mileage = mileage
        self.__color = color

    def move_forward(self, speed):
        print("Your %s is moving forward at %s" % (self.__model, speed))

    def move_backward(self, speed):
        print("Moving backward at %s" % speed)


class MuscleCar(Car):
    __hp = 300

    def set_hp(self, hp):
        self.__hp = hp

    def get_hp(self):
        return self.__hp

    def drag_race(self, opponent):
        if (self.__hp > opponent.get_hp()):
            return "You Win!"
        else:
            return "You Lose!"

mynewcar = MuscleCar('Ford', 'Mustang', '2016', 3000, 'red')
mynewcar.set_hp(687)
opponent = MuscleCar('Ford', 'Mustang', '2014', 6400, 'green')
opponent.set_hp(465)

mynewcar.move_forward('25mph')
print(mynewcar.drag_race(opponent))

   Notice that the MuscleCar objects were able to use the constructor and the move_forward method from
   the "Car" class even though the class they were instantiated from doesn't explicitly have them.

Overriding
   Just because a class inherits from another one, you're not stuck with all of the functionality of the
   parent class. You can overwrite parts of the parent class within child classes. The changes applied
   to the child class will not apply to the original parent class, so you don't have to worry about
   messing up any other classes.
   In the example above, the "MuscleCar" just had a variable, __hp just floating there with no way to
   set it on instantiation. Check out the same example, but with the constructor overridden.
class Car(object):
    def __init__(self, make = 'Ford', model = 'Pinto', year = '1971', mileage = 253812, color = 'orange'):
        self.__make = make
        self.__model = model
        self.__year = year
        self.__mileage = mileage
        self.__color = color

    def move_forward(self, speed):
        print("Your %s is moving forward at %s" % (self.__model, speed))

    def move_backward(self, speed):
        print("Moving backward at %s" % speed)


class MuscleCar(Car):
    def __init__(self, make = 'Ford', model = 'Mustang', year = '1965', mileage = 54032, color = 'blue', hp =
325):
        self.__make = make
        self.__model = model
        self.__year = year
        self.__mileage = mileage
        self.__color = color
                self.__hp = hp

    def set_hp(self, hp):
        self.__hp = hp

    def get_hp(self):
        return self.__hp

    def drag_race(self, opponent):
        if (self.__hp > opponent.get_hp()):
            return "You Win!"
        else:
            return "You Lose!"

mynewcar = MuscleCar('Ford', 'Mustang', '2016', 3000, 'red', 687)
opponent = MuscleCar()


mynewcar.move_forward('25mph')
print(mynewcar.drag_race(opponent))

   There are two things to notice. First, __hp has become self.__hp and is incorporated into the
   constructor. Because of this, setting it is much easier. Second, the default values for a new
   "MuscleCar" have been changed. A Pinto isn't a very good default muscle car, is it?
   You can do this with any variable or method in a subclass or child class. It adds an additional
   degree of flexibility and prevents you from being locked into the functionality of the parent or
   super class.

The Super Method
   Sometimes, you need to access the methods found in the parent class from within the child class. Take
   the previous example which overrides that constructor. A lot of that code is redundant. Using super()
   to call the constructor from the "Car" class eliminates that redundancy and makes for a more
   streamlined class.
   super() can also just be used to access regular methods for use in subclass methods. The example
   below used super() both ways.
class Car(object):
    def __init__(self, make = 'Ford', model = 'Pinto', year = '1971', mileage = 253812, color = 'orange'):
        self.__make = make
        self.__model = model
        self.__year = year
        self.__mileage = mileage
        self.__color = color

    def set_make(self, make):
        self.__make = make

    def get_make(self):
        return self.__make

    def set_model(self, model):
        self.__model = model

    def get_model(self):
        return self.__model

    def set_year(self, year):
        self.__year = year

    def get_year(self):
        return self.__year

    def set_mileage(self, mileage):
        self.__mileage = mileage

    def get_mileage(self):
        return self.__mileage

    def set_color(self, color):
        self.__color = color
def get_color(self):
        return self.__color

    def move_forward(self, speed):
        print("Your %s is moving forward at %s" % (self.__model, speed))

    def move_backward(self, speed):
        print("Moving backward at %s" % speed)


class MuscleCar(Car):
    def __init__(self, make = 'Ford', model = 'Mustang', year      = '1965', mileage = 54032, color = 'blue',
hp = 325):
        super().__init__(make, model, year, mileage, color)
        self.__hp = hp


    def set_hp(self, hp):
        self.__hp = hp

    def get_hp(self):
        return self.__hp

    def drag_race(self, opponent):
        if (self.__hp > opponent.get_hp()):
            return "You Win!"
        else:
            return "You Lose!"

    def trade_up(self, year, color):
        super().set_year(year)
        super().set_color(color)
        super().set_mileage(0)

mynewcar = MuscleCar('Ford', 'Mustang', '2016', 3000, 'red', 687)
opponent = MuscleCar()

mynewcar.move_forward('25mph')
print(mynewcar.drag_race(opponent))

mynewcar.trade_up('2017', 'black')
print("My new %s muscle car is %s and has %d miles" % (mynewcar.get_year(), mynewcar.get_color(), mynewcar.get
_mileage()))


   Look at the way the trade_up method makes use of super() to access and call those setter methods from
   the parent class.

Closing Thoughts
   Inheritance allows you to use classes as templates for more specialized classes. You can build out
   classes in such a structure that the begin to resemble a family tree, with the "older" and more
   general members passing on traits to the "younger" more specialized members.
   Much of Object Oriented Programming is reducing the amount of code that is written and preventing as
   much code as possible from being rewritten. Inheritance serves a big role in making this possible.

Exercises

    1. Create a basic class that inherits from the "Car" class.
    2. Instantiate your new class and call one of the methods from "Car."
    3. Create a new methods in your child class.
    4. Call your new method.
    5. Use super() to add variables to your child class's constructor.
    6. Create a method using super() to access the parent class's methods.
    7. Call your new method that uses super().


---
https://linuxconfig.org/python-polymorphism

Python Polymorphism
02 April 2017

Introduction
   Polymorphism is yet another important aspect of Object Oriented Programming. No Warcraft fans, it
   doesn't have anything to do with turning people into sheep. That'd be much cooler. Instead,
   Polymorphism allows methods and functions to use classes with similar functionality in the same way.
   Polymorphism cuts down on the amount of code that you need to write by eliminating redundancy in a
   logical and meaningful way. It relies on you, the programmer, to be clever in your design and harness
   similarities in objects.

What Is Polymorphism?
   Polymorphism is one of those things that's hard to define in a single word or phrase. The term takes
   slightly different forms in different programming languages, making it a bit harder to pin down
   concisely. Generally speaking, and in Python, it's the ability of multiple different objects derived
   from different classes to be used in the same way.
   To use the example of cars that this guide has been working with, imagine that you need to write a
   function that calls the move_forward method on any type of car that it's passed. Every object created
   from the original "Car" class or any of the subclasses that extend it should have a move_forward
   method, even if it's been overridden to do something slightly differently in some of the subclasses.
   This means that through polymorphism, you can write a single function that takes a "Car" object and
   calls move_forward. Since all of the objects instantiated from the subclasses of "Car" are still
   technically "Car" objects and have all of its original properties in some form or another, this will
   work.
   Please note that the specification of a single superclass to use as an object type is not entirely
   necessary in Python. Python is not strongly typed, so you don't have to explicitly define which
   variable types a method or function takes. In languages like Java, this plays a role in how
   polymorphism behaves. However, in Python, it's a good idea to think of it along these lines to ensure
   that the objects that you pass will all have the method or property being used.

Using It In Python
   Now, it would really help to see all of this in action. It's not as complex as you're probably
   thinking right now. First, make sure you're set up with the example classes. If you don't already
   have them, they're right below.
class Car(object):
    def __init__(self, make = 'Ford', model = 'Pinto', year = '1971', mileage = 253812, color = 'orange'):
        self.__make = make
        self.__model = model
        self.__year = year
        self.__mileage = mileage
        self.__color = color

    def set_make(self, make):
        self.__make = make

    def get_make(self):
        return self.__make

    def set_model(self, model):
        self.__model = model

    def get_model(self):
        return self.__model

    def set_year(self, year):
        self.__year = year

    def get_year(self):
        return self.__year

    def set_mileage(self, mileage):
        self.__mileage = mileage

    def get_mileage(self):
        return self.__mileage

    def set_color(self, color):
        self.__color = color
        def get_color(self):
        return self.__color

    def move_forward(self, speed):
        print("Your %s is moving forward at %s" % (self.__model, speed))

    def move_backward(self, speed):
        print("Moving backward at %s" % speed)


class MuscleCar(Car):
    def __init__(self, make = 'Ford', model = 'Mustang', year = '1965', mileage = 54032, color = 'blue', hp =
325):
                super().__init__(make, model, year, mileage, color)
        self.__hp = hp

    def set_hp(self, hp):
        self.__hp = hp

    def get_hp(self):
        return self.__hp

    def drag_race(self, opponent):
        if (self.__hp > opponent.get_hp()):
            return "You Win!"
        else:
            return "You Lose!"

    def trade_up(self, year, color):
        super().set_year(year)
        super().set_color(color)
        super().set_mileage(0)

   With the demo classes set up, you can test out a quick function that uses polymorphism to call
   move_forward.
newmusclecar = MuscleCar()
newcar = Car()

def go_25(car_object):
        car_object.move_forward("25mph")

go_25(newcar)
go_25(newmusclecar)

   Both function calls behave exactly the same, even though they were passed different objects that were
   created from different classes. Thanks to polymorphism, you don't have to write two different
   functions and can use the similar properties of the objects to write only one function.
   Try overriding one of the move_forward method in the "MuscleCar" class. Run the function again, and
   see what happens.

class MuscleCar(Car):
        

        def move_forward(self, speed):
        print("Your awesome %s is roaring down the road  at %s" % (self.__model, speed))

        


   When the function calls the move_forward method on the muscle car object, it still works perfectly,
   and the overridden version of the method is used.

Closing Thoughts
   Polymorphism sounds like it would be a terribly complex concept, but its name is somewhat of a
   misdirect. The concept itself isn't all that intimidating, and it even helps to simplify the overall
   structure of your code.
   A common theme in Object Oriented Programming is the elimination of redundancy through the reusable
   and adaptable code. Polymorphism is an important part of that picture.

Exercises

    1. Use the example classes to instantiate a "Car" object and a "MuscleCar" object.
    2. Create a function that can interact with either type of "Car" object.
    3. Call your function twice, passing it both objects.
    4. Override one of the methods in the MuscleCar class. Be sure not to change the parameters that it
       accepts to drastically.
    5. Call your function again.
    6. Create a new class that inherits from the "Car" class.
    7. Instantiate a new object from your newly created class. Pass the object to your function.


---
https://linuxconfig.org/python-packages-and-modules

Python Packages and Modules
02 April 2017

Introduction
   Whenever you need some additional functionality in Python, you turn to the import keyword to pull in
   extras from Python modules. You've used common ones like the math module plenty of times.
   Now, you will learn how to create your own Python modules and packages to compartmentalize your code.
   Modules are sort of like classes in that they make your code modular. While classes make code modular
   within a program and serve as the blueprints for objects, modules make all of your code modular
   across all programs and are utilities to be used just as they are.
   Through the use of modules, you can create your own toolbox with all sorts of parts and pieces that
   you commonly use. Modules can include anything from variables and constants to functions and even
   classes. Because of this versatility, you can set yourself up to have everything that you need at the
   beginning of any project.

Writing a Module
   Writing a module isn't difficult at all. Modules are actually just Python files. There isn't anything
   special about them. They are just structured differently because they serve as more of a toolkit or
   storage than a flowing and functioning program.
   Before you start writing a module, it's a good idea to set up a directory to work in. Unless the
   module is installed in your system Python installation, the path of the module is important.
   In your directory, create two files, mathstuff.py and test.py.
   Open up mathstuff.py and put the following far-from-perfect functions in it.
import math

def pythag(a, b):
    return math.sqrt(a + b)

def quadratic(a, b, c):
    x1 = (-1*b + math.sqrt(b**2 - 4*a*c)) / (2*a)
    x2 = (-1*b - math.sqrt(b**2 - 4*a*c)) / (2*a)
    return [x1, x2]


   Take notice that there's an import here too. You can import other modules in a module and use those
   statements as an easy way to handle dependencies.
   That's actually all that you need to write a Python module. This module is very simple, but you can
   clearly see what it does. If you were going to write a program that required a lot of functions to
   solve specific equations, you could create a module to hold the functions that you commonly use.

Importing Your Module
   Head over to your test.py. Open it up and enter some code to make use of the module that you just
   created.
from mathstuff import quadratic

x_vals = quadratic(10, 18, 6)

for x in x_vals:
    print(x)


   Like any of the other modules that you've used so far, you can use import to pull it in. You can also
   use from to select only the parts that you need.
   From there, you can just call the functions that you imported like they were written in the same file
   as the rest of your program.
   This example used functions because they're the most common use case, but you can just as easily work
   with classes or variables, and it will be exactly the same.

Organizing With Packages
   In larger projects, there is a very good chance that a single module file is not going to be a good
   fit. A file can quickly fill up with loads of functions and balloon to an unmanageable size. This is
   where packages come in.
   Python treats packages just like it would modules, but packages allow you to be more organized in
   your programming, and in more advanced instances, distribute your Python code on repositories.
   Packages can just be storage structures where you categorize your functions, classes, and variables
   in different files and sort them by their use case or functionality. They can also be complete pieces
   of functionality that are pre-built and ready to use. Imagine that you are a freelance developer, and
   your clients are always asking for a similar piece of functionality to send emails from their
   applications. You can create a package that contains all of that email functionality and plug it in
   to each project. It saves you a ton of time, and it could save your clients money. In this case,
   using packages is an all-around win.
   A Python package, in the most basic sense, is just a folder with a Python file in it called,
   __init__.py. That file doesn't have to contain anything. It just lets Python know to treat that
   folder as a package, which just acts like a big module.
   Try creating a package using the module you've already made. Make a new directory where you are,
   create the __init__.py in it, and move your mathstuff.py in too.
$ mkdir mathstuff
$ touch mathstuff/__init__.py
$ mv mathstuff.py mathstuff/

   If you run your test.py again, it'll still work. Files in packages with the same name can be imported
   with just their name. Change the name of the mathstuff.py file. It won't work anymore. To use other
   files within a package, you need to import them with the dot notation.
from package.file import function

   Try reconfiguring your import statement and try again. It will work as well as it did before.

Closing Thoughts
   The use of modules and packages can help you organize your code and keep everything modular reusable.
   They can also go a long way to de-clutter your code and boost readability.

Exercises

    1. Create a new module with a couple of functions in it.
    2. Create a file to import and run the functions from your module and do so.
    3. Convert your module into a package. Adjust your imports accordingly.


---
https://linuxconfig.org/reading-and-writing-files-with-python

Reading And Writing Files With Python
01 May 2017

Introduction
   Jut about any program of a decent size needs to be able to read and write from files. At very least,
   it needs to be able to generate logs. Python is also tightly integrated into Linux system
   administration and scripting. Again, reading and writing are important for managing a system.

Opening A File
   Python creates and object from the file that it opens. It can then manipulate that object. When it's
   done, it uses the object to save the any changes back to the file. Create a new text file and fill it
   with nonsense from your text editor. Be sure to include multiple lines of text. Now, create a Python
   file to work in. In that file, you can use Python's open function to open the file and create an
   object with it.
file = open('test.txt', 'r+')

   file is now an object that holds the information on the file. It can be both read and written. As you
   can see, the open() function takes two arguments. The first is the path to the file that needs to be
   opened, and the second is the mode that it will be opened in. There are a number of modes, but there
   are only a few that you'll use frequently.
            Modes
   Read                    r  Only read from the file
   Write>                  w  Erase and write to a file
   Append                  a  Add new lines to the end of a file
   Read & Write            r+ Read and write to a file without overwriting it
   Write & Read(Overwrite) w+ Write and read a file, overwriting its contents

Reading A File
   Take your file object for a test drive. Add a line in that calls the read() method.
file.read()

   The read method outputs the entire contents of the file into the command line. It's similar to using
   cat. Reading the file shows each line as a string with a newline character at the end. The last line
   appears as an empty string, ''.
   There is another method that you can use to grab individual lines, the readline() method. readline()
   starts at the beginning of a file and reads each line out individually each time it is called.
   Try removing the read() line from your file and calling readline() multiple times instead.
for x in range(1, 11):
        file.readline()

   If you had less than ten lines, you probably noticed a bunch of blank strings. That's what readline()
   spits out whenever it goes beyond the number of lines in a file.

Writing A File
   Writing to a file is even easier. All that you need to do to write to a file is call the write()
   method and pass it the string that you want written to the end of the file. write() will always write
   new lines to the end of the file.
file.write("I'm a new line!")

   You can write to a file as many times as you need to. Each time the write() method is called, it
   creates a new line, making it ideal for logging.

Seek
   As of now, you don't have any real control of the flow through the file. The seek() method gives you
   some of that back.
   It takes two numbers as arguments and allows you to move through the file in both directions. The
   first number is the position that you want the invisible pointer in the file to reverence. If you
   pass in a three, it'll be located after the third character. The second number is the place where you
   want it to start from. A value of 1 in the second place will cause the method to seek from he
   pointer's current position. A 2 would be then end of the file.
   Try using seek() and readline() together.
file.seek(15, 0)
file.readline()

   Python will print out from fifteen characters in to the end of the line where that point falls.

Closing the File
   When you're done working with a file, you have to close it in order for changes to be applied and for
   memory to be freed up. You can cloe a file by calling the close() method on the object.
file.close()

Closing Thoughts
   Now you can use Python to collect information from a file. You can also write output to a file. This
   opens up plenty of opportunity to use and store information from text files.

Exercises

    1. Create a text file with at least 10 lines.
    2. In Python, open the file as both readable and writable without overwriting it.
    3. Read the file in Python.
    4. Reset the invisible pointer in the file to the beginning.
    5. Read only the first two lines of the file.
    6. Reset to the beginning again.
    7. Read only the seventh and ninth lines.
    8. Write two new lines to the file.
    9. Close your file.


---
https://linuxconfig.org/python-lambdas

Python Lambdas
03 May 2017

Introduction
   You've worked with both functions and methods, but there's a different type of function, the
   anonymous function. Anonymous functions are just functions without names, and in Python, they are
   handled with the lambda operator.
   Anonymous functions allow you to use the behavior of a function without having to create a function.
   This is especially good when you only need to use a function once or twice. It might sound like an
   unusual occurrence, but it happens fairly frequently when a function or method takes a function as a
   parameter.

Lambdas
   The Lambda operator has a few basic parts. It consists of lambda, a list of parameters, and an
   operation. The operation is separated from the other two with a colon. Check out this example.
foo = lambda a=2, b=1 : a / b
print(foo)
print(foo(16, 4))

   If you're using lambdas in a standalone capacity, you can set them equal to a variable. In this form,
   they aren't that versatile, but they can still play a role in creating functions on the fly.
   Lambdas really find their use in being passed to other functions. See how it works in the example
   below.
def do_something(function, list_a, list_b):
        for x in list_a:
                for y in list_b:
                        function(x, y)

do_something(lambda x, y : print(x*y), [1, 3, 5], [2, 4, 6])

   Of course, this example isn't all that practical. It does illustrate the point, though. You can
   create a lambda within a function call to pass it as an argument to another function.

Map
   The map() function is an interesting one. It allows you to iterate simultaneously over one or more
   lists and pass them to a function. It's very easy for that function to be a lambda expression.
   This example can help clarify.
print(list(map(lambda x, y : x * y, [1, 2, 3, 4, 5], [2, 4, 6, 8, 10])))

   That looks like a mess, so it's best to break it down. The main chunk starts with map. It takes at
   least two arguments, a function and a list. It can take multiple lists, though, and this time there
   are two. It also takes a lambda expression that accepts two arguments and multiplies them together.
   The map function runs through those lists. It sets each element in the first list in the first
   argument of the function and each element in the second list in the second function argument. It runs
   the function each time. The map() function returns a map object.
   That map object needs to be converted into a more usable form. The list() function turns the object
   into a regular list. Then, print() prints out that list.
   Take a look at another one.
print(list(map(lambda x : x*2, [1, 2, 3, 4, 5])))

   The simpler example might be easier to follow.

Filter
   The filter() function is another function similar to map(). It takes a function and a list as
   arguments and iterates over the list, running the elements through the function.
   Instead of just running a function, filter() uses the function as a test condition for the elements
   in the list. The object that it creates contains all of the elements where the condition evaluated
   "True."
print(list(filter(lambda x : x > 5, [2, 4, 6, 8])))

   The resulting list only contained 6 and 8 because those were the two conditions where the condition
   given in the function evaluated "True." filter(), when used in conjunction with a lambda expression,
   is an efficient way to sort through and test lists against a condition.

Closing Thoughts
   Lambdas aren't the most popular topic in Python. Many developers don't even like them. Even Python's
   creator isn't a fan.
   If you happen to like them, great. If not, don't worry. There are alternatives that will be discussed
   in later guides.
   For now, it's just important to be aware of lambdas and how they work. You will encounter them from
   time to time, and they can be the easiest solution.

Exercises

    1. Create a lambda expression that multiplies two numbers and set it equal to a variable.
    2. Use that variable to call the lambda and pass it two numbers.
    3. Write a function that takes a function as a parameter. Call that function with and pass it a
       lambda.
    4. Use the map() function along with a lambda to add each element in two lists.
    5. Use the filter() function along with a lambda to test if each element in a list is odd.


---
https://linuxconfig.org/python-os-module

Python OS Module
10 May 2017

Introduction
   Python is a powerful scripting language. So, why not use it to script Linux? The os module is
   Python's answer to handling many Linux file operations.
   The os module allows Python to perform many of the file and folder operations that you'd typically
   carry out in the Linux command line. It enable you to begin swapping out Bash for Python, which makes
   for a much cleaner and friendlier scripting experience.

Loading OS
   The os module is a Python module like any other. In any script where you want to use it, you can use
   an import statement to pull it in.
import os

getcwd()

   The getcwd() method returns the current working directory in the form of a string. You don't need to
   pass it anything. It's roughly the equivalent of pwd.
print(os.getcwd())

chdir()

   chdir() is the Python equivalent of cd. Call the method and pass it the directory that you want to
   change to as a string.
os.chdir('/home/user/Documents')

   It also supports using relative paths just like cd.
os.chdir('../Downloads')

listdir()
   Using listdir() is very similar to running ls in Bash. There is one big difference, though, the
   return value.
   Instead of printing out the contents of the directory, you receive them back as a list.
download_list = os.listdir('Downloads')
print(download_list)

   Again, you can specify the directory, or it will list the contents of the current directory.

mkdir() and makedirs()

   These two are exactly what you'd expect them to be. mkdir() works very similarly to the Linux command
   that you know. In this instance, it can take a second parameter to specify permissions.
os.mkdir('testdir', 755)

   The makedirs() method works the same way, but can create directories recursively within each other,
   eliminating the need to run mkdir() multiple times.
os.makedirs('testdir2/something/somethingelse', 755)

   Once again, you can specify the permissions, if you want to.

chmod()

   This is once again a straightforward equivalent to it's traditional counterpart. chmod() for Python
   takes two arguments. The first is the directory to change, and the second is the permissions to
   change to.
os.chmod('test', 774)

chown()
   You can also change ownership with Python. chown() is the way you do it. The method is very similar
   to the Linux command, but it requires user and group ids to work.
os.chown('test', 1000, 1000)

   That command will change the ownership of the "test" directory to the user with an id of 1000 and the
   group with an id of 1000.

remove() and removedirs()
   remove() removes a single file that it's passed. You can also pass it the complete path to the file.
os.remove('/home/user/Downloads/somefile')

   To remove directories, use the removedirs() method. It will remove the specified directory and all of
   its contents.
os.removedirs('test_dir')

system()
   So, the last method here is the most powerful and also the most dangerous. The system() method is
   cheating. It lets you run any Linux system command that you pass to it.
   There are a couple of concerns here. First, to run the method, Python opens its own console. Using
   system() too much is inefficient and can hog resources. More importantly, system() can run anything.
   That means it can do some serious damage. If you're going to use system() use it sparingly and under
   controlled circumstances.
   Try running a command through system().
print(os.system(ls -lah))

   You can also get sort of creative with it and even pipe together commands like you would in a normal
   terminal.
print(os.system(ps aux | grep firefox))

   If you have Firefox running, the command will find the process and print out information on it.

Closing Thoughts
   You've taken the first step towards scripting your Linux system with Python. There are more tools
   that Python offers, and things get get very complicated in this space. Popular automation tools like
   Ansible and Salt are made with Python, so there really isn't a limit to what it can do.

Exercises
    1. Print your current directory using Python.
    2. Change into a different directory and print that one.
    3. Create a loop that iterates over the contents of a directory and prints each one individually.
    4. Create a new directory with a directory within it and another a step down.
    5. Change the permissions of your new directory so the owner can read write and execute, and
       everyone else can only read and execute.
    6. Delete the two subdirectories.
    7. Use Python to create a text file that lists all of the processes that your user is currently
       running.

       
---
https://linuxconfig.org/python-exception-handling

Python Exception Handling
18 May 2017

Introduction
   Python will let you know when you get your syntax wrong. It'll immediately fail and not allow your
   program to run.
   What about when your code has a different type of problem? Those are called exceptions, and they tend
   to be harder to catch. It's up to you to recognize situations where hey might come up and catch them
   to prevent your program from crashing altogether.
   Imagine a scenario where you need user input. Do you want your program to crash every time a user
   mistypes something or enters something erroneous? That's far from ideal. Since you know there could
   be a problem there, you can tell Python to look out for one, and recover gracefully.

Try and Except
   When you know there's a chance an exception will pop up, you ask Python to try the piece of code and
   look out for an exception. Take a look at it in the context of the number example from before.
try:
        number = int(input("Enter any number: "))
except:
        print("That didn't work")

   Now, instead of crashing, you program will continue, even if the user enters garbage.
   You can also tell Python exactly what type of exception to look for. In this case, it would be a
   ValueError.
try:
        number = int(input("Enter any number: "))
except ValueError:
        print("You didn't enter a number!")

   If Python knows what type of exception it's looking for, you can tell it how to respond accordingly.

Make Your Own
   You can make your own exceptions by writing them as classes that inherit from the Exception base
   class or any one of the other exception classes.
class NewException(Exception):
        pass

   You have to build into your program how to use your custom exceptions.

Raising Exceptions
   There is an option to manually raise exceptions with raise.
try:
        raise NewException
except NewException:
        print("It failed as planned!")

Multiple Excepts
   If you're expecting that there could be more than one exception, you can built multiples in with try.
   Start off by making a couple of custom exceptions.
class ExceptionA(Exception):
        pass

class ExceptionB(Exception):
        pass

   Now, use them with try.
try:
        raise ExceptionB
except (ExceptionA, ExceptionB):
        print("It was either A or B")

   Of course, that's not the best because in a real scenario, you wouldn't know which exception actually
   occurred. Try using separate except clauses instead.
try:
        raise ExceptionB
except ExceptionA:
        print("ExceptionA Occurred")
except ExceptionB:
        print("ExceptionB Occurred")
except:
        print("Something else happened")

   The third except acts to catch any other exception. That's the default behavior when a specific
   exception isn't given.

Else and Finally
   There are two additional clauses for handling what happens after exceptions are handled. They help
   your code respond to exceptions.
   The else clause allows you to run code only if an exception hasn't been raised.
try:
        number = int(input("Enter any number: "))
except ValueError:
        print("You didn't enter a number!")
else:
        print(number ** 2)

   You only want to try performing an operation on the number if one is entered.
   The finally cause will run regardless of any exceptions. It will always run at the end of the try
   block.
try:
        number = int(input("Enter any number: "))
except ValueError:
        print("You didn't enter a number!")
else:
        print(number ** 2)
finally:
        print("This will always run.")

Closing Thoughts
   It's important to understand what can go wrong with your programs. It's just as important to know
   that thing will go wrong. By accounting for exceptions, you can make your code as stable as possible
   and not frustrate your users.

   
---
