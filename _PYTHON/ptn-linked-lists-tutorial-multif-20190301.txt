filename: ptn_linked-lists_tutorial-multif_20190301.txt
https://stackabuse.com/linked-lists-in-detail-with-python-examples-single-linked-lists/

Linked Lists in Detail with Python Examples: Single Linked Lists
February 04, 2019

   Linked lists are one of the most commonly used data structures in any programming language. In this
   article, we will study linked lists in detail. We will see what are the different types of linked
   lists, how to traverse a linked list, how to insert and remove elements from a linked list, what are
   the different techniques to sort a linked list, how to reverse a linked list and so on.

   After reading this article, you should be able to crack all the [9]linked list interview questions.

What is a Linked List?
   Before we study what are linked lists, let's first briefly review how Arrays store data. In arrays,
   the data is stored at contiguous memory locations. For instance, if the first item in the array is
   stored at index 10 of the memory and is of size 15 bytes, the second item will be stored at index
   10+15+1 = 26th index. Therefore, it is straight forward to traverse an array.

   To find the third item in an array, you can simply use the starting index of the first item, plus the
   size of the first item, plus the size of the second item, plus 1.

How Linked Lists Store Data
   Linked Lists, on the other hand, are different. Linked lists, do not store data at contiguous memory
   locations. For each item in the memory location, linked list stores value of the item and the
   reference or pointer to the next item. One pair of the linked list item and the reference to next
   item constitutes a node.

   For instance, if a node consists of 34|10, it means that the value of the node is 30, while the next
   item is stored at the memory location "10". In order to traverse a linked list, you just need to know
   the memory location or reference of the first node, the rest of nodes can be sequentially traversed
   using the reference to the next element in each node.

   The reference to the first node is also known as the start node.

Linked Lists vs Arrays:
     * A linked list is a dynamic data structure which means that the memory reserved for the link list
       can be increased or reduced at runtime. No memory is allocated for a linked list data structure
       in advance. Whenever a new item is required to be added to the linked, the memory for the new
       node is created at run time. On the other hand, in case of the array, memory has to be allocated
       in advance for a specific number of items. In cases where sufficient items are not available to
       fill all array index, memory space is wasted.
     * Since arrays require contiguous memory locations, it is very difficult to remove or insert an
       item in an array since the memory locations of a large number of items have to be updated. On the
       other hand, linked list items are not stored in a contiguous memory location, therefore you can
       easily update linked lists.
     * Owing to its flexibility, a linked list is more suitable for implementing data structures like
       stacks, queues, and lists.

   However, there are some downsides to the linked list as well.
     * Since each linked list item has to store the reference to the next item, some extra memory is
       required.
     * Unlike Arrays, where you can directly access an item, you cannot access a linked list item
       directly since the only information you have is the reference to the first item. In Big-O
       terms, worst-case access time is O(n).

   In this series of articles, we will study the following types of linked lists along with their
   different functionalities.
     * Single Linked List
     * Doubly Linked List
     * Circular Linked List
     * Linked List with Header
     * Sorted Linked List

   In this first part of the article, we will focus on single linked list and its different operations.

Single Linked List
   A single linked list is the simplest of all the variants of linked lists. Every node in a single
   linked list contains an item and reference to the next item and that's it.

   In this section, we will see how to create a node for the single linked list along with the functions
   for different types of insertion, traversal, and deletion.

Creating the Node Class
   The first thing that you need to do is to create a class for the nodes. The objects of this class
   will be the actual nodes that we will insert in our linked list. We know that a node for a single
   linked list contains the item and the reference to the next node. Therefore, our node class will
   contain two member variables item and ref. The value of the item will be set by the value passed
   through the constructor, while the reference will be initially set to null.

   Execute the following script:
class Node:
    def __init__(self, data):
        self.item = data
        self.ref = None

Creating the Single Linked List Class
   Next, we need to create a class for the Linked List. This class will contain the methods to insert,
   remove, traverse and sort the list. Initially, the class will only contain one member start_node that
   will point to the starting or first node of the list. The value of start_node will be set to null
   using the constructor since the linked list will be empty at the time of creation. The following
   script creates a class for the linked list.
class LinkedList:
    def __init__(self):
        self.start_node = None

   Now we have created a class for our single list. The next step is to add insertion function to insert
   items into the linked list. But before that, we will add a function to traverse a linked list. This
   function will help us read the data in our list.

Traversing Linked List Items
   The Python code for the traverse function is as follows. Add the function below to the LinkedList
   class that we created in the last section.
def traverse_list(self):
    if self.start_node is None:
        print("List has no element")
        return
    else:
        n = self.start_node
        while n is not None:
            print(n.item , " ")
            n = n.ref

   Let's see what is happening in the above function. The function has two main parts. First, it checks
   whether the linked list is empty or not. The following code checks that:
  if self.start_node is None:
        print("List has no element")
        return

   If the linked list is empty, that means there is no item to iterate. In such cases, the
   traverse_list() function simply prints the statement that the list has no item.

   Otherwise if the list has an item, the following piece of code will execute:
    n = self.start_node
        while n is not None:
            print(n.item , " ")
            n = n.ref

   As we said earlier, the start variable will contain a reference to the first nodes. Therefore, we
   initialize a variable n with start variable. Next, we execute a loop that executes until n becomes
   none. Inside the loop, we print the item stored at the current node and then set the value of n
   variable to n.ref, which contains the reference to the next node. The reference of the last node is
   None since there is no node after that. Therefore, when n becomes None, the loop terminates.

   Now, we have a function to traverse a linked list, let's see how we can add items to a single linked
   list.

Inserting Items
   Depending upon the location where you want to insert an item, there are different ways to insert
   items in a single linked list.

Inserting Items at the Beginning
   The simplest way to insert an item in a single linked list is to add an item at the start of the
   list. The following function inserts item at the start of the list. Add this function to the
   LinkedList class that we created earlier.
    def insert_at_start(self, data):
        new_node = Node(data)
        new_node.ref = self.start_node
        self.start_node= new_node

   In the script above, we create a method insert_at_start(), the method accepts one parameter, which is
   basically the value of the item that we want to insert. Inside the method, we simply create an object
   of the Node class and set its reference to the start_node since start_node was previously storing the
   first node, which after insertion of a new node at the start will become the second node.

   Therefore, we add the reference of start_node to the ref variable of the new node. Now since the
   new_node is the first node, we set the value of the start_node variable to new_node.

Inserting Items at the End
   The following function is used to add an item at the end of the linked list.
  def insert_at_end(self, data):
        new_node = Node(data)
        if self.start_node is None:
            self.start_node = new_node
            return
        n = self.start_node
        while n.ref is not None:
            n= n.ref
        n.ref = new_node;

   In the above script, we create a function insert_at_end(), which inserts the element at the end of
   the linked list. The value of the item that we want to insert is passed as an argument to the
   function. The function consists of two parts. First we check if the linked list is empty or not, if
   the linked list is empty, all we have to do is set the value of the start_node variable to new_node
   object.

   On the other hand, if the list already contains some nodes. We initialize a variable n with the start
   node. We then iterate through all the nodes in the list using a while loop as we did in the case of
   traverse_list function. The loop terminates when we reach the last node. We then set the reference of
   the last node to the newly created new_node.

   Add the insert_at_end() function to the LinkedList class.

Inserting Item after another Item
   We may need to add item after another item in a single linked list. To do so, we can use the
   insert_after_item() function as defined below:
    def insert_after_item(self, x, data):

        n = self.start_node
        print(n.ref)
        while n is not None:
            if n.item == x:
                break
            n = n.ref
        if n is None:
            print("item not in the list")
        else:
            new_node = Node(data)
            new_node.ref = n.ref
            n.ref = new_node

   The insert_after_item() function accepts two parameters: x and data. The first parameter is the item
   after which you want to insert the new node while the second parameter contains the value for the new
   node.

   We start by creating a new variable n and assigning start_node variable to it. Next, we traverse
   through the linked list using while loop. The while loop executes until n becomes None. During each
   iteration, we check if the value stored in the current node is equal to the value passed by the x
   parameter. If the comparison returns true, we break the loop.

   Next, if the item is found, the n variable will not be None. The reference of the new_node is set to
   reference stored by n and the reference of n is set to new_node. Add the insert_after_item() function
   to the LinkesList class.

Inserting Item before another Item
    def insert_before_item(self, x, data):
        if self.start_node is None:
            print("List has no element")
            return

        if x == self.start_node.item:
            new_node = Node(data)
            new_node.ref = self.start_node
            self.start_node = new_node
            return

        n = self.start_node
        print(n.ref)
        while n.ref is not None:
            if n.ref.item == x:
                break
            n = n.ref
        if n.ref is None:
            print("item not in the list")
        else:
            new_node = Node(data)
            new_node.ref = n.ref
            n.ref = new_node

   In the script above we define the insert_before_item() function. The function has three parts. Let's
   look at each part in detail.
     if self.start_node is None:
        print("List has no element")
        return

   In the script above, we check if the list is empty. If it is actually empty, we simply print that the
   list has no element and return from the function.

   Next, we check if the element is located at the first index. Look at the following script:
     if x == self.start_node.item:
        new_node = Node(data)
        new_node.ref = self.start_node
        self.start_node = new_node
        return

   If the element after which we want to insert a new node is located at the first index. We simply set
   the reference of the newly inserted node to the start_node and then set the value of start_node to
   new_node.

   Finally, if the list is not None and the element is not found at the first index, we create a new
   variable n and assign start_node variable to it. Next, we traverse through the linked list using
   while loop. The while-loop executes until n.ref becomes None. During each iteration, we check if the
   value stored in the reference of the current node is equal to the value passed by the x parameter. If
   the comparison returns true, we break the loop.

   Next, if the item is found, the n.ref variable will not be None. The reference of the new_node is set
   to reference of n and the reference of n is set to new_node. Look at the following script:
    if n.ref is None:
        print("item not in the list")
    else:
        new_node = Node(data)
        new_node.ref = n.ref
        n.ref = new_node

   Add insert_before_item() function to the LinkedList class.

Inserting Item at Specific Index
   Sometimes, we need to insert item at a specific index, we can do so with the help of the following
   script:
    def insert_at_index (self, index, data):
        if index == 1:
            new_node = Node(data)
            new_node.ref = self.start_node
            self.start_node = new_node
        i = 1
        n = self.start_node
        while i < index-1 and n is not None:
            n = n.ref
            i = i+1
        if n is None:
            print("Index out of bound")
        else:
            new_node = Node(data)
            new_node.ref = n.ref
            n.ref = new_node

   In the script, we first check if the index that we want to store item to is 1, then simply assign
   start_node to the reference of the new_node and then set the value of start_node to new_node.

   Next, execute a while loop which executes until the counter i becomes greater than or equal to the
   index-1. For instance, if you want to add a new node to the third index. During the first iteration
   of the while loop, i will become 2 and the currently iterated node will be '2'. The loop will not
   execute again since i is now 2 which is equal to index-1 (3-1=2). Therefore, the loop will break.
   Next, we add a new node after the currently iterated node (which is node 2), hence the new node is
   added at index.

   It is important to mention that if the index or the location passed as argument is greater than the
   size of the linked list, a message will be displayed to the user that index is out of range or out of
   bound.

Testing Insertion Functions
   Now we have defined all our insertion functions, let's test them.

   First, create an object of the linked list class as follows:
new_linked_list = LinkedList()

   Next, let's first call the insert_at_end() function to add three elements to the linked list. Execute
   the following script:
new_linked_list.insert_at_end(5)
new_linked_list.insert_at_end(10)
new_linked_list.insert_at_end(15)

   To see, if the items have actually been inserted, let's traverse through the linked list using
   traverse function.
new_linked_list.traverse_list()

   You should see the following output:
5
10
15

   Next, let's add an element at the start:
new_linked_list.insert_at_start(20)

   Now, if you traverse the list, you should see the following output:
20
5
10
15

   Let's add a new item 17 after item 10:
new_linked_list.insert_after_item(10, 17)

   Traversing the list returns the following output now:
20
5
10
17
15

   You can see 17 inserted after 10.

   Let's now insert another item 25 before the item 17 using insert_before_item() function as shown
   below:
new_linked_list.insert_before_item(17, 25)

   Now the list will contain the following elements:
20
5
10
25
17
15

   Finally, let's add an element at the third location, which is currently occupied by 10. You will see
   that 10 will move one location forward and the new item will be inserted at its place. The
   insert_at_index() function can be used for this purpose. The following script inserts item 8 at index
   the third index of the list.
new_linked_list.insert_at_index(3,8)

   Now if you traverse the list, you should see the following output:
20
5
8
10
25
17
15

   And with that, we have tested all of our insertion functiond. We currently have 7 elements in our
   list. Let's write a function that returns the number of elements in a linked list.

Counting Elements
   The following function counts the total number of elements.
    def get_count(self):
        if self.start_node is None:
            return 0;
        n = self.start_node
        count = 0;
        while n is not None:
            count = count + 1
            n = n.ref
        return count

   In the script above we create get_count() function which simply counts the number of elements in the
   linked list. The function simply traverses through all the nodes in the array and increments a
   counter using while loop. At the end of the loop, the counter contains total number of elements in
   the loop.

   Add the above function to the LinkedList class, compile the LinkedList class and then insert some
   elements in the LinkedList as we did in the last section. We had 7 items in our linked list, by the
   end of the last section.

   Let's use the get_count() function to get the total number of items in the list:
new_linked_list.get_count()

   You should see the number of items in your linked list in the output.

   Alternatively, another way to get the 'count' of the list would be to track the number of items
   inserted and removed from the list in a simple counter variable belonging to the LinkedList class.
   This works well, and is faster than the get_count method above, if the underlying list data structure
   can not be manipulated from outside the class.

Searching Elements
   Searching for an element is quite similar to counting or traversing a linked list, all you have to do
   is to compare the value to be searched with the value of node during each iteration. If the value is
   found, print that the value is found and break the loop. If the element is not found after all the
   nodes are traversed, simply print that the element not found.

   The script for the search_item() is as follows:
    def search_item(self, x):
        if self.start_node is None:
            print("List has no elements")
            return
        n = self.start_node
        while n is not None:
            if n.item == x:
                print("Item found")
                return True
            n = n.ref
        print("item not found")
        return False

   Add the above function to the LinkedList class. Let's search an element in the previously created
   list. Execute the following script:
new_linked_list.search_item(5)

   Since we inserted 5 in our linked list, the above function will return true. The output will look
   like this:
Item found
True

Creating a Linked List
   Though we can add items one by one using any of the insertion functions. Let's create a function that
   asks the user to enter the number of elements in the node and then the individual element and enters
   that element in the linked list.
    def make_new_list(self):
        nums = int(input("How many nodes do you want to create: "))
        if nums == 0:
            return
        for i in range(nums):
            value = int(input("Enter the value for the node:"))
            self.insert_at_end(value)

   In the above script, the make_new_list() function first asks the user for the number of items in the
   list. Next using a for-loop, the user is prompted to enter the value for each node, which is then
   inserted into the linked list using the insert_at_end() function.

   The following screenshot shows the make_new_list() function in action.

Deleting Elements
   In this section, we will see the different ways to delete an element from a single linked list.

Deletion from the Start
   Deleting an element or item from the start of the linked list is straightforward. We have to set the
   reference of the start_node to the second node which we can do by simply assigning the value of the
   reference of the start node (which is pointing to the second node) to the start node as shown below:
    def delete_at_start(self):
        if self.start_node is None:
            print("The list has no element to delete")
            return
        self.start_node = self.start_node.ref

   In the script above, we first check if the list is empty or not. If the list is empty we display the
   message that the list has no element to delete. Otherwise, we assign the value of the start_node.ref
   to the start_node. The start_node will now point towards the second element. Add the
   delete_at_start() function to the LinkedList class.

Deletion at the End
   To delete an element from the end of the list, we simply have to iterate through the linked list till
   the second last element, and then we need to set the reference of the second last element to none,
   which will convert the second last element to last element.

   The script for the function delete_at_end is as follows:
    def delete_at_end(self):
        if self.start_node is None:
            print("The list has no element to delete")
            return

        n = self.start_node
        while n.ref.ref is not None:
            n = n.ref
        n.ref = None

   Add the above script to the LinkedList() class.

Deletion by Item Value
   To delete the element by value, we first have to find the node that contains the item with the
   specified value and then delete the node. Finding the item with the specified value is pretty similar
   to searching the item. Once the item to be deleted is found, the reference of the node before the
   item is set to the node that exists after the item being deleted. Look at the following script:
  def delete_element_by_value(self, x):
    if self.start_node is None:
        print("The list has no element to delete")
        return

    # Deleting first node
    if self.start_node.item == x:
        self.start_node = self.start_node.ref
        return

    n = self.start_node
    while n.ref is not None:
        if n.ref.item == x:
            break
        n = n.ref

    if n.ref is None:
        print("item not found in the list")
    else:
        n.ref = n.ref.ref

   In the script above, we first check if the list is empty. Next, we check if the element to be deleted
   is located at the start of the linked list. If the element is found at the start, we delete it by
   setting the first node to the reference of the first node (which basically refers to the second
   node).

   Finally, if the element is not found at the first index, we iterate through the linked list and check
   if the value of the node being iterated is equal to the value to be deleted. If the comparison
   returns true, we set reference of the previous node to the node which exists after the node which is
   being deleted.

Testing Deletion Functions

   Let's test deletion functions that we just created. But before that add some dummy data to our linked
   list using the following script:
new_linked_list.insert_at_end(10)
new_linked_list.insert_at_end(20)
new_linked_list.insert_at_end(30)
new_linked_list.insert_at_end(40)
new_linked_list.insert_at_end(50)

   The above script inserts 5 elements to a linked list. If you traverse the list, you should see the
   following items:
10
20
30
40
50

   Let's first delete an item from the start:
new_linked_list.delete_at_start()

   Now if you traverse the list, you should see the following output:
20
30
40
50

   Let's delete an element from the end now:
new_linked_list.delete_at_end()

   The list now contains the following items:
20
30
40

   Finally, let's delete an element by value, say 30.
new_linked_list.delete_element_by_value(30)

   Now if you traverse the list, you should not see the item 30.

Reversing a Linked List
   To reverse a linked list, you need to have three variables, prev, n and next. The prev will keep
   track of the previous node, the next will keep track of the next node will the n will correspond to
   the current node.

   We start a while-loop by assigning the starting node to the variable n and the prev variable is
   initialized to none. The loop executes until n becomes none. Inside the while loop, you need to
   perform the following functions.
     * Assign the value of the reference of the current node to next.
     * Set the value of reference of the current node n to the prev
     * Set prevvariable to current node n.
     * Set current node n to the value of next node.

   At the end of the loop, the prev variable will point to the last node, we need to make it the first
   node so we set the value self.start_node variable to prev. The while-loop will make each node point
   to its previous node, resulting in a reversed linked list. The script is as follows:
    def reverse_linkedlist(self):
        prev = None
        n = self.start_node
        while n is not None:
            next = n.ref
            n.ref = prev
            prev = n
            n = next
        self.start_node = prev

   Add the above function to the LinkedListclass. Create a linked list of random numbers and then see if
   you can reverse it using the reverse_linkedlist() function.

Conclusion
   In this article, we started our discussion about a single linked list. We saw what are the different
   functions that can be performed on the linked list such as traversing a linked list, inserting items
   to a linked list, searching and counting linked list items, deleting items from a linked list and
   reversing a single linked list.

   This is Part 1 of the series of articles on the linked list. In the next part (coming soon), we will
   see how to sort a single linked list, how to merge sorted linked lists and how to remove cycles from
   a single linked list.


---
https://stackabuse.com/sorting-and-merging-single-linked-list/

Sorting and Merging Single Linked List
February 22, 2019

   In the last article, we started our discussion about the linked list. We saw what the linked list is
   along with its advantages and disadvantages. We also studied some of the most commonly used linked
   list method such as traversal, insertion, deletion, searching, and counting an element. Finally, we
   saw how to reverse a linked list.

   In this article, we will continue from where we left in the [9]last article and will see how to sort
   a linked list using bubble and merge sort, and how to merge two sorted linked lists.

   Before we continue, it is imperative to mention that you should create Node and LinkedList classes
   that we created in the last article.

Sorting a Linked List using Bubble Sort
   There are two ways to sort a linked list using [10]bubble sort:
    1. Exchanging data between nodes
    2. Modifying the links between nodes

   In this section, we will see how both these approaches work. We will use the bubble sort algorithm to
   first sort the linked list by changing the data, and then we will see how we can use bubble sort to
   change the links in order to sort the linked list.

Sorting Linked List by Exchanging Data
   To sort a linked list by exchanging data, we need to declare three variables p, q, and end.

   The variable p will be initialized with the start node, while end will be set to None.

   It is important to remember that to sort the list with n elements using bubble sort, you need n-1
   iterations.

   To implement bubble sort, we need two while loops. The outer while loop executes until the value of
   variable end is equal to the self.start_node.

   The inner while loop executes until p becomes equal to the end variable. Inside the outer while loop,
   the value of p will be set to self.start_node which is the first node. Inside the inner while loop,
   the value of q will be set to p.link which is actually the node next to q. Then the values of p and q
   will be compared if p is greater than q the values of both the variables will be swapped and then p
   will point to p.ref, which is the next node. Finally, the end will be assigned the value of p. This
   process continues until the linked list is sorted.

   Let's understand this process with the help of an example. Suppose we have the following list:
8,7,1,6,9

   Let's implement our algorithm to sort the list. We'll see what will happen during each iteration. The
   purpose of the bubble sort is that during each iteration, the largest value should be pushed to the
   end, hence at the end of all iterations, the list will automatically be sorted.

   Before the loop executes, the value of end is set to None.

   In the first iteration, p will be set to 8, and q will be set to 7. Since p is greater than q, the
   values will be swapped and p will become p.ref. At this point of time the linked list will look like
   this:
7,8,1,6,9

   Since at this point of time, p is not equal to end, the loop will continue and now p will become 8
   and q will become 1. Since again p is greater than q, the values will be swapped again and p will
   again become p.ref. The list will look like this:
7,1,8,6,9

   Here again, p is not equal to end, the loop will continue and now p will become 8 and q will become
   6. Since again p is greater than q, the values will be swapped again and p will again become p.ref.
   The list will look like this:
7,1,6,8,9

   Again p is not equal to end, the loop will continue and now p will become 8 and q will become 9. Here
   since p is not greater than q, the values will not be swapped and p will become p.ref. At this point
   of time, the reference of p will point to None, and end also points to None. Hence the inner while
   loop will break and end will be set to p.

   In the next set of iterations, the loop will execute until 8, since 9 is already at the end. The
   process continues until the list is completely sorted.

   The Python code for sorting the linked list using bubble sort by exchanging the data is as follows:
    def bub_sort_datachange(self):
        end = None
        while end != self.start_node:
            p = self.start_node
            while p.ref != end:
                q = p.ref
                if p.item > q.item:
                    p.item, q.item = q.item, p.item
                p = p.ref
            end = p

   Add the bub_sort_dataexchange() method to the LinkedList class that you created in the last article.

   Once you add the method to the linked list, create any set of nodes using the make_new_list()
   function and then use the bub_sort_dataexchange() to sort the list. You should see the sorted list
   when you execute the traverse_list() function.

Sorting Linked List by Modifying Links
   Bubble sort can also be used to sort a linked list by modifying the links instead of changing data.
   The process remains quite similar to sorting the list by exchanging data, however, in this case, we
   have an additional variable r that will always correspond to the node previous than the p node.

   Let's take a simple example of how we will swap two nodes by modifying links. Suppose we have a
   linked list with the following items:
10,45,65,35,1

   And we want to swap 65 and 35. At this point in time p corresponds to node 65, and q corresponds to
   node 35. The variable r will correspond to node 45 (previous to node p). Now if the node p is greater
   than node q, which is the case here, the p.ref will be set to q.ref and q.ref will be set to p.
   Similarly, r.ref will be set to q. This will swap nodes 65 and 35.

   The following method implements the bubble sorting for the linked list by modifying links:
    def bub_sort_linkchange(self):
        end = None
        while end != self.start_node:
            r = p = self.start_node
            while p.ref != end:
                q = p.ref
                if p.item > q.item:
                    p.ref = q.ref
                    q.ref = p
                    if p != self.start_node:
                        r.ref = q
                    else:
                        self.start_node = q
                    p,q = q,p
                r = p
                p = p.ref
            end = p

   Add the bub_sort_linkchange() method to the LinkedList class that you created in the last article.

   Once you add the method to the linked list, create any set of nodes using the make_new_list()
   function and then use the bub_sort_linkchange() to sort the list. You should see the sorted list when
   you execute the traverse_list() function.

Merging Sorted Linked List
   In this section we will see how we can merge two sorted linked lists in a manner that the resulting
   linked list is also sorted. There are two approaches to achieve this. We can create a new linked list
   that contains individually sorted lists or we can simply change links of the two linked list to join
   the two sorted linked list. In the second case, we do not have to create a new linked list.

   Let's first see how we can merge two linked lists by creating a new list.

Merging Sorted Linked Lists by Creating a New List
   Let's first dry run the algorithm to see how we can merge two sorted linked list with the help of a
   new list.

   Suppose we have the following two sorted linked lists:

   list1:
10,45,65,

   list2:
5,15,35,68

   These are the two lists we want to merge. The algorithm is straight forward. All we will need is
   three variables, p, q, and em, and an empty list newlist.

   At the beginning of the algorithm, p will point to the first element of the list1 whereas q will
   point to the first element of the list2. The variable em will be empty. At the start of the
   algorithm, we will have the following values:
p = 10
q = 5
em = none
newlist = none

   Next, we will compare the first element of the list1 with the first element of list2, in other words,
   we will compare the values of p and q and the smaller value will be stored in the variable em which
   will become the first node of the new list. The value of em will be added to the end of the newlist.

   After the first comparison we will have the following values:
p = 10
q = 15
em = 5
newlist = 5

   Since q was less than p, therefore, we store the value of q in em moved 'q' one index to the right.
   In the second pass, we will have the following values:
p = 45
q = 15
em = 10
newlist = 5, 10

   Here since p was smaller, we add the value of p to newlist, and set em to p and then moved p one
   index to the right. In the next iteration we have:
p = 45
q = 35
em = 15
newlist = 5, 10, 15

   Similarly, in the next iteration:
p = 45
q = 68
em = 35
newlist = 5, 10, 15, 35

   And in the next iteration, p will again be smaller than q, hence:
p = 65
q = 68
em = 45
newlist = 5, 10, 15, 35, 45

   Finally,
p = None
q = 68
em = 65
newlist = 5, 10, 15, 35, 45, 65

   When one of the list becomes None, all the elements of the second list are added at the end of the
   new list. Therefore, the final list will be:
p = None
q = None
em = 68
newlist = 5, 10, 15, 35, 45, 65, 68

   The Python script for merging two sorted lists is as follows:
    def merge_helper(self, list2):
        merged_list = LinkedList()
        merged_list.start_node = self.merge_by_newlist(self.start_node, list2.start_node)
        return merged_list

    def merge_by_newlist(self, p, q):
        if p.item <= q.item:
            startNode = Node(p.item)
            p = p.ref
        else:
            startNode = Node(q.item)
            q = q.ref

        em = startNode

        while p is not None and q is not None:
            if p.item <= q.item:
                em.ref = Node(p.item)
                p = p.ref
            else:
                em.ref = Node(q.item)
                q = q.ref
            em = em.ref

        while p is not None:
            em.ref = Node(p.item)
            p = p.ref
            em = em.ref

        while q is not None:
            em.ref = Node(q.item)
            q = q.ref
            em = em.ref

        return startNode

   In the script above we have two methods: merge_helper() and merge_by_newlist(). The first method
   merge_helper() takes a linked list as a parameter and then passes the self class, which is a linked
   list itself and the linked list passed to it as a parameter, to the merge_by_newlist() method.

   The merge_by_newlist() method merges the two linked by creating a new linked list and returns the
   start node of the new linked list. Add these two methods to the LinkedList class. Create two new
   linked lists, sort them using the bub_sort_datachange() or the bub_sort_linkchange() methods that you
   created in the last section and then use the merge_by_newlist() to see if you can merge two sorted
   linked lists or not.

Merging Sorted Linked Lists by Rearranging Links
   In this approach, a new linked list is not used to store the merger of two sorted linked lists.
   Rather, the links of the two linked lists are modified in such a way that two linked lists are merged
   in a sorted manner.

   Let's see a simple example of how we can do this. Suppose we have the same two lists list1 and list2:

   list1:
10,45,65,

   list2:
5,15,35,68

   We want to merge them in a sorted manner by rearranging the links. To do so we need variables p, q
   and em. Initially, they will have the following values:
p = 10
q = 5
em = none
newlist = none

   Next, we will compare the first element of the list1 with the first element of list2, in other words,
   we will compare the values of p and q and the smaller value will be stored in the variable em which
   will become the first node of the new list.

   After the first comparison we will have the following values:
p = 10
q = 15
start = 5
em = start

   After the first iteration, since q is less than p, the start node will point towards q and q will
   become q.ref. The em will be equal to start. The em will always refer to the newly inserted node in
   the merged list.
p = 45
q = 15
em = 10

   Here since p was smaller than the q, the variable em now points towards the original value of p and p
   becomes p.ref.
p = 45
q = 35
em = 15

   Here since q was smaller than p, em points towards q and q becomes q.ref.
p = 45
q = 68
em = 35

   Similarly em here points towards q.
p = 65
q = 68
em = 45
newlist = 5, 10, 15, 35, 45

   And here em points towards becomes p.
p = None
q = 68
em = 65
newlist = 5, 10, 15, 35, 45, 65

   When one of the lists becomes None, the elements from the second list are simply added at the end.
p = None
q = None
em = 68
newlist = 5, 10, 15, 35, 45, 65, 68

   The script that contains functions for merging two lists without creating a new list is as follows:
    def merge_helper2(self, list2):
        merged_list = LinkedList()
        merged_list.start_node = self.merge_by_linkChange(self.start_node, list2.start_node)
        return merged_list

    def merge_by_linkChange(self, p, q):
        if p.item <= q.item:
            startNode = Node(p.item)
            p = p.ref
        else:
            startNode = Node(q.item)
            q = q.ref

        em = startNode

        while p is not None and q is not None:
            if p.item <= q.item:
                em.ref = Node(p.item)
                em = em.ref
                p = p.ref
            else:
                em.ref = Node(q.item)
                em = em.ref
                q = q.ref


        if p is None:
            em.ref = q
        else:
            em.ref = p

        return startNode

   In the script above we have two methods: merge_helper2() and merge_by_linkChange(). The first method
   merge_helper2() takes a linked list as a parameter and then passes the self class which is a linked
   list itself and the linked list passed to it as a parameter, to the merge_by_linkChange(), which
   merges the two linked by modifying the links and returns the start node of the merged list. Add these
   two methods to the LinkedList class. Create two new linked lists, sort them using the
   bub_sort_datachange() or the bub_sort_linkchange() methods that you created in the last section and
   then use the merge_by_newlist() to see if you can merge two sorted linked lists or not. Let's see
   this process in action.

   Create a new linked list using the following script:
new_linked_list1 = LinkedList()
new_linked_list1.make_new_list()

   The script will ask you for the number of nodes to enter. Enter as many nodes as you like and then
   add values for each node as shown below:
How many nodes do you want to create: 4
Enter the value for the node:12
Enter the value for the node:45
Enter the value for the node:32
Enter the value for the node:61

   Next, create another linked list repeating the above process:
new_linked_list2 = LinkedList()
new_linked_list2.make_new_list()

   Next, add a few dummy nodes with the help of the following script:
How many nodes do you want to create: 4
Enter the value for the node:36
Enter the value for the node:41
Enter the value for the node:25
Enter the value for the node:9

   The next step is to sort both the lists. Execute the following script:
new_linked_list1. bub_sort_datachange()
new_linked_list2. bub_sort_datachange()

   Finally, the following script merges the two linked lists:
list3 = new_linked_list1.merge_helper2(new_linked_list2)

   To see if the lists have actually been merged, execute the following script:
list3.traverse_list()

   The output looks like this:
9
12
25
32
36
41
45
61

Conclusion
   In this article, we continued from where we left in the [11]previous article. We saw how we can sort
   merge lists by changing data and then my modifying links. Finally, we also studied different ways of
   merging two sorted linked lists.

   In the next article we'll take a look at how to construct and perform operations on doubly linked
   lists.


---
https://stackabuse.com/doubly-linked-list-with-python-examples/

Doubly Linked List with Python Examples
February 28, 2019

   This is the third article in the series of articles on implementing linked list with Python. In
   Part 1 and Part 2 of the series we studied single linked list in detail. In this article, we
   will start our discussion about doubly linked list, which is actually an extension of single linked
   list.

   In single linked list each node of the list has two components, the actual value of the node and the
   reference to the next node in the linked list. In the doubly linked list, each node has three
   components: the value of the node, the reference to the previous node, and the reference to the next
   node. For the start node of the doubly linked list, the reference to the previous node is null.
   Similarly, for the last node in the doubly linked list, the reference to next node is null.

Pros and Cons of a Doubly Linked List
   Following are some of the pros and cons of a doubly linked list:

Pros
     * Unlike a single linked list, the doubly linked list can be traversed and searched in both
       directions. The reference to the next node helps in traversing the node in the forward direction
       while the references to the previous nodes allow traversal in the backward direction.
     * Basic operations such as insertion and deletion are easier to implement in the doubly linked
       lists since, unlike single linked lists, we do not need to traverse to the predecessor node and
       store its reference. Rather, in a doubly linked list the reference of the predecessor node can be
       retrieved from the node that we want to delete.

Cons
     * One of the major drawbacks of the doubly linked list is that you need more memory space to store
       one extra reference for each node.
     * A few additional steps are required to be performed in order to perform insertion and deletion
       operations.

Implementing the Doubly Linked List with Python
   In this section, we will see how we can create a very simple doubly linked list in Python. If you
   have read [11]Part 1 and [12]Part 2 of this series of articles, the code should be pretty
   straight-forward.

   As always, let's first create a class for the single node in the list. Add the following code to your
   file:
class Node:
    def __init__(self, data):
        self.item = data
        self.nref = None
        self.pref = None

   You can see in the above code, we create a Node class with three member variables: item, nref, and
   pref. The item variable will store the actual data for the node. The nref stores the reference to the
   next node, while pref stores the reference to the previous node in the doubly linked list.

   Next, we need to create the DoublyLinkedList class, which contains different doubly linked list
   related functions. Add the following code:
class DoublyLinkedList:
    def __init__(self):
        self.start_node = None

   Throughout this article we will keep adding functions to this class.

Inserting Items in Doubly Linked List
   In this section, we will see the different ways of inserting items in a doubly linked list.

Inserting Items in Empty List
   The easiest way to insert an item in a doubly linked list is to insert an item in the empty list. The
   following script inserts an element at the start of the doubly linked list:
 def insert_in_emptylist(self, data):
        if self.start_node is None:
            new_node = Node(data)
            self.start_node = new_node
        else:
            print("list is not empty")

   In the script above, we define a method insert_in_emptylist(). The method first checks whether the
   self.start_node variable is None or not. If the variable is None, it means that the list is actually
   empty. Next, a new node is created and its value is initialized by the value passed as a parameter to
   the data parameter of the insert_in_emptylist() function. Finally, the value of self.start_node
   variable is set to the new node. In case if the list is not empty, a message is simply displayed to
   the user that the list is not empty.

   Add the insert_in_emptylist() method to the DoublyLinkedList class that you created earlier.

Inserting Items at the Start
   To insert an item at the beginning of the doubly linked list, we have to first check whether the list
   is empty or not. If the list is empty, we can simply use the logic defined in the
   insert_in_emptylist() to insert the element since in an empty list, the first element is always at
   the start.

   Else, if the list is not empty, we need to perform three operations:
    1. For the new node, the reference to the next node will be set to self.start_node.
    2. For the self.start_node the reference to the previous node will be set to the newly inserted
       node.
    3. Finally, the self.start_node will become the newly inserted node.

   The following script inserts an item at the start of the doubly linked list:
    def insert_at_start(self, data):
        if self.start_node is None:
            new_node = Node(data)
            self.start_node = new_node
            print("node inserted")
            return
        new_node = Node(data)
        new_node.nref = self.start_node
        self.start_node.pref = new_node
        self.start_node = new_node

   Add the insert_at_start() method to the DoublyLinkedList class that you created earlier.

Inserting Items at the End
   Inserting an element at the end of the doubly linked list is somewhat similar to inserting an element
   at the start. At first, we need to check if the list is empty. If the list is empty then we can
   simply use the insert_in_emptylist() method to insert the element. If the list already contains some
   element, we traverse through the list until the reference to the next node becomes None. When the
   next node reference becomes None it means that the current node is the last node.

   The previous reference for the new node is set to the last node, and the next reference for the last
   node is set to the newly inserted node. The script for inserting an item at the last node is as
   follows:
    def insert_at_end(self, data):
        if self.start_node is None:
            new_node = Node(data)
            self.start_node = new_node
            return
        n = self.start_node
        while n.nref is not None:
            n = n.nref
        new_node = Node(data)
        n.nref = new_node
        new_node.pref = n

   Add the insert_at_end() method to the DoublyLinkedList class that you created earlier.

Inserting Item after another Item
   To insert an item after another item, we first check whether or not the list is empty. If the list is
   actually empty, we simply display the message that the "list is empty".

   Otherwise we iterate through all the nodes in the doubly linked list. In case if the node after which
   we want to insert the new node is not found, we display the message to the user that the item is not
   found. Else if the node is found, it is selected and we perform four operations:
    1. Set the previous reference of the newly inserted node to the selected node.
    2. Set the next reference of the newly inserted node to the next reference of the selected.
    3. If the selected node is not the last node, set the previous reference of the next node after the
       selected node to the newly added node.
    4. Finally, set the next reference of the selected node to the newly inserted node.

   The script for inserting item after another item is as follows:
    def insert_after_item(self, x, data):
        if self.start_node is None:
            print("List is empty")
            return
        else:
            n = self.start_node
            while n is not None:
                if n.item == x:
                    break
                n = n.nref
            if n is None:
                print("item not in the list")
            else:
                new_node = Node(data)
                new_node.pref = n
                new_node.nref = n.nref
                if n.nref is not None:
                    n.nref.prev = new_node
                n.nref = new_node

   Add the insert_after_item() method to the DoublyLinkedList class that you created earlier.

Inserting Item before another Item
   To insert an item before another item, we first check whether or not the list is empty. If the list
   is actually empty, we simply display the message that the "list is empty".

   Otherwise we iterate through all the nodes in the doubly linked list. In case if the node before
   which we want to insert the new node is not found, we display the message to the user that the item
   is not found. Else if the node is found, it is selected and we perform four operations:
    1. Set the next reference of the newly inserted node to the selected node.
    2. Set the previous reference of the newly inserted node to the previous reference of the selected.
    3. Set the next reference of the node previous to the selected node, to the newly added node.
    4. Finally, set the previous reference of the selected node to the newly inserted node.

   The script for adding item before another item in a doubly linked list is as follows:
    def insert_before_item(self, x, data):
        if self.start_node is None:
            print("List is empty")
            return
        else:
            n = self.start_node
            while n is not None:
                if n.item == x:
                    break
                n = n.nref
            if n is None:
                print("item not in the list")
            else:
                new_node = Node(data)
                new_node.nref = n
                new_node.pref = n.pref
                if n.pref is not None:
                    n.pref.nref = new_node
                n.pref = new_node

   Add the insert_before_item() method to the DoublyLinkedList class that you created earlier.

Traversing a Doubly Linked List
   Traversing a doubly linked list is very similar to traversing a single linked list. The script is as
   follows:
    def traverse_list(self):
        if self.start_node is None:
            print("List has no element")
            return
        else:
            n = self.start_node
            while n is not None:
                print(n.item , " ")
                n = n.nref

   Add the traverse_list() method to the DoublyLinkedList class that you created earlier.

Deleting Elements from Doubly Linked List
   Like insertion, there can be multiple ways to delete elements from a doubly linked list. In this
   section, we will review some of them.

Deleting Elements from the Start
   The easiest way to delete an element from a doubly linked list is from the start. To do so, all you
   have to do is set the value of the start node to the next node and then set the previous reference of
   the start node to None. However before we do that we need to perform two checks. First, we need to
   see if the list is empty. And then we have to see if the list contains only one element or not. If
   the list contains only one element then we can simply set the start node to None. The following
   script can be used to delete elements from the start of the doubly linked list.
   def delete_at_start(self):
        if self.start_node is None:
            print("The list has no element to delete")
            return
        if self.start_node.nref is None:
            self.start_node = None
            return
        self.start_node = self.start_node.nref
        self.start_prev = None;

   Add the delete_at_start() method to the DoublyLinkedList class that you created earlier.

Deleting Elements from the End
   To delete the element from the end, we again check if the list is empty or if the list contains a
   single element. If the list contains a single element, all we have to do is to set the start node to
   None. If the list has more than one element, we iterate through the list until the last node is
   reached. Once we reach the last node, we set the next reference of the node previous to the last
   node, to None which actually removes the last node. The following script can be used to delete the
   element from the end.
    def delete_at_end(self):
        if self.start_node is None:
            print("The list has no element to delete")
            return
        if self.start_node.nref is None:
            self.start_node = None
            return
        n = self.start_node
        while n.nref is not None:
            n = n.nref
        n.pref.nref = None

   Add the delete_at_end() method to the DoublyLinkedList class that you created earlier.

Deleting Elements by Value
   Deleting an element by value is the trickiest of all the deletion functions in doubly linked lists
   since several cases have to be handled in order to remove an element by value. Let's first see how
   the function looks like and then we will see the explanation of the individual piece of code.
    def delete_element_by_value(self, x):
        if self.start_node is None:
            print("The list has no element to delete")
            return
        if self.start_node.nref is None:
            if self.start_node.item == x:
                self.start_node = None
            else:
                print("Item not found")
            return

        if self.start_node.item == x:
            self.start_node = self.start_node.nref
            self.start_node.pref = None
            return

        n = self.start_node
        while n.nref is not None:
            if n.item == x:
                break;
            n = n.nref
        if n.nref is not None:
            n.pref.nref = n.nref
            n.nref.pref = n.pref
        else:
            if n.item == x:
                n.pref.nref = None
            else:
                print("Element not found")

   In the above script we create delete_element_by_value() function that takes the node value as
   parameter and deletes that node. At the beginining of the function we check if the list is empty or
   not. If the list is empty we simply display the user that the list is empty.

   This logic is implemented in the following piece of code:
        if self.start_node is None:
            print("The list has no element to delete")
            return

   Next, we check if the list has a single element and that element is actually the element we want to
   delete. If the only element is the one that we want to delete, we simply set the self.start_node to
   None which means that the list will now have no item. If there is only one item and that is not the
   item that we want to delete, we will simply display the message that item to be deleted is not found.

   The following piece of code implements this logic:
        if self.start_node.nref is None:
            if self.start_node.item == x:
                self.start_node = None
            else:
                print("Item not found")
            return

   Next, we handle the case where the list has more than one items but the item to be deleted is the
   first item. In that case we simply execute the logic that we wrote for the method delete_at_start().
   The following piece of code deletes an element from the start in case of multiple items:
        if self.start_node.item == x:
            self.start_node = self.start_node.nref
            self.start_node.pref = None
            return

   Finally, if the list contains multiple items and the item to be deleted is not the first item, we
   traverse all the elements in the list except the last one and see if any of the nodes has the value
   that matches the value be deleted. If the node is found, we perform the following two operations:
    1. Set the value of the next reference of the previous node to the next reference of the node to be
       deleted.
    2. Set the previous value of the next node to the previous reference of the node to be deleted.

   Finally, if the node to be deleted is the last node, the next reference of the node previous to the
   last node is set to None. The following script implements this logic:
        n = self.start_node
        while n.nref is not None:
            if n.item == x:
                break;
            n = n.nref
        if n.nref is not None:
            n.pref.nref = n.nref
            n.nref.pref = n.pref
        else:
            if n.item == x:
                n.pref.nref = None
            else:
                print("Element not found")

   Add the delete_element_by_value() method to the DoublyLinkedList class that you created earlier.

Reversing a Doubly Linked List
   To reverse a doubly linked list, you basically have to perform the following operations:
    1. The next reference of the start node should be set none because the first node will become the
       last node in the reversed list.
    2. The previous reference of the last node should be set to None since the last node will become the
       previous node.
    3. The next references of the nodes (except the first and last node) in the original list should be
       swapped with the previous references.

   The script for reversing a doubly linked list is as follows:
    def reverse_linked_list(self):
        if self.start_node is None:
            print("The list has no element to delete")
            return
        p = self.start_node
        q = p.nref
        p.nref = None
        p.pref = q
        while q is not None:
            q.pref = q.nref
            q.nref = p
            p = q
            q = q.pref
        self.start_node = p

   Add the reverse_linked_list() method to the DoublyLinkedList class that you created earlier.

Testing Doubly Linked List Functions
   In this section, we will test the doubly linked functions that we created in the previous sections.

   Let's first create the object of the DoublyLinkedList class. Execute the following script:
new_linked_list = DoublyLinkedList()

Testing Insertion Functions

   Let's test the insertion functions first. We'll first add elements in the empty list. Execute the
   following script:
new_linked_list.insert_in_emptylist(50)

   Now if you traverse the list, you should see 50 as the only element in the list as shown below:
new_linked_list.traverse_list()

   Output:
50

   Now let's add a few elements at the start. Execute the following script:
new_linked_list.insert_at_start(10)
new_linked_list.insert_at_start(5)
new_linked_list.insert_at_start(18)

   Now if you traverse the list, you should see the following elements in the list:
18
5
10
50

   To add the elements at the end, execute the following script:
new_linked_list.insert_at_end(29)
new_linked_list.insert_at_end(39)
new_linked_list.insert_at_end(49)

   Now if you traverse the doubly linked list, you should see the following elements:
18
5
10
50
29
39
49

   Let's insert an element after 50.
new_linked_list.insert_after_item(50, 65)

   Now the list should look like this:
18
5
10
50
65
29
39
49

   Finally, let's add an element before item 29.
new_linked_list.insert_before_item(29, 100)

   The list at this point of time, should contain the following elements:
18
5
10
50
65
100
29
39
49

Testing Deletion Functions
   Let's now test the deletion functions on the items that we inserted in the last sections. Let's first
   delete an element from the start.
new_linked_list.delete_at_start()

   Item 18 will be removed and the list will now look like this:
5
10
50
65
100
29
39
49

   Similarly, the following script deletes the element from the end of the doubly linked list:
new_linked_list.delete_at_end()

   Traversing the list now will return the following items:
5
10
50
65
100
29
39

   Finally, you can also delete the elements by value using the delete_element_by_value() function as
   shown below:
new_linked_list.delete_element_by_value(65)

   If you traverse the list now, you will see that item 65 will be deleted from the list.

Testing Reverse Function

   Finally, let's reverse the list using the reverse_linked_list() function. Execute the following
   script:
new_linked_list.reverse_linked_list()

   Now if you traverse the list, you will see the reversed linked list:
39
29
100
50
10
5

Conclusion
   The doubly linked list is extremely useful specifically when you have to perform lots of inserts and
   delete operations. The links to the previous and next nodes make it very easy to insert and delete
   new elements without keeping track of the previous and next nodes.

   In this article, we saw how doubly linked list can be implemented with Python. We also saw different
   ways to perform insert and delete operations on doubly linked list. Finally we studied how to reverse
   a doubly linked list.


---

... MORE TO COME ...
