filename: python_csv-reading-writing-multif_20171018.txt
http://www.pythonforbeginners.com/systems-programming/using-the-csv-module-in-python/

Using the CSV module in Python
   If you want to import or export spreadsheets and databases for use in the Python interpreter, you
   must rely on the CSV module, or Comma Separated Values format.

What is a CSV File?
   CSV files are used to store a large number of variables – or data. They are incredibly simplified
   spreadsheets – think Excel – only the content is stored in plaintext.

   And the CSV module is a built-in function that allows Python to parse these types of files.

   It’s worth noting that when you work with a CSV file, you are dabbling in JSON development.

   JSON – which stands for JavaScript Object Notation – is a format that is used to store information as
   JavaScript code in plaintext files. You don’t need to know JavaScript to work with these files, nor
   is the practice confined to that language. Obviously, since we’re working with Python here.

   The text inside a CSV file is laid out in rows, and each of those has columns, all separated by
   commas. Every line in the file is a row in the spreadsheet, while the commas are used to define and
   separate cells.

Working with the CSV Module
   To pull information from CSV files you use loop and split methods to get the data from individual
   columns.

   The CSV module explicitly exists to handle this task, making it much easier to deal with CSV
   formatted files. This becomes especially important when you are working with data that’s been
   exported from actual spreadsheets and databases to text files. This information can be tough to read
   on its own.

   Unfortunately, there is no standard so the CSV module uses “dialects” to support parsing using
   different parameters. Along with a generic reader and writer, the module includes a dialect for
   working with Microsoft Excel and related files.

CSV Functions
   The CSV module includes all the necessary functions built in. They are:
     * csv.reader
     * csv.writer
     * csv.register_dialect
     * csv.unregister_dialect
     * csv.get_dialect
     * csv.list_dialects
     * csv.field_size_limit

   In this guide we are only going to focus on the reader and writer functions which allow you to edit,
   modify, and manipulate the data stored in a CSV file.

Reading CSV Files
   To pull data from a CSV file, you must use the reader function to generate a reader object.

   The reader function is designed to take each line of the file and make a list of all columns. Then,
   you just choose the column you want the variable data for.

   It sounds a lot more complicated than it is. To prove it, let’s take a look at an example.
import CSV
With open(‘some.csv’, ‘rb’) as f:
reader = csv.reader(f)
for row in reader:
print row

   Notice how the first command is used to import the CSV module?

   Let’s look at another example.
import csv
import sys

f = open(sys.argv[1], ‘rb’)
reader = csv.reader(f)
for row in reader
print row

f.close()

   In the first two lines, we are importing the CSV and sys modules. Then, we open the CSV file we want
   to pull information from.

   Next, we create the reader object, iterate the rows of the file, and then print them. Finally, we
   close out the operation.

CSV Sample File
   We’re going to take a look at an example CSV file. Pay attention to how the information is stored and
   presented.
Title,Release Date,Director
And Now For Something Completely Different,1971,Ian MacNaughton
Monty Python And The Holy Grail,1975,Terry Gilliam and Terry Jones
Monty Python's Life Of Brian,1979,Terry Jones
Monty Python Live At The Hollywood Bowl,1982,Terry Hughes
Monty Python's The Meaning Of Life,1983,Terry Jones


Reading CSV Files Example
   We’re going to start with a basic CSV file that has 3 columns, containing the variables “A”, “B”,
   “C”, and “D”.


$ cat test.csv
A,B,”C D”
1,2,”3 4”
5,6,7


   Then, we’ll use the following Python program to read and display the contents of the above CSV file.


import csv

ifile = open(‘test.csv’, “rb”)
reader = csv.reader(ifile)

rownum = 0
for row in reader:
# Save header row.
if rownum ==0:
header = row
else:
colnum = 0
for col in row:
print ‘%-8s: %s’ % (header[colnum], col)
colnum + = 1

rownum + = 1

ifile.close()

   When we execute this program in Python, the output will look like this:
$ python csv1.py
A      : 1
B      : 2
C D      : 3 4
A      : 5
B      : 6
C D      : 7


Writing to CSV Files
   When you have a set of data that you would like to store inside a CSV file, it’s time to do the
   opposite and use the write function. Believe it or not, this is just as easy to accomplish as reading
   them.

   The writer() function will create an object suitable for writing. To iterate the data over the rows,
   you will need to use the writerow() function.

   Here’s an example.

   The following Python program converts a file called “test.csv” to a CSV file that uses tabs as a
   value separator with all values quoted. The delimiter character and the quote character, as well as
   how/when to quote, are specified when the writer is created. These same options are available when
   creating reader objects.


import csv

ifile  = open('test.csv', "rb")
reader = csv.reader(ifile)
ofile  = open('ttest.csv', "wb")
writer = csv.writer(ofile, delimiter='', quotechar='"', quoting=csv.QUOTE_ALL)

for row in reader:
    writer.writerow(row)

ifile.close()
ofile.close()


   When you execute this program, the output will be:

$ python csv2.py
$ cat ttest.csv
"A"     "B"     "C D"
"1"     "2"     "3 4"
"5"     "6"     "7"


Quoting CSV Files
   With the CSV module, you can also perform a variety of quoting functions.

   They are:
     * csv.QUOTE_ALL - Quote everything, regardless of type.
     * csv.QUOTE_MINIMAL - Quote fields with special characters
     * csv.QUOTE_NONNUMERIC - Quote all fields that are not integers or floats
     * csv.QUOTE_NONE - Do not quote anything on output



---
https://pythonprogramming.net/reading-csv-files-python-3/

Reading CSV files in Python

   This Python 3 tutorial covers how to read CSV data in from a file and then use it in Python. For
   this, we use the csv module. CSV literally stands for comma separated variable, where the comma is
   what is known as a "delimiter." While you can also just simply use Python's split() function, to
   separate lines and data within each line, the CSV module can also be used to make things easy.

   Here is the sample code that matches the video:

   Example CSV file data:
1/2/2014,5,8,red
1/3/2014,5,2,green
1/4/2014,9,1,blue

   Next, let's cover the reading of CSV files into memory:
import csv

with open('example.csv') as csvfile:
    readCSV = csv.reader(csvfile, delimiter=',')
    for row in readCSV:
        print(row)
        print(row[0])
        print(row[0],row[1],row[2],)

   Above, we've shown how to open a CSV file and read each row, as well as reference specific data on
   each row.

   Next, we will show how to pull out specific data from the spreadsheet and save it to a list variable:
import csv

with open('example.csv') as csvfile:
    readCSV = csv.reader(csvfile, delimiter=',')
    dates = []
    colors = []
    for row in readCSV:
        color = row[3]
        date = row[0]

        dates.append(date)
        colors.append(color)

    print(dates)
    print(colors)

   Once we have this data, what can we do with it? Maybe we are curious about what color something was
   on a specific date.
import csv

with open('example.csv') as csvfile:
    readCSV = csv.reader(csvfile, delimiter=',')
    dates = []
    colors = []
    for row in readCSV:
        color = row[3]
        date = row[0]

        dates.append(date)
        colors.append(color)

    print(dates)
    print(colors)

    # now, remember our lists?

    whatColor = input('What color do you wish to know the date of?:')
    coldex = colors.index(whatColor)
    theDate = dates[coldex]
    print('The date of',whatColor,'is:',theDate)

   Simple enough! If we enter something that doesn't exist, we get an ugly error.


---
http://zetcode.com/python/csv/

Python CSV tutorial - read write CSV

   Python CSV tutorial shows how to read and write CSV data with Python csv module.

CSV
   CSV (Comma Separated Values) is a very popular import and export data format used in spreadsheets and
   databases. Each line in a CSV file is a data record. Each record consists of one or more fields,
   separated by commas. While CSV is a very simple data format, there can be many differecies, such as
   different delimiters, new lines, or quoting characters.

Python csv module
   The csv module implements classes to read and write tabular data in CSV format. The csv module's
   reader and writer objects read and write sequences. Programmers can also read and write data in
   dictionary form using the DictReader and DictWriter classes.
   [INS: :INS]

Python CSV methods
   The following table shows Python csv methods:
           Method                                   Description
   csv.reader             returns a reader object which iterates over lines of a CSV file
   csv.writer             returns a writer object which writes data into CSV file
   csv.register_dialect   registers a CSV dialect
   csv.unregister_dialect unregisters a CSV dialect
   csv.get_dialect        returns a dialect with the given name
   csv.list_dialects      returns all registered dialects
   csv.field_size_limit   returns the current maximum field size allowed by the parser

Using Python csv module

import csv
   To use Python CSV module, we import csv.

Python CSV reader
   The csv.reader() method returns a reader object which iterates over lines in the given CSV file.
$ cat numbers.csv
16,6,4,12,81,6,71,6

   The numbers.csv file contains numbers.
   read_csv.py
#!/usr/bin/python3

import csv

f = open('numbers.csv', 'r')

with f:

    reader = csv.reader(f)

    for row in reader:
        for e in row:
            print(e)

   In the code example, we open the numbers.csv for reading and read its contents.
reader = csv.reader(f)

   We get the reader object.
for row in reader:
    for e in row:
        print(e)

   With two for loops, we iterate over the data.
$ ./read_csv.py
16
6
4
12
81
6
71
6

   This is the output of the example.

Python CSV reader with different delimiter
   The csv.reader() method allows to use a different delimiter with its delimiter attribute.
$ cat items.csv
pen|cup|bottle
chair|book|tablet

   The items.csv contains values separated with '|' character.
   read_csv.py
#!/usr/bin/python3

import csv

f = open('items.csv', 'r')

with f:

    reader = csv.reader(f, delimiter="|")

    for row in reader:

        for e in row:
            print(e)

   The code example reads and displays data from a CSV file that uses a '|' delimiter.
$ ./read_csv2.py
pen
cup
bottle
chair
book
tablet

   This is the output of the example.

Python CSV DictReader
   The csv.DictReader class operates like a regular reader but maps the information read into a
   dictionary. The keys for the dictionary can be passed in with the fieldnames parameter or inferred
   from the first row of the CSV file.
$ cat values.csv
min,avg,max
1, 5.5, 10
2, 3.5, 5

   The first line of the file consists of dictionary keys.
   read_csv_dictionary.py
#!/usr/bin/python3

# read_csv3.py

import csv

f = open('values.csv', 'r')

with f:

    reader = csv.DictReader(f)

    for row in reader:
        print(row['min'], row['avg'], row['max'])

   The example reads the values from the values.csv file using the csv.DictReader.
for row in reader:
    print(row['min'], row['avg'], row['max'] )

   The row is a Python dictionary and we reference the data with the keys.

Python CSV writer
   The csv.writer() method returns a writer object which converts the user's data into delimited strings
   on the given file-like object.
   write_csv.py
#!/usr/bin/python3

import csv

nms = [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12]]

f = open('numbers2.csv', 'w')

with f:

    writer = csv.writer(f)

    for row in nms:
        writer.writerow(row)

   The script writes numbers into the numbers2.csv file. The writerow() method writes a row of data into
   the specified file.
$ cat numbers2.csv
1,2,3,4,5,6
7,8,9,10,11,12

   It is possible to write all data in one shot. The writerows() method writes all given rows to the CSV
   file.
   write_csv2.py
#!/usr/bin/python3

import csv

nms = [[1, 2, 3], [7, 8, 9], [10, 11, 12]]

f = open('numbers3.csv', 'w')

with f:

    writer = csv.writer(f)
    writer.writerows(nms)

   The code example writes three rows of numbers into the file using the writerows() method.

Python CSV DictWriter
   The csv.DictWriter class operates like a regular writer but maps Python dictionaries into CSV rows.
   The fieldnames parameter is a sequence of keys that identify the order in which values in the
   dictionary passed to the writerow() method are written to the CSV file.
   write_csv_dictionary.py
#!/usr/bin/python3

import csv

f = open('names.csv', 'w')

with f:

    fnames = ['first_name', 'last_name']
    writer = csv.DictWriter(f, fieldnames=fnames)

    writer.writeheader()
    writer.writerow({'first_name' : 'John', 'last_name': 'Smith'})
    writer.writerow({'first_name' : 'Robert', 'last_name': 'Brown'})
    writer.writerow({'first_name' : 'Julia', 'last_name': 'Griffin'})

   The example writes the values from Python dictionaries into the CSV file using the csv.DictWriter.
writer = csv.DictWriter(f, fieldnames=fnames)

   New csv.DictWriter is created. The header names are passed to the fieldnames parameter.
writer.writeheader()

   The writeheader() method writes the headers to the CSV file.
writer.writerow({'first_name' : 'John', 'last_name': 'Smith'})

   The Python dictionary is written to a row in a CSV file.
$ cat names.csv
first_name,last_name
John,Smith
Robert,Brown
Julia,Griffin

   This is the output.

Python CSV custom dialect
   A custom dialect is created with the csv.register_dialect() method.
   custom_dialect.py
#!/usr/bin/python3

import csv

csv.register_dialect("hashes", delimiter="#")

f = open('items3.csv', 'w')

with f:

    writer = csv.writer(f, dialect="hashes")
    writer.writerow(("pens", 4))
    writer.writerow(("plates", 2))
    writer.writerow(("bottles", 4))
    writer.writerow(("cups", 1))

   The program uses a (#) character as a delimiter. The dialect is specified with the dialect option in
   the csv.writer() method.
$ cat items3.csv
pens#4
plates#2
bottles#4
cups#1

   This is the output.
   [INS: :INS]


---
https://www.blog.pythonlibrary.org/2014/02/26/python-101-reading-and-writing-csv-files/

Python 101: Reading and Writing CSV Files
February 26, 2014

   Python has a vast library of modules that are included with its distribution. The csv module gives
   the Python programmer the ability to parse CSV (Comma Separated Values) files. A CSV file is a human
   readable text file where each line has a number of fields, separated by commas or some other
   delimiter. You can think of each line as a row and each field as a column. The CSV format has no
   standard, but they are similar enough that the csv module will be able to read the vast majority of
   CSV files. You can also write CSV files using the csv module.
     ________________________________________________________________________________________________

Reading a CSV File
   There are two ways to read a CSV file. You can use the csv module’s reader function or you can use
   the DictReader class. We will look at both methods. But first, we need to get a CSV file so we have
   something to parse. There are many websites that provide interesting information in CSV format. We
   will be using the World Health Organization’s (WHO) website to download some information on
   Tuberculosis. You can go here to get it: http://www.who.int/tb/country/data/download/en/. Once
   you have the file, we’ll be ready to start. Ready? Then let’s look at some code!
import csv

#----------------------------------------------------------------------
def csv_reader(file_obj):
    """
    Read a csv file
    """
    reader = csv.reader(file_obj)
    for row in reader:
        print(" ".join(row))

#----------------------------------------------------------------------
if __name__ == "__main__":
    csv_path = "TB_data_dictionary_2014-02-26.csv"
    with open(csv_path, "rb") as f_obj:
        csv_reader(f_obj)

   Let’s take a moment to break this down a bit. First off, we have to actually import the csv module.
   Then we create a very simple function called csv_reader that accepts a file object. Inside the
   function, we pass the file object into the csv_reader function, which returns a reader object. The
   reader object allows iteration, much like a regular file object does. This let’s us iterate over each
   row in the reader object and print out the line of data, minus the commas. This works because each
   row is a list and we can join each element in the list together, forming one long string.

   Now let’s create our own CSV file and feed it into the DictReader class. Here’s a really simple one:

   first_name,last_name,address,city,state,zip_code
   Tyrese,Hirthe,1404 Turner Ville,Strackeport,NY,19106-8813
   Jules,Dicki,2410 Estella Cape Suite 061,Lake Nickolasville,ME,00621-7435
   Dedric,Medhurst,6912 Dayna Shoal,Stiedemannberg,SC,43259-2273

   Let’s save this in a file named data.csv. Now we’re ready to parse the file using the DictReader
   class. Let’s try it out:
import csv

#----------------------------------------------------------------------
def csv_dict_reader(file_obj):
    """
    Read a CSV file using csv.DictReader
    """
    reader = csv.DictReader(file_obj, delimiter=',')
    for line in reader:
        print(line["first_name"]),
        print(line["last_name"])

#----------------------------------------------------------------------
if __name__ == "__main__":
    with open("data.csv") as f_obj:
        csv_dict_reader(f_obj)

   In the example above, we open a file and pass the file object to our function as we did before. The
   function passes the file object to our DictReader class. We tell the DictReader that the delimiter is
   a comma. This isn’t actually required as the code will still work without that keyword argument.
   However, it’s a good idea to be explicit so you know what’s going on here. Next we loop over the
   reader object and discover that each line in the reader object is a dictionary. This makes printing
   out specific pieces of the line very easy.

   Now we’re ready to learn how to write a csv file to disk.
     ________________________________________________________________________________________________

Writing a CSV File
   The csv module also has two methods that you can use to write a CSV file. You can use the writer
   function or the DictWriter class. We’ll look at both of these as well. We will start with the writer
   function. Let’s look at a simple example:
# Python 2.x version
import csv

#----------------------------------------------------------------------
def csv_writer(data, path):
    """
    Write data to a CSV file path
    """
    with open(path, "wb") as csv_file:
        writer = csv.writer(csv_file, delimiter=',')
        for line in data:
            writer.writerow(line)

#----------------------------------------------------------------------
if __name__ == "__main__":
    data = ["first_name,last_name,city".split(","),
            "Tyrese,Hirthe,Strackeport".split(","),
            "Jules,Dicki,Lake Nickolasville".split(","),
            "Dedric,Medhurst,Stiedemannberg".split(",")
            ]
    path = "output.csv"
    csv_writer(data, path)

   In the code above, we create a csv_writer function that accepts two arguments: data and path. The
   data is a list of lists that we create at the bottom of the script. We use a shortened version of the
   data from the previous example and split the strings on the comma. This returns a list. So we end up
   with a nested list that looks like this:
[['first_name', 'last_name', 'city'],
 ['Tyrese', 'Hirthe', 'Strackeport'],
 ['Jules', 'Dicki', 'Lake Nickolasville'],
 ['Dedric', 'Medhurst', 'Stiedemannberg']]

   The csv_writer function opens the path that we pass in and creates a csv writer object. Then we loop
   over the nested list structure and write each line out to disk. Note that we specified what the
   delimiter should be when we created the writer object. If you want the delimiter to be something
   besides a comma, this is where you would set it.

   Now if you want to write a csv file in Python 3, the syntax is slightly different. Here’s how you
   would have to rewrite the function:
# Python 3.x version
import csv

def csv_writer(data, path):
    """
    Write data to a CSV file path
    """
    with open(path, "w", newline='') as csv_file:
        writer = csv.writer(csv_file, delimiter=',')
        for line in data:
            writer.writerow(line)

   You will note that you need to change the write mode to just ‘w’ and add the newline argument.

   Now we’re ready to learn how to write a CSV file using the DictWriter class! We’re going to use the
   data from the previous version and transform it into a list of dictionaries that we can feed to our
   hungry DictWriter. Let’s take a look:
# Python 2.x version
import csv

#----------------------------------------------------------------------
def csv_dict_writer(path, fieldnames, data):
    """
    Writes a CSV file using DictWriter
    """
    with open(path, "wb") as out_file:
        writer = csv.DictWriter(out_file, delimiter=',', fieldnames=fieldnames)
        writer.writeheader()
        for row in data:
            writer.writerow(row)

#----------------------------------------------------------------------
if __name__ == "__main__":
    data = ["first_name,last_name,city".split(","),
            "Tyrese,Hirthe,Strackeport".split(","),
            "Jules,Dicki,Lake Nickolasville".split(","),
            "Dedric,Medhurst,Stiedemannberg".split(",")
            ]
    my_list = []
    fieldnames = data[0]
    for values in data[1:]:
        inner_dict = dict(zip(fieldnames, values))
        my_list.append(inner_dict)

    path = "dict_output.csv"
    csv_dict_writer(path, fieldnames, my_list)

   Note: To convert this code to Python 3 syntax, you would need to change the with statement like you
   did before: with open(path, “w”, newline=”) as out_file:

   We will start in the second section first. As you can see, we start out with the nested list
   structure that we had before. Next we create and empty list and a list that contains the field names,
   which happens to be the first list inside the nested list. Remember, lists are zero-based, so the
   first element in a list starts at zero! Next we loop over the nested list construct, starting with
   the second element:
for values in data[1:]:
    inner_dict = dict(zip(fieldnames, values))
    my_list.append(inner_dict)

   Inside the for loop, we use Python builtins to create dictionary. The **zip** method will take two
   iterators (lists in this case) and turn them into a list of tuples. Here’s an example:
zip(fieldnames, values)
[('first_name', 'Dedric'), ('last_name', 'Medhurst'), ('city', 'Stiedemannberg')]

   Now when your wrap that call in **dict**, it turns that list of of tuples into a dictionary. Finally
   we append the dictionary to the list. When the **for** finishes, you’ll end up with a data structure
   that looks like this:
[{'city': 'Strackeport', 'first_name': 'Tyrese', 'last_name': 'Hirthe'},
{'city': 'Lake Nickolasville', 'first_name': 'Jules', 'last_name': 'Dicki'},
{'city': 'Stiedemannberg', 'first_name': 'Dedric', 'last_name': 'Medhurst'}]

   At the end of the second session, we call our csv_dict_writer function and pass in all the required
   arguments. Inside the function, we create a DictWriter instance and pass it a file object, a
   delimiter value and our list of field names. Next we write the field names out to disk and loop over
   the data one row at a time, writing the data to disk. The DictWriter class also support the writerows
   method, which we could have used instead of the loop. The csv.writer function also supports this
   functionality.

   You may be interested to know that you can also create Dialects with the csv module. This allows you
   to tell the csv module how to read or write a file in a very explicit manner. If you need this sort
   of thing because of an oddly formatted file from a client, then you’ll find this functionality
   invaluable.
     ________________________________________________________________________________________________

Wrapping Up
   Now you know how to use the csv module to read and write CSV files. There are many websites that put
   out their data in this format and it is used a lot in the business world. Have fun and happy coding!
     ________________________________________________________________________________________________

---
https://docs.python.org/3/library/csv.html

14.1. csv — CSV File Reading and Writing

   Source code: Lib/csv.py
     ________________________________________________________________________________________________

   The so-called CSV (Comma Separated Values) format is the most common import and export format for
   spreadsheets and databases. CSV format was used for many years prior to attempts to describe the
   format in a standardized way in RFC 4180. The lack of a well-defined standard means that subtle
   differences often exist in the data produced and consumed by different applications. These
   differences can make it annoying to process CSV files from multiple sources. Still, while the
   delimiters and quoting characters vary, the overall format is similar enough that it is possible to
   write a single module which can efficiently manipulate such data, hiding the details of reading and
   writing the data from the programmer.

   The csv module implements classes to read and write tabular data in CSV format. It allows
   programmers to say, “write this data in the format preferred by Excel,” or “read data from this file
   which was generated by Excel,” without knowing the precise details of the CSV format used by Excel.
   Programmers can also describe the CSV formats understood by other applications or define their own
   special-purpose CSV formats.

   The csv module’s reader and writer objects read and write sequences. Programmers can also
   read and write data in dictionary form using the DictReader and DictWriter classes.

   See also

   PEP 305 - CSV File API
          The Python Enhancement Proposal which proposed this addition to Python.

14.1.1. Module Contents
   The csv module defines the following functions:

   csv.reader(csvfile, dialect='excel', **fmtparams)
          Return a reader object which will iterate over lines in the given csvfile. csvfile can be any
          object which supports the iterator protocol and returns a string each time its __next__()
          method is called — file objects and list objects are both suitable. If csvfile is a file
          object, it should be opened with newline=''. An optional dialect parameter can be
          given which is used to define a set of parameters specific to a particular CSV dialect. It may
          be an instance of a subclass of the Dialect class or one of the strings returned by the
          list_dialects() function. The other optional fmtparams keyword arguments can be given to
          override individual formatting parameters in the current dialect. For full details about the
          dialect and formatting parameters, see section Dialects and Formatting Parameters.

          Each row read from the csv file is returned as a list of strings. No automatic data type
          conversion is performed unless the QUOTE_NONNUMERIC format option is specified (in which case
          unquoted fields are transformed into floats).

          A short usage example:

>>> import csv
>>> with open('eggs.csv', newline='') as csvfile:
...     spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')
...     for row in spamreader:
...         print(', '.join(row))
Spam, Spam, Spam, Spam, Spam, Baked Beans
Spam, Lovely Spam, Wonderful Spam

   csv.writer(csvfile, dialect='excel', **fmtparams)
          Return a writer object responsible for converting the user’s data into delimited strings on
          the given file-like object. csvfile can be any object with a write() method. If csvfile is a
          file object, it should be opened with newline=''. An optional dialect parameter can be
          given which is used to define a set of parameters specific to a particular CSV dialect. It may
          be an instance of a subclass of the Dialect class or one of the strings returned by the
          list_dialects() function. The other optional fmtparams keyword arguments can be given to
          override individual formatting parameters in the current dialect. For full details about the
          dialect and formatting parameters, see section Dialects and Formatting Parameters. To make
          it as easy as possible to interface with modules which implement the DB API, the value
          None is written as the empty string. While this isn’t a reversible transformation, it
          makes it easier to dump SQL NULL data values to CSV files without preprocessing the data
          returned from a cursor.fetch* call. All other non-string data are stringified with str()
          before being written.

          A short usage example:

import csv
with open('eggs.csv', 'w', newline='') as csvfile:
    spamwriter = csv.writer(csvfile, delimiter=' ',
                            quotechar='|', quoting=csv.QUOTE_MINIMAL)
    spamwriter.writerow(['Spam'] * 5 + ['Baked Beans'])
    spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])

   csv.register_dialect(name[, dialect[, **fmtparams]])
          Associate dialect with name. name must be a string. The dialect can be specified either by
          passing a sub-class of Dialect, or by fmtparams keyword arguments, or both, with keyword
          arguments overriding parameters of the dialect. For full details about the dialect and
          formatting parameters, see section Dialects and Formatting Parameters.

   csv.unregister_dialect(name)
          Delete the dialect associated with name from the dialect registry. An Error is raised if
          name is not a registered dialect name.

   csv.get_dialect(name)
          Return the dialect associated with name. An Error is raised if name is not a registered
          dialect name. This function returns an immutable Dialect.

   csv.list_dialects()
          Return the names of all registered dialects.

   csv.field_size_limit([new_limit])
          Returns the current maximum field size allowed by the parser. If new_limit is given, this
          becomes the new limit.

   The csv module defines the following classes:

   class csv.DictReader(f, fieldnames=None, restkey=None, restval=None, dialect='excel', *args,
          **kwds)
          Create an object that operates like a regular reader but maps the information in each row to
          an OrderedDict whose keys are given by the optional fieldnames parameter.

          The fieldnames parameter is a sequence. If fieldnames is omitted, the values in the first
          row of file f will be used as the fieldnames. Regardless of how the fieldnames are determined,
          the ordered dictionary preserves their original ordering.

          If a row has more fields than fieldnames, the remaining data is put in a list and stored with
          the fieldname specified by restkey (which defaults to None). If a non-blank row has fewer
          fields than fieldnames, the missing values are filled-in with None.

          All other optional or keyword arguments are passed to the underlying reader instance.

          Changed in version 3.6: Returned rows are now of type OrderedDict.

          A short usage example:

>>> import csv
>>> with open('names.csv') as csvfile:
...     reader = csv.DictReader(csvfile)
...     for row in reader:
...         print(row['first_name'], row['last_name'])
...
Eric Idle
John Cleese

>>> print(row)
OrderedDict([('first_name', 'John'), ('last_name', 'Cleese')])

   class csv.DictWriter(f, fieldnames, restval='', extrasaction='raise', dialect='excel', *args,
          **kwds)
          Create an object which operates like a regular writer but maps dictionaries onto output rows.
          The fieldnames parameter is a sequence of keys that identify the order in which values in
          the dictionary passed to the writerow() method are written to file f. The optional restval
          parameter specifies the value to be written if the dictionary is missing a key in fieldnames.
          If the dictionary passed to the writerow() method contains a key not found in fieldnames, the
          optional extrasaction parameter indicates what action to take. If it is set to 'raise', the
          default value, a ValueError is raised. If it is set to 'ignore', extra values in the
          dictionary are ignored. Any other optional or keyword arguments are passed to the underlying
          writer instance.

          Note that unlike the DictReader class, the fieldnames parameter of the DictWriter is
          not optional. Since Python’s dict objects are not ordered, there is not enough information
          available to deduce the order in which the row should be written to file f.

          A short usage example:

import csv

with open('names.csv', 'w') as csvfile:
    fieldnames = ['first_name', 'last_name']
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

    writer.writeheader()
    writer.writerow({'first_name': 'Baked', 'last_name': 'Beans'})
    writer.writerow({'first_name': 'Lovely', 'last_name': 'Spam'})
    writer.writerow({'first_name': 'Wonderful', 'last_name': 'Spam'})

   class csv.Dialect
          The Dialect class is a container class relied on primarily for its attributes, which are
          used to define the parameters for a specific reader or writer instance.

   class csv.excel
          The excel class defines the usual properties of an Excel-generated CSV file. It is
          registered with the dialect name 'excel'.

   class csv.excel_tab
          The excel_tab class defines the usual properties of an Excel-generated TAB-delimited file.
          It is registered with the dialect name 'excel-tab'.

   class csv.unix_dialect
          The unix_dialect class defines the usual properties of a CSV file generated on UNIX
          systems, i.e. using '\n' as line terminator and quoting all fields. It is registered with the
          dialect name 'unix'.

          New in version 3.2.

   class csv.Sniffer
          The Sniffer class is used to deduce the format of a CSV file.

          The Sniffer class provides two methods:

        sniff(sample, delimiters=None)
                Analyze the given sample and return a Dialect subclass reflecting the parameters
                found. If the optional delimiters parameter is given, it is interpreted as a string
                containing possible valid delimiter characters.

        has_header(sample)
                Analyze the sample text (presumed to be in CSV format) and return True if the first
                row appears to be a series of column headers.

   An example for Sniffer use:
with open('example.csv') as csvfile:
    dialect = csv.Sniffer().sniff(csvfile.read(1024))
    csvfile.seek(0)
    reader = csv.reader(csvfile, dialect)
    # ... process CSV file contents here ...

   The csv module defines the following constants:

   csv.QUOTE_ALL
          Instructs writer objects to quote all fields.

   csv.QUOTE_MINIMAL
          Instructs writer objects to only quote those fields which contain special characters such
          as delimiter, quotechar or any of the characters in lineterminator.

   csv.QUOTE_NONNUMERIC
          Instructs writer objects to quote all non-numeric fields.

          Instructs the reader to convert all non-quoted fields to type float.

   csv.QUOTE_NONE
          Instructs writer objects to never quote fields. When the current delimiter occurs in
          output data it is preceded by the current escapechar character. If escapechar is not set, the
          writer will raise Error if any characters that require escaping are encountered.

          Instructs reader to perform no special processing of quote characters.

   The csv module defines the following exception:

   exception csv.Error
          Raised by any of the functions when an error is detected.

14.1.2. Dialects and Formatting Parameters
   To make it easier to specify the format of input and output records, specific formatting parameters
   are grouped together into dialects. A dialect is a subclass of the Dialect class having a set of
   specific methods and a single validate() method. When creating reader or writer objects, the
   programmer can specify a string or a subclass of the Dialect class as the dialect parameter. In
   addition to, or instead of, the dialect parameter, the programmer can also specify individual
   formatting parameters, which have the same names as the attributes defined below for the Dialect
   class.

   Dialects support the following attributes:

   Dialect.delimiter
          A one-character string used to separate fields. It defaults to ','.

   Dialect.doublequote
          Controls how instances of quotechar appearing inside a field should themselves be quoted. When
          True, the character is doubled. When False, the escapechar is used as a prefix to
          the quotechar. It defaults to True.

          On output, if doublequote is False and no escapechar is set, Error is raised if a
          quotechar is found in a field.

   Dialect.escapechar
          A one-character string used by the writer to escape the delimiter if quoting is set to
          QUOTE_NONE and the quotechar if doublequote is False. On reading, the escapechar
          removes any special meaning from the following character. It defaults to None, which
          disables escaping.

   Dialect.lineterminator
          The string used to terminate lines produced by the writer. It defaults to '\r\n'.

          Note

          The reader is hard-coded to recognise either '\r' or '\n' as end-of-line, and ignores
          lineterminator. This behavior may change in the future.

   Dialect.quotechar
          A one-character string used to quote fields containing special characters, such as the
          delimiter or quotechar, or which contain new-line characters. It defaults to '"'.

   Dialect.quoting
          Controls when quotes should be generated by the writer and recognised by the reader. It can
          take on any of the QUOTE_* constants (see section Module Contents) and defaults to
          QUOTE_MINIMAL.

   Dialect.skipinitialspace
          When True, whitespace immediately following the delimiter is ignored. The default is
          False.

   Dialect.strict
          When True, raise exception Error on bad CSV input. The default is False.

14.1.3. Reader Objects
   Reader objects (DictReader instances and objects returned by the reader() function) have
   the following public methods:

   csvreader.__next__()
          Return the next row of the reader’s iterable object as a list (if the object was returned from
          reader()) or a dict (if it is a DictReader instance), parsed according to the
          current dialect. Usually you should call this as next(reader).

   Reader objects have the following public attributes:

   csvreader.dialect
          A read-only description of the dialect in use by the parser.

   csvreader.line_num
          The number of lines read from the source iterator. This is not the same as the number of
          records returned, as records can span multiple lines.

   DictReader objects have the following public attribute:

   csvreader.fieldnames
          If not passed as a parameter when creating the object, this attribute is initialized upon
          first access or when the first record is read from the file.

14.1.4. Writer Objects
   Writer objects (DictWriter instances and objects returned by the writer() function) have
   the following public methods. A row must be an iterable of strings or numbers for Writer objects and
   a dictionary mapping fieldnames to strings or numbers (by passing them through str() first) for
   DictWriter objects. Note that complex numbers are written out surrounded by parens. This may
   cause some problems for other programs which read CSV files (assuming they support complex numbers at
   all).

   csvwriter.writerow(row)
          Write the row parameter to the writer’s file object, formatted according to the current
          dialect.

          Changed in version 3.5: Added support of arbitrary iterables.

   csvwriter.writerows(rows)
          Write all the rows parameters (a list of row objects as described above) to the writer’s file
          object, formatted according to the current dialect.

   Writer objects have the following public attribute:

   csvwriter.dialect
          A read-only description of the dialect in use by the writer.

   DictWriter objects have the following public method:

   DictWriter.writeheader()
          Write a row with the field names (as specified in the constructor).

          New in version 3.2.

14.1.5. Examples
   The simplest example of reading a CSV file:
import csv
with open('some.csv', newline='') as f:
    reader = csv.reader(f)
    for row in reader:
        print(row)

   Reading a file with an alternate format:
import csv
with open('passwd', newline='') as f:
    reader = csv.reader(f, delimiter=':', quoting=csv.QUOTE_NONE)
    for row in reader:
        print(row)

   The corresponding simplest possible writing example is:
import csv
with open('some.csv', 'w', newline='') as f:
    writer = csv.writer(f)
    writer.writerows(someiterable)

   Since open() is used to open a CSV file for reading, the file will by default be decoded into
   unicode using the system default encoding (see locale.getpreferredencoding()). To decode a file
   using a different encoding, use the encoding argument of open:
import csv
with open('some.csv', newline='', encoding='utf-8') as f:
    reader = csv.reader(f)
    for row in reader:
        print(row)

   The same applies to writing in something other than the system default encoding: specify the encoding
   argument when opening the output file.

   Registering a new dialect:
import csv
csv.register_dialect('unixpwd', delimiter=':', quoting=csv.QUOTE_NONE)
with open('passwd', newline='') as f:
    reader = csv.reader(f, 'unixpwd')

   A slightly more advanced use of the reader — catching and reporting errors:
import csv, sys
filename = 'some.csv'
with open(filename, newline='') as f:
    reader = csv.reader(f)
    try:
        for row in reader:
            print(row)
    except csv.Error as e:
        sys.exit('file {}, line {}: {}'.format(filename, reader.line_num, e))

   And while the module doesn’t directly support parsing strings, it can easily be done:
import csv
for row in csv.reader(['one,two,three']):
    print(row)

   Footnotes
   If newline='' is not specified, newlines embedded inside quoted fields will not
   be interpreted correctly, and on platforms that use \r\n linendings on write an extra \r will be
   added. It should always be safe to specify newline='', since the csv module does its own
   (universal) newline handling.


---
https://docs.python.org/3/library/collections.html#collections.OrderedDict

8.3. collections — Container datatypes

   Source code: Lib/collections/__init__.py
     ________________________________________________________________________________________________

   This module implements specialized container datatypes providing alternatives to Python’s general
   purpose built-in containers, dict, list, set, and tuple.
   namedtuple() factory function for creating tuple subclasses with named fields
   deque        list-like container with fast appends and pops on either end
   ChainMap     dict-like class for creating a single view of multiple mappings
   Counter      dict subclass for counting hashable objects
   OrderedDict  dict subclass that remembers the order entries were added
   defaultdict  dict subclass that calls a factory function to supply missing values
   UserDict     wrapper around dictionary objects for easier dict subclassing
   UserList     wrapper around list objects for easier list subclassing
   UserString   wrapper around string objects for easier string subclassing

   Changed in version 3.3: Moved Collections Abstract Base Classes to the collections.abc
   module. For backwards compatibility, they continue to be visible in this module as well.

8.3.1. ChainMap objects
   New in version 3.3.

   A ChainMap class is provided for quickly linking a number of mappings so they can be treated as a
   single unit. It is often much faster than creating a new dictionary and running multiple update()
   calls.

   The class can be used to simulate nested scopes and is useful in templating.

   class collections.ChainMap(*maps)
          A ChainMap groups multiple dicts or other mappings together to create a single, updateable
          view. If no maps are specified, a single empty dictionary is provided so that a new chain
          always has at least one mapping.

          The underlying mappings are stored in a list. That list is public and can be accessed or
          updated using the maps attribute. There is no other state.

          Lookups search the underlying mappings successively until a key is found. In contrast, writes,
          updates, and deletions only operate on the first mapping.

          A ChainMap incorporates the underlying mappings by reference. So, if one of the underlying
          mappings gets updated, those changes will be reflected in ChainMap.

          All of the usual dictionary methods are supported. In addition, there is a maps attribute, a
          method for creating new subcontexts, and a property for accessing all but the first mapping:

        maps
                A user updateable list of mappings. The list is ordered from first-searched to
                last-searched. It is the only stored state and can be modified to change which mappings
                are searched. The list should always contain at least one mapping.

        new_child(m=None)
                Returns a new ChainMap containing a new map followed by all of the maps in the
                current instance. If m is specified, it becomes the new map at the front of the list of
                mappings; if not specified, an empty dict is used, so that a call to d.new_child() is
                equivalent to: ChainMap({}, *d.maps). This method is used for creating subcontexts that
                can be updated without altering values in any of the parent mappings.

                Changed in version 3.4: The optional m parameter was added.

        parents
                Property returning a new ChainMap containing all of the maps in the current instance
                except the first one. This is useful for skipping the first map in the search. Use cases
                are similar to those for the nonlocal keyword used in nested scopes. The use
                cases also parallel those for the built-in super() function. A reference to
                d.parents is equivalent to: ChainMap(*d.maps[1:]).

   See also
     * The MultiContext class in the Enthought CodeTools package has options to support writing
       to any mapping in the chain.
     * Django’s Context class for templating is a read-only chain of mappings. It also features
       pushing and popping of contexts similar to the new_child() method and the parents()
       property.
     * The Nested Contexts recipe has options to control whether writes and other mutations apply
       only to the first mapping or to any mapping in the chain.
     * A greatly simplified read-only version of Chainmap.

8.3.1.1. ChainMap Examples and Recipes
   This section shows various approaches to working with chained maps.

   Example of simulating Python’s internal lookup chain:
import builtins
pylookup = ChainMap(locals(), globals(), vars(builtins))

   Example of letting user specified command-line arguments take precedence over environment variables
   which in turn take precedence over default values:
import os, argparse

defaults = {'color': 'red', 'user': 'guest'}

parser = argparse.ArgumentParser()
parser.add_argument('-u', '--user')
parser.add_argument('-c', '--color')
namespace = parser.parse_args()
command_line_args = {k:v for k, v in vars(namespace).items() if v}

combined = ChainMap(command_line_args, os.environ, defaults)
print(combined['color'])
print(combined['user'])

   Example patterns for using the ChainMap class to simulate nested contexts:
c = ChainMap()        # Create root context
d = c.new_child()     # Create nested child context
e = c.new_child()     # Child of c, independent from d
e.maps[0]             # Current context dictionary -- like Python's locals()
e.maps[-1]            # Root context -- like Python's globals()
e.parents             # Enclosing context chain -- like Python's nonlocals

d['x']                # Get first key in the chain of contexts
d['x'] = 1            # Set value in current context
del d['x']            # Delete from current context
list(d)               # All nested values
k in d                # Check all nested values
len(d)                # Number of nested values
d.items()             # All nested items
dict(d)               # Flatten into a regular dictionary

   The ChainMap class only makes updates (writes and deletions) to the first mapping in the chain
   while lookups will search the full chain. However, if deep writes and deletions are desired, it is
   easy to make a subclass that updates keys found deeper in the chain:
class DeepChainMap(ChainMap):
    'Variant of ChainMap that allows direct updates to inner scopes'

    def __setitem__(self, key, value):
        for mapping in self.maps:
            if key in mapping:
                mapping[key] = value
                return
        self.maps[0][key] = value

    def __delitem__(self, key):
        for mapping in self.maps:
            if key in mapping:
                del mapping[key]
                return
        raise KeyError(key)

>>> d = DeepChainMap({'zebra': 'black'}, {'elephant': 'blue'}, {'lion': 'yellow'})
>>> d['lion'] = 'orange'         # update an existing key two levels down
>>> d['snake'] = 'red'           # new keys get added to the topmost dict
>>> del d['elephant']            # remove an existing key one level down
DeepChainMap({'zebra': 'black', 'snake': 'red'}, {}, {'lion': 'orange'})

8.3.2. Counter objects
   A counter tool is provided to support convenient and rapid tallies. For example:
>>> # Tally occurrences of words in a list
>>> cnt = Counter()
>>> for word in ['red', 'blue', 'red', 'green', 'blue', 'blue']:
...     cnt[word] += 1
>>> cnt
Counter({'blue': 3, 'red': 2, 'green': 1})

>>> # Find the ten most common words in Hamlet
>>> import re
>>> words = re.findall(r'\w+', open('hamlet.txt').read().lower())
>>> Counter(words).most_common(10)
[('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631),
 ('you', 554),  ('a', 546), ('my', 514), ('hamlet', 471), ('in', 451)]

   class collections.Counter([iterable-or-mapping])
          A Counter is a dict subclass for counting hashable objects. It is an unordered
          collection where elements are stored as dictionary keys and their counts are stored as
          dictionary values. Counts are allowed to be any integer value including zero or negative
          counts. The Counter class is similar to bags or multisets in other languages.

          Elements are counted from an iterable or initialized from another mapping (or counter):

>>> c = Counter()                           # a new, empty counter
>>> c = Counter('gallahad')                 # a new counter from an iterable
>>> c = Counter({'red': 4, 'blue': 2})      # a new counter from a mapping
>>> c = Counter(cats=4, dogs=8)             # a new counter from keyword args

          Counter objects have a dictionary interface except that they return a zero count for missing
          items instead of raising a KeyError:

>>> c = Counter(['eggs', 'ham'])
>>> c['bacon']                              # count of a missing element is zero
0

          Setting a count to zero does not remove an element from a counter. Use del to remove it
          entirely:

>>> c['sausage'] = 0                        # counter entry with a zero count
>>> del c['sausage']                        # del actually removes the entry

          New in version 3.1.

          Counter objects support three methods beyond those available for all dictionaries:

        elements()
                Return an iterator over elements repeating each as many times as its count. Elements are
                returned in arbitrary order. If an element’s count is less than one, elements() will
                ignore it.

>>> c = Counter(a=4, b=2, c=0, d=-2)
>>> sorted(c.elements())
['a', 'a', 'a', 'a', 'b', 'b']

        most_common([n])
                Return a list of the n most common elements and their counts from the most common to the
                least. If n is omitted or None, most_common() returns all elements in the counter.
                Elements with equal counts are ordered arbitrarily:

>>> Counter('abracadabra').most_common(3)
[('a', 5), ('r', 2), ('b', 2)]

        subtract([iterable-or-mapping])
                Elements are subtracted from an iterable or from another mapping (or counter). Like
                dict.update() but subtracts counts instead of replacing them. Both inputs and
                outputs may be zero or negative.

>>> c = Counter(a=4, b=2, c=0, d=-2)
>>> d = Counter(a=1, b=2, c=3, d=4)
>>> c.subtract(d)
>>> c
Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6})

                New in version 3.2.

          The usual dictionary methods are available for Counter objects except for two which work
          differently for counters.

        fromkeys(iterable)
                This class method is not implemented for Counter objects.

        update([iterable-or-mapping])
                Elements are counted from an iterable or added-in from another mapping (or counter).
                Like dict.update() but adds counts instead of replacing them. Also, the iterable is
                expected to be a sequence of elements, not a sequence of (key, value) pairs.

   Common patterns for working with Counter objects:
sum(c.values())                 # total of all counts
c.clear()                       # reset all counts
list(c)                         # list unique elements
set(c)                          # convert to a set
dict(c)                         # convert to a regular dictionary
c.items()                       # convert to a list of (elem, cnt) pairs
Counter(dict(list_of_pairs))    # convert from a list of (elem, cnt) pairs
c.most_common()[:-n-1:-1]       # n least common elements
+c                              # remove zero and negative counts

   Several mathematical operations are provided for combining Counter objects to produce multisets
   (counters that have counts greater than zero). Addition and subtraction combine counters by adding or
   subtracting the counts of corresponding elements. Intersection and union return the minimum and
   maximum of corresponding counts. Each operation can accept inputs with signed counts, but the output
   will exclude results with counts of zero or less.
>>> c = Counter(a=3, b=1)
>>> d = Counter(a=1, b=2)
>>> c + d                       # add two counters together:  c[x] + d[x]
Counter({'a': 4, 'b': 3})
>>> c - d                       # subtract (keeping only positive counts)
Counter({'a': 2})
>>> c & d                       # intersection:  min(c[x], d[x])
Counter({'a': 1, 'b': 1})
>>> c | d                       # union:  max(c[x], d[x])
Counter({'a': 3, 'b': 2})

   Unary addition and subtraction are shortcuts for adding an empty counter or subtracting from an empty
   counter.
>>> c = Counter(a=2, b=-4)
>>> +c
Counter({'a': 2})
>>> -c
Counter({'b': 4})

   New in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations.

   Note

   Counters were primarily designed to work with positive integers to represent running counts; however,
   care was taken to not unnecessarily preclude use cases needing other types or negative values. To
   help with those use cases, this section documents the minimum range and type restrictions.
     * The Counter class itself is a dictionary subclass with no restrictions on its keys and
       values. The values are intended to be numbers representing counts, but you could store anything
       in the value field.
     * The most_common() method requires only that the values be orderable.
     * For in-place operations such as c[key] += 1, the value type need only support addition and
       subtraction. So fractions, floats, and decimals would work and negative values are supported. The
       same is also true for update() and subtract() which allow negative and zero values for both
       inputs and outputs.
     * The multiset methods are designed only for use cases with positive values. The inputs may be
       negative or zero, but only outputs with positive values are created. There are no type
       restrictions, but the value type needs to support addition, subtraction, and comparison.
     * The elements() method requires integer counts. It ignores zero and negative counts.

   See also
     * Bag class in Smalltalk.
     * Wikipedia entry for Multisets.
     * C++ multisets tutorial with examples.
     * For mathematical operations on multisets and their use cases, see Knuth, Donald. The Art of
       Computer Programming Volume II, Section 4.6.3, Exercise 19.
     * To enumerate all distinct multisets of a given size over a given set of elements, see
       itertools.combinations_with_replacement():

     map(Counter, combinations_with_replacement(‘ABC’, 2)) –> AA AB AC BB BC CC

8.3.3. deque objects
   class collections.deque([iterable[, maxlen]])
          Returns a new deque object initialized left-to-right (using append()) with data from
          iterable. If iterable is not specified, the new deque is empty.

          Deques are a generalization of stacks and queues (the name is pronounced “deck” and is short
          for “double-ended queue”). Deques support thread-safe, memory efficient appends and pops from
          either side of the deque with approximately the same O(1) performance in either direction.

          Though list objects support similar operations, they are optimized for fast fixed-length
          operations and incur O(n) memory movement costs for pop(0) and insert(0, v) operations which
          change both the size and position of the underlying data representation.

          If maxlen is not specified or is None, deques may grow to an arbitrary length. Otherwise, the
          deque is bounded to the specified maximum length. Once a bounded length deque is full, when
          new items are added, a corresponding number of items are discarded from the opposite end.
          Bounded length deques provide functionality similar to the tail filter in Unix. They are also
          useful for tracking transactions and other pools of data where only the most recent activity
          is of interest.

          Deque objects support the following methods:

        append(x)
                Add x to the right side of the deque.

        appendleft(x)
                Add x to the left side of the deque.

        clear()
                Remove all elements from the deque leaving it with length 0.

        copy()
                Create a shallow copy of the deque.

                New in version 3.5.

        count(x)
                Count the number of deque elements equal to x.

                New in version 3.2.

        extend(iterable)
                Extend the right side of the deque by appending elements from the iterable argument.

        extendleft(iterable)
                Extend the left side of the deque by appending elements from iterable. Note, the series
                of left appends results in reversing the order of elements in the iterable argument.

        index(x[, start[, stop]])
                Return the position of x in the deque (at or after index start and before index stop).
                Returns the first match or raises ValueError if not found.

                New in version 3.5.

        insert(i, x)
                Insert x into the deque at position i.

                If the insertion would cause a bounded deque to grow beyond maxlen, an IndexError
                is raised.

                New in version 3.5.

        pop()
                Remove and return an element from the right side of the deque. If no elements are
                present, raises an IndexError.

        popleft()
                Remove and return an element from the left side of the deque. If no elements are
                present, raises an IndexError.

        remove(value)
                Remove the first occurrence of value. If not found, raises a ValueError.

        reverse()
                Reverse the elements of the deque in-place and then return None.

                New in version 3.2.

        rotate(n)
                Rotate the deque n steps to the right. If n is negative, rotate to the left. Rotating
                one step to the right is equivalent to: d.appendleft(d.pop()).

          Deque objects also provide one read-only attribute:

        maxlen
                Maximum size of a deque or None if unbounded.

                New in version 3.1.

   In addition to the above, deques support iteration, pickling, len(d), reversed(d), copy.copy(d),
   copy.deepcopy(d), membership testing with the in operator, and subscript references such as
   d[-1]. Indexed access is O(1) at both ends but slows to O(n) in the middle. For fast random access,
   use lists instead.

   Starting in version 3.5, deques support __add__(), __mul__(), and __imul__().

   Example:
>>> from collections import deque
>>> d = deque('ghi')                 # make a new deque with three items
>>> for elem in d:                   # iterate over the deque's elements
...     print(elem.upper())
G
H
I

>>> d.append('j')                    # add a new entry to the right side
>>> d.appendleft('f')                # add a new entry to the left side
>>> d                                # show the representation of the deque
deque(['f', 'g', 'h', 'i', 'j'])

>>> d.pop()                          # return and remove the rightmost item
'j'
>>> d.popleft()                      # return and remove the leftmost item
'f'
>>> list(d)                          # list the contents of the deque
['g', 'h', 'i']
>>> d[0]                             # peek at leftmost item
'g'
>>> d[-1]                            # peek at rightmost item
'i'

>>> list(reversed(d))                # list the contents of a deque in reverse
['i', 'h', 'g']
>>> 'h' in d                         # search the deque
True
>>> d.extend('jkl')                  # add multiple elements at once
>>> d
deque(['g', 'h', 'i', 'j', 'k', 'l'])
>>> d.rotate(1)                      # right rotation
>>> d
deque(['l', 'g', 'h', 'i', 'j', 'k'])
>>> d.rotate(-1)                     # left rotation
>>> d
deque(['g', 'h', 'i', 'j', 'k', 'l'])

>>> deque(reversed(d))               # make a new deque in reverse order
deque(['l', 'k', 'j', 'i', 'h', 'g'])
>>> d.clear()                        # empty the deque
>>> d.pop()                          # cannot pop from an empty deque
Traceback (most recent call last):
    File "<pyshell#6>", line 1, in -toplevel-
        d.pop()
IndexError: pop from an empty deque

>>> d.extendleft('abc')              # extendleft() reverses the input order
>>> d
deque(['c', 'b', 'a'])

8.3.3.1. deque Recipes
   This section shows various approaches to working with deques.

   Bounded length deques provide functionality similar to the tail filter in Unix:
def tail(filename, n=10):
    'Return the last n lines of a file'
    with open(filename) as f:
        return deque(f, n)

   Another approach to using deques is to maintain a sequence of recently added elements by appending to
   the right and popping to the left:
def moving_average(iterable, n=3):
    # moving_average([40, 30, 50, 46, 39, 44]) --> 40.0 42.0 45.0 43.0
    # http://en.wikipedia.org/wiki/Moving_average
    it = iter(iterable)
    d = deque(itertools.islice(it, n-1))
    d.appendleft(0)
    s = sum(d)
    for elem in it:
        s += elem - d.popleft()
        d.append(elem)
        yield s / n

   The rotate() method provides a way to implement deque slicing and deletion. For example, a pure
   Python implementation of del d[n] relies on the rotate() method to position elements to be popped:
def delete_nth(d, n):
    d.rotate(-n)
    d.popleft()
    d.rotate(n)

   To implement deque slicing, use a similar approach applying rotate() to bring a target element
   to the left side of the deque. Remove old entries with popleft(), add new entries with extend(), and
   then reverse the rotation. With minor variations on that approach, it is easy to implement Forth
   style stack manipulations such as dup, drop, swap, over, pick, rot, and roll.

8.3.4. defaultdict objects
   class collections.defaultdict([default_factory[, ...]])
          Returns a new dictionary-like object. defaultdict is a subclass of the built-in dict
          class. It overrides one method and adds one writable instance variable. The remaining
          functionality is the same as for the dict class and is not documented here.

          The first argument provides the initial value for the default_factory attribute; it
          defaults to None. All remaining arguments are treated the same as if they were passed to the
          dict constructor, including keyword arguments.

          defaultdict objects support the following method in addition to the standard dict
          operations:

        __missing__(key)
                If the default_factory attribute is None, this raises a KeyError exception
                with the key as argument.

                If default_factory is not None, it is called without arguments to provide a default
                value for the given key, this value is inserted in the dictionary for the key, and
                returned.

                If calling default_factory raises an exception this exception is propagated
                unchanged.

                This method is called by the __getitem__() method of the dict class when the
                requested key is not found; whatever it returns or raises is then returned or raised by
                __getitem__().

                Note that __missing__() is not called for any operations besides
                __getitem__(). This means that get() will, like normal dictionaries, return None as
                a default rather than using default_factory.

          defaultdict objects support the following instance variable:

        default_factory
                This attribute is used by the __missing__() method; it is initialized from the
                first argument to the constructor, if present, or to None, if absent.

8.3.4.1. defaultdict Examples
   Using list as the default_factory, it is easy to group a sequence of key-value pairs into a
   dictionary of lists:
>>> s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
>>> d = defaultdict(list)
>>> for k, v in s:
...     d[k].append(v)
...
>>> sorted(d.items())
[('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]

   When each key is encountered for the first time, it is not already in the mapping; so an entry is
   automatically created using the default_factory function which returns an empty list. The
   list.append() operation then attaches the value to the new list. When keys are encountered again, the
   look-up proceeds normally (returning the list for that key) and the list.append() operation adds
   another value to the list. This technique is simpler and faster than an equivalent technique using
   dict.setdefault():
>>> d = {}
>>> for k, v in s:
...     d.setdefault(k, []).append(v)
...
>>> sorted(d.items())
[('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]

   Setting the default_factory to int makes the defaultdict useful for counting (like a bag or
   multiset in other languages):
>>> s = 'mississippi'
>>> d = defaultdict(int)
>>> for k in s:
...     d[k] += 1
...
>>> sorted(d.items())
[('i', 4), ('m', 1), ('p', 2), ('s', 4)]

   When a letter is first encountered, it is missing from the mapping, so the default_factory function
   calls int() to supply a default count of zero. The increment operation then builds up the count
   for each letter.

   The function int() which always returns zero is just a special case of constant functions. A
   faster and more flexible way to create constant functions is to use a lambda function which can
   supply any constant value (not just zero):
>>> def constant_factory(value):
...     return lambda: value
>>> d = defaultdict(constant_factory('<missing>'))
>>> d.update(name='John', action='ran')
>>> '%(name)s %(action)s to %(object)s' % d
'John ran to <missing>'

   Setting the default_factory to set makes the defaultdict useful for building a dictionary
   of sets:
>>> s = [('red', 1), ('blue', 2), ('red', 3), ('blue', 4), ('red', 1), ('blue', 4)]
>>> d = defaultdict(set)
>>> for k, v in s:
...     d[k].add(v)
...
>>> sorted(d.items())
[('blue', {2, 4}), ('red', {1, 3})]

8.3.5. namedtuple() Factory Function for Tuples with Named Fields
   Named tuples assign meaning to each position in a tuple and allow for more readable, self-documenting
   code. They can be used wherever regular tuples are used, and they add the ability to access fields by
   name instead of position index.

   collections.namedtuple(typename, field_names, *, verbose=False, rename=False, module=None)
          Returns a new tuple subclass named typename. The new subclass is used to create tuple-like
          objects that have fields accessible by attribute lookup as well as being indexable and
          iterable. Instances of the subclass also have a helpful docstring (with typename and
          field_names) and a helpful __repr__() method which lists the tuple contents in a
          name=value format.

          The field_names are a sequence of strings such as ['x', 'y']. Alternatively, field_names can
          be a single string with each fieldname separated by whitespace and/or commas, for example 'x
          y' or 'x, y'.

          Any valid Python identifier may be used for a fieldname except for names starting with an
          underscore. Valid identifiers consist of letters, digits, and underscores but do not start
          with a digit or underscore and cannot be a keyword such as class, for, return, global,
          pass, or raise.

          If rename is true, invalid fieldnames are automatically replaced with positional names. For
          example, ['abc', 'def', 'ghi', 'abc'] is converted to ['abc', '_1', 'ghi', '_3'], eliminating
          the keyword def and the duplicate fieldname abc.

          If verbose is true, the class definition is printed after it is built. This option is
          outdated; instead, it is simpler to print the _source attribute.

          If module is defined, the __module__ attribute of the named tuple is set to that value.

          Named tuple instances do not have per-instance dictionaries, so they are lightweight and
          require no more memory than regular tuples.

          Changed in version 3.1: Added support for rename.

          Changed in version 3.6: The verbose and rename parameters became keyword-only arguments.

          Changed in version 3.6: Added the module parameter.

>>> # Basic example
>>> Point = namedtuple('Point', ['x', 'y'])
>>> p = Point(11, y=22)     # instantiate with positional or keyword arguments
>>> p[0] + p[1]             # indexable like the plain tuple (11, 22)
33
>>> x, y = p                # unpack like a regular tuple
>>> x, y
(11, 22)
>>> p.x + p.y               # fields also accessible by name
33
>>> p                       # readable __repr__ with a name=value style
Point(x=11, y=22)

   Named tuples are especially useful for assigning field names to result tuples returned by the
   csv or sqlite3 modules:
EmployeeRecord = namedtuple('EmployeeRecord', 'name, age, title, department, paygrade')

import csv
for emp in map(EmployeeRecord._make, csv.reader(open("employees.csv", "rb"))):
    print(emp.name, emp.title)

import sqlite3
conn = sqlite3.connect('/companydata')
cursor = conn.cursor()
cursor.execute('SELECT name, age, title, department, paygrade FROM employees')
for emp in map(EmployeeRecord._make, cursor.fetchall()):
    print(emp.name, emp.title)

   In addition to the methods inherited from tuples, named tuples support three additional methods and
   two attributes. To prevent conflicts with field names, the method and attribute names start with an
   underscore.

   classmethod somenamedtuple._make(iterable)
          Class method that makes a new instance from an existing sequence or iterable.

>>> t = [11, 22]
>>> Point._make(t)
Point(x=11, y=22)

   somenamedtuple._asdict()
          Return a new OrderedDict which maps field names to their corresponding values:

>>> p = Point(x=11, y=22)
>>> p._asdict()
OrderedDict([('x', 11), ('y', 22)])

          Changed in version 3.1: Returns an OrderedDict instead of a regular dict.

   somenamedtuple._replace(**kwargs)
          Return a new instance of the named tuple replacing specified fields with new values:

>>> p = Point(x=11, y=22)
>>> p._replace(x=33)
Point(x=33, y=22)

>>> for partnum, record in inventory.items():
...     inventory[partnum] = record._replace(price=newprices[partnum], timestamp=time.now())

   somenamedtuple._source
          A string with the pure Python source code used to create the named tuple class. The source
          makes the named tuple self-documenting. It can be printed, executed using exec(), or
          saved to a file and imported.

          New in version 3.3.

   somenamedtuple._fields
          Tuple of strings listing the field names. Useful for introspection and for creating new named
          tuple types from existing named tuples.

>>> p._fields            # view the field names
('x', 'y')

>>> Color = namedtuple('Color', 'red green blue')
>>> Pixel = namedtuple('Pixel', Point._fields + Color._fields)
>>> Pixel(11, 22, 128, 255, 0)
Pixel(x=11, y=22, red=128, green=255, blue=0)

   To retrieve a field whose name is stored in a string, use the getattr() function:
>>> getattr(p, 'x')
11

   To convert a dictionary to a named tuple, use the double-star-operator (as described in
   Unpacking Argument Lists):
>>> d = {'x': 11, 'y': 22}
>>> Point(**d)
Point(x=11, y=22)

   Since a named tuple is a regular Python class, it is easy to add or change functionality with a
   subclass. Here is how to add a calculated field and a fixed-width print format:
>>> class Point(namedtuple('Point', ['x', 'y'])):
...     __slots__ = ()
...     @property
...     def hypot(self):
...         return (self.x ** 2 + self.y ** 2) ** 0.5
...     def __str__(self):
...         return 'Point: x=%6.3f  y=%6.3f  hypot=%6.3f' % (self.x, self.y, self.hypot)

>>> for p in Point(3, 4), Point(14, 5/7):
...     print(p)
Point: x= 3.000  y= 4.000  hypot= 5.000
Point: x=14.000  y= 0.714  hypot=14.018

   The subclass shown above sets __slots__ to an empty tuple. This helps keep memory requirements low by
   preventing the creation of instance dictionaries.

   Subclassing is not useful for adding new, stored fields. Instead, simply create a new named tuple
   type from the _fields attribute:
>>> Point3D = namedtuple('Point3D', Point._fields + ('z',))

   Docstrings can be customized by making direct assignments to the __doc__ fields:
>>> Book = namedtuple('Book', ['id', 'title', 'authors'])
>>> Book.__doc__ += ': Hardcover book in active collection'
>>> Book.id.__doc__ = '13-digit ISBN'
>>> Book.title.__doc__ = 'Title of first printing'
>>> Book.authors.__doc__ = 'List of authors sorted by last name'

   Changed in version 3.5: Property docstrings became writeable.

   Default values can be implemented by using _replace() to customize a prototype instance:
>>> Account = namedtuple('Account', 'owner balance transaction_count')
>>> default_account = Account('<owner name>', 0.0, 0)
>>> johns_account = default_account._replace(owner='John')
>>> janes_account = default_account._replace(owner='Jane')

   See also
     * Recipe for named tuple abstract base class with a metaclass mix-in by Jan Kaliszewski.
       Besides providing an abstract base class for named tuples, it also supports an alternate
       metaclass-based constructor that is convenient for use cases where named tuples are being
       subclassed.
     * See types.SimpleNamespace() for a mutable namespace based on an underlying dictionary
       instead of a tuple.
     * See typing.NamedTuple() for a way to add type hints for named tuples.

8.3.6. OrderedDict objects
   Ordered dictionaries are just like regular dictionaries but they remember the order that items were
   inserted. When iterating over an ordered dictionary, the items are returned in the order their keys
   were first added.

   class collections.OrderedDict([items])
          Return an instance of a dict subclass, supporting the usual dict methods. An OrderedDict
          is a dict that remembers the order that keys were first inserted. If a new entry overwrites an
          existing entry, the original insertion position is left unchanged. Deleting an entry and
          reinserting it will move it to the end.

          New in version 3.1.

        popitem(last=True)
                The popitem() method for ordered dictionaries returns and removes a (key, value)
                pair. The pairs are returned in LIFO order if last is true or FIFO order if false.

        move_to_end(key, last=True)
                Move an existing key to either end of an ordered dictionary. The item is moved to the
                right end if last is true (the default) or to the beginning if last is false. Raises
                KeyError if the key does not exist:

>>> d = OrderedDict.fromkeys('abcde')
>>> d.move_to_end('b')
>>> ''.join(d.keys())
'acdeb'
>>> d.move_to_end('b', last=False)
>>> ''.join(d.keys())
'bacde'

                New in version 3.2.

   In addition to the usual mapping methods, ordered dictionaries also support reverse iteration using
   reversed().

   Equality tests between OrderedDict objects are order-sensitive and are implemented as
   list(od1.items())==list(od2.items()). Equality tests between OrderedDict objects and other
   Mapping objects are order-insensitive like regular dictionaries. This allows OrderedDict
   objects to be substituted anywhere a regular dictionary is used.

   Changed in version 3.5: The items, keys, and values views of OrderedDict now support
   reverse iteration using reversed().

   Changed in version 3.6: With the acceptance of PEP 468, order is retained for keyword arguments
   passed to the OrderedDict constructor and its update() method.

8.3.6.1. OrderedDict Examples and Recipes
   Since an ordered dictionary remembers its insertion order, it can be used in conjunction with sorting
   to make a sorted dictionary:
>>> # regular unsorted dictionary
>>> d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2}

>>> # dictionary sorted by key
>>> OrderedDict(sorted(d.items(), key=lambda t: t[0]))
OrderedDict([('apple', 4), ('banana', 3), ('orange', 2), ('pear', 1)])

>>> # dictionary sorted by value
>>> OrderedDict(sorted(d.items(), key=lambda t: t[1]))
OrderedDict([('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)])

>>> # dictionary sorted by length of the key string
>>> OrderedDict(sorted(d.items(), key=lambda t: len(t[0])))
OrderedDict([('pear', 1), ('apple', 4), ('orange', 2), ('banana', 3)])

   The new sorted dictionaries maintain their sort order when entries are deleted. But when new keys are
   added, the keys are appended to the end and the sort is not maintained.

   It is also straight-forward to create an ordered dictionary variant that remembers the order the keys
   were last inserted. If a new entry overwrites an existing entry, the original insertion position is
   changed and moved to the end:
class LastUpdatedOrderedDict(OrderedDict):
    'Store items in the order the keys were last added'

    def __setitem__(self, key, value):
        if key in self:
            del self[key]
        OrderedDict.__setitem__(self, key, value)

   An ordered dictionary can be combined with the Counter class so that the counter remembers the
   order elements are first encountered:
class OrderedCounter(Counter, OrderedDict):
    'Counter that remembers the order elements are first encountered'

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, OrderedDict(self))

    def __reduce__(self):
        return self.__class__, (OrderedDict(self),)

8.3.7. UserDict objects
   The class, UserDict acts as a wrapper around dictionary objects. The need for this class has
   been partially supplanted by the ability to subclass directly from dict; however, this class can
   be easier to work with because the underlying dictionary is accessible as an attribute.

   class collections.UserDict([initialdata])
          Class that simulates a dictionary. The instance’s contents are kept in a regular dictionary,
          which is accessible via the data attribute of UserDict instances. If initialdata is
          provided, data is initialized with its contents; note that a reference to initialdata
          will not be kept, allowing it be used for other purposes.

          In addition to supporting the methods and operations of mappings, UserDict instances
          provide the following attribute:

        data
                A real dictionary used to store the contents of the UserDict class.

8.3.8. UserList objects
   This class acts as a wrapper around list objects. It is a useful base class for your own list-like
   classes which can inherit from them and override existing methods or add new ones. In this way, one
   can add new behaviors to lists.

   The need for this class has been partially supplanted by the ability to subclass directly from
   list; however, this class can be easier to work with because the underlying list is accessible
   as an attribute.

   class collections.UserList([list])
          Class that simulates a list. The instance’s contents are kept in a regular list, which is
          accessible via the data attribute of UserList instances. The instance’s contents are
          initially set to a copy of list, defaulting to the empty list []. list can be any iterable,
          for example a real Python list or a UserList object.

          In addition to supporting the methods and operations of mutable sequences, UserList
          instances provide the following attribute:

        data
                A real list object used to store the contents of the UserList class.

   Subclassing requirements: Subclasses of UserList are expected to offer a constructor which can
   be called with either no arguments or one argument. List operations which return a new sequence
   attempt to create an instance of the actual implementation class. To do so, it assumes that the
   constructor can be called with a single parameter, which is a sequence object used as a data source.

   If a derived class does not wish to comply with this requirement, all of the special methods
   supported by this class will need to be overridden; please consult the sources for information about
   the methods which need to be provided in that case.

8.3.9. UserString objects
   The class, UserString acts as a wrapper around string objects. The need for this class has been
   partially supplanted by the ability to subclass directly from str; however, this class can be
   easier to work with because the underlying string is accessible as an attribute.

   class collections.UserString([sequence])
          Class that simulates a string or a Unicode string object. The instance’s content is kept in a
          regular string object, which is accessible via the data attribute of UserString
          instances. The instance’s contents are initially set to a copy of sequence. The sequence can
          be an instance of bytes, str, UserString (or a subclass) or an arbitrary
          sequence which can be converted into a string using the built-in str() function.

          Changed in version 3.5: New methods __getnewargs__, __rmod__, casefold, format_map,
          isprintable, and maketrans.
