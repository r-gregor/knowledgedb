filename: ptn_python-project-freezing-multif_20180912.txt
https://hackernoon.com/the-one-stop-guide-to-easy-cross-platform-python-freezing-part-1-c53e66556a0a

The one-stop guide to (easy) cross-platform Python freezing: Part 1

   It’s been almost an year since I have been a maintainer for [18]MusicBrainz Picard, a cross-platform
   multi-lingual desktop app, that allows you to tag your music files via this [19]very cool service
   called MusicBrainz.

   Picard, I’d say is a fairly large python app with about ~35k SLoC. With a python app of such size,
   come challenges. One of the toughest challenges I faced this last year has been packaging Picard for
   all the three platforms that it supports, Linux, macOS and Windows after I ported it to Python
   3/PyQt5 for my GSoC project. You can read more about that [20]here.

     “Freezing” your code is creating an executable file to distribute to end-users, that contains all
     of your application code as well as the Python interpreter.

     The advantage of distributing this way is that your application will “just work”, even if the user
     doesn’t already have the required version of Python (or any) installed. On Windows, and even on
     many Linux distributions and OS X, the right version of Python will not already be installed.

     - Hitchhiker’s Guide to Python

Testing my options
   Our existing setup used py2exe and py2app to freeze Picard for Windows and macOS respectively. Since
   they don’t entirely support Python 3 and PyQt5, I was on the lookout for a new freezing tool. I
   finally settled on [22]PyInstaller after testing waters with [23]cx_Freeze.

PyInstaller — A happy surprise
   One thing I’d like to say about PyInstaller — I was absolutely surprised how easy it was to freeze my
   python application, while putting minimal efforts from my side, chasing mythical dependencies. It
   supports Python 2 and 3 and all 3 desktop OSes and even allows you to create portable all-in-one
   binaries for each. How cool is that!

   I plan on giving you a small glimpse of how powerful and simple PyInstaller is, and how, coupled with
   [24]AppVeyor and [25]TravisCI, you can package your python apps for Windows and macOS without even
   having access to either of them.
     ________________________________________________________________________________________________

Getting started
   In this part of the blog, we will be making a PyInstaller spec file and freezing our package. In the
   next part, we will be looking into TravisCI and AppVeyor for continuous delivery.

Installing PyInstaller
   All you need to do is pip install pyinstaller . It is as simple as that. You can either install it
   globally or in a virtual environment housing your project. The latter is obviously preferable. This
   will give you access to mainly 2 scripts that we will be using in the rest of this
   tutorial — pyinstaller and pyi-makespec .

Project info and structure
   Let’s start with a very basic structure to introduce PyInstaller and make adjustments from there on,
   as per our needs.
package_dir
├── package
│   ├── submodule_bar
│   ├── submodule_foo
│   ├── __init__.py
│   └── main.py
├── entry_point.py
└── setup.py

   The above assume that you have an entry point script called entry_point.py which launches your
   application. See [26]python-packaging for help on how to package your app.

   Now comes the magical part. All you need to do to freeze your app is

   pyinstaller entry_point.py -n foobar

   It is as simple as that! PyInstaller will automagically figure out all the dependencies, include all
   the dynamic libraries that need to be loaded and create adistdirectory with the frozen app named
   foobar.

   The output should as follows
package_dir
├── dist
│   └── foobar
│       ├── ...
│       ├── ...
│       ├── ...
│       └── foobar
├── package
│   ├── submodule_bar
│   ├── submodule_foo
│   ├── __init__.py
│   └── main.py
├── entry_point.py
├── foobar.spec
└── setup.py

   You can execute your app by launching dist/foobar/foobar (Of course it will be foobar.exe or
   foobar.app on Windows and macOS respectively.

Portable apps, what is this magic?
   Now let’s take things a bit further. What if you want you entire app bundled with all its
   dependencies as a single portable executable? Simple, just pass the --onefile flag to PyInstaller.

   pyinstaller entry_point.py -n foobar --onefile

   PyInstaller will output a single portable executable in the dist folder named foobar which can easily
   be launched. Again, PyInstaller will automagically find and bundle all the dependencies inside that
   one file!
     ________________________________________________________________________________________________

It can’t surely be that simple? Can it? What if I need to…

Bundle Libraries
   PyInstaller supports a lot of major frameworks and libraries out of the box. This includes —

   Babel, Django, IPython, matplotlib, numpy, pillow, PyGTK, PyQt4, PyQt5, scipy, sphinx, SQLAlchemy,
   wxPython and many more.

   If your app depends on any of the above libraries, you don’t need to worry about the hassles of
   including dependent libraries, dlls, hidden imports, packages or anything else for that matter.
   PyInstaller takes care of everything for you. It inspects your code recursively and figures out all
   the dependencies.

Add and bundle resources
   Resources can be anything, images, icons, textual data, translation strings. There is a very simple
   recipe to bundle and access your resources. For simplicity, let’s assume all your resources are
   available inside a directory called resources as below —
package_dir
├── package
│   ├── submodule_bar
│   ├── submodule_foo
│   ├── __init__.py
│   └── main.py
├── resources
│   ├── bar.dat
│   └── foo.png
├── entry_point.py
└── setup.py

   Bundling the resources
   Run pyi-makespec entry_point.py -n foobar --onefile. The pyi-makespec script accepts the same
   arguments as pyinstaller but instead of actually running PyInstaller, it creates a foobar.spec spec
   file for you to customise, which can then be called with pyinstaller foobar.spec.

   Your foobar.spec file should look something like this —
   https://hackernoon.com/media/bff7bb66aa209c51983f6991a8d99b26?postId=c53e66556a0a

   The spec file is simply a python script albeit with some special callables as shown above. To add
   resources, you simply need to create an array with a list of tuples —
     * The first string specifies the file or files as they are in this system now.
     * The second specifies the name of the folder to contain the files at run-time.

   A simple script to do the same would be —
   https://hackernoon.com/media/5896eea1d4bb6d584f014323c386c40f?postId=c53e66556a0a

   You will be adding the above code to the spec file, which should now look like this —
   https://hackernoon.com/media/6e566f23e898b918fdc7129a69e5cfa7?postId=c53e66556a0a

   Notice the call to get_resources() in a.datas .

   Accessing bundled resources

   Quoting from the PyInstaller wiki —

     You may need to learn at run-time whether the app is running from source, or is “frozen”
     (bundled). For example, you might have data files that are normally found based on a module’s
     __file__ attribute. That will not work when the code is bundled.

     The PyInstaller bootloader adds the name frozen to the sys module. So the test for “are we
     bundled?”

   To summarise, this is what you need to do to access any resources you have bundled —

   Add the following two variables to your utility section —
   https://hackernoon.com/media/4c5b22ff5b9fa967f6d749e73c120831?postId=c53e66556a0a

   You can then use this in your entry_point.py as follows —
   https://hackernoon.com/media/d094b254e31e093ff3565aa35cbd6259?postId=c53e66556a0a

   You can now load your resources in main.py as follows —
   https://hackernoon.com/media/8c223f13b12df58fdd1e19573a59047c?postId=c53e66556a0a

Bundle binaries
   PyInstaller should automagically bundle any .so or .dll files by inspecting your python module. But
   in case it [35]fails to do so, it is easy to add them.

   Bundling binaries or libraries that your app depends on is pretty much similar to how you would
   bundle data files.

   Assuming the following directory structure —
package_dir
├── bin
│   ├── bar.so
│   ├── bar.dll
│   └── bar.dylib
├── package
│   ├── submodule_bar
│   ├── submodule_foo
│   ├── __init__.py
│   └── main.py
├── resources
│   ├── bar.dat
│   └── foo.png
├── entry_point.py
└── setup.py

   Let’s say your app depends on a shared library bar, and you have binaries available for it for all 3
   operating systems.

   You might go around including them as follows —
   https://hackernoon.com/media/402576d2e67f60ee00cd274f7d4d261e?postId=c53e66556a0a

   You might ask, what’s the difference between adding a file as a data file or a binary file, well
   quoting from the PyInstaller Wiki —

     Binary files refers to DLLs, dynamic libraries, shared object-files, and such, which PyInstaller
     is going to search for further binary dependencies. Files like images and PDFs should go into
     thedatas

   So make sure you are adding any dlls or so files as binaries instead of data files.

Freeze a GUI app
   You will probably want to pass the --windowed flag to pyinstaller in order to make sure there is no
   console while opening the App.

Freeze a macOS app

   If you are freezing a one-file windowed macOS app you will want to add an additional callable to your
   spec file like so —
   https://hackernoon.com/media/886bd31ba6ff956da2d98d7870add67e?postId=c53e66556a0a

   See the PyInstaller-Wiki for more information about these options.

     Note: For simple cases, you can also accomplish all the of the above through flags passed to the
     pyisntaller or pyi-makespec scripts. See [39]Using Spec Files for more information.

What’s next?
   The above recipes should be more than enough for all general use cases. I hope the above provides a
   basic guide on how to use PyInstaller. For more advanced use cases, you can sift through the
   PyInstaller Wiki.

   If you want to see the above guide in action, you can have a look at the Picard github repo.

   In the next part of this blog, we will learn how to make use of AppVeyor and TravisCI along with
   PyInstaller to bundle our applications.

HALLLLP, I am stuck!

   If you find yourself unable to comprehend any part of the guide or have a very particular use-case,
   leave a comment below, I will be happy to help if I can :)


---
https://medium.com/@amimahloof/how-to-package-a-python-project-with-all-of-its-dependencies-for-offline-install-7eb240b27418

How to package a python project with all of its dependencies for offline install.

   I’m writing this post to show the way I think is the correct way for installing and packaging python
   apps with all their dependencies.

   Often you need to have a package that you can use to install the app and it’s dependencies without
   reaching the internet at all, it could be a remote server with only access to internal network for
   security reasons, and it could be that one of your dependencies is hosted on a private git repository
   and you don’t want to hard code the git token for installing it over https, for example, a docker
   container.

   My approach is combing SetupTools, DistUtils, and pip Wheel for a final tar.gz format.

   I assume you already familiar with the basics of packaging:
   https://python-packaging.readthedocs.io/en/latest/minimal.html

   basic python packaging requires the minimum of a setup.py file in the root of your project which then
   you can call on python setup.py sdist

   https://medium.com/media/a3bd4f55ed5526f45ea5dc852d37030a?postId=7eb240b27418
   
   setup.py gist
   https://gist.github.com/innovia/c1fd315ae186fd402a723af0564817a7
   
   The cmdclass is an extension to setuptools and is the class that will package the code for
   distribution but also collects all packages from requirements.txt into the archive.
   This script below (package.py) is a setuptools command extension for creating a distribution from a
   project.
   normal python setup sdist will only pack files and folders, while this script go over the
   requirements.txt will make a wheel
   (zip like archive) of the requirement to be stored at wheelhouse folder and packed together with
   the code as a single tar.gz file.

   Packaging Caveat:
   This script collects the installed (compiled) requirements from where it runs, this means that if
   your requirements.txt contains any requirements that are based on C-extensions such as psycopg for
   example, the compiled package will be collected.
   When you unpack the archive at the destination if the system is different than the system you
   collected the package from it will not work as intended and even crash.

   let me re-iterate this:
   ubuntu != centos != macOS
   python2.6 != python2.7

   You can however, package on ubuntu when the target system is Debian since they are the same family.

   https://medium.com/media/47e81af4f2fc5b5b29f24298ed01cf88?postId=7eb240b27418

   This script can only run from the same family due to C-extensions that needs to be compiled on
   specific
   platform (i.e psycopg etc…).

   What this script does:

   This script is deleting and recreating wheelhouse folder in the root of your project dir.

   It then calls pip wheel -r requirements.txt which collects installed packages from the current
   environment they are installed into .whl files in the wheelhouse, then the script creates a local
   requirements.txt file without any http links in it, just the local package name as its stored in the
   wheelhouse, the reason for this is the way that pip works.

   After the package is unpacked at the target destination, the requirements can be installed locally
   and offline from the wheelhouse folder using the option --no-index on pip install which ignores
   package index (only looking at --find-links URLs instead).
   --find-links <url | path> looks for archive from url or path.
   Since the original requirements.txt might have links to a non pip repo such as Github (https) pip
   will parse the links for the archive from a url and not from the wheelhouse, resulting in a http
   request.
   This functions creates a new requirements.txt (it will backup the original requirements.txt into
   requirements.orig, and restore after packaging) with t only the name and version for each of the
   packages, thus eliminating the need to fetch / parse links from http sources and install all archives
   completely offline from the wheelhouse.

   Finally, the script calls setuptools sdist — so you can change this to whatever format you want that
   is supported by setuptools.
   MANIFEST.in
   The last part for packaging the wheelhouse we need to tell setuptools to include this folder in the
   archive using graft wheelhouse:

   https://medium.com/media/fef45878014aa3e78c379333945f038e?postId=7eb240b27418

   Notice that I prune (delete/skip from the archive) git folder itself.

   Putting it all together:
   Create the files in the root of your project:
     * package.py
     * setup.py
     * MANIFEST.in

   Call python setup.py package :
   this will delete and recreate the wheelhouse folder on the root of your project, then it will collect
   the packages into the wheelhouse folder.
   The last step will create the archive in the dist folder on the root of your project.

   At this point you may copy the archive into a docker image or into your server any way you like.

   Unpacking:
   To unpack simply tar zxf archive.tar.gz and then call
pip install -r requirements.txt --use-wheel --no-index --find-links wheelhouse

   your packages will be installed completely offline.

   Bonus Tip:
   If you plan on running this archive in docker container, i suggest you build a python docker image
   with all gcc OpenSSL and other build libs for installing all the dependancies on and from this
   container run setup.py package into a shared mount volume / copy to wherever you want. this way your
   runtime container is lean and does not need all the heavy build libs.


---
https://askubuntu.com/questions/90764/how-do-i-create-a-deb-package-for-a-single-python-script

How do I create a deb package for a single python script?

   I have a single python script that I want to distribute as a deb package. It is a [48]indicator which
   shows local date in Unity panel. I did follow [49]create a .deb Package from scripts or binaries but
   I could not create a deb package because it fails.

   Can someone give me a step-by-step instruction on what I should do? As far as I know this script
   depends on python-appindicator.

   NOTE:
   I do not want any links to Debian/Ubuntu packaging instructions. I have seen most of them. I don't
   find them beginner friendly.

***   
       While Debian and Ubuntu packaging instructions aren't beginner friendly (trust me, I know), many
       GUI applications that create debs for you just turn up a bunch of errors when you run a final
       package checker, such as lintian. If you're serious about packaging, then toughing it out and
       working through the instructions is the best way to go :) – [59]Thomas Boxley Dec 30 '11 at 14:03
     * I don't know about packaging, but the functionality you are trying to add is built in to Unity.

***
   What follows is a basic example of how a source package for a python script might look. While most of
   the packaging tutorials are a bit complex, they can really help if you hit a problem. That said, I
   first learned the basics of Debian packaging by simply looking at Debian packages. apt-get source
   something similar and learn by example.

   Here's your basic source package layout:
my-script/
    -- myScript
    -- debian/
        -- changelog
        -- copyright
        -- compat
        -- rules
        -- control
        -- install

   Run dch --create in the directory to create a properly formatted debian/changelog entry.

   debian/copyright should look like:
Format: http://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
Upstream-Name: myScript
Upstream-Contact: Name, <email@address>

Files: *
Copyright: 2011, Name, <email@address>
License: (GPL-2+ | LGPL-2 | GPL-3 | whatever)
 Full text of licence.
 .
 Unless there is a it can be found in /usr/share/common-licenses

   debian/compat can just be: 7

   debian/rules:
#!/usr/bin/make -f

%:
    dh $@ --with python2

   Note that there must be "tab" before dh $@ --with python2, not spaces.

   debian/control:
Source: my-script
Section: python
Priority: optional
Maintainer: Name, <email@address>
Build-Depends: debhelper (>= 7),
               python (>= 2.6.6-3~)
Standards-Version: 3.9.2
X-Python-Version: >= 2.6


Package: my-script
Architecture: all
Section: python
Depends: python-appindicator, ${misc:Depends}, ${python:Depends}
Description: short description
 A long description goes here.
 .
 It can contain multiple paragraphs

   debian/install:
myScript usr/bin/

   This file indicates which file will be installed into which folder.

   Now build it with debuild --no-tgz-check

   This will create a functional deb package. Lintian is going to throw a few warnings regarding the
   lack of an orig.tar.gz, but unless you plan on creating a proper upstream project that makes tarball
   releases you'll probably just want to ignore that for now.

***
       As a packager (and a backporter), I package python scripts fairly often. I can safely say that
       this answer here is the most complete explanation of what to do to create a package for a single
       python script. – [69]Thomas Ward♦ Dec 31 '11 at 0:24

***
       Could you also update it for Python 3? I guess we need to make changes in debian/rules and
       debian/control, but I am not sure about that. – [70]Aditya Jan 3 '14 at 16:14

***
       @Aditya, maybe a new question is in order for Python3? The answer wouldn't be very different, but
       this answer is aiming to be the simplest/bare minimum example of how to package a Python script.
       Not sure I want to clutter it up with multiple implementations. – [71]andrewsomething Jan 3 '14

***
     * @andrewsomething: Then you might be interested in [72]this one which prompted me to leave that
       comment... A bit of editing is required on that one, I would try my hand at it... – [73]Aditya
       Jan 3 '14 at 16:50

***
       What about the libraries? If the python script imports libraries then it won't work – [74]D.Snap
       Mar 16 '16 at 9:20

***
    1. create a folder with any name on your home eg: mypyscript
    2. Open the folder and create two folders with names 'DEBIAN' and 'usr'
    3. Open the folder DEBIAN. Create a text file (without extension) with name 'control' there.
    4. Open 'control' and type as follows and save it on DEBIAN
Package: mypyscript
Version: 0.01
Architecture: all
Maintainer: your name<your mail id>
Installed-Size: 2
Depends: python-appindicator
Section: extras
Priority: optional
Homepage: your homepage
Description: describe

    5. Back to the folder named mypyscript. Open 'usr'. Create a folder named 'bin'. Open 'bin' and
       paste your pythonscript file there.
    6. You can also make a menu entry. But that is not essential.
    7. Back to the home folder where the folder 'mypyscript' lies or close the file browser.
    8. Open terminal. Be sure that terminal is in the home folder. type dpkg -b mypyscript .Then press
       enter. In seconds your deb package is ready

   note: please fill the 'control' file properly. Don't use apostrophes. It is only for indicating the
   names.

***
       Worked so fine. :-) Thanks! – [81]Ionică Bizău Nov 4 '13 at 18:05

***
       Works great! The accepted answer is complex. – [82]SuB Jan 8 '14 at 13:24
     * Don't forget to change permission of 'myscript' to 755 and the owner of it to root. – [83]SuB Jan

***
   I would check out quickly, great for creating quick apps and generating debs google it or you can
   find tutorials here http://developer.ubuntu.com/

***
     * Yes, I also like to add. wiki.ubuntu.com/Quickly, if you prefer videos like me, youtube
       is a great resource – [96]Jiew Meng Dec 31 '11 at 3:45

***     
	 * Quickly cannot simply turn a package into .deb package – [97]Archisman Panigrahi Mar 20 '16 at

***
   Try pkgme. It's supposed to Just Work.

   Install via:
sudo apt install pkgme

   Run via:
pkgme
debuild

***
   Meanwhile there is an article describing the dilemma found on
   [105]https://www.nylas.com/blog/packaging-deploying-python/. It mainly states that there is
   dh-virtualenv working together with make-deb to easily deploy Python code just using a setup.py file.
   A short manual can be found on [106]https://gist.github.com/JeOam/bc6cbf38f04d6f9dbf81


---
https://schneide.blog/2017/06/06/packaging-python-projects-for-debianubuntu/

Packaging Python projects for Debian/Ubuntu

   Deployment of software using built-in software management tools is very convenient and provides a
   nice user experience (UX) for the users. For debian-based linux distributions like Ubuntu packaging
   software in .deb-packages is the way to go. So how can we prepare our python projects for packaging
   as a deb-package? The good news is that python is supported out-of-the-box in the debian package
   build system.

   Alternatively, you can use the [15]distutils-extension stdeb if you do not need complete flexibility
   in creating the packages.

Basic python deb-package
   If you are using setuptools/distutils for your python project debian packaging consists of editing
   the package metadata and adding --with python to the rules file. For a nice headstart we can generate
   templates of the debian metadata files using two simple commands (the debhelper package is needed for
   dh_make:
# create a tarball with the current project sources
python setup.py sdist
# generate the debian package metadata files
dh_make -p ${project_name}_${version} -f dist/${project_name}-${version}.tar.gz

   You have to edit at least the control-file, the changelog and the rules-file to build the python
   package. In the rules-file the make-target % is the crucial point and should include the flag to
   build a python project:
# main packaging script based on dh7 syntax
%:
        dh $@ --with python

   After that you can build the package issueing dpkg-buildpackage.

The caveats
   The debian packaging system is great in complaining about non-conformant aspects of your package. It
   demands digital signatures, correct file and directory names including version strings etc.
   Unfortunately it is not very helpful when you make packaging  mistakes resulting in empty, incomplete
   or broken packages.

Issues with setup.py
   The setup.py build script has to reside on the same level as the debian-directory containing the
   package metadata. The packaging tools will not tell you if they could not find the setup script. In
   addition it will always run setup.py using python 2, even if you specified --with python3 in the
   rules-file.

Packaging for specific python versions
   If you want better control over the target python versions for the package you should use
   [16]Pybuild. You can do this by a little change to the rules-file, e.g. a python3-only build using
   Pybuild:
# main packaging script based on dh7 syntax
%:
        dh $@ --with python3 --buildsystem=pybuild

   For pybuild to work it is crucial to add the needed python interpreter(s) besides the mandatory build
   dependency dh-python to the Build-Depends of the control-file, for python3-only it could look like
   this:
Build-Depends: debhelper (>=9), dh-python, python3-all
...
Depends: ${python3:Depends}

   Without the dh-python build dependency pybuild will silently do nothing. Getting the build
   dependencies wrong will create incomplete or broken packages. Take extra care of getting this right!

Conclusion
   Debian packaging looks quite intimidating at first because there are so many ways to build a package.
   Many different tools can ease package creation but also add confusion. Packaging python software is
   done easily if you know the quirks. The [17]python examples from the [18]Guide for Debian Maintainers
   are certainly worth a look!


---
https://www.debian.org/doc/manuals/debmake-doc/ch08.en.html#setup-py

   #[1]Guide for Debian Maintainers [2]Guide for Debian Maintainers [3]Chapter 7. Tips
   [4]Appendix A. debmake(1) manpage

Chapter 8. More Examples

   Table of Contents
   8.1. Cherry-pick templates
   8.2. No Makefile (shell, CLI)
   8.3. Makefile (shell, CLI)
   8.4. setup.py (Python3, CLI)
   8.5. Makefile (shell, GUI)
   8.6. setup.py (Python3, GUI)
   8.7. Makefile (single-binary package)
   8.8. Makefile.in + configure (single-binary package)
   8.9. Autotools (single-binary package)
   8.10. CMake (single-binary package)
   8.11. Autotools (multi-binary package)
   8.12. CMake (multi-binary package)
   8.13. Internationalization
   8.14. Details

   There is an old Latin saying: “fabricando fit faber” (“practice makes perfect”).

   It is highly recommended to practice and experiment with all the steps of Debian packaging with
   simple packages. This chapter provides you with many upstream cases for your practice.

   This should also serve as introductory examples for many programing topics.
     * Programing in the POSIX shell, Python3, and C.
     * Method to create a desktop GUI program launcher with icon graphics.
     * Conversion of a command from [21]CLI to [22]GUI.
     * Conversion of a program to use gettext for [23]internationalization and localization: POSIX
       shell, Python3, and C sources.
     * Overview of many build systems: Makefile, Python distutils, Autotools, and CMake.

   Please note that Debian takes a few things seriously:
     * Free software (a.k.a. Libre software)
     * Stability and security of OS
     * Universal OS realized via:
          + free choice for upstream sources,
          + free choice of CPU architectures, and
          + free choice of UI languages.

   The typical packaging example presented in [24]Chapter 4, Simple Example is the prerequisite for this
   chapter.

   Some details are intentionally left vague in the following sections. Please try to read the pertinent
   documentation and practice yourself to find them out.
   [Tip] Tip

   The best source of a packaging example is the current Debian archive itself. Please use the
   “[25]Debian Code Search” service to find pertinent examples.
   
...

8.4. setup.py (Python3, CLI)

   Here is an example of creating a simple Debian package from a Python3 CLI program using setup.py as
   its build system.

   Let’s assume its upstream tarball to be debhello-1.1.tar.gz.

   This type of source is meant to be installed as a non-system file as:
 $ tar -xzmf debhello-1.1.tar.gz
 $ cd debhello-1.1
 $ python3 setup.py install

   Debian packaging requires changing the last line to “python3 setup.py install --install-layout=deb”
   to install files into the target system image location. This issue is automatically addressed when
   using the dh command for Debian packaging.

   Let’s get the source and make the Debian package.

   Download debhello-1.1.tar.gz.
 $ wget http://www.example.org/download/debhello-1.1.tar.gz
 ...
 $ tar -xzmf debhello-1.1.tar.gz
 $ tree
.
├── debhello-1.1
│   ├── LICENSE
│   ├── MANIFEST.in
│   ├── PKG-INFO
│   ├── hello_py
│   │   └── __init__.py
│   ├── scripts
│   │   └── hello
│   └── setup.py
└── debhello-1.1.tar.gz

3 directories, 7 files

   Here, the hello script and its associated hello_py module are as follows.

   hello (v=1.1).
 $ cat debhello-1.1/scripts/hello
#!/usr/bin/python3
import hello_py

if __name__ == '__main__':
    hello_py.main()

   hello_py/__init__.py (v=1.1).
 $ cat debhello-1.1/hello_py/__init__.py
#!/usr/bin/python3
def main():
    print('Hello Python3!')
    input("Press Enter to continue...")
    return

if __name__ == '__main__':
    main()

   These are packaged using the Python [31]distutils with the setup.py and MANIFEST.in files.

   setup.py (v=1.1).
 $ cat debhello-1.1/setup.py
#!/usr/bin/python3
# vi:se ts=4 sts=4 et ai:
from distutils.core import setup

setup(name='debhello',
    version='4.0',
    description='Hello Python',
    long_description='Hello Python program.',
    author='Osamu Aoki',
    author_email='osamu@debian.org',
    url='http://people.debian.org/~osamu/',
    packages=['hello_py'],
    package_dir={'hello_py': 'hello_py'},
    scripts=['scripts/hello'],
    classifiers = ['Development Status :: 3 - Alpha',
        'Environment :: Console',
        'Intended Audience :: Developers',
        'License :: OSI Approved :: MIT License',
        'Natural Language :: English',
        'Operating System :: POSIX :: Linux',
        'Programming Language :: Python :: 3',
        'Topic :: Utilities',
    ],
    platforms   = 'POSIX',
    license     = 'MIT License'
)

   MANIFEST.in (v=1.1).
 $ cat debhello-1.1/MANIFEST.in
include MANIFEST.in
include LICENSE

   [Tip] Tip

   Many modern Python packages are distributed using [32]setuptools. Since setuptools is an enhanced
   alternative to distutils, this example is useful for them.

   Let’s package this with the debmake command. Here, the -b':py3' option is used to specify the
   generated binary package containing Python3 script and module files.
 $ cd debhello-1.1
 $ debmake -b':py3'
I: set parameters
I: sanity check of parameters
I: pkg="debhello", ver="1.1", rev="1"
I: *** start packaging in "debhello-1.1". ***
I: provide debhello_1.1.orig.tar.gz for non-native Debian package
I: pwd = "/path/to"
I: $ ln -sf debhello-1.1.tar.gz debhello_1.1.orig.tar.gz
I: pwd = "/path/to/debhello-1.1"
I: parse binary package settings: :py3
I: binary package=debhello Type=python3 / Arch=all M-A=foreign
...

   Let’s inspect the notable template files generated.

   debian/rules (template file, v=1.1):
 $ cat debhello-1.1/debian/rules
#!/usr/bin/make -f
# You must remove unused comment lines for the released package.
#export DH_VERBOSE = 1

%:
        dh $@ --with python3 --buildsystem=pybuild

   This is essentially the standard debian/rules file with the dh command.

   The use of the “--with python3” option invokes dh_python3 to calculate Python dependencies, add
   maintainer scripts to byte compiled files, etc. See dh_python3(1).

   The use of the “--buildsystem=pybuild” option invokes various build systems for requested Python
   versions in order to build modules and extensions. See pybuild(1).

   debian/control (template file, v=1.1):
 $ cat debhello-1.1/debian/control
Source: debhello
Section: unknown
Priority: optional
Maintainer: "Firstname Lastname" <email.address@example.org>
Build-Depends: debhelper (>=11~), dh-python, python3-all
Standards-Version: 4.1.4
Homepage: <insert the upstream URL, if relevant>
X-Python3-Version: >= 3.2

Package: debhello
Architecture: all
Multi-Arch: foreign
Depends: ${misc:Depends}, ${python3:Depends}
Description: auto-generated package by debmake
 This Debian binary package was auto-generated by the
 debmake(1) command provided by the debmake package.

   Since this is the Python3 package, the debmake command sets “Architecture: all” and “Multi-Arch:
   foreign”. Also, it sets required substvar parameters as “Depends: ${python3:Depends},
   ${misc:Depends}”. These are explained in [33]Chapter 5, Basics.

   Let’s make this Debian package better as the maintainer.

   debian/rules (maintainer version, v=1.1):
 $ vim debhello-1.1/debian/rules
 ... hack, hack, hack, ...
 $ cat debhello-1.1/debian/rules
#!/usr/bin/make -f
export DH_VERBOSE = 1

%:
        dh $@ --with python3 --buildsystem=pybuild

   debian/control (maintainer version, v=1.1):
 $ vim debhello-1.1/debian/control
 ... hack, hack, hack, ...
 $ cat debhello-1.1/debian/control
Source: debhello
Section: devel
Priority: optional
Maintainer: Osamu Aoki <osamu@debian.org>
Build-Depends: debhelper (>=11~), dh-python, python3-all
Standards-Version: 4.1.3
Homepage: http://anonscm.debian.org/cgit/collab-maint/debmake-doc.git/
X-Python3-Version: >= 3.2

Package: debhello
Architecture: all
Multi-Arch: foreign
Depends: ${misc:Depends}, ${python3:Depends}
Description: example package in the debmake-doc package
 This is an example package to demonstrate Debian packaging using
 the debmake command.
 .
 The generated Debian package uses the dh command offered by the
 debhelper package and the dpkg source format `3.0 (quilt)'.

   The hello command does not come with the upstream-provided manpage; let’s add it as the maintainer.

   debian/manpages etc. (maintainer version, v=1.1):
 $ vim debhello-1.1/debian/hello.1
 ... hack, hack, hack, ...
 $ vim debhello-1.1/debian/manpages
 ... hack, hack, hack, ...
 $ cat debhello-1.1/debian/manpages
debian/hello.1

   There are several other template files under the debian/ directory. These also need to be updated.

   The rest of the packaging activities are practically the same as the ones in [34]Section 8.3,
   “Makefile (shell, CLI)”.

   Template files under debian/. (v=1.1):
 $ tree debhello-1.1/debian
debhello-1.1/debian
├── README.Debian
├── changelog
├── compat
├── control
├── copyright
├── hello.1
├── manpages
├── patches
│   └── series
├── rules
├── source
│   ├── format
│   └── local-options
└── watch

2 directories, 12 files

   Here is the generated dependency list of debhello_1.1-1_all.deb.

   The generated dependency list of debhello_1.1-1_all.deb:
 $ dpkg -f debhello_1.1-1_all.deb pre-depends depends recommends conflicts br...
Depends: python3:any (>= 3.2~)

...

8.6. setup.py (Python3, GUI)

   Here is an example of creating a simple Debian package from a Python3 GUI program using the setup.py
   as its build system.

   This upstream is based on [39]Section 8.4, “setup.py (Python3, CLI)” with enhanced GUI, desktop icon,
   and manpage support.

   Let’s assume this upstream tarball to be debhello-1.3.tar.gz.

   Let’s get the source and make the Debian package.

   Download debhello-1.3.tar.gz.
 $ wget http://www.example.org/download/debhello-1.3.tar.gz
 ...
 $ tar -xzmf debhello-1.3.tar.gz
 $ tree
.
├── debhello-1.3
│   ├── LICENSE
│   ├── MANIFEST.in
│   ├── PKG-INFO
│   ├── data
│   │   ├── hello.desktop
│   │   └── hello.png
│   ├── hello_py
│   │   └── __init__.py
│   ├── man
│   │   └── hello.1
│   ├── scripts
│   │   └── hello
│   └── setup.py
└── debhello-1.3.tar.gz

5 directories, 10 files

   Here are the upstream sources.

   hello (v=1.3).
 $ cat debhello-1.3/scripts/hello
#!/usr/bin/python3
import hello_py

if __name__ == '__main__':
    hello_py.main()

   hello_py/__init__.py (v=1.3).
 $ cat debhello-1.3/hello_py/__init__.py
#!/usr/bin/python3
from gi.repository import Gtk

class TopWindow(Gtk.Window):

    def __init__(self):
        Gtk.Window.__init__(self)
        self.title = "Hello World!"
        self.counter = 0
        self.border_width = 10
        self.set_default_size(400, 100)
        self.set_position(Gtk.WindowPosition.CENTER)
        self.button = Gtk.Button(label="Click me!")
        self.button.connect("clicked", self.on_button_clicked)
        self.add(self.button)
        self.connect("delete-event", self.on_window_destroy)

    def on_window_destroy(self, *args):
        Gtk.main_quit(*args)

    def on_button_clicked(self, widget):
        self.counter += 1
        widget.set_label("Hello, World!\nClick count = %i" % self.counter)

def main():
    window = TopWindow()
    window.show_all()
    Gtk.main()

if __name__ == '__main__':
    main()

   setup.py (v=1.3).
 $ cat debhello-1.3/setup.py
#!/usr/bin/python3
# vi:se ts=4 sts=4 et ai:
from distutils.core import setup

setup(name='debhello',
    version='4.1',
    description='Hello Python',
    long_description='Hello Python program.',
    author='Osamu Aoki',
    author_email='osamu@debian.org',
    url='http://people.debian.org/~osamu/',
    packages=['hello_py'],
    package_dir={'hello_py': 'hello_py'},
    scripts=['scripts/hello'],
    data_files=[
        ('share/applications', ['data/hello.desktop']),
        ('share/pixmaps', ['data/hello.png']),
        ('share/man/man1', ['man/hello.1']),
    ],
    classifiers = ['Development Status :: 3 - Alpha',
        'Environment :: Console',
        'Intended Audience :: Developers',
        'License :: OSI Approved :: MIT License',
        'Natural Language :: English',
        'Operating System :: POSIX :: Linux',
        'Programming Language :: Python :: 3',
        'Topic :: Utilities',
    ],
    platforms   = 'POSIX',
    license     = 'MIT License'
)

   MANIFEST.in (v=1.3).
 $ cat debhello-1.3/MANIFEST.in
include MANIFEST.in
include LICENSE
include data/hello.deskto
include data/hello.png
include man/hello.1

   Let’s package this with the debmake command. Here, the -b':py3' option is used to specify that the
   generated binary package contains Python3 script and module files.
 $ cd debhello-1.3
 $ debmake -b':py3'
I: set parameters
I: sanity check of parameters
I: pkg="debhello", ver="1.3", rev="1"
I: *** start packaging in "debhello-1.3". ***
I: provide debhello_1.3.orig.tar.gz for non-native Debian package
I: pwd = "/path/to"
I: $ ln -sf debhello-1.3.tar.gz debhello_1.3.orig.tar.gz
I: pwd = "/path/to/debhello-1.3"
I: parse binary package settings: :py3
I: binary package=debhello Type=python3 / Arch=all M-A=foreign
...

   The result is practically the same as in [40]Section 8.4, “setup.py (Python3, CLI)”.

   Let’s make this Debian package better as the maintainer.

   debian/rules (maintainer version, v=1.3):
 $ vim debhello-1.3/debian/rules
 ... hack, hack, hack, ...
 $ cat debhello-1.3/debian/rules
#!/usr/bin/make -f
export DH_VERBOSE = 1

%:
        dh $@ --with python3 --buildsystem=pybuild

   debian/control (maintainer version, v=1.3):
 $ vim debhello-1.3/debian/control
 ... hack, hack, hack, ...
 $ cat debhello-1.3/debian/control
Source: debhello
Section: devel
Priority: optional
Maintainer: Osamu Aoki <osamu@debian.org>
Build-Depends: debhelper (>=11~), dh-python, python3-all
Standards-Version: 4.1.3
Homepage: https://salsa.debian.org/debian/debmake-doc
X-Python3-Version: >= 3.2

Package: debhello
Architecture: all
Multi-Arch: foreign
Depends: gir1.2-gtk-3.0, python3-gi, ${misc:Depends}, ${python3:Depends}
Description: example package in the debmake-doc package
 This is an example package to demonstrate Debian packaging using
 the debmake command.
 .
 The generated Debian package uses the dh command offered by the
 debhelper package and the dpkg source format `3.0 (quilt)'.

   Please note the manually added python3-gi and gir1.2-gtk-3.0 dependencies.

   Since this upstream source has a manpage and other files with matching entries in the setup.py file,
   there is no need to create them and add the debian/install and debian/manpages files that were
   required in [41]Section 8.4, “setup.py (Python3, CLI)”.

   The rest of the packaging activities are practically the same as in [42]Section 8.4, “setup.py
   (Python3, CLI)”.

   Here is the generated dependency list of debhello_1.3-1_all.deb.

   The generated dependency list of debhello_1.3-1_all.deb:
 $ dpkg -f debhello_1.3-1_all.deb pre-depends depends recommends conflicts br...
Depends: gir1.2-gtk-3.0, python3-gi, python3:any (>= 3.2~)

...


---
