filename: python_classes-and-inheritance-multif_20170926.txt
https://www.tutorialspoint.com/python3/python_classes_objects.htm

Python 3 - Object Oriented

   Python has been an object-oriented language since the time it existed. Due to this, creating and
   using classes and objects are downright easy. This chapter helps you become an expert in using
   Python's object-oriented programming support.

   If you do not have any previous experience with object-oriented (OO) programming, you may want to
   consult an introductory course on it or at least a tutorial of some sort so that you have a grasp of
   the basic concepts.

   However, here is a small introduction of Object-Oriented Programming (OOP) to help you −

Overview of OOP Terminology
     * Class − A user-defined prototype for an object that defines a set of attributes that characterize
       any object of the class. The attributes are data members (class variables and instance variables)
       and methods, accessed via dot notation.
     * Class variable − A variable that is shared by all instances of a class. Class variables are
       defined within a class but outside any of the class's methods. Class variables are not used as
       frequently as instance variables are.
     * Data member − A class variable or instance variable that holds data associated with a class and
       its objects.
     * Function overloading − The assignment of more than one behavior to a particular function. The
       operation performed varies by the types of objects or arguments involved.
     * Instance variable − A variable that is defined inside a method and belongs only to the current
       instance of a class.
     * Inheritance − The transfer of the characteristics of a class to other classes that are derived
       from it.
     * Instance − An individual object of a certain class. An object obj that belongs to a class Circle,
       for example, is an instance of the class Circle.
     * Instantiation − The creation of an instance of a class.
     * Method − A special kind of function that is defined in a class definition.
     * Object − A unique instance of a data structure that is defined by its class. An object comprises
       both data members (class variables and instance variables) and methods.
     * Operator overloading − The assignment of more than one function to a particular operator.

Creating Classes
   The class statement creates a new class definition. The name of the class immediately follows the
   keyword class followed by a colon as follows −
class ClassName:
   'Optional class documentation string'
   class_suite

     * The class has a documentation string, which can be accessed via ClassName.__doc__.
     * The class_suite consists of all the component statements defining class members, data attributes
       and functions.

Example
   Following is an example of a simple Python class −
class Employee:
   'Common base class for all employees'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1

   def displayCount(self):
     print "Total Employee %d" % Employee.empCount

   def displayEmployee(self):
      print "Name : ", self.name,  ", Salary: ", self.salary

     * The variable empCount is a class variable whose value is shared among all the instances of a in
       this class. This can be accessed as Employee.empCount from inside the class or outside the class.
     * The first method __init__() is a special method, which is called class constructor or
       initialization method that Python calls when you create a new instance of this class.
     * You declare other class methods like normal functions with the exception that the first argument
       to each method is self. Python adds the self argument to the list for you; you do not need to
       include it when you call the methods.

Creating Instance Objects
   To create instances of a class, you call the class using class name and pass in whatever arguments
   its __init__ method accepts.
This would create first object of Employee class
emp1 = Employee("Zara", 2000)
This would create second object of Employee class
emp2 = Employee("Manni", 5000)

Accessing Attributes
   You access the object's attributes using the dot operator with object. Class variable would be
   accessed using class name as follows −
emp1.displayEmployee()
emp2.displayEmployee()
print ("Total Employee %d" % Employee.empCount)

   Now, putting all the concepts together −
#!/usr/bin/python3

class Employee:
   'Common base class for all employees'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1

   def displayCount(self):
     print ("Total Employee %d" % Employee.empCount)

   def displayEmployee(self):
      print ("Name : ", self.name,  ", Salary: ", self.salary)


#This would create first object of Employee class"
emp1 = Employee("Zara", 2000)
#This would create second object of Employee class"
emp2 = Employee("Manni", 5000)
emp1.displayEmployee()
emp2.displayEmployee()
print ("Total Employee %d" % Employee.empCount)

   When the above code is executed, it produces the following result −
Name :  Zara ,Salary:  2000
Name :  Manni ,Salary:  5000
Total Employee 2

   You can add, remove, or modify attributes of classes and objects at any time −
emp1.salary = 7000  # Add an 'salary' attribute.
emp1.name = 'xyz'  # Modify 'age' attribute.
del emp1.salary  # Delete 'age' attribute.

   Instead of using the normal statements to access attributes, you can use the following functions −
     * The getattr(obj, name[, default]) − to access the attribute of object.
     * The hasattr(obj,name) − to check if an attribute exists or not.
     * The setattr(obj,name,value) − to set an attribute. If attribute does not exist, then it would be
       created.
     * The delattr(obj, name) − to delete an attribute.

hasattr(emp1, 'salary')    # Returns true if 'salary' attribute exists
getattr(emp1, 'salary')    # Returns value of 'salary' attribute
setattr(emp1, 'salary', 7000) # Set attribute 'salary' at 7000
delattr(emp1, 'salary')    # Delete attribute 'salary'

Built-In Class Attributes
   Every Python class keeps following built-in attributes and they can be accessed using dot operator
   like any other attribute −
     * __dict__ − Dictionary containing the class's namespace.
     * __doc__ − Class documentation string or none, if undefined.
     * __name__ − Class name.
     * __module__ − Module name in which the class is defined. This attribute is "__main__" in
       interactive mode.
     * __bases__ − A possibly empty tuple containing the base classes, in the order of their occurrence
       in the base class list.

   For the above class let us try to access all these attributes −
#!/usr/bin/python3

class Employee:
   'Common base class for all employees'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1

   def displayCount(self):
     print ("Total Employee %d" % Employee.empCount)

   def displayEmployee(self):
      print ("Name : ", self.name,  ", Salary: ", self.salary)

emp1 = Employee("Zara", 2000)
emp2 = Employee("Manni", 5000)
print ("Employee.__doc__:", Employee.__doc__)
print ("Employee.__name__:", Employee.__name__)
print ("Employee.__module__:", Employee.__module__)
print ("Employee.__bases__:", Employee.__bases__)
print ("Employee.__dict__:", Employee.__dict__ )

   When the above code is executed, it produces the following result −
Employee.__doc__: Common base class for all employees
Employee.__name__: Employee
Employee.__module__: __main__
Employee.__bases__: (<class 'object'>,)
Employee.__dict__: {
   'displayCount': <function Employee.displayCount at 0x0160D2B8>,
   '__module__': '__main__', '__doc__': 'Common base class for all employees',
   'empCount': 2, '__init__':
   <function Employee.__init__ at 0x0124F810>, 'displayEmployee':
   <function Employee.displayEmployee at 0x0160D300>,
   '__weakref__':
   <attribute '__weakref__' of 'Employee' objects>, '__dict__':
   <attribute '__dict__' of 'Employee' objects>
}

Destroying Objects (Garbage Collection)
   Python deletes unneeded objects (built-in types or class instances) automatically to free the memory
   space. The process by which Python periodically reclaims blocks of memory that no longer are in use
   is termed as Garbage Collection.

   Python's garbage collector runs during program execution and is triggered when an object's reference
   count reaches zero. An object's reference count changes as the number of aliases that point to it
   changes.

   An object's reference count increases when it is assigned a new name or placed in a container (list,
   tuple, or dictionary). The object's reference count decreases when it is deleted with del, its
   reference is reassigned, or its reference goes out of scope. When an object's reference count reaches
   zero, Python collects it automatically.
a = 40      # Create object <40>
b = a       # Increase ref. count  of <40>
c = [b]     # Increase ref. count  of <40>

del a       # Decrease ref. count  of <40>
b = 100     # Decrease ref. count  of <40>
c[0] = -1   # Decrease ref. count  of <40>

   You normally will not notice when the garbage collector destroys an orphaned instance and reclaims
   its space. However, a class can implement the special method __del__(), called a destructor, that is
   invoked when the instance is about to be destroyed. This method might be used to clean up any
   non-memory resources used by an instance.

Example
   This __del__() destructor prints the class name of an instance that is about to be destroyed −
#!/usr/bin/python3

class Point:
   def __init__( self, x=0, y=0):
      self.x = x
      self.y = y
   def __del__(self):
      class_name = self.__class__.__name__
      print (class_name, "destroyed")

pt1 = Point()
pt2 = pt1
pt3 = pt1
print (id(pt1), id(pt2), id(pt3));   # prints the ids of the obejcts
del pt1
del pt2
del pt3

   When the above code is executed, it produces the following result −
3083401324 3083401324 3083401324
Point destroyed

   Note − Ideally, you should define your classes in a separate file, then you should import them in
   your main program file using import statement.

   In the above example, assuming definition of a Point class is contained in point.py and there is no
   other executable code in it.
#!/usr/bin/python3
import point
p1 = point.Point()

Class Inheritance
   Instead of starting from a scratch, you can create a class by deriving it from a pre-existing class
   by listing the parent class in parentheses after the new class name.

   The child class inherits the attributes of its parent class, and you can use those attributes as if
   they were defined in the child class. A child class can also override data members and methods from
   the parent.

Syntax
   Derived classes are declared much like their parent class; however, a list of base classes to inherit
   from is given after the class name −
class SubClassName (ParentClass1[, ParentClass2, ...]):
   'Optional class documentation string'
   class_suite

Example
#!/usr/bin/python3

class Parent:        # define parent class
   parentAttr = 100
   def __init__(self):
      print ("Calling parent constructor")

   def parentMethod(self):
      print ('Calling parent method')

   def setAttr(self, attr):
      Parent.parentAttr = attr

   def getAttr(self):
      print ("Parent attribute :", Parent.parentAttr)

class Child(Parent): # define child class
   def __init__(self):
      print ("Calling child constructor")

   def childMethod(self):
      print ('Calling child method')

c = Child()          # instance of child
c.childMethod()      # child calls its method
c.parentMethod()     # calls parent's method
c.setAttr(200)       # again call parent's method
c.getAttr()          # again call parent's method

   When the above code is executed, it produces the following result −
Calling child constructor
Calling child method
Calling parent method
Parent attribute : 200

   In a similar way, you can drive a class from multiple parent classes as follows −
class A:        # define your class A
.....

class B:         # define your calss B
.....

class C(A, B):   # subclass of A and B
.....

   You can use issubclass() or isinstance() functions to check a relationships of two classes and
   instances.
     * The issubclass(sub, sup) boolean function returns True, if the given subclass sub is indeed a
       subclass of the superclass sup.
     * The isinstance(obj, Class) boolean function returns True, if obj is an instance of class Class or
       is an instance of a subclass of Class

Overriding Methods
   You can always override your parent class methods. One reason for overriding parent's methods is that
   you may want special or different functionality in your subclass.

Example
#!/usr/bin/python3

class Parent:        # define parent class
   def myMethod(self):
      print ('Calling parent method')

class Child(Parent): # define child class
   def myMethod(self):
      print ('Calling child method')

c = Child()          # instance of child
c.myMethod()         # child calls overridden method

   When the above code is executed, it produces the following result −
Calling child method

Base Overloading Methods
   The following table lists some generic functionality that you can override in your own classes −
   S.No. Method, Description & Sample Call
   1

   __init__ ( self [,args...] )

   Constructor (with any optional arguments)

   Sample Call : obj = className(args)
   2

   __del__( self )

   Destructor, deletes an object

   Sample Call : del obj
   3

   __repr__( self )

   Evaluatable string representation

   Sample Call : repr(obj)
   4

   __str__( self )

   Printable string representation

   Sample Call : str(obj)
   5

   __cmp__ ( self, x )

   Object comparison

   Sample Call : cmp(obj, x)

Overloading Operators

   Suppose you have created a Vector class to represent two-dimensional vectors. What happens when you
   use the plus operator to add them? Most likely Python will yell at you.

   You could, however, define the __add__ method in your class to perform vector addition and then the
   plus operator would behave as per expectation −

Example
#!/usr/bin/python3

class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b

   def __str__(self):
      return 'Vector (%d, %d)' % (self.a, self.b)

   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)

v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)

   When the above code is executed, it produces the following result −
Vector(7,8)

Data Hiding
   An object's attributes may or may not be visible outside the class definition. You need to name
   attributes with a double underscore prefix, and those attributes then will not be directly visible to
   outsiders.

Example

#!/usr/bin/python3

class JustCounter:
   __secretCount = 0

   def count(self):
      self.__secretCount += 1
      print (self.__secretCount)

counter = JustCounter()
counter.count()
counter.count()
print (counter.__secretCount)

   When the above code is executed, it produces the following result −
1
2
Traceback (most recent call last):
   File "test.py", line 12, in <module>
      print counter.__secretCount
AttributeError: JustCounter instance has no attribute '__secretCount'

   Python protects those members by internally changing the name to include the class name. You can
   access such attributes as object._className__attrName. If you would replace your last line as
   following, then it works for you −
.........................
print (counter._JustCounter__secretCount)

   When the above code is executed, it produces the following result −
1
2
2


---
https://www.python-course.eu/python3_object_oriented_programming.php

Object-oriented Programming

   "Certainly not every good program is object-oriented, and not every object-oriented program is good."
   (Bjarne Stroustrup, Danish computer scientist, best known for the creation and the development of the
   widely used C++ programming language.)
   "Object-oriented programming is an exceptionally bad idea which could only have originated in
   California."
   (Edsger Dijkstra, (Dutch computer Scientist, 1930-2002)
   Dijkstra also said:
   "... what society overwhelmingly asks for is snake oil. Of course, the snake oil has the most
   impressive names - otherwise you would be selling nothing - like "Structured Analysis and Design",
   "Software Engineering", "Maturity Models", "Management Information Systems", "Integrated Project
   Support Environments" "Object Orientation" and "Business Process Re-engineering"

Shooting Yourself in the Foot
   by Mark Hammond:
   Python: You create a gun module, a gun class, a foot module and a foot class. After realising you
   can't point the gun at the foot, you pass a reference to the gun to a foot object. After the foot is
   blown up, the gun object remains alive for eternity, ready to shoot all future feet that may happen
   to appear.
   Java: You find that Microsoft and Sun have released incompatible class libraries both implementing
   Gun objects. You then find that although there are plenty of feet objects implemented in the past in
   many other languages, you cannot get access to one. But seeing as Java is so cool, you don't care and
   go around shooting anything else you can find.
   by Mark Hammond

Object-Oriented Programming - General Introduction
   Fruit as a Class Though Python is an object-oriented language without fuss or quibble, we have so far
   intentionally avoided the treatment of object-oriented programming (OOP) in the previous chapters of
   our Python tutorial. We skipped OOP, because we are convinced that it is easier and more fun to start
   learning Python without having to know about all the details of object-oriented programming.
   But even though we have avoided OOP, it has nevertheless always been present in the exercises and
   examples of our course. We used objects and methods from classes without properly explaining their
   OOP background. In this chapter, we will catch up on what has been missing so far. We will provide an
   introduction into the principles of object oriented programming in general and into the specifics of
   the OOP approach of Python. OOP is one of the most powerful tools of Python, but nevertheless you
   don't have to use it, i.e. you can write powerful and efficient programs without it as well.
   Though many computer scientists and programmers consider OOP to be a modern programming paradigm, the
   roots go back to 1960s. The first programming language to use objects was Simula 67. As the name
   implies, Simula 67 was introduced in the year 1967. A major breakthrough for object-oriented
   programming came with the programming language Smalltalk in the 1970s.
   You will learn to know the four major principles of object-orientation and the way Python deals with
   them in the next section of this tutorial on object-oriented programming: Library of the Court of
   Appeal for Ontario in Toronto
     * Encapsulation
     * Data Abstraction
     * Polymorphism
     * Inheritance

   Before we start with the section on the way OOP is used in Python, we want to give you a general idea
   about object-oriented programming. For this purpose, we would like to draw your attention to a public
   library. Let's think about a huge one, like the "British Library" in London or the "New York Public
   Library" in New York. If it helps, you can imagine the libraries in Paris, Berlin, Ottawa or
   Toronto^1 as well. Each of these contain an organized collection of books, periodicals, newspapers,
   audiobooks, films and so on.
   Generally, there are two opposed ways of keeping the stock in a library. You can use a "closed
   access" method that is the stock is not displayed on open shelves. In this system, trained staff
   brings the books and other publications to the users on demand. Another way of running a library is
   open-access shelving, also known as "open shelves". "Open" means open to all the users of the library
   not only specially trained staff. In this case the books are openly displayed. Imperative languages
   like C could be seen as open-access shelving libraries. The user can do everything. It's up to the
   user to find the books and to put them back at the right shelf. Even though this is great for the
   user, it might lead to serious problems in the long run. For example some books will be misplaced, so
   it's hard to find them again. As you may have guessed already, "closed access" can be compared to
   object oriented programming. The analogy can be seen like this: The books and other publications,
   which a library offers, are like the data in an object-oriented program. Access to the books is
   restricted like access to the data is restricted in OOP. Getting or returning a book is only possible
   via the staff. The staff functions like the methods in OOP, which control the access to the data. So,
   the data, - often called attributes, - in such a program can be seen as being hidden and protected by
   a shell, and it can only be accessed by special functions, usually called methods in the OOP context.
   Putting the data behind a "shell" is called Encapsulation.
   So a library can be regarded as a class and a book is an instance or an object of this class.
   Generally speaking, an object is defined by a class. A class is a formal description of how an object
   is designed, i.e. which attributes and methods it has. These objects are called instances as well.
   The expressions are in most cases used synonymously. A class should not be confused with an object.

OOP in Python
  First-class Everything
  
   Even though we haven't talked about classes and object orientation in previous chapters, we have
   worked with classes all the time. In fact, everything is a class in Python. Guido van Rossum has
   designed the language according to the principle "first-class everything". He wrote: "One of my goals
   for Python was to make it so that all objects were "first class." By this, I meant that I wanted all
   objects that could be named in the language (e.g., integers, strings, functions, classes, modules,
   methods, and so on) to have equal status. That is, they can be assigned to variables, placed in
   lists, stored in dictionaries, passed as arguments, and so forth." (Blog, The History of Python,
   February 27, 2009) This means that "everything" is treated the same way, everything is a class:
   functions and methods are values just like lists, integers or floats. Each of these are instances of
   their corresponding classes.
>>> x = 42
>>> type(x)
<class 'int'>
>>> y = 4.34
>>> type(x)
<class 'int'>
>>> def f(x):
...     return x + 1
...
>>> type(f)
<class 'function'>
>>> import math
>>> type(math)
<class 'module'>
>>>

   One of the many integrated classes in Python is the list class, which we have quite often used in our
   exercises and examples. The list class provides a wealth of methods to build lists, to access and
   change elements, or to remove elements:
>>> x = [3,6,9]
>>> y = [45, "abc"]
>>> print(x[1])
6
>>> x[1] = 99
>>> x.append(42)
>>> last = y.pop()
>>> print(last)
abc
>>>

   The variables x and y of the previous example denote two instances of the list class. In simplified
   terms, we have said so far that "x and y are lists". We will use the terms "object" and "instance"
   synonymously in the following chapters, as it is often done.^2
   pop and append of the previous example are methods of the list class. pop returns the most upper (or
   you might think of it as the "rightest") element of the list and removes this element from the list.
   We will not explain how Python has implemented lists internally. We don't need this information,
   because the list class provides us with all the necessary methods to access the data indirectly. This
   means that the encapsulation details are encapsulated. We will learn about encapsulation later.

  A Minimal Class in Python

   Evolution of Robots
   We will design and use a robot class in Python as an example to demonstrate the most important terms
   and ideas of object orientation. We will start with the simplest class in Python.
class Robot:
    pass

   We can realize the fundamental syntactical structure of a class in Python: A class consists of two
   parts: the header and the body. The header usually consists of just one line of code. It begins with
   the keyword "class" followed by a blank and an arbitrary name for the class. The class name is
   "Robot" in our case. The class name is followed by a listing of other class names, which are classes
   from which the defined class inherits from. These classes are called superclasses, base classes or
   sometimes parent classes. If you look at our example, you will see that this listing of superclasses
   is not obligatory. You don't have to bother about inheritance and superclasses for the time being. We
   will introduce them later.
   The body of a class consists of an indented block of statements. In our case a single statement, the
   "pass" statement.
   A class object is created, when the definition is left normally, i.e. via the end. This is basically
   a wrapper around the contents of the namespace created by the class definition.
   It's hard to believe, especially for C++ or Java programmers, but we have already defined a complete
   class with just three words and two lines of code. We are capable of using this class as well:
class Robot:
    pass

if __name__ == "__main__":
    x = Robot()
    y = Robot()
    y2 = y
    print(y == y2)
    print(y == x)

   We have created two different robots x and y in our example. Besides this, we have created a
   reference y2 to y, i.e. y2 is an alias name for y. The output of this example program looks like
   this:
True
False

  Attributes

   Those who have learned already another object-oriented language, will have realized that the terms
   attributes and properties are usually used synonymously. It may even be used in the definition of an
   attribute, like Wikipedia does: "In computing, an attribute is a specification that defines a
   property of an object, element, or file. It may also refer to or set the specific value for a given
   instance of such."
   Even in normal English usage the words "attribute" and "property" can be used in some cases as
   synonyms. Both can have the meaning "An attribute, feature, quality, or characteristic of something
   or someone". Usually an "attribute" is used to denote a specific ability or characteristic which
   something or someone has, like black hair, no hair, or a quick perception, or "her quickness to grasp
   new tasks". So, think a while about your outstanding attributes. What about your "outstanding
   properties"? Great, if one of your strong points is your ability to quickly understand and adapt to
   new situations! Otherwise, you would not learn Python!
   Let's get back to Python: We will learn later that properties and attributes are essentially
   different things in Python. This subsection of our tutorial is about attributes in Python. So far our
   robots have no attributes. Not even a name, like it is customary for ordinary robots, isn't it? So,
   let's implement a name attribute. "type designation", "build year" and so on are easily conceivable
   as further attributes as well. ^3
   Attributes are created inside of a class definition, as we will soon learn. We can dynamically create
   arbitrary new attributes for existing instances of a class. We do this by joining an arbitrary name
   to the instance name, separated by a dot ".". In the following example, we demonstrate this by
   created an attribute for the name and the build year:
>>> class Robot:
...     pass
...
>>> x = Robot()
>>> y = Robot()
>>>
>>> x.name = "Marvin"
>>> x.build_year = "1979"
>>>
>>> y.name = "Caliban"
>>> y.build_year = "1993"
>>>
>>> print(x.name)
Marvin
>>> print(y.build_year)
1993
>>>

   As we have said before: This is not the way to properly create instance attributes. We introduced
   this example, because we think that it may help to make the following explanations easier to
   understand.
   If you want to know, what's happening internally: The instances possess dictionaries __dict__, which
   they use to store their attributes and their corresponding values:
>>> x.__dict__
{'name': 'Marvin', 'build_year': '1979'}
>>> y.__dict__
{'name': 'Caliban', 'build_year': '1993'}

   Attributes can be bound to class names as well. In this case, each instance will possess this name as
   well. Watch out, what happens, if you assign the same name to an instance:
>>> class Robot(object):
...     pass
...
>>> x = Robot()
>>> Robot.brand = "Kuka"
>>> x.brand
'Kuka'
>>> x.brand = "Thales"
>>> Robot.brand
'Kuka'
>>> y = Robot()
>>> y.brand
'Kuka'
>>> Robot.brand = "Thales"
>>> y.brand
'Thales'
>>> x.brand
'Thales'

   If you look at the __dict__ dictionaries, you can see what's happening.
>>> x.__dict__
{'brand': 'Thales'}
>>> y.__dict__
{}
>>>
>>> Robot.__dict__
mappingproxy({'__module__': '__main__', '__weakref__': , '__doc__': None, '__dict__': , 'brand': 'Thales'})

   If you try to access y.brand, Python checks first, if "brand" is a key of the y.__dict__ dictionary.
   If it is not, Python checks, if "brand" is a key of the Robot.__dict__. If so, the value can be
   retrieved.
   If an attribute name is not in included in either of the dictionary, the attribute name is not
   defined. If you try to access a non-existing attribute, you will raise an AttributeError:
>>> x.energy
Traceback (most recent call last):
  File "<stdin>", line 1, in
AttributeError: 'Robot' object has no attribute 'energy'
>>>

   By using the function getattr, you can prevent this exception, if you provide a default value as the
   third argument:
>>> getattr(x, 'energy', 100)
100
>>>

   Binding attributes to objects is a general concept in Python. Even function names can be attributed.
   You can bind an attribute to a function name in the same way, we have done so far:

>>> def f(x):
...     return 42
...
>>> f.x = 42
>>> print(f.x)
42
>>>

   This can be used as a replacement for the static function variables of C and C++, which are not
   possible in Python. We use a counter attribute in the following example:
def f(x):
    f.counter = getattr(f, "counter", 0) + 1
    return "Monty Python"


for i in range(10):
    f(i)

print(f.counter)

   If you call this little script, it will output 10.
   As we have already mentioned, we do not create instance attributes like this. To properly create
   instances we need methods. You will learn in the following subsection of our tutorial, how you can
   define methods.

  Methods

   Hi, I'm Marvin

   We want to demonstrate now, how we can define methods in classes.
   Methods in Python are essentially functions in accordance with Guido's saying "first-class
   everything".
   Let's define a function "hi", which takes an object "obj" as an argument and assumes that this object
   has an attribute "name". We will also define again our basic Robot class:
def hi(obj):
    print("Hi, I am " + obj.name + "!")

class Robot:
    pass


x = Robot()
x.name = "Marvin"
hi(x)

   If we call this code, we get the result
Hi, I am Marvin!

   We will now bind the function „hi“ to a class attribute „say_hi“!
def hi(obj):
        print("Hi, I am " + obj.name)

class Robot:
    say_hi = hi


x = Robot()
x.name = "Marvin"
Robot.say_hi(x)

   "say_hi" is called a method. Usually, it will be called like this:
   x.say_hi()
   It is possible to define methods like this, but you shouldn't do it.
   The proper way to do it:
     * Instead of defining a function outside of a class definition and binding it to a class attribute,
       we define a method directly inside (indented) of a class definition.
     * A method is "just" a function which is defined inside of a class.
     * The first parameter is used a reference to the calling instance.
     * This parameter is usually called self.
     * Self corresponds to the Robot object x.

   We have seen that a method differs from a function only in two aspects:
     * It belongs to a class, and it is defined within a class
     * The first parameter in the definition of a method has to be a reference to the instance, which
       called the method. This parameter is usually called "self".

   As a matter of fact, "self" is not a Python keyword. It's just a naming convention! So C++ or Java
   programmers are free to call it "this", but this way they are risking that others might have greater
   difficulties in understanding their code!
   Most other object-oriented programming languages pass the reference to the object (self) as a hidden
   parameter to the methods.
   You saw before that the calls Robot.say_hi(x)". and "x.say_hi()" are equivalent. "x.say_hi()" can be
   seen as an "abbreviated" form, i.e. Python automatically binds it to the instance name. Besides this
   "x.say_hi()" is the usual way to call methods in Python and in other object oriented languages.
   For a Class C, an instance x of C and a method m of C the following three method calls are
   equivalent:
     * type(x).m(x, ...)
     * C.m(x, ...)
     * x.m(...)

   Before you proceed with the following text, you may mull over the previous example for awhile. Can
   you figure out, what is wrong in the design?
   There is more than one thing about this code, which may disturb you, but the essential problem at the
   moment is the fact that we create a robot and that after the creation, we shouldn't forget about
   naming it! If we forget it, say_hi will raise an error.
   We need a mechanism to initialize an instance right after its creation. This is the __init__-method,
   which we cover in the next section.

  The __init__ Method

   We want to define the attributes of an instance right after its creation. __init__ is a method which
   is immediately and automatically called after an instance has been created. This name is fixed and it
   is not possible to chose another name. __init__ is one of the so-called magic methods, of which we
   will get to know some more details later. The __init__ method is used to initialize an instance.
   There is no explicit constructor or destructor method in Python, as they are known in C++ and Java.
   The __init__ method can be anywhere in a class definition, but it is usually the first method of a
   class, i.e. it follows right after the class header.
>>> class A:
...     def __init__(self):
...         print("__init__ has been executed!")
...
>>> x = A()
__init__ has been executed!
>>>

   We add an __init__-method to our robot class:
class Robot:

    def __init__(self, name=None):
        self.name = name

    def say_hi(self):
        if self.name:
            print("Hi, I am " + self.name)
        else:
            print("Hi, I am a robot without a name")


x = Robot()
x.say_hi()
y = Robot("Marvin")
y.say_hi()

   This little program returns the following:
Hi, I am a robot without a name
Hi, I am Marvin

  Data Abstraction, Data Encapsulation, and Information Hiding
  
    Definitions of Terms

   Data Abstraction = Data Encapsulation + Information Hiding Data Abstraction, Data Encapsulation and
   Information Hiding are often synonymously used in books and tutorials on OOP. But there is a
   difference. Encapsulation is seen as the bundling of data with the methods that operate on that data.
   Information hiding on the other hand is the principle that some internal information or data is
   "hidden", so that it can't be accidentally changed. Data encapsulation via methods doesn't
   necessarily mean that the data is hidden. You might be capable of accessing and seeing the data
   anyway, but using the methods is recommended. Finally, data abstraction is present, if both data
   hiding and data encapsulation is used. This means data abstraction is the broader term:
   Data Abstraction = Data Encapsulation + Data Hiding
   Encapsulation is often accomplished by providing two kinds of methods for attributes: The methods for
   retrieving or accessing the values of attributes are called getter methods. Getter methods do not
   change the values of attributes, they just return the values. The methods used for changing the
   values of attributes are called setter methods.
   We will define now a Robot class with a Getter and a Setter for the name attribute. We will call them
   get_name and set_name accordingly.
class Robot:

    def __init__(self, name=None):
        self.name = name

    def say_hi(self):
        if self.name:
            print("Hi, I am " + self.name)
        else:
            print("Hi, I am a robot without a name")

    def set_name(self, name):
        self.name = name

    def get_name(self):
        return self.name


x = Robot()
x.set_name("Henry")
x.say_hi()
y = Robot()
y.set_name(x.get_name())
print(y.get_name())

   Hopefully, it will be easy for you to see, that this program prints the following:
Hi, I am Henry
Henry

   Before you go on, you can do a little exercise. You can add an additional attribute "build_year" with
   Getters and Setters to the Robot class.
class Robot:

    def __init__(self,
                 name=None,
                 build_year=None):
        self.name = name
        self.build_year = build_year

    def say_hi(self):
        if self.name:
            print("Hi, I am " + self.name)
        else:
            print("Hi, I am a robot without a name")
        if self.build_year:
            print("I was built in " + str(self.build_year))
        else:
            print("It's not known, when I was created!")

    def set_name(self, name):
        self.name = name

    def get_name(self):
        return self.name

    def set_build_year(self, by):
        self.build_year = by

    def get_build_year(self):
        return self.build_year


x = Robot("Henry", 2008)
y = Robot()
y.set_name("Marvin")
x.say_hi()
y.say_hi()

   The program returns the following output:
Hi, I am Henry
I was built in 2008
Hi, I am Marvin
It's not known, when I was created!

   There is still something wrong with our Robot class. The Zen of Python says: "There should be one--
   and preferably only one --obvious way to do it." Our Robot class provides us with two ways to access
   or to change the "name" or the "build_year" attribute. This can be prevented by using private
   attributes, which we will explain later.

  __str__- and __repr__-Methods

   We will have a short break in our treatise on data abstraction for a quick side-trip. We want to
   introduce two important magic methods "__str__" and "__repr__", which we will need in future
   examples. In the course of this tutorial, we have already encountered the __str__ method. We had seen
   that we can depict various data as string by using the str function, which uses "magically" the
   internal __str__ method of the corresponding data type. __repr__is similar. It also produces a string
   representation.
>>> l = ["Python", "Java", "C++", "Perl"]
>>> print(l)
['Python', 'Java', 'C++', 'Perl']
>>> str(l)
"['Python', 'Java', 'C++', 'Perl']"
>>> repr(l)
"['Python', 'Java', 'C++', 'Perl']"
>>> d = {"a":3497, "b":8011, "c":8300}
>>> print(d)
{'a': 3497, 'c': 8300, 'b': 8011}
>>> str(d)
"{'a': 3497, 'c': 8300, 'b': 8011}"
>>> repr(d)
"{'a': 3497, 'c': 8300, 'b': 8011}"
>>> x = 587.78
>>> str(x)
'587.78'
>>> repr(x)
'587.78'
>>>

   If you apply str or repr to an object, Python is looking for a corresponding method __str__ or
   __repr__ in the class definition of the object. If the method does exist, it will be called.
   In the following example, we define a class A, having neither a __str__ nor a __repr__ method. We
   want to see, what happens, if we use print directly on an instance of this class, or if we apply str
   or repr to this instance:
>>> class A:
...     pass
...
>>> a = A()
>>> print(a)
<__main__.A object at 0xb720a64c>
>>> print(repr(a))
<__main__.A object at 0xb720a64c>
>>> print(str(a))
<__main__.A object at 0xb720a64c>
>>> a
<__main__.A object at 0xb720a64c>
>>>

   As both methods are not available, Python uses the default output for our object "a".
   If a class has a __str__ method, the method will be used for an instance x of that class, if either
   the function str is applied to it or if it is used in a print function. __str__ will not be used, if
   repr is called, or if we try to output the value directly in an interactive Python shell:
>>> class A:
...     def __str__(self):
...         return "42"
...
>>> a = A()

>>> print(repr(a))
<__main__.A object at 0xb720a4cc>
>>> print(str(a))
42
>>> a
<__main__.A object at 0xb720a4cc>

   Otherwise, if a class has only the __repr__ method and no __str__ method, __repr__ will be applied in
   the situations, where __str__would be applied, if it were available:
>>> class A:
...     def __repr__(self):
...         return "42"
...
>>> a = A()
>>> print(repr(a))
42
>>> print(str(a))
42
>>> a
42

   A frequently asked question is when to use __repr__ annd when __str__. __str__ is always the right
   choice, if the output should be for the end user or in other words, if it should be nicely printed.
   __repr__ on the other hand is used for the internal representation of an object. The output of
   __repr__ should be - if feasible - a string which can be parsed by the python interpreter. The result
   of this parsing is in an equal object.
   This means that the following should be true for an object "o":
   o == eval(repr(o))
   This is shown in the following interactive Python session:
>>> l = [3,8,9]
>>> s = repr(l)
>>> s
'[3, 8, 9]'
>>> l == eval(s)
True
>>> l == eval(str(l))
True
>>>

   We show in the following example with the datetime module that eval can only be applied on the
   strings created by repr:
>>> import datetime
>>> today = datetime.datetime.now()
>>> str_s = str(today)
>>> eval(str_s)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 1
    2014-01-26 17:35:39.215144
          ^
SyntaxError: invalid token
>>> repr_s = repr(today)
>>> t = eval(repr_s)
>>> type(t)
<class 'datetime.datetime'>
>>>

   We can see that eval(repr_s) returns again a datetime.datetime object. The String created by str
   can't be turned into a datetime.datetime object by parsing it.
   We will extend our robot class with a repr method. We dropped the other methods to keep this example
   simple:
class Robot:

    def __init__(self, name, build_year):
        self.name = name
        self.build_year = build_year

    def __repr__(self):
        return "Robot('" + self.name + "', " +  str(self.build_year) +  ")"

if __name__ == "__main__":
    x = Robot("Marvin", 1979)

    x_str = str(x)
    print(x_str)
    print("Type of x_str: ", type(x_str))
    new = eval(x_str)
    print(new)
    print("Type of new:", type(new))

   x_str has the value Robot('Marvin', 1979). eval(x_str) converts it again into a Robot instance.
   The script returns the following output:
$ python3 robot_class5.py
Robot("Marvin",1979)
Type of x_str:   <class 'str'>
Robot("Marvin",1979)
Type of new: <class '__main__.Robot'>

   Now it's time to extend our class with a user friendly __str__ method:
class Robot:

    def __init__(self, name, build_year):
        self.name = name
        self.build_year = build_year

    def __repr__(self):
        return "Robot('" + self.name + "', " +  str(self.build_year) +  ")"

    def __str__(self):
        return "Name: " + self.name + ", Build Year: " +  str(self.build_year)

if __name__ == "__main__":
    x = Robot("Marvin", 1979)

    x_str = str(x)
    print(x_str)
    print("Type of x_str: ", type(x_str))
    new = eval(x_str)
    print(new)
    print("Type of new:", type(new))

   When we start this program, we can see that it is not possible to convert our string x_str, created
   via str(x), into a Robot object anymore.
$ python3 robot_class6.py
Name: Marvin, Build Year: 1979
Type of x_str:  <class 'str'>
Traceback (most recent call last):
  File "robot_class6.py", line 19, in <module>
    new = eval(x_str)
  File "<string>", line 1
    Name: Marvin, Build Year: 1979
        ^
SyntaxError: invalid syntax

   We show in the following program that x_repr can still be turned into a Robot object:
class Robot:

    def __init__(self, name, build_year):
        self.name = name
        self.build_year = build_year

    def __repr__(self):
        return "Robot(\"" + self.name + "\"," +  str(self.build_year) +  ")"

    def __str__(self):
        return "Name: " + self.name + ", Build Year: " +  str(self.build_year)

if __name__ == "__main__":
    x = Robot("Marvin", 1979)

    x_repr = repr(x)
    print(x_repr, type(x_repr))
    new = eval(x_repr)
    print(new)
    print("Type of new:", type(new))

   The output looks like this:
$ python3 robot_class6b.py
Robot("Marvin",1979) <class 'str'>
Name: Marvin, Build Year: 1979
Type of new: <class '__main__.Robot'>

  Public- Protected- and Private Attributes

   No Trespassing Who doesn't know those trigger-happy farmers from films. Shooting as soon as somebody
   enters their property. This "somebody" has of course neglected the "no trespassing" sign, indicating
   that the land is private property. Maybe he hasn't seen the sign, maybe the sign is hard to be seen?
   Imagine a jogger, running the same course five times a week for more than a year, but than he
   receives a $50 fine for trespassing in the Winchester Fells. Trespassing is a criminal offence in
   Massachusetts. He was innocent anyway, because the signage was inadequate in the area.^4
   Even though no trespassing signs and strict laws do protect the private property, some surround their
   property with fences to keep off unwanted "visitors". Should the fence keep the dog in the yard or
   the burglar in the street? Choose your fence: Wood panel fencing, post-and-rail fencing, chain-link
   fencing with or without barbed wire and so on.
   We have a similar situation in the design of object-oriented programming languages. The first
   decision to take is how to protect the data which should be private. The second decision is what to
   do if trespassing, i.e. accessing or changing private data, occurs. Of course, the private data may
   be protected in a way that it can't be accessed under no circumstances. This is hardly possible in
   practice, as we know from the old saying "Where there's a will, there's a way"!
   Enter at your own risk Some owners allow a restricted access to their property. Joggers or hikers may
   find signs like "Enter at your own risk". A third kind of property might be public property like
   streets or parks, where it is perfectly legal to be.
   We have the same classification again in object-oriented programming:
     * Private attributes should only be used by the owner, i.e. inside of the class definition itself.
     * Protected (restricted) Attributes may be used, but at your own risk. Essentially, this means that
       they should only be used under certain conditions.
     * Public Attributes can and should be freely used.

   Python uses a special naming scheme for attributes to control the accessibility of the attributes. So
   far, we have used attribute names, which can be freely used inside or outside of a class definition,
   as we have seen. This corresponds to public attributes of course.
   There are two ways to restrict the access to class attributes:
     * First, we can prefix an attribute name with a leading underscore "_". This marks the attribute as
       protected. It tells users of the class not to use this attribute unless, somebody writes a
       subclass. We will learn about inheritance and subclassing in the next chapter of our tutorial.
     * Second, we can prefix an attribute name with two leading underscores "__". The attribute is now
       inaccessible and invisible from outside. It's neither possible to read nor write to those
       attributes except inside of the class definition itself.^5

   To summarize the attribute types:
--------------------------------------------------------------------------------------------------------------
Naming     Type        Meaning
--------------------------------------------------------------------------------------------------------------
name       Public      These attributes can be freely used inside or outside of a class definition.

_name      Protected   Protected attributes should not be used outside of the class definition, unless inside
                        of a subclass definition.
                        
__name     Private     This kind of attribute is inaccessible and invisible. It's neither possible to read
                        nor write to those attributes, except inside of the class definition itself.
--------------------------------------------------------------------------------------------------------------

   We want to demonstrate the behaviour of these attribute types with an example class:
class A():

    def __init__(self):
        self.__priv = "I am private"
        self._prot = "I am protected"
        self.pub = "I am public"

   We store this class (attribute_tests.py) and test its behaviour in the following interactive Python
   shell:
>>> from attribute_tests import A
>>> x = A()
>>> x.pub
'I am public'
>>> x.pub = x.pub + " and my value can be changed"
>>> x.pub
'I am public and my value can be changed'
>>> x._prot
'I am protected'
>>> x.__priv
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'A' object has no attribute '__priv'
>>>

   The error message is very interesting. One might have expected a message like "__priv is private". We
   get the message "AttributeError: 'A' object has no attribute '__priv'" instead, which looks like a
   "lie". There is such an attribute, but we are told that there isn't. This is perfect information
   hiding. Telling a user that an attribute name is private, means that we make some information
   visible, i.e. the existence or non-existence of a private variable.
   Our next task consists in rewriting our Robot class. Though we have Getter and Setter methods for the
   name and the build_year, we can access the attributes directly as well, because we have defined them
   as public attributes. Data Encapsulation means, that we should only be able to access private
   attributes via getters and setters.
   We have to replace each occurrence of self.name and self.build_year by self.__name and
   self.__build_year.
   The listing of our revised class:
class Robot:

    def __init__(self, name=None, build_year=2000):
        self.__name = name
        self.__build_year = build_year

    def say_hi(self):
        if self.__name:
            print("Hi, I am " + self.__name)
        else:
            print("Hi, I am a robot without a name")

    def set_name(self, name):
        self.__name = name

    def get_name(self):
        return self.__name

    def set_build_year(self, by):
        self.__build_year = by

    def get_build_year(self):
        return self.__build_year

    def __repr__(self):
        return "Robot('" + self.__name + "', " +  str(self.__build_year) +  ")"

    def __str__(self):
        return "Name: " + self.__name + ", Build Year: " +  str(self.__build_year)


if __name__ == "__main__":
    x = Robot("Marvin", 1979)
    y = Robot("Caliban", 1943)
    for rob in [x, y]:
        rob.say_hi()
        if rob.get_name() == "Caliban":
            rob.set_build_year(1993)
        print("I was built in the year " + str(rob.get_build_year()) + "!")

   We get the following out, if we call this program:
Hi, I am Marvin
I was built in the year 1979!
Hi, I am Caliban
I was built in the year 1993!

   Every private attribute of our class has a getter and a setter. There are IDEs for object-oriented
   programming languages, who automatically provide getters and setters for every private attribute as
   soon as an attribute is created.
   This may look like the following class:
class A():

    def __init__(self, x, y):
        self.__x = x
        self.__y = y

    def GetX(self):
        return self.__x

    def GetY(self):
        return self.__y

    def SetX(self, x):
        self.__x = x

    def SetY(self, y):
        self.__y = y

   There are at least two good reasons against such an approach. First of all not every private
   attribute needs to be accessed from outside. Second, we will create non-pythonic Code this way, as
   you will learn soon.

  Destructor

   What we said about constructors holds true for destructors as well. There is no "real" destructor,
   but something similar, i.e. the method __del__. It is called when the instance is about to be
   destroyed and if there is no other reference to this instance. If a base class has a __del__()
   method, the derived class's __del__() method, if any, must explicitly call it to ensure proper
   deletion of the base class part of the instance.
   The following script is an example with __init__ and __del__:
class Robot():

    def __init__(self, name):
        print(name + " has been created!")

    def __del__(self):
        print ("Robot has been destroyed")


if __name__ == "__main__":
    x = Robot("Tik-Tok")
    y = Robot("Jenkins")
    z = x
    print("Deleting x")
    del x
    print("Deleting z")
    del z
    del y

   The output of the previous program:
$ python3 del_example.py
Tik-Tok has been created!
Jenkins has been created!
Deleting x
Deleting z
Robot has been destroyed
Robot has been destroyed

   The usage of the __del__method is very problematic. If we change the previous code to personalize the
   deletion of a robot, we create an error:
class Robot():

    def __init__(self, name):
        print(name + " has been created!")

    def __del__(self):
        print (self.name + " says bye-bye!")


if __name__ == "__main__":
    x = Robot("Tik-Tok")
    y = Robot("Jenkins")
    z = x
    print("Deleting x")
    del x
    print("Deleting z")
    del z
    del y

   We get the following output with error messages:
$ python3 del_example.py
Tik-Tok has been created!
Jenkins has been created!
Deleting x
Deleting z
Exception AttributeError: "'Robot' object has no attribute 'name'" in <bound method Robot.__del__ of \
<__main__.Robot object at 0xb71da3cc>> ignored

Exception AttributeError: "'Robot' object has no attribute 'name'" in <bound method Robot.__del__ of \
<__main__.Robot object at 0xb71da36c>> ignored

   We are accessing an attribute which doesn't exist anymore. We will learn later, why this is the case.

  Footnotes:

   ^1
   The picture on the right side is taken in the Library of the Court of Appeal for Ontario, located
   downtown Toronto in historic Osgoode Hall ^2
   "Objects are Python's abstraction for data. All data in a Python program is represented by objects or
   by relations between objects. (In a sense, and in conformance to Von Neumann's model of a "stored
   program computer", code is also represented by objects.) Every object has an identity, a type and a
   value." (excerpt from the official Python Language Reference)
   ^3
   "attribute" stems from the Latin verb "attribuere" which means "to associate with"
   ^4
   http://www.wickedlocal.com/x937072506/tJogger-ticketed-for-trespassing-in-the-Winchester-Fells-kicks-
   back
   ^5 There is a way to access a private attribute directly. In our example, we can do it like this:
   x._Robot__build_year
   You shouldn't do this under any circumstances!


---
https://jeffknupp.com/blog/2014/06/18/improve-your-python-python-classes-and-object-oriented-programming/

Improve Your Python: Python Classes and Object Oriented Programming

   The class is a fundamental building block in Python. It is the underpinning for not only many popular
   programs and libraries, but the Python standard library as well. Understanding what classes are, when
   to use them, and how they can be useful is essential, and the goal of this article. In the process,
   we'll explore what the term Object-Oriented Programming means and how it ties together with Python
   classes.

Everything Is An Object...
   What is the class keyword used for, exactly? Like its function-based cousin def, it concerns the
   definition of things. While def is used to define a function, class is used to define a class. And
   what is a class? Simply a logical grouping of data and functions (the latter of which are frequently
   referred to as "methods" when defined within a class).

   What do we mean by "logical grouping"? Well, a class can contain any data we'd like it to, and can
   have any functions (methods) attached to it that we please. Rather than just throwing random things
   together under the name "class", we try to create classes where there is a logical connection between
   things. Many times, classes are based on objects in the real world (like Customer or Product). Other
   times, classes are based on concepts in our system, like HTTPRequest or Owner.

   Regardless, classes are a modeling technique; a way of thinking about programs. When you think about
   and implement your system in this way, you're said to be performing Object-Oriented Programming.
   "Classes" and "objects" are words that are often used interchangeably, but they're not really the
   same thing. Understanding what makes them different is the key to understanding what they are and how
   they work.

..So Everything Has A Class?
   Classes can be thought of as blueprints for creating objects. When I define a Customer class using
   the class keyword, I haven't actually created a customer. Instead, what I've created is a sort of
   instruction manual for constructing "customer" objects. Let's look at the following example code:
class Customer(object):
    """A customer of ABC Bank with a checking account. Customers have the
    following properties:

    Attributes:
        name: A string representing the customer's name.
        balance: A float tracking the current balance of the customer's account.
    """

    def __init__(self, name, balance=0.0):
        """Return a Customer object whose name is *name* and starting
        balance is *balance*."""
        self.name = name
        self.balance = balance

    def withdraw(self, amount):
        """Return the balance remaining after withdrawing *amount*
        dollars."""
        if amount > self.balance:
            raise RuntimeError('Amount greater than available balance.')
        self.balance -= amount
        return self.balance

    def deposit(self, amount):
        """Return the balance remaining after depositing *amount*
        dollars."""
        self.balance += amount
        return self.balance

   The class Customer(object) line does not create a new customer. That is, just because we've defined a
   Customer doesn't mean we've created one; we've merely outlined the blueprint to create a Customer
   object. To do so, we call the class's __init__ method with the proper number of arguments (minus
   self, which we'll get to in a moment).

   So, to use the "blueprint" that we created by defining the class Customer (which is used to create
   Customer objects), we call the class name almost as if it were a function: jeff = Customer('Jeff
   Knupp', 1000.0). This line simply says "use the Customer blueprint to create me a new object, which
   I'll refer to as jeff."

   The jeff object, known as an instance, is the realized version of the Customer class. Before we
   called Customer(), no Customer object existed. We can, of course, create as many Customer objects as
   we'd like. There is still, however, only one Customer class, regardless of how many instances of the
   class we create.

self?
   So what's with that self parameter to all of the Customer methods? What is it? Why, it's the
   instance, of course! Put another way, a method like withdraw defines the instructions for withdrawing
   money from some abstract customer's account. Calling jeff.withdraw(100.0) puts those instructions to
   use on the jeff instance.

   So when we say def withdraw(self, amount):, we're saying, "here's how you withdraw money from a
   Customer object (which we'll call self) and a dollar figure (which we'll call amount). self is the
   instance of the Customer that withdraw is being called on. That's not me making analogies, either.
   jeff.withdraw(100.0) is just shorthand for Customer.withdraw(jeff, 100.0), which is perfectly valid
   (if not often seen) code.

__init__
   self may make sense for other methods, but what about __init__? When we call __init__, we're in the
   process of creating an object, so how can there already be a self? Python allows us to extend the
   self pattern to when objects are constructed as well, even though it doesn't exactly fit. Just
   imagine that jeff = Customer('Jeff Knupp', 1000.0) is the same as calling jeff = Customer(jeff, 'Jeff
   Knupp', 1000.0); the jeff that's passed in is also made the result.

   This is why when we call __init__, we initialize objects by saying things like self.name = name.
   Remember, since self is the instance, this is equivalent to saying jeff.name = name, which is the
   same as jeff.name = 'Jeff Knupp. Similarly, self.balance = balance is the same as jeff.balance =
   1000.0. After these two lines, we consider the Customer object "initialized" and ready for use.

Be careful what you __init__
   After __init__ has finished, the caller can rightly assume that the object is ready to use. That is,
   after jeff = Customer('Jeff Knupp', 1000.0), we can start making deposit and withdraw calls on jeff;
   jeff is a fully-initialized object.

   Imagine for a moment we had defined the Customer class slightly differently:
class Customer(object):
    """A customer of ABC Bank with a checking account. Customers have the
    following properties:

    Attributes:
        name: A string representing the customer's name.
        balance: A float tracking the current balance of the customer's account.
    """

    def __init__(self, name):
        """Return a Customer object whose name is *name*."""
        self.name = name

    def set_balance(self, balance=0.0):
        """Set the customer's starting balance."""
        self.balance = balance

    def withdraw(self, amount):
        """Return the balance remaining after withdrawing *amount*
        dollars."""
        if amount > self.balance:
            raise RuntimeError('Amount greater than available balance.')
        self.balance -= amount
        return self.balance

    def deposit(self, amount):
        """Return the balance remaining after depositing *amount*
        dollars."""
        self.balance += amount
        return self.balance

   This may look like a reasonable alternative; we simply need to call set_balance before we begin using
   the instance. There's no way, however, to communicate this to the caller. Even if we document it
   extensively, we can't force the caller to call jeff.set_balance(1000.0) before calling
   jeff.withdraw(100.0). Since the jeff instance doesn't even have a balance attribute until
   jeff.set_balance is called, this means that the object hasn't been "fully" initialized.

   The rule of thumb is, don't introduce a new attribute outside of the __init__ method, otherwise
   you've given the caller an object that isn't fully initialized. There are exceptions, of course, but
   it's a good principle to keep in mind. This is part of a larger concept of object consistency: there
   shouldn't be any series of method calls that can result in the object entering a state that doesn't
   make sense.

   Invariants (like, "balance should always be a non-negative number") should hold both when a method is
   entered and when it is exited. It should be impossible for an object to get into an invalid state
   just by calling its methods. It goes without saying, then, that an object should start in a valid
   state as well, which is why it's important to initialize everything in the __init__ method.

Instance Attributes and Methods
   An function defined in a class is called a "method". Methods have access to all the data contained on
   the instance of the object; they can access and modify anything previously set on self. Because they
   use self, they require an instance of the class in order to be used. For this reason, they're often
   referred to as "instance methods".

   If there are "instance methods", then surely there are other types of methods as well, right? Yes,
   there are, but these methods are a bit more esoteric. We'll cover them briefly here, but feel free to
   research these topics in more depth.

Static Methods
   Class attributes are attributes that are set at the class-level, as opposed to the instance-level.
   Normal attributes are introduced in the __init__ method, but some attributes of a class hold for all
   instances in all cases. For example, consider the following definition of a Car object:
class Car(object):

    wheels = 4

    def __init__(self, make, model):
        self.make = make
        self.model = model

mustang = Car('Ford', 'Mustang')
print mustang.wheels
# 4
print Car.wheels
# 4

   A Car always has four wheels, regardless of the make or model. Instance methods can access these
   attributes in the same way they access regular attributes: through self (i.e. self.wheels).

   There is a class of methods, though, called static methods, that don't have access to self. Just like
   class attributes, they are methods that work without requiring an instance to be present. Since
   instances are always referenced through self, static methods have no self parameter.

   The following would be a valid static method on the Car class:
class Car(object):
    ...
    def make_car_sound():
        print 'VRooooommmm!'

   No matter what kind of car we have, it always makes the same sound (or so I tell my ten month old
   daughter). To make it clear that this method should not receive the instance as the first parameter
   (i.e. self on "normal" methods), the @staticmethod decorator is used, turning our definition into:
class Car(object):
    ...
    @staticmethod
    def make_car_sound():
        print 'VRooooommmm!'

Class Methods
   A variant of the static method is the class method. Instead of receiving the instance as the first
   parameter, it is passed the class. It, too, is defined using a decorator:
class Vehicle(object):
    ...
    @classmethod
    def is_motorcycle(cls):
        return cls.wheels == 2

   Class methods may not make much sense right now, but that's because they're used most often in
   connection with our next topic: inheritance.

Inheritance
   While Object-oriented Programming is useful as a modeling tool, it truly gains power when the concept
   of inheritance is introduced. Inherticance is the process by which a "child" class derives the data
   and behavior of a "parent" class. An example will definitely help us here.

   Imagine we run a car dealership. We sell all types of vehicles, from motorcycles to trucks. We set
   ourselves apart from the competition by our prices. Specifically, how we determine the price of a
   vehicle on our lot: $5,000 x number of wheels a vehicle has. We love buying back our vehicles as
   well. We offer a flat rate - 10% of the miles driven on the vehicle. For trucks, that rate is
   $10,000. For cars, $8,000. For motorcycles, $4,000.

   If we wanted to create a sales system for our dealership using Object-oriented techniques, how would
   we do so? What would the objects be? We might have a Sale class, a Customer class, an Inventory
   class, and so forth, but we'd almost certainly have a Car, Truck, and Motorcycle class.

   What would these classes look like? Using what we've learned, here's a possible implementation of the
   Car class:
class Car(object):
    """A car for sale by Jeffco Car Dealership.

    Attributes:
        wheels: An integer representing the number of wheels the car has.
        miles: The integral number of miles driven on the car.
        make: The make of the car as a string.
        model: The model of the car as a string.
        year: The integral year the car was built.
        sold_on: The date the vehicle was sold.
    """

    def __init__(self, wheels, miles, make, model, year, sold_on):
        """Return a new Car object."""
        self.wheels = wheels
        self.miles = miles
        self.make = make
        self.model = model
        self.year = year
        self.sold_on = sold_on

    def sale_price(self):
        """Return the sale price for this car as a float amount."""
        if self.sold_on is not None:
            return 0.0  # Already sold
        return 5000.0 * self.wheels

    def purchase_price(self):
        """Return the price for which we would pay to purchase the car."""
        if self.sold_on is None:
            return 0.0  # Not yet sold
        return 8000 - (.10 * self.miles)

    ...

   OK, that looks pretty reasonable. Of course, we would likely have a number of other methods on the
   class, but I've shown two of particular interest to us: sale_price and purchase_price. We'll see why
   these are important in a bit.

   Now that we've got the Car class, perhaps we should crate a Truck class? Let's follow the same
   pattern we did for car:
class Truck(object):
    """A truck for sale by Jeffco Car Dealership.

    Attributes:
        wheels: An integer representing the number of wheels the truck has.
        miles: The integral number of miles driven on the truck.
        make: The make of the truck as a string.
        model: The model of the truck as a string.
        year: The integral year the truck was built.
        sold_on: The date the vehicle was sold.
    """

    def __init__(self, wheels, miles, make, model, year, sold_on):
        """Return a new Truck object."""
        self.wheels = wheels
        self.miles = miles
        self.make = make
        self.model = model
        self.year = year
        self.sold_on = sold_on

    def sale_price(self):
        """Return the sale price for this truck as a float amount."""
        if self.sold_on is not None:
            return 0.0  # Already sold
        return 5000.0 * self.wheels

    def purchase_price(self):
        """Return the price for which we would pay to purchase the truck."""
        if self.sold_on is None:
            return 0.0  # Not yet sold
        return 10000 - (.10 * self.miles)

    ...

   Wow. That's almost identical to the car class. One of the most important rules of programming (in
   general, not just when dealing with objects) is "DRY" or "Don't Repeat Yourself. We've definitely
   repeated ourselves here. In fact, the Car and Truck classes differ only by a single character (aside
   from comments).

   So what gives? Where did we go wrong? Our main problem is that we raced straight to the concrete:
   Cars and Trucks are real things, tangible objects that make intuitive sense as classes. However, they
   share so much data and functionality in common that it seems there must be an abstraction we can
   introduce here. Indeed there is: the notion of Vehicles.

Abstract Classes
   A Vehicle is not a real-world object. Rather, it is a concept that some real-world objects (like
   cars, trucks, and motorcycles) embody. We would like to use the fact that each of these objects can
   be considered a vehicle to remove repeated code. We can do that by creating a Vehicle class:
class Vehicle(object):
    """A vehicle for sale by Jeffco Car Dealership.

    Attributes:
        wheels: An integer representing the number of wheels the vehicle has.
        miles: The integral number of miles driven on the vehicle.
        make: The make of the vehicle as a string.
        model: The model of the vehicle as a string.
        year: The integral year the vehicle was built.
        sold_on: The date the vehicle was sold.
    """

    base_sale_price = 0

    def __init__(self, wheels, miles, make, model, year, sold_on):
        """Return a new Vehicle object."""
        self.wheels = wheels
        self.miles = miles
        self.make = make
        self.model = model
        self.year = year
        self.sold_on = sold_on


    def sale_price(self):
        """Return the sale price for this vehicle as a float amount."""
        if self.sold_on is not None:
            return 0.0  # Already sold
        return 5000.0 * self.wheels

    def purchase_price(self):
        """Return the price for which we would pay to purchase the vehicle."""
        if self.sold_on is None:
            return 0.0  # Not yet sold
        return self.base_sale_price - (.10 * self.miles)

   Now we can make the Car and Truck class inherit from the Vehicle class by replacing object in the
   line class Car(object). The class in parenthesis is the class that is inherited from (object
   essentially means "no inheritance". We'll discuss exactly why we write that in a bit).

   We can now define Car and Truck in a very straightforward way:
class Car(Vehicle):

    def __init__(self, wheels, miles, make, model, year, sold_on):
        """Return a new Car object."""
        self.wheels = wheels
        self.miles = miles
        self.make = make
        self.model = model
        self.year = year
        self.sold_on = sold_on
        self.base_sale_price = 8000


class Truck(Vehicle):

    def __init__(self, wheels, miles, make, model, year, sold_on):
        """Return a new Truck object."""
        self.wheels = wheels
        self.miles = miles
        self.make = make
        self.model = model
        self.year = year
        self.sold_on = sold_on
        self.base_sale_price = 10000

   This works, but has a few problems. First, we're still repeating a lot of code. We'd ultimately like
   to get rid of all repetition. Second, and more problematically, we've introduced the Vehicle class,
   but should we really allow people to create Vehicle objects (as opposed to Cars or Trucks)? A Vehicle
   is just a concept, not a real thing, so what does it mean to say the following:
v = Vehicle(4, 0, 'Honda', 'Accord', 2014, None)
print v.purchase_price()

   A Vehicle doesn't have a base_sale_price, only the individual child classes like Car and Truck do.
   The issue is that Vehicle should really be an Abstract Base Class. Abstract Base Classes are classes
   that are only meant to be inherited from; you can't create instance of an ABC. That means that, if
   Vehicle is an ABC, the following is illegal:
v = Vehicle(4, 0, 'Honda', 'Accord', 2014, None)

   It makes sense to disallow this, as we never meant for vehicles to be used directly. We just wanted
   to use it to abstract away some common data and behavior. So how do we make a class an ABC? Simple!
   The abc module contains a metaclass called ABCMeta (metaclasses are a bit outside the scope of this
   article). Setting a class's metaclass to ABCMeta and making one of its methods virtual makes it an
   ABC. A virtual method is one that the ABC says must exist in child classes, but doesn't necessarily
   actually implement. For example, the Vehicle class may be defined as follows:
from abc import ABCMeta, abstractmethod

class Vehicle(object):
    """A vehicle for sale by Jeffco Car Dealership.


    Attributes:
        wheels: An integer representing the number of wheels the vehicle has.
        miles: The integral number of miles driven on the vehicle.
        make: The make of the vehicle as a string.
        model: The model of the vehicle as a string.
        year: The integral year the vehicle was built.
        sold_on: The date the vehicle was sold.
    """

    __metaclass__ = ABCMeta

    base_sale_price = 0

    def sale_price(self):
        """Return the sale price for this vehicle as a float amount."""
        if self.sold_on is not None:
            return 0.0  # Already sold
        return 5000.0 * self.wheels

    def purchase_price(self):
        """Return the price for which we would pay to purchase the vehicle."""
        if self.sold_on is None:
            return 0.0  # Not yet sold
        return self.base_sale_price - (.10 * self.miles)

    @abstractmethod
    def vehicle_type():
        """"Return a string representing the type of vehicle this is."""
        pass

   Now, since vehicle_type is an abstractmethod, we can't directly create an instance of Vehicle. As
   long as Car and Truck inherit from Vehicle and define vehicle_type, we can instantiate those classes
   just fine.

   Returning to the repetition in our Car and Truck classes, let see if we can't remove that by hoisting
   up common functionality to the base class, Vehicle:
from abc import ABCMeta, abstractmethod
class Vehicle(object):
    """A vehicle for sale by Jeffco Car Dealership.


    Attributes:
        wheels: An integer representing the number of wheels the vehicle has.
        miles: The integral number of miles driven on the vehicle.
        make: The make of the vehicle as a string.
        model: The model of the vehicle as a string.
        year: The integral year the vehicle was built.
        sold_on: The date the vehicle was sold.
    """

    __metaclass__ = ABCMeta

    base_sale_price = 0
    wheels = 0

    def __init__(self, miles, make, model, year, sold_on):
        self.miles = miles
        self.make = make
        self.model = model
        self.year = year
        self.sold_on = sold_on

    def sale_price(self):
        """Return the sale price for this vehicle as a float amount."""
        if self.sold_on is not None:
            return 0.0  # Already sold
        return 5000.0 * self.wheels

    def purchase_price(self):
        """Return the price for which we would pay to purchase the vehicle."""
        if self.sold_on is None:
            return 0.0  # Not yet sold
        return self.base_sale_price - (.10 * self.miles)

    @abstractmethod
    def vehicle_type(self):
        """"Return a string representing the type of vehicle this is."""
        pass

   Now the Car and Truck classes become:
class Car(Vehicle):
    """A car for sale by Jeffco Car Dealership."""

    base_sale_price = 8000
    wheels = 4

    def vehicle_type(self):
        """"Return a string representing the type of vehicle this is."""
        return 'car'

class Truck(Vehicle):
    """A truck for sale by Jeffco Car Dealership."""

    base_sale_price = 10000
    wheels = 4

    def vehicle_type(self):
        """"Return a string representing the type of vehicle this is."""
        return 'truck'

   This fits perfectly with our intuition: as far as our system is concerned, the only difference
   between a car and truck is the base sale price. Defining a Motorcycle class, then, is similarly
   simple:
class Motorcycle(Vehicle):
    """A motorcycle for sale by Jeffco Car Dealership."""

    base_sale_price = 4000
    wheels = 2

    def vehicle_type(self):
        """"Return a string representing the type of vehicle this is."""
        return 'motorcycle'

Inheritance and the LSP
   Even though it seems like we used inheritance to get rid of duplication, what we were really doing
   was simply providing the proper level of abstraction. And abstraction is the key to understanding
   inheritance. We've seen how one side-effect of using inheritance is that we reduce duplicated code,
   but what about from the caller's perspective. How does using inheritance change that code?

   Quite a bit, it turns out. Imagine we have two classes, Dog and Person, and we want to write a
   function that takes either type of object and prints out whether or not the instance in question can
   speak (a dog can't, a person can). We might write code like the following:
def can_speak(animal):
    if isinstance(animal, Person):
        return True
    elif isinstance(animal, Dog):
        return False
    else:
        raise RuntimeError('Unknown animal!')

   That works when we only have two types of animals, but what if we have twenty, or two hundred? That
   if...elif chain is going to get quite long.

   The key insight here is that can_speak shouldn't care what type of animal it's dealing with, the
   animal class itself should tell us if it can speak. By introducing a common base class, Animal, that
   defines can_speak, we relieve the function of it's type-checking burden. Now, as long as it knows it
   was an Animal that was passed in, determining if it can speak is trivial:
def can_speak(animal):
    return animal.can_speak()

   This works because Person and Dog (and whatever other classes we crate to derive from Animal) follow
   the Liskov Substitution Principle. This states that we should be able to use a child class (like
   Person or Dog) wherever a parent class (Animal) is expected an everything will work fine. This sounds
   simple, but it is the basis for a powerful concept we'll discuss in a future article: interfaces.

Summary
   Hopefully, you've learned a lot about what Python classes are, why they're useful, and how to use
   them. The topic of classes and Object-oriented Programming are insanely deep. Indeed, they reach to
   the core of computer science. This article is not meant to be an exhaustive study of classes, nor
   should it be your only reference. There are literally thousands of explanations of OOP and classes
   available online, so if you didn't find this one suitable, certainly a bit of searching will reveal
   one better suited to you.

   As always, corrections and arguments are welcome in the comments. Just try to keep it civil.


---
https://www.programiz.com/python-programming/class

Python Objects and Class

   In this article, you'll learn about the core functionality of Python, Python objects and classes.
   You'll learn what a class is, how to create it and use it in your program.
   [INS: :INS]
   Python classes and objects

   Python is an object oriented programming language. Unlike procedure oriented programming, where the
   main emphasis is on functions, object oriented programming stress on objects.

   Object is simply a collection of data (variables) and methods (functions) that act on those data.
   And, class is a blueprint for the object.

   We can think of class as a sketch (prototype) of a house. It contains all the details about the
   floors, doors, windows etc. Based on these descriptions we build the house. House is the object.

   As, many houses can be made from a description, we can create many objects from a class. An object is
   also called an instance of a class and the process of creating this object is called instantiation.

Defining a Class in Python
   Like function definitions begin with the keyword [14]def, in Python, we define a class using the
   keyword [15]class.

   The first string is called docstring and has a brief description about the class. Although not
   mandatory, this is recommended.

   Here is a simple class definition.
class MyNewClass:
    '''This is a docstring. I have created a new class'''
    pass

   A class creates a new local [16]namespace where all its attributes are defined. Attributes may be
   data or functions.

   There are also special attributes in it that begins with double underscores (__). For example,
   __doc__ gives us the docstring of that class.

   As soon as we define a class, a new class object is created with the same name. This class object
   allows us to access the different attributes as well as to instantiate new objects of that class.
class MyClass:
        "This is my second class"
        a = 10
        def func(self):
                print('Hello')

# Output: 10
print(MyClass.a)

# Output: <function MyClass.func at 0x0000000003079BF8>
print(MyClass.func)

# Output: 'This is my second class'
print(MyClass.__doc__)

   When you run the program, the output will be:
10
<function 0x7feaa932eae8="" at="" myclass.func="">
This is my second class

Creating an Object in Python
   We saw that the class object could be used to access different attributes.

   It can also be used to create new object instances (instantiation) of that class. The procedure to
   create an object is similar to a [17]function call.
>>> ob = MyClass()

   This will create a new instance object named ob. We can access attributes of objects using the object
   name prefix.

   Attributes may be data or method. Method of an object are corresponding functions of that class. Any
   function object that is a class attribute defines a method for objects of that class.

   This means to say, since MyClass.func is a function object (attribute of class), ob.func will be a
   method object.
class MyClass:
        "This is my second class"
        a = 10
        def func(self):
                print('Hello')

# create a new MyClass
ob = MyClass()

# Output: <function MyClass.func at 0x000000000335B0D0>
print(MyClass.func)

# Output: <bound method MyClass.func of <__main__.MyClass object at 0x000000000332DEF0>>
print(ob.func)

# Calling function func()
# Output: Hello
ob.func()

   You may have noticed the self parameter in function definition inside the class but, we called the
   method simply as ob.func() without any [18]arguments. It still worked.

   This is because, whenever an object calls its method, the object itself is passed as the first
   argument. So, ob.func() translates into MyClass.func(ob).

   In general, calling a method with a list of n arguments is equivalent to calling the corresponding
   function with an argument list that is created by inserting the method's object before the first
   argument.

   For these reasons, the first argument of the function in class must be the object itself. This is
   conventionally called self. It can be named otherwise but we highly recommend to follow the
   convention.

   Now you must be familiar with class object, instance object, function object, method object and their
   differences.

Constructors in Python
   Class functions that begins with double underscore (__) are called special functions as they have
   special meaning.

   Of one particular interest is the __init__() function. This special function gets called whenever a
   new object of that class is instantiated.

   This type of function is also called constructors in Object Oriented Programming (OOP). We normally
   use it to initialize all the variables.
class ComplexNumber:
    def __init__(self,r = 0,i = 0):
        self.real = r
        self.imag = i

    def getData(self):
        print("{0}+{1}j".format(self.real,self.imag))

# Create a new ComplexNumber object
c1 = ComplexNumber(2,3)

# Call getData() function
# Output: 2+3j
c1.getData()

# Create another ComplexNumber object
# and create a new attribute 'attr'
c2 = ComplexNumber(5)
c2.attr = 10

# Output: (5, 0, 10)
print((c2.real, c2.imag, c2.attr))

# but c1 object doesn't have attribute 'attr'
# AttributeError: 'ComplexNumber' object has no attribute 'attr'
c1.attr

   In the above example, we define a new class to represent complex numbers. It has two functions,
   __init__() to initialize the variables (defaults to zero) and getData() to display the number
   properly.

   An interesting thing to note in the above step is that attributes of an object can be created on the
   fly. We created a new attribute attr for object c2 and we read it as well. But this did not create
   that attribute for object c1.

Deleting Attributes and Objects
   Any attribute of an object can be deleted anytime, using the del statement. Try the following on the
   Python shell to see the output.
>>> c1 = ComplexNumber(2,3)
>>> del c1.imag
>>> c1.getData()
Traceback (most recent call last):
...
AttributeError: 'ComplexNumber' object has no attribute 'imag'

>>> del ComplexNumber.getData
>>> c1.getData()
Traceback (most recent call last):
...
AttributeError: 'ComplexNumber' object has no attribute 'getData'

   We can even delete the object itself, using the del statement.
>>> c1 = ComplexNumber(1,3)
>>> del c1
>>> c1
Traceback (most recent call last):
...
NameError: name 'c1' is not defined

   Actually, it is more complicated than that. When we do c1 = ComplexNumber(1,3), a new instance object
   is created in memory and the name c1 binds with it.

   On the command del c1, this binding is removed and the name c1 is deleted from the corresponding
   namespace. The object however continues to exist in memory and if no other name is bound to it, it is
   later automatically destroyed.

   This automatic destruction of unreferenced objects in Python is also called garbage collection.


---
https://en.wikibooks.org/wiki/A_Beginner%27s_Python_Tutorial/Classes

A Beginner's Python Tutorial/Classes

   One thing that you will get to know about programming, is that programmers like to be lazy. If
   something has been done before, why should you do it again?

   That is what functions cover in Python. You've already had your code do something special. Now you
   want to do it again. You put that special code into a function, and re-use it for all it is worth.
   You can refer to a function anywhere in your code, and the computer will always know what you are
   talking about. Handy, eh?

   Of course, functions have their limitations. Functions don't store any information like variables do
   - every time a function is run, it starts afresh. However, certain functions and variables are
   related to each other very closely, and need to interact with each other a lot. For example, imagine
   you have a golf club. It has information about it (i.e. variables) like the length of the shaft, the
   material of the grip, and the material of the head. It also has functions associated with it, like
   the function of swinging your golf club, or the function of breaking it in pure frustration. For
   those functions, you need to know the variables of the shaft length, head material, etc.

   That can easily be worked around with normal functions. Parameters affect the effect of a function.
   But what if a function needs to affect variables? What happens if each time you use your golf club,
   the shaft gets weaker, the grip on the handle wears away a little, you get that little more
   frustrated, and a new scratch is formed on the head of the club? A function cannot do that. A
   function only makes one output, not four or five, or five hundred. What is needed is a way to group
   functions and variables that are closely related into one place so that they can interact with each
   other.

   Chances are that you also have more than one golf club. Without classes, you need to write a whole
   heap of code for each different golf club. This is a pain, seeing that all clubs share common
   features, it is just that some have changed properties - like what the shaft is made of, and its
   weight. The ideal situation would be to have a design of your basic golf club. Each time you create a
   new club, simply specify its attributes - the length of its shaft, its weight, etc.

   Or what if you want a golf club, which has added extra features? Maybe you decide to attach a clock
   to your golf club (why, I don't know - it was your idea). Does this mean that we have to create this
   golf club from scratch? We would have to write code first for our basic golf club, plus all of that
   again, and the code for the clock, for our new design. Wouldn't it be better if we were to just take
   our existing golf club, and then tack the code for the clock to it?

   These problems are what a thing called object-oriented-programming solves. It puts functions and
   variables together in a way that they can see each other and work together, be replicated, and
   altered as needed, and not when unneeded. And we use a thing called a 'class' to do this.

Creating a Class
   What is a class? Think of a class as a blueprint. It isn't something in itself, it simply describes
   how to make something. You can create lots of objects from that blueprint - known technically as
   instances.

   So how do you make these so-called 'classes'? Very easily, with the class operator:

   Code Example 1 - defining a class

# Defining a class
class class_name:
    [statement 1]
    [statement 2]
    [statement 3]
    [etc.]

   Makes little sense? That's okay, here is an example that creates the definition of a Shape:

   Code Example 2 - Example of a Class

#An example of a class
class Shape:

    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.description = "This shape has not been described yet"
        self.author = "Nobody has claimed to make this shape yet"

    def area(self):
        return self.x * self.y

    def perimeter(self):
        return 2 * self.x + 2 * self.y

    def describe(self, text):
        self.description = text

    def authorName(self, text):
        self.author = text

    def scaleSize(self, scale):
        self.x = self.x * scale
        self.y = self.y * scale

   What you have created is a description of a shape (That is, the variables) and what operations you
   can do with the shape (That is, the functions). This is very important - you have not made an actual
   shape, simply the description of what a shape is. The shape has a width (x), a height (y), and an
   area and perimeter (area(self) and perimeter(self)). No code is run when you define a class - you are
   simply making functions and variables.

   The function called __init__ is run when we create an instance of Shape - that is, when we create an
   actual shape, as opposed to the 'blueprint' we have here, __init__ is run. You will understand how
   this works later.

   self is how we refer to things in the class from within itself. self is the first parameter in any
   function defined inside a class. Any function or variable created on the first level of indentation
   (that is, lines of code that start one TAB to the right of where we put class Shape) is automatically
   put into self. To access these functions and variables elsewhere inside the class, their name must be
   preceeded with self and a full-stop (e.g. self.variable_name).

Using a Class
   It's all well and good that we can make a class, but how do we use one? Here is an example of what we
   call "creating an instance of a class". Assume that the code in example 2 has already been run:

   Code Example 3 - Creating a class

rectangle = Shape(100, 45)

   What has been done? It takes a little explaining...

   The __init__ function really comes into play at this time. We create an instance of a class by first
   giving its name (in this case, Shape) and then, in brackets, the values to pass to the __init__
   function. The init function runs (using the parameters you gave it in brackets) and then spits out an
   instance of that class, which in this case is assigned to the name "rectangle".

   Think of our class instance, rectangle, as a self-contained collection of variables and functions. In
   the same way that we used self to access functions and variables of the class instance from within
   itself, we use the name that we assigned to it now (rectangle) to access functions and variables of
   the class instance from outside of itself. Following on from the code we ran above, we would do this:

   Code Example 4 - accessing attributes from outside an instance

#finding the area of your rectangle:
print(rectangle.area())

#finding the perimeter of your rectangle:
print(rectangle.perimeter())

#describing the rectangle
rectangle.describe("A wide rectangle, more than twice\
 as wide as it is tall")

#making the rectangle 50% smaller
rectangle.scaleSize(0.5)

#re-printing the new area of the rectangle
print(rectangle.area())

   As you see, where self would be used from within the class instance, its assigned name is used when
   outside the class. We do this to view and change the variables inside the class, and to access the
   functions that are there.

   We aren't limited to a single instance of a class - we could have as many instances as we like. I
   could do this:

   Code Example 5 - More than one instance

long_rectangle = Shape(120,10)
fat_rectangle = Shape(130,120)

   Both long_rectangle and fat_rectangle have their own functions and variables contained inside them -
   they are totally independent of each other. There is no limit to the number of instances I could
   create.

Lingo
   Object-oriented programming has a set of lingo that is associated with it. It's about time that we
   have this all cleared up:
     * when we first describe a class, we are defining it (like with functions)
     * the ability to group similar functions and variables together is called encapsulation
     * the word 'class' can be used when describing the code where the class is defined (like how a
       function is defined), and it can also refer to an instance of that class - this can get
       confusing, so make sure you know in which form we are talking about classes
     * a variable inside a class is known as an 'attribute'
     * a function inside a class is known as a 'method'
     * a class is in the same category of things as variables, lists, dictionaries, etc. That is, they
       are objects
     * a class is known as a 'data structure' - it holds data, and the methods to process that data.

Inheritance
   Let's have a look back at the introduction. We know how classes group together variables and
   functions, known as attributes and methods, so that both the data and the code to process it, are in
   the same spot. We can create any number of instances of that class, so that we don't have to write
   new code for every new object we create. But what about adding extra features to our golf club
   design? This is where inheritance comes into play.

   Python makes inheritance really easy. We define a new class, based on another, 'parent' class. Our
   new class brings everything over from the parent, and we can also add other things to it. If any new
   attributes or methods have the same name as an attribute or method in our parent class, it is used
   instead of the parent one. Remember the Shape class?

   Code Example 6 - the Shape class

class Shape:
    def __init__(self,x,y):
        self.x = x
        self.y = y
        self.description = "This shape has not been described yet"
        self.author = "Nobody has claimed to make this shape yet"
    def area(self):
        return self.x * self.y
    def perimeter(self):
        return 2 * self.x + 2 * self.y
    def describe(self,text):
        self.description = text
    def authorName(self,text):
        self.author = text
    def scaleSize(self,scale):
        self.x = self.x * scale
        self.y = self.y * scale

   If we wanted to define a new class, let's say a square, based on our previous Shape class, we would
   do this:

   Code Example 7 - Using inheritance

class Square(Shape):
    def __init__(self,x):
        self.x = x
        self.y = x

   It is just like normally defining a class, but this time we put the parent class that we inherited
   from in brackets after the name. As you can see, this lets us describe a square really quickly.
   That's because we inherited everything from the shape class, and changed only what needed to be
   changed. In this case we redefined the __init__ function of Shape so that the X and Y values are the
   same.

   Let's take from what we have learnt, and create another new class, this time inherited from Square.
   It will be two squares, one immediately left of the other:

   Code Example 8 - DoubleSquare class

# The shape looks like this:
# _________
#|    |    |
#|    |    |
#|____|____|

class DoubleSquare(Square):
    def __init__(self,y):
        self.x = 2 * y
        self.y = y
    def perimeter(self):
        return 2 * self.x + 3 * self.y

   This time, we also had to redefine the perimeter function, as there is a line going down the middle
   of the shape. Try creating an instance of this class. As a helpful hint, the IDLE command line starts
   where your code ends - so typing a line of code is like adding that line to the end of the program
   you have written.

Pointers and Dictionaries of Classes
   Thinking back, when you say that one variable equals another, e.g. variable2 = variable1, the
   variable on the left-hand side of the equal-sign takes on the value of the variable on the right.
   With class instances, this happens a little differently - the name on the left becomes the class
   instance on the right. So in instance2 = instance1, instance2 is 'pointing' to instance1 - there are
   two names given to the one class instance, and you can access the class instance via either name.

   In other languages, you do things like this using pointers, however in python this all happens behind
   the scenes.

   The final thing that we will cover is dictionaries of classes. Keeping in mind what we have just
   learnt about pointers, we can assign an instance of a class to an entry in a list or dictionary. This
   allows for virtually any amount of class instances to exist when our program is run. Lets have a look
   at the example below, and see how it describes what I am talking about:

   Code Example 9 - Dictionaries of Classes

# Again, assume the definitions on Shape,
# Square and DoubleSquare have been run.
# First, create a dictionary:
dictionary = {}

# Then, create some instances of classes in the dictionary:
dictionary["DoubleSquare 1"] = DoubleSquare(5)
dictionary["long rectangle"] = Shape(600,45)

#You can now use them like a normal class:
print(dictionary["long rectangle"].area())

dictionary["DoubleSquare 1"].authorName("The Gingerbread Man")
print(dictionary["DoubleSquare 1"].author)

   As you see, we simply replaced our boring old name on the left-hand side with an exciting, new,
   dynamic, dictionary entry. Pretty cool, eh?


---
https://www.digitalocean.com/community/tutorials/understanding-class-and-instance-variables-in-python-3

Understanding Class and Instance Variables in Python 3
March 27, 2017

Introduction
   Object-oriented programming allows for [37]variables to be used at the class level or the
   instance level. Variables are essentially symbols that stand in for a value you’re using in a
   program.

   At the class level, variables are referred to as class variables, whereas variables at the instance
   level are called instance variables.

   When we expect variables are going to be consistent across instances, or when we would like to
   initialize a variable, we can define that variable at the class level. When we anticipate the
   variables will change significantly across instances, we can define them at the instance level.

   One of the principles of software development is the DRY principle, which stands for don’t repeat
   yourself. This principle is geared towards limiting repetition within code, and object-oriented
   programming adheres to the DRY principle as it reduces redundancy.

   This tutorial will demonstrate the use of both class and instance variables in object-oriented
   programming within Python.

Class Variables
   Class variables are defined within the [38]class construction. Because they are owned by the class
   itself, class variables are shared by all instances of the class. They therefore will generally have
   the same value for every instance unless you are using the class variable to initialize a variable.

   Defined outside of all the methods, class variables are, by convention, typically placed right below
   the class header and before the [39]constructor method and other methods.

   A class variable alone looks like this:
class Shark:
    animal_type = "fish"

   Here, the variable animal_type is assigned the value "fish".

   We can create an instance of the Shark class (we’ll call it new_shark) and print the variable by
   using dot notation:
   shark.py
class Shark:
    animal_type = "fish"

new_shark = Shark()
print(new_shark.animal_type)

   Let’s run the program:
     * python shark.py

   Output
fish

   Our program returns the value of the variable.

   Let’s add a few more class variables and print them out:
   shark.py
class Shark:
    animal_type = "fish"
    location = "ocean"
    followers = 5

new_shark = Shark()
print(new_shark.animal_type)
print(new_shark.location)
print(new_shark.followers)

   Just like with any other variable, class variables can consist of any [40]data type available to us
   in Python. In this program we have strings and an integer. Let’s run the program again with the
   python shark.py command and see the output:

   Output
fish
ocean
5

   The instance of new_shark is able to access all the class variables and print them out when we run
   the program.

   Class variables allow us to define variables upon constructing the class. These variables and their
   associated values are then accessible to each instance of the class.

Instance Variables
   Instance variables are owned by instances of the class. This means that for each object or instance
   of a class, the instance variables are different.

   Unlike class variables, instance variables are defined within methods.

   In the Shark class example below, name and age are instance variables:
class Shark:
    def __init__(self, name, age):
        self.name = name
        self.age = age

   When we create a Shark object, we will have to define these variables, which are passed as parameters
   within the constructor method or another method.
class Shark:
    def __init__(self, name, age):
        self.name = name
        self.age = age

new_shark = Shark("Sammy", 5)

   As with class variables, we can similarly call to print instance variables:
   shark.py
class Shark:
    def __init__(self, name, age):
        self.name = name
        self.age = age

new_shark = Shark("Sammy", 5)
print(new_shark.name)
print(new_shark.age)

   When we run the program above with python shark.py, we’ll receive the following output:

   Output
Sammy
5

   The output we receive is made up of the values of the variables that we initialized for the object
   instance of new_shark.

   Let’s create another object of the Shark class called stevie:
   shark.py
class Shark:
    def __init__(self, name, age):
        self.name = name
        self.age = age

new_shark = Shark("Sammy", 5)
print(new_shark.name)
print(new_shark.age)

stevie = Shark("Stevie", 8)
print(stevie.name)
print(stevie.age)

   The stevie object, like the new_shark object passes the parameters specific for that instance of the
   Shark class to assign values to the instance variables.

   Instance variables, owned by objects of the class, allow for each object or instance to have
   different values assigned to those variables.

Working with Class and Instance Variables Together

   Class variables and instance variables will often be utilized at the same time, so let’s look at an
   example of this using the Shark class we created. The comments in the program outline each step of
   the process.
   shark.py
class Shark:

    # Class variables
    animal_type = "fish"
    location = "ocean"

    # Constructor method with instance variables name and age
    def __init__(self, name, age):
        self.name = name
        self.age = age

    # Method with instance variable followers
    def set_followers(self, followers):
        print("This user has " + str(followers) + " followers")


def main():
    # First object, set up instance variables of constructor method
    sammy = Shark("Sammy", 5)

    # Print out instance variable name
    print(sammy.name)

    # Print out class variable location
    print(sammy.location)

    # Second object
    stevie = Shark("Stevie", 8)

    # Print out instance variable name
    print(stevie.name)

    # Use set_followers method and pass followers instance variable
    stevie.set_followers(77)

    # Print out class variable animal_type
    print(stevie.animal_type)

if __name__ == "__main__":
    main()


   When we run the program with python shark.py, we’ll receive the following output:

   Output
Sammy
ocean
Stevie
This user has 77 followers
fish

   Here, we have made use of both class and instance variables in two objects of the Shark class, sammy
   and stevie.

Conclusion
   In object-oriented programming, variables at the class level are referred to as class variables,
   whereas variables at the object level are called instance variables.

   This differentiation allows us to use class variables to initialize objects with a specific value
   assigned to variables, and use different variables for each object with instance variables.

   Making use of class- and instance-specific variables can ensure that our code adheres to the DRY
   principle to reduce repetition within code.


---
http://www.jesshamrick.com/2011/05/18/an-introduction-to-classes-and-inheritance-in-python/

An Introduction to Classes and Inheritance (in Python)
May 18th, 2011

   If you would like a copy of the code used in this post, you can download it [10]here.

   This post aims to give a short, basic introduction to the concept of classes and inheritance, using
   Python as the language of choice. It assumes knowledge of very basic Python syntax and functions.
   These examples were conceived during the [11]Boston Python Workshop this past weekend.

What is a Class?
   Data structures like lists and strings are extremely useful, but sometimes they aren’t enough to
   represent something you’re trying to implement. For example, let’s say we needed to keep track of a
   bunch of pets. We could represent a pet using a list by specifying the first element of the list as
   the pet’s name and the second element of the list as the pet’s species. This is very arbitrary and
   nonintuitive, however – how do you know which element is supposed to be which?

   Classes give us the ability to create more complicated data structures that contain arbitrary
   content. We can create a Pet class that keeps track of the name and species of the pet in usefully
   named attributes called name and species, respectively.

What is an Instance?
   Before we get into creating a class itself, we need to understand an important distinction. A class
   is something that just contains structure – it defines how something should be laid out or
   structured, but doesn’t actually fill in the content. For example, a Pet class may say that a pet
   needs to have a name and a species, but it will not actually say what the pet’s name or species is.

   This is where instances come in. An instance is a specific copy of the class that does contain all of
   the content. For example, if I create a pet polly, with name "Polly" and species "Parrot", then polly
   is an instance of Pet.

   This can sometimes be a very difficult concept to master, so let’s look at it from another angle.
   Let’s say that the government has a particular tax form that it requires everybody to fill out.
   Everybody has to fill out the same type of form, but the content that people put into the form
   differs from person to person. A class is like the form: it specifies what content should exist. Your
   copy of the form with your specific information if like an instance of the class: it specifies what
   the content actually is.

Keeping Track of Pets
   Now that we have an idea of what a class is and what the difference between a class and an instance
   is, let’s look at a real class!
   Pet Class

class Pet(object):

    def __init__(self, name, species):
        self.name = name
        self.species = species

    def getName(self):
        return self.name

    def getSpecies(self):
        return self.species

    def __str__(self):
        return "%s is a %s" % (self.name, self.species)

Line 1
   This is the basic incant for creating a class. The first word, class, indicates that we are creating
   a class. The second word, Pet, indicates the name of the class. The word in parentheses, object, is
   the class that Pet is inheriting from. We’ll get more into inheritance below, so for now all you need
   to know is that object is a special variable in Python that you should include in the parentheses
   when you are creating a new class.

Lines 3-5
   When we create a new pet, we need to initialize (that is, specify) it with a name and a species. The
   __init__ method (method is just a special term for functions that are part of a class) is a special
   Python function that is called when an instance of a class is first created. For example, when
   running the code polly = Pet("Polly", "Parrot"), the __init__ method is called with values polly,
   "Polly", and "Parrot" for the variables self, name, and species, respectively.

   The self variable is the instance of the class. Remember that instances have the structure of the
   class but that the values within an instance may vary from instance to instance. So, we want to
   specify that our instance (self) has different values in it than some other possible instance. That
   is why we say self.name = name instead of Pet.name = name.

   You might have noticed that the __init__ method (as well as other methods in the Pet class) have this
   self variable, but that when you call the method (e.g. polly = Pet("Polly", "Parrot")), you only have
   to pass in two values. Why don’t we have to pass in the self parameter? This phenomena is a special
   behavior of Python: when you call a method of an instance, Python automatically figures out what self
   should be (from the instance) and passes it to the function. In the case of __init__, Python first
   creates self and then passes it in. We’ll talk a little bit more about this below when we discuss the
   getName and getSpecies methods.

Lines 7-11
   We can also define methods to get the contents of the instance. The getName method takes an instance
   of a Pet as a parameter and looks up the pet’s name. Similarly, the getSpecies method takes an
   instance of a Pet as a parameter and looks up the pet’s species. Again, we require the self parameter
   so that the function knows which instance of Pet to operate on: it needs to be able to find out the
   content.

   As mentioned before, we don’t actually have to pass in the self parameter because Python
   automatically figures it out. To make it a little bit clearer as to what is going on, we can look at
   two different ways of calling getName. The first way is the standard way of doing it:
   polly.getName(). The second, while not conventional, is equivalent: Pet.getName(polly). Note how in
   the second example we had to pass in the instance because we did not call the method via the
   instance. Python can’t figure out what the instance is if it doesn’t have any information about it.

   To drive the difference between instances and classes home, we can look at an explicit example:

>>> from pets import Pet
>>> polly = Pet("Polly", "Parrot")
>>> print "Polly is a %s" % polly.getSpecies()
Polly is a Parrot
>>> print "Polly is a %s" % Pet.getSpecies(polly)
Polly is a Parrot
>>> print "Polly is a %s" % Pet.getSpecies()
Traceback (most recent call last):
  File "", line 1, in
TypeError: unbound method getSpecies() must be called with Pet instance as first
argument (got nothing instead)

Lines 13-14
   This __str__ method is a special function that is defined for all classes in Python (you have have
   noticed that methods beginning and ending with a double underscore are special). You can specify your
   own version of any built-in method, known as overriding the method. By overriding the __str__ method
   specifically, we can define the behavior when we try to print an instance of the Pet class using the
   print keyword.

Using Classes
   Let’s look at some examples of using the Pet class!
   
   Polly the Parrot

>>> from pets import Pet
>>> polly = Pet("Polly", "Parrot")
>>> polly.getName()
'Polly'
>>> polly.getSpecies()
'Parrot'
>>> print polly
Polly is a Parrot


   Ginger the Cat
   
>>> from pets import Pet
>>> ginger = Pet("Ginger", "Cat")
>>> ginger.getName()
'Ginger'
>>> ginger.getSpecies()
'Cat'
>>> print ginger
Ginger is a Cat

   Clifford the Dog
   
>>> from pets import Pet
>>> clifford = Pet("Clifford", "Dog")
>>> clifford.getName()
'Clifford'
>>> clifford.getSpecies()
'Dog'
>>> print clifford
Clifford is a Dog

Subclasses
   Sometimes just defining a single class (like Pet) is not enough. For example, some pets are dogs and
   most dogs like to chase cats, and maybe we want to keep track of which dogs do or do not like to
   chase cats. Birds are also pets but they generally don’t like to chase cats. We can make another
   class that is a Pet but is also specifically a Dog, for example: this gives us the structure from Pet
   but also any structure we want to specify for Dog.
   
   Dog Class
   
class Dog(Pet):

    def __init__(self, name, chases_cats):
        Pet.__init__(self, name, "Dog")
        self.chases_cats = chases_cats

    def chasesCats(self):
        return self.chases_cats

   We want to specify that all Dogs have species "Dog", and also whether or not the dog likes to chase
   cats. To do this, we need to define our own initialization function (recall that this is known as
   overriding). We also need to call the parent class initialization function, though, because we still
   want the name and species fields to be initialized. If we did not have line 4, then we could still
   call the methods getName and getSpecies. However, because Pet.__init__ was never called, the name and
   species fields were never created, so calling getName or getSpecies would throw an error.

   We can define a similar subclass for cats:
   
   Cat Class
   
class Cat(Pet):

    def __init__(self, name, hates_dogs):
        Pet.__init__(self, name, "Cat")
        self.hates_dogs = hates_dogs

    def hatesDogs(self):
        return self.hates_dogs

A Closer Look at Inheritance
   Let’s examine the difference between Dog and Pet.
   
>>> from pets import Pet, Dog
>>> mister_pet = Pet("Mister", "Dog")
>>> mister_dog = Dog("Mister", True)

   The function used below, isinstance, is a special function that checs to see if an instance is an
   instance of a certain type of class. Here we can see that mister_pet is an instance of Pet, but not
   Dog, while mister_dog is an instance of both Pet and Dog:
   
>>> isinstance(mister_pet, Pet)
True
>>> isinstance(mister_pet, Dog)
False
>>> isinstance(mister_dog, Pet)
True
>>> isinstance(mister_dog, Dog)
True

   Because mister_pet is a Pet, but not a Dog, we can’t call chasesCats on it because the Pet class has
   no chasesCats method. We can, however, call chasesCats on mister_dog, because it is defined for the
   Dog class. Conversely, we can call the getName method on both mister_pet and mister_dog because they
   are both instances of Pet, even though getName is not explicitly defined in the Dog class.
   
>>> mister_pet.chasesCats()
Traceback (most recent call last):
  File "", line 1, in
AttributeError: 'Pet' object has no attribute 'chasesCats'
>>> mister_dog.chasesCats()
True
>>> mister_pet.getName()
'Mister'
>>> mister_dog.getName()
'Mister'

Cats and Dogs

   Now let’s create some cats and dogs.

>>> from pets import Cat, Dog
>>> fido = Dog("Fido", True)
>>> rover = Dog("Rover", False)
>>> mittens = Cat("Mittens", True)
>>> fluffy = Cat("Fluffy", False)
>>> print fido
Fido is a Dog
>>> print rover
Rover is a Dog
>>> print mittens
Mittens is a Cat
>>> print fluffy
Fluffy is a Cat
>>> print "%s chases cats: %s" % (fido.getName(), fido.chasesCats())
Fido chases cats: True
>>> print "%s chases cats: %s" % (rover.getName(), rover.chasesCats())
Rover chases cats: False
>>> print "%s hates dogs: %s" % (mittens.getName(), mittens.hatesDogs())
Mittens hates dogs: True
>>> print "%s hates dogs: %s" % (fluffy.getName(), fluffy.hatesDogs())
Fluffy hates dogs: False

The End

