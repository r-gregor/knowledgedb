filename: python_OOP_V1-multif_20171004.txt
https://www.tutorialspoint.com/python/python_classes_objects.htm

Python Object Oriented

   Python has been an object-oriented language since it existed. Because of this, creating and using
   classes and objects are downright easy. This chapter helps you become an expert in using Python's
   object-oriented programming support.

   If you do not have any previous experience with object-oriented (OO) programming, you may want to
   consult an introductory course on it or at least a tutorial of some sort so that you have a grasp of
   the basic concepts.

   However, here is small introduction of Object-Oriented Programming (OOP) to bring you at speed −

Overview of OOP Terminology
     * Class: A user-defined prototype for an object that defines a set of attributes that characterize
       any object of the class. The attributes are data members (class variables and instance variables)
       and methods, accessed via dot notation.
     * Class variable: A variable that is shared by all instances of a class. Class variables are
       defined within a class but outside any of the class's methods. Class variables are not used as
       frequently as instance variables are.
     * Data member: A class variable or instance variable that holds data associated with a class and
       its objects.
     * Function overloading: The assignment of more than one behavior to a particular function. The
       operation performed varies by the types of objects or arguments involved.
     * Instance variable: A variable that is defined inside a method and belongs only to the current
       instance of a class.
     * Inheritance: The transfer of the characteristics of a class to other classes that are derived
       from it.
     * Instance: An individual object of a certain class. An object obj that belongs to a class Circle,
       for example, is an instance of the class Circle.
     * Instantiation: The creation of an instance of a class.
     * Method : A special kind of function that is defined in a class definition.
     * Object: A unique instance of a data structure that's defined by its class. An object comprises
       both data members (class variables and instance variables) and methods.
     * Operator overloading: The assignment of more than one function to a particular operator.

Creating Classes
   The class statement creates a new class definition. The name of the class immediately follows the
   keyword class followed by a colon as follows −
class ClassName:
   'Optional class documentation string'
   class_suite

     * The class has a documentation string, which can be accessed via ClassName.__doc__.
     * The class_suite consists of all the component statements defining class members, data attributes
       and functions.

Example
   Following is the example of a simple Python class −
class Employee:
   'Common base class for all employees'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1

   def displayCount(self):
     print "Total Employee %d" % Employee.empCount

   def displayEmployee(self):
      print "Name : ", self.name,  ", Salary: ", self.salary

     * The variable empCount is a class variable whose value is shared among all instances of a this
       class. This can be accessed as Employee.empCount from inside the class or outside the class.
     * The first method __init__() is a special method, which is called class constructor or
       initialization method that Python calls when you create a new instance of this class.
     * You declare other class methods like normal functions with the exception that the first argument
       to each method is self. Python adds the self argument to the list for you; you do not need to
       include it when you call the methods.

Creating Instance Objects
   To create instances of a class, you call the class using class name and pass in whatever arguments
   its __init__ method accepts.
"This would create first object of Employee class"
emp1 = Employee("Zara", 2000)
"This would create second object of Employee class"
emp2 = Employee("Manni", 5000)

Accessing Attributes

   You access the object's attributes using the dot operator with object. Class variable would be
   accessed using class name as follows −
emp1.displayEmployee()
emp2.displayEmployee()
print "Total Employee %d" % Employee.empCount

   Now, putting all the concepts together −
#!/usr/bin/python

class Employee:
   'Common base class for all employees'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1

   def displayCount(self):
     print "Total Employee %d" % Employee.empCount

   def displayEmployee(self):
      print "Name : ", self.name,  ", Salary: ", self.salary

"This would create first object of Employee class"
emp1 = Employee("Zara", 2000)
"This would create second object of Employee class"
emp2 = Employee("Manni", 5000)
emp1.displayEmployee()
emp2.displayEmployee()
print "Total Employee %d" % Employee.empCount

   When the above code is executed, it produces the following result −
Name :  Zara ,Salary:  2000
Name :  Manni ,Salary:  5000
Total Employee 2

   You can add, remove, or modify attributes of classes and objects at any time −
emp1.age = 7  # Add an 'age' attribute.
emp1.age = 8  # Modify 'age' attribute.
del emp1.age  # Delete 'age' attribute.

   Instead of using the normal statements to access attributes, you can use the following functions −
     * The getattr(obj, name[, default]) : to access the attribute of object.
     * The hasattr(obj,name) : to check if an attribute exists or not.
     * The setattr(obj,name,value) : to set an attribute. If attribute does not exist, then it would be
       created.
     * The delattr(obj, name) : to delete an attribute.

hasattr(emp1, 'age')    # Returns true if 'age' attribute exists
getattr(emp1, 'age')    # Returns value of 'age' attribute
setattr(emp1, 'age', 8) # Set attribute 'age' at 8
delattr(empl, 'age')    # Delete attribute 'age'

Built-In Class Attributes
   Every Python class keeps following built-in attributes and they can be accessed using dot operator
   like any other attribute −
     * __dict__: Dictionary containing the class's namespace.
     * __doc__: Class documentation string or none, if undefined.
     * __name__: Class name.
     * __module__: Module name in which the class is defined. This attribute is "__main__" in
       interactive mode.
     * __bases__: A possibly empty tuple containing the base classes, in the order of their occurrence
       in the base class list.

   For the above class let us try to access all these attributes −
#!/usr/bin/python

class Employee:
   'Common base class for all employees'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1

   def displayCount(self):
     print "Total Employee %d" % Employee.empCount

   def displayEmployee(self):
      print "Name : ", self.name,  ", Salary: ", self.salary

print "Employee.__doc__:", Employee.__doc__
print "Employee.__name__:", Employee.__name__
print "Employee.__module__:", Employee.__module__
print "Employee.__bases__:", Employee.__bases__
print "Employee.__dict__:", Employee.__dict__

   When the above code is executed, it produces the following result −
Employee.__doc__: Common base class for all employees
Employee.__name__: Employee
Employee.__module__: __main__
Employee.__bases__: ()
Employee.__dict__: {'__module__': '__main__', 'displayCount':
<function displayCount at 0xb7c84994>, 'empCount': 2,
'displayEmployee': <function displayEmployee at 0xb7c8441c>,
'__doc__': 'Common base class for all employees',
'__init__': <function __init__ at 0xb7c846bc>}

Destroying Objects (Garbage Collection)
   Python deletes unneeded objects (built-in types or class instances) automatically to free the memory
   space. The process by which Python periodically reclaims blocks of memory that no longer are in use
   is termed Garbage Collection.

   Python's garbage collector runs during program execution and is triggered when an object's reference
   count reaches zero. An object's reference count changes as the number of aliases that point to it
   changes.

   An object's reference count increases when it is assigned a new name or placed in a container (list,
   tuple, or dictionary). The object's reference count decreases when it's deleted with del, its
   reference is reassigned, or its reference goes out of scope. When an object's reference count reaches
   zero, Python collects it automatically.
a = 40      # Create object <40>
b = a       # Increase ref. count  of <40>
c = [b]     # Increase ref. count  of <40>

del a       # Decrease ref. count  of <40>
b = 100     # Decrease ref. count  of <40>
c[0] = -1   # Decrease ref. count  of <40>

   You normally will not notice when the garbage collector destroys an orphaned instance and reclaims
   its space. But a class can implement the special method __del__(), called a destructor, that is
   invoked when the instance is about to be destroyed. This method might be used to clean up any non
   memory resources used by an instance.

Example
   This __del__() destructor prints the class name of an instance that is about to be destroyed −
#!/usr/bin/python

class Point:
   def __init__( self, x=0, y=0):
      self.x = x
      self.y = y
   def __del__(self):
      class_name = self.__class__.__name__
      print class_name, "destroyed"

pt1 = Point()
pt2 = pt1
pt3 = pt1
print id(pt1), id(pt2), id(pt3) # prints the ids of the obejcts
del pt1
del pt2
del pt3

   When the above code is executed, it produces following result −
3083401324 3083401324 3083401324
Point destroyed

   Note: Ideally, you should define your classes in separate file, then you should import them in your
   main program file using import statement.

Class Inheritance
   Instead of starting from scratch, you can create a class by deriving it from a preexisting class by
   listing the parent class in parentheses after the new class name.

   The child class inherits the attributes of its parent class, and you can use those attributes as if
   they were defined in the child class. A child class can also override data members and methods from
   the parent.

Syntax
   Derived classes are declared much like their parent class; however, a list of base classes to inherit
   from is given after the class name −
class SubClassName (ParentClass1[, ParentClass2, ...]):
   'Optional class documentation string'
   class_suite

Example
#!/usr/bin/python

class Parent:        # define parent class
   parentAttr = 100
   def __init__(self):
      print "Calling parent constructor"

   def parentMethod(self):
      print 'Calling parent method'

   def setAttr(self, attr):
      Parent.parentAttr = attr

   def getAttr(self):
      print "Parent attribute :", Parent.parentAttr

class Child(Parent): # define child class
   def __init__(self):
      print "Calling child constructor"

   def childMethod(self):
      print 'Calling child method'

c = Child()          # instance of child
c.childMethod()      # child calls its method
c.parentMethod()     # calls parent's method
c.setAttr(200)       # again call parent's method
c.getAttr()          # again call parent's method

   When the above code is executed, it produces the following result −
Calling child constructor
Calling child method
Calling parent method
Parent attribute : 200

   Similar way, you can drive a class from multiple parent classes as follows −
class A:        # define your class A
.....

class B:         # define your class B
.....

class C(A, B):   # subclass of A and B
.....

   You can use issubclass() or isinstance() functions to check a relationships of two classes and
   instances.
     * The issubclass(sub, sup) boolean function returns true if the given subclass sub is indeed a
       subclass of the superclass sup.
     * The isinstance(obj, Class) boolean function returns true if obj is an instance of class Class or
       is an instance of a subclass of Class

Overriding Methods
   You can always override your parent class methods. One reason for overriding parent's methods is
   because you may want special or different functionality in your subclass.

Example
#!/usr/bin/python

class Parent:        # define parent class
   def myMethod(self):
      print 'Calling parent method'

class Child(Parent): # define child class
   def myMethod(self):
      print 'Calling child method'

c = Child()          # instance of child
c.myMethod()         # child calls overridden method

   When the above code is executed, it produces the following result −
Calling child method

Base Overloading Methods

   Following table lists some generic functionality that you can override in your own classes −
   SN Method, Description & Sample Call
   1 __init__ ( self [,args...] )
   Constructor (with any optional arguments)
   Sample Call : obj = className(args)
   2 __del__( self )
   Destructor, deletes an object
   Sample Call : del obj
   3 __repr__( self )
   Evaluatable string representation
   Sample Call : repr(obj)
   4 __str__( self )
   Printable string representation
   Sample Call : str(obj)
   5 __cmp__ ( self, x )
   Object comparison
   Sample Call : cmp(obj, x)

Overloading Operators
   Suppose you have created a Vector class to represent two-dimensional vectors, what happens when you
   use the plus operator to add them? Most likely Python will yell at you.

   You could, however, define the __add__ method in your class to perform vector addition and then the
   plus operator would behave as per expectation −

Example
#!/usr/bin/python

class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b

   def __str__(self):
      return 'Vector (%d, %d)' % (self.a, self.b)

   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)

v1 = Vector(2,10)
v2 = Vector(5,-2)
print v1 + v2

   When the above code is executed, it produces the following result −
Vector(7,8)

Data Hiding

   An object's attributes may or may not be visible outside the class definition. You need to name
   attributes with a double underscore prefix, and those attributes then are not be directly visible to
   outsiders.

Example
#!/usr/bin/python

class JustCounter:
   __secretCount = 0

   def count(self):
      self.__secretCount += 1
      print self.__secretCount

counter = JustCounter()
counter.count()
counter.count()
print counter.__secretCount

   When the above code is executed, it produces the following result −
1
2
Traceback (most recent call last):
  File "test.py", line 12, in <module>
    print counter.__secretCount
AttributeError: JustCounter instance has no attribute '__secretCount'

   Python protects those members by internally changing the name to include the class name. You can
   access such attributes as object._className__attrName. If you would replace your last line as
   following, then it works for you −
.........................
print counter._JustCounter__secretCount

   When the above code is executed, it produces the following result −
1
2
2


---
https://python.swaroopch.com/oop.html

Object Oriented Programming

   In all the programs we wrote till now, we have designed our program around functions i.e. blocks of
   statements which manipulate data. This is called the procedure-oriented way of programming. There is
   another way of organizing your program which is to combine data and functionality and wrap it inside
   something called an object. This is called the object oriented programming paradigm. Most of the time
   you can use procedural programming, but when writing large programs or have a problem that is better
   suited to this method, you can use object oriented programming techniques.

   Classes and objects are the two main aspects of object oriented programming. A class creates a new
   type where objects are instances of the class. An analogy is that you can have variables of type int
   which translates to saying that variables that store integers are variables which are instances
   (objects) of the int class.

     Note for Static Language Programmers

     Note that even integers are treated as objects (of the int class). This is unlike C++ and Java
     (before version 1.5) where integers are primitive native types.

     See help(int) for more details on the class.

     C# and Java 1.5 programmers will find this similar to the boxing and unboxing concept.

   Objects can store data using ordinary variables that belong to the object. Variables that belong to
   an object or class are referred to as fields. Objects can also have functionality by using functions
   that belong to a class. Such functions are called methods of the class. This terminology is important
   because it helps us to differentiate between functions and variables which are independent and those
   which belong to a class or object. Collectively, the fields and methods can be referred to as the
   attributes of that class.

   Fields are of two types - they can belong to each instance/object of the class or they can belong to
   the class itself. They are called instance variables and class variables respectively.

   A class is created using the class keyword. The fields and methods of the class are listed in an
   indented block.

The self
   Class methods have only one specific difference from ordinary functions - they must have an extra
   first name that has to be added to the beginning of the parameter list, but you do not give a value
   for this parameter when you call the method, Python will provide it. This particular variable refers
   to the object itself, and by convention, it is given the name self.

   Although, you can give any name for this parameter, it is strongly recommended that you use the name
   self - any other name is definitely frowned upon. There are many advantages to using a standard name
   - any reader of your program will immediately recognize it and even specialized IDEs (Integrated
   Development Environments) can help you if you use self.

     Note for C++/Java/C# Programmers

     The self in Python is equivalent to the this pointer in C++ and the this reference in Java and C#.

   You must be wondering how Python gives the value for self and why you donʼt need to give a value for
   it. An example will make this clear. Say you have a class called MyClass and an instance of this
   class called myobject. When you call a method of this object as myobject.method(arg1, arg2), this is
   automatically converted by Python into MyClass.method(myobject, arg1, arg2) - this is all the special
   self is about.

   This also means that if you have a method which takes no arguments, then you still have to have one
   argument - the self.

Classes
   The simplest class possible is shown in the following example (save as oop_simplestclass.py).
class Person:
    pass  # An empty block

p = Person()
print(p)

   Output:
$ python oop_simplestclass.py
<__main__.Person instance at 0x10171f518>

   How It Works
   We create a new class using the class statement and the name of the class. This is followed by an
   indented block of statements which form the body of the class. In this case, we have an empty block
   which is indicated using the pass statement.

   Next, we create an object/instance of this class using the name of the class followed by a pair of
   parentheses. (We will learn [31]more about instantiation in the next section). For our verification,
   we confirm the type of the variable by simply printing it. It tells us that we have an instance of
   the Person class in the __main__ module.

   Notice that the address of the computer memory where your object is stored is also printed. The
   address will have a different value on your computer since Python can store the object wherever it
   finds space.

Methods
   We have already discussed that classes/objects can have methods just like functions except that we
   have an extra self variable. We will now see an example (save as oop_method.py).
class Person:
    def say_hi(self):
        print(ʼHello, how are you?ʼ)

p = Person()
p.say_hi()
# The previous 2 lines can also be written as
# Person().say_hi()

   Output:
$ python oop_method.py
Hello, how are you?

   How It Works

   Here we see the self in action. Notice that the say_hi method takes no parameters but still has the
   self in the function definition.

The __init__ method

   There are many method names which have special significance in Python classes. We will see the
   significance of the __init__ method now.

   The __init__ method is run as soon as an object of a class is instantiated. The method is useful to
   do any initialization you want to do with your object. Notice the double underscores both at the
   beginning and at the end of the name.

   Example (save as oop_init.py):
class Person:
    def __init__(self, name):
        self.name = name

    def say_hi(self):
        print(ʼHello, my name isʼ, self.name)

p = Person(ʼSwaroopʼ)
p.say_hi()
# The previous 2 lines can also be written as
# Person(ʼSwaroopʼ).say_hi()

   Output:
$ python oop_init.py
Hello, my name is Swaroop

   How It Works
   Here, we define the __init__ method as taking a parameter name (along with the usual self). Here, we
   just create a new field also called name. Notice these are two different variables even though they
   are both called ʼnameʼ. There is no problem because the dotted notation self.name means that there is
   something called "name" that is part of the object called "self" and the other name is a local
   variable. Since we explicitly indicate which name we are referring to, there is no confusion.

   When creating new instance p, of the class Person, we do so by using the class name, followed by the
   arguments in the parentheses: p = Person(ʼSwaroopʼ).

   We do not explicitly call the __init__ method. This is the special significance of this method.

   Now, we are able to use the self.name field in our methods which is demonstrated in the say_hi
   method.

Class And Object Variables
   We have already discussed the functionality part of classes and objects (i.e. methods), now let us
   learn about the data part. The data part, i.e. fields, are nothing but ordinary variables that are
   bound to the namespaces of the classes and objects. This means that these names are valid within the
   context of these classes and objects only. Thatʼs why they are called name spaces.

   There are two types of fields - class variables and object variables which are classified depending
   on whether the class or the object owns the variables respectively.

   Class variables are shared - they can be accessed by all instances of that class. There is only one
   copy of the class variable and when any one object makes a change to a class variable, that change
   will be seen by all the other instances.

   Object variables are owned by each individual object/instance of the class. In this case, each object
   has its own copy of the field i.e. they are not shared and are not related in any way to the field by
   the same name in a different instance. An example will make this easy to understand (save as
   oop_objvar.py):
class Robot:
    """Represents a robot, with a name."""

    # A class variable, counting the number of robots
    population = 0

    def __init__(self, name):
        """Initializes the data."""
        self.name = name
        print("(Initializing {})".format(self.name))

        # When this person is created, the robot
        # adds to the population
        Robot.population += 1

    def die(self):
        """I am dying."""
        print("{} is being destroyed!".format(self.name))

        Robot.population -= 1

        if Robot.population == 0:
            print("{} was the last one.".format(self.name))
        else:
            print("There are still {:d} robots working.".format(
                Robot.population))

    def say_hi(self):
        """Greeting by the robot.

        Yeah, they can do that."""
        print("Greetings, my masters call me {}.".format(self.name))

    @classmethod
    def how_many(cls):
        """Prints the current population."""
        print("We have {:d} robots.".format(cls.population))


droid1 = Robot("R2-D2")
droid1.say_hi()
Robot.how_many()

droid2 = Robot("C-3PO")
droid2.say_hi()
Robot.how_many()

print("\nRobots can do some work here.\n")

print("Robots have finished their work. So letʼs destroy them.")
droid1.die()
droid2.die()

Robot.how_many()

   Output:
$ python oop_objvar.py
(Initializing R2-D2)
Greetings, my masters call me R2-D2.
We have 1 robots.
(Initializing C-3PO)
Greetings, my masters call me C-3PO.
We have 2 robots.

Robots can do some work here.

Robots have finished their work. So letʼs destroy them.
R2-D2 is being destroyed!
There are still 1 robots working.
C-3PO is being destroyed!
C-3PO was the last one.
We have 0 robots.

   How It Works
   This is a long example but helps demonstrate the nature of class and object variables. Here,
   population belongs to the Robot class and hence is a class variable. The name variable belongs to the
   object (it is assigned using self) and hence is an object variable.

   Thus, we refer to the population class variable as Robot.population and not as self.population. We
   refer to the object variable name using self.name notation in the methods of that object. Remember
   this simple difference between class and object variables. Also note that an object variable with the
   same name as a class variable will hide the class variable!

   Instead of Robot.population, we could have also used self.__class__.population because every object
   refers to its class via the self.__class__ attribute.

   The how_many is actually a method that belongs to the class and not to the object. This means we can
   define it as either a classmethod or a staticmethod depending on whether we need to know which class
   we are part of. Since we refer to a class variable, letʼs use classmethod.

   We have marked the how_many method as a class method using a [32]decorator.

   Decorators can be imagined to be a shortcut to calling a wrapper function, so applying the
   @classmethod decorator is same as calling:
how_many = classmethod(how_many)

   Observe that the __init__ method is used to initialize the Robot instance with a name. In this
   method, we increase the population count by 1 since we have one more robot being added. Also observe
   that the values of self.name is specific to each object which indicates the nature of object
   variables.

   Remember, that you must refer to the variables and methods of the same object using the self only.
   This is called an attribute reference.

   In this program, we also see the use of docstrings for classes as well as methods. We can access the
   class docstring at runtime using Robot.__doc__ and the method docstring as Robot.say_hi.__doc__

   In the die method, we simply decrease the Robot.population count by 1.

   All class members are public. One exception: If you use data members with names using the double
   underscore prefix such as __privatevar, Python uses name-mangling to effectively make it a private
   variable.

   Thus, the convention followed is that any variable that is to be used only within the class or object
   should begin with an underscore and all other names are public and can be used by other
   classes/objects. Remember that this is only a convention and is not enforced by Python (except for
   the double underscore prefix).

     Note for C++/Java/C# Programmers

     All class members (including the data members) are public and all the methods are virtual in
     Python.

Inheritance
   One of the major benefits of object oriented programming is reuse of code and one of the ways this is
   achieved is through the inheritance mechanism. Inheritance can be best imagined as implementing a
   type and subtype relationship between classes.

   Suppose you want to write a program which has to keep track of the teachers and students in a
   college. They have some common characteristics such as name, age and address. They also have specific
   characteristics such as salary, courses and leaves for teachers and, marks and fees for students.

   You can create two independent classes for each type and process them but adding a new common
   characteristic would mean adding to both of these independent classes. This quickly becomes unwieldy.

   A better way would be to create a common class called SchoolMember and then have the teacher and
   student classes inherit from this class i.e. they will become sub-types of this type (class) and then
   we can add specific characteristics to these sub-types.

   There are many advantages to this approach. If we add/change any functionality in SchoolMember, this
   is automatically reflected in the subtypes as well. For example, you can add a new ID card field for
   both teachers and students by simply adding it to the SchoolMember class. However, changes in the
   subtypes do not affect other subtypes. Another advantage is that if you can refer to a teacher or
   student object as a SchoolMember object which could be useful in some situations such as counting of
   the number of school members. This is called polymorphism where a sub-type can be substituted in any
   situation where a parent type is expected i.e. the object can be treated as an instance of the parent
   class.

   Also observe that we reuse the code of the parent class and we do not need to repeat it in the
   different classes as we would have had to in case we had used independent classes.

   The SchoolMember class in this situation is known as the base class or the superclass. The Teacher
   and Student classes are called the derived classes or subclasses.

   We will now see this example as a program (save as oop_subclass.py):
class SchoolMember:
    ʼʼʼRepresents any school member.ʼʼʼ
    def __init__(self, name, age):
        self.name = name
        self.age = age
        print(ʼ(Initialized SchoolMember: {})ʼ.format(self.name))

    def tell(self):
        ʼʼʼTell my details.ʼʼʼ
        print(ʼName:"{}" Age:"{}"ʼ.format(self.name, self.age), end=" ")


class Teacher(SchoolMember):
    ʼʼʼRepresents a teacher.ʼʼʼ
    def __init__(self, name, age, salary):
        SchoolMember.__init__(self, name, age)
        self.salary = salary
        print(ʼ(Initialized Teacher: {})ʼ.format(self.name))

    def tell(self):
        SchoolMember.tell(self)
        print(ʼSalary: "{:d}"ʼ.format(self.salary))


class Student(SchoolMember):
    ʼʼʼRepresents a student.ʼʼʼ
    def __init__(self, name, age, marks):
        SchoolMember.__init__(self, name, age)
        self.marks = marks
        print(ʼ(Initialized Student: {})ʼ.format(self.name))

    def tell(self):
        SchoolMember.tell(self)
        print(ʼMarks: "{:d}"ʼ.format(self.marks))

t = Teacher(ʼMrs. Shrividyaʼ, 40, 30000)
s = Student(ʼSwaroopʼ, 25, 75)

# prints a blank line
print()

members = [t, s]
for member in members:
    # Works for both Teachers and Students
    member.tell()

   Output:
$ python oop_subclass.py
(Initialized SchoolMember: Mrs. Shrividya)
(Initialized Teacher: Mrs. Shrividya)
(Initialized SchoolMember: Swaroop)
(Initialized Student: Swaroop)

Name:"Mrs. Shrividya" Age:"40" Salary: "30000"
Name:"Swaroop" Age:"25" Marks: "75"

   How It Works
   To use inheritance, we specify the base class names in a tuple following the class name in the class
   definition. Next, we observe that the __init__ method of the base class is explicitly called using
   the self variable so that we can initialize the base class part of the object. This is very important
   to remember - Since we are defining a __init__ method in Teacher and Student subclasses, Python does
   not automatically call the constructor of the base class SchoolMember, you have to explicitly call it
   yourself.

   In contrast, if we have not defined an __init__ method in a subclass, Python will call the
   constructor of the base class automatically.

   We also observe that we can call methods of the base class by prefixing the class name to the method
   call and then pass in the self variable along with any arguments.

   Notice that we can treat instances of Teacher or Student as just instances of the SchoolMember when
   we use the tell method of the SchoolMember class.

   Also, observe that the tell method of the subtype is called and not the tell method of the
   SchoolMember class. One way to understand this is that Python always starts looking for methods in
   the actual type, which in this case it does. If it could not find the method, it starts looking at
   the methods belonging to its base classes one by one in the order they are specified in the tuple in
   the class definition.

   A note on terminology - if more than one class is listed in the inheritance tuple, then it is called
   multiple inheritance.

   The end parameter is used in the print function in the superclassʼs tell() method to print a line and
   allow the next print to continue on the same line. This is a trick to make print not print a \n
   (newline) symbol at the end of the printing.

Summary
   We have now explored the various aspects of classes and objects as well as the various terminologies
   associated with it. We have also seen the benefits and pitfalls of object-oriented programming.
   Python is highly object-oriented and understanding these concepts carefully will help you a lot in
   the long run.


---
http://anandology.com/python-practice-book/object_oriented_programming.html

4. Object Oriented Programming

4.1. State
   Suppose we want to model a bank account with support for deposit and withdraw operations. One way to
   do that is by using global state as shown in the following example.
balance = 0

def deposit(amount):
    global balance
    balance += amount
    return balance

def withdraw(amount):
    global balance
    balance -= amount
    return balance

   The above example is good enough only if we want to have just a single account. Things start getting
   complicated if want to model multiple accounts.

   We can solve the problem by making the state local, probably by using a dictionary to store the
   state.
def make_account():
    return {'balance': 0}

def deposit(account, amount):
    account['balance'] += amount
    return account['balance']

def withdraw(account, amount):
    account['balance'] -= amount
    return account['balance']

   With this it is possible to work with multiple accounts at the same time.
>>> a = make_account()
>>> b = make_account()
>>> deposit(a, 100)
100
>>> deposit(b, 50)
50
>>> withdraw(b, 10)
40
>>> withdraw(a, 10)
90

4.2. Classes and Objects
class BankAccount:
    def __init__(self):
        self.balance = 0

    def withdraw(self, amount):
        self.balance -= amount
        return self.balance

    def deposit(self, amount):
        self.balance += amount
        return self.balance

>>> a = BankAccount()
>>> b = BankAccount()
>>> a.deposit(100)
100
>>> b.deposit(50)
50
>>> b.withdraw(10)
40
>>> a.withdraw(10)
90

4.3. Inheritance
   Let us try to create a little more sophisticated account type where the account holder has to
   maintain a pre-determined minimum balance.
class MinimumBalanceAccount(BankAccount):
    def __init__(self, minimum_balance):
        BankAccount.__init__(self)
        self.minimum_balance = minimum_balance

    def withdraw(self, amount):
        if self.balance - amount < self.minimum_balance:
            print 'Sorry, minimum balance must be maintained.'
        else:
            BankAccount.withdraw(self, amount)

   Problem 1: What will the output of the following program.
class A:
    def f(self):
        return self.g()

    def g(self):
        return 'A'

class B(A):
    def g(self):
        return 'B'

a = A()
b = B()
print a.f(), b.f()
print a.g(), b.g()

   Example: Drawing Shapes
class Canvas:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.data = [[' '] * width for i in range(height)]

    def setpixel(self, row, col):
        self.data[row][col] = '*'

    def getpixel(self, row, col):
        return self.data[row][col]

    def display(self):
        print "\n".join(["".join(row) for row in self.data])

class Shape:
    def paint(self, canvas): pass

class Rectangle(Shape):
    def __init__(self, x, y, w, h):
        self.x = x
        self.y = y
        self.w = w
        self.h = h

    def hline(self, x, y, w):
        pass

    def vline(self, x, y, h):
        pass

    def paint(self, canvas):
        hline(self.x, self.y, self.w)
        hline(self.x, self.y + self.h, self.w)
        vline(self.x, self.y, self.h)
        vline(self.x + self.w, self.y, self.h)

class Square(Rectangle):
    def __init__(self, x, y, size):
        Rectangle.__init__(self, x, y, size, size)

class CompoundShape(Shape):
    def __init__(self, shapes):
        self.shapes = shapes

    def paint(self, canvas):
        for s in self.shapes:
            s.paint(canvas)

4.4. Special Class Methods
   In Python, a class can implement certain operations that are invoked by special syntax (such as
   arithmetic operations or subscripting and slicing) by defining methods with special names. This is
   Python’s approach to operator overloading, allowing classes to define their own behavior with respect
   to language operators.

   For example, the + operator invokes __add__ method.
>>> a, b = 1, 2
>>> a + b
3
>>> a.__add__(b)
3

   Just like __add__ is called for + operator, __sub__, __mul__ and __div__ methods are called for -, *,
   and / operators.

   Example: Rational Numbers

   Suppose we want to do arithmetic with rational numbers. We want to be able to add, subtract,
   multiply, and divide them and to test whether two rational numbers are equal.

   We can add, subtract, multiply, divide, and test equality by using the following relations:
n1/d1 + n2/d2 = (n1*d2 + n2*d1)/(d1*d2)
n1/d1 - n2/d2 = (n1*d2 - n2*d1)/(d1*d2)
n1/d1 * n2/d2 = (n1*n2)/(d1*d2)
(n1/d1) / (n2/d2) = (n1*d2)/(d1*n2)

n1/d1 == n2/d2 if and only if n1*d2 == n2*d1

   Lets write the rational number class.
class RationalNumber:
    """
    Rational Numbers with support for arthmetic operations.

        >>> a = RationalNumber(1, 2)
        >>> b = RationalNumber(1, 3)
        >>> a + b
        5/6
        >>> a - b
        1/6
        >>> a * b
        1/6
        >>> a/b
        3/2
    """
    def __init__(self, numerator, denominator=1):
        self.n = numerator
        self.d = denominator

    def __add__(self, other):
        if not isinstance(other, RationalNumber):
            other = RationalNumber(other)

        n = self.n * other.d + self.d * other.n
        d = self.d * other.d
        return RationalNumber(n, d)

    def __sub__(self, other):
        if not isinstance(other, RationalNumber):
            other = RationalNumber(other)

        n1, d1 = self.n, self.d
        n2, d2 = other.n, other.d
        return RationalNumber(n1*d2 - n2*d1, d1*d2)

    def __mul__(self, other):
        if not isinstance(other, RationalNumber):
            other = RationalNumber(other)

        n1, d1 = self.n, self.d
        n2, d2 = other.n, other.d
        return RationalNumber(n1*n2, d1*d2)

    def __div__(self, other):
        if not isinstance(other, RationalNumber):
            other = RationalNumber(other)

        n1, d1 = self.n, self.d
        n2, d2 = other.n, other.d
        return RationalNumber(n1*d2, d1*n2)

    def __str__(self):
        return "%s/%s" % (self.n, self.d)

    __repr__ = __str__

4.5. Errors and Exceptions
   We’ve already seen exceptions in various places. Python gives NameError when we try to use a variable
   that is not defined.
>>> foo
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'foo' is not defined

   try adding a string to an integer:
>>> "foo" + 2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: cannot concatenate 'str' and 'int' objects

   try dividing a number by 0:
>>> 2/0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero

   or, try opening a file that is not there:
>>> open("not-there.txt")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IOError: [Errno 2] No such file or directory: 'not-there.txt'

   Python raises exception in case errors. We can write programs to handle such errors. We too can raise
   exceptions when an error case in encountered.

   Exceptions are handled by using the try-except statements.
def main():
    filename = sys.argv[1]
    try:
        for row in parse_csv(filename):
            print row
    except IOError:
        print >> sys.stderr, "The given file doesn't exist: ", filename
        sys.exit(1)

   This above example prints an error message and exits with an error status when an IOError is
   encountered.

   The except statement can be written in multiple ways:
# catch all exceptions
try:
    ...
except:

# catch just one exception
try:
    ...
except IOError:
    ...

# catch one exception, but provide the exception object
try:
    ...
except IOError, e:
    ...

# catch more than one exception
try:
    ...
except (IOError, ValueError), e:
    ...

   It is possible to have more than one except statements with one try.
try:
    ...
except IOError, e:
    print >> sys.stderr, "Unable to open the file (%s): %s" % (str(e), filename)
    sys.exit(1)
except FormatError, e:
    print >> sys.stderr, "File is badly formatted (%s): %s" % (str(e), filename)

   The try statement can have an optional else clause, which is executed only if no exception is raised
   in the try-block.
try:
    ...
except IOError, e:
    print >> sys.stderr, "Unable to open the file (%s): %s" % (str(e), filename)
    sys.exit(1)
else:
    print "successfully opened the file", filename

   There can be an optional else clause with a try statement, which is executed irrespective of whether
   or not exception has occured.
try:
    ...
except IOError, e:
    print >> sys.stderr, "Unable to open the file (%s): %s" % (str(e), filename)
    sys.exit(1)
finally:
    delete_temp_files()

   Exception is raised using the raised keyword.
raise Exception("error message")

   All the exceptions are extended from the built-in Exception class.

   class ParseError(Exception):
          pass

   Problem 2: What will be the output of the following program?
try:
    print "a"
except:
    print "b"
else:
    print "c"
finally:
    print "d"

   Problem 3: What will be the output of the following program?
try:
    print "a"
    raise Exception("doom")
except:
    print "b"
else:
    print "c"
finally:
    print "d"

   Problem 4: What will be the output of the following program?
def f():
    try:
        print "a"
        return
    except:
        print "b"
    else:
        print "c"
    finally:
        print "d"

f()



---
http://zetcode.com/lang/python/oop/

Object-oriented programming in Python

   In this part of the Python tutorial, we talk about object-oriented programming in Python.

   There are three widely used programming paradigms there: procedural programming, functional
   programming, and object-oriented programming. Python supports all three programming paradigms.

Object-oriented programming
   Object-oriented programming (OOP) is a programming paradigm that uses objects and their interactions
   to design applications and computer programs.

   There are some basic programming concepts in OOP:
     * Abstraction
     * Polymorphism
     * Encapsulation
     * Inheritance

   The abstraction is simplifying complex reality by modeling classes appropriate to the problem. The
   polymorphism is the process of using an operator or function in different ways for different data
   input. The encapsulation hides the implementation details of a class from other objects. The
   inheritance is a way to form new classes using classes that have already been defined.

Python objects
   Everything in Python is an object. Objects are basic building blocks of a Python OOP program.
   object_types.py
#!/usr/bin/python3

# object_types.py

import sys

def function():
    pass

print(type(1))
print(type(""))
print(type([]))
print(type({}))
print(type(()))
print(type(object))
print(type(function))
print(type(sys))

   In this example we show that all these entities are in fact objects. The type() function returns the
   type of the object specified.
$ ./object_types.py
<class 'int'>
<class 'str'>
<class 'list'>
<class 'dict'>
<class 'tuple'>
<class 'type'>
<class 'function'>
<class 'module'>

   Integers, strings, lists, dictionaries, tuples, functions, and modules are Python objects.

The class keyword
   The previous objects were all built-in objects of the Python programming language. The user defined
   objects are created using the class keyword. The class is a blueprint that defines a nature of a
   future object. From classes we construct instances. An instance is a specific object created from a
   particular class. For example, Huck might be an instance of a Dog class.
   first_object.py
#!/usr/bin/python3

# first_object.py

class First():
    pass

fr = First()

print(type(fr))
print(type(First))

   This is our first class. The body of the class is left empty for now. It is a convention to give
   classes a name that starts with a capital letter.
class First():
    pass

   Here we define the First class. Note that by default, all classes inherit from the base object.
fr = First()

   Here we create a new instance of the First class. Or in other words, we instantiate the First class.
   The fr is a reference to our new object.
$ ./first_object.py
<class '__main__.First'>
<class 'type'>

   Here we see that fr is an instance object of the First class.

   Inside a class, we can define attributes and methods. An attribute is a characteristic of an object.
   This can be for example a salary of an employee. A method defines operations that we can perform with
   our objects. A method might define a cancellation of an account. Technically, attributes are
   variables and methods are functions defined inside a class.

Object initialization
   A special method called __init__() is used to initialize an object.
   object_initialization.py
#!/usr/bin/python3

# object_initialization.py

class Being():

    def __init__(self):
        print("Being is initialized")

Being()

   We have a Being class. The special method __init__() is called automatically right after the object
   has been created.
$ ./object_initialization.py
Being is initialized

   This is the example output.

Attributes
   Attributes are characteristics of an object. Attributes are set in the __init__() method.
   attributes.py
#!/usr/bin/python3

# attributes.py

class Cat():

    def __init__(self, name):

        self.name = name

missy = Cat('Missy')
lucky = Cat('Lucky')

print(missy.name)
print(lucky.name)

   In this code example, we have a Cat class. The special method __init__() is called automatically
   right after the object has been created.
def __init__(self, name):

   Each method in a class definition begins with a reference to the instance object. It is by convention
   named self. There is nothing special about the self name. We could name it this, for example. The
   second parameter, name, is the argument. The value is passed during the class initialization.
self.name = name

   Here we pass an attribute to an instance object.
missy = Cat('Missy')
lucky = Cat('Lucky')

   Here we create two objects: cats Missy and Lucky. The number of arguments must correspond to the
   __init__() method of the class definition. The 'Missy' and 'Lucky' strings become the name parameter
   of the __init__() method.
print(missy.name)
print(lucky.name)

   Here we print the attributes of the two cat objects. Each instance of a class can have their own
   attributes.
$ ./attributes.py
Missy
Lucky

   The attributes can be assigned dynamically, not just during initialization. This is demonstrated by
   the next example.
   attributes_dynamic.py
#!/usr/bin/python3

# attributes_dynamic.py

class Person():
    pass

p = Person()
p.age = 24
p.name = "Peter"

print("{0} is {1} years old".format(p.name, p.age))

   We define and create an empty Person class.
p.age = 24
p.name = "Peter"

   Here we create two attributes dynamically: age and name.
$ ./attributes_dynamic.py
24 is Peter years old

Class attributes
   So far, we have been talking about instance attributes. In Python there are also so called class
   object attributes. Class object attributes are same for all instances of a class.
   class_attribute.py
#!/usr/bin/python3

# class_attribute.py

class Cat:
    species = 'mammal'

    def __init__(self, name, age):

        self.name = name
        self.age = age


missy = Cat('Missy', 3)
lucky = Cat('Lucky', 5)

print(missy.name, missy.age)
print(lucky.name, lucky.age)

print(Cat.species)
print(missy.__class__.species)
print(lucky.__class__.species)

   In our example, we have two cats with specific name and age attributes. Both cats share some
   characteristics. Missy and Lucky are both mammals. This is reflected in a class level attribute
   species. The attribute is defined outside any method name in the body of a class.
print(Cat.species)
print(missy.__class__.species)

   There are two ways how we can access the class object attributes: either via the name of the Cat
   class, or with the help of a special __class__ attribute.
$ ./class_attribute.py
Missy 3
Lucky 5
mammal
mammal
mammal

Methods
   Methods are functions defined inside the body of a class. They are used to perform operations with
   the attributes of our objects. Methods are essential in the encapsulation concept of the OOP
   paradigm. For example, we might have a connect() method in our AccessDatabase class. We need not to
   be informed how exactly the method connect connects to the database. We only know that it is used to
   connect to a database. This is essential in dividing responsibilities in programming, especially in
   large applications.
   methods.py
#!/usr/bin/python3

# methods.py

class Circle():

    pi = 3.141592

    def __init__(self, radius=1):
        self.radius = radius

    def area(self):
        return self.radius * self.radius * Circle.pi

    def setRadius(self, radius):
        self.radius = radius

    def getRadius(self):
        return self.radius


c = Circle()

c.setRadius(5)
print(c.getRadius())
print(c.area())

   In the code example, we have a Circle class. We define three new methods.
def area(self):
    return self.radius * self.radius * Circle.pi

   The area() method returns the area of a circle.
def setRadius(self, radius):
    self.radius = radius

   The setRadius() method sets a new value for the radius attribute.
def getRadius(self):
    return self.radius

   The getRadius() method returns the current radius.
c.setRadius(5)

   The method is called on an instance object. The c object is paired with the self parameter of the
   class definition. The number 5 is paired with the radius parameter.
$ ./methods.py
5
78.5398

   In Python, we can call methods in two ways. There are bounded and unbounded method calls.
   bound_unbound_methods.py
#!/usr/bin/python3

# bound_unbound_methods.py

class Methods():

    def __init__(self):
        self.name = 'Methods'

    def getName(self):
        return self.name


m = Methods()

print(m.getName())
print(Methods.getName(m))

   In this example, we demostrate both method calls.
print(m.getName())

   This is the bounded method call. The Python interpreter automatically pairs the m instance with the
   self parameter.
print(Methods.getName(m))

   And this is the unbounded method call. The instance object is explicitly given to the getName()
   method.
$ ./bound_unbound_methods.py
Methods
Methods

Inheritance
   Inheritance is a way to form new classes using classes that have already been defined. The newly
   formed classes are called derived classes, the classes that we derive from are called base classes.
   Important benefits of inheritance are code reuse and reduction of complexity of a program. The
   derived classes (descendants) override or extend the functionality of base classes (ancestors).
   inheritance.py
#!/usr/bin/python3

# inheritance.py

class Animal:

    def __init__(self):
        print("Animal created")

    def whoAmI(self):
        print("Animal")

    def eat(self):
        print("Eating")


class Dog(Animal):

    def __init__(self):
        super().__init__()

        print("Dog created")

    def whoAmI(self):
        print("Dog")

    def bark(self):
        print("Woof!")

d = Dog()
d.whoAmI()
d.eat()
d.bark()

   In this example, we have two classes: Animal and Dog. The Animal is the base class, the Dog is the
   derived class. The derived class inherits the functionality of the base class. It is shown by the
   eat() method. The derived class modifies existing behaviour of the base class, shown by the whoAmI()
   method. Finally, the derived class extends the functionality of the base class, by defining a new
   bark() method.
class Dog(Animal):

    def __init__(self):
        super().__init__()

        print("Dog created")

   We put the ancestor classes in round brackets after the name of the descendant class. If the derived
   class provides its own __init__() method and we want to call the parent constructor, we have to
   explicitly call the base class __init__() method with the help of the super function.
$ ./inherit.py
Animal created
Dog created
Dog
Eating
Woof!

Polymorphism
   Polymorphism is the process of using an operator or function in different ways for different data
   input. In practical terms, polymorphism means that if class B inherits from class A, it doesn't have
   to inherit everything about class A; it can do some of the things that class A does differently.
   basic_polymorphism.py
#!/usr/bin/python3

# basic_polymorphism.py

a = "alfa"
b = (1, 2, 3, 4)
c = ['o', 'm', 'e', 'g', 'a']

print(a[2])
print(b[1])
print(c[3])

   Python uses polymorphism extensively in built-in types. Here we use the same indexing operator for
   three different data types.
$ ./basic_polymorphism.py
f
2
g

   Polymorphism is mostly used when dealing with inheritance.
   polymorphism.py
#!/usr/bin/python3

# polymorphism.py

class Animal:

   def __init__(self, name=''):

      self.name = name

   def talk(self):

      pass

class Cat(Animal):

   def talk(self):

      print("Meow!")

class Dog(Animal):

   def talk(self):

      print("Woof!")

a = Animal()
a.talk()

c = Cat("Missy")
c.talk()

d = Dog("Rocky")
d.talk()

   Here we have two species: a dog and a cat. Both are animals. The Dog class and the Cat class inherit
   the Animal class. They have a talk() method, which gives different output for them.
$ ./polymorphism.py
Meow!
Woof!

Special Methods
   Classes in Python programming language can implement certain operations with special method names.
   These methods are not called directly, but by a specific language syntax. This is similar to what is
   known as operator overloading in C++ or Ruby.
   special_methods.py
#!/usr/bin/python3

# special_methods.py

class Book():

    def __init__(self, title, author, pages):

        print("A book is created")

        self.title = title
        self.author = author
        self.pages = pages

    def __str__(self):

        return "Title:{0} , author:{1}, pages:{2} ".format(
            self.title, self.author, self.pages)

    def __len__(self):

        return self.pages

    def __del__(self):

        print("A book is destroyed")

book = Book("Inside Steve's Brain", "Leander Kahney", 304)

print(book)
print(len(book))
del book

   In our code example, we have a book class. Here we introduce four special methods: __init__(),
   __str__(), __len__() and __del__().
book = Book("Inside Steve's Brain", "Leander Kahney", 304)

   Here we call the __init__() method. The method creates a new instance of a Book class.
print(book)

   The print keyword calls the __str__() method. This method should return an informal string
   representation of an object.
print(len(book))

   The len() function invokes the __len__() method. In our case, we print the number of pages of our
   book.
del book

   The del keyword deletes an object. It invokes its __del__() method.

   In the next example we implement a vector class and demonstrate addition and substraction operations
   on it.
   vector.py
#!/usr/bin/python3

# vector.py

class Vector():

    def __init__(self, data):

        self.data = data

    def __str__(self):

        return repr(self.data)

    def __add__(self, other):

        data = []

        for j in range(len(self.data)):

            data.append(self.data[j] + other.data[j])

        return Vector(data)

    def __sub__(self, other):

        data = []

        for j in range(len(self.data)):

            data.append(self.data[j] - other.data[j])

        return Vector(data)


x = Vector([1, 2, 3])
y = Vector([3, 0, 2])

print(x + y)
print(y - x)

   The example presents __add__ and __sub__ methods.
def __add__(self, other):

    data = []

    for j in range(len(self.data)):

        data.append(self.data[j] + other.data[j])

    return Vector(data)

   Here we implement the addition operation of vectors. The __add__() method is called when we add two
   Vector objects with the + operator. Here we add each member of the respective vectors.
$ ./vector.py
[4, 2, 5]
[2, -2, -1]

   This is the output.
