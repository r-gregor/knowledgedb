filename: zig-howto-build-and-use-packages-multif-20250411.txt
https://mattfreire.blog/posts/how-to-build-and-use-zig-packages

How to build and use Zig packages
Saturday, November 11, 2023

   I've been using zig for a short period of time and one of the first things I wanted to do was install
   a package. Zig is a relatively new language and to my surprise had released the official package
   manager quite recently. There are some tutorials and references that helped me understand how this
   all works but I wanted to make this as simple as possible for someone new to zig. It wouldn't be a
   complete video without referencing articles from [**1]Ed Yu. These were very helpful to get an
   introduction to the concepts. But sometimes the best way to learn is to go and do it yourself.

   In this article I'll walk through two things:
     * How to build a package
     * And then, how to install a package, or rather, how to add a package as a dependency

How to build a package
   When it comes to building or writing your own package there are many different things you might want
   to include in your package. Things like:
     * code you've written (your library)
     * artifacts
     * static files

   I'm going to cover how to build a package that includes code you've written. The articles from Ed Yu
   cover how to include artifacts and static files.

Step 1 - Create a github repository
   Self explanatory

Step 2 - Create a zig project
   In a terminal run the zig command to create a starting project
$> zig init-exe

Step 3 - Write your code
   This is all up to you but for simplicity make sure you have a main.zig file as that is the file that
   will be included in the package. Of course, you can customise this but let's keep it simple.

Step 4 - Write a build.zig.zon file
   In your project base folder create a build.zig.zon file. The zig package manager will use this file
   to configure details about your package, such as the name, version and dependencies.

   The syntax is JSON-like:
.{
	.name = "my-package",
	.version = "0.0.1",
	.paths = .{""},
}

   Copy the above into your build.zig.zon file and update the name and version to match your project.

Step 5 - Write a build.zig file
   The build.zig file will include your code as a module in the build

const std = @import("std");

pub fn build(b: *std.Build) !void {
	const target = b.standardTargetOptions(.{});
	const optimize = b.standardOptimizeOption(.{});

	const dep_opts = .{ .target = target, .optimize = optimize };
	_ = dep_opts;

	_ = b.addModule("zig-llm", .{
			.source_file = .{ .path = "src/main.zig" },
			.dependencies = &.{},
		});
}

   Notice here that the source file is src/main.zig. This is the file that will be included in the
   package. If you change the name of this file you will need to update the build.zig file to match.

Step 6 - Build your package
   In a terminal run the following command to build your package
$> zig build

   If your build outputs an error, check the previous steps to make sure you've followed them correctly.

Step 6 - Push your changes and make a release
   Push your changes to github and create a release. This will be the version of your package that you
   can use in other projects.

   On Github you can create a release by going to the releases screen from your repository.

   Then click the "Create a new release" button. On the next screen you can enter a new name for your
   release. In this example I'm creating a new version v0.0.4:

   Congratulations! You've created a package. Now let's see how to use it.

Step 7 - Use your package
   Now that you've created a release you can use your package in other projects. In this example I'm
   going to create a new project and add my package as a dependency.

Step 7.1 - Create a new project
   In a terminal run the zig command to create a starting project
$> zig init-exe

Step 7.2 - Add your package as a dependency
   In your project base folder create a build.zig.zon file. This time we will specify the dependency of
   our package.

   Ed Yu greatly points out that the easiest way to get the hash of your package is to set the hash
   value as a random hash value and then run the zig build command. Zig will complain that the hash is
   incorrect and will output the correct hash. You can then copy the correct hash into your
   build.zig.zon file.

   To make it easier for your users, you could include the hash in the README file of your package.

   Here's an example using my package ZigLLM as a dependency:

.{
	.name = "zig-example-use",
	.version = "0.0.1",
	.dependencies = .{
		.zig_llm = .{
			// the url to the release of the module
			.url = "https://github.com/mattfreire/zig-llm/archive/refs/tags/v0.0.3.tar.gz",
			.hash = "1220145cd26ccbbf94dd8c23c4d66acc4fbf56cec2c876592000732ce6b7481278b9",
		},
	},
	.paths = .{""},
}

   Now run the zig build command and you should see a quick log of the package being downloaded and
   built. If the build step fails then zig should tell you that it's because of the hash or URL being
   incorrect.

   Once it builds successfully you can then move to the next step.

Step 7.3 - Add the dependency as a module
   Now that you've confirmed your package is being found and downloaded you can add it as a module in
   your build.zig file.

   I'll continue with ZigLLm as an example for completeness. In your build.zig file add the following:

const std = @import("std");

// Although this function looks imperative, note that its job is to
// declaratively construct a build graph that will be executed by an external
// runner.
pub fn build(b: *std.Build) void {
	// Standard target options allows the person running `zig build` to choose
	// what target to build for. Here we do not override the defaults, which
	// means any target is allowed, and the default is native. Other options
	// for restricting supported target set are available.
	const target = b.standardTargetOptions(.{});

	// Standard optimization options allow the person running `zig build` to select
	// between Debug, ReleaseSafe, ReleaseFast, and ReleaseSmall. Here we do not
	// set a preferred release mode, allowing the user to decide how to optimize.
	const optimize = b.standardOptimizeOption(.{});

	const exe = b.addExecutable(.{
		.name = "example",
		// In this case the main source file is merely a path, however, in more
		// complicated build scripts, this could be a generated file.
		.root_source_file = .{ .path = "src/main.zig" },
		.target = target,
		.optimize = optimize,
	});

	//
	//
	// Adding this section
	//
	//
	// using zig-llm as a dependency
	const zig_llm = b.dependency("zig_llm", .{
		.target = target,
		.optimize = optimize,
	});
	// adding it as a module
	exe.addModule("zig-llm", zig_llm.module("zig-llm"));
	//
	//
	//
	//
	//

	// This declares intent for the executable to be installed into the
	// standard location when the user invokes the "install" step (the default
	// step when running `zig build`).
	b.installArtifact(exe);

	// This *creates* a Run step in the build graph, to be executed when another
	// step is evaluated that depends on it. The next line below will establish
	// such a dependency.
	const run_cmd = b.addRunArtifact(exe);

	// By making the run step depend on the install step, it will be run from the
	// installation directory rather than directly from within the cache directory.
	// This is not necessary, however, if the application depends on other installed
	// files, this ensures they will be present and in the expected location.
	run_cmd.step.dependOn(b.getInstallStep());

	// This allows the user to pass arguments to the application in the build
	// command itself, like this: `zig build run -- arg1 arg2 etc`
	if (b.args) |args| {
		run_cmd.addArgs(args);
	}

	// This creates a build step. It will be visible in the `zig build --help` menu,
	// and can be selected like this: `zig build run`
	// This will evaluate the `run` step rather than the default, which is "install".
	const run_step = b.step("run", "Run the app");
	run_step.dependOn(&run_cmd.step);

	// Creates a step for unit testing. This only builds the test executable
	// but does not run it.
	const unit_tests = b.addTest(.{
		.root_source_file = .{ .path = "src/main.zig" },
		.target = target,
		.optimize = optimize,
	});

	const run_unit_tests = b.addRunArtifact(unit_tests);

	// Similar to creating the run step earlier, this exposes a `test` step to
	// the `zig build --help` menu, providing a way for the user to request
	// running the unit tests.
	const test_step = b.step("test", "Run unit tests");
	test_step.dependOn(&run_unit_tests.step);
}

   In this build file we've added zig-llm as the name of the module for the zig_llm dependency defined
   in the build.zig.zon file.

   Now you can import the module in your src/main.zig file:

const std = @import("std");
const llm = @import("zig-llm");
const exit = std.os.exit;

pub fn main() !void {
	const alloc = std.heap.page_allocator;
	const env = try std.process.getEnvMap(alloc);

	const api_key = env.get("OPENAI_API_KEY");
	const organization_id = env.get("OPENAI_ORGANIZATION_ID");

	if (api_key == null or organization_id == null) {
		std.log.info("Please set your API key and Organization ID\n", .{});
		exit(1);
	}

	var openai = try llm.OpenAI.init(alloc, api_key.?, organization_id.?);
	defer openai.deinit();

	const models = try openai.get_models();
	std.debug.print("{}", .{models});

	const completion = try openai.completion("gpt-4", "Write a poem", 30, 1, false);
	for (completion.choices) |choice| {
		std.debug.print("Choice:\n {s}", .{choice.message.content});
	}
}

   And that's it! You've now created a package and used it as a dependency in another project.


---
[**1]
https://zig.news/edyu/zig-package-manager-wtf-is-zon-558e

Zig Package Manager - WTF is Zon
Jun.27.2023

Introduction
   Zig is a modern system programming language and although it claims to a be a better C, many
   people who initially didn't need system programming were attracted to it due to the simplicity of its
   syntax compared to alternatives such as C++ or Rust.

   However, due to the power of the language, some of the syntaxes are not obvious for those first
   coming into the language. I was actually one such person.

   Today we will take a break from the language itself to talk about one of the most important new
   features that was introduced recently in Zig -- the package manager. I've read somewhere that all
   modern languages need to have package manager built in. Although I don't share the same opinion, it's
   indicative of how important a good package manager is for the underlying language. For example,
   JavaScript has npm, Haskell has cabal, and Rust has cargo.

Disclaimer
   I've added a follow-up article WTF is Zig Package Manager 2. It goes over a better hack to make
   the package manager to work for my need.

   There is a reason why I changed my typical subtitle of power and complexity to hack and complexity
   for this particular article because unfortunately the Zig package manager is currently only on the
   master branch (or edge) and its a work-in-progress until 0.11 is released. As for the hack part, it
   will make sense after you read through the part of Provide a Package.

   The state of the release 0.11 as of June 2023 is in flux so you will encounter many bugs and problems
   along the way. I'm not writing this to discourage you from using it but to set the right expectation,
   so you don't throw away the baby (Zig) with the bath water (package manager).

   Zig along with its package manager is being constantly improved, and honestly, it's already very
   useful and usable even in the current state (despite the frustrations along with one of the hackiest
   things I've done, which I will describe later in the article).

   When you run zig build, you may see several failures (such as segmentation fault) when it's pulling
   down packages before it will succeed after several more tries. Although there is indication it's
   because of TLS but I don't want to give out wrong information that I haven't investigated myself.
~/w/z/my-wtf-project main* $> zig build
fish: Job 1, 'zig build' terminated by signal SIGSEGV (Address boundary error)
~/w/z/my-wtf-project main* 3.8s | 139 $> zig build
fish: Job 1, 'zig build' terminated by signal SIGSEGV (Address boundary error)
~/w/z/my-wtf-project main* 1.2s | 139 $> zig build
fish: Job 1, 'zig build' terminated by signal SIGSEGV (Address boundary error)
~/w/z/my-wtf-project main* 1.2s | 139 $> zig build
fish: Job 1, 'zig build' terminated by signal SIGSEGV (Address boundary error)
~/w/z/my-wtf-project main* 3s | 139 $> zig build
~/w/z/my-wtf-project main* 38s $> ls

Package Manager
   So, what's the purpose of the package manager? For a developer, the package manager is used to use
   other people's code easily. For example, say you need to use a new library, it's much easier to use
   the underlying package manager to add (either download and/or link to the library) the library and
   then somehow configure something in your project to magically link to the library for you to use it
   in your code.

Zig Package Manager(s)
   Zig had some other package managers in the past but now we have a built-in official package manager
   as part of version 0.11 (not released yet as of July, 2023).

   Interestingly, there are no additional commands to remember as the package manager is built into the
   language. Zig also does not have a global repository or a website that hosts the global repository
   such as npmjs does for Javascript or crates.io for Rust.

   So really, the Zig package manager is just same old zig build that you need to build your project
   anyways. There is nothing new you really need to use the package manager.

   There is however a new file-type with the extension .zon and a new file called build.zig.zon. zon
   stands for Zig Object Notation similar to how json stands for JavaScript Object Notation. It's mainly
   a way to describe hierarchical relationship such as dependencies needed in the project.

   In order to use a Zig package using the package manager, you'll need to do 3 things:
    1. Add your dependencies in build.zig.zon
    2. Incorporate your dependencies to your build process in build.zig
    3. Import your dependencies in your code using @import

build.zig.zon
   If you open up a zon file such as the following, you'll notice, it looks like a json file such as the
   typical package.json somewhat.

// because zon file is really just a zig struct
// comments are really done in the same way using 2 forward slashes
.{
	// the name of your project
	.name = "my-wtf-project",
	// the version of your project
	.version = "0.0.1",

	// the actual packages you need as dependencies of your project
	.dependencies = .{
		// the name of the package
		.zap = .{
			// the url to the release of the module
			.url = "https://github.com/zigzap/zap/archive/refs/tags/v0.1.7-pre.tar.gz",
			// the hash of the module, this is not the checksum of the tarball
			.hash = "1220002d24d73672fe8b1e39717c0671598acc8ec27b8af2e1caf623a4fd0ce0d1bd",
		},
	}
}

   There are several things of note here in the code above:
    1. The object looking curly braces are actually anonymous structs, if you don't know what structs
       are, you can think them as like an object. I briefly talked about structs in my previous article:
       Zig Union(Enum).
    2. The . in front of the curly braces are important as it denotes the struct as an anonymous struct.

     "For the purpose of zon, you can think of anonymous struct as a similar data format to json, but
     instead using Zig's struct literal syntax."

    3. The . in front of field names are also important because it conforms to the expected structure.
       In this particular struct, there is an expectation of three top level fields of name, version,
       and dependencies respectively.

dependencies
   To use a package that's been prepared for the new Zig package manager, you just need to list it in
   the dependencies section.

   In the previous example, I showed how to add Zap, a webserver, to your project by listing both
   the url of the release and the hash.

   The url is fairly easy to find as you can normally find it on github directly.

   However, the hash is difficult to find out because it's not just the md5sum, sha1sum, or even
   sha256sum of the tarball listed in url. The hash does use sha256 but it's not a direct hash of the
   tarball so it's not easily calculated by the user of the package.

   Luckily the easiest way I found is just to put any hash there initially and then zig build will
   complain and give you the correct hash. I know it's not ideal until all package author follows what
   Zap does by listing the hash in the release notes or the README.

   The dependencies section showing 2 packages:

	.dependencies = .{
		.zap = .{
			.url = "https://github.com/zigzap/zap/archive/refs/tags/v0.1.7-pre.tar.gz",
			.hash = "1220002d24d73672fe8b1e39717c0671598acc8ec27b8af2e1caf623a4fd0ce0d1bd",
		},
		.duck = .{
			.url = "https://github.com/beachglasslabs/duckdb.zig/archive/refs/tags/v0.0.1.tar.gz",
			.hash = "12207c44a5bc996bb969915a5091ca9b70e5bb0f9806827f2e3dd210c946e346a05e",
		}
	}

   Once you add your dependencies, zig buid would pull down your dependent packages as part of your
   project.

   But you may need to add the package in your build step as well. Zig is different in many languages
   that it minimizes a runtime so often you'll need to build and link your dependencies in your project.

Module
   In order to use the library exposed as a dependency, you have to expose the module of the dependency
   and add the module to the compile step.

   You can think of a module as the code that are exported by the library so that the caller of the
   package can import the library into the source code.

   In the next section, the code adds a module using a call to addModule(). The first argument is the
   name you want to use in your code so you can import the module. The second argument is where the code
   is located within the module in the dependency. In other words, you are aliasing a namespace (the 2nd
   argument) to a new name (1st argument).

build.zig
   Here is an example of the build.zig illustrating how to add the module duck in your project so that
   you can subsequently use the library by importing const duck = @import("duck");:

const std = @import("std");

pub fn build(b: *std.Build) !void {
	// these are boiler plate code until you know what you are doing
	// and you need to add additional options
	const target = b.standardTargetOptions(.{});
	const optimize = b.standardOptimizeOption(.{});

	// this is your own program
	const exe = b.addExecutable(.{
		// the name of your project
		.name = "my-wtf-project",
		// your main function
		.root_source_file = .{ .path = "testzon.zig" },
		// references the ones you declared above
		.target = target,
		.optimize = optimize,
	});

	// using duck as a dependency
	const duck = b.dependency("duck", .{
		.target = target,
		.optimize = optimize,
	});
	// duck has exported itself as duck
	// now you are re-exporting duck
	// as a module in your project with the name duck
	exe.addModule("duck", duck.module("duck"));
	// you need to link to the output of the build process
	// that was done by the duck package
	// in this case, duck is outputting a library
	// to which your project need to link as well
	exe.linkLibrary(duck.artifact("duck"));

	// now install your own executable after it's built correctly
	b.installArtifact(exe);
}

   What the code snippet above does is that it first declares your project as an executable and then
   pulls in duck as a dependency.

   The build.zig in the duck project already exported itself as the module duck but you are adding it
   again as a module with the same name duck.

   The linkLibrary call is the actual call to link to the output (Zig calls it artifact) of the duck
   module.

@import
   Now you have everything setup in your build, you need to use the new package in your code.

   All you need to do is to use the @import builtin to import your new library just like how you
   normally import the standard library @import(std).

const std = @import("std");
const DuckDb = @import("duck");

pub fn main() !void {
	// setup database
	var duck = try DuckDb.init(null);
	defer duck.deinit();
}

Provide a Package
   Ok, this is for those who would like to understand how the Zig package manager works as a
   library/package provider.

   To better illustrate things, I'll use a new package duckdb.zig that I wrote.

   DuckDb is a column-based SQL database so think it as basically a column-based SQLite.
   I will split the project into 3 packages A, B, and C. Basically the idea is that our project will be
   C that is the actual project that uses DuckDb. The project C will then use the Zig layer provided by
   package B, which in turn will need the actual DuckDb libraries in package A.

   So in our case, we have the project my-wtf-project, which will call the Zig library provided by
   duckdb.zig. The duckdb.zig is really a wrapper of libduckdb that provides the dynamic
   library of release 0.8.1 of DuckDb. To use the A, B, C in the previous paragraph, C is our
   project my-wtf-project, B is duckdb.zig, and A is libduckdb.

   Note: I will talk about the actual process of making a wrapper library in a future article.

A: libduckdb
   The duckdb is written in c++ and the libduckdb-linux-amd64 release from duckdb only provided 3 files:
   duckdb.h, duckdb.hpp, and libduckdb.so.

   I unzipped the package and placed duckdb.h under include directory and libduckdb.so under lib
   directory.

   Here are the first 3 hacks needed:
    1. You don't need to build anything, but the package manager expects to see a build.zig file in the
       package so you must provide one.
    2. Because you provided a build.zig, you need to provide some build artifact even if it's not
       needed.
    3. The most important part and the hackiest part is that you need to use the constructs used for
       header files to install the library.

build.zig.zon of A: libduckdb.
   This is probably the simplest build.zig.zon as you don't need any dependencies.

   This should remind people of a very simple .cabal, cargo.toml, or package.json file.

// build.zig.zon
// there are no dependencies
// eventually, may want to list duckdb itself as a dependency
.{
	.name = "duckdb",
	.version = "0.8.1",
}

Artifact
   You'll see the word artifact used often in the build process. One way to grasp artifact is to think
   it as the output of the build. If you are building a shared library, the .so file is the artifact; a
   static library, the .a file is the artifact; and for an executable, the actual execuable is the
   artifact.

   When you have the artifact in the code (build.zig), you can then use the artifact object to pass in
   to other function calls that can extract parts of the artifact based on their individual need. For
   example, installLibraryHeaders() would take in the artifact object and install any header files
   installed as part of the artifact.

   In fact, this is something we will and we have to take advantage of in order to make our build work.

   In the code below, the executable .name = "my-wtf-project tells the build that my-wtf-project is the
   name of the artifact and the executable is the actual artifact.

pub fn build(b: *std.Build) !void {
	const target = b.standardTargetOptions(.{});
	const optimize = b.standardOptimizeOption(.{});

	const exe = b.addExecutable(.{
		.name = "my-wtf-project",
		.root_source_file = .{ .path = "testzon.zig" },
		.target = target,
		.optimize = optimize,
	});

	// see how exe is now referred as artifact
	b.installArtifact(exe);
}


build.zig of A: libduckdb.
   We are essentially building something we don't really need but we definitely need the installHeader
   calls because this is how we install the 2 files we need in our artifact: include/duckdb.h and
   lib/libduckdb.so.

   Note that we are building a library without specifying a source code anywhere. We however do need to
   at least link to something. In this case, we need to link to the libduckdb.so even though we don't
   need any symbols from it because the build process needs either a source file or a library to link
   to.

   Yes, we are using the installHeader to install a dynamic library because there is no alternative.

   We can use installLibFile to install the lib/libduckdb.so but as you'll see in package B, it won't
   work without using installHeader.

   The call to installHeader requires a source and destination arguments but the destination argument
   assumes relative path of the target header directory. Therefore, we need to use ../lib/libduckdb.so
   in order to install libduckdb.so under lib directory instead of the default include.

   The final call to installArtifact is the one that will be utilized by B to grab the 2 files needed as
   described next. It will in this case, create an artifact libduckdb.a that we don't really need. For
   us, the artifact contains 3 things, the duckdb.h, libduckdb.so, and libduckdb.a. We only need the
   first two and libduckdb.a really is a side-effect of the artifact that we can toss away later in B.

   You can say we only need the bath water, not the baby. (Sorry for the bad jokes but I can't help
   myself.)

const std = @import("std");

pub fn build(b: *std.Build) !void {
	const target = b.standardTargetOptions(.{});
	const optimize = b.standardOptimizeOption(.{});

	var libduckdb_module = b.createModule(.{
		.source_file = .{
			.path = "lib/libduckdb.so"
		}
	});

	try b.modules.put(b.dupe("libduckdb"), libduckdb_module);

	// We don't need this static library
	// but a build process is required
	// in order to use the artifact
	// the artifact is named by the .name field
	// in this case it's called 'duckdb'
	// notice there is no reference to a source file
	const lib = b.addStaticLibrary(.{
		.name = "duckdb",
		.target = target,
		.optimize = optimize,
	});

	// point to the library path
	lib.addIncludePath("include");
	// point to the library path so we can find the system library
	// we need this to find the libduckdb.so
	lib.addLibraryPath(.{ path = "lib" });
	// this means to link to libduckdb.so in the lib directory
	// the call will prepend 'lib' and append '.so'
	lib.linkSystemLibraryName("duckdb");

	// HACK XXX hope zig fixes it
	// installHeader assumes include target directory
	// so we need to use '..' to go to the parent directory
	lib.installHeader("lib/libduckdb.so", "../lib/libduckdb.so");
	lib.installHeader("include/duckdb.h", "duckdb.h");

	b.installArtifact(lib);
}

B: duckdb.zig
   The duckdb.zig is a minimal (for now) Zig wrapper to duckdb. The idea is so that any Zig project
   depending on it doesn't have to deal with the C/C++ API just the Zig equivalent.

   We still need to perpetuate the hack by making sure libduckdb.so is part of the output artifact of
   duckdb.zig as well.

build.zig.zon of B: duckdb.zig
   We do have a dependency now as we need to refer to a release of A: libduckdb.

// build.zig.zon
// Now we depend on a release of A: libduckdb
.{
	// name of the package
	.name = "duck",
	// now we can version it to anything
	// as it's just the version of the zig wrapper
	.version = "0.0.1",

	.dependencies = .{
		// point to the name defined in libduckdb's build.zig.zon
		.duckdb = .{
			// the github release
			.url = "https://github.com/beachglasslabs/libduckdb/archive/refs/tags/v0.8.1.tar.gz",
			.hash = "1220f2fd60e07231291a44683a9297c1b42ed9adc9c681594ee21e0db06231bf4e07",
		}
	}
}

build.zig of B: duckdb.zig
   We now need to refer to the libduckdb (A) package using the name duckdb by making a call to
   Build.dependency("duckdb).

   We then name our module duck and add the module to Build with such name so that the build process can
   get the module by name if needed.

   Our own artifact is now named duck by calling Build.addStaticLibrary() with .name = "duck" in the
   anonymous struct.

   Although we call linkLibrary(duck_dep.artifact("duckdb")), the empty library created in libduckdb A
   doesn't actually resolve anything symbols because all the symbols are really in the dynamic library
   libduckdb.so.

   The most important part of the [DEL: hack :DEL] build is to call to installLibraryHeaders() because
   we want to once again include the output of the libduckdb artifact in our own artifact so that
   anything that depends on duckdb.zig would have access to both the duckdb.h and libduckdb.so from A.

const std = @import("std");

pub fn build(b: *std.Build) !void {
	const target = b.standardTargetOptions(.{});
	const optimize = b.standardOptimizeOption(.{});

	// we need to refer to the dependency in build.zig.zon
	const duck_dep = b.dependency("duckdb", .{
		.target = target,
		.optimize = optimize,
	});

	// we are creating our own module here
	var duck_module = b.createModule(.{
		.source_file = .{ .path = "src/main.zig" },
	});

	// we name the module duck which will be used later
	try b.modules.put(b.dupe("duck"), duck_module);

	// we are building a static library
	const lib = b.addStaticLibrary(.{
		// the output will be libduck.a
		.name = "duck",
		// the code to our wrapper library
		.root_source_file = .{ .path = "src/main.zig" },
		.target = target,
		.optimize = optimize,
	});

	// we link to the empty library in libduckdb
	// package that doesn't resolve any symbols
	// as these symbols are defined in libduckdb.so
	lib.linkLibrary(duck_dep.artifact("duckdb"));

	// we must use this hack again
	// to make sure include/duckdb.h and lib/libduckdb.so
	// are installed
	lib.installLibraryHeaders(duck_dep.artifact("duckdb"));
	// run the install to install the output artifact
	b.installArtifact(lib);
}

C: my-wtf-project
   Now to create the executable for our project, we need to link to the packages A libduckdb and B
   duckdb.zig.

build.zig.zon of C: my-wtf-project
   Our only dependency is the release of B: duckdb.zig.

   Notice that we do not need to refer to A (libduckdb) at all because B hides that from us.

// build.zig.zon
// Now we depend on a release of B: duckdb.zig
.{
	// this is the name of our own project
	.name = "my-wtf-project",
	// this is the version of our own project
	.version = "0.0.1",

	.dependencies = .{
		// we depend on the duck package described in B
		.duck = .{
			.url = "https://github.com/beachglasslabs/duckdb.zig/archive/refs/tags/v0.0.1.tar.gz",
			.hash = "12207c44a5bc996bb969915a5091ca9b70e5bb0f9806827f2e3dd210c946e346a05e",
		},
	},
}

build.zig of C: my-wtf-project
   This is somewhat similar to the build.zig of B (duckdb.zig).

   Although we never referred to A (libduckdb) at all in build.zig.zon, we do need to refer to the
   artifact of "duck" and install libduckdb.so from A (libduckdb) using the same [DEL: hack :DEL]
   call installLibraryHeaders(duck.artifact("duck")). However, We now refer to the library header as
   part of the artifact of B (duckdb.zig), not that of A (libduckdb).

   We also have to link to the library provided by B (duckdb.zig) because it actually includes the
   Zig wrapper functions we need in our code by calling linkLibrary(duck.artifact("duck")).

   If you look at the code below, you'll notice a curious use of std.fmt.allocPrint() that refers to
   something called Build.install_prefix. It's just a fancy way to refer to the output directory what
   typically defaults to zig-out. The reason is that our executable do need to find the symbols exposed
   by the dynamic library from A (libduckdb) for the linking process.

   We basically tell the build that to add zig-out/lib to find the libraries needed for linking and then
   link to libduckdb.so by calling linkSystemLibraryName("duckdb").

   Due to the latest change in Zig, we also now need to tell the build that libduckdb.so requires the
   libC by calling linkLibC.

   Afterwards, we just install the executable by calling 'Build.installArtifact()', which would install
   the executable to zig-out/bin just like how Zig normally does. Note that our artifact for our project
   is called "my-wtf-project" because we put that name in .name during our call to Build.addExecutable.

const std = @import("std");

pub fn build(b: *std.Build) !void {
	const target = b.standardTargetOptions(.{});

	const optimize = b.standardOptimizeOption(.{});

	const exe = b.addExecutable(.{
		// the name of our project artifact (executable)
		.name = "my-wtf-project",
		// we point to our project code
		.root_source_file = .{ .path = "testzon.zig" },
		.target = target,
		.optimize = optimize,
	});

	// we depends on duckdb.zig artifact
	// this is the name in build.zig.zon
	const duck = b.dependency("duck", .{
		.target = target,
		.optimize = optimize,
	});
	exe.installLibraryHeaders(duck.artifact("duck"));
	exe.addModule("duck", duck.module("duck"));
	exe.linkLibrary(duck.artifact("duck"));

	// install_prefix by default is "zig-out"
	const path = try std.fmt.allocPrint(b.allocator, "{s}/lib", .{b.install_prefix});
	defer b.allocator.free(path);
	// we need to somehow refer to the location of the libduckdb.so
	exe.addLibraryPath(.{ .path = path });
	exe.linkSystemLibraryName("duckdb");
	// libduckdb requires libC
	exe.linkLibC();

	// This declares intent for the executable to be installed into the
	// standard location when the user invokes the "install" step (the default
	// step when running `zig build`).
	b.installArtifact(exe);
}

Running the executable
   Note that in order to run our executable, we need to tell it where to find libduckdb.so.

   The easiest way I found is to invoke our exectable like LID_LIBRARY_PATH=zig-out/lib my-wtf-project.

~/w/z/wtf-zig-zon master* $> LD_LIBRARY_PATH=zig-out/lib zig-out/bin/my-wtf-project
duckdb: opened in-memory db
duckdb: db connected
duckdb: query sql select * from pragma_version();
Database version is v0.8.1


STOPPED!

Leaks detected: false

Bonus: Cache
   When the Zig package manager pulls down the packages, it saves them under .cache/zig. What it means
   is that once you have pulled down a package, you don't need network to pull down the same package
   again. However, there are times where the Zig package manager doesn't update/work properly, you'll
   need to delete the cache specific to your package and tell Zig to re-download the package.

   The following command will remove all the packages from your cache:

rm -rf ~/.cache/zig/*

The End
   There is a follow-up article
   [**2][https://zig.news/edyu/zig-package-manager-wtf-is-zon-2-0110-update-1jo3]WTF is Zig Package Manager 2.


---
[**2]
https://zig.news/edyu/zig-package-manager-wtf-is-zon-2-0110-update-1jo3

Zig Package Manager 2 - WTF is Build.Zig.Zon and Build.Zig (0.11.0 Update)
Oct.18.2023

Introduction
   Zig is a modern system programming language and although it claims to a be a better C, many
   people who initially didn't need system programming were attracted to it due to the simplicity of its
   syntax compared to alternatives such as C++ or Rust.

   However, due to the power of the language, some of the syntaxes are not obvious for those first
   coming into the language. I was actually one such person.

   Several months ago, when I first tried out the new Zig package manager, it was before Zig 0.11.0
   was officially released. Not only was the language unstable, but also the package manager itself was
   subject to a lot of stability issues especially with TLS. I had to hack together a system that worked
   for my need, and I documented my journey in Zig Package Manager - WTF is Zon.

   Since then I've had discussion of the Zig package manager with Andrew and various others through
   the Zig Discord, Ziggit, and even opened up a Github issue.

   Now that Zig has released 0.11.0 in August 2023, and many of the stability problems were resolved
   so I want to revisit my hack to see whether I can do a better hack.

   A special shoutout to my friend InKryption, who was tremendously helpful in my understanding of
   the package manager. I wouldn't be able to come up with this better hack without his help.

Disclaimer
   As I mentioned in my previous article, I changed my typical subtitle of power and complexity to
   hack and complexity because not only was Zig 0.11.0 (which first introduced the package manager)
   not released yet but also I had to do a pretty ugly hack to make it work.

   I just want to reiterate my stance on Zig and the package manager. I'm not writing this to discourage
   you from using it but to set the right expectation and hopefully help you in case you encounter
   similar issues.

   Zig along with its package manager is being constantly improved and I'm looking forward to the
   0.12.0 release.

   Today, I'll introduce a better hack than what I had to do in June, 2023 and ideally I can retire my
   hack after the 0.12.0 release.

   I'll most likely write a follow-up article once Zig 0.12.0 is released (hopefully) by the end of
   the year.

   I will not reiterate concepts introduced in Part 1, so please read that first if you find this
   article confusing.

Package (Manager) vs Binary Library
   One of my previous misunderstandings of the package manager was that I was using a Zig package as a
   library.

   Let's reuse the same example of C -> B -> A from Part 1
   in that our program C depended on package B, which in turn depended on package A.

   The way I was building the program C and packages B and A was that I was basically copying over
   everything package A produced to package B and then copied over both what package B produced and
   package A produced to program C as part of the build process. The thing that was produced is called
   an artifact in Zig package manager.

   That was not the correct way to use a package manager because one of the benefits of a package
   manager is that you only need to concern yourself with the packages you depended on directly without
   needing to care about the additional packages those direct packages depended on themselves.

   In the example of C -> B -> A, program C should only know/care about package B and not needing to
   care at all that package B needed package A internally because the package manager should have taken
   care of the transitive dependencies.

   In other words, package manager should have good enough encapsulation for packages so that the users
   need not care about packages not directly required by the main (their own) programs.

   As an example, despite many of the dependency problems, npm does a good job (probably too good a job)
   of encapsulation.

   It's so good that sometimes when you add 1 package, you might be surprised when npm automatically
   pulls down hundreds of packages because it would recursively download all depenencies.

   However, such clean encapsulation is not always possible when we are building native programs in Zig
   especially when shared libraries are involved.

Artifact vs Module
   In addition to artifacts, the Zig package manager also has the concept of a module but it is mainly
   referring to Zig source code and is primary used so that your program can import the Zig package as a
   library.

   A module is equivalent to a Zig library (source code) exposed by the package manager. A module is not
   useful when the binary library you depend on is not written in Zig.

   When building your program, you need access to the artifact produced by the dependency in order to
   access the specific items produced by such dependency.

   To summarize, if your package is written in Zig, then you can access the Zig code in such package as
   a module and you can access either the shared libarary, static library, or the executable produced by
   such package as artifacts. However, if your package is not written in Zig, then you need to do some
   additional work to expose the code/library as a module and expose the resulting items as part of the
   artifact.

   The main problem I had to deal with was that the Zig package manager resolved around the idea of an
   artifact which requires a Compile step that is involved with either a compilation and/or linking
   step. As stated earlier, an artifact is the stuff that was produced as part of the build process.
   Where this falls apart is when we need to package together items that do not require a build
   (Compile) step.

   Hence, the existing artifact conceptualization doesn't work well with when we have to deal with a
   package composed of an existing binary library such as a shared library that doesn't require any
   additional compilation or linking. Note that this can be the case even if you have the source code
   because you may not want to compile the source code yourself if the project releases binary packages
   as part of its releases.

The Problem
   I'll reintroduce the problem mentioned in Part 1.

   The scenario is quite common in projects that uses packages written in a different language from the
   main project:

   A: You often would need the shared or static library from the package written in another language compiled
      for your environment (such as Linux).
   B: You would also need to write a wrapper for such library in your native language.
   C: You then would write your program calling the functions provided by the wrapper B.

   Our concrete example has 3 packages A, B, and C. Our program my-wtf-project is in package C, which
   needs to use DuckDb for its database needs.

   The project C will use the Zig layer provided by package B, which in turn will need the actual
   DuckDb implementation provided by package A.

   For our my-wtf-project, our main program will call the Zig library provided by zig-duckdb. The
   zig-duckdb is just a Zig wrapper of libduckdb that provides the dynamic library of
   release 0.9.1 of DuckDb.

   To use the C -> B -> A example in the earlier section, program C is our project my-wtf-project,
   package B is zig-duckdb, and project A is libduckdb.

   Note that package B used to be called duckdb.zig but it has since been renamed to zig-duckdb.

The Hack in Part 1
   There are two hacks I had to do for the build.zig of package A(libduckdb),
   package B(zig-duckdb), and program C(my-wtf-project):
    1. In the build.zig of libduckdb, I had to create an artifact even if the libduckdb.so is a
       shared library that doesn't need additional compilation/linking by creating a new static library
       that is linked to libduckdb.so just so I can use the artifact in
       zig-duckdb.
    2. I had to use Build.installHeader to install both the duckdb.h and the libduckdb.so in all the
       build.zig to copy over these 2 files to zig-out/include and zig-out/lib respectively.

The New Hack
   I'm still calling this a hack because as stated, a module is mainly used to refer to Zig source code
   that can be used as a library to be imported by your program. Just like how a shared library is not
   meant to be installed via calls to install header files, a module is meant to be used to refer to
   individual artifacts in a package. However, this is exactly what I had to do.

   I believe this is better than how I was using Build.installHeader and Build.installLibraryHeader to
   install artifacts produced by dependencies.

   A big benefit of using the module to refer to non-Zig-produced artifacts is that we do not need to
   copy over artifacts from the dependencies anymore.

A: libduckdb
   The duckdb was written in c++ and the libduckdb-linux-amd64 release from duckdb only provided
   3 files: duckdb.h, duckdb.hpp, and libduckdb.so.

   I unzipped the package and placed duckdb.h under the include directory and libduckdb.so under the lib
   directory.

build.zig.zon of A: libduckdb
   Because libduckdb has no dependencies, the zon file is extremely simple.

   It just lists the name and the version. I've intentionally been using the actual version number of
   the underlying DuckDb.

// build.zig.zon
// there are no dependencies
.{
	// note that we don't have to call this libduckdb
	.name = "duckdb",
	.version = "0.9.1",
}

build.zig of A: libduckdb
   This is the first big change from Part 1. We are not building anymore fake artifact. We are only
   introducing some modules so that any package depending on this package can reference these items
   using the various module names. This is still a hack because technically these items are artifacts
   not modules but at least we don't have to compile a shared library that doesn't need to be compiled.

pub fn build(b: *std.Build) !void {
	_ = b.addModule("libduckdb.lib", .{ .source_file = .{ .path = b.pathFromRoot("lib") } });
	_ = b.addModule("libduckdb.include", .{ .source_file = .{ .path = b.pathFromRoot("include") } });
	_ = b.addModule("duckdb.h", .{ .source_file = .{ .path = b.pathFromRoot("include/duckdb.h") } });
	_ = b.addModule("libduckdb.so", .{ .source_file = .{ .path = b.pathFromRoot("lib/libduckdb.so") } });
}

   This will make more sense in the next sections.

B: zig-duckdb
   The zig-duckdb is still a minimal Zig wrapper to DuckDb. It suits my needs for now and the
   only changes added since last time are the ability to query for boolean and optional values.

   The big change is that we no longer need to install libduckdb.so or duckdb.h from libduckdb.

build.zig.zon of B: zig-duckdb
   We do have a dependency now as we need to refer to a release of A: libduckdb.

// build.zig.zon
// Now we depend on a release of A: libduckdb
.{
	.name = "duck",
	.version = "0.0.5",

	.dependencies = .{
		// this is the name you want to use in the build.zig to reference this dependency
		// note that we didn't have to call this libduckdb or even duckdb
		.duckdb = .{
			.url = "https://github.com/beachglasslabs/libduckdb/archive/refs/tags/v0.9.1.3.tar.gz",
			.hash = "1220e182337ada061ebf86df2a73bda40e605561554f9dfebd6d1cd486a86c964e09",
		},
	},
}

build.zig of B: zig-duckdb
   Note that we no longer install libduckdb.so or duckdb.h as part of the build process we previous had
   to do in Part 1.

   We do have to call addModule multiple times to expose not only the library libduck.a (the artifact of
   this package) itself but also re-export the modules provided by libduckdb.

   Note how we now call
   duck_dep.builder.pathFromRoot(duck_dep.module("libduckdb.include").source_file.path to access the
   include directory and
   duck_dep.builder.pathFromRoot(duck_dep.module("libduckdb.lib").source_file.path) to access the lib
   directory.

   You can think of this as equivalent of reaching inside of libduckdb to access these items and
   therefore we don't have to copy these items into our output directory anymore as we previously had to
   do with lib.installLibraryHeaders(duck_dep.artifact("duckdb")).

pub fn build(b: *std.Build) !void {
	const target = b.standardTargetOptions(.{});

	const optimize = b.standardOptimizeOption(.{});

	const duck_dep = b.dependency("duckdb", .{});

	// this is our main wrapper file
	_ = b.addModule("duck", .{
		.source_file = .{ .path = "src/main.zig" },
	});

	// (re-)add modules from libduckdb
	_ = b.addModule("libduckdb.include", .{
		.source_file = .{ .path = duck_dep.builder.pathFromRoot(
			duck_dep.module("libduckdb.include").source_file.path,
		) },
	});

	_ = b.addModule("libduckdb.lib", .{
		.source_file = .{ .path = duck_dep.builder.pathFromRoot(
			duck_dep.module("libduckdb.lib").source_file.path,
		) },
	});

	_ = b.addModule("duckdb.h", .{
		.source_file = .{ .path = duck_dep.builder.pathFromRoot(
			duck_dep.module("duckdb.h").source_file.path,
		) },
	});

	_ = b.addModule("libduckdb.so", .{
		.source_file = .{ .path = duck_dep.builder.pathFromRoot(
			duck_dep.module("libduckdb.so").source_file.path,
		) },
	});

	const lib = b.addStaticLibrary(.{
		.name = "duck",
		// In this case the main source file is merely a path, however, in more
		// complicated build scripts, this could be a generated file.
		.root_source_file = .{ .path = "src/main.zig" },
		.target = target,
		.optimize = optimize,
	});

	lib.addLibraryPath(.{ .path = duck_dep.builder.pathFromRoot(
		duck_dep.module("libduckdb.lib").source_file.path,
	) });
	lib.addIncludePath(.{ .path = duck_dep.builder.pathFromRoot(
		duck_dep.module("libduckdb.include").source_file.path,
	) });
	lib.linkSystemLibraryName("duckdb");

	b.installArtifact(lib);

}

   Note that if you really want to install libduckdb.so for example, you can do so with the following
   call:

_ = b.installLibFile(duck_dep.builder.pathFromRoot(
	duck_dep.module("libduckdb.so").source_file.path,
	), "libduckdb.so");

   If you look into the project, you will see that I introduced a new file called test.zig that was
   meant to test the new boolean and optional values.

   In order to run the test, I've added a new test step in build.zig:

	const unit_tests = b.addTest(.{
		.root_source_file = .{ .path = "src/test.zig" },
		.target = target,
		.optimize = optimize,
	});
	unit_tests.step.dependOn(b.getInstallStep());
	unit_tests.linkLibC();
	// note how I use modules to access these directories
	unit_tests.addLibraryPath(.{ .path = duck_dep.builder.pathFromRoot(
		duck_dep.module("libduckdb.lib").source_file.path,
	) });
	unit_tests.addIncludePath(.{ .path = duck_dep.builder.pathFromRoot(
		duck_dep.module("libduckdb.include").source_file.path,
	) });
	unit_tests.linkSystemLibraryName("duckdb");

	const run_unit_tests = b.addRunArtifact(unit_tests);
	run_unit_tests.setEnvironmentVariable("LD_LIBRARY_PATH", duck_dep.builder.pathFromRoot(
		duck_dep.module("libduckdb.lib").source_file.path,
	));

	const test_step = b.step("test", "Run unit tests");
	test_step.dependOn(&run_unit_tests.step);

   Once again, you can see that's why I've exposed the lib and include directories of libduckdb via
   module.
   I can now call addIncludePath and addLibraryPath by referencing their modules.

   Note the call to setEnvironmentVariable because -L is only useful for linking not for running the
   test/program. Hence you need to point to libduckdb.so using LD_LIBRARY_PATH and once again by
   accessing the location of the shared library inside the libduckdb package.

C: my-wtf-project
   Now to create the executable for our project, we need to link to the packages A libduckdb and B
   zig-duckdb.

build.zig.zon of C: my-wtf-project
   Our only dependency is the release of B: zig-duckdb.

// build.zig.zon
// Now we depend on a release of B: zig-duckdb
.{
	// this is the name of our own project
	.name = "my-wtf-project",
	// this is the version of our own project
	.version = "0.0.2",

	.dependencies = .{
		// we depend on the duck package described in B
		.duck = .{
			.url = "https://github.com/beachglasslabs/zig-duckdb/archive/refs/tags/v0.0.5.tar.gz",
			.hash = "12207c44a5bc996bb969915a5091ca9b70e5bb0f9806827f2e3dd210c946e346a05e",
		},
	},
}

build.zig of C: my-wtf-project
   This is somewhat similar to the build.zig of B (zig-duckdb).

   Note once again that we do not need to call installLibraryHeaders to install the libduckdb.so and
   duckdb.h anymore.

   I've also added setEnvironmentVariable to set LD_LIBRARY_PATH for running the test program.

pub fn build(b: *std.Build) !void {
	const target = b.standardTargetOptions(.{});

	const optimize = b.standardOptimizeOption(.{});

	const exe = b.addExecutable(.{
		.name = "my-wtf-project",
		.root_source_file = .{ .path = "testzon.zig" },
		.target = target,
		.optimize = optimize,
	});

	const duck = b.dependency("duck", .{
		.target = target,
		.optimize = optimize,
	});
	exe.addModule("duck", duck.module("duck"));
	exe.linkLibrary(duck.artifact("duck"));

	exe.addIncludePath(.{ .path = duck.builder.pathFromRoot(
		duck.module("libduckdb.include").source_file.path,
	) });
	exe.addLibraryPath(.{ .path = duck.builder.pathFromRoot(
		duck.module("libduckdb.lib").source_file.path,
	) });
	//	You'll get segmentation fault if you don't link with libC
	exe.linkLibC();
	exe.linkSystemLibraryName("duckdb");

	b.installArtifact(exe);

	const run_cmd = b.addRunArtifact(exe);

	run_cmd.step.dependOn(b.getInstallStep());

	// you must set the LD_LIBRARY_PATH to find libduckdb.so
	run_cmd.setEnvironmentVariable("LD_LIBRARY_PATH", duck.builder.pathFromRoot(
		duck.module("libduckdb.lib").source_file.path,
	));

	const run_step = b.step("run", "Run the test");
	run_step.dependOn(&run_cmd.step);
}

Running the executable
   You can now just call zig build run to run the test program because we already set LD_LIBRARY_PATH
   using setEnvironmentVariable in our build.zig.

 I	~/w/z/wtf-zig-zon-2 6m 10.7s $> zig build run
info: duckdb: opened in-memory db

info: duckdb: db connected

debug: duckdb: query sql select * from pragma_version();

Database version is v0.9.1


STOPPED!

Leaks detected: false
 I ~/w/z/wtf-zig-zon-2 4.1s $>

Bonus: Package Cache
   When I mentioned reaching inside the package, what happens behind the scene is that the package is in
   ~/.cache/zig so all these magic with module is really specifying the path to the particular packages
   under ~/.cache/zig.

   You can see more clearly what's going on if you add --verbose to your zig build or zig build
   commands.

 I ~/w/z/wtf-zig-zon-2 4.1s $> zig build run --verbose
/snap/zig/8241/zig build-lib \
/home/ed/.cache/zig/p/1220fe38df4d196b7aeca68ee6de3f7b36f1424196466038000f7485113cf704f478/src/main.zig \
-lduckdb --cache-dir /home/ed/ws/zig/wtf-zig-zon-2/zig-cache --global-cache-dir /home/ed/.cache/zig \
--name duck -static -target native-native -mcpu znver3-mwaitx-pku+shstk-wbnoinvd \
-I /home/ed/.cache/zig/p/1220e182337ada061ebf86df2a73bda40e605561554f9dfebd6d1cd486a86c964e09/include \
-L /home/ed/.cache/zig/p/1220e182337ada061ebf86df2a73bda40e605561554f9dfebd6d1cd486a86c964e09/lib \
--listen=-/snap/zig/8241/zig build-exe /home/ed/ws/zig/wtf-zig-zon-2/testzon.zig \
/home/ed/ws/zig/wtf-zig-zon-2/zig-cache/o/b893f00994b9c79eab2c150de991b233/libduck.a -lduckdb -lduckdb \
-lc --cache-dir /home/ed/ws/zig/wtf-zig-zon-2/zig-cache --global-cache-dir /home/ed/.cache/zig \
--name my-wtf-project --mod \
duck::/home/ed/.cache/zig/p/1220fe38df4d196b7aeca68ee6de3f7b36f1424196466038000f7485113cf704f478/src/main.zig
\--deps duck -I /home/ed/.cache/zig/p/1220e182337ada061ebf86df2a73bda40e605561554f9dfebd6d1cd486a86c964e09/include
\-L /home/ed/.cache/zig/p/1220e182337ada061ebf86df2a73bda40e605561554f9dfebd6d1cd486a86c964e09/lib \
--listen=-LD_LIBRARY_PATH=/home/ed/.cache/zig/p/1220e182337ada061ebf86df2a73bda40e605561554f9dfebd6d1cd486a86c964e09/lib/home/ed/ws/zig/wtf-zig-zon-2/zig-out/bin/my-wtf-project

info: duckdb: opened in-memory db

info: duckdb: db connected

debug: duckdb: query sql select * from pragma_version();

Database version is v0.9.1


STOPPED!

Leaks detected: false
 I ~/w/z/wtf-zig-zon-2 $>

The End


---

