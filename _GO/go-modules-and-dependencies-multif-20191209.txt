filename: go_modules-and-dependencies-multif_20191209.txt
https://www.bogotobogo.com/GoLang/GoLang_Modules_1_Creating_a_new_module.php

GoLang Tutorial - Modules 1 (Creating a new module)

   Introduction
   This post is an introduction to the basic operations needed to get started using modules.

   A module is a collection of Go packages stored in a file tree with a go.mod file at its root. The
   go.mod file defines the module's module path, which is also the import path used for the root
   directory, and its dependency requirements, which are the other modules needed for a successful
   build.

   Each dependency requirement is written as a module path and a specific semantic version.

   As of Go 1.12, the go command enables the use of modules when the current directory or any parent
   directory has a go.mod, provided the directory is outside $GOPATH/src. (Inside $GOPATH/src, for
   compatibility, the go command still runs in the old GOPATH mode, even if a go.mod is found.

   This post is using 1.12:
$> go version
go version go1.12.4 darwin/amd64

   Starting in Go 1.13, module mode will be the default for all development.
   Creating a new module

   Let's create a new module.

   First, we want to create a new, empty directory ($GOPATH/myModule) somewhere outside $GOPATH/src, cd
   into that directory, and then create a new source file, hello.go:
   hello-world-go.png

   We may also want to write a test, too, in hello_test.go:
   hello-test.png
myModule/
    +-- hello.go
    +-- hello_test.go

   At this point, the directory contains a package, but NOT a module, because there is no go.mod file.
$> go test
PASS
ok      _/Users/kihyuckhong/go/myModule 0.016s

   The last line of the output summarizes the overall package test.

   Because we are working outside $GOPATH and also outside any module, the go command knows no import
   path for the current directory and makes up a fake one based on the directory name:
   _/Users/kihyuckhong/go/myModule.

   Let's make the current directory the root of a module by using go mod init and then try go test
   again:
$> go mod init example.com/hello
go: creating new go.mod: module example.com/hello

.
+-- go.mod
+-- hello.go
+-- hello_test.go

   The go.mod file only appears in the root of the module.

   The go mod init command wrote a go.mod file:
$> cat go.mod
module example.com/hello

go 1.12

   Packages in subdirectories have import paths consisting of the module path plus the path to the
   subdirectory.

   For example, if we created a subdirectory world, we would not need to (nor want to) run go mod init
   there. The package would automatically be recognized as part of the example.com/hello module, with
   import path example.com/hello/world.



---
https://www.bogotobogo.com/GoLang/GoLang_Modules_2_Adding_and_Updating_Dependencies.php
encies)

   Adding Dependencies

   The primary purpose of Go modules was to improve the experience of using (that is, adding a
   dependency on) code written by other developers.

   Let's update our hello.go to import rsc.io/quote and use it to implement Hello:
   hello-go.png

   Now let's try the test again:
$> go test
PASS
ok      example.com/hello       0.012s

   Now, we have a new file called go.sum:
   go-sum.png
$> cat go.sum
golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZOaTkIIMiVjBQcw93ERBE4m30iBm00nkL0i8=
golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
rsc.io/quote v1.5.2 h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3Y=
rsc.io/quote v1.5.2/go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPXsUe+TKr0=
rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=
rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=

   The go command resolves imports by using the specific dependency module versions listed in go.mod:
$> cat go.mod
module example.com/hello

go 1.12

require rsc.io/quote v1.5.2

   When it encounters an import of a package not provided by any module in go.mod, the go command
   automatically looks up the module containing that package and adds it to go.mod, using the latest
   version.

   In our example, go test resolved the new import rsc.io/quote to the module rsc.io/quote v1.5.2. It
   also downloaded two dependencies used by rsc.io/quote, namely rsc.io/sampler and golang.org/x/text.

   Only direct dependencies are recorded in the go.mod file.

   The second go test command will not repeat this work, since the go.mod is now up-to-date and the
   downloaded modules are cached locally in $GOPATH/pkg/mod:
$> go test
PASS
ok      example.com/hello       0.009s

   Note that adding one direct dependency often brings in other indirect dependencies too. The command
   go list -m all lists the current module and all its dependencies:
$> go list -m all
example.com/hello
golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c
rsc.io/quote v1.5.2
rsc.io/sampler v1.3.0

   In the go list output, the current module, also known as the main module, is always the first line,
   followed by dependencies sorted by module path.

   The golang.org/x/text version v0.0.0-20170915032832-14c0d48ead0c is an example of a pseudo-version,
   which is the go command's version syntax for a specific untagged commit.

   In addition to go.mod, the go command maintains a file named go.sum as shown earlier, and it is
   containing the expected cryptographic hashes of the content of specific module versions.

   The go command uses the go.sum file to ensure that future downloads of these modules retrieve the
   same bits as the first download, to ensure the modules our project depends on do not change
   unexpectedly, whether for malicious, accidental, or other reasons.

   Both go.modand go.sum should be checked into version control.



---
https://deepsource.io/blog/go-modules/

Package management in Go

Brief overview of package management in Go pre and post Go modules

   Package management is one of the things Go has always missed. One of the major drawbacks of the
   previous (pre 1.11) go get was lack of support for managing dependency versions and enabling
   reproducible builds. The community has developed package managers and tools like Glide, dep and
   many others serving as de-facto solutions for versioning dependencies.

     "I use go get for production builds." - said no one ever.

   Go's implementation of package management traces its origins back to Google (which has a giant
   monolithic repository for all their source code). Let's break down on what's wrong with 'pre - go
   module' package management tooling.
    1. Versioning dependencies
    2. Vendoring dependencies
    3. The necessity of GOPATH

Versioning dependencies
   go get by default didn't support module versioning. The idea behind the first version of go's package
   management was - no need for module versioning, no need for 3rd-party module repositories, you build
   everything from your current branch.

   Pre Go 1.11, adding a dependency meant cloning that dependency's source code repo in your GOPATH.
   That was about it. There was no concept of versions. Rather, it always pointed to the current master
   branch at the time of cloning. Another major issue cropped up when different projects needed
   different versions of a dependency - which wasn't possible either.

Vendoring dependencies
   Package vendoring is commonly referred to as the case where dependent packages are stored in the same
   place as your project. That usually means your dependencies are checked into your source management
   system, such as Git.

   Consider this case - A uses dependency B, which uses a feature of dependency C introduced in version
   1.5 of C, B must be able to ensure that A's build uses C 1.5 or later. Pre Go 1.5, there was no
   mechanism for carrying dependency code alongside commands without rewriting import paths.

Necessity of GOPATH
   GOPATH exists for two main reasons:
    1. In Go, the import declaration references a package via its fully qualified import path. GOPATH
       exist so that from any directory inside GOPATH/src the go tool can compute the absolute import
       path of the package in question.
    2. A location to store dependencies fetched by go get.

   What's wrong with this?
    1. GOPATH doesn't allow checking out the source of a project in a directory of choice like they
       are used to with other languages.
    2. Additionally, GOPATH does not let the developer have more than one copy of a project (or its
       dependencies) checked out at the same time.

Introducing Go Modules

   Go 1.11 introduces preliminary support for Go modules. From Go Wiki,

     A module is a collection of related Go packages that are versioned together as a single unit.
     Modules record precise dependency requirements and create reproducible builds.

   Go modules brings three important features built-in,

   1) go.mod file similar to package.json or Pipfile.

   2) A machine-generated transitive dependency description - go.sum.

   3) No more GOPATH limitation. Modules can be in any path.
$> go help mod
Go mod provides access to operations on modules.

Note that support for modules is built into all the go commands,
not just 'go mod'. For example, day-to-day adding, removing, upgrading,
and downgrading of dependencies should be done using 'go get'.
See 'go help modules' for an overview of module functionality.

Usage:

        go mod <command> [arguments]

The commands are:

        download    download modules to local cache
        edit        edit go.mod from tools or scripts
        graph       print module requirement graph
        init        initialize new module in current directory
        tidy        add missing and remove unused modules
        vendor      make vendored copy of dependencies
        verify      verify dependencies have expected content
        why         explain why packages or modules are needed

Use "go help mod <command>" for more information about a command.

Migrating to Go Modules
   To use Go modules, update Go to version >= 1.11. Since GOPATH is going away, one can activate module
   support in one of these two ways:
     * Invoke the go command in a directory outside of the GOPATH/src tree, with a valid go.mod file in
       the current directory.
     * Go modules don't work if source is under GOPATH. To override this behaviour, invoke the go
       command with GO111MODULE=on environment variable set.

   Let's start porting by following these simple steps:
     * As GOPATH isn't necessary anymore, move the module out of GOPATH.
     * From the project root, create the initial module definition - go mod init
       github.com/username/repository. The best part is, go mod automatically converts dependencies from
       existing package managers like dep, Gopkg, glide and six others. This will create a file
       called go.mod with the module name and dependencies with its versions.

$> cat go.mod
module github.com/deepsourcelabs/cli

go 1.12

require (
        github.com/certifi/gocertifi v0.0.0-20190410005359-59a85de7f35e
        github.com/getsentry/raven-go v0.2.0
        github.com/pkg/errors v0.0.0-20190227000051-27936f6d90f9

     * Run go build to create a go.sum file which contains the expected cryptographic checksums of the
       content of specific module versions. This is to ensure that future downloads of these modules
       retrieve the same bits as the first download. Note that go.sum is not a lock file.

$> cat go.sum
github.com/certifi/gocertifi v0.0.0-20190410005359-59a85de7f35e h1:9574pc8MX6rF/QyO14SPHhM5KKIOo9fkb/1ifuYMTKU=
github.com/certifi/gocertifi v0.0.0-20190410005359-59a85de7f35e/go.mod h1:GJKEexRPVJrBSOjoqN5VNOIKJ5Q3RViH6eu3puDRwx4=
github.com/getsentry/raven-go v0.2.0 h1:no+xWJRb5ZI7eE8TWgIq1jLulQiIoLG0IfYxv5JYMGs=
github.com/getsentry/raven-go v0.2.0/go.mod h1:KungGk8q33+aIAZUIVWZDr2OfAEBsO49PX4NzFV5kcQ=
github.com/pkg/errors v0.0.0-20190227000051-27936f6d90f9 h1:dIsTcVF0w9viTLHXUEkDI7cXITMe+M/MRRM2MwisVow=
github.com/pkg/errors v0.0.0-20190227000051-27936f6d90f9/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=

     Note on versioning: To maintain backward compatibility, if the module is version v2 or higher, the
     major version of the module must be included as a /vN at the end of the module paths used in
     go.modfiles (e.g., module github.com/username/repository/v2

Everyday commands

List dependencies
   go list -m all lists the current module and all its dependencies.
$> go list -m all
github.com/deepsourcelabs/cli
github.com/certifi/gocertifi v0.0.0-20190410005359-59a85de7f35e
github.com/getsentry/raven-go v0.2.0
github.com/pkg/errors v0.0.0-20190227000051-27936f6d90f9

     In the go list output, the current module, also known as the main module, is always the first
     line, followed by dependencies sorted by module path.

List available versions of a package
   go list -m -versions github.com/username/repository lists available versions of a package.
$> go list -m -versions github.com/getsentry/raven-go
github.com/getsentry/raven-go v0.1.0 v0.1.1 v0.1.2 v0.2.0

Add a dependency
   Adding a dependency is implicit. After importing a dependency in code, running go build or go test
   command gets the latest version of the module and adds it to go.mod file. If you would like to add a
   dependency explicitly, rungo get github.com/username/repository.

Upgrade/downgrade a dependency
   go get github.com/username/repository@vx.x.x downloads and sets the specific version of the
   dependency and updates go.mod file.
$> go get github.com/getsentry/raven-go@v0.1.2
go: finding github.com/getsentry/raven-go v0.1.2
go: downloading github.com/getsentry/raven-go v0.1.2
go: extracting github.com/getsentry/raven-go v0.1.2

$> cat go.mod
module github.com/deepsourcelabs/marvin-go

go 1.12

require (
        github.com/certifi/gocertifi v0.0.0-20190410005359-59a85de7f35e
        github.com/getsentry/raven-go v0.1.2
        github.com/pkg/errors v0.0.0-20190227000051-27936f6d90f9
)

$> cat go.sum
github.com/certifi/gocertifi v0.0.0-20190410005359-59a85de7f35e h1:9574pc8MX6rF/QyO14SPHhM5KKIOo9fkb/1ifuYMTKU=
github.com/certifi/gocertifi v0.0.0-20190410005359-59a85de7f35e/go.mod h1:GJKEexRPVJrBSOjoqN5VNOIKJ5Q3RViH6eu3puDRwx4=
github.com/getsentry/raven-go v0.1.2 h1:4V0z512S5mZXiBvmW2RbuZBSIY1sEdMNsPjpx2zwtSE=
github.com/getsentry/raven-go v0.1.2/go.mod h1:KungGk8q33+aIAZUIVWZDr2OfAEBsO49PX4NzFV5kcQ=
github.com/getsentry/raven-go v0.2.0 h1:no+xWJRb5ZI7eE8TWgIq1jLulQiIoLG0IfYxv5JYMGs=
github.com/getsentry/raven-go v0.2.0/go.mod h1:KungGk8q33+aIAZUIVWZDr2OfAEBsO49PX4NzFV5kcQ=
github.com/pkg/errors v0.0.0-20190227000051-27936f6d90f9 h1:dIsTcVF0w9viTLHXUEkDI7cXITMe+M/MRRM2MwisVow=
github.com/pkg/errors v0.0.0-20190227000051-27936f6d90f9/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=

Vendoring dependencies
   When using modules, the go command completely ignores vendor directories. For backward compatibility
   with older versions of Go, or to ensure that all files used for a build are stored together in a
   single file tree, rungo mod vendor.

   This creates a directory named vendor in the root directory of the main module and stores all the
   packages from dependency modules there.

     Note: To build using the main module's top-level vendor directory, run 'go build -mod=vendor'.

Remove unused dependencies
   go mod tidy trims unused dependencies and updates go.mod file.

FAQs
Is GOPATH not needed anymore?

   No. Farewell GOPATH.

Which version is pulled by default?
   The go.mod file and the go command more generally use semantic versions as the standard form for
   describing module versions, so that versions can be compared to determine which should be considered
   earlier or later than another. A module version like v1.2.3 is introduced by tagging a revision in
   the underlying source repository. Untagged revisions can be referred to using a "pseudo-version" like
   v0.0.0-yyyymmddhhmmss-abcdefabcdef, where the time is the commit time in UTC and the final suffix is
   the prefix of the commit hash.

Should go.sum be checked into version control?

   Yes.


---
https://www.modularfinance.se/blog/2019/0321-go-modules--docker-and-goland?l=sv

Migrating to Go Modules

   I spent yesterday figuring out how to port our workflow here at Modular Finance to a more modern one.
   Specifically trying to make go modules play nice with our docker containers.

   We have successfully tried this out before but only for trivial cases. This time I tried to take on
   one of our bigger projects and it has proven to be a bit more challenging.

Background
   At Modular Finance we use a lot of Go and Docker for most of our projects and products. We both
   develop, test and deploy all of our code in a docker environment. This gives us a lot of benefits, a
   consistent environment across the applications life cycle, easy to get started for new developers,
   standardized builds and so on. Nothing is however without its downside and some work has to be put in
   to get things running.

   We run and build multiple products. Each product we have is a separate git repo which may consist of
   many micro services, gateways, frontends, databases and so on. These products share generic libraries
   which we keep in a separate (private) git repo, kit. This gives us a paradigm where we have mono repo
   for each product and a shared repo between them.

   To develop our applications we use docker compose which is easily then translated to a kubernetes
   configuration when deployed to our integration, test and production environments. A typical structure
   for a product might look as follows
 a-project/
 |- go/
 |  `- src/
 |     `- a-project/
 |        |- service1/
 |        |- service2/
 |        |  |- cmd/
 |        |  |- internal/
 |        |  |- modelfiles.go
 |        |  `- Dockerfile
 |        `- vendor/
 |- frontend1/
 |- frontend2/
 |- databases/
 `- docker-compose.yml

   Each service becomes its own docker container, we mount a-project/go/src/a-project into /go/src/ on
   each go docker container. In our IDE we now add the a-project/go as our $GOPATH. Until now we have
   been using govendor for dependency management placing all dependencies in
   a-project/go/src/a-project/vendor.

   This structure is the last one in a long line of different structures/workflows we have tried and it
   has been serving us very well during the last year or so. But since Go modules are now available we
   want to address a couple of things that has been hard to solve with govendor.

The basics
   Let's start with a trivial case. There are already a lot of resources around the web for this. I
   found https://github.com/donvito/hellomod to be a helpful starting point.

   This tells us to create a main.go looking something like this:
package main

import "github.com/donvito/hellomod"

func main() {
    hellomod.SayHello()
}

   Then:
go mod init hello # -> go: creating new go.mod: module hello

   Which gives us a new file go.mod with one line: module hello.

   So far so good, let's wrap this in a docker container since we use docker-compose:
# dockerfile

FROM golang:1.11-alpine

# go get uses git to fetch modules
RUN apk add --no-cache git

RUN mkdir -p /go/src/hello
WORKDIR /go/src/hello

ENV GO111MODULE=on

CMD go run main.go

# docker-compose.yml

version: '3.0'

services:
  hello-service:
    build:
      context: .
      dockerfile: ./dockerfile
    volumes:
      - .:/go/src/hello/
      - ./pkg:/go/pkg

   Spinning this up with docker-compose up downloads the missing github.com/donvito/hellomod go module
   we specified in main.go above. We can see the module in the pkg folder that we mounted:
   pkg/mod/github.com/donvito/hellomod@v1.0.1/

Permissions
   Using this setup we can continue to develop our app and let docker download modules for us when
   needed. However one slightly annoying part is that since we run as root inside the container our pkg/
   folder will be locked behind sudo.

   This is nothing new, govendor and package managers in other languages have the same behavior. To make
   our dev environments more smooth we typically add the following to our docker configs:
# ...

# mirror dev user
ARG UID

RUN useradd --uid $UID --create-home $USER

RUN chown -R $UID /go

USER $USER

CMD go run main.go

# ...

  hello-service:
    build:
      context: .
      dockerfile: ./dockerfile
      args:
        UID: ${UID}
        USER: ${USER}
# ...

   Let now restart everything with the correct uid
echo UID=$(id -u) >> .env # <- docker-compose default env config
docker-compose up

Private git repos as Go Modules
   Cool, we're done with the basics. On to more complex stuff.

   As many other companies we try to dogfood as much as we can. This was the first roadblock I
   encountered when trying to convert to go modules. Previously we (a bit reluctantly) imported private
   packages using git submodules. This works but since it's possible to import stuff with go get
   directly from git it adds complexity.

   The method I went with is to pass in my ssh socket to the docker container. I'm not passing in any
   ssh keys but for safety I'm just recommending this method for dev configs.

   To access private repos with go get we'll first configure git to use ssh instead of the https. In
   normal git repos, git figures out what protocol to use by itself (depending on how the "remote" is
   configured). In this case we need to pre-empt the default https setting by overriding it in the
   .gitconfig inside the container. We're also silencing the "authenticity of host ... (yes/no)" prompt by
   adding the "... StrictHostKeyChecking ..." line below.

   Final dockerfile:
#dockerfile

FROM golang:1.11-alpine

RUN apk add --no-cache git curl build-base bash openssh-client shadow

RUN mkdir -p /go/src/hello
WORKDIR /go/src/hello

ENV GO111MODULE=on

# mirror dev user
ARG UID
ARG USER

RUN useradd --uid $UID --create-home $USER
RUN chown -R $UID /go

RUN printf "[url \"git@bitbucket.org:\"]\n\tinsteadOf = https://bitbucket.org/\n" >> /home/$USER/.gitconfig
RUN mkdir /home/$USER/.ssh && echo "StrictHostKeyChecking no " > /home/$USER/.ssh/config

USER $USER

CMD go run main.go

   Okay, almost there, now just share the ssh socket

   Final docker-compose.yml:
# docker-compose.yml

version: '3.0'

services:
  hello-service:
    build:
      context: .
      dockerfile: ./dockerfile
      args:
        UID: ${UID}
        USER: ${USER}
    environment:
      SSH_AUTH_SOCK: /run/ssh_agent
    volumes:
      - $SSH_AUTH_SOCK:/run/ssh_agent
      - .:/go/src/hello/
      - ./pkg:/go/pkg

   Add a private repo as import in main.go and spin up the container. It should download everything as
   go modules to pkg/, both public and private dependencies.

GoLand configuration
   Last bit of setup. We typically use GoLand for developing Go. To make GoLand recognize the pkg/
   folder as modules (for IntelliSense etc.) open settings (ctrl + alt + s on ubuntu) then:
     * Go > Go Modules (vgo) > ✓ Enable Go Modules (vgo integration)
     * Go > GOPATH > Project GOPATH: add parent folder for pkg/

   I ran in to an annoying issue here with the yaml.v2 module. I even found another user with the
   exact same problem. Unfortunately the trail ends there in a striking resemblance to a relevant
   xkcd: Wisdom of the Ancients

   I have some suspicions about what's wrong here but nothing concrete.

   My solution so far has been to hack around this using chmod from inside the container
# somewhere after fetching go modules in the dockerfile
chmod +w /go/pkg/mod/gopkg.in/yaml.v2@v2.2.2 /go/pkg/mod/gopkg.in/yaml.v2@v2.2.2/go.mod

   With that we have a really nice (apart from that last thing), encapsulated, environment for
   developing Go projects with Docker and private go modules.


---
https://codeengineered.com/blog/2019/go-mod-major-versions/

Go Modules and Major Versions

   Working with Go modules whose major version is 2 or greater is different than working version 0 or 1
   and is different than doing so with the tools that came before it like dep and glide. There are
   changes that need to be made to both the module and the way it's consumed. Having had to work through
   this with [**1]semver, here are some practical things I've learned along the way.

go.mod Module Name
   Once you hit v2 of a module, which is often the code in a repository, the go.mod file needs some
   changes. For example, the first line of the semver package for v1 would have been:
module github.com/Masterminds/semver

   When it moved beyond v1 it had to change. For example, here is the change for v3:
module github.com/Masterminds/semver/v3

   The version is in the module path.

Changes Using go get
   Using go get to retrieve a version changes as well. With version 1 the command could look like:
$> go get github.com/Masterminds/semver@v1.5.0

   But, if you tried to change the version to v3.0.1, the latest v3 release at the time of this writing,
   you'd get an error. The major version needs to be part of the path. You would need to use:
$> go get github.com/Masterminds/semver/v3@v3.0.1

Requiring modules
   Requiring modules follows this same paradigm. This is for both the require statements within the .go
   files and the go.mod require statement.

   For example, to require v3 the go.mod file pulling in semver would need to have a line like:
require github.com/Masterminds/semver/v3@v3.0.1

   and the require statements in the code would need to import github.com/Masterminds/semver/v3. The
   calls to functions in the package don't need to change unless you're working with multiple versions
   of the same package. For example, when importing v3 a call to semver.NewVersion would still work as
   expected.

   If the changes to the import statements aren't made Go will try get the latest v1 release, update the
   go.mod file to include the v1 release, and use that. This happens when running commands like go
   build. If you didn't know, go build can modify your go.mod file.

   This is just a quick primer. There are more details in the Go wiki and docs if you need more details.



---
[**1]
https://github.com/Masterminds/semver

SemVer
   The semver package provides the ability to work with Semantic Versions in Go. Specifically it
   provides the ability to:
     * Parse semantic versions
     * Sort semantic versions
     * Check if a semantic version fits within a set of constraints
     * Optionally work with a v prefix

   If you are looking for a command line tool for version comparisons please see vert which uses
   this library.

Package Versions
   There are three major versions fo the semver package.
     * 3.x.x is the new stable and active version. This version is focused on constraint compatibility
       for range handling in other tools from other languages. It has a similar API to the v1 releases.
       The development of this version is on the master branch. The documentation for this version is
       below.
     * 2.x was developed primarily for dep. There are no tagged releases and the development was
       performed by @sdboyer. There are API breaking changes from v1. This version lives on the
       2.x branch.
     * 1.x.x is the most widely used version with numerous tagged releases. This is the previous stable
       and is still maintained for bug fixes. The development, to fix bugs, occurs on the release-1
       branch. You can read the documentation here.

Parsing Semantic Versions
   There are two functions that can parse semantic versions. The StrictNewVersion function only parses
   valid version 2 semantic versions as outlined in the specification. The NewVersion function attempts
   to coerce a version into a semantic version and parse it. For example, if there is a leading v or a
   version listed without all 3 parts (e.g. v1.2) it will attempt to coerce it into a valid semantic
   version (e.g., 1.2.0). In both cases a Version object is returned that can be sorted, compared, and
   used in constraints.

   When parsing a version an error is returned if there is an issue parsing the version. For example,
v, err := semver.NewVersion("1.2.3-beta.1+build345")

   The version object has methods to get the parts of the version, compare it to other versions, convert
   the version back into a string, and get the original string. Getting the original string is useful if
   the semantic version was coerced into a valid form.

Sorting Semantic Versions
   A set of versions can be sorted using the sort package from the standard library. For example,
raw := []string{"1.2.3", "1.0", "1.3", "2", "0.4.2",}
vs := make([]*semver.Version, len(raw))
for i, r := range raw {
    v, err := semver.NewVersion(r)
    if err != nil {
        t.Errorf("Error parsing version: %s", err)
    }

    vs[i] = v
}

sort.Sort(semver.Collection(vs))

Checking Version Constraints
   There are two methods for comparing versions. One uses comparison methods on Version instances and
   the other uses Constraints. There are some important differences to notes between these two methods
   of comparison.
    1. When two versions are compared using functions such as Compare, LessThan, and others it will
       follow the specification and always include prereleases within the comparison. It will provide an
       answer that is valid with the comparison section of the spec at
       https://semver.org/#spec-item-11
    2. When constraint checking is used for checks or validation it will follow a different set of rules
       that are common for ranges with tools like npm/js and Rust/Cargo. This includes considering
       prereleases to be invalid if the ranges does not include one. If you want to have it include
       pre-releases a simple solution is to include -0 in your range.
    3. Constraint ranges can have some complex rules including the shorthand use of ~ and ^. For more
       details on those see the options below.

   There are differences between the two methods or checking versions because the comparison methods on
   Version follow the specification while comparison ranges are not part of the specification. Different
   packages and tools have taken it upon themselves to come up with range rules. This has resulted in
   differences. For example, npm/js and Cargo/Rust follow similar patterns while PHP has a different
   pattern for ^. The comparison features in this package follow the npm/js and Cargo/Rust lead because
   applications using it have followed similar patters with their versions.

   Checking a version against version constraints is one of the most featureful parts of the package.
c, err := semver.NewConstraint(">= 1.2.3")
if err != nil {
    // Handle constraint not being parsable.
}

v, err := semver.NewVersion("1.3")
if err != nil {
    // Handle version not being parsable.
}
// Check if the version meets the constraints. The a variable will be true.
a := c.Check(v)

Basic Comparisons
   There are two elements to the comparisons. First, a comparison string is a list of space or comma
   separated AND comparisons. These are then separated by || (OR) comparisons. For example, ">= 1.2 <
   3.0.0 || >= 4.2.3" is looking for a comparison that's greater than or equal to 1.2 and less than
   3.0.0 or is greater than or equal to 4.2.3.

   The basic comparisons are:
     * =: equal (aliased to no operator)
     * !=: not equal
     * >: greater than
     * <: less than
     * >=: greater than or equal to
     * <=: less than or equal to

Working With Prerelease Versions
   Pre-releases, for those not familiar with them, are used for software releases prior to stable or
   generally available releases. Examples of prereleases include development, alpha, beta, and release
   candidate releases. A prerelease may be a version such as 1.2.3-beta.1 while the stable release would
   be 1.2.3. In the order of precedence, prereleases come before their associated releases. In this
   example 1.2.3-beta.1 < 1.2.3.

   According to the Semantic Version specification prereleases may not be API compliant with their
   release counterpart. It says,

     A pre-release version indicates that the version is unstable and might not satisfy the intended
     compatibility requirements as denoted by its associated normal version.

   SemVer comparisons using constraints without a prerelease comparator will skip prerelease versions.
   For example, >=1.2.3 will skip prereleases when looking at a list of releases while >=1.2.3-0 will
   evaluate and find prereleases.

   The reason for the 0 as a pre-release version in the example comparison is because pre-releases can
   only contain ASCII alphanumerics and hyphens (along with . separators), per the spec. Sorting happens
   in ASCII sort order, again per the spec. The lowest character is a 0 in ASCII sort order (see an
   ASCII Table)

   Understanding ASCII sort ordering is important because A-Z comes before a-z. That means >=1.2.3-BETA
   will return 1.2.3-alpha. What you might expect from case sensitivity doesn't apply here. This is due
   to ASCII sort ordering which is what the spec specifies.

Hyphen Range Comparisons
   There are multiple methods to handle ranges and the first is hyphens ranges. These look like:
     * 1.2 - 1.4.5 which is equivalent to >= 1.2 <= 1.4.5
     * 2.3.4 - 4.5 which is equivalent to >= 2.3.4 <= 4.5

Wildcards In Comparisons
   The x, X, and * characters can be used as a wildcard character. This works for all comparison
   operators. When used on the = operator it falls back to the patch level comparison (see tilde below).
   For example,
     * 1.2.x is equivalent to >= 1.2.0, < 1.3.0
     * >= 1.2.x is equivalent to >= 1.2.0
     * <= 2.x is equivalent to < 3
     * * is equivalent to >= 0.0.0

Tilde Range Comparisons (Patch)
   The tilde (~) comparison operator is for patch level ranges when a minor version is specified and
   major level changes when the minor number is missing. For example,
     * ~1.2.3 is equivalent to >= 1.2.3, < 1.3.0
     * ~1 is equivalent to >= 1, < 2
     * ~2.3 is equivalent to >= 2.3, < 2.4
     * ~1.2.x is equivalent to >= 1.2.0, < 1.3.0
     * ~1.x is equivalent to >= 1, < 2

Caret Range Comparisons (Major)
   The caret (^) comparison operator is for major level changes once a stable (1.0.0) release has
   occurred. Prior to a 1.0.0 release the minor versions acts as the API stability level. This is useful
   when comparisons of API versions as a major change is API breaking. For example,
     * ^1.2.3 is equivalent to >= 1.2.3, < 2.0.0
     * ^1.2.x is equivalent to >= 1.2.0, < 2.0.0
     * ^2.3 is equivalent to >= 2.3, < 3
     * ^2.x is equivalent to >= 2.0.0, < 3
     * ^0.2.3 is equivalent to >=0.2.3 <0.3.0
     * ^0.2 is equivalent to >=0.2.0 <0.3.0
     * ^0.0.3 is equivalent to >=0.0.3 <0.0.4
     * ^0.0 is equivalent to >=0.0.0 <0.1.0
     * ^0 is equivalent to >=0.0.0 <1.0.0

Validation
   In addition to testing a version against a constraint, a version can be validated against a
   constraint. When validation fails a slice of errors containing why a version didn't meet the
   constraint is returned. For example,
c, err := semver.NewConstraint("<= 1.2.3, >= 1.4")
if err != nil {
    // Handle constraint not being parseable.
}

v, err := semver.NewVersion("1.3")
if err != nil {
    // Handle version not being parseable.
}

// Validate a version against a constraint.
a, msgs := c.Validate(v)
// a is false
for _, m := range msgs {
    fmt.Println(m)

    // Loops over the errors which would read
    // "1.3 is greater than 1.2.3"
    // "1.3 is less than 1.4"
}


---
https://marcofranssen.nl/manage-go-tools-via-go-modules/

Manage Go tools via Go modules
October 2nd 2019

   In this blog I will cover how I'm managing and versioning the tools my Go projects depend on. [9]Go
   Modules are available since Go 1.11. Using Go Modules you can manage the dependencies for your
   project. You can compare it to NPM in Nodejs projects or Maven in Java project or Nuget in .NET
   projects.

   In general Go Modules are used to manage your compile time dependencies. However in my projects I
   also like to manage the tools required for Continuous Integration in my projects. To ensure all
   developers have same versions of tools installed and to ensure my CI server (Jenkins, Travis,
   CircleCI) can install and use the same version of the tools. I found a way using Go Modules, by
   default you will have some issue with go mod tidy if you would just manually add the tools as
   dependencies to your go.mod file.

Initialize
   To start with Go Modules we first have to initialize a new Go Module. We do that by creating a new
   folder and run the go mod init command.
$> mkdir my-project
$> cd my-project
$> go mod init github.com/marcofranssen/my-project
go: creating new go.mod: module github.com/marcofranssen/my-project

   This will result in following go.mod file.
$> cat go.mod
module github.com/marcofranssen/my-project
go 1.12

Add your tools as dependency

   Now we want to add our tools as dependency to our go.mod. In general you would think to just add them
   using go get, which works at first sight perfectly fine. See below example.
$> go get -u github.com/goreleaser/goreleaser
$> go get -u golang.org/x/lint/golint
$> cat go.mod
module github.com/marcofranssen/my-project
go 1.12
require (
        golang.org/x/crypto v0.0.0-20191001170739-f9e2070545dc // indirect
        golang.org/x/lint v0.0.0-20190930215403-16217165b5de // indirect
        golang.org/x/net v0.0.0-20191002035440-2ec189313ef0 // indirect
        golang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e // indirect
        golang.org/x/sys v0.0.0-20191002091554-b397fe3ad8ed // indirect
        golang.org/x/text v0.3.2 // indirect
        golang.org/x/tools v0.0.0-20191001184121-329c8d646ebe // indirect
)

   As you can see it added indirect dependencies, and you will notice the goreleaser dependencies are
   not there at all as the second go get has removed them. Indirect means there is none of your own code
   which has a direct dependency on the module, which is correct as these are tools I would use and not
   dependencies of my own to be written code. You will also see there is a go.sum file generated, which
   I will skip for now as it is not relevant for this explanation.

   Now there is also the go mod tidy command which cleans your dependencies etc. This is a recommended
   command to run before you make a release to ensure all dependencies are cleaned and accurate with the
   real needs of your code. So lets run that command now and check what happens.
$> go mod tidy
$> cat go.mod
module github.com/marcofranssen/my-project
go 1.12

   As you can see all the dependencies are again removed from the go.mod file and the go.sum file is
   cleaned up as well. This happens because there is no dependency in any .go file.

TL;DR

   To ensure my tool dependencies are not removed and can leverage the Go Modules, I create a file
   tools.go. In this file I will list all my tool dependencies using an import statement.
   tools.go
// +build tools
package main
import (
    _ "github.com/fullstorydev/grpcui/cmd/grpcui"
    _ "github.com/golang/protobuf/protoc-gen-go"
    _ "github.com/golangci/golangci-lint/cmd/golangci-lint"
    _ "github.com/goreleaser/goreleaser"
    _ "github.com/spf13/cobra/cobra"
    _ "github.com/tebeka/go2xunit"
    _ "golang.org/x/lint/golint"
    _ "golang.org/x/perf/cmd/benchstat"
    _ "golang.org/x/tools/cmd/stringer"
)

   As you can notice I have also added a build constraint a.k.a. build tag comment in the top of the
   file, to ensure it is not compiled into the binary, when running go build. Now with this file in
   place I can very easily install all my tools using a simple bash command. go install will make all
   the tools available in your $GO_WORKSPACE/bin folder. Normally this folder is available in your PATH
   so you can use the binaries in any folder of your choice.
$> cat tools.go | grep _ | awk -F'"' '{print $2}' | xargs -tI % go install %
go install github.com/fullstorydev/grpcui/cmd/grpcui
go: finding github.com/fullstorydev/grpcui/cmd/grpcui latest
go: finding github.com/fullstorydev/grpcui/cmd latest
go: downloading golang.org/x/net v0.0.0-20190522155817-f3200d17e092
go: extracting golang.org/x/net v0.0.0-20190522155817-f3200d17e092
go install github.com/golang/protobuf/protoc-gen-go
go install github.com/golangci/golangci-lint/cmd/golangci-lint
go: finding github.com/golangci/golangci-lint/cmd/golangci-lint latest
go: finding github.com/golangci/golangci-lint/cmd latest
go: downloading golang.org/x/tools v0.0.0-20190912215617-3720d1ec3678
go: extracting golang.org/x/tools v0.0.0-20190912215617-3720d1ec3678
go: downloading github.com/securego/gosec v0.0.0-20190912120752-140048b2a218
go: downloading github.com/matoous/godox v0.0.0-20190910121045-032ad8106c86
go: extracting github.com/securego/gosec v0.0.0-20190912120752-140048b2a218
go: extracting github.com/matoous/godox v0.0.0-20190910121045-032ad8106c86
go install github.com/goreleaser/goreleaser
go: downloading github.com/goreleaser/goreleaser v0.118.2
go: extracting github.com/goreleaser/goreleaser v0.118.2
......
.....
....
.......

   Above bash script will read all the lines starting with an _ from the file and it will strip the "
   before it passes them to go install. As you can see now the go.mod and go.sum files are updated. Also
   notice the dependencies are not cleared anymore when running go mod tidy.
$> cat go.mod
module github.com/marcofranssen/my-project
go 1.12
require (
        github.com/fullstorydev/grpcui v0.2.1
        github.com/golang/protobuf v1.3.2
        github.com/golangci/golangci-lint v1.19.1
        github.com/goreleaser/goreleaser v0.118.2
        github.com/spf13/cobra v0.0.5
        github.com/tebeka/go2xunit v1.4.10
        golang.org/x/lint v0.0.0-20190409202823-959b441ac422
        golang.org/x/perf v0.0.0-20190823172224-ecb187b06eb0
        golang.org/x/tools v0.0.0-20190912215617-3720d1ec3678
)
$> go mod tidy
$> cat go.mod
module github.com/marcofranssen/my-project
go 1.12
require (
        github.com/fullstorydev/grpcui v0.2.1
        github.com/golang/protobuf v1.3.2
        github.com/golangci/golangci-lint v1.19.1
        github.com/goreleaser/goreleaser v0.118.2
        github.com/spf13/cobra v0.0.5
        github.com/tebeka/go2xunit v1.4.10
        golang.org/x/lint v0.0.0-20190409202823-959b441ac422
        golang.org/x/perf v0.0.0-20190823172224-ecb187b06eb0
        golang.org/x/tools v0.0.0-20190912215617-3720d1ec3678
)

   Also notice the dependencies are no longer indirect as you now have code which depends on the given
   module. Don't worry, due to the build constraint this code will not be compiled into the binary
   when running go build ., unless you ofcourse provide a build argument with the tools constraint.

   Now I can imagine you don't want to type this command all the time, so the next thing I do in my
   projects is adding a Makefile including a install-tools task.
   Makefile
download:
  @echo Download go.mod dependencies
  @go mod download
install-tools: download
  @echo Installing tools from tools.go
  @cat tools.go | grep _ | awk -F'"' '{print $$2}' | xargs -tI % go install %

   This now allows me to run simply make install-tools.
$> make install-tools
Download go.mod dependencies
Installing tools from tools.go
go install github.com/fullstorydev/grpcui/cmd/grpcui
go install github.com/golang/protobuf/protoc-gen-go
go install github.com/golangci/golangci-lint/cmd/golangci-lint
go install github.com/goreleaser/goreleaser
go install github.com/spf13/cobra/cobra
go install github.com/tebeka/go2xunit
go install golang.org/x/lint/golint
go install golang.org/x/perf/cmd/benchstat
go install golang.org/x/tools/cmd/stringer

   Now in your Makefile you can add more tasks for compiling, testing, benchmarking and running your
   application, so you have less manual commands to type in your project.

   Summarized you will now have following files in your folder, which you could now start committing in
   your repo before you continue setting up your project and adding the code.
my-project
|- go.mod
|- go.sum
|- Makefile
`- tools.go



---
https://gobuffalo.io/en/docs/gomods

   As of December 1st, 2019 Buffalo, and all related packages, require Go Modules and the use of the
   GOPATH is no longer supported.

   Please see this blog post for more information
   https://blog.gobuffalo.io/the-road-to-1-0-requiring-modules-5672c6b015e5.

Go Modules
   NOTE: Please read https://github.com/golang/go/wiki/Modules to understand more about Go Modules
   before using them.

Enabling Go Module Support
   since v0.13.0

   The support for Go Modules in "Buffalo" packages is experimental, as are Go Modules (as of v1.11.x).
   To "opt-in" to using Go Modules you need to turn them using the GO111MODULE environment variable and
   setting it to on.

   This is REQUIRED to use Go Modules with "Buffalo" packages. The auto setting for GO111MODULE is NOT
   supported.
$> export GO111MODULE=on

Working Outside of the GOPATH
   In addition to repeatable builds, Go Modules, allows you to easily work outside of the GOPATH.

   With GO111MODULE=on the buffalo command should work as it previously did inside the GOPATH.
$> export GO111MODULE=on
$> buffalo new -h

Working Inside the GOPATH
   Because Go Modules are still experimental, and not complete, it is recommended to continue to work
   INSIDE the GOPATH. This will allow you to easily move between using, and not using modules.

   When working inside the GOPATH you should continue to use GOPATH style module names.

Recommended
   This style of module name works both inside, and outside, of the GOPATH easily. It also makes your
   projects work with go get.
module github.com/markbates/coke

Not-Recommended
   This style of module, can work inside of the GOPATH, but it is less flexible, although shorter, than
   the longer format module name.
module coke

   Regardless of which module name style you pick, you MUST be consistent within your application.

   For example, if your module name is coke your actions package is coke/actions. If you module name is
   github.com/markbates/coke your actions package is github.com/markbates/coke/actions.

FAQs

I Get invalid import
   When I run buffalo build I get strange errors like this when I run outside of my GOPATH:
invalid import path: "D:/projects/testBuffalo/src/my-project/actions"

   Make sure you have GO111MODULE=on. If you don't, Buffalo, tries to use your GOPATH to determine your
   package locations. Enable Go Modules support and try again.

How Do I Migrate From Dep?
   The go mod init tool can read your Gopkg.toml files and create a new go.mod for you.
   https://github.com/golang/go/wiki/Modules

How Do I Use The development Branch?
   If you want to live on the "edge" and use the latest, bleeding edge, version of Buffalo you can tell
   Go Modules to get that version:
$> go get -u github.com/gobuffalo/buffalo@development
$> go mod tidy


---
