filename: go-tui-build-tui-application-with-tview-20251107.txt
https://dev.to/bekbrace/build-tui-application-with-go-tview-l18

Build TUI application with GO (tview)

Hey everyone! I hope you're all doing great. I've been getting some amazing feedback and thoughtful messages
from you over the past few weeks, and I just want to say a big THANK YOU. It truly means the world to me to
see how much you're engaging with the content I've been creating.

Today, I'm thrilled to share a fresh new tutorial on my YouTube channel-one that I think you're going to love!
This time, I'm giving you something super practical: building a Text User Interface (TUI) application with Go.
Specifically a simple yet powerful Inventory Management System [btw, I'm a credit manager by day and
programmer by night :D]. I'm using go version go1.22.3 windows/amd64
Here's the video tut: https://youtu.be/aiWOTYiIzyE

If you've ever wanted to step up your Go programming skills and explore how to create efficient terminal-based
tools, this tutorial is for you. With the help of the incredible tview package (I introduce it early on in the
video at 0:24), we'll craft an intuitive interface that's not only functional but also user-friendly. Think of
it as a lightweight, no-fuss way to handle your inventory right from your terminal.

Here's a quick overview of what you'll learn:

1 - Installation & Setup: I'll guide you step by step to get your environment ready, from setting up Go to
    installing the tview package.
2 - Building the TUI: Together, we'll design and code the interface, making it interactive and visually
    appealing.
3 - JSON for Data Storage: You'll see how we use JSON to store inventory data. This ensures quick access and
    persistent storage, so your data remains intact even after you close the app.
4 - Practical Usage: By the end of the tutorial, you'll have a fully functional tool to help you manage stock
    efficiently-perfect for small projects or just honing your programming skills.

What's awesome about this project is how approachable it is. Whether you're a beginner looking to expand your
knowledge or an experienced developer curious about TUIs, there's something for everyone in this video. Plus,
the skills you pick up here can be applied to so many other areas-from creating dashboards to building tools
for automation.

I'd love for you to check out the tutorial and let me know what you think! Your feedback helps shape future
content, and I'm always excited to hear what you've built after following along.

Code -> [**1]https://github.com/BekBrace/inv-tui-go
Happy coding, and see you in the comments section!

---
[**1]https://github.com/BekBrace/inv-tui-go

Inventory Management TUI Application

Overview
This Go application is a terminal-based inventory management tool designed to help users manage their stock
efficiently. Utilizing the tview package, it provides a user-friendly Text User Interface (TUI) for adding,
viewing, and deleting inventory items. The application supports persistent storage, saving the inventory data
in a JSON file.

Features
    Add Items: Easily add new items with names and stock quantities.
    View Inventory: Display all current items in stock.
    Delete Items: Remove items from the inventory using their item ID.
    Persistent Storage: Inventory is saved in inventory.json, which is loaded on startup.

Prerequisites
    Go version 1.16 or higher
    tview package for creating the TUI

Installation
    Clone the repository:
$> git clone <repository-url>
$> cd inventory-management

    Install the required installeents [the only external dependency you'll need!]
$> go get github.com/rivo/tview

    Run application
$> go run main.go

Usage
Adding an Item
    Enter the item name in the Item Name field.
    Enter the stock quantity in the Stock field.
    Click the Add Item button to save the item.

Deleting an Item
    Enter the item ID (index) in the Item ID to delete field.
    Click the Delete Item button to remove it from the inventory.

Exiting the Application
    Click the Exit button to close the application.

Inventory Data Structure
The inventory items are stored in a JSON file (inventory.json) with the following structure:
[
	{
		"name": "ItemName",
		"stock": 10
	},
	{
		"name": "AnotherItem",
		"stock": 5
	}
]

Code Structure
Main Application Logic:
    loadInventory(): Loads inventory data from inventory.json.
    saveInventory(): Saves current inventory state to inventory.json.
    deleteItem(index int): Deletes an item from the inventory based on its ID.

Dependencies:
    encoding/json: For JSON encoding/decoding.
    fmt: For formatted I/O.
    log: For error logging.
    os: For operating system interactions.
    strconv: For string conversion.
    github.com/rivo/tview: For TUI functionality.

Contributing
Contributions are welcome! If you'd like to contribute, please fork the repository and submit a pull request.

BekBrace/inv-tui-go (Public)
	|
	|-- README.md
	|-- .gitignore
	|-- go.mod
	|-- go.sum
	|-- inventory.json
	+-- main.go

---
[go.mod]
module inventory

go 1.22.3

require (
	github.com/gdamore/encoding v1.0.0 // indirect
	github.com/gdamore/tcell v1.4.0 // indirect
	github.com/gdamore/tcell/v2 v2.7.4 // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-runewidth v0.0.15 // indirect
	github.com/rivo/tview v0.0.0-20241016194538-c5e4fb24af13 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	golang.org/x/sys v0.17.0 // indirect
	golang.org/x/term v0.17.0 // indirect
	golang.org/x/text v0.14.0 // indirect
)


---
[inventory,json]
[
	{
		"name": "Sinclair",
		"stock": 340
	},
	{
		"name": "IBM RT",
		"stock": 500
	},
	{
		"name": "Atari 800XL",
		"stock": 50
	}
]


---
[main.go]
package main

import (
	"encoding/json" // Handles JSON encoding/decoding
	"fmt"           // For formatted I/O like printing to the console
	"log"           // Handles logging errors
	"os"            // Provides operating system functionality like file handling
	"strconv"       // Converts strings to other types, like converting string to int

	// tview page in GO
	// https://pkg.go.dev/github.com/rivo/tview#section-readme
	"github.com/rivo/tview" // This is the TUI package that provides user interface elements
)

// Define an Item structure that will hold the stock information
type Item struct {
	Name  string `json:"name"`  // Name of the item (will be stored as JSON)
	Stock int    `json:"stock"` // Quantity of the item in stock (also stored as JSON)
}

// Initialize an empty slice to store the inventory and set the filename for persistence
var (
	inventory     = []Item{}         // Our inventory list, initially empty
	inventoryFile = "inventory.json" // File where inventory will be saved/loaded from
)

// This function loads the inventory from the JSON file
func loadInventory() {
	// Check if the file exists before attempting to load it
	// // The _ is a blank identifier used in Go to ignore a value that you don't need to use later in your
	// code.
	// if _, err := os.Stat(inventoryFile); err == nil {
	// Here, os.Stat returns two values: the file information (of type os.FileInfo) and an error. Since you
	// only care about whether the file exists (i.e., if there is an error), you can ignore the file
	// information by assigning it to _. This way, you avoid cluttering your code with variables you
	// don't use.
	if _, err := os.Stat(inventoryFile); err == nil {
		// Read the contents of the file
		data, err := os.ReadFile(inventoryFile)
		if err != nil {
			log.Fatal("Error reading inventory file:", err)
		}
		// Parse the JSON data into the inventory slice
		json.Unmarshal(data, &inventory)
	}
}

// This function saves the current inventory to the JSON file
func saveInventory() {
	// Marshal the inventory into JSON with pretty formatting (indentation)
	// The MarshalIndent function ensures that the JSON is "pretty-printed," meaning it adds spaces and
	// newlines for easier reading.
	data, err := json.MarshalIndent(inventory, "", "  ")
	if err != nil {
		log.Fatal("Error saving inventory:", err)
	}
	// Write the JSON data back to the file, overwriting the old data

	// os.WriteFile writes the JSON data to the file specified by inventoryFile.
	// The 0644 sets the file permissions: the owner can read and write, while others can only read the file.
	// This overwrites the old inventory data in the file with the new data in data.
	os.WriteFile(inventoryFile, data, 0644)
}

// Deletes an item from the inventory based on its index
func deleteItem(index int) {
	// Check if the index is valid
	if index < 0 || index >= len(inventory) {
		fmt.Println("Invalid item index.")
		return
	}
	/*
		The goal here is to remove an item from the inventory slice at a specific index.
		inventory[:index]:
		This takes a slice of all elements before the item you want to remove. It creates a new slice that
		starts from the beginning (0) up to but not including index.
		Example: If inventory = [A, B, C, D] and index = 2, then inventory[:index] will give you [A, B].
	*/
	// Remove the item from the inventory using slicing
	// append(inventory[:index], inventory[index+1:]...):

	// The append function joins the two slices: everything before the index and everything after the index,
	// effectively skipping the item at index.append(inventory[:index], inventory[index+1:]...):

	// The append function joins the two slices: everything before the index and everything after the index,
	// effectively skipping the item at index.
	// The ... syntax is used to unpack the slice inventory[index+1:] so that its elements are appended
	// individually.
	// The ... syntax is used to unpack the slice inventory[index+1:] so that its elements are appended
	// individually.
	inventory = append(inventory[:index], inventory[index+1:]...)
	// Save the updated inventory back to the file
	saveInventory()
}

// Main function, where the program execution begins
func main() {
	// Create a new TUI application
	app := tview.NewApplication()

	// Load existing inventory from the JSON file
	loadInventory()

	// Create a TextView that will display the inventory items in the TUI
	inventoryList := tview.NewTextView().
		SetDynamicColors(true). // Enable dynamic coloring of text
		SetRegions(true).       // Allows regions for interaction (not used here)
		SetWordWrap(true)       // Enables word wrapping to fit the TextView size

	inventoryList.SetBorder(true).SetTitle("Inventory Items") // Set border and title

	// This function refreshes the inventory display whenever there are changes
	refreshInventory := func() {
		// Clear the current content of the TextView
		inventoryList.Clear()
		// If inventory is empty, display a message
		if len(inventory) == 0 {
			fmt.Fprintln(inventoryList, "No items in inventory.")
		} else {
			// Iterate through inventory and print each item to the TextView
			for i, item := range inventory {
				fmt.Fprintf(inventoryList, "[%d] %s (Stock: %d)\n", i+1, item.Name, item.Stock)
			}
		}
	}

	// Create input fields for item name and stock quantity
	itemNameInput := tview.NewInputField().SetLabel("Item Name: ")
	itemStockInput := tview.NewInputField().SetLabel("Stock: ")

	// Create an input field for deleting an item by its index (ID)
	itemIDInput := tview.NewInputField().SetLabel("Item ID to delete: ")

	// Create a form that lets the user add or delete items
	form := tview.NewForm().
		AddFormItem(itemNameInput).    // Add the item name input to the form
		AddFormItem(itemStockInput).   // Add the item stock input to the form
		AddFormItem(itemIDInput).      // Add the item ID input for deletion
		AddButton("Add Item", func() { // Button to add a new item
			// Get the text input for name and stock
			name := itemNameInput.GetText()
			stock := itemStockInput.GetText()
			// Check if both fields are filled
			if name != "" && stock != "" {
				// Convert the stock input to an integer
				quantity, err := strconv.Atoi(stock)
				if err != nil {
					fmt.Fprintln(inventoryList, "Invalid stock value.")
					return
				}
				// Add the new item to the inventory slice
				inventory = append(inventory, Item{Name: name, Stock: quantity})
				// Save the updated inventory
				saveInventory()
				// Refresh the inventory display
				refreshInventory()
				// Clear the input fields after adding the item
				itemNameInput.SetText("")
				itemStockInput.SetText("")
			}
		}).
		AddButton("Delete Item", func() { // Button to delete an item
			idStr := itemIDInput.GetText()
			// Ensure the ID field is not empty
			if idStr == "" {
				fmt.Fprintln(inventoryList, "Please enter an item ID to delete.")
				return
			}
			// Convert the ID to an integer and check if it's valid
			id, err := strconv.Atoi(idStr)
			if err != nil || id < 1 || id > len(inventory) {
				fmt.Fprintln(inventoryList, "Invalid item ID.")
				return
			}
			// Delete the item (adjust for zero-based index)
			deleteItem(id - 1)
			fmt.Fprintf(inventoryList, "Item [%d] deleted.\n", id)
			// Refresh the inventory display after deletion
			refreshInventory()
			itemIDInput.SetText("") // Clear the ID input field
		}).
		AddButton("Exit", func() { // Button to exit the application
			app.Stop()
		})

	// Set a border and title for the form
	form.SetBorder(true).SetTitle("Manage Inventory").SetTitleAlign(tview.AlignLeft)

	// Create a layout using Flex to display the inventory list and the form side by side
	flex := tview.NewFlex().
		AddItem(inventoryList, 0, 1, false). // Left side: inventory list
		AddItem(form, 0, 1, true)            // Right side: form for adding/deleting items

	// Initial inventory display
	refreshInventory()

	// Start the TUI application
	if err := app.SetRoot(flex, true).Run(); err != nil {
		panic(err)
	}
}


---

