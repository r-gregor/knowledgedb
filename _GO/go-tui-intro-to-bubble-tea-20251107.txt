filename: go-tui-intro-to-bubble-tea-20251107.txt
https://dev.to/andyhaskell/intro-to-bubble-tea-in-go-21lg

Make slick command-line apps with Bubble Tea (2 Part Series)

[part-1]Intro to Bubble Tea in Go

Doing stuff in the command line is cool and can make you feel like you're the hero in a hacker movie. But it
can also feel old-school with monochromatic avalanches of text, or intimidating with all the command line
flags and dollar sign prefixes and different ways to break things without warning.

But the command line isn't the only way to use your terminal, there's also TUIs, terminal user interfaces,
which give a more user-friendly feel to your program. I really like TUIs because they feel like the new and
the old at the same time. And in Go, lately the Bubble Tea library, and all of Charm Bracelet's other tools,
has been getting a lot of attention for making it easy to make TUIs.

The advantages of Bubble Tea that have jumped out at me so far are:

    Uses the Elm architecture that's shared with browser UI frameworks, so if you've already done some React,
    Vue, or Elm, it will feel familiar The Elm architecture isn't just familiar for modern frontend devs, it's
    a great way to organize UI code, so it's conducive to building starting your app simple and growing its
    logic in a manageable way Because it's in Go, the language's consistent syntax is conducive to learning by
    reading other people's code

In this series, I'm going to be building a basic TUI app from the ground up for logging what you've been
learning in code each day if you're doing a program like #100Devs or one of the ones in the #100DaysOfCode
family. At the time I'm writing this it's not finished yet, so each tutorial will be about looking at specific
concepts. The approximate roadmap is going to be:

 * Writing a simple hello world app and seeing how its architecture works
 * Building our first real Bubble Tea component, a menu
 * Making our menu look cool with some styling, using the CSS-like Lipgloss library
 * Adding routing to our app to display different pages
 * Using Bubble Tea components other people have made, using the Bubbles library
 * Saving our check-ins to a JSON file

So get your terminal ready, and a boba-sized straw because without further ado it's time to jump into Bubble Tea!

Writing our first basic app
As a first step, we're going to make a "hello world" app in Bubble Tea that you exit by pressing Ctrl+C, which
will also introduce us to each part of a Bubble Tea app.

First, in a new directory titled "code-journal", run:

$> go mod init
$> go get github.com/charmbracelet/bubbletea

Then, create a file called app.go and add the following code:

package main

import (
	tea "github.com/charmbracelet/bubbletea"
)

func main() {
	p := tea.NewProgram(
		newSimplePage("This app is under construction"),
	)

	if err := p.Start(); err != nil {
		panic(err)
	}
}


Then, let's make another file called simple_page.go that contains our first UI, a simple page that just
displays some text:

package main

import (
	"fmt"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
)

// MODEL DATA
type simplePage struct { text string }

func newSimplePage(text string) simplePage {
	return simplePage{text: text}
}

func (s simplePage) Init() tea.Cmd { return nil }

// VIEW
func (s simplePage) View() string {
	textLen := len(s.text)
	topAndBottomBar := strings.Repeat("*", textLen + 4)
	return fmt.Sprintf(
		"%s\n* %s *\n%s\n\nPress Ctrl+C to exit",
		topAndBottomBar, s.text, topAndBottomBar,
	)
}

// UPDATE
func (s simplePage) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg.(type) {
	case tea.KeyMsg:
		switch msg.(tea.KeyMsg).String() {
		case "ctrl+c":
			return s, tea.Quit
		}
	}
	return s, nil
}


Before we break down the code, let's run it and see what it does. In your terminal, run:

$> go build
$> ./code-journal

and you should see something like this:

 [img][Terminal displaying the text]

Cool! You've got your first Bubble Tea app running. Now let's take a closer look at the code.

Model is the main interface of Bubble Tea
The main function starts the program by creating a new program with the simplePage model.

func main() {
	p := tea.NewProgram(
		newSimplePage("This app is under construction"),
	)

	if err := p.Start(); err != nil {
		panic(err)
	}
}

We call tea.NewProgram, whose signature is:
func NewProgram(initialModel Model) *Program

and then calling that program's Start method starts our app. But what is the initialModel?

Model is the main interface of Bubble Tea. It has three methods:

type Model interface {
	Init() Cmd
	Update(msg Msg) (Model, Cmd)
	View() string
}

The Init method is called when the app starts, returning a tea.Cmd. A Cmd is more or less "stuff happening
behind the scenes" like loading data, or time flowing. But for the current tutorial, we don't have any
background stuff, so our init method just returns nil.

func (s simplePage) Init() tea.Cmd { return nil }

Next up, we've got the View method. One of the cool abstractions of Bubble Tea is that your whole UI's display
is a string! And View is where you make that string.

func (s simplePage) View() string {
	textLen := len(s.text)
	topAndBottomBar := strings.Repeat("*", textLen + 4)

	return fmt.Sprintf(
		"%s\n* %s *\n%s\n\nPress Ctrl+C to exit",
		topAndBottomBar, s.text, topAndBottomBar,
	)
}

So we put the text of our simplePage in a box made of asterisks, with a message at the bottom saying "Press
Ctrl+C to exit"

But we can't exit our app if it doesn't handle user input, so that's where our Update method comes in.

func (s simplePage) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg.(type) {
	case tea.KeyMsg:
		switch msg.(tea.KeyMsg).String() {
		case "ctrl+c":
			return s, tea.Quit
		}
	}
	return s, nil
}

The Update method takes in a tea.Msg and returns a new tea.Model and sometimes a tea.Cmd (like if an action
results in retrieving some data or a timer going off).

A tea.Msg's type signature is

type Msg interface {}

So it can be any type and carry as much or as little data as you need. It's sort of like a browser event in
JavaScript if you've done frontend there; a timer event doesn't carry any data, a click event tells you what
clicked on, etc.

The kind of message we're processing is tea.KeyMsg, which represents keyboard input. We're checking if the
user pressed Ctrl+C, and if so, we return the tea.Quit command, which is of the type tea.Cmd and tells Bubble
Tea to exit the app.

For any other kind of input though, we don't do anything. We just return the model as-is. If we were doing
something though like UI navigation, though, we would change some fields on the Model and then return it,
causing the UI to update. And that's what we're going to see in the next tutorial where we make a menu
component!


---
https://dev.to/andyhaskell/processing-user-input-in-bubble-tea-with-a-menu-component-222i

[part-2]Processing user input in Bubble Tea with a menu component

In the last tutorial, we did a "hello world" app, and it processed just a bit of user input ("press Ctrl+C to
exit").

But we didn't really get a feel for actually using user input to change the model's data, and in turn change
what we see in the app. So in this tutorial, we're going to create a menu component that lets us move between
buttons.

Defining our data
The first thing we need for any Bubble Tea component is the data our model is in charge of. If you recall, in
our simplePage model, the data was just the text we were displaying:
type simplePage struct { text string }

In our menu, what we need to do is:
 * Display our options
 * Show which option is selected
 * Additionally, let the user press the enter to go to another page. But we'll add that in a later tutorial.
    - For now, we can still make an onPress function passed in that tells us what we do if the user presses
      enter.

So our model's data will look like this; if you're following along, write this in a file named menu.go.

type menu struct {
	options       []menuItem
	selectedIndex int
}

type menuItem struct {
	text          string
	onPress       func() tea.Msg
}


A menu is made up of menuItems, and each menuItem has text and a function handling pressing enter. In this
tutorial we'll just have the app toggle between all-caps and all-lowercase so it's at least doing something.

It returns a tea.Msg because that's we're able to change the data in response to this user input. We'll see
why in the next section, when we're implementing the Model interface.

Implementing the Model interface
If you recall, for us to use our model as a UI component, it needs to implement this interface:

type Model interface {
	Init() Cmd
	Update(msg Msg) (Model, Cmd)
	View() string
}

First let's write the Init function.
func (m menu) Init() tea.Cmd { return nil }


Again, we still don't have any initial Cmd we need to run, so we can just return nil.
For the View function, let's make an old-school menu with an arrow to tell us which item is currently
selected.

func (m menu) View() string {
	var options []string
	for i, o := range m.options {
		if i == m.selectedIndex {
			options = append(options, fmt.Sprintf("-> %s", o.text))
		} else {
			options = append(options, fmt.Sprintf("   %s", o.text))
		}
	}
	return fmt.Sprintf(`%s

Press enter/return to select a list item, arrow keys to move, or Ctrl+C to exit.`,
    strings.Join(options, "\n"))
}

As mentioned in the last tutorial, one of the things that makes Bubble Tea really learnable is that the
display for your UI is basically one big string. So in menu.View we make a slice of strings where the selected
option has an arrow and the non-selected options have leading spaces. Then we join them all together and add
our contols to the bottom.

Finally, let's write our Update method to handle user input.

func (m menu) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg.(type) {
	case tea.KeyMsg:
		switch msg.(tea.KeyMsg).String() {
			case "ctrl+c":
				return m, tea.Quit
			case "down", "right", "up", "left":
				return m.moveCursor(msg.(tea.KeyMsg)), nil
		}
	}
	return m, nil
}

func (m menu) moveCursor(msg tea.KeyMsg) menu {
	switch msg.String() {
		case "up", "left":
			m.selectedIndex--
		case "down", "right":
			m.selectedIndex++
		default:
			// do nothing
	}

	optCount := len(m.options)
	m.selectedIndex = (m.selectedIndex + optCount) % optCount
	return m
}

The Update method is the most complex part of this app, so let's break that down.

case "ctrl+c":
	return m, tea.Quit

Like before, we're handling the KeyMsg type, and we're the Ctrl+C keypress to quit the app by returning the
Quit cmd.

case "down", "right", "up", "left":
	return m.moveCursor(msg.(tea.KeyMsg)), nil

For the arrow keys, though, we use a helper function, moveCursor, which returns an updated model.

func (m menu) moveCursor(msg tea.KeyMsg) menu {
	switch msg.String() {
		case "up", "left":
			m.selectedIndex--
		case "down", "right":
			m.selectedIndex++
		default:
			// do nothing
	}

	optCount := len(m.options)
	m.selectedIndex = (m.selectedIndex + optCount) % optCount
	return m
}

The up and left KeyMsg strings serve as our "navigate up" keys, and the down and right ones navigate us down,
decrementing and incrementing m.selected.

Then, we use the mod operator to ensure that m.selected is one of the indices of our options.

Finally, with the model updated, moveCursor returns the model that in turn is returned by Update, and the new
model ultimately gets processed by our View method.

Before we move on to processing the enter key though, we should see our app run. So let's put our new menu
component into a main function and run it.

func main() {
	m := menu{
		options: []menuItem{
			menuItem{
				text: "new check-in",
				onPress: func() tea.Msg { return struct{}{} },
			},
			menuItem{
				text: "view check-ins",
				onPress: func() tea.Msg { return struct{}{} },
			},
		},
	}

	p := tea.NewProgram(m)
	if err := p.Start(); err != nil {
		panic(err)
	}
}

For now, onPress is just a no-op that returns an empty struct. Now, let's run our app.

$> go build
$> ./check-ins

You should see something like this:

 [img][List of options you can select, with an arrow pointed to the selected one, and instructions at the bottom]

Cool! Now the menu can toggle what's selected! Now let's handle that user input.

Handling the enter key and seeing what the tea.Cmd type actually does
So far, we haven't really taken a close look at the tea.Cmd type. It's one of the two return values for the
Update method, but we've only used it so far to exit the app. Let's take a closer look at its type signature.
type Cmd func() tea.Msg

A Cmd is some sort of function that does some stuff, and then gives us back a tea.Msg. That function can be
time passing, it can be I/O like retrieving some data, really anything goes! The tea.Msg in turn gets used by
our Update function to update our model and finally our view.

So handling a user pressing the enter key, and then running an arbitrary onPress function, is one such way to
use a Cmd. So let's start with an enter button handler.

	case tea.KeyMsg:
		switch msg.(tea.KeyMsg).String() {
			case "q":
				return m, tea.Quit
			case "down", "right", "up", "left":
				return m.moveCursor(msg.(tea.KeyMsg)), nil
+			case "enter", "return":
+				return m, m.options[m.selectedIndex].onPress
	}


Notice that when the user presses enter, we return the model, unchanged, but we also return the selected
item's onPress function. If you recall when we defined the menuItem type, the type of its onPress field was
func() tea.Msg. In other words, that exactly matches the Cmd type alias!

There's one other thing we need to do inside the Update method though. Right now, we're only handling the
tea.KeyMsg type. The type we're returning for toggling the selected item's capitalization will be a brand new
type ot tea.Msg, so we need to define it, and then add a case to our Update method for it. First, let's define
the struct.
type toggleCasingMsg struct{}

We don't need any data to be passed in, so our Msg is just an empty struct; if you recall, the tea.Msg type is
just an empty interface, so we can have a Msg contain as much or as little data as we need.

Now back in the Update method, let's add a case for toggleCasingMsg!

First add the method toggleSelectedItemCase

func (m menu) toggleSelectedItemCase() tea.Model {
	selectedText := m.options[m.selectedIndex].text

	if selectedText == strings.ToUpper(selectedText) {
		m.options[m.selectedIndex].text = strings.ToLower(selectedText)
	} else {
		m.options[m.selectedIndex].text = strings.ToUpper(selectedText)
	}
	return m
}

Then add it to the Update method.

	func (m menu) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
		switch msg.(type) {
+			case toggleCasingMsg:
+				return m.toggleSelectedItemCase(), nil
			case tea.KeyMsg:
				// our KeyMsg handlers here

On a toggleCasingMsg, we update the casing of the selected menu item, and then return the updated model.

Finally, in app.go, let's use our toggleCasingMsg

	menuItem{
		text:    "new check-in",
-		onPress: func() tea.Msg { return struct{}{} },
+		onPress: func() tea.Msg { return toggleCasingMsg{} },
	},
	menuItem{
		text:    "view check-ins",
-		onPress: func() tea.Msg { return struct{}{} },
+		onPress: func() tea.Msg { return toggleCasingMsg{} },
	},

Now let's try our app out!

$> go build
$> ./check-ins

The app should now look like this:

  [img][List of options you can select, with an arrow pointed to the selected one that's now in all caps
        because the user had pressed enter, and instructions at the bottom]

Note, by the way, that at this stage of the app, this isn't the only way we could have processed enter; we
also could have just processed all the toggling entirely in the update function, rather than having to process
it with a Cmd. The reason I chose to use a Cmd were:
 * To show a simple use case for a non-Quit Cmd in Bubble Tea
 * By using a Cmd, we can pass arbitrary event handler functions into our components, a similar pattern if
   you've coded in React.

Next up, we've got a menu, but it's not very flashy just yet. In the next tutorial, we'll see how to use
Bubble Tea to make our app look cool; first by hand, then with Bubble Tea's CSS-like Lip Gloss package!


---

