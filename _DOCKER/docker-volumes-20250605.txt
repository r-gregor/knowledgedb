filename: docker-volumes-20250605.txt
https://spacelift.io/blog/docker-volumes

Docker Volumes - Guide with Examples
23 Mar 2023

   Docker containers are easiest to use with stateless applications because their filesystems are
   ephemeral in nature. Changes made to a container's environment are lost when the container stops,
   crashes, or gets replaced.

   You can Dockerize stateful applications such as databases and file servers by attaching volumes
   to your containers. Volumes provide persistent storage that's independent of individual containers.
   You can reattach volumes to a different container after a failure or use them to share data between
   several containers simultaneously.

   In this article, you'll learn what volumes are and the use cases they enable. We'll also cover some
   practical examples of using volumes with Docker and Docker Compose.

What Are Docker Volumes?
   Volumes are a mechanism for storing data outside containers. All volumes are managed by Docker and
   stored in a dedicated directory on your host, usually /var/lib/docker/volumes for Linux systems.

   Volumes are mounted to filesystem paths in your containers. When containers write to a path beneath a
   volume mount point, the changes will be applied to the volume instead of the container's writable
   image layer. The written data will still be available if the container stops - as the volume's stored
   separately on your host, it can be remounted to another container or accessed directly using manual
   tools.

   Volumes work with both Linux and Windows containers. Several different drivers are available to
   store volume data in different services. Local storage on your Docker host is the default, but NFS
   volumes, CIFS/Samba shares, and device-level block storage adapters are available as alternatives.
   Third-party plugins can add extra storage options too.

Bind Mounts vs. Docker Volumes
   Bind mounts are another way to give containers access to files and folders on your host. They
   directly mount a host directory into your container. Any changes made to the directory will be
   reflected on both sides of the mount, whether the modification originates from the host or within the
   container.

   Bind mounts are best used for ad-hoc storage on a short-term basis. They're convenient in development
   workflows. For example: bind mounting your working directory into a container automatically
   synchronizes your source code files, allowing you to immediately test changes without rebuilding your
   Docker image.

   Volumes are a better solution when you're providing permanent storage to operational containers.
   Because they're managed by Docker, you don't need to manually maintain directories on your host.
   There's less chance of data being accidentally modified and no dependency on a particular folder
   structure. Volume drivers also offer increased performance and the possibility of writing changes
   directly to remote locations.

When to Use Docker Volumes?
   Volumes are designed to support the deployment of stateful Docker containers. You'll need to use a
   volume when a container requires persistent storage to permanently save new and modified files.

   Typical volume use cases include the following:
     * Database storage - You should mount a volume to the storage directories used by databases such as
       MySQL, Postgres, and Mongo. This will ensure your data persists after the container stops.
     * Application data - Data generated by your application, such as file uploads, documents, and
       profile photos, should be stored in a volume.
     * Essential caches - Consider using a volume to persist the contents of any caches, which would
       take significant time to rebuild.
     * Convenient data backups - Docker's centralized volume storage makes it easy to backup container
       data by mirroring /var/lib/docker/volumes to another location. Community tools and Docker
       Desktop extensions can automate the process, providing a much simpler experience than manually
       copying individual bind-mounted directories.
     * Share data between containers - Docker volumes can be mounted to multiple containers
       simultaneously. Containers have real-time access to the changes made by their neighbors.
     * Write to remote filesystems - You'll need to use a volume when you want containers to write to
       remote filesystems and network shares. This can facilitate simpler workflows for applications
       that interact with your LAN resources.

   You don't need to mount a volume to containers that don't have writable filesystem paths or that only
   store disposable content. As a general rule, create a volume when your container's writing data which
   will cause disruption if it's lost.

Example: Using Docker Volumes
   Let's see how volumes work. You can start a container with a volume by setting the -v flag when you
   call docker run.

   The following command starts a new Ubuntu 22.04 container and attaches your terminal to it (-it),
   ready to run demonstration commands in the following steps. A volume called demo_volume is mounted to
   /data inside the container. Run the command now:
$> docker run -it -v demo_volume:/data ubuntu:22.04

   List the contents of your container's /data directory:
$> ls /data

   The path exists, indicating the volume has mounted successfully, but no files have been created yet.

   Add a test file with some arbitrary content:
$> echo "foobar" > /data/foo

$> cat /data/foo
foobar

   Next, detach from your container by pressing Ctrl+C or running exit:
$> exit
exit

   The container will immediately stop because there's no other process running within it.

   Now, start a new container that attaches the same volume:
$> docker run -it -v demo_volume:/app alpine:latest

   The demo_volume volume already exists so Docker will reuse it instead of creating a new one. This
   time, the volume is mounted to a different path inside the container, but when you list the path's
   content, you'll see the file that the first container created:
$> cat /app/foo
foobar

   Docker persisted the volume's content after the first container stopped, allowing it to be reused
   with your replacement container.

Manually Creating and Linking Volumes
   This example above demonstrated how Docker automatically creates volumes when you reference a new
   name for the first time. You can manually create volumes ahead of time with the docker volume create
   command:
$> docker volume create app_data
app_data

   The volume can then be mounted to your containers in the same way as before:
$> docker run -it -v app_data:/app alpine:latest

Populating Volume Content
   You can mount volumes to container paths that already contain data. When this happens, Docker will
   copy the existing container data into your new volume. This prevents accidental data loss. Other
   containers which use the volume will also see the content that's been populated from neighboring
   mount points.

Mounting Volumes as Read-Only
   Volumes are mounted in read-write mode by default. To mount a volume in read-only mode, include ro or
   readonly as the third field in your docker run command's -v flag:
$> docker run -it -v app_data:/app:ro alpine:latest

   The container will be able to read the volume's content from the mount point but will be prevented
   from making modifications. This is ideal when a volume's shared between multiple containers, only
   some of which are expected to perform writes.

   Write operations in containers with a readonly mount will fail with an error:
$> echo "foo" > /app/bar
/bin/sh: can't create /app/bar: Read-only file system

Reusing Volumes When Containers Start
   Sometimes you might want to start a new container with the same volumes as an existing container on
   your host. Instead of repeating the list of -v flags required, you can use --volumes-from to
   automatically include another container's volumes:
# Create the first container
$> docker run -d --name db -v app_data:/data database-image:latest

# Create the second container
$> docker run -d --name backup --volumes-from db backup-image:latest

   Docker will mount all the volumes that are already attached to the existing container. The same
   destination paths will be used to mount the volumes into your new container.

   This feature is useful when you're backing up an existing container's volumes. You can easily mount a
   target container's volumes into a new container running a dedicated backup image.

Using Volumes in Dockerfiles
   Docker allows images to define volume mount points with the VOLUME Dockerfile instruction. When a
   container is started from an image, Docker will automatically create new volumes for the mount points
   listed in the Dockerfile.

   The following Dockerfile will always mount a volume to /app_data inside the container, even if you
   call docker run without the -v flag:
FROM ubuntu:22.04
VOLUME /app_data

   You can still manually mount a new or existing volume to paths referenced by VOLUME instructions. The
   -v flag overrides the Dockerfile's content:
$> docker run -v custom_volume:/app_data app-image:latest

   The VOLUME instruction ensures that critical paths are always persisted when users start a new
   container. However, it should be treated carefully because users won't necessarily expect this
   behavior. Using VOLUME removes the choice of creating a purely ephemeral container for debugging or
   testing purposes.

Interacting With Docker Volumes
   The Docker CLI includes a set of commands for interacting with the volumes on your host.

   List all your volumes with docker volume ls:
$> docker volume ls
DRIVER      VOLUME NAME
local       app_data
local       demo_volume

   You'll see the name of each volume and the storage driver it's backed by. To access more detailed
   information about a specific volume, use docker volume inspect instead:
$> docker volume inspect demo_volume
[
	{
		"CreatedAt": "2023-03-16T14:05:55Z",
		"Driver": "local",
		"Labels": null,
		"Mountpoint": "/var/lib/docker/volumes/demo_volume/_data",
		"Name": "demo_volume",
		"Options": null,
		"Scope": "local"
	}
]

   Delete a volume with docker volume rm:
$> docker volume rm demo_volume
demo_volume

   Volumes which are currently mounted to a container can't be deleted unless you add the -f (force)
   flag:
$> docker volume rm app_data -f

   Finally, you can clean up all unused volumes with docker volume prune. The command deletes volumes
   that aren't mounted to at least one container. You'll be shown a confirmation prompt before the prune
   begins. After it completes, the total amount of freed disk space will be displayed in your terminal.
$> docker volume prune
WARNING! This will remove all local volumes not used by at least one container.
Total reclaimed space: 6B

   Check out other Docker CLI commands in our [**1][https://spacelift.io/blog/docker-commands-cheat-sheet]Docker
   cheat sheet.

Using Volumes With Docker Compose
   Volumes can also be defined and used in Docker Compose. In your docker-compose.yml file, add a
   top-level volumes field that lists the volumes to create, then mount your volumes into your
   containers within the services section:
services:
| app:
| | image: app-image:latest
| | volumes:
| | | - app_data:/data
volumes:
| app_data:

   Compose automatically creates and mounts your volumes when you run docker compose up. To use an
   existing volume, add it to the volumes section of your docker-compose.yml file and set the external
   flag to true:
volumes:
| demo_volume:
| | external: true

Key Points
   Docker volumes provide persistent storage for your containers. Docker manages the data in your
   volumes separately to your containers. Volumes can be attached to multiple containers simultaneously,
   remain accessible after the containers they're mounted to are stopped, and can be centrally managed
   using the Docker CLI.

   Mount a volume whenever your containerized applications need to permanently store filesystem changes.
   Data stored in volumes is protected against container failures and restarts, but changes to any other
   paths in the container will be lost.


---
[**1]
https://spacelift.io/blog/docker-commands-cheat-sheet

Docker Cheat Sheet - 36 Docker CLI Commands
23 Jun 2023

   Need a quick reference for commonly used docker CLI commands? You're in the right place.

   The docker CLI is the command-line tool used to interact with a Docker installation. You need it to
   start containers, build images, interact with the Docker resources on your machine, and manage
   configuration settings.

   In this article, we'll provide a brief description for the majority of the main docker commands. You
   can use this list to learn more about Docker's functionality, or simply find out how to use a
   particular feature.

Docker CLI Commands Cheat Sheet
   Here's a quick table of contents:
    1. General Commands
    2. Build Images
    3. Run Containers
    4. Manage Containers
    5. Copy to and From Containers
    6. Execute Commands in Containers
    7. Access Container Logs
    8. View Container Resource Utilization
    9. Manage Images
   10. Manage Networks
   11. Manage Volumes
   12. Use Configuration Contexts
   13. Create SBOMs
   14. Scan for Vulnerabilities
   15. Docker Hub Account
   16. Clean Up Unused Resources

   If you need more help installing and getting started with Docker, check out our Docker tutorial
   for beginners.

   Let's dive into the commands cheat sheet!

General Commands
   First up, here are some basics to get you started:

   docker version :-> Displays detailed information about your Docker CLI and daemon versions.

   docker system info :-> Lists data about your Docker environment, including active plugins and the
   number of containers and images on your system.

   docker help :-> View the help index, a reference of all the supported commands.

   docker <command> --help :-> View the help information about a particular command, including detailed
   information on the supported option flags.

Build Images
   These commands relate to building new images from Dockerfiles:

   docker build . :-> Build the Dockerfile in your working directory into a new image.

   docker build -t example-image:latest . :-> Build the Dockerfile in your working directory and tag the
   resulting image as example-image:latest.

   docker build -f docker/app-dockerfile :-> Build the Dockerfile at the docker/app-dockerfile path.

   docker build --build-arg foo=bar . :-> Build an image and set the foo build argument to the value
   bar. Read more: What are Docker Build Args & How to Use Them

   docker build --pull . :-> Instructs Docker to pull updated versions of the images referenced in FROM
   instructions in your Dockerfile, before building your new image.

   docker build --quiet . :-> Build an image without emitting any output during the build. The image ID
   will still be emitted to the terminal when the build completes.

Run Containers
   After building an image, use these commands to run containers:

   docker run example-image:latest :-> Run a new container using the example-image:latest image. The
   output from the container's foreground process will be shown in your terminal.

   >docker run example-image:latest demo-command :-> Supplying an argument after the image name sets the
   command to run inside the container; it will be appended to the image's entrypoint. (It's
   possible to override the entrypoint with the docker run command's --entrypoint flag.)

   docker run --rm example-image:latest :-> The --rm flag instructs Docker to automatically remove the
   container when it exits instead of allowing it to remain as a stopped container.

   docker run -d example-image:latest :-> Detaches your terminal from the running container, leaving the
   container in the background.

   docker run -it example-image:latest :-> Attaches your terminal's input stream and a TTY to the
   container. Use this command to run interactive commands inside the container.

   docker run --name my-container example-image:latest :-> Names the new container my-container.

   docker run --hostname my-container example-image:latest :-> Set the container's hostname to a specific
   value (it defaults to the container's name).

   docker run --env foo=bar example-image:latest :-> Set the value of the foo environment variable inside
   the container to bar.

   docker run --env-file config.env example-image:latest :-> Populate environment variables inside the
   container from the file config.env. The file should contain key-value pairs in the format foo=bar.
   Read more: How to run environment variables in a Docker container.

   docker run -p 8080:80 example-image:latest :-> Bind port 8080 on your Docker host to port 80 inside the
   container. It allows you to visit localhost:8080 to access the network service listening on port 80
   inside the container.

   docker run -v /host-directory:/container-directory example-image:latest :-> Bind mount /host-directory
   on your host to /container-directory inside the container. The directory's contents will be visible
   on both sides of the mount.

   docker run -v data:/data example-image:latest :-> Mount the named Docker volume called data to
   /data inside the container.

   docker run --network my-network example-image:latest :-> Connect the new container to the Docker
   network called my-network.

   docker run --restart unless-stopped example-image:latest :-> Set the container to start automatically
   when the Docker daemon starts, unless the container has been manually stopped. Other restart
   policies are also supported.

   docker run --privileged example-image:latest :-> Run the container with privileged access to the
   host system. This should usually be disabled to maintain security.

Manage Containers
   After you've started some containers, you can use the following set of commands to manage them:

   docker ps :-> List all the containers currently running on your host.

   docker ps -a :-> List every container on your host, including stopped ones.

   docker attach <container> :-> Attach your terminal to the foreground process of the container with the
   ID or name <container>.

   docker commit <container> new-image:latest :-> Save the current state of <container> to a new image
   called new-image:latest.

   docker inspect <container> :-> Obtain all the information Docker holds about a container, in JSON
   format.

   docker kill <container> :-> Send a SIGKILL signal to the foreground process running in a container, to
   force it to stop.

   docker rename <container> my-container :-> Rename a specified container to my-container.

   docker pause <container> and docker unpause <container> :-> Pause and unpause the processes running
   within a specific container.

   docker stop <container> :-> Stop a running container.

   docker start <container> :-> Start a previously stopped container.

   docker rm <container> :-> Delete a container by its ID or name. Use the -f (force) flag to delete a
   container that's currently running.

   Read more: How to Stop and Remove Docker Containers.

Copy to and From Containers
   The docker cp command facilitates bi-directional copying between containers and your host
   machine:

   docker cp example.txt my-container:/data :-> Copy example.txt from your host to /data inside the
   my-container container.

   docker cp my-container:/data/example.txt /demo/example.txt :-> Copy /data/example.txt out of the
   my-container container, to /demo/example.txt on your host.

   If you need to move files or folders between two containers, you should copy from the first container
   to your host, then onwards into the second container.

Execute Commands in Containers
   The docker exec command allows you to run a new process inside a currently running container:

   docker exec my-container demo-command :-> Run demo-command inside my-container; the process' output
   will be shown in your terminal

   docker exec -it my-container demo-command :-> Run a command interactively by attaching your terminal's
   input stream and a pseudo-TTY.

Access Container Logs
   docker logs <container> :-> This command streams the existing log output from a container into your
   terminal window, then exits.

   docker logs <container> --follow :-> This variation emits all existing logs, then continues to stream
   new logs into your terminal as they're stored.

   docker logs <container> -n 10 :-> Get the last 10 logs from a container.

   Logs are collated from the standard output and error streams emitted by the container's foreground
   process.

View Container Resource Utilization
   docker stats <container> :-> Stream a container's resource utilization information into your terminal.
   The output includes CPU, memory, and I/O usage, as well as the number of processes running within the
   container.

Manage Images
   The following commands interact with images stored on your Docker host:

   docker images :-> List all stored images.

   docker rmi <image> :-> Delete an image by its ID or tag. Deletion of images which have multiple tags
   must be forced using the -f flag.

   docker tag <image> example-image:latest :-> Add a new tag (example-image:latest) to an existing image
   (<image>).

Pull and Push Images
   docker push example.com/user/image:latest :-> Push an image from your Docker host to a remote registry.
   The image is identified by its tag, which must reference the registry you're pushing to.

   docker pull example.com/user/image:latest :-> Manually pull an image from a remote registry to make it
   available on your host.

   When the image's tag omits a registry URL, the Docker Hub registry will be used as the default.

Manage Networks
   These commands administer the Docker networks on your host:

   docker create network my-network :-> Create a new network called my-network; it will default to using
   the bridge driver.

   docker create network my-network -d host :-> Use the -d flag to select an alternative driver, such as
   host.

   docker network connect <network> <container> :-> Connect a container to an existing network.

   docker network disconnect <network> <container> :-> Remove a container from a network it's currently
   connected to.

   docker network ls :-> List all the Docker networks available on your host, including built-in networks
   such as bridge and host.

   docker network rm <network> :-> Delete a network by its ID or name. This is only possible when there
   are no containers currently connected to the network.

Manage Volumes
   The following commands relate to the management of storage volumes:

   docker volume create my-volume :-> Create a new named volume called my-volume.

   docker volume ls :-> List the volumes present on your host.

   docker volume rm :-> Delete a volume, which will destroy the data within it. The volume must not be
   used by any container.

Use Configuration Contexts
   Configuration contexts allow you to connect to multiple Docker daemon instances from a single
   installation of the Docker CLI.

   docker context create my-context --host=tcp://host:2376,ca=~/ca-file,cert=~/cert-file,key=~/key-file
   :-> Create a new context called my-context to connect to a specified Docker host.

   docker context update <context> :-> Modify the configuration of a named context; the command accepts
   the same arguments as docker context create.

   docker context ls :-> List the contexts available in your Docker config file.

   docker context use <context> :-> Switch to a named context. Subsequent docker commands will be executed
   against the Docker host configured in the newly selected context.

   docker context rm <context> :-> Delete a context by its name.

Create SBOMs
   Docker now has integrated SBOM generation capabilities. SBOMs are indexes of the packages
   included in your container images.

   docker sbom example-image:latest :-> Produce an SBOM for the image tagged example-image:latest. The
   SBOM will be shown in your terminal.

   docker sbom example-image:latest --output sbom.txt :-> Produce an SBOM and save it to sbom.txt.

   docker sbom example-image:latest --format spdx-json :-> Produce an SBOM in a standard machine-parseable
   format, such as SPDX (spdx-json), CycloneDX (cyclonedx-json), or Syft JSON (syft-json).

Scan for Vulnerabilities
   Docker also has a built-in image vulnerability scanner that's powered by Snyk:

   docker scan example-image:latest :-> Scan for vulnerabilities in the image tagged example-image:latest.
   The results will be shown in your terminal.

   docker scan example-image:latest --file Dockerfile :-> The --file argument supplies the path to the
   Dockerfile that was used to build the image. When the Dockerfile is available, more detailed
   vulnerability information is produced.

   docker scan example-image:latest --severity high :-> Only report vulnerabilities that are high severity
   or higher. The --severity flag also supports low and medium values.

Docker Hub Account
   These commands interact with your Docker Hub account:

   docker login :-> Login to your account. You'll be prompted to supply credentials interactively. You
   must login before you can push images. Logging in also helps you avoid hitting public pull rate
   limits.

   docker logout :-> Logs you out of your account.

   docker search nginx :-> Searches Docker Hub for images matching the supplied search term (nginx, in
   this example).

Clean Up Unused Resources
   It's normal for a regularly used Docker installation to accumulate a large number of resources, many
   of which become redundant as you create replacements. These commands will clean up your environment:

   docker system prune :-> Removes unused data, including dangling image layers (images with no tags).

   docker system prune -a :-> Extends the prune process by deleting all unused images, instead of only
   dangling ones.

   docker system prune --volumes :-> Includes volume data in the prune process. This will delete any
   volumes that aren't used by a container.

   docker image prune :-> Removes dangling images, without affecting any other types of data.

   docker image prune -a :-> Removes all unused images.

   docker network prune :-> Removes unused networks.

   docker volume prune :-> Removes unused volumes.

   docker system df :-> Reports your Docker installation's total disk usage.

   The prune commands will prompt you to confirm your intentions before any resources are deleted. You
   can disable the prompt by setting the -f (force) flag.

Key Points
   The commands shown in this article are a quick reference for the most commonly used Docker CLI
   capabilities. If you need more information on any of the commands included in this article, you can
   check out the official documentation on the Docker website.


---

