filename: replace-recursive-with-iterative-or-stack-multif_20230516.txt
https://haacked.com/archive/2007/03/04/Replacing_Recursion_With_a_Stack.aspx/

Replacing Recursion With a Stack
Mar 4, 2007

   Less trivially, I've interviewed many candidates who can't use recursion to solve a real problem.

   A programmer who doesn't know how to use recursion isn't necessarily such a bad thing, assuming the
   programmer is handy with the Stack data structure. Any recursive algorithm can be replaced with a
   non-recursive algorithm by using a Stack.

   As an aside, I would expect any developer who knew how to use a stack in this way would probably have
   no problem with recursion.

   After all, what is a recursive method really doing under the hood but implicitely making use of the
   call stack?

   I'll demonstrate a method that removes recursion by explicitely using an instance of the Stack class,
   and I'll do so using a common task that any ASP.NET developer might find familiar. I should point out
   that I'm not recommending that you should or shouldn't do this with methods that use recursion. I'm
   merely pointing out that you can do this.

   In ASP.NET, a Web Page is itself a control (i.e. the Page class inherits from Control), that contains
   other controls. And those controls can possibly contain yet other controls, thus creating a tree
   structure of controls.

   So how do you find a control with a specific ID that could be nested at any level of the control
   hierarchy?

   Well the recursive version is pretty straightforward and similar to other methods I've written
   before.
public Control FindControlRecursively(Control root, string id) {
	Control current = root;

	if (current.ID == id)
		return current;

	foreach (Control control in current.Controls) {
		Control found = FindControlRecursively(control, id);
		if (found != null)
			return found;
	}
	return null;
}

   The recursion occures when we call FindControlRecursively within this method. Essentially what is
   happening (and this is a simplification) when we call that method is that our current execution point
   is pushed onto the call stack and the runtime starts executing the code for the internal method call.
   When that method finally returns, we pop our place from the stack and continue executing.

   Rather than try to explain, let me just show you the non-recursive version of this method using a
   Stack.

public Control FindControlSansRecursion(Control root, string id) {
	//seed it.
	Stack<Control> stack = new Stack<Control>();
	stack.Push(root);

	while(stack.Count > 0) {
		Control current = stack.Pop();
		if (current.ID == id)
			return current;

		foreach (Control control in current.Controls) {
			stack.Push(control);
		}
	}

	//didn't find it.
	return null;
}

   One thing to keep in mind is that both of these implementations assume that we won't run into a
   circular reference problem in which a child control contains an ancestor node.

   For the System.Web.UI.Control class we safe in making this assumption. If you try and create a
   circular reference, a StackOverflowException is thrown. The following code demonstrates this point.

Control control = new Control();
control.Controls.Add(new Control());

// This line will throw a StackOverflowException.
control.Controls[0].Controls.Add(control);

   If the hierarchical structure you are using does allow circular references, you'll have to keep track
   of which nodes you've already seen so that you don't get caught in any infinitel loops.
   Found a typo or mistake in the post? suggest edit



---
https://stackoverflow.com/questions/159590/way-to-go-from-recursion-to-iteration

Way to go from recursion to iteration

   I've used recursion quite a lot on my many years of programming to solve simple problems, but I'm
   fully aware that sometimes you need iteration due to memory/speed problems.

   So, sometime in the very far past I went to try and find if there existed any "pattern" or text-book
   way of transforming a common recursion approach to iteration and found nothing. Or at least nothing
   that I can remember it would help.
     * Are there general rules?
     * Is there a "pattern"?

***
   Usually, I replace a recursive algorithm by an iterative algorithm by pushing the parameters that
   would normally be passed to the recursive function onto a stack. In fact, you are replacing the
   program stack by one of your own.

var stack = [];
stack.push(firstObject);

// while not empty
while (stack.length) {

	// Pop off end of stack.
	obj = stack.pop();

	// Do stuff.
	// Push other objects on the stack as needed.
	...

}

   Note: if you have more than one recursive call inside and you want to preserve the order of the
   calls, you have to add them in the reverse order to the stack:

foo(first);
foo(second);

   has to be replaced by
stack.push(second);
stack.push(first);

     * 1
       Pushing just the parameters may not be sufficient. you need to push the local variables which are
       used subsequent to the point of recursive call. Also, the linked article provides a skeleton that
       is not suitable for implementations having recur. calls from deeper code blocks. I have tried to
       provide a repeatable method for converstion as an answer below.
***
   Really, the most common way to do it is to keep your own stack. Here's a recursive quicksort function
   in C:

void quicksort(int* array, int left, int right) {
	if(left >= right)
		return;

	int index = partition(array, left, right);
	quicksort(array, left, index - 1);
	quicksort(array, index + 1, right);
}

   Here's how we could make it iterative by keeping our own stack:

void quicksort(int *array, int left, int right) {
	int stack[1024];
	int i=0;

	stack[i++] = left;
	stack[i++] = right;

	while (i > 0) {
		right = stack[--i];
		left = stack[--i];

		if (left >= right)
			continue;

		int index = partition(array, left, right);
		stack[i++] = left;
		stack[i++] = index - 1;
		stack[i++] = index + 1;
		stack[i++] = right;
	}
}

   Obviously, this example doesn't check stack boundaries... and really you could size the stack based
   on the worst case given left and and right values. But you get the idea.

***
   It seems nobody has addressed where the recursive function calls itself more than once in the body,
   and handles returning to a specific point in the recursion (i.e. not primitive-recursive). It is said
   that every recursion can be turned into iteration, so it appears that this should be possible.

   I just came up with a C# example of how to do this. Suppose you have the following recursive
   function, which acts like a postorder traversal, and that AbcTreeNode is a 3-ary tree with pointers
   a, b, c.

public static void AbcRecursiveTraversal(this AbcTreeNode x, List<int> list) {
	if (x != null) {
		AbcRecursiveTraversal(x.a, list);
		AbcRecursiveTraversal(x.b, list);
		AbcRecursiveTraversal(x.c, list);
		list.Add(x.key);//finally visit root
	}
}

   The iterative solution:

int? address = null;
AbcTreeNode x = null;
x = root;
address = A;
stack.Push(x);
stack.Push(null);

	while (stack.Count > 0) {
		bool @return = x == null;

		if (@return == false) {

			switch (address) {
				case A://
					stack.Push(x);
					stack.Push(B);
					x = x.a;
					address = A;
					break;
				case B:
					stack.Push(x);
					stack.Push(C);
					x = x.b;
					address = A;
					break;
				case C:
					stack.Push(x);
					stack.Push(null);
					x = x.c;
					address = A;
					break;
				case null:
					list_iterative.Add(x.key);
					@return = true;
					break;
			}

		}


		if (@return == true) {
			address = (int?)stack.Pop();
			x = (AbcTreeNode)stack.Pop();
		}


	}

***
   Well, in general, recursion can be mimicked as iteration by simply using a storage variable. Note
   that recursion and iteration are generally equivalent; one can almost always be converted to the
   other. A tail-recursive function is very easily converted to an iterative one. Just make the
   accumulator variable a local one, and iterate instead of recurse. Here's an example in C++ (C were it
   not for the use of a default argument):

// tail-recursive
int factorial (int n, int acc = 1) {
	if (n == 1)
		return acc;
	else
		return factorial(n - 1, acc * n);
}

// iterative
int factorial (int n) {
	int acc = 1;
	for (; n > 1; --n)
		acc *= n;
	return acc;
}

***
   The stacks and recursion elimination article captures the idea of externalizing the stack frame
   on heap, but does not provide a straightforward and repeatable way to convert. Below is one.

   While converting to iterative code, one must be aware that the recursive call may happen from an
   arbitrarily deep code block. Its not just the parameters, but also the point to return to the logic
   that remains to be executed and the state of variables which participate in subsequent conditionals,
   which matter. Below is a very simple way to convert to iterative code with least changes.

   Consider this recursive code:

struct tnode {
	tnode(int n) : data(n), left(0), right(0) {}
	tnode *left, *right;
	int data;
};

void insertnode_recur(tnode *node, int num) {
	if(node->data <= num) {
		if(node->right == NULL)
			node->right = new tnode(num);
		else
			insertnode(node->right, num);
	} else {
		if(node->left == NULL)
			node->left = new tnode(num);
		else
			insertnode(node->left, num);
	}
}

   Iterative code:

// Identify the stack variables that need to be preserved across stack
// invocations, that is, across iterations and wrap them in an object
struct stackitem {
	stackitem(tnode *t, int n) : node(t), num(n), ra(0) {}
	tnode *node; int num;
	int ra; //to point of return
};

void insertnode_iter(tnode *node, int num) {
	vector<stackitem> v;
	//pushing a stackitem is equivalent to making a recursive call.
	v.push_back(stackitem(node, num));

	while(v.size()) {
		// taking a modifiable reference to the stack item makes prepending
		// 'si.' to auto variables in recursive logic suffice
		// e.g., instead of num, replace with si.num.
		stackitem &si = v.back();
		switch(si.ra) {
			// this jump simulates resuming execution after return from recursive
			// call
			case 1: goto ra1;
			case 2: goto ra2;
			default: break;
		}

		if(si.node->data <= si.num) {
			if(si.node->right == NULL) {
				si.node->right = new tnode(si.num);
			} else {
				// replace a recursive call with below statements
				// (a) save return point,
				// (b) push stack item with new stackitem,
				// (c) continue statement to make loop pick up and start
				//    processing new stack item,
				// (d) a return point label
				// (e) optional semi-colon, if resume point is an end
				// of a block.

				si.ra=1;
				v.push_back(stackitem(si.node->right, si.num));
				continue;
ra1:            ;
			}
		} else {
			if(si.node->left == NULL) {
				si.node->left = new tnode(si.num);
			} else {
				si.ra=2;
				v.push_back(stackitem(si.node->left, si.num));
				continue;
ra2:            ;
			}
		}

		v.pop_back();
	}
}

   Notice how the structure of the code still remains true to the recursive logic and modifications are
   minimal, resulting in less number of bugs. For comparison, I have marked the changes with ++ and --.
   Most of the new inserted blocks except v.push_back, are common to any converted iterative logic

void insertnode_iter(tnode *node, int num) {

	+++++++++++++++++++++++++
	vector<stackitem> v;
	v.push_back(stackitem(node, num));

	while(v.size()) {
		stackitem &si = v.back();
		switch(si.ra) {
			case 1: goto ra1;
			case 2: goto ra2;
			default: break;
		}

		------------------------
			if(si.node->data <= si.num) {
				if(si.node->right == NULL) {
					si.node->right = new tnode(si.num);
				} else {

					+++++++++++++++++++++++++
					si.ra=1;
					v.push_back(stackitem(si.node->right, si.num));
					continue;
ra1:            ;

				-------------------------
				}
			} else {
				if(si.node->left == NULL) {
					si.node->left = new tnode(si.num);
				} else {

					+++++++++++++++++++++++++
					si.ra=2;
					v.push_back(stackitem(si.node->left, si.num));
					continue;
ra2:            ;

				-------------------------
				}
			}

		+++++++++++++++++++++++++
		v.pop_back();
	}

	-------------------------
}

***
   Search google for "Continuation passing style." There is a general procedure for converting to a tail
   recursive style; there is also a general procedure for turning tail recursive functions into loops.

***
   Just killing time... A recursive function

void foo(Node* node) {
	if(node == NULL)
		return;
	// Do something with node...
	foo(node->left);
	foo(node->right);
}

   can be converted to

void foo(Node* node) {
	if(node == NULL)
		return;

	// Do something with node...

	stack.push(node->right);
	stack.push(node->left);

	while(!stack.empty()) {
		node1 = stack.pop();
		if(node1 == NULL)
			continue;
		// Do something with node1...
		stack.push(node1->right);
		stack.push(node1->left);
	}

}

***
   Thinking of things that actually need a stack:

   If we consider the pattern of recursion as:

	if(task can be done directly) {
		return result of doing task directly
	} else {
		split task into two or more parts
		solve for each part (possibly by recursing)
		return result constructed by combining these solutions
	}

   For example, the classic Tower of Hanoi

	if(the number of discs to move is 1) {
		just move it
	} else {
		move n-1 discs to the spare peg
		move the remaining disc to the target peg
		move n-1 discs from the spare peg to the target peg, using the current peg as a spare
	}

   This can be translated into a loop working on an explicit stack, by restating it as:

	place seed task on stack

	while stack is not empty
	take a task off the stack
	if(task can be done directly) {
		Do it
	} else {
		Split task into two or more parts
		Place task to consolidate results on stack
		Place each task on stack
	}


   For Tower of Hanoi this becomes:

	stack.push(new Task(size, from, to, spare));
	while(! stack.isEmpty()) {
		task = stack.pop();
		if(task.size() = 1) {
			just move it
		} else {
			stack.push(new Task(task.size() -1, task.spare(), task,to(), task,from()));
			stack.push(new Task(1, task.from(), task.to(), task.spare()));
			stack.push(new Task(task.size() -1, task.from(), task.spare(), task.to()));
		}
	}

   There is considerable flexibility here as to how you define your stack. You can make your stack a
   list of Command objects that do sophisticated things. Or you can go the opposite direction and make
   it a list of simpler types (e.g. a "task" might be 4 elements on a stack of int, rather than one
   element on a stack of Task).

   All this means is that the memory for the stack is in the heap rather than in the Java execution
   stack, but this can be useful in that you have more control over it.

***
   Generally the technique to avoid stack overflow is for recursive functions is called trampoline
   technique which is widely adopted by Java devs.

   However, for C# there is a little helper method here that turns your recursive function to
   iterative without requiring to change logic or make the code in-comprehensible. C# is such a nice
   language that amazing stuff is possible with it.

   It works by wrapping parts of the method by a helper method. For example the following recursive
   function:

int Sum(int index, int[] array) {
	//This is the termination condition
	if (int >= array.Length)
		//This is the returning value when termination condition is true
		return 0;

	//This is the recursive call
	var sumofrest = Sum(index+1, array);

	//This is the work to do with the current item and the
	//result of recursive call
	return array[index]+sumofrest;
}

   Turns into:

int Sum(int[] ar) {
	return RecursionHelper<int>.CreateSingular(i => i >= ar.Length, i => 0)
		.RecursiveCall((i, rv) => i + 1)
		.Do((i, rv) => ar[i] + rv)
		.Execute(0);
}

***
   One pattern to look for is a recursion call at the end of the function (so called tail-recursion).
   This can easily be replaced with a while. For example, the function foo:

void foo(Node* node) {
	if(node == NULL)
		return;
	// Do something with node...
	foo(node->left);
	foo(node->right);
}

   ends with a call to foo. This can be replaced with:

void foo(Node* node) {
	while(node != NULL)
	{
		// Do something with node...
		foo(node->left);
		node = node->right;
	}
}

   which eliminates the second recursive call.

***
   The node had the following structure:

typedef struct {
	int32_t type;
	int32_t valueint;
	double  valuedouble;
	struct  cNODE *next;
	struct  cNODE *prev;
	struct  cNODE *child;
} cNODE;

   The recursive deletion function looked like:
   
void cNODE_Delete(cNODE *c) {
	cNODE*next;
	while (c) {
		next=c->next;
		if (c->child) {
			cNODE_Delete(c->child)
		}
		free(c);
		c=next;
	}
}

   In general, it is not always possible to avoid a stack for recursive functions that invoke itself
   more than one time (or even once). However, for this particular structure, it is possible. The idea
   is to flatten all the nodes into a single list. This is accomplished by putting the current node's
   child at the end of the top row's list.

void cNODE_Delete (cNODE *c) {
	cNODE *tmp, *last = c;
	while (c) {
		while (last->next) {
			last = last->next;   /* find last */
		}
		if ((tmp = c->child)) {
			c->child = NULL;     /* append child to last */
			last->next = tmp;
			tmp->prev = last;
		}
		tmp = c->next;           /* remove current */
		free(c);
		c = tmp;
	}
}

   This technique can be applied to any data linked structure that can be reduce to a DAG with a
   deterministic topological ordering. The current nodes children are rearranged so that the last child
   adopts all of the other children. Then the current node can be deleted and traversal can then iterate
   to the remaining child.

***
   Recursion is nothing but the process of calling of one function from the other only this process is
   done by calling of a function by itself. As we know when one function calls the other function the
   first function saves its state(its variables) and then passes the control to the called function. The
   called function can be called by using the same name of variables ex fun1(a) can call fun2(a). When
   we do recursive call nothing new happens. One function calls itself by passing the same type and
   similar in name variables(but obviously the values stored in variables are different,only the name
   remains same.)to itself. But before every call the function saves its state and this process of
   saving continues. The SAVING IS DONE ON A STACK.

   NOW THE STACK COMES INTO PLAY.

   So if you write an iterative program and save the state on a stack each time and then pop out the
   values from stack when needed, you have successfully converted a recursive program into an iterative
   one!

   The proof is simple and analytical.

   In recursion the computer maintains a stack and in iterative version you will have to manually
   maintain the stack.

   Think over it, just convert a depth first search(on graphs) recursive program into a dfs iterative
   program.

   All the best!

***
TLDR

   You can compare the source code below, before and after to intuitively understand the approach
   without reading this whole answer.

   I ran into issues with some multi-key quicksort code I was using to process very large blocks of text
   to produce suffix arrays. The code would abort due to the extreme depth of recursion required. With
   this approach, the termination issues were resolved. After conversion the maximum number of frames
   required for some jobs could be captured, which was between 10K and 100K, taking from 1M to 6M
   memory. Not an optimum solution, there are more effective ways to produce suffix arrays. But anyway,
   here's the approach used.

The approach
   A general way to convert a recursive function to an iterative solution that will apply to any case is
   to mimic the process natively compiled code uses during a function call and the return from the call.

   Taking an example that requires a somewhat involved approach, we have the multi-key quicksort
   algorithm. This function has three successive recursive calls, and after each call, execution begins
   at the next line.

   The state of the function is captured in the stack frame, which is pushed onto the execution stack.
   When sort() is called from within itself and returns, the stack frame present at the time of the call
   is restored. In that way all the variables have the same values as they did before the call - unless
   they were modified by the call.

Recursive function

def sort(a: list_view, d: int):
	if len(a) <= 1:
		return
	p = pivot(a, d)
	i, j = partition(a, d, p)
	sort(a[0:i], d)
	sort(a[i:j], d + 1)
	sort(a[j:len(a)], d)

   Taking this model, and mimicking it, a list is set up to act as the stack. In this example tuples are
   used to mimic frames. If this were encoded in C, structs could be used. The data can be contained
   within a data structure instead of just pushing one value at a time.

Reimplemented as "iterative"

# Assume `a` is view-like object where slices reference
# the same internal list of strings.

def sort(a: list_view):
	stack = []
	stack.append((LEFT, a, 0))                  # Initial frame.

	while len(stack) > 0:
		frame = stack.pop()

		if len(frame[1]) <= 1:                  # Guard.
			continue

		stage = frame[0]                        # Where to jump to.

		if stage == LEFT:
			_, a, d = frame                     # a - array/list, d - depth.
			p = pivot(a, d)
			i, j = partition(a, d, p)
			stack.append((MID, a, i, j, d))     # Where to go after "return".
			stack.append((LEFT, a[0:i], d))     # Simulate function call.

		elif stage == MID:                      # Picking up here after "call"
			_, a, i, j, d = frame               # State before "call" restored.
			stack.append((RIGHT, a, i, j, d))   # Set up for next "return".
			stack.append((LEFT, a[i:j], d + 1)) # Split list and "recurse".

		elif stage == RIGHT:
			_, a, _, j, d = frame
			stack.append((LEFT, a[j:len(a)], d)

		else:
		pass

   When a function call is made, information on where to begin execution after the function returns is
   included in the stack frame. In this example, if/elif/else blocks represent the points where
   execution begins after return from a call. In C this could be implemented as a switch statement.

   In the example, the blocks are given labels; they're arbitrarily labeled by how the list is
   partitioned within each block. The first block, "LEFT" splits the list on the left side. The "MID"
   section represents the block that splits the list in the middle, etc.

   With this approach, mimicking a call takes two steps. First a frame is pushed onto the stack that
   will cause execution to resume in the block following the current one after the "call" "returns". A
   value in the frame indicates which if/elif/else section to fall into on the loop that follows the
   "call".

   Then the "call" frame is pushed onto the stack. This sends execution to the first, "LEFT", block in
   most cases for this specific example. This is where the actual sorting is done regardless which
   section of the list was split to get there.

   Before the looping begins, the primary frame pushed at the top of the function represents the initial
   call. Then on each iteration, a frame is popped. The "LEFT/MID/RIGHT" value/label from the frame is
   used to fall into the correct block of the if/elif/else statement. The frame is used to restore the
   state of the variables needed for the current operation, then on the next iteration the return frame
   is popped, sending execution to the subsequent section.

Return values
   If the recursive function returns a value used by itself, it can be treated the same way as other
   variables. Just create a field in the stack frame for it. If a "callee" is returning a value, it
   checks the stack to see if it has any entries; and if so, updates the return value in the frame on
   the top of the stack. For an example of this you can check this other example of this same
   approach to recursive to iterative conversion.

Conclusion
   Methods like this that convert recursive functions to iterative functions, are essentially also
   "recursive". Instead of the process stack being utilized for actual function calls, another
   programmatically implemented stack takes its place.

   What is gained? Perhaps some marginal improvements in speed. Or it could serve as a way to get around
   stack limitations imposed by some compilers and/or execution environments (stack pointer hitting the
   guard page). In some cases, the amount of data pushed onto the stack can be reduced. Do the gains
   offset the complexity introduced in the code by mimicking something that we get automatically with
   the recursive implementation?

   In the case of the sorting algorithm, finding a way to implement this particular one without a stack
   could be challenging, plus there are so many iterative sorting algorithms available that are much
   faster. It's been said that any recursive algorithm can be implemented iteratively. Sure... but some
   algorithms don't convert well without being modified to such a degree that they're no longer the same
   algorithm.

   It may not be such a great idea to convert recursive algorithms just for the sake of converting them.
   Anyway, for what it's worth, the above approach is a generic way of converting that should apply to
   just about anything.

   If you find you really need an iterative version of a recursive function that doesn't use a memory
   eating stack of its own, the best approach may be to scrap the code and write your own using the
   description from a scholarly article, or work it out on paper and then code it from scratch, or other
   ground up approach.

***
   Another simple and complete example of turning the recursive function into iterative one using the
   stack.

#include <iostream>
#include <stack>
using namespace std;

int GCD(int a, int b) { return b == 0 ? a : GCD(b, a % b); }

struct Par {
	int a, b;
	Par() : Par(0, 0) {}
	Par(int _a, int _b) : a(_a), b(_b) {}
};

int GCDIter(int a, int b) {
	stack<Par> rcstack;

	if (b == 0)
		return a;
	rcstack.push(Par(b, a % b));

	Par p;
	while (!rcstack.empty()) {
		p = rcstack.top();
		rcstack.pop();
		if (p.b == 0)
			continue;
		rcstack.push(Par(p.b, p.a % p.b));
	}

	return p.a;
}

int main() {
	//cout << GCD(24, 36) << endl;
	cout << GCDIter(81, 36) << endl;

	cin.get();
	return 0;
}




---
https://blog.moertel.com/posts/2013-05-11-recursive-to-iterative.html

Tricks of the trade: Recursion to Iteration, Part 1: The Simple Method, secret features, and accumulators
May 11, 2013

recursion-to-iteration series

   Alternative title: I wish Python had tail-call elimination.

   Recursive programming is powerful because it maps so easily to proof by induction, making it easy
   to design algorithms and prove them correct.

   But recursion is poorly supported by many popular programming languages. Drop a large input into a
   recursive algorithm in Python, and you'll probably hit the runtime's recursion limit. Raise the
   limit, and you may run out of stack space and segfault.

   These are not happy outcomes.

   Therefore, an important trick of the trade is knowing how to translate recursive algorithms into
   iterative algorithms. That way, you can design, prove, and initially code your algorithms in the
   almighty realm of recursion. Then, after you've got things just the way you want them, you can
   translate your algorithms into equivalent iterative forms through a series of mechanical steps. You
   can prove your cake and run it in Python, too.

   This topic - turning recursion into iteration - is fascinating enough that I'm going to do a
   series of posts on it. Tail calls, trampolines, continuation-passing style - and more. Lots of good
   stuff.

   For today, though, let's just look at one simple method and one supporting trick.

The Simple Method
   This translation method works on many simple recursive functions. When it works, it works well, and
   the results are lean and fast. I generally try it first and consider more complicated methods only
   when it fails.

   In a nutshell:
    1. Study the function.
    2. Convert all recursive calls into tail calls. (If you can't, stop. Try another method.)
    3. Introduce a one-shot loop around the function body.
    4. Convert tail calls into continue statements.
    5. Tidy up.

   An important property of this method is that it's incrementally correct - after every step you have a
   function that's equivalent to the original. So if you have unit tests, you can run them after each
   and every step to make sure you didn't make a mistake.

   Let's see the method in action.

Example: factorial
   With a function this simple, we could probably go straight to the iterative version without using any
   techniques, just a little noggin power. But the point here is to develop a mechanical process that we
   can trust when our functions aren't so simple or our noggins aren't so powered. So we're going to
   work on a really simple function so that we can focus on the process.

   Ready? Then let's show these guys how cyber-commandos get it done! Mark IV style!
   
    1. Study the original function.

def factorial(n):
	if n < 2:
		return 1
	return n * factorial(n - 1)

       Nothing scary here. Just one recursive call. We can do this!

    2. Convert recursive calls into tail calls.

	def factorial1a(n, acc=1):
		if n < 2:
			return 1 * acc
		return factorial1a(n - 1, acc * n)

       (If this step seemed confusing, see the Bonus Explainer at the end of the article for the "secret
       feature" trick behind the step.)

    3. Introduce a one-shot loop around the function body. You want while True: body ; break.

	def factorial1b(n, acc=1):
		while True:
			if n < 2:
				return 1 * acc
			return factorial1b(n - 1, acc * n)
			break

       Yes, I know putting a break after a return is crazy, but do it anyway. Clean-up comes later. For
       now, we're going by the numbers.

    4. Replace all recursive tail calls f(x=x1, y=y1, ...) with (x, y, ...) = (x1, y1, ...); continue.
       Be sure to update all arguments in the assignment.

	def factorial1c(n, acc=1):
		while True:
			if n < 2:
				return 1 * acc
			(n, acc) = (n - 1, acc * n)
			continue
			break

       For this step, I copy the original function's argument list, parentheses and all, and paste it
       over the return keyword. Less chance to screw something up that way. It's all about being
       mechanical.

    5. Tidy the code and make it more idiomatic.

	def factorial1d(n, acc=1):
		while n > 1:
			(n, acc) = (n - 1, acc * n)
		return acc

       Okay. This step is less about mechanics and more about style. Eliminate the cruft. Simplify. Make
       it sparkle.

    6. That's it. You're finished!

What have we gained?
   We just did five steps of work to convert our original, recursive factorial function into the
   equivalent, iterative factorial1d function. If our programming language had supported tail-call
   elimination, we could have stopped at step two with factorial1a. But nooooooo... We had to press on,
   all the way through step five, because we're using Python. It's almost enough to make a
   cyber-commando punch a kitten.

   No, the work wasn't hard, but it was still work. So what did it buy us?

   To see what it bought us, let's look inside the Python run-time environment. We'll use the Online
   Python Tutor's visualizer to observe the build-up of stack frames as factorial, factorial1a, and
   factorial1d each compute the factorial of 5.

   This is very cool, so don't miss the link: Visualize It! (ProTip: Open it in a new tab.)

   Click the "Forward" button to step through the execution of the functions. Notice what happens in the
   Frames column. When factorial is computing the factorial of 5, five frames build up on the stack. Not
   a coincidence.

   Same thing for our tail-recursive factorial1a. (You're right. It is tragic.)

   But not for our iterative wonder factorial1d. It uses just one stack frame, over and over, until it's
   done. That's economy!

   That's why we did the work. Economy. We converted O(n) stack use into O(1) stack use. When n could be
   large, that savings matters. It could be the difference between getting an answer and getting a
   segfault.

Not-so-simple cases
   Okay, so we tackled factorial. But that was an easy one. What if your function isn't so easy? Then
   it's time for more advanced methods.

   That's our topic for next time.

   Until then, keep your brain recursive and your Python code iterative.

Bonus Explainer: Using secret features for tail-call conversion

   In step 2 of The Simple Method, we converted the recursive call in this code:

	def factorial(n):
		if n < 2:
			return 1
		return n * factorial(n - 1)  # <-- right here!

   into the recursive tail call in this code:

	def factorial(n, acc=1):
		if n < 2:
			return 1 * acc
		return factorial(n - 1, acc * n)  # <-- oh, yeah!

   This conversion is easy once you get the hang of it, but the first few times you see it, it seems
   like magic. So let's take this one step by step.

   First, the problem. We want to get rid of the n * in the following code:
		return n * factorial(n - 1)

   That n * stands between our recursive call to factorial and the return keyword. In other words, the
   code is actually equivalent to the following:

		x = factorial(n - 1)
		result = n * x
		return result

   That is, our code has to call the factorial function, await its result (x), and then do something
   with that result (multiply it by n) before it can return its result. It's that pesky intermediate
   doing something we must get rid of. We want nothing but the recursive call to factorial in the return
   statement.

   So how do we get rid of that multiplication?
   Here's the trick. We extend our function with a multiplication feature and use it to do the
   multiplication for us.

   Shh! It's a secret feature, though, just for us. Nobody else.

   In essence, every call to our extended function will not only compute a factorial but also (secretly)
   multiply that factorial by whatever extra value we give it. The variables that hold these extra
   values are often called "accumulators," so I use the name acc here as a nod to tradition.

   So here's our function, freshly extended:

	def factorial(n, acc=1):
		if n < 2:
			return acc * 1
		return acc * n * factorial(n - 1)

   See what I did to add the secret multiplication feature? Two things.

   First, I took the original function and added an additional argument acc, the multiplier. Note that
   it defaults to 1 so that it has no effect until we give it some other value (since \(1 \cdot x =
   x\)). Gotta keep the secret secret, after all.

   Second, I changed every single return statement from return {whatever} to return acc * {whatever}.
   Whenever our function would have returned x, it now returns acc * x. And that's it. Our secret
   feature is done! And it's trivial to prove correct. (In fact, we just did prove it correct! Re-read
   the second sentence.)

   Both changes were entirely mechanical, hard to screw up, and, together, default to doing nothing.
   These are the properties you want when adding secret features to your functions.

   Okay. Now we have a function that computes the factorial of n and, secretly, multiplies it by acc.

   Now let's return to that troublesome line, but in our newly extended function:

	return acc * n * factorial(n - 1)

   It computes the factorial of n - 1 and then multiplies it by acc * n. But wait! We don't need to do
   that multiplication ourselves. Not anymore. Now we can ask our extended factorial function to do it
   for us, using the secret feature.

   So we can rewrite the troublesome line as

	return factorial(n - 1, acc * n)

   And that's a tail call!

   So our tail-call version of the factorial function is this:

	def factorial(n, acc=1):
		if n < 2:
			return acc * 1
		return factorial(n - 1, acc * n)

   And now that all our recursive calls are tail calls - there was only the one - this function is easy
   to convert into iterative form using The Simple Method described in the main article.

   Let's review the Secret Feature trick for making recursive calls into tail calls. By the numbers:
    1. Find a recursive call that's not a tail call.
    2. Identify what work is being done between that call and its return statement.
    3. Extend the function with a secret feature to do that work, as controlled by a new accumulator
       argument with a default value that causes it to do nothing.
    4. Use the secret feature to eliminate the old work.
    5. You've now got a tail call!
    6. Repeat until all recursive calls are tail calls.

   With a little practice, it becomes second nature. So...

Exercise: Get your practice on!
   You mission is to get rid of the recursion in the following function. Feel like you can handle it?
   Then just fork the exercise repo and do your stuff to exercise1.py.

def find_val_or_next_smallest(bst, x):
	"""Get the greatest value <= x in a binary search tree.

	Returns None if no such value can be found.

	"""
	if bst is None:
		return None
	elif bst.val == x:
		return x
	elif bst.val > x:
		return find_val_or_next_smallest(bst.left, x)
	else:
		right_best = find_val_or_next_smallest(bst.right, x)
		if right_best is None:
			return bst.val
		return right_best

   Have fun!



---
https://www.cs.odu.edu/~zeil/cs361/latest/Public/recursionConversion/index.html

Converting Recursion to Iteration
May 12, 2023

   A common application of stacks is in converting recursive algorithms to iterative forms.

   Recursion and iteration (looping) are equally powerful. Any recursive algorithm can be rewritten to
   use loops instead. The opposite is also true. Any iterative algorithm can be written in terms of
   recursion only.

   Given a choice of which to use, our decision is likey to come down to issues of
     * expressiveness: some algorithms are just naturally simpler or easier to write with loops. Some
       are simpler with recursion.

   Given the fact that testing and debugging of code usually takes much more effort than writing it in
   the first case, anything we can do to make code simpler (thuse reducing the opportunities for makeing
   mistakes) is worth giving serious consideration.
     * performance: Iteration is usually (though not always) faster than an equivalent recursion.

1 A Diversion - Function Calls at the Machine Level
   In a sense, all recursion is an illusion. At the machine level, you have an iterative process for
   fetchign and executing instructions. All function calls (including the recursive ones) are
   implemented via a runtime stack (called the activation stack) to keep track of the return addresses,
   actual parameters, and local variables associated with function calls. Each function call actually
   results in pushing an activation record containing that information onto the stack. Returning from a
   function is accomplished by getting and saving the return address out of the top record on the stack,
   popping the stack once, and jumping to the saved address.

   The actual structure of activation stacks is machine and compiler dependent. A typical one is shown
   here.

   Typical contents of the saved state area would include
     * the return address - where to go when returning from the call, and
     * contents of critical machine registers at the start of the call

   Contents of the params area would be
     * the values fo the actual parameters being passed to the function
     * space for the return value that the call will eventually send back to the caller

   The locals area holds the space for any local variables declared within the called function's body.

   The collection of all this information for a single call is called an activation record or,
   sometimes, a frame. An activation stack is typically managed via two pointers. One is the true top of
   the stack. The other is a pointer to the top completed frame or activation record - the one
   describing the function that is currently being executed. These two pointers are often slightly
   different. That's because, if the currently executing function is getting ready to call some other
   function, it will get ready by pushing its saved state info and any parameterts it wants to pass onto
   the top of the stack, forming an "incomplete" actication record as shown in the diagram.

   For a function call foo(a, b+c, d);, the caller would
     * Push state information, including a return address and the current values of the top-of-stack and
       top-frame pointers.
     * Evaluate each of the three parameter expressions, pushing their values onto the stack. If foo has
       a non-void return type, the caller would also push enough space for the return value.
     * The caller would then jump to the starting address of foo's function body.

   The code in the body of foo would typically start by pushing enough additional bytes onto the top of
   the stack to allow room for all of the local variables declared in that function body. This completes
   the activation record for the call to foo.

   The execution fo the function body of foo then proceeds. When a return statement (or end of the body)
   is encountered,
     * the return value (if any) is written into the spoace reserved for it in the params area
     * a jump is made to the return address recorded in the saved state area

   Upon return to the original caller, the caller then
     * copies the return value (if any) to some appropiate location
     * restores to top frame and top-of-stack pointers to their saved values. In effect, this pops the
       entire activation record that had been built for foo off of the stack, leaving the caller's
       activation record back on top.

   You can observe activation stacks in almost any debugger. Set a breakpoint and execute the code until
   that breakpoint is reached. When execution pauses, most debuggers will show not only where you
   stopped, but how you got there (in the form of the activation stack). In the picture shown here, for
   example, you can see that we have reached a breakpoint inside a function called dist, In the upper
   right corner, however you can see the entire activation (call) stack at this point in time. Like all
   C++ programs, we started by running main. In this program, main called undergroundCables, which
   called processDataSet, which called dist.

   This stack-based approach to execution handles recursive calls naturally. A recursive call is just
   one that happens to put another activation record for the same function body onto the stack. But that
   really makes no difference at all in how the machine-level execution treats that call. Arguably, the
   only difference is what happens when things go wrong. If you have an iterative algorithm and you make
   a mistake that leads to an infinite loop, the program simply runs forever (or until you kill the
   program). With a recursive algorithm, if you mess up and get into an infinte recursion, the program
   runs for a while and then crashes due to a lack of memory. An infinite recursion causes the
   activation stack to grow longer and longer until it occupies all available memory.

   In a sense, then, computers really don't do recursion. What we might write as a recursive algorithm
   really gets translated as a series of stack pushes followed by a jump back to the beginning of the
   recursive function, all implemented using the underlying CPU whose internal code is, fundamentally,
   iterative. With that in mind, you can see why, if we wanted to rewrite our own code to eliminate
   recursion, stacks are likely to prove useful.

2 Converting Recursive Algorithms to Iteration
   How, then do we go about converting recursive functions to an iterative form?

2.1 Tail Recursion
   A function is called \first-term{tail-recursive} if each activation of the function will make at most
   a single recursive call, and will return immediately after that call (with no further calculation
   performed upon the return value from the call).

   Tail recursive routines have an immediate, and simple pattern of conversion.

T tailRecursiveFoo(U x, V y) {
	if (bar(x, y))
		return baz(x,y);
	else {
		⋮ // block 1
		return tailRecursiveFoo(w, z);
	}
}


   becomes

T Foo(U x, V y) {
	while (! bar(x, y)) {
		⋮ // block 1
		x = w;
		y = z;
	}
	return baz(x,y);
}


2.1.1 Tail Recursion Example: binarySearch
   An example of tail-recursion is the binary search, which converts by the pattern just shown from the
   recursive form shown here:

unsigned int binarySearch (T v[], unsigned int n, const T& value)
	// search for value in ordered array of data
	// return index of value, or index of
	// next smaller value if not in collection
{
	binarySearch (v, 0, n, value);
}

unsigned int binarySearch (T v[], unsigned int low, int high, const T& value) {

	// repeatedly reduce the area of search
	// until it is just one value
	if (low < high) {
		int mid = (low + high) / 2;
		if (v[mid] < value) {
			return binarySearch (v, mid + 1, high, value);
		} else {
			return binarySearch (v, low, mid, value);
		}
	} else {
		// return the lower value
		return low;
	}
}


   into its more familiar iterative form:

unsigned int binarySearch (T v[], unsigned int n, const T& value)
	// search for value in ordered array of data
	// return index of value, or index of
	// next smaller value if not in collection
{

	int low = 0;
	int high = n;

	// repeatedly reduce the area of search
	// until it is just one value
	while (low < high) {
		int mid = (low + high) / 2;
		if (v[mid] < value) {
			low = mid + 1;
		} else {
			high = mid;
		}
	}
	// return the lower value
	return low;
}


2.2 Conversion Using Stacks
   As noted earlier, CPU's execute recursive code by storing information about each recursive call in an
   "activation stack".

   If we wanted to convert an algorithm from a recursive form to an iterative form, we could simulate
   this process with our own stacks.

   Any recursive algorithm can be converted to an iterative form by using a stack to capture the
   "history" of
     * actual parameters
     * local variables

   that would have been placed on the activation stack.

   The general idea is:
     * recursive calls get replaced by push
          + depending on details, may push new values, old values, or both
     * returns from recursive calls get replaced by pop
     * main calculation of recursive routine gets put inside a loop
          + at start of loop, set variables from stack top and pop the stack

2.2.1 Looking at the Pieces

T recursiveFoo (U param1, V param2) {
	U local1;
	V local2 = bar(U,V);
	⋮  // code block 1
	recursiveFoo (local1, local2);
	⋮  // code block 2
	recursiveFoo (param1, local2);
	⋮  // code block 3
	recursiveFoo (local1, param2);
	⋮  // code block 4
}


   We can think of a recursive function as being divided into several pieces, separated by the recursive
   calls. (This is a bit of an oversimplification, since we aren't considering what happens if the
   recursive calls are inside if or loop statements, but those can be dealt with once you get the basic
   idea.)

   We can simulate calls to the recursive routine by saving, on a stack, all parameters and local
   variables. In addition, just as a "real" function call needs to know its return address, we may need
   to save a "location" indicator to let us know which block of code we're supposed to execute upon a
   simulated return from a simulated recursive call.

   It helps, then, to have a convenient structure to hold each set of information to go on the stack:

struct FooStateInfo {
	U param1;
	V param2;
	U local1;
	V local2;
	int location;
};

typedef stack<list<FooStateInfo> > FooStack;


2.2.2 Getting "parameters" from the stack
   Starting with this recursive code, ...

T recursiveFoo (U param1, V param2) {
	U local1;
	V local2;
	⋮  // code block 1
	recursiveFoo (local1, local2);
	⋮  // code block 2
	recursiveFoo (param1, local2);
	⋮  // code block 3
	recursiveFoo (local1, param2);
	⋮  // code block 4
}


   ... we create one large control loop. Inside this loop, we have the blocks of code from the original
   recursive routine, but the recursive calls at the end of each block is replaced by a push of the
   information that we want restored upon "return" from a simulated recursive call and another push that
   sets up a simulated recursive call.

T iterativeFoo (U param1, V param2) {
	U local1;
	V local2;
	FooStack stk;
	stk.push ({param1, param2, local1, local2, 1});
	while (!stk.empty()) {
		// get parameters from stack
		const FooStackInfo& stkTop = stk.top();
		param1 = stkTop.param1;
		param2 = stkTop.param2;
		local1 = stkTop.local1;
		local2 = stkTop.local2;
		stk.pop();

		switch (stkTop.location) {
			case 1:
				⋮  // code block 1
				stk.push ({param1, param2, local1, local2, 2});
				stk.push ({local1, local2, local1, local2, 1});
				break;
			case 2:
				⋮  // code block 2
				stk.push ({param1, param2, local1, local2, 3});
				stk.push ({param1, local2, local1, local2, 1});
				break;
			case 3:
				⋮  // code block 3
				stk.push ({param1, param2, local1, local2, 4});
				stk.push ({local1, param2, local1, local2, 1});
				break;
			case 4:
				⋮  // code block 4
				break;
		}
	}
}

   The final block (and any block that, in the original routine, does not do further recursive calls)
   does not get these pushes. If the original routine only makes recursive calls under certain
   conditions:

if (bar(local1, local2)) {
	recursiveFoo(local1, local2);
}


   then the same thing happens in the iterative form with the pushes that simulate the recursive call:

if (bar(local1, local2)) {
	stk.push ({param1, param2, local1, local2, <[..]>});
	stk.push ({local1, local2, local1, local2, 1});
}


2.2.3 Simplifying
   Now, the general approach to conversion outlined here is almost always overkill.
     * We seldom need to save every parameter and local variable.
          + For example, pure inputs whose values are never changed won't need to be put onto the stack.
     * If a recursive call occurs at the very end of the routine, we might not need to set up the
       simulated return.
     * If two or more recursive calls immediately follow one another, we can put them both on the stack
       immediately, rather than simulate a return in between the two.

   You need to look carefully at the algorithm you are converting to see if these or other
   simplifications are possible.

2.3 Conversion Example: quicksort
   Let's look at how this works by converting a slightly modified version of our recursive quicksort
   algorithm to an iterative form.

template <class T>
void quickSort(T[] v, unsigned int low, unsigned int high) {
	// no need to sort a vector of zero or one elements
	if (low >= high)
		return;

	// select the pivot value
	unsigned int pivotIndex = (low + high) / 2;

	// partition the vector
	pivotIndex = pivot (v, low, high, pivotIndex);

	// sort the two sub vectors
	if (low < pivotIndex)
		quickSort(v, low, pivotIndex);

	if (pivotIndex < high)
		quickSort(v, pivotIndex + 1, high);
}


template <class T>
void quickSort(T[] v, unsigned int numberOfElements) {
	if (numberOfElements > 1)
		quickSort(v, 0, numberOfElements - 1);
}

   Try out the quicksort in an animation. You might want to refresh your memory of how it works.

   The pivot algorithm is already not recursive, so we can leave it be.

   What values actually need to be carried over to recursive calls, or restored when we return from a
   recursive call? v is the same array throughout. The formal parameters low and high, however, are
   different for each call. The local variable pivotIndex is used to determine whether to make a
   recursive call (or, in our conversion, whether to push information onto the stack) and to help
   compute the values of the formal parameters for the next call. Since we compute the formal parameter
   values before pushing information onto the stack, we won't need to preserve the value pivotIndex
   after we have done the pushes.

   Finally, we won't need to use a location indicator, as the only recursive calls are adjacent and at
   the very end of the routine (no need for a simulated return).

   So, it appears that the only information we will need to place into our stack will be the values of
   low and high.

2.3.1 Setting Up the Stack
   ... the only information we will need to place into our stack will be the values of low and high.

   Since we only have two objects to go on the stack, we don't need to declare a special type to hold
   them. The standard library provides, in <utility>, a convenient container for pairs of objects,
   called pair.

   In this case, we would use a pair<unsigned int,unsigned int>. We can create an object of this type
   either by invoking the constructor:

stk.push (pair<unsigned int, unsigned int> (23, 47));

   or via the function make_pair:

stk.push (make_pair(23, 47));

   We can see, therefore, what kind of stack we will need, and what the push commands to simulate the
   recursive calls will look like.

template <class T>
void quickSort(T[] v, unsigned int low, unsigned int high) {
	stack<pair<unsigned int, unsigned int>, list<pair<unsigned int, unsigned int> > > stk;
	// no need to sort a vector of zero or one elements
	if (low >= high)
		return;

	// select the pivot value
	unsigned int pivotIndex = (low + high) / 2;

	// partition the vector
	pivotIndex = pivot (v, low, high, pivotIndex);

	// sort the two sub vectors
	if (low < pivotIndex)
		quickSort(v, low, pivotIndex); // stk.push (make_pair(low, pivotIndex))

	if (pivotIndex < high)
		quickSort(v, pivotIndex + 1, high); // stk.push (make_pair(pivotIndex+1,high))
}

   Now, let's introduce the main loop ...

template <class T>
void quickSort(T[] v, unsigned int low, unsigned int high) {
	stack<pair<unsigned int, unsigned int>, list<pair<unsigned int, unsigned int> > > stk;
	stk.push (make_pair(low, high)); // initialize the stack

	while (!stk.empty()) {
		// simulated recursive call - remove parameters from stack
		low = stk.top().first;
		high = stk.top().second;
		stk.pop();

		// no need to sort a vector of zero or one elements
		if (low >= high)
			return;

		// select the pivot value
		unsigned int pivotIndex = (low + high) / 2;

		// partition the vector
		pivotIndex = pivot (v, low, high, pivotIndex);

		// sort the two sub vectors
		if (low < pivotIndex)
			quickSort(v, low, pivotIndex); // stk.push (make_pair(low, pivotIndex))

		if (pivotIndex < high)
			quickSort(v, pivotIndex + 1, high); // stk.push (make_pair(pivotIndex+1,high))
	}
}

   And then we actually replace the recursive calls by the simulating pushes.

template <class T>
void quickSort(T[] v, unsigned int low, unsigned int high) {
	stack<pair<unsigned int, unsigned int>, list<pair<unsigned int, unsigned int> > > stk;
	stk.push (make_pair(low, high)); // initialize the stack

	while (!stk.empty()) {
		// simulated recursive call - remove parameters from stack
		low = stk.top().first;
		high = stk.top().second;
		stk.pop();

		// no need to sort a vector of zero or one elements
		if (low >= high)
			return;

		// select the pivot value
		unsigned int pivotIndex = (low + high) / 2;

		// partition the vector
		pivotIndex = pivot (v, low, high, pivotIndex);

		// sort the two sub vectors
		if (low < pivotIndex)
			stk.push (make_pair(low, pivotIndex));

		if (pivotIndex < high)
			stk.push (make_pair(pivotIndex+1, high));
	}
}

   Now that just leaves the return statement to deal with. How do we simulate a return?
     * By going to the end of the loop without pushing anything new onto the stack.

template <class T>
void quickSort(T[] v, unsigned int low, unsigned int high) {
	stack<pair<unsigned int, unsigned int>, list<pair<unsigned int, unsigned int> > > stk;
	stk.push (make_pair(low, high)); // initialize the stack

	while (!stk.empty()) {
		// simulated recursive call - remove parameters from stack
		low = stk.top().first;
		high = stk.top().second;
		stk.pop();

		// no need to sort a vector of zero or one elements
		if (low >= high)
			return;

		// select the pivot value
		unsigned int pivotIndex = (low + high) / 2;

		// partition the vector
		pivotIndex = pivot (v, low, high, pivotIndex);

		// sort the two sub vectors
		if (low < pivotIndex)
			stk.push (make_pair(low, pivotIndex));

		if (pivotIndex < high)
			stk.push (make_pair(pivotIndex+1, high));
	}
}

   Finally, we note that, with no recursion, there's really no point to having the two separate
   quicksort routines - the "wrapper" was really there only to get the recursion started up.

template <class T>
void quickSort(T[] v, unsigned int low, unsigned int high) {
	stack<pair<unsigned int, unsigned int>, list<pair<unsigned int, unsigned int> > > stk;
	stk.push (make_pair(low, high)); // initialize the stack

	while (!stk.empty()) {
		// simulated recursive call - remove parameters from stack
		low = stk.top().first;
		high = stk.top().second;
		stk.pop();

		// no need to sort a vector of zero or one elements
		if (low < high) {
			// select the pivot value
			unsigned int pivotIndex = (low + high) / 2;

			// partition the vector
			pivotIndex = pivot (v, low, high, pivotIndex);

			// sort the two sub vectors
			if (low < pivotIndex)
				stk.push (make_pair(low, pivotIndex));

			if (pivotIndex < high)
				stk.push (make_pair(pivotIndex+1, high));
		}
	}
}

template <class T>
void quickSort(T[] v, unsigned int numberOfElements) {
	if (numberOfElements > 1)
		quickSort(v, 0, numberOfElements - 1);
}

   We can combine them into one.

template <class T>
void quickSort(T[] v, unsigned int numberOfElements) {
	if (numberOfElements > 1) { // quickSort(v, 0, numberOfElements - 1);
		stack<pair<unsigned int, unsigned int>, list<pair<unsigned int, unsigned int> > > stk;
		stk.push (make_pair(0, numberOfElements - 1)); // initialize the stack

		while (!stk.empty()) {
			// simulated recursive call - remove parameters from stack
			low = stk.top().first;
			high = stk.top().second;
			stk.pop();

			// no need to sort a vector of zero or one elements
			if (low < high) {
				// select the pivot value
				unsigned int pivotIndex = (low + high) / 2;

				// partition the vector
				pivotIndex = pivot (v, low, high, pivotIndex);

				// sort the two sub vectors
				if (low < pivotIndex)
					stk.push (make_pair(low, pivotIndex));

				if (pivotIndex < high)
					stk.push (make_pair(pivotIndex+1, high));
			}
		}
	}
}

   This iterative form, when used with a reasonable pivot rule (such as median-of-3), is not only O(N
   log N) on average, but has an extremely low multiplicative constant, making it one of the best
   choices as a practical sorting algorithm.

3 Last Thoughts
   Sometimes it's really not worth converting algorithms from recursive to iterative. Some elegant,
   simple recursive algorithms become horrendously complicated in iterative form. On the other hand, as
   noted earlier, there are times when we have little choice (e.g., embedded systems).

   In these kinds of situations, conversion from recursion to iteration may be the only way to get a
   system running.



---
https://medium.com/@chenfelix/removal-of-recursion-28ab46c891c7

Recursion: Recursion To Iteration
Jan 26, 2018

   Although recursion is easier to be implemented in some cases, we need to learn how to program the
   same function without recursion. For some systems, system memory is not big enough, recursion will
   make it run out of memory. For the overhead of a recursion, it takes much space to store variables
   into the system storage. The following is the factorial function which is implemented by recursion.

     Example 1: Factorial Function (n!)

int factorial (int n) {
	if (n < 1) return 1;
	else return n * factorial(n-1);  // this is bad for processing n
}

   For the space issue, the following is implemented by tail recursion, which can reduce the size of the
   function's overhead by compiler optimization.

int factorial(int n, int r) {
	if (n < 1) {
		return r;
	} else {
		return factorial (n-1, r * n);  // a little bit good
	}
}

   Here, as we know, the recursion mentioned above can be removed by two ways, Iteration (loop) and
   Stack.

   By Iteration, The rules of Recursion Removal  is quoted:
    1. Recursion can be removed by replace the selection structure with a loop.
    2. If some data need to be stored for processing after the end of the recursive step, a data
       structure is needed in addition to the loop
    3. The data structure vary from a simple string or an array to a stack.

#define true 1
int factorial(int n) {
	int r = 1;    while (true) {
		if (n < 1) return r;        r = r * n ;
		n = n - 1;
	}
}

   By Stack,
    1. A stack for each parameter, variable, (Label).
    2. A variable to hold the return value.
    3. if the stop condition is reached, check whether the stack is empty.
    4. If the stack is not empty, pop() and jump to the appropriate label.
    5. If the stack is empty, return the result.

int factorial(int n ) {
	new a stack P;
L1:
	if (n > 1) {
		push to stack P (n);
		n = n - 1;
		goto L1;
L2:
		r = r * n;
	} else {
		r = 1;
	}

	if (stack is not empty) {
		n = pop();
		goto L2;
	} else {
		return r;
	}
}

     Example 2: Fibonnaci Series

   Fibonnaci Series is very popular, the series is as following: 0, 1, 1, 2, 3, 5, 8, 13,... ,which is
   implemented by recursion.

int Fibonnaci(n) {
	if (n < 2) return n;
	return Fibonnaci(n-1) + Fibonnaci(n-2);
}

   Fibonnaci Series Without Recursion

uint64_t Fibonnaci(uint64_t n) {
	if (n == 0) return 0;
	if (n == 1) return 1;
	if (n > 95) return -1;    // overflow, unsigned integer    uint64_t n1 = 1, n0 = 0, nth = 0;
	while(--n > 2) {          // control the number of loops
		nth = n1 + n0;
		n0 = n1;
		n1 = nth;
	}
	return nth;
}

   Simulate a Fibonnaci Series by using stack structure.

uint64_t Fibonnaci(uint64_t n) {
	ret = 0;
L0:
		if (n > 2) {
			push(n), push(1)      // stores local variable n and
			n = n - 1;            // change to the next loop variables
			goto L0;
		} else {
			ret = ret + 1;
		}
L1:
	if (n > 2) {
		push (n), push(2)     // stores local variable n and
		n = n - 2;            // change to the next loop variables
		goto L0;
	} else {
		r = 0
	}
L2:

	ret = ret + r;

	if (stack is not empty) {
		step = pop(), n = pop();
		switch(step) {
			case 1:
				goto L1;
			case 2:
				goto L2;
		}
	}
	return r1;
}

   Now, the general approach to conversion outlined here is almost always overkill.
    1. We seldom need to save every parameter and local variable.
    2. If a recursive call occurs at the very end of the routine, we might not need to set up the
       simulated return.
    3. If two or more recursive calls immediately follow one another, we can put them both on the stack
       immediately, rather than simulate a return in between the two. (like: BinarySearch or QuickSort)



---
https://forums.oracle.com/ords/apexds/post/replace-recursive-with-stack-8718

Replace recursive with stack
Oct 31 2008

   Hi,
   I want to replace following recursive implementation with stack. I implemented one, but I found the
   performance it was worse than the recursive one. Could anyone show me a stack implementation which
   has better performance?

public static int f(int n) {
	if (n == 1) {
		return 1;
	}
	int value = 0;

	if (n % 2 == 0) {
		value = 2*p1(n/2) + n;
	} else {
		value = p1(n/2) + p1(n/2 + 1) + n;
	}
	return value;
}



---
https://www.geeksforgeeks.org/tail-recursion/

What is Tail Recursion

     Tail recursion is defined as a recursive function in which the recursive call is the last
     statement that is executed by the function. So basically nothing is left to execute after the
     recursion call.

   For example the following C++ function print() is tail recursive.

C
// An example of tail recursive function

void print(int n) {
	if (n < 0)
		return;
	printf("%d ", n);

	// The last executed statement is recursive call
	print(n - 1);
}


C++
// An example of tail recursive function

static void print(int n) {
	if (n < 0)
		return;
	cout << " " << n;

	// The last executed statement is recursive call
	print(n - 1);
}


Java
// An example of tail recursive function

static void print(int n) {
	if (n < 0)
		return;

	System.out.print(" " + n);

	// The last executed statement
	// is recursive call
	print(n - 1);
}


Python3
# An example of tail recursive function

def prints(n):

	if (n < 0):
		return
	print(str(n), end=' ')

	# The last executed statement is recursive call
	prints(n-1)

	# This code is contributed by Pratham76
	# improved by ashish2021


Javascript
<script>
// An example of tail recursive function
function print(n) {
	if (n < 0)
		return;

	document.write(" " + n);

	// The last executed statement
	// is recursive call
	print(n - 1);
}

</script>


C
// An example of tail recursive function

void print(int n) {
	if (n < 0)

		return;
	<< " " << n;

	// The last executed statement is recursive call
	print(n - 1);
}


C++
// An example of tail recursive function

static void print(int n)
{
	if (n < 0)
		return;
	cout << " " << n;

	// The last executed statement is recursive call
	print(n - 1);
}


Java
// An example of tail recursive function

static void print(int n) {
	if (n < 0)
		return;

	System.out.print(" " + n);

	// The last executed statement
	// is recursive call
	print(n - 1);
}


Python3
# An example of tail recursive function

def prints(n):

	if (n < 0):
		return
	print(str(n), end=' ')

	# The last executed statement is recursive call
	prints(n-1)

	# This code is contributed by Pratham76
	# improved by ashish2021


Javascript
<script>
// An example of tail recursive function
function print(n) {
	if (n < 0)
		return;

	document.write(" " + n);

	// The last executed statement
	// is recursive call
	print(n - 1);
}

</script>

   Time Complexity: O(n)
   Auxiliary Space: O(n)

Need for Tail Recursion:
   The tail recursive functions are considered better than non-tail recursive functions as
   tail-recursion can be optimized by the compiler.

   Compilers usually execute recursive procedures by using a stack. This stack consists of all the
   pertinent information, including the parameter values, for each recursive call. When a procedure is
   called, its information is pushed onto a stack, and when the function terminates the information is
   popped out of the stack. Thus for the non-tail-recursive functions, the stack depth (maximum amount
   of stack space used at any time during compilation) is more.

     The idea used by compilers to optimize tail-recursive functions is simple, since the recursive
     call is the last statement, there is nothing left to do in the current function, so saving the
     current function's stack frame is of no use (See this for more details).

Can a non-tail-recursive function be written as tail-recursive to optimize it?

   Consider the following function to calculate the factorial of n.

   It is a non-tail-recursive function. Although it looks like a tail recursive at first look. If we
   take a closer look, we can see that the value returned by fact(n-1) is used in fact(n). So the call
   to fact(n-1) is not the last thing done by fact(n).

C++
#include <iostream>
using namespace std;

// A NON-tail-recursive function.  The function is not tail
// recursive because the value returned by fact(n-1) is used
// in fact(n) and call to fact(n-1) is not the last thing
// done by fact(n)
unsigned int fact(unsigned int n) {
	if (n <= 0)
		return 1;

	return n * fact(n - 1);
}

// Driver program to test above function
int main() {
	cout << fact(5);
	return 0;
}


Java
class GFG {

	// A NON-tail-recursive function.
	// The function is not tail
	// recursive because the value
	// returned by fact(n-1) is used
	// in fact(n) and call to fact(n-1)
	// is not the last thing done by
	// fact(n)
	static int fact(int n) {
		if (n == 0)
			return 1;

		return n * fact(n - 1);
	}

	// Driver program
	public static void main(String[] args) {
		System.out.println(fact(5));
	}
}

Python3
	# A NON-tail-recursive function.
	# The function is not tail
	# recursive because the value
	# returned by fact(n-1) is used
	# in fact(n) and call to fact(n-1)
	# is not the last thing done by
	# fact(n)

	def fact(n):
		if (n == 0):
			return 1
		return n * fact(n-1)


	# Driver program to test
	# above function
	if __name__ == '__main__':
		print(fact(5))


Javascript
<script>

// A NON-tail-recursive function.
// The function is not tail
// recursive because the value
// returned by fact(n-1) is used
// in fact(n) and call to fact(n-1)
// is not the last thing done by
// fact(n)
function fact(n) {
	if (n == 0)
		return 1;

	return n * fact(n - 1);
}

// Driver code
document.write(fact(5));

</script>

   Output
120

   Time Complexity: O(n)
   Auxiliary Space: O(n)

   The above function can be written as a tail-recursive function. The idea is to use one more argument
   and accumulate the factorial value in the second argument. When n reaches 0, return the accumulated
   value.

   Below is the implementation using a tail-recursive function.

C++
#include <iostream>
using namespace std;

// A tail recursive function to calculate factorial
unsigned factTR(unsigned int n, unsigned int a) {
	if (n <= 1)
		return a;

	return factTR(n - 1, n * a);
}

// A wrapper over factTR
unsigned int fact(unsigned int n) { return factTR(n, 1); }

// Driver program to test above function
int main() {
	cout << fact(5);
	return 0;
}


Java
// Java Code for Tail Recursion

class GFG {

	// A tail recursive function
	// to calculate factorial
	static int factTR(int n, int a) {
		if (n <= 0)
			return a;

		return factTR(n - 1, n * a);
	}

	// A wrapper over factTR
	static int fact(int n) { return factTR(n, 1); }

	// Driver code
	static public void main(String[] args) {
		System.out.println(fact(5));
	}
}


Python3
	# A tail recursive function
	# to calculate factorial

	def fact(n, a=1):

		if (n <= 1):
			return a

		return fact(n - 1, n * a)

	# Driver program to test
	# above function
	print(fact(5))

	# This code is contributed
	# by Smitha
	# improved by Ujwal, ashish2021


Javascript
<script>

// Javascript Code for Tail Recursion

// A tail recursive function
// to calculate factorial
function factTR(n, a) {
	if (n <= 0)
		return a;

	return factTR(n - 1, n * a);
}

// A wrapper over factTR
function fact(n) {
	return factTR(n, 1);
}

// Driver code
document.write(fact(5));

</script>


   Output
120

   Time Complexity: O(n)
   Auxiliary Space: O(1)


---
