filename: git_tips-and-tricks-multif_20250310.txt
https://danmackinlay.name/notebook/git

Git tricks
June 26, 2015 - March 3, 2025

   My own notes on git the source control system. This is one of the more heavily documented tools on
   the internet. As such, notes here are not intended to be a tutorial because the internet is full of
   those.

1 Learning git
   See the fastai masterclass for many more helpful tips/links/scripts/recommendations. Learn
   Git Branching explains the mechanics in a friendly fashion. Steve Bennett's 10 things I hate
   about Git is also useful.

   Mark Dominus' master class:
     * [**1]The Universe of Discourse: Things I wish everyone knew about Git (Part I)
     * [**2]The Universe of Discourse: Things I wish everyone knew about Git (Part II)

2 Tips
   Universally-acclaimed classic: [**3]git tips.

3 Working with normies in the cloud
   Working with a colleague who doesn't like git? Try this git collab trick that lets you work in
   hostile file systems such as OneDrive.

   I really mean "try this" in the sense of "I have not tried this".

   Create bare repository outside cloud-synced locations but on your local disk (OR you can use remote
   git host like GitHub, etc.; just something that is not on the cloud):
$> mkdir ~/git-storage/myproject.git
$> cd ~/git-storage/myproject.git
$> git init --bare

   Prepare OneDrive workspace:
$> mkdir ~/OneDrive/myproject
$> cd ~/OneDrive/myproject

   Link workspace to bare repo using Git's clone-with-separation:
$> git clone --separate-git-dir=~/git-storage/myproject.git /dev/null .
$> rm .git  # Remove auto-created folder
$> echo "gitdir: ~/git-storage/myproject.git" > .git

   Create initial commit through a temporary clone:
$> cd ~/git-storage
$> git clone myproject.git temp-work
$> cd temp-work

$> touch README.md
$> git add .
$> git commit -m "Initial commit"
$> git push origin main

$> cd ..
$> rm -rf temp-work

   Checkout files in OneDrive workspace:
$> cd ~/OneDrive/myproject
$> git reset --hard HEAD

4 Verify Workflow
   Regular Git operations work normally:
# Make changes
$> echo "New content" >> file.txt
$> git add .
$> git commit -m "Update file"
$> git push

   File structure shows clean separation:
~/git-storage/myproject.git  # Bare repo (Git data)
~/OneDrive/myproject         # Working files (.git file only)

   Key advantages:
     1. No .git folder synced to cloud
     2. Full Git history stored locally in bare repo 
     3. Works with all Git commands as normal
     4. Easy to relocate Git data without breaking links

   For Windows paths, use doubled backslashes in .git file: gitdir: C:\\\\path\\\\to\\\\repo.git

5 Handy git config
5.1 git editor
   I often do editing in VS code, so it is convenient to set it as git editor:
$> git config --global core.editor "code-insiders --wait"  # insiders

5.2 .gitignore
   Basic level: Ignore macOS .DS_Store files
$> echo .DS_Store >> .gitignore_global
$> git config --global core.excludesfile $HOME/.gitignore_global

6 Handy git commands
6.1 Merging ours/theirs
   During a merge, git checkout --theirs filename (or --ours) will checkout respectively their (or
   our) version. The following sweet hack will resolve all files accordingly:
$> git diff --name-only --diff-filter=U | xargs git checkout --theirs --

   I do this a lot and will never remember the details, so here are some aliases for fish which I
   can use to make this easier:
$> echo "alias git_theirs 'git diff --name-only --diff-filter=U | xargs git checkout --theirs --'" >  \
	~/.config/fish/conf.d/git_theirs.fish
$> echo "alias git_ours   'git diff --name-only --diff-filter=U | xargs git checkout --ours   --'" >> \
	~/.config/fish/conf.d/git_theirs.fish
$> chmod a+x ~/.config/fish/conf.d/git_theirs.fish
$> source ~/.config/fish/conf.d/git_theirs.fish

6.2 Searching
6.2.1 ...for a matching file
   git grep

6.2.2 ...for a matching commit
   Easy, except for the abstruse naming; It is called "pickaxe" and spelled -S.
$> git log -Sword

6.3 track the history of a file including renames
   Kashyap Kondamudi advises Use --follow option in git log to view a file's history.
$> git log --oneline --find-renames --stat --follow -- src/somefile.ts

6.4 Clone a single branch
$> git clone --single-branch --branch <branchname> <remote-repo>

6.5 Remove file from versioning without deleting my copy
$> git rm --cached blah.tmp

6.6 delete remote branch
$> git push <remote_name> --delete <branch_name>

6.7 Push to a non-obvious branch
$> git push origin HEAD:refs/heads/backdoor

   This is almost obvious except the git naming of things seems... arbitrary? Why refs/heads/SOMETHING?
   Read on.

7 What git calls things
   By which I mean that which is formally denoted as git references. git references is the canonical
   description of the mechanics. tl;dr the most common names are refs/heads/SOMETHING for branch
   SOMETHING, refs/tags/SOMETHING and remotes/SOMEREMOTE/SOMETHING for (last known state of) a remote
   branch.

   As alexwlchan explains, these references are friendly names for commits, and should be thought of
   as pointers to commits.

   And yet there is something a little magical going on. How come if I pull a branch, I get the latest
   version of that branch, not the earliest to use that name? Other stuff is happening.

   The uses are (at least partly) convention and other references can be used too. For example gerrit
   uses refs/for/ for code review purposes.

8 Filters
   Commands applied to your files on the way in and out of the repository. Keywords, smudge, clean,
   .gitattr These are a long story, but not so complicated in practice. A useful one is
   stripping crap from jupyter notebooks.

9 Commit hooks
   For doing stuff before you put it in cold storage. e.g., asking DID YOU REALLY WANT TO INCLUDE THAT
   GIANT FILE?

   Here is a commit hook that does exactly that. I made a slightly modernized version:
$> curl -L https://gist.github.com/danmackinlay/6e4a0e5c38a43972a0de2938e6ddadba/raw/install.sh | bash

   UPDATE: I decided this was a waste of time and removed it.

   After that installation you can retrofit the hook to an existing repository thusly
p -R ~/.git_template/hooks .git/

   There are various frameworks for managing hooks, if you have lots. For example, pre-commit is a
   mini-system for managing git hooks, based on python. Husky is a node.js-based one.

   I am not sure whether hook management systems actually save time overall for a solo developer, since
   the kind of person who remembers to install a pre-commit hook is also the kind of person who is
   relatively less likely to need one. Also, it is remarkably labour-intensive to install the
   dependencies for all these systems, so if you are using heterogeneous systems this becomes tedious.

   To skip the pre-commit hook,
$> git commit --no-verify

10 Subtrees/submodules/subprojects/subdirs/subterranean mole people
   Sub-projects inside other projects? External projects? The simplest way of integrating external
   projects seems to be as subtrees. Once this is set up we can mostly ignore them and things work
   mostly as expected. Alternatively, there are submodules, which have various complications.
   More recently, there is the subtrac system, which I have not yet used.

10.1 Submodule
   Include external projects as separate repositories within a repository is possible, but I won't
   document it, since it's well documented elsewhere, and I use it less often, because it is fiddly.
   Some discipline is required to make it go; you need to remember to git submodule init, etc.

10.2 Subtrac
   Have not yet tried.
     subtrac is a helper tool that makes it easier to keep track of your git submodule contents. It
     collects the entire contents of the entire history of all your submodules (recursively) into a
     separate git branch, which can be pushed, pulled, forked, and merged however you want.

10.3 Subtree
   Subtree subsumes one git tree into another in a usually-transparent way (no separate checkout as
   with submodules). It can be used for temporary merging or for splicing and dicing projects.

10.3.1 Splicing a subtree onto a project
   Creatin':
$> git fetch remote branch
$> git subtree add --prefix=subdir remote branch --squash

   Updatin':
$> git fetch remote branch
$> git subtree pull --prefix=subdir remote branch --squash
$> git subtree push --prefix=subdir remote branch --squash

   Con: Rebasin' with a subtree in your repo is slow and involved.

10.3.2 Taking a cutting to make a sub-project
   Use subtree split to prise out one chunk. It has various wrinkles but is fast and easy.
$> pushd superproject
$> git subtree split -P project_subdir -b project_branch
$> popd
$> mkdir project
$> pushd project
$> git init
$> git pull ../superproject project_branch

   Alternatively, to comprehensively rewrite history to exclude everything outside a subdir:
pushd superproject
$> cd ..
$> git clone superproject subproject
$> pushd subproject
$> git filter-branch \
    --subdirectory-filter project_subdir \
    --prune-empty -- \
    --all

10.4 Download a sub-directory from a git tree
   This works for GitHub at least. I think anything running git-svn?

   Heinous hack
    1. replace tree/master => trunk
    2. svn co the new URL
$> svn co https://github.com/buckyroberts/Source-Code-from-Tutorials/trunk/Python

11 Deleting all tags
$> git tag -l | xargs -I %% git push -v origin :refs/tags/%%
$> git tag -l | xargs git tag -d && git fetch -t

12 Conventions
   Many possible workflows are feasible with git. Large teams often have elaborate conventions for what
   to name branches and who gets to merge what with whom. Here are some I have seen in the wild:
     * Conventional Commits
     * Trunk-based Development
     * GitHub flow (which is not the same as gitflow)

   Some of these systems have associated helpers, see next.

13 Helpers
   Git has various layers of abstraction, from a very basic infrastructure of plumbing, through
   notionally use-friendly, higher-level porcelain commands which are supposed by authors of git to be
   user friendly but universally regarded as "a passable first attempt at best", through to various
   helper commands that ease various workflows and pain points.

13.1 git-worktree
     * Git Worktrees and GitButler
     * Git - git-worktree Documentation

13.2 git-branchless
   arxanas/git-branchless: Branchless workflow for Git

     The branchless workflow is designed for use in a repository with a single main branch that all
     commits are rebased onto. It improves developer velocity by encouraging fast and frequent commits,
     and helps developers operate on these commits fearlessly.

     In the branchless workflow, the commits you're working on are inferred based on your activity, so
     you no longer need branches to keep track of them. Nonetheless, branches are sometimes convenient,
     and git-branchless fully supports them. If you prefer, you can continue to use your normal
     workflow and benefit from features like git sl or git undo without going entirely branchless.

13.3 git-undo
   Also: git undo: We can do better

     How is it so easy to "lose" your data in a system that's supposed to never lose your data?

     Well, it's not that it's too easy to lose your data - but rather, that it's too difficult to
     recover it. For each operation you want to recover from, there's a different "magic" incantation
     to undo it. All the data is still there in principle, but it's not accessible to many in practice.

     ...To address this problem, I offer git undo

13.4 gerrit
   Gerrit is a code review system for git.

13.5 legit
   legit simplifies feature branch workflows.

13.6 rerere
   Not repeating yourself during merges/rebases? git rerere automates this:
$> git config --global rerere.enabled true
$> git config --global rerere.autoupdate true

14 Importing some files across a branch
$> git checkout my_branch -- my_file/

15 Garbage collecting
   In brief, this will purge a lot of stuff from a constipated repo in emergencies:
$> git reflog expire --expire=now --all && git gc --prune=now

16 Editing history
16.1 Cleaning out all big files

   bfg does that:
$> git clone --mirror git://example.com/some-big-repo.git
$> cd some-big-repo.git
$> git repack
$> bfg --strip-blobs-bigger-than 10M .
$> git reflog expire --expire=now --all && git gc --prune=now --aggressive
$> git push -f

16.2 Deleting specific things
   I think bfg also does this. There is also native support:
$> git filter-branch -f --index-filter 'git rm -r --cached --ignore-unmatch unwanted_files'

16.3 Exporting a minimal history from some repository
   i.e. Exporting a branch for a client/collaborator, which they should still operate on in git, but
   which does not contain all the potentially proprietary stuff in the main repo. Ideally they should
   see one commit with no history.

   If the merge history is clean, there is no need to be fancy; if I have a branch which has never
   merged in any secret information then I can just push it to a new repository and it won't bring along
   any of the secret stuff.

   OTOH, research code is often unhygienic and chaotic, so we might need to be more careful.

   Option 0: Export a tarball and then forget about git:
$> git archive HEAD --format=zip > archive.zip

16.3.1 Option 1: squash the whole thing onto a single commit.
   I don't know a faster way of doing this than the classic:
$> git checkout -b temp_branch
$> git rebase --root -i

   Addendum: possibly this bash hack is superior?
$> git reset $(git commit-tree HEAD^{tree} -m "A new start")

16.3.2 Option 2: create an orphan branch and copy the files over
   Here is an example.
$> git checkout --orphan temp_branch
$> git add -A
$> git commit -am "Initial commit"
$> git branch -D master
$> git branch -m master
$> git push -f origin master

   Merging with branches created this way can be tedious, however.

16.3.3 Option 3: Serendipitous orphan
   create an orphaned commit that exactly matches an existing commit:
$> TREE=`git cat-file -p master |sed '1,/^$/s/^tree //p;d;'`
$> COMMIT=`echo Truncated tree | git commit-tree $TREE`
$> git branch truncated-master $COMMIT
$> git branch backup-master-just-in-case-i-regret-it-later master
$> git push -f origin truncated-master:master

   I think this possibly allows us to easily cherry-pick commits against the new tree and return to the
   original.

17 Making git work with a broken-permission FS
   e.g. you are editing a git repo on NTFS via Linux and things are silly.
$> git config core.filemode false

18 Detecting if there are changes to commit
   Thomas Nyman:
if output=$(git status --porcelain) && [ -z "$output" ]; then
	# Working directory clean
else
	# Uncommitted changes
fi

19 Emergency commit
   Oh crap I'm leaving the office in a hurry and I just need to get my work into git ASAP for continuing
   on another computer. I don't care about sensible commit messages because I am on my own private
   branch and no-one else will see them when I squash the pull request.

   I put this little script in a file called gitbang to automate this case.
#!/usr/bin/env bash
# I'm leaving the office. Capture all changes in my private branch and push to server.
#!/usr/bin/env bash

if output=$(git status --porcelain) && [ -z "$output" ]; then
	echo "nothing to commit"
else
	git add --all && git commit -m bang
fi

# Determine branch to use: either first argument or default to current branch's upstream
branch=${1:-$(git rev-parse --abbrev-ref --symbolic-full-name "@{u}" 2>/dev/null | sed 's|^.*/||')}

# If upstream wasn't set and no argument provided, fall back to local current branch
if [ -z "$branch" ]; then
	branch=$(git rev-parse --abbrev-ref HEAD)
fi

git pull origin "$branch" \
	&& git submodule update --init --recursive \
	&& git push origin HEAD:"$branch"

   Pro tip: if you use VS code there is a feature called Cloud Changes that synchronises your
   changes to the cloud, so you can pick up where you left off on another computer without arsing about
   with git, it seems.

20 Git hosting
     * Github is the gorilla of git hosting
     * Gitlab has open-source and self-hosted options as well as a cloud offering
     * Codeberg is a gitea host

   One doesn't need to use a git hosting service at all, it's just convenient to have a pre-arranged
   central meeting place. A classic way to avoid the need for such a host is...

21 git email workflows
   Learn to use email with git.

22 Content-specific diffing
   Tools such as git-latexdiff provide custom diffing for, in this case, LaTeX code. These
   need to be found on a case-by-case basis.

23 SSH credentials
   Managing SSH credentials in git is non-obvious. See SSH.

24 Jupyter
   For sanity in git+jupyter, see jupyter.

25 Decent GUIs
   See Git GUIs.

26 Which repo am I in?
   For fish and bash shell, see bash-git-prompt.

27 Data versioning
   See data versioning.

28 Incoming
     * Trying to convince academics to use git - Juulia Suvilehto
     * The Universe of Discourse: I wish people would stop insisting that Git branches are nothing
       but refs


---
[**1]
https://blog.plover.com/prog/git/tips.html

Things I wish everyone knew about Git (Part I)
Wed, 29 Jun 2022

   This is a writeup of a talk I gave in December for my previous employer. It's long so I'm
   publishing it in several parts:
     * Part I (you are here):
          + How to approach Git; general strategy
          + Read Git From the Bottom Up
     * Part II: (coming later)
          + It is really hard to lose stuff
          + But what if you do lose something?
          + Finding old stuff with git-reflog
          + What if you can't find it?
          + What if you regret something you did?
          + Git leaves a trail
          + A few things can be lost forever!
          + git-rev-parse
     * More coming later still:
          + Branches are fictitious
          + Committing partial changes
          + Push and fetch; tracking branches
          + Aliases and custom commands

How to approach Git; general strategy
   Git has an elegant and powerful underlying model based on a few simple concepts:
    1. Commits are immutable snapshots of the repository
    2. Branches are named sequences of commits
    3. Every object has a unique ID, derived from its content

   literal dumpster fire
   The command set wasn't always well thought out, and then over the years it grew by accretion, with
   new stuff piled on top of old stuff that couldn't be changed because Backward Compatibility. The
   commands are non-orthogonal and when two commands perform the same task they often have inconsistent
   options or are described with different terminology. Even when the individual commands don't conflict
   with one another, they are often badly-designed and confusing. The documentation is often very
   poorly written.

  What this means
   With a lot of software, you can opt to use it at a surface level without understanding it at a deeper
   level:

                                   "I don't need to know how it works.
                               I just want to know which commands to run."

   This is often an effective strategy, but

                                       with Git, this does not work.

   You can't "just know which commands to run" because the commands do not make sense!

   To work effectively with Git, you must have a model of what the repository is like, so that you can
   formulate questions like "is the repo on this state or that state?" and "the repo is in this state,
   how do I get it into that state?". At that point you look around for a command that answers your
   question, and there are probably several ways to do what you want.

   But if you try to understand the commands without the model, you will suffer, because the commands do
   not make sense.

   Just a few examples:
     * git-reset does up to three different things, depending on flags
     * git-checkout is worse
     * The opposite of git-push is not git-pull, it's git-fetch
     * etc.

   If you try to understand the commands without a clear idea of the model, you'll be perpetually
   confused about what is happening and why, and you won't know what questions to ask to find out what
   is going on.

READ THIS
   When I first used Git it drove me almost to tears of rage and frustration. But I did get it under
   control. I don't love Git, but I use it every day, by choice, and I use it effectively.

   The magic key that rescued me was

                                            John Wiegley's
                                          Git From the Bottom Up

   Git From the Bottom Up explains the model. I read it. After that I wept no more. I understood what
   was going on. I knew how to try things out and how to interpret what I saw. Even when I got a
   surprise, I had a model to fit it into.

   You should read it too.

   That's the best advice I have. Read Wiegley's explanation. Set aside time to go over it carefully and
   try out his examples. It fixed me.

   If I were going to tell every programmer just one thing about Git, that would be it.

   The rest of this series is all downhill from here.

   But if I were going to tell everyone just one more thing, it would be:

                                 It is very hard to permanently lose work.
                            If something seems to have gone wrong, don't panic.
                                      Remain calm and ask an expert.


---
[**2]
https://blog.plover.com/prog/git/tips-2.html

Things I wish everyone knew about Git (Part II)
Wed, 06 Jul 2022

   This is a writeup of a talk I gave in December for my previous employer. It's long so I'm
   publishing it in several parts:
     * Part I:
          + How to approach Git; general strategy
          + Read Git From the Bottom Up
     * Part II (you are here):
          + It is really hard to lose stuff
          + But what if you do lose something?
          + Finding old stuff with git-reflog
          + What if you can't find it?
          + What if you regret something you did?
          + Git leaves a trail
          + A few things can be lost forever!
          + git-rev-parse
     * More coming later:
          + Branches are fictitious
          + Committing partial changes
          + Push and fetch; tracking branches
          + Aliases and custom commands

   The most important material is in [**1]Part I.

It is really hard to lose stuff
   A Git repository is an append-only filesystem. You can add snapshots of files and directories, but
   you can't modify or delete anything. Git commands sometimes purport to modify data. For example git
   commit --amend suggests that it amends a commit. It doesn't. There is no such thing as amending a
   commit; commits are immutable.

   Rather, it writes a completely new commit, and then kinda turns its back on the old one. But the old
   commit is still in there, pristine, forever.

   In a Git repository you can lose things, in the sense of forgetting where they are. But they can
   almost always be found again, one way or another, and when you find them they will be exactly the
   same as they were before. If you git commit --amend and change your mind later, it's not hard to get
   the old ⸢unamended⸣ commit back if you want it for some reason.
     * If you have the SHA for a file, it will always be the exact same version of the file with the
       exact same contents.
     * If you have the SHA for a directory (a "tree" in Git jargon) it will always contain the exact
       same versions of the exact same files with the exact same names.
     * If you have the SHA for a commit, it will always contain the exact same metainformation
       (description, when made, by whom, etc.) and the exact same snapshot of the entire file tree.

   Objects can have other names and descriptions that come and go, but the SHA is forever.

   (There's a small qualification to this: if the SHA is the only way to refer to a certain object, if
   it has no other names, and if you haven't used it for a few months, Git might discard it from the
   repository entirely.)

  But what if you do lose something?
   There are many good answers to this question but I think the one to know first is git-reflog, because
   it covers the great majority of cases.

   The git-reflog command means:

                          "List the SHAs of commits I have visited recently"

   When I run git reflog the top of the output says what commits I had checked out at recently, with the
   top line being the commit I have checked out right now:
    523e9fa1 HEAD@{0}: checkout: moving from dev to pasha
    5c31648d HEAD@{1}: pull: Fast-forward
    07053923 HEAD@{2}: checkout: moving from pr2323 to dev
    ...

   The last thing I did was check out the branch named pasha; its tip commit is at 523e9f1a.

   Before that, I did git pull and Git updated my local dev branch from the remote one, updating it to
   5c31648d.

   Before that, I had switched to dev from a different branch, pr2323. At that time, before the pull,
   dev referred to commit 07053923.

   Farther down in the output are some commits I visited last August:
    ...
    58ec94f6 HEAD@{928}: pull --rebase origin dev: checkout 58ec94f6d6cb375e09e29a7a6f904e3b3c552772
    e0cfbaee HEAD@{929}: commit: WIP: model classes for condensedPlate and condensedRNAPlate
    f8d17671 HEAD@{930}: commit: Unskip tests that depend on standard seed data
    31137c90 HEAD@{931}: commit (amend): migrate pedigree tests into test/pedigree
    a4a2431a HEAD@{932}: commit: migrate pedigree tests into test/pedigree
    1fe585cb HEAD@{933}: checkout: moving from LAB-808-dao-transaction-test-mode to LAB-815-pedigree-extension
s
    ...

   Flux capacitor (magic time-travel doohickey) from "Back to the Future"

   Suppose I'm caught in some horrible Git nightmare. Maybe I deleted the entire test suite or
   accidentally put my Small Wonder fanfic into a commit message or overwrote the report templates with
   150 gigabytes of goat porn. I can go back to how things were before. I look in the reflog for the SHA
   of the commit just before I made my big blunder, and then:
    git reset --hard 881f53fa

   Phew, it was just a bad dream.

   (Of course, if my colleagues actually saw the goat porn, it can't fix that.)

   I would like to nominate Wile E. Coyote to be the mascot of Git. Because Wile E. is always
   getting himself into situations like this one:

   Wile E., a cartoon coyote has just fired a shotgun at Bugs Bunny. For some reason the shotgun
   has fired backwards and blown his face off, as Git sometimes does.

   But then, in the next scene, he is magically unharmed. That's Git.

  Finding old stuff with git-reflog
     * git reflog by itself lists the places that HEAD has been
     * git reflog some-branch lists the places that some-branch has been
     * That HEAD@{1} thing in the reflog output is another way to name that commit if you don't want to
       use the SHA.
     * You can abbreviate it to just @{1}.
     * The following locutions can be used with any git command that wants you to identify a commit:
          + @{17} (HEAD as it was 17 actions ago)
          + @{18:43} (HEAD as it was at 18:43 today)
          + @{yesterday} (HEAD as it was 24 hours ago)
          + dev@{'3 days ago'} (dev as it was 3 days ago)
          + some-branch@{'Aug 22'} (some-branch as it was last August 22)
       (Use with git-checkout, git-reset, git-show, git-diff, etc.)
     * Also useful:
git show dev@{'Aug 22'}:path/to/some/file.txt

       "Print out that file, as it was on dev, as dev was on August 22"

   It's all still in there.

  What if you can't find it?
   Don't panic! Someone with more experience can probably find it for you. If you have a local Git
   expert, ask them for help.

   And if they are busy and can't help you immediately, the thing you're looking for won't disappear
   while you wait for them. The repository is append-only. Every version of everything is saved. If they
   could have found it today, they will still be able to find it tomorrow.

   (Git will eventually throw away lost and unused snapshots, but typically not anything you have used
   in the last 90 days.)

What if you regret something you did?
   Don't panic! It can probably put it back the way it was.

  Git leaves a trail
   When you make a commit, Git prints something like this:
    your-topic-branch 4e86fa23 Rework foozle subsystem

   If you need to find that commit again, the SHA 4e86fa23 is in your terminal scrollback.

   When you fetch a remote branch, Git prints:
       6e8fab43..bea7535b  dev        -> origin/dev

   What commit was origin/dev before the fetch? At 6e8fab43. What commit is it now? bea7535b.

   What if you want to look at how it was before? No problem, 6e8fab43 is still there. It's not called
   origin/dev any more, but the SHA is forever. You can still check it out and look at it:
    git checkout -b how-it-was-before 6e8fab43

   What if you want to compare how it was with how it is now?
    git log 6e8fab43..bea7535b
    git show 6e8fab43..bea7535b
    git diff 6e8fab43..bea7535b

   Git tries to leave a trail of breadcrumbs in your terminal. It's constantly printing out SHAs that
   you might want again.

A few things can be lost forever!
   After all that talk about how Git will not lose things, I should point out the exceptions. The big
   exception is that if you have created files or made changes in the working tree, Git is unaware of
   them until you have added them with git-add. Until then, those changes are in the working tree but
   not in the repository, and if you discard them Git cannot help you get them back.

   Good advice is Commit early and often. If you don't commit, at least add changes with git-add. Files
   added but not committed are saved in the repository, although they can be hard to find because
   they haven't been packaged into a commit with a single SHA id.

   Some people automate this: they have a process that runs every few minutes and commits the current
   working tree to a special branch that they look at only in case of disaster.

     The dangerous commands are git-reset and git-checkout

   which modify the working tree, and so might wipe out changes that aren't in the repository. Git will
   try to warn you before doing something destructive to your working tree changes.

  git-rev-parse
   We saw a little while ago that Git's language for talking about commits and files is quite
   sophisticated:
            my-topic-branch@{'Aug 22'}:path/to/some/file.txt

   Where is this language documented? Maybe not where you would expect: it's in the manual for
   git-rev-parse.

   The git rev-parse command is less well-known than it should be. It takes a description of some object
   and turns it into a SHA. Why is that useful? Maybe not, but

     The git-rev-parse man page explains the syntax of the descriptions Git understands.

   A good habit is to skim over the manual every few months. You'll pick up something new and useful
   every time.

   My favorite is that if you use the syntax :/foozle you get the most recent commit on the current
   branch whose message mentions foozle. For example:
$> git show :/foozle

   or
$> git log :/introduce..:/remove

   Coming next week (probably), a few miscellaneous matters about using Git more effectively.


---
[**3]
https://www.liip.ch/en/blog/git-tips-tricks

Git : Tips & Tricks
11.12.2015

   Git is a really powerful tool but it can sometimes be hard to grasp some concepts and the way of
   doing some things is convoluted. In the following post, I'll try to list a few tips and tricks to
   make your life easier.

   Git is a really powerful tool but it can sometimes be hard to grasp some concepts and the way of
   doing some things is convoluted.

   In the following post, I'll try to list a few tips and tricks to make your life easier.

   Thanks to my colleagues and all the people on the Internet for those !

Ignore whitespace changes
   We start with probably the most known one : ignore whitespace when doing a diff. Some of you may know
   that it suffice to add ?w=1 to the github changes URL to start ignore whitespaces, you can do exactly
   the same on the command line by adding the -w argument to git :
$> git diff -w

   This will make code reviews a lot easier when you had to change the indentation of your code for
   example.

Delete whitespace changes
   In the same vein as the previous tip, there is also a way to stage only non-whitespace changed by
   running the following command :
$> git diff -w --no-color | git apply --cached --ignore-whitespace

   We first generate a diff without them, and disable colors to be on the safe side, and then apply this
   patch. After running this, you will have the changes staged and all the whitespace will be unstaged.
   You can clear them by running git checkout -- ..

   If you want to can add this to your git aliases to have a handy command :
$> git config --global alias.addnw "!sh -c 'git diff -w --no-color \"$@\" | q
	git apply --cached --ignore-whitespace' -"

Highlight word changes
   Github users will know that the exact change is highlighted there instead of just the whole line,
   this makes reviewing code easier. You can achieve the same thing on the command line multiple way.

   The easier one is to simply use the --word-diff=color argument :
$> git diff --word-diff=color

   You can even change the regex used to match words, for example, to add the comma as word separator,
   --word-diff-regex="[^[:space:],]+".

   There is also a bit more complicated way which leads to better result : using the the
   diff-highlight script shipped with git. The script is not available in all git installation, you
   may need to download it and put it somewhere on your hard drive. Once you have located the script,
   simply add the following to your configuration file :
$> git config --global core.pager '/path/to/diff-highlight | less'

   This will activate it for all commands, if you want to limit it to some only, you can configure each
   pager individually : pager.diff, pager.log, pager.show, pager.<cmd>.

Quickly see all tags
   git tag lists all tags, but does not really display useful informations. You can do a lot better with:
$> git log --decorate --oneline --simplify-by-decoration

   Or as an alias :
$> git config --global alias.releases 'log --decorate --oneline --simplify-by-decoration --all'

Graphical Log
   git log does not really convey information about merges, this is where the --graph attribute is
   coming handy. With some more tuning, it becomes this alias :
$> git config --global alias.graph 'log --graph --oneline --decorate --date-order --color --boundary --all'

   This alias is just a start, you can configure the output a lot more. For example see this
   StackOverflow answer:
   [http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs#answer-9074343]Pretty git branch graphs

Clean merged branches
   In most git workflow, you end up creating a lot of branches. Once they are merged in your master
   branch, they usually aren't useful anymore. You can easily list all branches merged in the current
   branch:
$> git branch --merged # local branches
$> git branch -r --merged # remote branches

   Here's how you can delete them :
$> # local branches
$> git branch --merged | grep -v "^\*" | xargs -n 1 git branch -d
$> # remote branches
$> git branch -r --merged | grep -v $(git rev-parse --abbrev-ref HEAD) | sed 's/origin\///' | \
	xargs -n 1 git push --delete origin

   Be careful running those. You can just display the branched that will be deleted by removing the last
   | and everything after.

   Once you've cleaned remote branches, you should advise everyone including you to run the following to
   cleanup any renmants of those branches :
$> git remote prune origin

   If you want more tips about git spring cleaning head to Git housekeeping tutorial

Package of your repository
   You can easily create archives of your repository with the archive command :
$> git archive -output=my_archive.zip master # zip version
$> git archive master | bzip2 > my_archive.tar.bz2# tar.bz2 version

   What is a little less known, is that archive will respect the export-ignore attribute in your
   .gitattributes file.

   As an added bonus, some packaging tools, like Composer, will also ignore those files when creating
   the package thus saving bandwidth and disk space for everyone.

Add only part of the changes
   How many times are you ready to commit some code only to realize that it would make a lot more sense
   if you could do it in multiple commits. It's pretty easy to do when you just want to separate changes
   made to different files, but you can also easily stage only part of the modifications done to a
   single file by using the -p switch.

   When running git add -p, git will ask you what to do with each "hunk" (or code part). It will
   interactively ask you what to do for each group of changes it detects in a file. At any time you can
   issue the ? to see all possible answers, the most used being :
     * y to stage this modification
     * n to keep this modification in the working copy
     * s to split the modification in smaller parts

Ignore modifications to a committed file
   It happens more often than not that you need to do some modifications on a file that you don't want
   committed. It maybe to change some configuration specific to your own environment or simply some
   debug code you use often.

   If the file you've modified is already committed, .gitignore will not help you and the modification
   will always show when running status or diff and you have the risk of accidentally commit it.

   You can use the update-index command to tell git to ignore changes made to a certain file like this :
$> git update-index --assume-unchanged path/to/my/file

   Be aware than any further change to this file will also be ignored by git. If you want to revert the
   "assume unchanged" status, simply run :
$> git update-index --no-assume-unchanged path/to/my/file

Diff contextual information
   Depending on the language you use, you eventually already saw that git tries to give you context
   information for each modification when doing a diff. This is called a hunk header and you can modify
   it to suites your need.

   Say we want to modifiy how PHP hunks are contextualized. First we need to specify the diff driver to
   use for PHP files in your .gitattributes file :
*.php diff=php

   For PHP this should suffice, because git already ships a corresponding diff driver. However, if you
   want to change the header anyway or add a new definition, add this in your .gitconfig :
[diff "phpf"]
xfuncname = "regex for my hunk""

   Git will then go backward from the modification and display the first line that matches the regex you
   configured. For more details, you can head to the official gitattributes documentation.

Easy commit fixup
   When working on a feature, it happens that you want to do a commit that fixes something you commited
   earlier. Sure you can simply commit and then do some rebase magic, but what if I told you there's a
   better way ?

   Say my history looks like this :
$> git log --oneline --decorate
xxxxxx3 (HEAD, feature-branch) third commit
xxxxxx2 second commit
xxxxxx1 first commit
xxxxxx0 (master) starting point

   If I want to fix something introduced in the second commit I can simply do :
$> git add .
$> git commit --fixup xxxxxx2
$> git log --oneline --decorate
xxxxxx4 (HEAD, feature-branch) fixup! second commit
xxxxxx3 third commit
xxxxxx2 second commit
xxxxxx1 first commit
xxxxxx0 (master) starting point

   Notice the fixup! prefix of the commit message ? Now git can use this information to automatically
   rebase your changes :
$> git rebase --interactive --autosquash master

   This will open an interactive rebase editor session like you are accustomed to, but your fixup commit
   will be automatically placed correctly in the list with the correct action :
pick xxxxxx1 first commit
pick xxxxxx2 second commit
fixup xxxxxx4 fixup! second commit
pick xxxxxx3 third commit

   Usually, it's now only a matter of accepting the rebase as is and tada !

   If you want to aleays autosquash you can simply add it to your config :
$> git config --global rebase.autosquash true

   I also defined some aliases to help :
fix = commit --fixup HEAD~1 # fixup the last commmit
fixup = commit --fixup # fixup a commit in the history (need a revision)
squash = commit --squash # squash a commit in the history (need a revision)
ri = rebase --interactive # interactive rebase

rerere : Reuse Recorded Resolution
   rerere is a feature of git that automatically records conflict resolution upon merges and is then
   able to reapply them automatically when the same conflicts arise again.

   I personnaly didn't find any usecase in my day to day job justifying the use of rerere, but the
   following Medium article can be of help to people having sharing the same workflow as the other :
   Fix conflicts only once with git rerere

The reflog : never loose a commit again
   History modification is great in some cases but can also lead to loosing some commits on your
   branches. Fear not, you can retrieve them.

   The git reflog command displays all action that were made on the working copy including all commits.
   Just find the lost commit in the list, copy its hash and then reapply it where ever you want by using
   the cherry-pick command.

   reflog is also a great command to use when you are wondering what the heck you could have done today ;)

Tig
   Tig is a console Git browser a bit like the GitHub client or Sourcetree but that works in any
   terminal. It is a great tool if you don't like the command line but still have to sometimes work over
   SSH on some servers.

   Describing the features would be out of scope from this blog post, so I'll just link you to the
   homepage : Tig.

Autocorrect commands
   If you often do typos when writing git commands, just do :
$> git config --global help.autocorrect 1

   Now git can autocorrect your errors for you :
$> git sttaus
WARNING: You called a Git command named 'sttaus', which does not exist.
Continuing under the assumption that you meant 'status'
in 0.1 seconds automatically...

Only blame on certain things
   Sometimes a coworker reindent some code or move some lines around or to a completely different files.
   When trying to understand the origin of some lines those kind of changes get of the way of using
   blame efficiently. Fortunately, git is so powerful that even that can't stop you :
$> git blame -w # ignore commits that only change white spaces
$> git blame -M # ignore commits that moved the lines in the same file
$> git blame -C # ignore commits that moved the lines from another file

   Be aware that this renders the command slower however.

Add comments to commmit
   Even wanted to add some comments to a commit ? It is possible with Git.

   However, the feature is not really usable, but it may be come in handy some times so here's the link
   to a nice blog post explaining everything : Note to Self.

Safer push force (Thanks Odi !)
   It shouldn't happen, but we all know how things are, sometimes you have to make a push --force on a
   branch. Let met tell you it can be a lot more secure using git push --force-with-lease. Using this
   option, Git will first check if the last commit you fetched from the remote is still the last one. If
   not, the push will be aborted, avoiding that you overwrite changes made by your co-workers !

   There's no shorthand for this command, but you can create an alias :
$> git config --global alias.pushf 'push --force-with-lease'

Final words
   Those are the tips and tricks I learned during the years I've been using Git. Some I use daily, some
   I just keep around for when the need arise. I hope those will be useful to you !

   If you find the list lacking, please feel free to add your own tips in the comments and I'll update
   the post with them !


---

